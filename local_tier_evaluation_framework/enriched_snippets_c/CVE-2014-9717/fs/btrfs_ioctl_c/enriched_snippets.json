[
  {
    "function_name": "btrfs_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "5198-5337",
    "snippet": "long btrfs_ioctl(struct file *file, unsigned int\n\t\tcmd, unsigned long arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tvoid __user *argp = (void __user *)arg;\n\n\tswitch (cmd) {\n\tcase FS_IOC_GETFLAGS:\n\t\treturn btrfs_ioctl_getflags(file, argp);\n\tcase FS_IOC_SETFLAGS:\n\t\treturn btrfs_ioctl_setflags(file, argp);\n\tcase FS_IOC_GETVERSION:\n\t\treturn btrfs_ioctl_getversion(file, argp);\n\tcase FITRIM:\n\t\treturn btrfs_ioctl_fitrim(file, argp);\n\tcase BTRFS_IOC_SNAP_CREATE:\n\t\treturn btrfs_ioctl_snap_create(file, argp, 0);\n\tcase BTRFS_IOC_SNAP_CREATE_V2:\n\t\treturn btrfs_ioctl_snap_create_v2(file, argp, 0);\n\tcase BTRFS_IOC_SUBVOL_CREATE:\n\t\treturn btrfs_ioctl_snap_create(file, argp, 1);\n\tcase BTRFS_IOC_SUBVOL_CREATE_V2:\n\t\treturn btrfs_ioctl_snap_create_v2(file, argp, 1);\n\tcase BTRFS_IOC_SNAP_DESTROY:\n\t\treturn btrfs_ioctl_snap_destroy(file, argp);\n\tcase BTRFS_IOC_SUBVOL_GETFLAGS:\n\t\treturn btrfs_ioctl_subvol_getflags(file, argp);\n\tcase BTRFS_IOC_SUBVOL_SETFLAGS:\n\t\treturn btrfs_ioctl_subvol_setflags(file, argp);\n\tcase BTRFS_IOC_DEFAULT_SUBVOL:\n\t\treturn btrfs_ioctl_default_subvol(file, argp);\n\tcase BTRFS_IOC_DEFRAG:\n\t\treturn btrfs_ioctl_defrag(file, NULL);\n\tcase BTRFS_IOC_DEFRAG_RANGE:\n\t\treturn btrfs_ioctl_defrag(file, argp);\n\tcase BTRFS_IOC_RESIZE:\n\t\treturn btrfs_ioctl_resize(file, argp);\n\tcase BTRFS_IOC_ADD_DEV:\n\t\treturn btrfs_ioctl_add_dev(root, argp);\n\tcase BTRFS_IOC_RM_DEV:\n\t\treturn btrfs_ioctl_rm_dev(file, argp);\n\tcase BTRFS_IOC_FS_INFO:\n\t\treturn btrfs_ioctl_fs_info(root, argp);\n\tcase BTRFS_IOC_DEV_INFO:\n\t\treturn btrfs_ioctl_dev_info(root, argp);\n\tcase BTRFS_IOC_BALANCE:\n\t\treturn btrfs_ioctl_balance(file, NULL);\n\tcase BTRFS_IOC_CLONE:\n\t\treturn btrfs_ioctl_clone(file, arg, 0, 0, 0);\n\tcase BTRFS_IOC_CLONE_RANGE:\n\t\treturn btrfs_ioctl_clone_range(file, argp);\n\tcase BTRFS_IOC_TRANS_START:\n\t\treturn btrfs_ioctl_trans_start(file);\n\tcase BTRFS_IOC_TRANS_END:\n\t\treturn btrfs_ioctl_trans_end(file);\n\tcase BTRFS_IOC_TREE_SEARCH:\n\t\treturn btrfs_ioctl_tree_search(file, argp);\n\tcase BTRFS_IOC_TREE_SEARCH_V2:\n\t\treturn btrfs_ioctl_tree_search_v2(file, argp);\n\tcase BTRFS_IOC_INO_LOOKUP:\n\t\treturn btrfs_ioctl_ino_lookup(file, argp);\n\tcase BTRFS_IOC_INO_PATHS:\n\t\treturn btrfs_ioctl_ino_to_path(root, argp);\n\tcase BTRFS_IOC_LOGICAL_INO:\n\t\treturn btrfs_ioctl_logical_to_ino(root, argp);\n\tcase BTRFS_IOC_SPACE_INFO:\n\t\treturn btrfs_ioctl_space_info(root, argp);\n\tcase BTRFS_IOC_SYNC: {\n\t\tint ret;\n\n\t\tret = btrfs_start_delalloc_roots(root->fs_info, 0, -1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = btrfs_sync_fs(file_inode(file)->i_sb, 1);\n\t\t/*\n\t\t * The transaction thread may want to do more work,\n\t\t * namely it pokes the cleaner ktread that will start\n\t\t * processing uncleaned subvols.\n\t\t */\n\t\twake_up_process(root->fs_info->transaction_kthread);\n\t\treturn ret;\n\t}\n\tcase BTRFS_IOC_START_SYNC:\n\t\treturn btrfs_ioctl_start_sync(root, argp);\n\tcase BTRFS_IOC_WAIT_SYNC:\n\t\treturn btrfs_ioctl_wait_sync(root, argp);\n\tcase BTRFS_IOC_SCRUB:\n\t\treturn btrfs_ioctl_scrub(file, argp);\n\tcase BTRFS_IOC_SCRUB_CANCEL:\n\t\treturn btrfs_ioctl_scrub_cancel(root, argp);\n\tcase BTRFS_IOC_SCRUB_PROGRESS:\n\t\treturn btrfs_ioctl_scrub_progress(root, argp);\n\tcase BTRFS_IOC_BALANCE_V2:\n\t\treturn btrfs_ioctl_balance(file, argp);\n\tcase BTRFS_IOC_BALANCE_CTL:\n\t\treturn btrfs_ioctl_balance_ctl(root, arg);\n\tcase BTRFS_IOC_BALANCE_PROGRESS:\n\t\treturn btrfs_ioctl_balance_progress(root, argp);\n\tcase BTRFS_IOC_SET_RECEIVED_SUBVOL:\n\t\treturn btrfs_ioctl_set_received_subvol(file, argp);\n#ifdef CONFIG_64BIT\n\tcase BTRFS_IOC_SET_RECEIVED_SUBVOL_32:\n\t\treturn btrfs_ioctl_set_received_subvol_32(file, argp);\n#endif\n\tcase BTRFS_IOC_SEND:\n\t\treturn btrfs_ioctl_send(file, argp);\n\tcase BTRFS_IOC_GET_DEV_STATS:\n\t\treturn btrfs_ioctl_get_dev_stats(root, argp);\n\tcase BTRFS_IOC_QUOTA_CTL:\n\t\treturn btrfs_ioctl_quota_ctl(file, argp);\n\tcase BTRFS_IOC_QGROUP_ASSIGN:\n\t\treturn btrfs_ioctl_qgroup_assign(file, argp);\n\tcase BTRFS_IOC_QGROUP_CREATE:\n\t\treturn btrfs_ioctl_qgroup_create(file, argp);\n\tcase BTRFS_IOC_QGROUP_LIMIT:\n\t\treturn btrfs_ioctl_qgroup_limit(file, argp);\n\tcase BTRFS_IOC_QUOTA_RESCAN:\n\t\treturn btrfs_ioctl_quota_rescan(file, argp);\n\tcase BTRFS_IOC_QUOTA_RESCAN_STATUS:\n\t\treturn btrfs_ioctl_quota_rescan_status(file, argp);\n\tcase BTRFS_IOC_QUOTA_RESCAN_WAIT:\n\t\treturn btrfs_ioctl_quota_rescan_wait(file, argp);\n\tcase BTRFS_IOC_DEV_REPLACE:\n\t\treturn btrfs_ioctl_dev_replace(root, argp);\n\tcase BTRFS_IOC_GET_FSLABEL:\n\t\treturn btrfs_ioctl_get_fslabel(file, argp);\n\tcase BTRFS_IOC_SET_FSLABEL:\n\t\treturn btrfs_ioctl_set_fslabel(file, argp);\n\tcase BTRFS_IOC_FILE_EXTENT_SAME:\n\t\treturn btrfs_ioctl_file_extent_same(file, argp);\n\tcase BTRFS_IOC_GET_SUPPORTED_FEATURES:\n\t\treturn btrfs_ioctl_get_supported_features(file, argp);\n\tcase BTRFS_IOC_GET_FEATURES:\n\t\treturn btrfs_ioctl_get_features(file, argp);\n\tcase BTRFS_IOC_SET_FEATURES:\n\t\treturn btrfs_ioctl_set_features(file, argp);\n\t}\n\n\treturn -ENOTTY;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define BTRFS_IOC_SET_RECEIVED_SUBVOL_32 _IOWR(BTRFS_IOCTL_MAGIC, 37, \\\n\t\t\t\tstruct btrfs_ioctl_received_subvol_args_32)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_ioctl_set_features",
          "args": [
            "file",
            "argp"
          ],
          "line": 5333
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_set_features",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "5139-5196",
          "snippet": "static int btrfs_ioctl_set_features(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tstruct btrfs_super_block *super_block = root->fs_info->super_copy;\n\tstruct btrfs_ioctl_feature_flags flags[2];\n\tstruct btrfs_trans_handle *trans;\n\tu64 newflags;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (copy_from_user(flags, arg, sizeof(flags)))\n\t\treturn -EFAULT;\n\n\t/* Nothing to do */\n\tif (!flags[0].compat_flags && !flags[0].compat_ro_flags &&\n\t    !flags[0].incompat_flags)\n\t\treturn 0;\n\n\tret = check_feature(root, flags[0].compat_flags,\n\t\t\t    flags[1].compat_flags, COMPAT);\n\tif (ret)\n\t\treturn ret;\n\n\tret = check_feature(root, flags[0].compat_ro_flags,\n\t\t\t    flags[1].compat_ro_flags, COMPAT_RO);\n\tif (ret)\n\t\treturn ret;\n\n\tret = check_feature(root, flags[0].incompat_flags,\n\t\t\t    flags[1].incompat_flags, INCOMPAT);\n\tif (ret)\n\t\treturn ret;\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\n\tspin_lock(&root->fs_info->super_lock);\n\tnewflags = btrfs_super_compat_flags(super_block);\n\tnewflags |= flags[0].compat_flags & flags[1].compat_flags;\n\tnewflags &= ~(flags[0].compat_flags & ~flags[1].compat_flags);\n\tbtrfs_set_super_compat_flags(super_block, newflags);\n\n\tnewflags = btrfs_super_compat_ro_flags(super_block);\n\tnewflags |= flags[0].compat_ro_flags & flags[1].compat_ro_flags;\n\tnewflags &= ~(flags[0].compat_ro_flags & ~flags[1].compat_ro_flags);\n\tbtrfs_set_super_compat_ro_flags(super_block, newflags);\n\n\tnewflags = btrfs_super_incompat_flags(super_block);\n\tnewflags |= flags[0].incompat_flags & flags[1].incompat_flags;\n\tnewflags &= ~(flags[0].incompat_flags & ~flags[1].incompat_flags);\n\tbtrfs_set_super_incompat_flags(super_block, newflags);\n\tspin_unlock(&root->fs_info->super_lock);\n\n\treturn btrfs_commit_transaction(trans, root);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_ioctl_set_features(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tstruct btrfs_super_block *super_block = root->fs_info->super_copy;\n\tstruct btrfs_ioctl_feature_flags flags[2];\n\tstruct btrfs_trans_handle *trans;\n\tu64 newflags;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (copy_from_user(flags, arg, sizeof(flags)))\n\t\treturn -EFAULT;\n\n\t/* Nothing to do */\n\tif (!flags[0].compat_flags && !flags[0].compat_ro_flags &&\n\t    !flags[0].incompat_flags)\n\t\treturn 0;\n\n\tret = check_feature(root, flags[0].compat_flags,\n\t\t\t    flags[1].compat_flags, COMPAT);\n\tif (ret)\n\t\treturn ret;\n\n\tret = check_feature(root, flags[0].compat_ro_flags,\n\t\t\t    flags[1].compat_ro_flags, COMPAT_RO);\n\tif (ret)\n\t\treturn ret;\n\n\tret = check_feature(root, flags[0].incompat_flags,\n\t\t\t    flags[1].incompat_flags, INCOMPAT);\n\tif (ret)\n\t\treturn ret;\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\n\tspin_lock(&root->fs_info->super_lock);\n\tnewflags = btrfs_super_compat_flags(super_block);\n\tnewflags |= flags[0].compat_flags & flags[1].compat_flags;\n\tnewflags &= ~(flags[0].compat_flags & ~flags[1].compat_flags);\n\tbtrfs_set_super_compat_flags(super_block, newflags);\n\n\tnewflags = btrfs_super_compat_ro_flags(super_block);\n\tnewflags |= flags[0].compat_ro_flags & flags[1].compat_ro_flags;\n\tnewflags &= ~(flags[0].compat_ro_flags & ~flags[1].compat_ro_flags);\n\tbtrfs_set_super_compat_ro_flags(super_block, newflags);\n\n\tnewflags = btrfs_super_incompat_flags(super_block);\n\tnewflags |= flags[0].incompat_flags & flags[1].incompat_flags;\n\tnewflags &= ~(flags[0].incompat_flags & ~flags[1].incompat_flags);\n\tbtrfs_set_super_incompat_flags(super_block, newflags);\n\tspin_unlock(&root->fs_info->super_lock);\n\n\treturn btrfs_commit_transaction(trans, root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_get_features",
          "args": [
            "file",
            "argp"
          ],
          "line": 5331
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_get_features",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "5058-5072",
          "snippet": "static int btrfs_ioctl_get_features(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tstruct btrfs_super_block *super_block = root->fs_info->super_copy;\n\tstruct btrfs_ioctl_feature_flags features;\n\n\tfeatures.compat_flags = btrfs_super_compat_flags(super_block);\n\tfeatures.compat_ro_flags = btrfs_super_compat_ro_flags(super_block);\n\tfeatures.incompat_flags = btrfs_super_incompat_flags(super_block);\n\n\tif (copy_to_user(arg, &features, sizeof(features)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_ioctl_get_features(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tstruct btrfs_super_block *super_block = root->fs_info->super_copy;\n\tstruct btrfs_ioctl_feature_flags features;\n\n\tfeatures.compat_flags = btrfs_super_compat_flags(super_block);\n\tfeatures.compat_ro_flags = btrfs_super_compat_ro_flags(super_block);\n\tfeatures.incompat_flags = btrfs_super_incompat_flags(super_block);\n\n\tif (copy_to_user(arg, &features, sizeof(features)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_get_supported_features",
          "args": [
            "file",
            "argp"
          ],
          "line": 5329
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_get_supported_features",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "5043-5056",
          "snippet": "static int btrfs_ioctl_get_supported_features(struct file *file,\n\t\t\t\t\t      void __user *arg)\n{\n\tstatic struct btrfs_ioctl_feature_flags features[3] = {\n\t\tINIT_FEATURE_FLAGS(SUPP),\n\t\tINIT_FEATURE_FLAGS(SAFE_SET),\n\t\tINIT_FEATURE_FLAGS(SAFE_CLEAR)\n\t};\n\n\tif (copy_to_user(arg, &features, sizeof(features)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_ioctl_get_supported_features(struct file *file,\n\t\t\t\t\t      void __user *arg)\n{\n\tstatic struct btrfs_ioctl_feature_flags features[3] = {\n\t\tINIT_FEATURE_FLAGS(SUPP),\n\t\tINIT_FEATURE_FLAGS(SAFE_SET),\n\t\tINIT_FEATURE_FLAGS(SAFE_CLEAR)\n\t};\n\n\tif (copy_to_user(arg, &features, sizeof(features)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_file_extent_same",
          "args": [
            "file",
            "argp"
          ],
          "line": 5327
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_file_extent_same",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "2929-3033",
          "snippet": "static long btrfs_ioctl_file_extent_same(struct file *file,\n\t\t\tstruct btrfs_ioctl_same_args __user *argp)\n{\n\tstruct btrfs_ioctl_same_args *same;\n\tstruct btrfs_ioctl_same_extent_info *info;\n\tstruct inode *src = file_inode(file);\n\tu64 off;\n\tu64 len;\n\tint i;\n\tint ret;\n\tunsigned long size;\n\tu64 bs = BTRFS_I(src)->root->fs_info->sb->s_blocksize;\n\tbool is_admin = capable(CAP_SYS_ADMIN);\n\tu16 count;\n\n\tif (!(file->f_mode & FMODE_READ))\n\t\treturn -EINVAL;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tif (get_user(count, &argp->dest_count)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tsize = offsetof(struct btrfs_ioctl_same_args __user, info[count]);\n\n\tsame = memdup_user(argp, size);\n\n\tif (IS_ERR(same)) {\n\t\tret = PTR_ERR(same);\n\t\tgoto out;\n\t}\n\n\toff = same->logical_offset;\n\tlen = same->length;\n\n\t/*\n\t * Limit the total length we will dedupe for each operation.\n\t * This is intended to bound the total time spent in this\n\t * ioctl to something sane.\n\t */\n\tif (len > BTRFS_MAX_DEDUPE_LEN)\n\t\tlen = BTRFS_MAX_DEDUPE_LEN;\n\n\tif (WARN_ON_ONCE(bs < PAGE_CACHE_SIZE)) {\n\t\t/*\n\t\t * Btrfs does not support blocksize < page_size. As a\n\t\t * result, btrfs_cmp_data() won't correctly handle\n\t\t * this situation without an update.\n\t\t */\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = -EISDIR;\n\tif (S_ISDIR(src->i_mode))\n\t\tgoto out;\n\n\tret = -EACCES;\n\tif (!S_ISREG(src->i_mode))\n\t\tgoto out;\n\n\t/* pre-format output fields to sane values */\n\tfor (i = 0; i < count; i++) {\n\t\tsame->info[i].bytes_deduped = 0ULL;\n\t\tsame->info[i].status = 0;\n\t}\n\n\tfor (i = 0, info = same->info; i < count; i++, info++) {\n\t\tstruct inode *dst;\n\t\tstruct fd dst_file = fdget(info->fd);\n\t\tif (!dst_file.file) {\n\t\t\tinfo->status = -EBADF;\n\t\t\tcontinue;\n\t\t}\n\t\tdst = file_inode(dst_file.file);\n\n\t\tif (!(is_admin || (dst_file.file->f_mode & FMODE_WRITE))) {\n\t\t\tinfo->status = -EINVAL;\n\t\t} else if (file->f_path.mnt != dst_file.file->f_path.mnt) {\n\t\t\tinfo->status = -EXDEV;\n\t\t} else if (S_ISDIR(dst->i_mode)) {\n\t\t\tinfo->status = -EISDIR;\n\t\t} else if (!S_ISREG(dst->i_mode)) {\n\t\t\tinfo->status = -EACCES;\n\t\t} else {\n\t\t\tinfo->status = btrfs_extent_same(src, off, len, dst,\n\t\t\t\t\t\t\tinfo->logical_offset);\n\t\t\tif (info->status == 0)\n\t\t\t\tinfo->bytes_deduped += len;\n\t\t}\n\t\tfdput(dst_file);\n\t}\n\n\tret = copy_to_user(argp, same, size);\n\tif (ret)\n\t\tret = -EFAULT;\n\nout:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define BTRFS_MAX_DEDUPE_LEN\t(16 * 1024 * 1024)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\n#define BTRFS_MAX_DEDUPE_LEN\t(16 * 1024 * 1024)\n\nstatic long btrfs_ioctl_file_extent_same(struct file *file,\n\t\t\tstruct btrfs_ioctl_same_args __user *argp)\n{\n\tstruct btrfs_ioctl_same_args *same;\n\tstruct btrfs_ioctl_same_extent_info *info;\n\tstruct inode *src = file_inode(file);\n\tu64 off;\n\tu64 len;\n\tint i;\n\tint ret;\n\tunsigned long size;\n\tu64 bs = BTRFS_I(src)->root->fs_info->sb->s_blocksize;\n\tbool is_admin = capable(CAP_SYS_ADMIN);\n\tu16 count;\n\n\tif (!(file->f_mode & FMODE_READ))\n\t\treturn -EINVAL;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tif (get_user(count, &argp->dest_count)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tsize = offsetof(struct btrfs_ioctl_same_args __user, info[count]);\n\n\tsame = memdup_user(argp, size);\n\n\tif (IS_ERR(same)) {\n\t\tret = PTR_ERR(same);\n\t\tgoto out;\n\t}\n\n\toff = same->logical_offset;\n\tlen = same->length;\n\n\t/*\n\t * Limit the total length we will dedupe for each operation.\n\t * This is intended to bound the total time spent in this\n\t * ioctl to something sane.\n\t */\n\tif (len > BTRFS_MAX_DEDUPE_LEN)\n\t\tlen = BTRFS_MAX_DEDUPE_LEN;\n\n\tif (WARN_ON_ONCE(bs < PAGE_CACHE_SIZE)) {\n\t\t/*\n\t\t * Btrfs does not support blocksize < page_size. As a\n\t\t * result, btrfs_cmp_data() won't correctly handle\n\t\t * this situation without an update.\n\t\t */\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = -EISDIR;\n\tif (S_ISDIR(src->i_mode))\n\t\tgoto out;\n\n\tret = -EACCES;\n\tif (!S_ISREG(src->i_mode))\n\t\tgoto out;\n\n\t/* pre-format output fields to sane values */\n\tfor (i = 0; i < count; i++) {\n\t\tsame->info[i].bytes_deduped = 0ULL;\n\t\tsame->info[i].status = 0;\n\t}\n\n\tfor (i = 0, info = same->info; i < count; i++, info++) {\n\t\tstruct inode *dst;\n\t\tstruct fd dst_file = fdget(info->fd);\n\t\tif (!dst_file.file) {\n\t\t\tinfo->status = -EBADF;\n\t\t\tcontinue;\n\t\t}\n\t\tdst = file_inode(dst_file.file);\n\n\t\tif (!(is_admin || (dst_file.file->f_mode & FMODE_WRITE))) {\n\t\t\tinfo->status = -EINVAL;\n\t\t} else if (file->f_path.mnt != dst_file.file->f_path.mnt) {\n\t\t\tinfo->status = -EXDEV;\n\t\t} else if (S_ISDIR(dst->i_mode)) {\n\t\t\tinfo->status = -EISDIR;\n\t\t} else if (!S_ISREG(dst->i_mode)) {\n\t\t\tinfo->status = -EACCES;\n\t\t} else {\n\t\t\tinfo->status = btrfs_extent_same(src, off, len, dst,\n\t\t\t\t\t\t\tinfo->logical_offset);\n\t\t\tif (info->status == 0)\n\t\t\t\tinfo->bytes_deduped += len;\n\t\t}\n\t\tfdput(dst_file);\n\t}\n\n\tret = copy_to_user(argp, same, size);\n\tif (ret)\n\t\tret = -EFAULT;\n\nout:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_set_fslabel",
          "args": [
            "file",
            "argp"
          ],
          "line": 5325
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_set_fslabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "4998-5036",
          "snippet": "static int btrfs_ioctl_set_fslabel(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tstruct btrfs_super_block *super_block = root->fs_info->super_copy;\n\tstruct btrfs_trans_handle *trans;\n\tchar label[BTRFS_LABEL_SIZE];\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (copy_from_user(label, arg, sizeof(label)))\n\t\treturn -EFAULT;\n\n\tif (strnlen(label, BTRFS_LABEL_SIZE) == BTRFS_LABEL_SIZE) {\n\t\tbtrfs_err(root->fs_info, \"unable to set label with more than %d bytes\",\n\t\t       BTRFS_LABEL_SIZE - 1);\n\t\treturn -EINVAL;\n\t}\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out_unlock;\n\t}\n\n\tspin_lock(&root->fs_info->super_lock);\n\tstrcpy(super_block->label, label);\n\tspin_unlock(&root->fs_info->super_lock);\n\tret = btrfs_commit_transaction(trans, root);\n\nout_unlock:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_ioctl_set_fslabel(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tstruct btrfs_super_block *super_block = root->fs_info->super_copy;\n\tstruct btrfs_trans_handle *trans;\n\tchar label[BTRFS_LABEL_SIZE];\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (copy_from_user(label, arg, sizeof(label)))\n\t\treturn -EFAULT;\n\n\tif (strnlen(label, BTRFS_LABEL_SIZE) == BTRFS_LABEL_SIZE) {\n\t\tbtrfs_err(root->fs_info, \"unable to set label with more than %d bytes\",\n\t\t       BTRFS_LABEL_SIZE - 1);\n\t\treturn -EINVAL;\n\t}\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out_unlock;\n\t}\n\n\tspin_lock(&root->fs_info->super_lock);\n\tstrcpy(super_block->label, label);\n\tspin_unlock(&root->fs_info->super_lock);\n\tret = btrfs_commit_transaction(trans, root);\n\nout_unlock:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_get_fslabel",
          "args": [
            "file",
            "argp"
          ],
          "line": 5323
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_get_fslabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "4975-4996",
          "snippet": "static int btrfs_ioctl_get_fslabel(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tsize_t len;\n\tint ret;\n\tchar label[BTRFS_LABEL_SIZE];\n\n\tspin_lock(&root->fs_info->super_lock);\n\tmemcpy(label, root->fs_info->super_copy->label, BTRFS_LABEL_SIZE);\n\tspin_unlock(&root->fs_info->super_lock);\n\n\tlen = strnlen(label, BTRFS_LABEL_SIZE);\n\n\tif (len == BTRFS_LABEL_SIZE) {\n\t\tbtrfs_warn(root->fs_info,\n\t\t\t\"label is too long, return the first %zu bytes\", --len);\n\t}\n\n\tret = copy_to_user(arg, label, len);\n\n\treturn ret ? -EFAULT : 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_ioctl_get_fslabel(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tsize_t len;\n\tint ret;\n\tchar label[BTRFS_LABEL_SIZE];\n\n\tspin_lock(&root->fs_info->super_lock);\n\tmemcpy(label, root->fs_info->super_copy->label, BTRFS_LABEL_SIZE);\n\tspin_unlock(&root->fs_info->super_lock);\n\n\tlen = strnlen(label, BTRFS_LABEL_SIZE);\n\n\tif (len == BTRFS_LABEL_SIZE) {\n\t\tbtrfs_warn(root->fs_info,\n\t\t\t\"label is too long, return the first %zu bytes\", --len);\n\t}\n\n\tret = copy_to_user(arg, label, len);\n\n\treturn ret ? -EFAULT : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_dev_replace",
          "args": [
            "root",
            "argp"
          ],
          "line": 5321
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_dev_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "4144-4190",
          "snippet": "static long btrfs_ioctl_dev_replace(struct btrfs_root *root, void __user *arg)\n{\n\tstruct btrfs_ioctl_dev_replace_args *p;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tp = memdup_user(arg, sizeof(*p));\n\tif (IS_ERR(p))\n\t\treturn PTR_ERR(p);\n\n\tswitch (p->cmd) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_CMD_START:\n\t\tif (root->fs_info->sb->s_flags & MS_RDONLY) {\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t\tif (atomic_xchg(\n\t\t\t&root->fs_info->mutually_exclusive_operation_running,\n\t\t\t1)) {\n\t\t\tret = BTRFS_ERROR_DEV_EXCL_RUN_IN_PROGRESS;\n\t\t} else {\n\t\t\tret = btrfs_dev_replace_start(root, p);\n\t\t\tatomic_set(\n\t\t\t &root->fs_info->mutually_exclusive_operation_running,\n\t\t\t 0);\n\t\t}\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_CMD_STATUS:\n\t\tbtrfs_dev_replace_status(root->fs_info, p);\n\t\tret = 0;\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_CMD_CANCEL:\n\t\tret = btrfs_dev_replace_cancel(root->fs_info, p);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (copy_to_user(arg, p, sizeof(*p)))\n\t\tret = -EFAULT;\nout:\n\tkfree(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_dev_replace(struct btrfs_root *root, void __user *arg)\n{\n\tstruct btrfs_ioctl_dev_replace_args *p;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tp = memdup_user(arg, sizeof(*p));\n\tif (IS_ERR(p))\n\t\treturn PTR_ERR(p);\n\n\tswitch (p->cmd) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_CMD_START:\n\t\tif (root->fs_info->sb->s_flags & MS_RDONLY) {\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t\tif (atomic_xchg(\n\t\t\t&root->fs_info->mutually_exclusive_operation_running,\n\t\t\t1)) {\n\t\t\tret = BTRFS_ERROR_DEV_EXCL_RUN_IN_PROGRESS;\n\t\t} else {\n\t\t\tret = btrfs_dev_replace_start(root, p);\n\t\t\tatomic_set(\n\t\t\t &root->fs_info->mutually_exclusive_operation_running,\n\t\t\t 0);\n\t\t}\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_CMD_STATUS:\n\t\tbtrfs_dev_replace_status(root->fs_info, p);\n\t\tret = 0;\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_CMD_CANCEL:\n\t\tret = btrfs_dev_replace_cancel(root->fs_info, p);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (copy_to_user(arg, p, sizeof(*p)))\n\t\tret = -EFAULT;\nout:\n\tkfree(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_quota_rescan_wait",
          "args": [
            "file",
            "argp"
          ],
          "line": 5319
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_quota_rescan_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "4795-4803",
          "snippet": "static long btrfs_ioctl_quota_rescan_wait(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\treturn btrfs_qgroup_wait_for_completion(root->fs_info);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_quota_rescan_wait(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\treturn btrfs_qgroup_wait_for_completion(root->fs_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_quota_rescan_status",
          "args": [
            "file",
            "argp"
          ],
          "line": 5317
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_quota_rescan_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "4770-4793",
          "snippet": "static long btrfs_ioctl_quota_rescan_status(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tstruct btrfs_ioctl_quota_rescan_args *qsa;\n\tint ret = 0;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tqsa = kzalloc(sizeof(*qsa), GFP_NOFS);\n\tif (!qsa)\n\t\treturn -ENOMEM;\n\n\tif (root->fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN) {\n\t\tqsa->flags = 1;\n\t\tqsa->progress = root->fs_info->qgroup_rescan_progress.objectid;\n\t}\n\n\tif (copy_to_user(arg, qsa, sizeof(*qsa)))\n\t\tret = -EFAULT;\n\n\tkfree(qsa);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_quota_rescan_status(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tstruct btrfs_ioctl_quota_rescan_args *qsa;\n\tint ret = 0;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tqsa = kzalloc(sizeof(*qsa), GFP_NOFS);\n\tif (!qsa)\n\t\treturn -ENOMEM;\n\n\tif (root->fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN) {\n\t\tqsa->flags = 1;\n\t\tqsa->progress = root->fs_info->qgroup_rescan_progress.objectid;\n\t}\n\n\tif (copy_to_user(arg, qsa, sizeof(*qsa)))\n\t\tret = -EFAULT;\n\n\tkfree(qsa);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_qgroup_limit",
          "args": [
            "file",
            "argp"
          ],
          "line": 5313
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_qgroup_limit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "4689-4735",
          "snippet": "static long btrfs_ioctl_qgroup_limit(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tstruct btrfs_ioctl_qgroup_limit_args *sa;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\tint err;\n\tu64 qgroupid;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tsa = memdup_user(arg, sizeof(*sa));\n\tif (IS_ERR(sa)) {\n\t\tret = PTR_ERR(sa);\n\t\tgoto drop_write;\n\t}\n\n\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out;\n\t}\n\n\tqgroupid = sa->qgroupid;\n\tif (!qgroupid) {\n\t\t/* take the current subvol as qgroup */\n\t\tqgroupid = root->root_key.objectid;\n\t}\n\n\t/* FIXME: check if the IDs really exist */\n\tret = btrfs_limit_qgroup(trans, root->fs_info, qgroupid, &sa->lim);\n\n\terr = btrfs_end_transaction(trans, root);\n\tif (err && !ret)\n\t\tret = err;\n\nout:\n\tkfree(sa);\ndrop_write:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_qgroup_limit(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tstruct btrfs_ioctl_qgroup_limit_args *sa;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\tint err;\n\tu64 qgroupid;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tsa = memdup_user(arg, sizeof(*sa));\n\tif (IS_ERR(sa)) {\n\t\tret = PTR_ERR(sa);\n\t\tgoto drop_write;\n\t}\n\n\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out;\n\t}\n\n\tqgroupid = sa->qgroupid;\n\tif (!qgroupid) {\n\t\t/* take the current subvol as qgroup */\n\t\tqgroupid = root->root_key.objectid;\n\t}\n\n\t/* FIXME: check if the IDs really exist */\n\tret = btrfs_limit_qgroup(trans, root->fs_info, qgroupid, &sa->lim);\n\n\terr = btrfs_end_transaction(trans, root);\n\tif (err && !ret)\n\t\tret = err;\n\nout:\n\tkfree(sa);\ndrop_write:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_qgroup_create",
          "args": [
            "file",
            "argp"
          ],
          "line": 5311
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_qgroup_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "4638-4687",
          "snippet": "static long btrfs_ioctl_qgroup_create(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tstruct btrfs_ioctl_qgroup_create_args *sa;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\tint err;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tsa = memdup_user(arg, sizeof(*sa));\n\tif (IS_ERR(sa)) {\n\t\tret = PTR_ERR(sa);\n\t\tgoto drop_write;\n\t}\n\n\tif (!sa->qgroupid) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out;\n\t}\n\n\t/* FIXME: check if the IDs really exist */\n\tif (sa->create) {\n\t\tret = btrfs_create_qgroup(trans, root->fs_info, sa->qgroupid,\n\t\t\t\t\t  NULL);\n\t} else {\n\t\tret = btrfs_remove_qgroup(trans, root->fs_info, sa->qgroupid);\n\t}\n\n\terr = btrfs_end_transaction(trans, root);\n\tif (err && !ret)\n\t\tret = err;\n\nout:\n\tkfree(sa);\ndrop_write:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_qgroup_create(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tstruct btrfs_ioctl_qgroup_create_args *sa;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\tint err;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tsa = memdup_user(arg, sizeof(*sa));\n\tif (IS_ERR(sa)) {\n\t\tret = PTR_ERR(sa);\n\t\tgoto drop_write;\n\t}\n\n\tif (!sa->qgroupid) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out;\n\t}\n\n\t/* FIXME: check if the IDs really exist */\n\tif (sa->create) {\n\t\tret = btrfs_create_qgroup(trans, root->fs_info, sa->qgroupid,\n\t\t\t\t\t  NULL);\n\t} else {\n\t\tret = btrfs_remove_qgroup(trans, root->fs_info, sa->qgroupid);\n\t}\n\n\terr = btrfs_end_transaction(trans, root);\n\tif (err && !ret)\n\t\tret = err;\n\nout:\n\tkfree(sa);\ndrop_write:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_qgroup_assign",
          "args": [
            "file",
            "argp"
          ],
          "line": 5309
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_qgroup_assign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "4591-4636",
          "snippet": "static long btrfs_ioctl_qgroup_assign(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tstruct btrfs_ioctl_qgroup_assign_args *sa;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\tint err;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tsa = memdup_user(arg, sizeof(*sa));\n\tif (IS_ERR(sa)) {\n\t\tret = PTR_ERR(sa);\n\t\tgoto drop_write;\n\t}\n\n\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out;\n\t}\n\n\t/* FIXME: check if the IDs really exist */\n\tif (sa->assign) {\n\t\tret = btrfs_add_qgroup_relation(trans, root->fs_info,\n\t\t\t\t\t\tsa->src, sa->dst);\n\t} else {\n\t\tret = btrfs_del_qgroup_relation(trans, root->fs_info,\n\t\t\t\t\t\tsa->src, sa->dst);\n\t}\n\n\terr = btrfs_end_transaction(trans, root);\n\tif (err && !ret)\n\t\tret = err;\n\nout:\n\tkfree(sa);\ndrop_write:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_qgroup_assign(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tstruct btrfs_ioctl_qgroup_assign_args *sa;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\tint err;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tsa = memdup_user(arg, sizeof(*sa));\n\tif (IS_ERR(sa)) {\n\t\tret = PTR_ERR(sa);\n\t\tgoto drop_write;\n\t}\n\n\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out;\n\t}\n\n\t/* FIXME: check if the IDs really exist */\n\tif (sa->assign) {\n\t\tret = btrfs_add_qgroup_relation(trans, root->fs_info,\n\t\t\t\t\t\tsa->src, sa->dst);\n\t} else {\n\t\tret = btrfs_del_qgroup_relation(trans, root->fs_info,\n\t\t\t\t\t\tsa->src, sa->dst);\n\t}\n\n\terr = btrfs_end_transaction(trans, root);\n\tif (err && !ret)\n\t\tret = err;\n\nout:\n\tkfree(sa);\ndrop_write:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_quota_ctl",
          "args": [
            "file",
            "argp"
          ],
          "line": 5307
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_quota_ctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "4540-4589",
          "snippet": "static long btrfs_ioctl_quota_ctl(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tstruct btrfs_ioctl_quota_ctl_args *sa;\n\tstruct btrfs_trans_handle *trans = NULL;\n\tint ret;\n\tint err;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tsa = memdup_user(arg, sizeof(*sa));\n\tif (IS_ERR(sa)) {\n\t\tret = PTR_ERR(sa);\n\t\tgoto drop_write;\n\t}\n\n\tdown_write(&root->fs_info->subvol_sem);\n\ttrans = btrfs_start_transaction(root->fs_info->tree_root, 2);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out;\n\t}\n\n\tswitch (sa->cmd) {\n\tcase BTRFS_QUOTA_CTL_ENABLE:\n\t\tret = btrfs_quota_enable(trans, root->fs_info);\n\t\tbreak;\n\tcase BTRFS_QUOTA_CTL_DISABLE:\n\t\tret = btrfs_quota_disable(trans, root->fs_info);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\terr = btrfs_commit_transaction(trans, root->fs_info->tree_root);\n\tif (err && !ret)\n\t\tret = err;\nout:\n\tkfree(sa);\n\tup_write(&root->fs_info->subvol_sem);\ndrop_write:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_quota_ctl(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tstruct btrfs_ioctl_quota_ctl_args *sa;\n\tstruct btrfs_trans_handle *trans = NULL;\n\tint ret;\n\tint err;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tsa = memdup_user(arg, sizeof(*sa));\n\tif (IS_ERR(sa)) {\n\t\tret = PTR_ERR(sa);\n\t\tgoto drop_write;\n\t}\n\n\tdown_write(&root->fs_info->subvol_sem);\n\ttrans = btrfs_start_transaction(root->fs_info->tree_root, 2);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out;\n\t}\n\n\tswitch (sa->cmd) {\n\tcase BTRFS_QUOTA_CTL_ENABLE:\n\t\tret = btrfs_quota_enable(trans, root->fs_info);\n\t\tbreak;\n\tcase BTRFS_QUOTA_CTL_DISABLE:\n\t\tret = btrfs_quota_disable(trans, root->fs_info);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\terr = btrfs_commit_transaction(trans, root->fs_info->tree_root);\n\tif (err && !ret)\n\t\tret = err;\nout:\n\tkfree(sa);\n\tup_write(&root->fs_info->subvol_sem);\ndrop_write:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_get_dev_stats",
          "args": [
            "root",
            "argp"
          ],
          "line": 5305
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_get_dev_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "4120-4142",
          "snippet": "static long btrfs_ioctl_get_dev_stats(struct btrfs_root *root,\n\t\t\t\t      void __user *arg)\n{\n\tstruct btrfs_ioctl_get_dev_stats *sa;\n\tint ret;\n\n\tsa = memdup_user(arg, sizeof(*sa));\n\tif (IS_ERR(sa))\n\t\treturn PTR_ERR(sa);\n\n\tif ((sa->flags & BTRFS_DEV_STATS_RESET) && !capable(CAP_SYS_ADMIN)) {\n\t\tkfree(sa);\n\t\treturn -EPERM;\n\t}\n\n\tret = btrfs_get_dev_stats(root, sa);\n\n\tif (copy_to_user(arg, sa, sizeof(*sa)))\n\t\tret = -EFAULT;\n\n\tkfree(sa);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_get_dev_stats(struct btrfs_root *root,\n\t\t\t\t      void __user *arg)\n{\n\tstruct btrfs_ioctl_get_dev_stats *sa;\n\tint ret;\n\n\tsa = memdup_user(arg, sizeof(*sa));\n\tif (IS_ERR(sa))\n\t\treturn PTR_ERR(sa);\n\n\tif ((sa->flags & BTRFS_DEV_STATS_RESET) && !capable(CAP_SYS_ADMIN)) {\n\t\tkfree(sa);\n\t\treturn -EPERM;\n\t}\n\n\tret = btrfs_get_dev_stats(root, sa);\n\n\tif (copy_to_user(arg, sa, sizeof(*sa)))\n\t\tret = -EFAULT;\n\n\tkfree(sa);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_send",
          "args": [
            "file",
            "argp"
          ],
          "line": 5303
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "5708-6003",
          "snippet": "long btrfs_ioctl_send(struct file *mnt_file, void __user *arg_)\n{\n\tint ret = 0;\n\tstruct btrfs_root *send_root;\n\tstruct btrfs_root *clone_root;\n\tstruct btrfs_fs_info *fs_info;\n\tstruct btrfs_ioctl_send_args *arg = NULL;\n\tstruct btrfs_key key;\n\tstruct send_ctx *sctx = NULL;\n\tu32 i;\n\tu64 *clone_sources_tmp = NULL;\n\tint clone_sources_to_rollback = 0;\n\tint sort_clone_roots = 0;\n\tint index;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tsend_root = BTRFS_I(file_inode(mnt_file))->root;\n\tfs_info = send_root->fs_info;\n\n\t/*\n\t * The subvolume must remain read-only during send, protect against\n\t * making it RW. This also protects against deletion.\n\t */\n\tspin_lock(&send_root->root_item_lock);\n\tsend_root->send_in_progress++;\n\tspin_unlock(&send_root->root_item_lock);\n\n\t/*\n\t * This is done when we lookup the root, it should already be complete\n\t * by the time we get here.\n\t */\n\tWARN_ON(send_root->orphan_cleanup_state != ORPHAN_CLEANUP_DONE);\n\n\t/*\n\t * Userspace tools do the checks and warn the user if it's\n\t * not RO.\n\t */\n\tif (!btrfs_root_readonly(send_root)) {\n\t\tret = -EPERM;\n\t\tgoto out;\n\t}\n\n\targ = memdup_user(arg_, sizeof(*arg));\n\tif (IS_ERR(arg)) {\n\t\tret = PTR_ERR(arg);\n\t\targ = NULL;\n\t\tgoto out;\n\t}\n\n\tif (!access_ok(VERIFY_READ, arg->clone_sources,\n\t\t\tsizeof(*arg->clone_sources) *\n\t\t\targ->clone_sources_count)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (arg->flags & ~BTRFS_SEND_FLAG_MASK) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tsctx = kzalloc(sizeof(struct send_ctx), GFP_NOFS);\n\tif (!sctx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tINIT_LIST_HEAD(&sctx->new_refs);\n\tINIT_LIST_HEAD(&sctx->deleted_refs);\n\tINIT_RADIX_TREE(&sctx->name_cache, GFP_NOFS);\n\tINIT_LIST_HEAD(&sctx->name_cache_list);\n\n\tsctx->flags = arg->flags;\n\n\tsctx->send_filp = fget(arg->send_fd);\n\tif (!sctx->send_filp) {\n\t\tret = -EBADF;\n\t\tgoto out;\n\t}\n\n\tsctx->send_root = send_root;\n\t/*\n\t * Unlikely but possible, if the subvolume is marked for deletion but\n\t * is slow to remove the directory entry, send can still be started\n\t */\n\tif (btrfs_root_dead(sctx->send_root)) {\n\t\tret = -EPERM;\n\t\tgoto out;\n\t}\n\n\tsctx->clone_roots_cnt = arg->clone_sources_count;\n\n\tsctx->send_max_size = BTRFS_SEND_BUF_SIZE;\n\tsctx->send_buf = vmalloc(sctx->send_max_size);\n\tif (!sctx->send_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsctx->read_buf = vmalloc(BTRFS_SEND_READ_SIZE);\n\tif (!sctx->read_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsctx->pending_dir_moves = RB_ROOT;\n\tsctx->waiting_dir_moves = RB_ROOT;\n\tsctx->orphan_dirs = RB_ROOT;\n\n\tsctx->clone_roots = vzalloc(sizeof(struct clone_root) *\n\t\t\t(arg->clone_sources_count + 1));\n\tif (!sctx->clone_roots) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (arg->clone_sources_count) {\n\t\tclone_sources_tmp = vmalloc(arg->clone_sources_count *\n\t\t\t\tsizeof(*arg->clone_sources));\n\t\tif (!clone_sources_tmp) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = copy_from_user(clone_sources_tmp, arg->clone_sources,\n\t\t\t\targ->clone_sources_count *\n\t\t\t\tsizeof(*arg->clone_sources));\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = 0; i < arg->clone_sources_count; i++) {\n\t\t\tkey.objectid = clone_sources_tmp[i];\n\t\t\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\t\t\tkey.offset = (u64)-1;\n\n\t\t\tindex = srcu_read_lock(&fs_info->subvol_srcu);\n\n\t\t\tclone_root = btrfs_read_fs_root_no_name(fs_info, &key);\n\t\t\tif (IS_ERR(clone_root)) {\n\t\t\t\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\t\t\t\tret = PTR_ERR(clone_root);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tclone_sources_to_rollback = i + 1;\n\t\t\tspin_lock(&clone_root->root_item_lock);\n\t\t\tclone_root->send_in_progress++;\n\t\t\tif (!btrfs_root_readonly(clone_root)) {\n\t\t\t\tspin_unlock(&clone_root->root_item_lock);\n\t\t\t\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\t\t\t\tret = -EPERM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tspin_unlock(&clone_root->root_item_lock);\n\t\t\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\n\t\t\tsctx->clone_roots[i].root = clone_root;\n\t\t}\n\t\tvfree(clone_sources_tmp);\n\t\tclone_sources_tmp = NULL;\n\t}\n\n\tif (arg->parent_root) {\n\t\tkey.objectid = arg->parent_root;\n\t\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\t\tkey.offset = (u64)-1;\n\n\t\tindex = srcu_read_lock(&fs_info->subvol_srcu);\n\n\t\tsctx->parent_root = btrfs_read_fs_root_no_name(fs_info, &key);\n\t\tif (IS_ERR(sctx->parent_root)) {\n\t\t\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\t\t\tret = PTR_ERR(sctx->parent_root);\n\t\t\tgoto out;\n\t\t}\n\n\t\tspin_lock(&sctx->parent_root->root_item_lock);\n\t\tsctx->parent_root->send_in_progress++;\n\t\tif (!btrfs_root_readonly(sctx->parent_root) ||\n\t\t\t\tbtrfs_root_dead(sctx->parent_root)) {\n\t\t\tspin_unlock(&sctx->parent_root->root_item_lock);\n\t\t\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\t\t\tret = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock(&sctx->parent_root->root_item_lock);\n\n\t\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\t}\n\n\t/*\n\t * Clones from send_root are allowed, but only if the clone source\n\t * is behind the current send position. This is checked while searching\n\t * for possible clone sources.\n\t */\n\tsctx->clone_roots[sctx->clone_roots_cnt++].root = sctx->send_root;\n\n\t/* We do a bsearch later */\n\tsort(sctx->clone_roots, sctx->clone_roots_cnt,\n\t\t\tsizeof(*sctx->clone_roots), __clone_root_cmp_sort,\n\t\t\tNULL);\n\tsort_clone_roots = 1;\n\n\tret = ensure_commit_roots_uptodate(sctx);\n\tif (ret)\n\t\tgoto out;\n\n\tcurrent->journal_info = BTRFS_SEND_TRANS_STUB;\n\tret = send_subvol(sctx);\n\tcurrent->journal_info = NULL;\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (!(sctx->flags & BTRFS_SEND_FLAG_OMIT_END_CMD)) {\n\t\tret = begin_cmd(sctx, BTRFS_SEND_C_END);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = send_cmd(sctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\tWARN_ON(sctx && !ret && !RB_EMPTY_ROOT(&sctx->pending_dir_moves));\n\twhile (sctx && !RB_EMPTY_ROOT(&sctx->pending_dir_moves)) {\n\t\tstruct rb_node *n;\n\t\tstruct pending_dir_move *pm;\n\n\t\tn = rb_first(&sctx->pending_dir_moves);\n\t\tpm = rb_entry(n, struct pending_dir_move, node);\n\t\twhile (!list_empty(&pm->list)) {\n\t\t\tstruct pending_dir_move *pm2;\n\n\t\t\tpm2 = list_first_entry(&pm->list,\n\t\t\t\t\t       struct pending_dir_move, list);\n\t\t\tfree_pending_move(sctx, pm2);\n\t\t}\n\t\tfree_pending_move(sctx, pm);\n\t}\n\n\tWARN_ON(sctx && !ret && !RB_EMPTY_ROOT(&sctx->waiting_dir_moves));\n\twhile (sctx && !RB_EMPTY_ROOT(&sctx->waiting_dir_moves)) {\n\t\tstruct rb_node *n;\n\t\tstruct waiting_dir_move *dm;\n\n\t\tn = rb_first(&sctx->waiting_dir_moves);\n\t\tdm = rb_entry(n, struct waiting_dir_move, node);\n\t\trb_erase(&dm->node, &sctx->waiting_dir_moves);\n\t\tkfree(dm);\n\t}\n\n\tWARN_ON(sctx && !ret && !RB_EMPTY_ROOT(&sctx->orphan_dirs));\n\twhile (sctx && !RB_EMPTY_ROOT(&sctx->orphan_dirs)) {\n\t\tstruct rb_node *n;\n\t\tstruct orphan_dir_info *odi;\n\n\t\tn = rb_first(&sctx->orphan_dirs);\n\t\todi = rb_entry(n, struct orphan_dir_info, node);\n\t\tfree_orphan_dir_info(sctx, odi);\n\t}\n\n\tif (sort_clone_roots) {\n\t\tfor (i = 0; i < sctx->clone_roots_cnt; i++)\n\t\t\tbtrfs_root_dec_send_in_progress(\n\t\t\t\t\tsctx->clone_roots[i].root);\n\t} else {\n\t\tfor (i = 0; sctx && i < clone_sources_to_rollback; i++)\n\t\t\tbtrfs_root_dec_send_in_progress(\n\t\t\t\t\tsctx->clone_roots[i].root);\n\n\t\tbtrfs_root_dec_send_in_progress(send_root);\n\t}\n\tif (sctx && !IS_ERR_OR_NULL(sctx->parent_root))\n\t\tbtrfs_root_dec_send_in_progress(sctx->parent_root);\n\n\tkfree(arg);\n\tvfree(clone_sources_tmp);\n\n\tif (sctx) {\n\t\tif (sctx->send_filp)\n\t\t\tfput(sctx->send_filp);\n\n\t\tvfree(sctx->clone_roots);\n\t\tvfree(sctx->send_buf);\n\t\tvfree(sctx->read_buf);\n\n\t\tname_cache_free(sctx);\n\n\t\tkfree(sctx);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nlong btrfs_ioctl_send(struct file *mnt_file, void __user *arg_)\n{\n\tint ret = 0;\n\tstruct btrfs_root *send_root;\n\tstruct btrfs_root *clone_root;\n\tstruct btrfs_fs_info *fs_info;\n\tstruct btrfs_ioctl_send_args *arg = NULL;\n\tstruct btrfs_key key;\n\tstruct send_ctx *sctx = NULL;\n\tu32 i;\n\tu64 *clone_sources_tmp = NULL;\n\tint clone_sources_to_rollback = 0;\n\tint sort_clone_roots = 0;\n\tint index;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tsend_root = BTRFS_I(file_inode(mnt_file))->root;\n\tfs_info = send_root->fs_info;\n\n\t/*\n\t * The subvolume must remain read-only during send, protect against\n\t * making it RW. This also protects against deletion.\n\t */\n\tspin_lock(&send_root->root_item_lock);\n\tsend_root->send_in_progress++;\n\tspin_unlock(&send_root->root_item_lock);\n\n\t/*\n\t * This is done when we lookup the root, it should already be complete\n\t * by the time we get here.\n\t */\n\tWARN_ON(send_root->orphan_cleanup_state != ORPHAN_CLEANUP_DONE);\n\n\t/*\n\t * Userspace tools do the checks and warn the user if it's\n\t * not RO.\n\t */\n\tif (!btrfs_root_readonly(send_root)) {\n\t\tret = -EPERM;\n\t\tgoto out;\n\t}\n\n\targ = memdup_user(arg_, sizeof(*arg));\n\tif (IS_ERR(arg)) {\n\t\tret = PTR_ERR(arg);\n\t\targ = NULL;\n\t\tgoto out;\n\t}\n\n\tif (!access_ok(VERIFY_READ, arg->clone_sources,\n\t\t\tsizeof(*arg->clone_sources) *\n\t\t\targ->clone_sources_count)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (arg->flags & ~BTRFS_SEND_FLAG_MASK) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tsctx = kzalloc(sizeof(struct send_ctx), GFP_NOFS);\n\tif (!sctx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tINIT_LIST_HEAD(&sctx->new_refs);\n\tINIT_LIST_HEAD(&sctx->deleted_refs);\n\tINIT_RADIX_TREE(&sctx->name_cache, GFP_NOFS);\n\tINIT_LIST_HEAD(&sctx->name_cache_list);\n\n\tsctx->flags = arg->flags;\n\n\tsctx->send_filp = fget(arg->send_fd);\n\tif (!sctx->send_filp) {\n\t\tret = -EBADF;\n\t\tgoto out;\n\t}\n\n\tsctx->send_root = send_root;\n\t/*\n\t * Unlikely but possible, if the subvolume is marked for deletion but\n\t * is slow to remove the directory entry, send can still be started\n\t */\n\tif (btrfs_root_dead(sctx->send_root)) {\n\t\tret = -EPERM;\n\t\tgoto out;\n\t}\n\n\tsctx->clone_roots_cnt = arg->clone_sources_count;\n\n\tsctx->send_max_size = BTRFS_SEND_BUF_SIZE;\n\tsctx->send_buf = vmalloc(sctx->send_max_size);\n\tif (!sctx->send_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsctx->read_buf = vmalloc(BTRFS_SEND_READ_SIZE);\n\tif (!sctx->read_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsctx->pending_dir_moves = RB_ROOT;\n\tsctx->waiting_dir_moves = RB_ROOT;\n\tsctx->orphan_dirs = RB_ROOT;\n\n\tsctx->clone_roots = vzalloc(sizeof(struct clone_root) *\n\t\t\t(arg->clone_sources_count + 1));\n\tif (!sctx->clone_roots) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (arg->clone_sources_count) {\n\t\tclone_sources_tmp = vmalloc(arg->clone_sources_count *\n\t\t\t\tsizeof(*arg->clone_sources));\n\t\tif (!clone_sources_tmp) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = copy_from_user(clone_sources_tmp, arg->clone_sources,\n\t\t\t\targ->clone_sources_count *\n\t\t\t\tsizeof(*arg->clone_sources));\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = 0; i < arg->clone_sources_count; i++) {\n\t\t\tkey.objectid = clone_sources_tmp[i];\n\t\t\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\t\t\tkey.offset = (u64)-1;\n\n\t\t\tindex = srcu_read_lock(&fs_info->subvol_srcu);\n\n\t\t\tclone_root = btrfs_read_fs_root_no_name(fs_info, &key);\n\t\t\tif (IS_ERR(clone_root)) {\n\t\t\t\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\t\t\t\tret = PTR_ERR(clone_root);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tclone_sources_to_rollback = i + 1;\n\t\t\tspin_lock(&clone_root->root_item_lock);\n\t\t\tclone_root->send_in_progress++;\n\t\t\tif (!btrfs_root_readonly(clone_root)) {\n\t\t\t\tspin_unlock(&clone_root->root_item_lock);\n\t\t\t\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\t\t\t\tret = -EPERM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tspin_unlock(&clone_root->root_item_lock);\n\t\t\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\n\t\t\tsctx->clone_roots[i].root = clone_root;\n\t\t}\n\t\tvfree(clone_sources_tmp);\n\t\tclone_sources_tmp = NULL;\n\t}\n\n\tif (arg->parent_root) {\n\t\tkey.objectid = arg->parent_root;\n\t\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\t\tkey.offset = (u64)-1;\n\n\t\tindex = srcu_read_lock(&fs_info->subvol_srcu);\n\n\t\tsctx->parent_root = btrfs_read_fs_root_no_name(fs_info, &key);\n\t\tif (IS_ERR(sctx->parent_root)) {\n\t\t\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\t\t\tret = PTR_ERR(sctx->parent_root);\n\t\t\tgoto out;\n\t\t}\n\n\t\tspin_lock(&sctx->parent_root->root_item_lock);\n\t\tsctx->parent_root->send_in_progress++;\n\t\tif (!btrfs_root_readonly(sctx->parent_root) ||\n\t\t\t\tbtrfs_root_dead(sctx->parent_root)) {\n\t\t\tspin_unlock(&sctx->parent_root->root_item_lock);\n\t\t\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\t\t\tret = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock(&sctx->parent_root->root_item_lock);\n\n\t\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\t}\n\n\t/*\n\t * Clones from send_root are allowed, but only if the clone source\n\t * is behind the current send position. This is checked while searching\n\t * for possible clone sources.\n\t */\n\tsctx->clone_roots[sctx->clone_roots_cnt++].root = sctx->send_root;\n\n\t/* We do a bsearch later */\n\tsort(sctx->clone_roots, sctx->clone_roots_cnt,\n\t\t\tsizeof(*sctx->clone_roots), __clone_root_cmp_sort,\n\t\t\tNULL);\n\tsort_clone_roots = 1;\n\n\tret = ensure_commit_roots_uptodate(sctx);\n\tif (ret)\n\t\tgoto out;\n\n\tcurrent->journal_info = BTRFS_SEND_TRANS_STUB;\n\tret = send_subvol(sctx);\n\tcurrent->journal_info = NULL;\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (!(sctx->flags & BTRFS_SEND_FLAG_OMIT_END_CMD)) {\n\t\tret = begin_cmd(sctx, BTRFS_SEND_C_END);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = send_cmd(sctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\tWARN_ON(sctx && !ret && !RB_EMPTY_ROOT(&sctx->pending_dir_moves));\n\twhile (sctx && !RB_EMPTY_ROOT(&sctx->pending_dir_moves)) {\n\t\tstruct rb_node *n;\n\t\tstruct pending_dir_move *pm;\n\n\t\tn = rb_first(&sctx->pending_dir_moves);\n\t\tpm = rb_entry(n, struct pending_dir_move, node);\n\t\twhile (!list_empty(&pm->list)) {\n\t\t\tstruct pending_dir_move *pm2;\n\n\t\t\tpm2 = list_first_entry(&pm->list,\n\t\t\t\t\t       struct pending_dir_move, list);\n\t\t\tfree_pending_move(sctx, pm2);\n\t\t}\n\t\tfree_pending_move(sctx, pm);\n\t}\n\n\tWARN_ON(sctx && !ret && !RB_EMPTY_ROOT(&sctx->waiting_dir_moves));\n\twhile (sctx && !RB_EMPTY_ROOT(&sctx->waiting_dir_moves)) {\n\t\tstruct rb_node *n;\n\t\tstruct waiting_dir_move *dm;\n\n\t\tn = rb_first(&sctx->waiting_dir_moves);\n\t\tdm = rb_entry(n, struct waiting_dir_move, node);\n\t\trb_erase(&dm->node, &sctx->waiting_dir_moves);\n\t\tkfree(dm);\n\t}\n\n\tWARN_ON(sctx && !ret && !RB_EMPTY_ROOT(&sctx->orphan_dirs));\n\twhile (sctx && !RB_EMPTY_ROOT(&sctx->orphan_dirs)) {\n\t\tstruct rb_node *n;\n\t\tstruct orphan_dir_info *odi;\n\n\t\tn = rb_first(&sctx->orphan_dirs);\n\t\todi = rb_entry(n, struct orphan_dir_info, node);\n\t\tfree_orphan_dir_info(sctx, odi);\n\t}\n\n\tif (sort_clone_roots) {\n\t\tfor (i = 0; i < sctx->clone_roots_cnt; i++)\n\t\t\tbtrfs_root_dec_send_in_progress(\n\t\t\t\t\tsctx->clone_roots[i].root);\n\t} else {\n\t\tfor (i = 0; sctx && i < clone_sources_to_rollback; i++)\n\t\t\tbtrfs_root_dec_send_in_progress(\n\t\t\t\t\tsctx->clone_roots[i].root);\n\n\t\tbtrfs_root_dec_send_in_progress(send_root);\n\t}\n\tif (sctx && !IS_ERR_OR_NULL(sctx->parent_root))\n\t\tbtrfs_root_dec_send_in_progress(sctx->parent_root);\n\n\tkfree(arg);\n\tvfree(clone_sources_tmp);\n\n\tif (sctx) {\n\t\tif (sctx->send_filp)\n\t\t\tfput(sctx->send_filp);\n\n\t\tvfree(sctx->clone_roots);\n\t\tvfree(sctx->send_buf);\n\t\tvfree(sctx->read_buf);\n\n\t\tname_cache_free(sctx);\n\n\t\tkfree(sctx);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_set_received_subvol_32",
          "args": [
            "file",
            "argp"
          ],
          "line": 5300
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_set_received_subvol_32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "4895-4945",
          "snippet": "static long btrfs_ioctl_set_received_subvol_32(struct file *file,\n\t\t\t\t\t\tvoid __user *arg)\n{\n\tstruct btrfs_ioctl_received_subvol_args_32 *args32 = NULL;\n\tstruct btrfs_ioctl_received_subvol_args *args64 = NULL;\n\tint ret = 0;\n\n\targs32 = memdup_user(arg, sizeof(*args32));\n\tif (IS_ERR(args32)) {\n\t\tret = PTR_ERR(args32);\n\t\targs32 = NULL;\n\t\tgoto out;\n\t}\n\n\targs64 = kmalloc(sizeof(*args64), GFP_NOFS);\n\tif (!args64) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmemcpy(args64->uuid, args32->uuid, BTRFS_UUID_SIZE);\n\targs64->stransid = args32->stransid;\n\targs64->rtransid = args32->rtransid;\n\targs64->stime.sec = args32->stime.sec;\n\targs64->stime.nsec = args32->stime.nsec;\n\targs64->rtime.sec = args32->rtime.sec;\n\targs64->rtime.nsec = args32->rtime.nsec;\n\targs64->flags = args32->flags;\n\n\tret = _btrfs_ioctl_set_received_subvol(file, args64);\n\tif (ret)\n\t\tgoto out;\n\n\tmemcpy(args32->uuid, args64->uuid, BTRFS_UUID_SIZE);\n\targs32->stransid = args64->stransid;\n\targs32->rtransid = args64->rtransid;\n\targs32->stime.sec = args64->stime.sec;\n\targs32->stime.nsec = args64->stime.nsec;\n\targs32->rtime.sec = args64->rtime.sec;\n\targs32->rtime.nsec = args64->rtime.nsec;\n\targs32->flags = args64->flags;\n\n\tret = copy_to_user(arg, args32, sizeof(*args32));\n\tif (ret)\n\t\tret = -EFAULT;\n\nout:\n\tkfree(args32);\n\tkfree(args64);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_set_received_subvol_32(struct file *file,\n\t\t\t\t\t\tvoid __user *arg)\n{\n\tstruct btrfs_ioctl_received_subvol_args_32 *args32 = NULL;\n\tstruct btrfs_ioctl_received_subvol_args *args64 = NULL;\n\tint ret = 0;\n\n\targs32 = memdup_user(arg, sizeof(*args32));\n\tif (IS_ERR(args32)) {\n\t\tret = PTR_ERR(args32);\n\t\targs32 = NULL;\n\t\tgoto out;\n\t}\n\n\targs64 = kmalloc(sizeof(*args64), GFP_NOFS);\n\tif (!args64) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmemcpy(args64->uuid, args32->uuid, BTRFS_UUID_SIZE);\n\targs64->stransid = args32->stransid;\n\targs64->rtransid = args32->rtransid;\n\targs64->stime.sec = args32->stime.sec;\n\targs64->stime.nsec = args32->stime.nsec;\n\targs64->rtime.sec = args32->rtime.sec;\n\targs64->rtime.nsec = args32->rtime.nsec;\n\targs64->flags = args32->flags;\n\n\tret = _btrfs_ioctl_set_received_subvol(file, args64);\n\tif (ret)\n\t\tgoto out;\n\n\tmemcpy(args32->uuid, args64->uuid, BTRFS_UUID_SIZE);\n\targs32->stransid = args64->stransid;\n\targs32->rtransid = args64->rtransid;\n\targs32->stime.sec = args64->stime.sec;\n\targs32->stime.nsec = args64->stime.nsec;\n\targs32->rtime.sec = args64->rtime.sec;\n\targs32->rtime.nsec = args64->rtime.nsec;\n\targs32->flags = args64->flags;\n\n\tret = copy_to_user(arg, args32, sizeof(*args32));\n\tif (ret)\n\t\tret = -EFAULT;\n\nout:\n\tkfree(args32);\n\tkfree(args64);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_set_received_subvol",
          "args": [
            "file",
            "argp"
          ],
          "line": 5297
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_set_received_subvol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "4948-4973",
          "snippet": "static long btrfs_ioctl_set_received_subvol(struct file *file,\n\t\t\t\t\t    void __user *arg)\n{\n\tstruct btrfs_ioctl_received_subvol_args *sa = NULL;\n\tint ret = 0;\n\n\tsa = memdup_user(arg, sizeof(*sa));\n\tif (IS_ERR(sa)) {\n\t\tret = PTR_ERR(sa);\n\t\tsa = NULL;\n\t\tgoto out;\n\t}\n\n\tret = _btrfs_ioctl_set_received_subvol(file, sa);\n\n\tif (ret)\n\t\tgoto out;\n\n\tret = copy_to_user(arg, sa, sizeof(*sa));\n\tif (ret)\n\t\tret = -EFAULT;\n\nout:\n\tkfree(sa);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_set_received_subvol(struct file *file,\n\t\t\t\t\t    void __user *arg)\n{\n\tstruct btrfs_ioctl_received_subvol_args *sa = NULL;\n\tint ret = 0;\n\n\tsa = memdup_user(arg, sizeof(*sa));\n\tif (IS_ERR(sa)) {\n\t\tret = PTR_ERR(sa);\n\t\tsa = NULL;\n\t\tgoto out;\n\t}\n\n\tret = _btrfs_ioctl_set_received_subvol(file, sa);\n\n\tif (ret)\n\t\tgoto out;\n\n\tret = copy_to_user(arg, sa, sizeof(*sa));\n\tif (ret)\n\t\tret = -EFAULT;\n\nout:\n\tkfree(sa);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_balance_progress",
          "args": [
            "root",
            "argp"
          ],
          "line": 5295
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_balance_progress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "4507-4538",
          "snippet": "static long btrfs_ioctl_balance_progress(struct btrfs_root *root,\n\t\t\t\t\t void __user *arg)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_ioctl_balance_args *bargs;\n\tint ret = 0;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tmutex_lock(&fs_info->balance_mutex);\n\tif (!fs_info->balance_ctl) {\n\t\tret = -ENOTCONN;\n\t\tgoto out;\n\t}\n\n\tbargs = kzalloc(sizeof(*bargs), GFP_NOFS);\n\tif (!bargs) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tupdate_ioctl_balance_args(fs_info, 1, bargs);\n\n\tif (copy_to_user(arg, bargs, sizeof(*bargs)))\n\t\tret = -EFAULT;\n\n\tkfree(bargs);\nout:\n\tmutex_unlock(&fs_info->balance_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_balance_progress(struct btrfs_root *root,\n\t\t\t\t\t void __user *arg)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_ioctl_balance_args *bargs;\n\tint ret = 0;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tmutex_lock(&fs_info->balance_mutex);\n\tif (!fs_info->balance_ctl) {\n\t\tret = -ENOTCONN;\n\t\tgoto out;\n\t}\n\n\tbargs = kzalloc(sizeof(*bargs), GFP_NOFS);\n\tif (!bargs) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tupdate_ioctl_balance_args(fs_info, 1, bargs);\n\n\tif (copy_to_user(arg, bargs, sizeof(*bargs)))\n\t\tret = -EFAULT;\n\n\tkfree(bargs);\nout:\n\tmutex_unlock(&fs_info->balance_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_balance_ctl",
          "args": [
            "root",
            "arg"
          ],
          "line": 5293
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_balance_ctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "4492-4505",
          "snippet": "static long btrfs_ioctl_balance_ctl(struct btrfs_root *root, int cmd)\n{\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tswitch (cmd) {\n\tcase BTRFS_BALANCE_CTL_PAUSE:\n\t\treturn btrfs_pause_balance(root->fs_info);\n\tcase BTRFS_BALANCE_CTL_CANCEL:\n\t\treturn btrfs_cancel_balance(root->fs_info);\n\t}\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_balance_ctl(struct btrfs_root *root, int cmd)\n{\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tswitch (cmd) {\n\tcase BTRFS_BALANCE_CTL_PAUSE:\n\t\treturn btrfs_pause_balance(root->fs_info);\n\tcase BTRFS_BALANCE_CTL_CANCEL:\n\t\treturn btrfs_cancel_balance(root->fs_info);\n\t}\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_scrub_progress",
          "args": [
            "root",
            "argp"
          ],
          "line": 5289
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_scrub_progress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "4098-4118",
          "snippet": "static long btrfs_ioctl_scrub_progress(struct btrfs_root *root,\n\t\t\t\t       void __user *arg)\n{\n\tstruct btrfs_ioctl_scrub_args *sa;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tsa = memdup_user(arg, sizeof(*sa));\n\tif (IS_ERR(sa))\n\t\treturn PTR_ERR(sa);\n\n\tret = btrfs_scrub_progress(root, sa->devid, &sa->progress);\n\n\tif (copy_to_user(arg, sa, sizeof(*sa)))\n\t\tret = -EFAULT;\n\n\tkfree(sa);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_scrub_progress(struct btrfs_root *root,\n\t\t\t\t       void __user *arg)\n{\n\tstruct btrfs_ioctl_scrub_args *sa;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tsa = memdup_user(arg, sizeof(*sa));\n\tif (IS_ERR(sa))\n\t\treturn PTR_ERR(sa);\n\n\tret = btrfs_scrub_progress(root, sa->devid, &sa->progress);\n\n\tif (copy_to_user(arg, sa, sizeof(*sa)))\n\t\tret = -EFAULT;\n\n\tkfree(sa);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_scrub_cancel",
          "args": [
            "root",
            "argp"
          ],
          "line": 5287
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_scrub_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "4090-4096",
          "snippet": "static long btrfs_ioctl_scrub_cancel(struct btrfs_root *root, void __user *arg)\n{\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\treturn btrfs_scrub_cancel(root->fs_info);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_scrub_cancel(struct btrfs_root *root, void __user *arg)\n{\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\treturn btrfs_scrub_cancel(root->fs_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_wait_sync",
          "args": [
            "root",
            "argp"
          ],
          "line": 5283
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_wait_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "4043-4055",
          "snippet": "static noinline long btrfs_ioctl_wait_sync(struct btrfs_root *root,\n\t\t\t\t\t   void __user *argp)\n{\n\tu64 transid;\n\n\tif (argp) {\n\t\tif (copy_from_user(&transid, argp, sizeof(transid)))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\ttransid = 0;  /* current trans */\n\t}\n\treturn btrfs_wait_for_commit(root, transid);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic noinline long btrfs_ioctl_wait_sync(struct btrfs_root *root,\n\t\t\t\t\t   void __user *argp)\n{\n\tu64 transid;\n\n\tif (argp) {\n\t\tif (copy_from_user(&transid, argp, sizeof(transid)))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\ttransid = 0;  /* current trans */\n\t}\n\treturn btrfs_wait_for_commit(root, transid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_start_sync",
          "args": [
            "root",
            "argp"
          ],
          "line": 5281
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_start_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "4014-4041",
          "snippet": "static noinline long btrfs_ioctl_start_sync(struct btrfs_root *root,\n\t\t\t\t\t    void __user *argp)\n{\n\tstruct btrfs_trans_handle *trans;\n\tu64 transid;\n\tint ret;\n\n\ttrans = btrfs_attach_transaction_barrier(root);\n\tif (IS_ERR(trans)) {\n\t\tif (PTR_ERR(trans) != -ENOENT)\n\t\t\treturn PTR_ERR(trans);\n\n\t\t/* No running transaction, don't bother */\n\t\ttransid = root->fs_info->last_trans_committed;\n\t\tgoto out;\n\t}\n\ttransid = trans->transid;\n\tret = btrfs_commit_transaction_async(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\nout:\n\tif (argp)\n\t\tif (copy_to_user(argp, &transid, sizeof(transid)))\n\t\t\treturn -EFAULT;\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic noinline long btrfs_ioctl_start_sync(struct btrfs_root *root,\n\t\t\t\t\t    void __user *argp)\n{\n\tstruct btrfs_trans_handle *trans;\n\tu64 transid;\n\tint ret;\n\n\ttrans = btrfs_attach_transaction_barrier(root);\n\tif (IS_ERR(trans)) {\n\t\tif (PTR_ERR(trans) != -ENOENT)\n\t\t\treturn PTR_ERR(trans);\n\n\t\t/* No running transaction, don't bother */\n\t\ttransid = root->fs_info->last_trans_committed;\n\t\tgoto out;\n\t}\n\ttransid = trans->transid;\n\tret = btrfs_commit_transaction_async(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\nout:\n\tif (argp)\n\t\tif (copy_to_user(argp, &transid, sizeof(transid)))\n\t\t\treturn -EFAULT;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "root->fs_info->transaction_kthread"
          ],
          "line": 5277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_sync_fs",
          "args": [
            "file_inode(file)->i_sb",
            "1"
          ],
          "line": 5271
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_sync_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "978-1019",
          "snippet": "int btrfs_sync_fs(struct super_block *sb, int wait)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(sb);\n\tstruct btrfs_root *root = fs_info->tree_root;\n\n\ttrace_btrfs_sync_fs(wait);\n\n\tif (!wait) {\n\t\tfilemap_flush(fs_info->btree_inode->i_mapping);\n\t\treturn 0;\n\t}\n\n\tbtrfs_wait_ordered_roots(fs_info, -1);\n\n\ttrans = btrfs_attach_transaction_barrier(root);\n\tif (IS_ERR(trans)) {\n\t\t/* no transaction, don't bother */\n\t\tif (PTR_ERR(trans) == -ENOENT) {\n\t\t\t/*\n\t\t\t * Exit unless we have some pending changes\n\t\t\t * that need to go through commit\n\t\t\t */\n\t\t\tif (fs_info->pending_changes == 0)\n\t\t\t\treturn 0;\n\t\t\t/*\n\t\t\t * A non-blocking test if the fs is frozen. We must not\n\t\t\t * start a new transaction here otherwise a deadlock\n\t\t\t * happens. The pending operations are delayed to the\n\t\t\t * next commit after thawing.\n\t\t\t */\n\t\t\tif (__sb_start_write(sb, SB_FREEZE_WRITE, false))\n\t\t\t\t__sb_end_write(sb, SB_FREEZE_WRITE);\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t\ttrans = btrfs_start_transaction(root, 0);\n\t\t}\n\t\tif (IS_ERR(trans))\n\t\t\treturn PTR_ERR(trans);\n\t}\n\treturn btrfs_commit_transaction(trans, root);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nint btrfs_sync_fs(struct super_block *sb, int wait)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(sb);\n\tstruct btrfs_root *root = fs_info->tree_root;\n\n\ttrace_btrfs_sync_fs(wait);\n\n\tif (!wait) {\n\t\tfilemap_flush(fs_info->btree_inode->i_mapping);\n\t\treturn 0;\n\t}\n\n\tbtrfs_wait_ordered_roots(fs_info, -1);\n\n\ttrans = btrfs_attach_transaction_barrier(root);\n\tif (IS_ERR(trans)) {\n\t\t/* no transaction, don't bother */\n\t\tif (PTR_ERR(trans) == -ENOENT) {\n\t\t\t/*\n\t\t\t * Exit unless we have some pending changes\n\t\t\t * that need to go through commit\n\t\t\t */\n\t\t\tif (fs_info->pending_changes == 0)\n\t\t\t\treturn 0;\n\t\t\t/*\n\t\t\t * A non-blocking test if the fs is frozen. We must not\n\t\t\t * start a new transaction here otherwise a deadlock\n\t\t\t * happens. The pending operations are delayed to the\n\t\t\t * next commit after thawing.\n\t\t\t */\n\t\t\tif (__sb_start_write(sb, SB_FREEZE_WRITE, false))\n\t\t\t\t__sb_end_write(sb, SB_FREEZE_WRITE);\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t\ttrans = btrfs_start_transaction(root, 0);\n\t\t}\n\t\tif (IS_ERR(trans))\n\t\t\treturn PTR_ERR(trans);\n\t}\n\treturn btrfs_commit_transaction(trans, root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 5271
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_start_delalloc_roots",
          "args": [
            "root->fs_info",
            "0",
            "-1"
          ],
          "line": 5268
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_delalloc_roots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "9228-9282",
          "snippet": "int btrfs_start_delalloc_roots(struct btrfs_fs_info *fs_info, int delay_iput,\n\t\t\t       int nr)\n{\n\tstruct btrfs_root *root;\n\tstruct list_head splice;\n\tint ret;\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state))\n\t\treturn -EROFS;\n\n\tINIT_LIST_HEAD(&splice);\n\n\tmutex_lock(&fs_info->delalloc_root_mutex);\n\tspin_lock(&fs_info->delalloc_root_lock);\n\tlist_splice_init(&fs_info->delalloc_roots, &splice);\n\twhile (!list_empty(&splice) && nr) {\n\t\troot = list_first_entry(&splice, struct btrfs_root,\n\t\t\t\t\tdelalloc_root);\n\t\troot = btrfs_grab_fs_root(root);\n\t\tBUG_ON(!root);\n\t\tlist_move_tail(&root->delalloc_root,\n\t\t\t       &fs_info->delalloc_roots);\n\t\tspin_unlock(&fs_info->delalloc_root_lock);\n\n\t\tret = __start_delalloc_inodes(root, delay_iput, nr);\n\t\tbtrfs_put_fs_root(root);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (nr != -1) {\n\t\t\tnr -= ret;\n\t\t\tWARN_ON(nr < 0);\n\t\t}\n\t\tspin_lock(&fs_info->delalloc_root_lock);\n\t}\n\tspin_unlock(&fs_info->delalloc_root_lock);\n\n\tret = 0;\n\tatomic_inc(&fs_info->async_submit_draining);\n\twhile (atomic_read(&fs_info->nr_async_submits) ||\n\t      atomic_read(&fs_info->async_delalloc_pages)) {\n\t\twait_event(fs_info->async_submit_wait,\n\t\t   (atomic_read(&fs_info->nr_async_submits) == 0 &&\n\t\t    atomic_read(&fs_info->async_delalloc_pages) == 0));\n\t}\n\tatomic_dec(&fs_info->async_submit_draining);\nout:\n\tif (!list_empty_careful(&splice)) {\n\t\tspin_lock(&fs_info->delalloc_root_lock);\n\t\tlist_splice_tail(&splice, &fs_info->delalloc_roots);\n\t\tspin_unlock(&fs_info->delalloc_root_lock);\n\t}\n\tmutex_unlock(&fs_info->delalloc_root_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nint btrfs_start_delalloc_roots(struct btrfs_fs_info *fs_info, int delay_iput,\n\t\t\t       int nr)\n{\n\tstruct btrfs_root *root;\n\tstruct list_head splice;\n\tint ret;\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state))\n\t\treturn -EROFS;\n\n\tINIT_LIST_HEAD(&splice);\n\n\tmutex_lock(&fs_info->delalloc_root_mutex);\n\tspin_lock(&fs_info->delalloc_root_lock);\n\tlist_splice_init(&fs_info->delalloc_roots, &splice);\n\twhile (!list_empty(&splice) && nr) {\n\t\troot = list_first_entry(&splice, struct btrfs_root,\n\t\t\t\t\tdelalloc_root);\n\t\troot = btrfs_grab_fs_root(root);\n\t\tBUG_ON(!root);\n\t\tlist_move_tail(&root->delalloc_root,\n\t\t\t       &fs_info->delalloc_roots);\n\t\tspin_unlock(&fs_info->delalloc_root_lock);\n\n\t\tret = __start_delalloc_inodes(root, delay_iput, nr);\n\t\tbtrfs_put_fs_root(root);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (nr != -1) {\n\t\t\tnr -= ret;\n\t\t\tWARN_ON(nr < 0);\n\t\t}\n\t\tspin_lock(&fs_info->delalloc_root_lock);\n\t}\n\tspin_unlock(&fs_info->delalloc_root_lock);\n\n\tret = 0;\n\tatomic_inc(&fs_info->async_submit_draining);\n\twhile (atomic_read(&fs_info->nr_async_submits) ||\n\t      atomic_read(&fs_info->async_delalloc_pages)) {\n\t\twait_event(fs_info->async_submit_wait,\n\t\t   (atomic_read(&fs_info->nr_async_submits) == 0 &&\n\t\t    atomic_read(&fs_info->async_delalloc_pages) == 0));\n\t}\n\tatomic_dec(&fs_info->async_submit_draining);\nout:\n\tif (!list_empty_careful(&splice)) {\n\t\tspin_lock(&fs_info->delalloc_root_lock);\n\t\tlist_splice_tail(&splice, &fs_info->delalloc_roots);\n\t\tspin_unlock(&fs_info->delalloc_root_lock);\n\t}\n\tmutex_unlock(&fs_info->delalloc_root_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_space_info",
          "args": [
            "root",
            "argp"
          ],
          "line": 5264
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_space_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "3849-3987",
          "snippet": "static long btrfs_ioctl_space_info(struct btrfs_root *root, void __user *arg)\n{\n\tstruct btrfs_ioctl_space_args space_args;\n\tstruct btrfs_ioctl_space_info space;\n\tstruct btrfs_ioctl_space_info *dest;\n\tstruct btrfs_ioctl_space_info *dest_orig;\n\tstruct btrfs_ioctl_space_info __user *user_dest;\n\tstruct btrfs_space_info *info;\n\tu64 types[] = {BTRFS_BLOCK_GROUP_DATA,\n\t\t       BTRFS_BLOCK_GROUP_SYSTEM,\n\t\t       BTRFS_BLOCK_GROUP_METADATA,\n\t\t       BTRFS_BLOCK_GROUP_DATA | BTRFS_BLOCK_GROUP_METADATA};\n\tint num_types = 4;\n\tint alloc_size;\n\tint ret = 0;\n\tu64 slot_count = 0;\n\tint i, c;\n\n\tif (copy_from_user(&space_args,\n\t\t\t   (struct btrfs_ioctl_space_args __user *)arg,\n\t\t\t   sizeof(space_args)))\n\t\treturn -EFAULT;\n\n\tfor (i = 0; i < num_types; i++) {\n\t\tstruct btrfs_space_info *tmp;\n\n\t\tinfo = NULL;\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(tmp, &root->fs_info->space_info,\n\t\t\t\t\tlist) {\n\t\t\tif (tmp->flags == types[i]) {\n\t\t\t\tinfo = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tif (!info)\n\t\t\tcontinue;\n\n\t\tdown_read(&info->groups_sem);\n\t\tfor (c = 0; c < BTRFS_NR_RAID_TYPES; c++) {\n\t\t\tif (!list_empty(&info->block_groups[c]))\n\t\t\t\tslot_count++;\n\t\t}\n\t\tup_read(&info->groups_sem);\n\t}\n\n\t/*\n\t * Global block reserve, exported as a space_info\n\t */\n\tslot_count++;\n\n\t/* space_slots == 0 means they are asking for a count */\n\tif (space_args.space_slots == 0) {\n\t\tspace_args.total_spaces = slot_count;\n\t\tgoto out;\n\t}\n\n\tslot_count = min_t(u64, space_args.space_slots, slot_count);\n\n\talloc_size = sizeof(*dest) * slot_count;\n\n\t/* we generally have at most 6 or so space infos, one for each raid\n\t * level.  So, a whole page should be more than enough for everyone\n\t */\n\tif (alloc_size > PAGE_CACHE_SIZE)\n\t\treturn -ENOMEM;\n\n\tspace_args.total_spaces = 0;\n\tdest = kmalloc(alloc_size, GFP_NOFS);\n\tif (!dest)\n\t\treturn -ENOMEM;\n\tdest_orig = dest;\n\n\t/* now we have a buffer to copy into */\n\tfor (i = 0; i < num_types; i++) {\n\t\tstruct btrfs_space_info *tmp;\n\n\t\tif (!slot_count)\n\t\t\tbreak;\n\n\t\tinfo = NULL;\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(tmp, &root->fs_info->space_info,\n\t\t\t\t\tlist) {\n\t\t\tif (tmp->flags == types[i]) {\n\t\t\t\tinfo = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tif (!info)\n\t\t\tcontinue;\n\t\tdown_read(&info->groups_sem);\n\t\tfor (c = 0; c < BTRFS_NR_RAID_TYPES; c++) {\n\t\t\tif (!list_empty(&info->block_groups[c])) {\n\t\t\t\tbtrfs_get_block_group_info(\n\t\t\t\t\t&info->block_groups[c], &space);\n\t\t\t\tmemcpy(dest, &space, sizeof(space));\n\t\t\t\tdest++;\n\t\t\t\tspace_args.total_spaces++;\n\t\t\t\tslot_count--;\n\t\t\t}\n\t\t\tif (!slot_count)\n\t\t\t\tbreak;\n\t\t}\n\t\tup_read(&info->groups_sem);\n\t}\n\n\t/*\n\t * Add global block reserve\n\t */\n\tif (slot_count) {\n\t\tstruct btrfs_block_rsv *block_rsv = &root->fs_info->global_block_rsv;\n\n\t\tspin_lock(&block_rsv->lock);\n\t\tspace.total_bytes = block_rsv->size;\n\t\tspace.used_bytes = block_rsv->size - block_rsv->reserved;\n\t\tspin_unlock(&block_rsv->lock);\n\t\tspace.flags = BTRFS_SPACE_INFO_GLOBAL_RSV;\n\t\tmemcpy(dest, &space, sizeof(space));\n\t\tspace_args.total_spaces++;\n\t}\n\n\tuser_dest = (struct btrfs_ioctl_space_info __user *)\n\t\t(arg + sizeof(struct btrfs_ioctl_space_args));\n\n\tif (copy_to_user(user_dest, dest_orig, alloc_size))\n\t\tret = -EFAULT;\n\n\tkfree(dest_orig);\nout:\n\tif (ret == 0 && copy_to_user(arg, &space_args, sizeof(space_args)))\n\t\tret = -EFAULT;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_space_info(struct btrfs_root *root, void __user *arg)\n{\n\tstruct btrfs_ioctl_space_args space_args;\n\tstruct btrfs_ioctl_space_info space;\n\tstruct btrfs_ioctl_space_info *dest;\n\tstruct btrfs_ioctl_space_info *dest_orig;\n\tstruct btrfs_ioctl_space_info __user *user_dest;\n\tstruct btrfs_space_info *info;\n\tu64 types[] = {BTRFS_BLOCK_GROUP_DATA,\n\t\t       BTRFS_BLOCK_GROUP_SYSTEM,\n\t\t       BTRFS_BLOCK_GROUP_METADATA,\n\t\t       BTRFS_BLOCK_GROUP_DATA | BTRFS_BLOCK_GROUP_METADATA};\n\tint num_types = 4;\n\tint alloc_size;\n\tint ret = 0;\n\tu64 slot_count = 0;\n\tint i, c;\n\n\tif (copy_from_user(&space_args,\n\t\t\t   (struct btrfs_ioctl_space_args __user *)arg,\n\t\t\t   sizeof(space_args)))\n\t\treturn -EFAULT;\n\n\tfor (i = 0; i < num_types; i++) {\n\t\tstruct btrfs_space_info *tmp;\n\n\t\tinfo = NULL;\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(tmp, &root->fs_info->space_info,\n\t\t\t\t\tlist) {\n\t\t\tif (tmp->flags == types[i]) {\n\t\t\t\tinfo = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tif (!info)\n\t\t\tcontinue;\n\n\t\tdown_read(&info->groups_sem);\n\t\tfor (c = 0; c < BTRFS_NR_RAID_TYPES; c++) {\n\t\t\tif (!list_empty(&info->block_groups[c]))\n\t\t\t\tslot_count++;\n\t\t}\n\t\tup_read(&info->groups_sem);\n\t}\n\n\t/*\n\t * Global block reserve, exported as a space_info\n\t */\n\tslot_count++;\n\n\t/* space_slots == 0 means they are asking for a count */\n\tif (space_args.space_slots == 0) {\n\t\tspace_args.total_spaces = slot_count;\n\t\tgoto out;\n\t}\n\n\tslot_count = min_t(u64, space_args.space_slots, slot_count);\n\n\talloc_size = sizeof(*dest) * slot_count;\n\n\t/* we generally have at most 6 or so space infos, one for each raid\n\t * level.  So, a whole page should be more than enough for everyone\n\t */\n\tif (alloc_size > PAGE_CACHE_SIZE)\n\t\treturn -ENOMEM;\n\n\tspace_args.total_spaces = 0;\n\tdest = kmalloc(alloc_size, GFP_NOFS);\n\tif (!dest)\n\t\treturn -ENOMEM;\n\tdest_orig = dest;\n\n\t/* now we have a buffer to copy into */\n\tfor (i = 0; i < num_types; i++) {\n\t\tstruct btrfs_space_info *tmp;\n\n\t\tif (!slot_count)\n\t\t\tbreak;\n\n\t\tinfo = NULL;\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(tmp, &root->fs_info->space_info,\n\t\t\t\t\tlist) {\n\t\t\tif (tmp->flags == types[i]) {\n\t\t\t\tinfo = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tif (!info)\n\t\t\tcontinue;\n\t\tdown_read(&info->groups_sem);\n\t\tfor (c = 0; c < BTRFS_NR_RAID_TYPES; c++) {\n\t\t\tif (!list_empty(&info->block_groups[c])) {\n\t\t\t\tbtrfs_get_block_group_info(\n\t\t\t\t\t&info->block_groups[c], &space);\n\t\t\t\tmemcpy(dest, &space, sizeof(space));\n\t\t\t\tdest++;\n\t\t\t\tspace_args.total_spaces++;\n\t\t\t\tslot_count--;\n\t\t\t}\n\t\t\tif (!slot_count)\n\t\t\t\tbreak;\n\t\t}\n\t\tup_read(&info->groups_sem);\n\t}\n\n\t/*\n\t * Add global block reserve\n\t */\n\tif (slot_count) {\n\t\tstruct btrfs_block_rsv *block_rsv = &root->fs_info->global_block_rsv;\n\n\t\tspin_lock(&block_rsv->lock);\n\t\tspace.total_bytes = block_rsv->size;\n\t\tspace.used_bytes = block_rsv->size - block_rsv->reserved;\n\t\tspin_unlock(&block_rsv->lock);\n\t\tspace.flags = BTRFS_SPACE_INFO_GLOBAL_RSV;\n\t\tmemcpy(dest, &space, sizeof(space));\n\t\tspace_args.total_spaces++;\n\t}\n\n\tuser_dest = (struct btrfs_ioctl_space_info __user *)\n\t\t(arg + sizeof(struct btrfs_ioctl_space_args));\n\n\tif (copy_to_user(user_dest, dest_orig, alloc_size))\n\t\tret = -EFAULT;\n\n\tkfree(dest_orig);\nout:\n\tif (ret == 0 && copy_to_user(arg, &space_args, sizeof(space_args)))\n\t\tret = -EFAULT;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_logical_to_ino",
          "args": [
            "root",
            "argp"
          ],
          "line": 5262
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_logical_to_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "4271-4322",
          "snippet": "static long btrfs_ioctl_logical_to_ino(struct btrfs_root *root,\n\t\t\t\t\tvoid __user *arg)\n{\n\tint ret = 0;\n\tint size;\n\tstruct btrfs_ioctl_logical_ino_args *loi;\n\tstruct btrfs_data_container *inodes = NULL;\n\tstruct btrfs_path *path = NULL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tloi = memdup_user(arg, sizeof(*loi));\n\tif (IS_ERR(loi)) {\n\t\tret = PTR_ERR(loi);\n\t\tloi = NULL;\n\t\tgoto out;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsize = min_t(u32, loi->size, 64 * 1024);\n\tinodes = init_data_container(size);\n\tif (IS_ERR(inodes)) {\n\t\tret = PTR_ERR(inodes);\n\t\tinodes = NULL;\n\t\tgoto out;\n\t}\n\n\tret = iterate_inodes_from_logical(loi->logical, root->fs_info, path,\n\t\t\t\t\t  build_ino_list, inodes);\n\tif (ret == -EINVAL)\n\t\tret = -ENOENT;\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = copy_to_user((void *)(unsigned long)loi->inodes,\n\t\t\t   (void *)(unsigned long)inodes, size);\n\tif (ret)\n\t\tret = -EFAULT;\n\nout:\n\tbtrfs_free_path(path);\n\tvfree(inodes);\n\tkfree(loi);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_logical_to_ino(struct btrfs_root *root,\n\t\t\t\t\tvoid __user *arg)\n{\n\tint ret = 0;\n\tint size;\n\tstruct btrfs_ioctl_logical_ino_args *loi;\n\tstruct btrfs_data_container *inodes = NULL;\n\tstruct btrfs_path *path = NULL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tloi = memdup_user(arg, sizeof(*loi));\n\tif (IS_ERR(loi)) {\n\t\tret = PTR_ERR(loi);\n\t\tloi = NULL;\n\t\tgoto out;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsize = min_t(u32, loi->size, 64 * 1024);\n\tinodes = init_data_container(size);\n\tif (IS_ERR(inodes)) {\n\t\tret = PTR_ERR(inodes);\n\t\tinodes = NULL;\n\t\tgoto out;\n\t}\n\n\tret = iterate_inodes_from_logical(loi->logical, root->fs_info, path,\n\t\t\t\t\t  build_ino_list, inodes);\n\tif (ret == -EINVAL)\n\t\tret = -ENOENT;\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = copy_to_user((void *)(unsigned long)loi->inodes,\n\t\t\t   (void *)(unsigned long)inodes, size);\n\tif (ret)\n\t\tret = -EFAULT;\n\nout:\n\tbtrfs_free_path(path);\n\tvfree(inodes);\n\tkfree(loi);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_ino_to_path",
          "args": [
            "root",
            "argp"
          ],
          "line": 5260
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_ino_to_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "4192-4249",
          "snippet": "static long btrfs_ioctl_ino_to_path(struct btrfs_root *root, void __user *arg)\n{\n\tint ret = 0;\n\tint i;\n\tu64 rel_ptr;\n\tint size;\n\tstruct btrfs_ioctl_ino_path_args *ipa = NULL;\n\tstruct inode_fs_paths *ipath = NULL;\n\tstruct btrfs_path *path;\n\n\tif (!capable(CAP_DAC_READ_SEARCH))\n\t\treturn -EPERM;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tipa = memdup_user(arg, sizeof(*ipa));\n\tif (IS_ERR(ipa)) {\n\t\tret = PTR_ERR(ipa);\n\t\tipa = NULL;\n\t\tgoto out;\n\t}\n\n\tsize = min_t(u32, ipa->size, 4096);\n\tipath = init_ipath(size, root, path);\n\tif (IS_ERR(ipath)) {\n\t\tret = PTR_ERR(ipath);\n\t\tipath = NULL;\n\t\tgoto out;\n\t}\n\n\tret = paths_from_inode(ipa->inum, ipath);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tfor (i = 0; i < ipath->fspath->elem_cnt; ++i) {\n\t\trel_ptr = ipath->fspath->val[i] -\n\t\t\t  (u64)(unsigned long)ipath->fspath->val;\n\t\tipath->fspath->val[i] = rel_ptr;\n\t}\n\n\tret = copy_to_user((void *)(unsigned long)ipa->fspath,\n\t\t\t   (void *)(unsigned long)ipath->fspath, size);\n\tif (ret) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\tfree_ipath(ipath);\n\tkfree(ipa);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_ino_to_path(struct btrfs_root *root, void __user *arg)\n{\n\tint ret = 0;\n\tint i;\n\tu64 rel_ptr;\n\tint size;\n\tstruct btrfs_ioctl_ino_path_args *ipa = NULL;\n\tstruct inode_fs_paths *ipath = NULL;\n\tstruct btrfs_path *path;\n\n\tif (!capable(CAP_DAC_READ_SEARCH))\n\t\treturn -EPERM;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tipa = memdup_user(arg, sizeof(*ipa));\n\tif (IS_ERR(ipa)) {\n\t\tret = PTR_ERR(ipa);\n\t\tipa = NULL;\n\t\tgoto out;\n\t}\n\n\tsize = min_t(u32, ipa->size, 4096);\n\tipath = init_ipath(size, root, path);\n\tif (IS_ERR(ipath)) {\n\t\tret = PTR_ERR(ipath);\n\t\tipath = NULL;\n\t\tgoto out;\n\t}\n\n\tret = paths_from_inode(ipa->inum, ipath);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tfor (i = 0; i < ipath->fspath->elem_cnt; ++i) {\n\t\trel_ptr = ipath->fspath->val[i] -\n\t\t\t  (u64)(unsigned long)ipath->fspath->val;\n\t\tipath->fspath->val[i] = rel_ptr;\n\t}\n\n\tret = copy_to_user((void *)(unsigned long)ipa->fspath,\n\t\t\t   (void *)(unsigned long)ipath->fspath, size);\n\tif (ret) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\tfree_ipath(ipath);\n\tkfree(ipa);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_ino_lookup",
          "args": [
            "file",
            "argp"
          ],
          "line": 5258
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_ino_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "2262-2290",
          "snippet": "static noinline int btrfs_ioctl_ino_lookup(struct file *file,\n\t\t\t\t\t   void __user *argp)\n{\n\t struct btrfs_ioctl_ino_lookup_args *args;\n\t struct inode *inode;\n\t int ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\targs = memdup_user(argp, sizeof(*args));\n\tif (IS_ERR(args))\n\t\treturn PTR_ERR(args);\n\n\tinode = file_inode(file);\n\n\tif (args->treeid == 0)\n\t\targs->treeid = BTRFS_I(inode)->root->root_key.objectid;\n\n\tret = btrfs_search_path_in_tree(BTRFS_I(inode)->root->fs_info,\n\t\t\t\t\targs->treeid, args->objectid,\n\t\t\t\t\targs->name);\n\n\tif (ret == 0 && copy_to_user(argp, args, sizeof(*args)))\n\t\tret = -EFAULT;\n\n\tkfree(args);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic noinline int btrfs_ioctl_ino_lookup(struct file *file,\n\t\t\t\t\t   void __user *argp)\n{\n\t struct btrfs_ioctl_ino_lookup_args *args;\n\t struct inode *inode;\n\t int ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\targs = memdup_user(argp, sizeof(*args));\n\tif (IS_ERR(args))\n\t\treturn PTR_ERR(args);\n\n\tinode = file_inode(file);\n\n\tif (args->treeid == 0)\n\t\targs->treeid = BTRFS_I(inode)->root->root_key.objectid;\n\n\tret = btrfs_search_path_in_tree(BTRFS_I(inode)->root->fs_info,\n\t\t\t\t\targs->treeid, args->objectid,\n\t\t\t\t\targs->name);\n\n\tif (ret == 0 && copy_to_user(argp, args, sizeof(*args)))\n\t\tret = -EFAULT;\n\n\tkfree(args);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_tree_search_v2",
          "args": [
            "file",
            "argp"
          ],
          "line": 5256
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_tree_search_v2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "2133-2170",
          "snippet": "static noinline int btrfs_ioctl_tree_search_v2(struct file *file,\n\t\t\t\t\t       void __user *argp)\n{\n\tstruct btrfs_ioctl_search_args_v2 __user *uarg;\n\tstruct btrfs_ioctl_search_args_v2 args;\n\tstruct inode *inode;\n\tint ret;\n\tsize_t buf_size;\n\tconst size_t buf_limit = 16 * 1024 * 1024;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t/* copy search header and buffer size */\n\tuarg = (struct btrfs_ioctl_search_args_v2 __user *)argp;\n\tif (copy_from_user(&args, uarg, sizeof(args)))\n\t\treturn -EFAULT;\n\n\tbuf_size = args.buf_size;\n\n\tif (buf_size < sizeof(struct btrfs_ioctl_search_header))\n\t\treturn -EOVERFLOW;\n\n\t/* limit result size to 16MB */\n\tif (buf_size > buf_limit)\n\t\tbuf_size = buf_limit;\n\n\tinode = file_inode(file);\n\tret = search_ioctl(inode, &args.key, &buf_size,\n\t\t\t   (char *)(&uarg->buf[0]));\n\tif (ret == 0 && copy_to_user(&uarg->key, &args.key, sizeof(args.key)))\n\t\tret = -EFAULT;\n\telse if (ret == -EOVERFLOW &&\n\t\tcopy_to_user(&uarg->buf_size, &buf_size, sizeof(buf_size)))\n\t\tret = -EFAULT;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic noinline int btrfs_ioctl_tree_search_v2(struct file *file,\n\t\t\t\t\t       void __user *argp)\n{\n\tstruct btrfs_ioctl_search_args_v2 __user *uarg;\n\tstruct btrfs_ioctl_search_args_v2 args;\n\tstruct inode *inode;\n\tint ret;\n\tsize_t buf_size;\n\tconst size_t buf_limit = 16 * 1024 * 1024;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t/* copy search header and buffer size */\n\tuarg = (struct btrfs_ioctl_search_args_v2 __user *)argp;\n\tif (copy_from_user(&args, uarg, sizeof(args)))\n\t\treturn -EFAULT;\n\n\tbuf_size = args.buf_size;\n\n\tif (buf_size < sizeof(struct btrfs_ioctl_search_header))\n\t\treturn -EOVERFLOW;\n\n\t/* limit result size to 16MB */\n\tif (buf_size > buf_limit)\n\t\tbuf_size = buf_limit;\n\n\tinode = file_inode(file);\n\tret = search_ioctl(inode, &args.key, &buf_size,\n\t\t\t   (char *)(&uarg->buf[0]));\n\tif (ret == 0 && copy_to_user(&uarg->key, &args.key, sizeof(args.key)))\n\t\tret = -EFAULT;\n\telse if (ret == -EOVERFLOW &&\n\t\tcopy_to_user(&uarg->buf_size, &buf_size, sizeof(buf_size)))\n\t\tret = -EFAULT;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_trans_end",
          "args": [
            "file"
          ],
          "line": 5252
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_trans_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "3995-4012",
          "snippet": "long btrfs_ioctl_trans_end(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_trans_handle *trans;\n\n\ttrans = file->private_data;\n\tif (!trans)\n\t\treturn -EINVAL;\n\tfile->private_data = NULL;\n\n\tbtrfs_end_transaction(trans, root);\n\n\tatomic_dec(&root->fs_info->open_ioctl_trans);\n\n\tmnt_drop_write_file(file);\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nlong btrfs_ioctl_trans_end(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_trans_handle *trans;\n\n\ttrans = file->private_data;\n\tif (!trans)\n\t\treturn -EINVAL;\n\tfile->private_data = NULL;\n\n\tbtrfs_end_transaction(trans, root);\n\n\tatomic_dec(&root->fs_info->open_ioctl_trans);\n\n\tmnt_drop_write_file(file);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_trans_start",
          "args": [
            "file"
          ],
          "line": 5250
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_trans_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "3716-3754",
          "snippet": "static long btrfs_ioctl_trans_start(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\n\tret = -EPERM;\n\tif (!capable(CAP_SYS_ADMIN))\n\t\tgoto out;\n\n\tret = -EINPROGRESS;\n\tif (file->private_data)\n\t\tgoto out;\n\n\tret = -EROFS;\n\tif (btrfs_root_readonly(root))\n\t\tgoto out;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\tgoto out;\n\n\tatomic_inc(&root->fs_info->open_ioctl_trans);\n\n\tret = -ENOMEM;\n\ttrans = btrfs_start_ioctl_transaction(root);\n\tif (IS_ERR(trans))\n\t\tgoto out_drop;\n\n\tfile->private_data = trans;\n\treturn 0;\n\nout_drop:\n\tatomic_dec(&root->fs_info->open_ioctl_trans);\n\tmnt_drop_write_file(file);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_trans_start(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\n\tret = -EPERM;\n\tif (!capable(CAP_SYS_ADMIN))\n\t\tgoto out;\n\n\tret = -EINPROGRESS;\n\tif (file->private_data)\n\t\tgoto out;\n\n\tret = -EROFS;\n\tif (btrfs_root_readonly(root))\n\t\tgoto out;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\tgoto out;\n\n\tatomic_inc(&root->fs_info->open_ioctl_trans);\n\n\tret = -ENOMEM;\n\ttrans = btrfs_start_ioctl_transaction(root);\n\tif (IS_ERR(trans))\n\t\tgoto out_drop;\n\n\tfile->private_data = trans;\n\treturn 0;\n\nout_drop:\n\tatomic_dec(&root->fs_info->open_ioctl_trans);\n\tmnt_drop_write_file(file);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_clone_range",
          "args": [
            "file",
            "argp"
          ],
          "line": 5248
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_clone_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "3700-3708",
          "snippet": "static long btrfs_ioctl_clone_range(struct file *file, void __user *argp)\n{\n\tstruct btrfs_ioctl_clone_range_args args;\n\n\tif (copy_from_user(&args, argp, sizeof(args)))\n\t\treturn -EFAULT;\n\treturn btrfs_ioctl_clone(file, args.src_fd, args.src_offset,\n\t\t\t\t args.src_length, args.dest_offset);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_clone_range(struct file *file, void __user *argp)\n{\n\tstruct btrfs_ioctl_clone_range_args args;\n\n\tif (copy_from_user(&args, argp, sizeof(args)))\n\t\treturn -EFAULT;\n\treturn btrfs_ioctl_clone(file, args.src_fd, args.src_offset,\n\t\t\t\t args.src_length, args.dest_offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_clone",
          "args": [
            "file",
            "arg",
            "0",
            "0",
            "0"
          ],
          "line": 5246
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_clone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "3540-3698",
          "snippet": "static noinline long btrfs_ioctl_clone(struct file *file, unsigned long srcfd,\n\t\t\t\t       u64 off, u64 olen, u64 destoff)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct fd src_file;\n\tstruct inode *src;\n\tint ret;\n\tu64 len = olen;\n\tu64 bs = root->fs_info->sb->s_blocksize;\n\tint same_inode = 0;\n\n\t/*\n\t * TODO:\n\t * - split compressed inline extents.  annoying: we need to\n\t *   decompress into destination's address_space (the file offset\n\t *   may change, so source mapping won't do), then recompress (or\n\t *   otherwise reinsert) a subrange.\n\t *\n\t * - split destination inode's inline extents.  The inline extents can\n\t *   be either compressed or non-compressed.\n\t */\n\n\t/* the destination must be opened for writing */\n\tif (!(file->f_mode & FMODE_WRITE) || (file->f_flags & O_APPEND))\n\t\treturn -EINVAL;\n\n\tif (btrfs_root_readonly(root))\n\t\treturn -EROFS;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tsrc_file = fdget(srcfd);\n\tif (!src_file.file) {\n\t\tret = -EBADF;\n\t\tgoto out_drop_write;\n\t}\n\n\tret = -EXDEV;\n\tif (src_file.file->f_path.mnt != file->f_path.mnt)\n\t\tgoto out_fput;\n\n\tsrc = file_inode(src_file.file);\n\n\tret = -EINVAL;\n\tif (src == inode)\n\t\tsame_inode = 1;\n\n\t/* the src must be open for reading */\n\tif (!(src_file.file->f_mode & FMODE_READ))\n\t\tgoto out_fput;\n\n\t/* don't make the dst file partly checksummed */\n\tif ((BTRFS_I(src)->flags & BTRFS_INODE_NODATASUM) !=\n\t    (BTRFS_I(inode)->flags & BTRFS_INODE_NODATASUM))\n\t\tgoto out_fput;\n\n\tret = -EISDIR;\n\tif (S_ISDIR(src->i_mode) || S_ISDIR(inode->i_mode))\n\t\tgoto out_fput;\n\n\tret = -EXDEV;\n\tif (src->i_sb != inode->i_sb)\n\t\tgoto out_fput;\n\n\tif (!same_inode) {\n\t\tif (inode < src) {\n\t\t\tmutex_lock_nested(&inode->i_mutex, I_MUTEX_PARENT);\n\t\t\tmutex_lock_nested(&src->i_mutex, I_MUTEX_CHILD);\n\t\t} else {\n\t\t\tmutex_lock_nested(&src->i_mutex, I_MUTEX_PARENT);\n\t\t\tmutex_lock_nested(&inode->i_mutex, I_MUTEX_CHILD);\n\t\t}\n\t} else {\n\t\tmutex_lock(&src->i_mutex);\n\t}\n\n\t/* determine range to clone */\n\tret = -EINVAL;\n\tif (off + len > src->i_size || off + len < off)\n\t\tgoto out_unlock;\n\tif (len == 0)\n\t\tolen = len = src->i_size - off;\n\t/* if we extend to eof, continue to block boundary */\n\tif (off + len == src->i_size)\n\t\tlen = ALIGN(src->i_size, bs) - off;\n\n\t/* verify the end result is block aligned */\n\tif (!IS_ALIGNED(off, bs) || !IS_ALIGNED(off + len, bs) ||\n\t    !IS_ALIGNED(destoff, bs))\n\t\tgoto out_unlock;\n\n\t/* verify if ranges are overlapped within the same file */\n\tif (same_inode) {\n\t\tif (destoff + len > off && destoff < off + len)\n\t\t\tgoto out_unlock;\n\t}\n\n\tif (destoff > inode->i_size) {\n\t\tret = btrfs_cont_expand(inode, inode->i_size, destoff);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Lock the target range too. Right after we replace the file extent\n\t * items in the fs tree (which now point to the cloned data), we might\n\t * have a worker replace them with extent items relative to a write\n\t * operation that was issued before this clone operation (i.e. confront\n\t * with inode.c:btrfs_finish_ordered_io).\n\t */\n\tif (same_inode) {\n\t\tu64 lock_start = min_t(u64, off, destoff);\n\t\tu64 lock_len = max_t(u64, off, destoff) + len - lock_start;\n\n\t\tlock_extent_range(src, lock_start, lock_len);\n\t} else {\n\t\tlock_extent_range(src, off, len);\n\t\tlock_extent_range(inode, destoff, len);\n\t}\n\n\tret = btrfs_clone(src, inode, off, olen, len, destoff);\n\n\tif (same_inode) {\n\t\tu64 lock_start = min_t(u64, off, destoff);\n\t\tu64 lock_end = max_t(u64, off, destoff) + len - 1;\n\n\t\tunlock_extent(&BTRFS_I(src)->io_tree, lock_start, lock_end);\n\t} else {\n\t\tunlock_extent(&BTRFS_I(src)->io_tree, off, off + len - 1);\n\t\tunlock_extent(&BTRFS_I(inode)->io_tree, destoff,\n\t\t\t      destoff + len - 1);\n\t}\n\t/*\n\t * Truncate page cache pages so that future reads will see the cloned\n\t * data immediately and not the previous data.\n\t */\n\ttruncate_inode_pages_range(&inode->i_data, destoff,\n\t\t\t\t   PAGE_CACHE_ALIGN(destoff + len) - 1);\nout_unlock:\n\tif (!same_inode) {\n\t\tif (inode < src) {\n\t\t\tmutex_unlock(&src->i_mutex);\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t} else {\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\tmutex_unlock(&src->i_mutex);\n\t\t}\n\t} else {\n\t\tmutex_unlock(&src->i_mutex);\n\t}\nout_fput:\n\tfdput(src_file);\nout_drop_write:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_clone(struct inode *src, struct inode *inode,\n\t\t       u64 off, u64 olen, u64 olen_aligned, u64 destoff);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_clone(struct inode *src, struct inode *inode,\n\t\t       u64 off, u64 olen, u64 olen_aligned, u64 destoff);\n\nstatic noinline long btrfs_ioctl_clone(struct file *file, unsigned long srcfd,\n\t\t\t\t       u64 off, u64 olen, u64 destoff)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct fd src_file;\n\tstruct inode *src;\n\tint ret;\n\tu64 len = olen;\n\tu64 bs = root->fs_info->sb->s_blocksize;\n\tint same_inode = 0;\n\n\t/*\n\t * TODO:\n\t * - split compressed inline extents.  annoying: we need to\n\t *   decompress into destination's address_space (the file offset\n\t *   may change, so source mapping won't do), then recompress (or\n\t *   otherwise reinsert) a subrange.\n\t *\n\t * - split destination inode's inline extents.  The inline extents can\n\t *   be either compressed or non-compressed.\n\t */\n\n\t/* the destination must be opened for writing */\n\tif (!(file->f_mode & FMODE_WRITE) || (file->f_flags & O_APPEND))\n\t\treturn -EINVAL;\n\n\tif (btrfs_root_readonly(root))\n\t\treturn -EROFS;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tsrc_file = fdget(srcfd);\n\tif (!src_file.file) {\n\t\tret = -EBADF;\n\t\tgoto out_drop_write;\n\t}\n\n\tret = -EXDEV;\n\tif (src_file.file->f_path.mnt != file->f_path.mnt)\n\t\tgoto out_fput;\n\n\tsrc = file_inode(src_file.file);\n\n\tret = -EINVAL;\n\tif (src == inode)\n\t\tsame_inode = 1;\n\n\t/* the src must be open for reading */\n\tif (!(src_file.file->f_mode & FMODE_READ))\n\t\tgoto out_fput;\n\n\t/* don't make the dst file partly checksummed */\n\tif ((BTRFS_I(src)->flags & BTRFS_INODE_NODATASUM) !=\n\t    (BTRFS_I(inode)->flags & BTRFS_INODE_NODATASUM))\n\t\tgoto out_fput;\n\n\tret = -EISDIR;\n\tif (S_ISDIR(src->i_mode) || S_ISDIR(inode->i_mode))\n\t\tgoto out_fput;\n\n\tret = -EXDEV;\n\tif (src->i_sb != inode->i_sb)\n\t\tgoto out_fput;\n\n\tif (!same_inode) {\n\t\tif (inode < src) {\n\t\t\tmutex_lock_nested(&inode->i_mutex, I_MUTEX_PARENT);\n\t\t\tmutex_lock_nested(&src->i_mutex, I_MUTEX_CHILD);\n\t\t} else {\n\t\t\tmutex_lock_nested(&src->i_mutex, I_MUTEX_PARENT);\n\t\t\tmutex_lock_nested(&inode->i_mutex, I_MUTEX_CHILD);\n\t\t}\n\t} else {\n\t\tmutex_lock(&src->i_mutex);\n\t}\n\n\t/* determine range to clone */\n\tret = -EINVAL;\n\tif (off + len > src->i_size || off + len < off)\n\t\tgoto out_unlock;\n\tif (len == 0)\n\t\tolen = len = src->i_size - off;\n\t/* if we extend to eof, continue to block boundary */\n\tif (off + len == src->i_size)\n\t\tlen = ALIGN(src->i_size, bs) - off;\n\n\t/* verify the end result is block aligned */\n\tif (!IS_ALIGNED(off, bs) || !IS_ALIGNED(off + len, bs) ||\n\t    !IS_ALIGNED(destoff, bs))\n\t\tgoto out_unlock;\n\n\t/* verify if ranges are overlapped within the same file */\n\tif (same_inode) {\n\t\tif (destoff + len > off && destoff < off + len)\n\t\t\tgoto out_unlock;\n\t}\n\n\tif (destoff > inode->i_size) {\n\t\tret = btrfs_cont_expand(inode, inode->i_size, destoff);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Lock the target range too. Right after we replace the file extent\n\t * items in the fs tree (which now point to the cloned data), we might\n\t * have a worker replace them with extent items relative to a write\n\t * operation that was issued before this clone operation (i.e. confront\n\t * with inode.c:btrfs_finish_ordered_io).\n\t */\n\tif (same_inode) {\n\t\tu64 lock_start = min_t(u64, off, destoff);\n\t\tu64 lock_len = max_t(u64, off, destoff) + len - lock_start;\n\n\t\tlock_extent_range(src, lock_start, lock_len);\n\t} else {\n\t\tlock_extent_range(src, off, len);\n\t\tlock_extent_range(inode, destoff, len);\n\t}\n\n\tret = btrfs_clone(src, inode, off, olen, len, destoff);\n\n\tif (same_inode) {\n\t\tu64 lock_start = min_t(u64, off, destoff);\n\t\tu64 lock_end = max_t(u64, off, destoff) + len - 1;\n\n\t\tunlock_extent(&BTRFS_I(src)->io_tree, lock_start, lock_end);\n\t} else {\n\t\tunlock_extent(&BTRFS_I(src)->io_tree, off, off + len - 1);\n\t\tunlock_extent(&BTRFS_I(inode)->io_tree, destoff,\n\t\t\t      destoff + len - 1);\n\t}\n\t/*\n\t * Truncate page cache pages so that future reads will see the cloned\n\t * data immediately and not the previous data.\n\t */\n\ttruncate_inode_pages_range(&inode->i_data, destoff,\n\t\t\t\t   PAGE_CACHE_ALIGN(destoff + len) - 1);\nout_unlock:\n\tif (!same_inode) {\n\t\tif (inode < src) {\n\t\t\tmutex_unlock(&src->i_mutex);\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t} else {\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\tmutex_unlock(&src->i_mutex);\n\t\t}\n\t} else {\n\t\tmutex_unlock(&src->i_mutex);\n\t}\nout_fput:\n\tfdput(src_file);\nout_drop_write:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_dev_info",
          "args": [
            "root",
            "argp"
          ],
          "line": 5242
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_dev_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "2702-2748",
          "snippet": "static long btrfs_ioctl_dev_info(struct btrfs_root *root, void __user *arg)\n{\n\tstruct btrfs_ioctl_dev_info_args *di_args;\n\tstruct btrfs_device *dev;\n\tstruct btrfs_fs_devices *fs_devices = root->fs_info->fs_devices;\n\tint ret = 0;\n\tchar *s_uuid = NULL;\n\n\tdi_args = memdup_user(arg, sizeof(*di_args));\n\tif (IS_ERR(di_args))\n\t\treturn PTR_ERR(di_args);\n\n\tif (!btrfs_is_empty_uuid(di_args->uuid))\n\t\ts_uuid = di_args->uuid;\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tdev = btrfs_find_device(root->fs_info, di_args->devid, s_uuid, NULL);\n\n\tif (!dev) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tdi_args->devid = dev->devid;\n\tdi_args->bytes_used = btrfs_device_get_bytes_used(dev);\n\tdi_args->total_bytes = btrfs_device_get_total_bytes(dev);\n\tmemcpy(di_args->uuid, dev->uuid, sizeof(di_args->uuid));\n\tif (dev->name) {\n\t\tstruct rcu_string *name;\n\n\t\trcu_read_lock();\n\t\tname = rcu_dereference(dev->name);\n\t\tstrncpy(di_args->path, name->str, sizeof(di_args->path));\n\t\trcu_read_unlock();\n\t\tdi_args->path[sizeof(di_args->path) - 1] = 0;\n\t} else {\n\t\tdi_args->path[0] = '\\0';\n\t}\n\nout:\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\tif (ret == 0 && copy_to_user(arg, di_args, sizeof(*di_args)))\n\t\tret = -EFAULT;\n\n\tkfree(di_args);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_dev_info(struct btrfs_root *root, void __user *arg)\n{\n\tstruct btrfs_ioctl_dev_info_args *di_args;\n\tstruct btrfs_device *dev;\n\tstruct btrfs_fs_devices *fs_devices = root->fs_info->fs_devices;\n\tint ret = 0;\n\tchar *s_uuid = NULL;\n\n\tdi_args = memdup_user(arg, sizeof(*di_args));\n\tif (IS_ERR(di_args))\n\t\treturn PTR_ERR(di_args);\n\n\tif (!btrfs_is_empty_uuid(di_args->uuid))\n\t\ts_uuid = di_args->uuid;\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tdev = btrfs_find_device(root->fs_info, di_args->devid, s_uuid, NULL);\n\n\tif (!dev) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tdi_args->devid = dev->devid;\n\tdi_args->bytes_used = btrfs_device_get_bytes_used(dev);\n\tdi_args->total_bytes = btrfs_device_get_total_bytes(dev);\n\tmemcpy(di_args->uuid, dev->uuid, sizeof(di_args->uuid));\n\tif (dev->name) {\n\t\tstruct rcu_string *name;\n\n\t\trcu_read_lock();\n\t\tname = rcu_dereference(dev->name);\n\t\tstrncpy(di_args->path, name->str, sizeof(di_args->path));\n\t\trcu_read_unlock();\n\t\tdi_args->path[sizeof(di_args->path) - 1] = 0;\n\t} else {\n\t\tdi_args->path[0] = '\\0';\n\t}\n\nout:\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\tif (ret == 0 && copy_to_user(arg, di_args, sizeof(*di_args)))\n\t\tret = -EFAULT;\n\n\tkfree(di_args);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_fs_info",
          "args": [
            "root",
            "argp"
          ],
          "line": 5240
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_fs_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "2669-2700",
          "snippet": "static long btrfs_ioctl_fs_info(struct btrfs_root *root, void __user *arg)\n{\n\tstruct btrfs_ioctl_fs_info_args *fi_args;\n\tstruct btrfs_device *device;\n\tstruct btrfs_device *next;\n\tstruct btrfs_fs_devices *fs_devices = root->fs_info->fs_devices;\n\tint ret = 0;\n\n\tfi_args = kzalloc(sizeof(*fi_args), GFP_KERNEL);\n\tif (!fi_args)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tfi_args->num_devices = fs_devices->num_devices;\n\tmemcpy(&fi_args->fsid, root->fs_info->fsid, sizeof(fi_args->fsid));\n\n\tlist_for_each_entry_safe(device, next, &fs_devices->devices, dev_list) {\n\t\tif (device->devid > fi_args->max_id)\n\t\t\tfi_args->max_id = device->devid;\n\t}\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\tfi_args->nodesize = root->fs_info->super_copy->nodesize;\n\tfi_args->sectorsize = root->fs_info->super_copy->sectorsize;\n\tfi_args->clone_alignment = root->fs_info->super_copy->sectorsize;\n\n\tif (copy_to_user(arg, fi_args, sizeof(*fi_args)))\n\t\tret = -EFAULT;\n\n\tkfree(fi_args);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_fs_info(struct btrfs_root *root, void __user *arg)\n{\n\tstruct btrfs_ioctl_fs_info_args *fi_args;\n\tstruct btrfs_device *device;\n\tstruct btrfs_device *next;\n\tstruct btrfs_fs_devices *fs_devices = root->fs_info->fs_devices;\n\tint ret = 0;\n\n\tfi_args = kzalloc(sizeof(*fi_args), GFP_KERNEL);\n\tif (!fi_args)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tfi_args->num_devices = fs_devices->num_devices;\n\tmemcpy(&fi_args->fsid, root->fs_info->fsid, sizeof(fi_args->fsid));\n\n\tlist_for_each_entry_safe(device, next, &fs_devices->devices, dev_list) {\n\t\tif (device->devid > fi_args->max_id)\n\t\t\tfi_args->max_id = device->devid;\n\t}\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\tfi_args->nodesize = root->fs_info->super_copy->nodesize;\n\tfi_args->sectorsize = root->fs_info->super_copy->sectorsize;\n\tfi_args->clone_alignment = root->fs_info->super_copy->sectorsize;\n\n\tif (copy_to_user(arg, fi_args, sizeof(*fi_args)))\n\t\tret = -EFAULT;\n\n\tkfree(fi_args);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_rm_dev",
          "args": [
            "file",
            "argp"
          ],
          "line": 5238
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_rm_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "2627-2667",
          "snippet": "static long btrfs_ioctl_rm_dev(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tstruct btrfs_ioctl_vol_args *vol_args;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tvol_args = memdup_user(arg, sizeof(*vol_args));\n\tif (IS_ERR(vol_args)) {\n\t\tret = PTR_ERR(vol_args);\n\t\tgoto err_drop;\n\t}\n\n\tvol_args->name[BTRFS_PATH_NAME_MAX] = '\\0';\n\n\tif (atomic_xchg(&root->fs_info->mutually_exclusive_operation_running,\n\t\t\t1)) {\n\t\tret = BTRFS_ERROR_DEV_EXCL_RUN_IN_PROGRESS;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&root->fs_info->volume_mutex);\n\tret = btrfs_rm_device(root, vol_args->name);\n\tmutex_unlock(&root->fs_info->volume_mutex);\n\tatomic_set(&root->fs_info->mutually_exclusive_operation_running, 0);\n\n\tif (!ret)\n\t\tbtrfs_info(root->fs_info, \"disk deleted %s\",vol_args->name);\n\nout:\n\tkfree(vol_args);\nerr_drop:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_rm_dev(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tstruct btrfs_ioctl_vol_args *vol_args;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tvol_args = memdup_user(arg, sizeof(*vol_args));\n\tif (IS_ERR(vol_args)) {\n\t\tret = PTR_ERR(vol_args);\n\t\tgoto err_drop;\n\t}\n\n\tvol_args->name[BTRFS_PATH_NAME_MAX] = '\\0';\n\n\tif (atomic_xchg(&root->fs_info->mutually_exclusive_operation_running,\n\t\t\t1)) {\n\t\tret = BTRFS_ERROR_DEV_EXCL_RUN_IN_PROGRESS;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&root->fs_info->volume_mutex);\n\tret = btrfs_rm_device(root, vol_args->name);\n\tmutex_unlock(&root->fs_info->volume_mutex);\n\tatomic_set(&root->fs_info->mutually_exclusive_operation_running, 0);\n\n\tif (!ret)\n\t\tbtrfs_info(root->fs_info, \"disk deleted %s\",vol_args->name);\n\nout:\n\tkfree(vol_args);\nerr_drop:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_add_dev",
          "args": [
            "root",
            "argp"
          ],
          "line": 5236
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_add_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "2594-2625",
          "snippet": "static long btrfs_ioctl_add_dev(struct btrfs_root *root, void __user *arg)\n{\n\tstruct btrfs_ioctl_vol_args *vol_args;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (atomic_xchg(&root->fs_info->mutually_exclusive_operation_running,\n\t\t\t1)) {\n\t\treturn BTRFS_ERROR_DEV_EXCL_RUN_IN_PROGRESS;\n\t}\n\n\tmutex_lock(&root->fs_info->volume_mutex);\n\tvol_args = memdup_user(arg, sizeof(*vol_args));\n\tif (IS_ERR(vol_args)) {\n\t\tret = PTR_ERR(vol_args);\n\t\tgoto out;\n\t}\n\n\tvol_args->name[BTRFS_PATH_NAME_MAX] = '\\0';\n\tret = btrfs_init_new_device(root, vol_args->name);\n\n\tif (!ret)\n\t\tbtrfs_info(root->fs_info, \"disk added %s\",vol_args->name);\n\n\tkfree(vol_args);\nout:\n\tmutex_unlock(&root->fs_info->volume_mutex);\n\tatomic_set(&root->fs_info->mutually_exclusive_operation_running, 0);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_add_dev(struct btrfs_root *root, void __user *arg)\n{\n\tstruct btrfs_ioctl_vol_args *vol_args;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (atomic_xchg(&root->fs_info->mutually_exclusive_operation_running,\n\t\t\t1)) {\n\t\treturn BTRFS_ERROR_DEV_EXCL_RUN_IN_PROGRESS;\n\t}\n\n\tmutex_lock(&root->fs_info->volume_mutex);\n\tvol_args = memdup_user(arg, sizeof(*vol_args));\n\tif (IS_ERR(vol_args)) {\n\t\tret = PTR_ERR(vol_args);\n\t\tgoto out;\n\t}\n\n\tvol_args->name[BTRFS_PATH_NAME_MAX] = '\\0';\n\tret = btrfs_init_new_device(root, vol_args->name);\n\n\tif (!ret)\n\t\tbtrfs_info(root->fs_info, \"disk added %s\",vol_args->name);\n\n\tkfree(vol_args);\nout:\n\tmutex_unlock(&root->fs_info->volume_mutex);\n\tatomic_set(&root->fs_info->mutually_exclusive_operation_running, 0);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_resize",
          "args": [
            "file",
            "argp"
          ],
          "line": 5234
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_resize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "1450-1592",
          "snippet": "static noinline int btrfs_ioctl_resize(struct file *file,\n\t\t\t\t\tvoid __user *arg)\n{\n\tu64 new_size;\n\tu64 old_size;\n\tu64 devid = 1;\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tstruct btrfs_ioctl_vol_args *vol_args;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_device *device = NULL;\n\tchar *sizestr;\n\tchar *retptr;\n\tchar *devstr = NULL;\n\tint ret = 0;\n\tint mod = 0;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tif (atomic_xchg(&root->fs_info->mutually_exclusive_operation_running,\n\t\t\t1)) {\n\t\tmnt_drop_write_file(file);\n\t\treturn BTRFS_ERROR_DEV_EXCL_RUN_IN_PROGRESS;\n\t}\n\n\tmutex_lock(&root->fs_info->volume_mutex);\n\tvol_args = memdup_user(arg, sizeof(*vol_args));\n\tif (IS_ERR(vol_args)) {\n\t\tret = PTR_ERR(vol_args);\n\t\tgoto out;\n\t}\n\n\tvol_args->name[BTRFS_PATH_NAME_MAX] = '\\0';\n\n\tsizestr = vol_args->name;\n\tdevstr = strchr(sizestr, ':');\n\tif (devstr) {\n\t\tsizestr = devstr + 1;\n\t\t*devstr = '\\0';\n\t\tdevstr = vol_args->name;\n\t\tret = kstrtoull(devstr, 10, &devid);\n\t\tif (ret)\n\t\t\tgoto out_free;\n\t\tif (!devid) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t\tbtrfs_info(root->fs_info, \"resizing devid %llu\", devid);\n\t}\n\n\tdevice = btrfs_find_device(root->fs_info, devid, NULL, NULL);\n\tif (!device) {\n\t\tbtrfs_info(root->fs_info, \"resizer unable to find device %llu\",\n\t\t       devid);\n\t\tret = -ENODEV;\n\t\tgoto out_free;\n\t}\n\n\tif (!device->writeable) {\n\t\tbtrfs_info(root->fs_info,\n\t\t\t   \"resizer unable to apply on readonly device %llu\",\n\t\t       devid);\n\t\tret = -EPERM;\n\t\tgoto out_free;\n\t}\n\n\tif (!strcmp(sizestr, \"max\"))\n\t\tnew_size = device->bdev->bd_inode->i_size;\n\telse {\n\t\tif (sizestr[0] == '-') {\n\t\t\tmod = -1;\n\t\t\tsizestr++;\n\t\t} else if (sizestr[0] == '+') {\n\t\t\tmod = 1;\n\t\t\tsizestr++;\n\t\t}\n\t\tnew_size = memparse(sizestr, &retptr);\n\t\tif (*retptr != '\\0' || new_size == 0) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\tif (device->is_tgtdev_for_dev_replace) {\n\t\tret = -EPERM;\n\t\tgoto out_free;\n\t}\n\n\told_size = btrfs_device_get_total_bytes(device);\n\n\tif (mod < 0) {\n\t\tif (new_size > old_size) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t\tnew_size = old_size - new_size;\n\t} else if (mod > 0) {\n\t\tif (new_size > ULLONG_MAX - old_size) {\n\t\t\tret = -ERANGE;\n\t\t\tgoto out_free;\n\t\t}\n\t\tnew_size = old_size + new_size;\n\t}\n\n\tif (new_size < 256 * 1024 * 1024) {\n\t\tret = -EINVAL;\n\t\tgoto out_free;\n\t}\n\tif (new_size > device->bdev->bd_inode->i_size) {\n\t\tret = -EFBIG;\n\t\tgoto out_free;\n\t}\n\n\tdo_div(new_size, root->sectorsize);\n\tnew_size *= root->sectorsize;\n\n\tprintk_in_rcu(KERN_INFO \"BTRFS: new size for %s is %llu\\n\",\n\t\t      rcu_str_deref(device->name), new_size);\n\n\tif (new_size > old_size) {\n\t\ttrans = btrfs_start_transaction(root, 0);\n\t\tif (IS_ERR(trans)) {\n\t\t\tret = PTR_ERR(trans);\n\t\t\tgoto out_free;\n\t\t}\n\t\tret = btrfs_grow_device(trans, device, new_size);\n\t\tbtrfs_commit_transaction(trans, root);\n\t} else if (new_size < old_size) {\n\t\tret = btrfs_shrink_device(device, new_size);\n\t} /* equal, nothing need to do */\n\nout_free:\n\tkfree(vol_args);\nout:\n\tmutex_unlock(&root->fs_info->volume_mutex);\n\tatomic_set(&root->fs_info->mutually_exclusive_operation_running, 0);\n\tmnt_drop_write_file(file);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic noinline int btrfs_ioctl_resize(struct file *file,\n\t\t\t\t\tvoid __user *arg)\n{\n\tu64 new_size;\n\tu64 old_size;\n\tu64 devid = 1;\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tstruct btrfs_ioctl_vol_args *vol_args;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_device *device = NULL;\n\tchar *sizestr;\n\tchar *retptr;\n\tchar *devstr = NULL;\n\tint ret = 0;\n\tint mod = 0;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tif (atomic_xchg(&root->fs_info->mutually_exclusive_operation_running,\n\t\t\t1)) {\n\t\tmnt_drop_write_file(file);\n\t\treturn BTRFS_ERROR_DEV_EXCL_RUN_IN_PROGRESS;\n\t}\n\n\tmutex_lock(&root->fs_info->volume_mutex);\n\tvol_args = memdup_user(arg, sizeof(*vol_args));\n\tif (IS_ERR(vol_args)) {\n\t\tret = PTR_ERR(vol_args);\n\t\tgoto out;\n\t}\n\n\tvol_args->name[BTRFS_PATH_NAME_MAX] = '\\0';\n\n\tsizestr = vol_args->name;\n\tdevstr = strchr(sizestr, ':');\n\tif (devstr) {\n\t\tsizestr = devstr + 1;\n\t\t*devstr = '\\0';\n\t\tdevstr = vol_args->name;\n\t\tret = kstrtoull(devstr, 10, &devid);\n\t\tif (ret)\n\t\t\tgoto out_free;\n\t\tif (!devid) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t\tbtrfs_info(root->fs_info, \"resizing devid %llu\", devid);\n\t}\n\n\tdevice = btrfs_find_device(root->fs_info, devid, NULL, NULL);\n\tif (!device) {\n\t\tbtrfs_info(root->fs_info, \"resizer unable to find device %llu\",\n\t\t       devid);\n\t\tret = -ENODEV;\n\t\tgoto out_free;\n\t}\n\n\tif (!device->writeable) {\n\t\tbtrfs_info(root->fs_info,\n\t\t\t   \"resizer unable to apply on readonly device %llu\",\n\t\t       devid);\n\t\tret = -EPERM;\n\t\tgoto out_free;\n\t}\n\n\tif (!strcmp(sizestr, \"max\"))\n\t\tnew_size = device->bdev->bd_inode->i_size;\n\telse {\n\t\tif (sizestr[0] == '-') {\n\t\t\tmod = -1;\n\t\t\tsizestr++;\n\t\t} else if (sizestr[0] == '+') {\n\t\t\tmod = 1;\n\t\t\tsizestr++;\n\t\t}\n\t\tnew_size = memparse(sizestr, &retptr);\n\t\tif (*retptr != '\\0' || new_size == 0) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\tif (device->is_tgtdev_for_dev_replace) {\n\t\tret = -EPERM;\n\t\tgoto out_free;\n\t}\n\n\told_size = btrfs_device_get_total_bytes(device);\n\n\tif (mod < 0) {\n\t\tif (new_size > old_size) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t\tnew_size = old_size - new_size;\n\t} else if (mod > 0) {\n\t\tif (new_size > ULLONG_MAX - old_size) {\n\t\t\tret = -ERANGE;\n\t\t\tgoto out_free;\n\t\t}\n\t\tnew_size = old_size + new_size;\n\t}\n\n\tif (new_size < 256 * 1024 * 1024) {\n\t\tret = -EINVAL;\n\t\tgoto out_free;\n\t}\n\tif (new_size > device->bdev->bd_inode->i_size) {\n\t\tret = -EFBIG;\n\t\tgoto out_free;\n\t}\n\n\tdo_div(new_size, root->sectorsize);\n\tnew_size *= root->sectorsize;\n\n\tprintk_in_rcu(KERN_INFO \"BTRFS: new size for %s is %llu\\n\",\n\t\t      rcu_str_deref(device->name), new_size);\n\n\tif (new_size > old_size) {\n\t\ttrans = btrfs_start_transaction(root, 0);\n\t\tif (IS_ERR(trans)) {\n\t\t\tret = PTR_ERR(trans);\n\t\t\tgoto out_free;\n\t\t}\n\t\tret = btrfs_grow_device(trans, device, new_size);\n\t\tbtrfs_commit_transaction(trans, root);\n\t} else if (new_size < old_size) {\n\t\tret = btrfs_shrink_device(device, new_size);\n\t} /* equal, nothing need to do */\n\nout_free:\n\tkfree(vol_args);\nout:\n\tmutex_unlock(&root->fs_info->volume_mutex);\n\tatomic_set(&root->fs_info->mutually_exclusive_operation_running, 0);\n\tmnt_drop_write_file(file);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_defrag",
          "args": [
            "file",
            "argp"
          ],
          "line": 5232
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_defrag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "2525-2592",
          "snippet": "static int btrfs_ioctl_defrag(struct file *file, void __user *argp)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_ioctl_defrag_range_args *range;\n\tint ret;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tif (btrfs_root_readonly(root)) {\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tif (!capable(CAP_SYS_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = btrfs_defrag_root(root);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tret = btrfs_defrag_root(root->fs_info->extent_root);\n\t\tbreak;\n\tcase S_IFREG:\n\t\tif (!(file->f_mode & FMODE_WRITE)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\trange = kzalloc(sizeof(*range), GFP_KERNEL);\n\t\tif (!range) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (argp) {\n\t\t\tif (copy_from_user(range, argp,\n\t\t\t\t\t   sizeof(*range))) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tkfree(range);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t/* compression requires us to start the IO */\n\t\t\tif ((range->flags & BTRFS_DEFRAG_RANGE_COMPRESS)) {\n\t\t\t\trange->flags |= BTRFS_DEFRAG_RANGE_START_IO;\n\t\t\t\trange->extent_thresh = (u32)-1;\n\t\t\t}\n\t\t} else {\n\t\t\t/* the rest are all set to zero by kzalloc */\n\t\t\trange->len = (u64)-1;\n\t\t}\n\t\tret = btrfs_defrag_file(file_inode(file), file,\n\t\t\t\t\trange, 0, 0);\n\t\tif (ret > 0)\n\t\t\tret = 0;\n\t\tkfree(range);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\nout:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_ioctl_defrag(struct file *file, void __user *argp)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_ioctl_defrag_range_args *range;\n\tint ret;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tif (btrfs_root_readonly(root)) {\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tif (!capable(CAP_SYS_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = btrfs_defrag_root(root);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tret = btrfs_defrag_root(root->fs_info->extent_root);\n\t\tbreak;\n\tcase S_IFREG:\n\t\tif (!(file->f_mode & FMODE_WRITE)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\trange = kzalloc(sizeof(*range), GFP_KERNEL);\n\t\tif (!range) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (argp) {\n\t\t\tif (copy_from_user(range, argp,\n\t\t\t\t\t   sizeof(*range))) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tkfree(range);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t/* compression requires us to start the IO */\n\t\t\tif ((range->flags & BTRFS_DEFRAG_RANGE_COMPRESS)) {\n\t\t\t\trange->flags |= BTRFS_DEFRAG_RANGE_START_IO;\n\t\t\t\trange->extent_thresh = (u32)-1;\n\t\t\t}\n\t\t} else {\n\t\t\t/* the rest are all set to zero by kzalloc */\n\t\t\trange->len = (u64)-1;\n\t\t}\n\t\tret = btrfs_defrag_file(file_inode(file), file,\n\t\t\t\t\trange, 0, 0);\n\t\tif (ret > 0)\n\t\t\tret = 0;\n\t\tkfree(range);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\nout:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_default_subvol",
          "args": [
            "file",
            "argp"
          ],
          "line": 5228
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_default_subvol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "3756-3831",
          "snippet": "static long btrfs_ioctl_default_subvol(struct file *file, void __user *argp)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_root *new_root;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key location;\n\tstruct btrfs_disk_key disk_key;\n\tu64 objectid = 0;\n\tu64 dir_id;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_from_user(&objectid, argp, sizeof(objectid))) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (!objectid)\n\t\tobjectid = BTRFS_FS_TREE_OBJECTID;\n\n\tlocation.objectid = objectid;\n\tlocation.type = BTRFS_ROOT_ITEM_KEY;\n\tlocation.offset = (u64)-1;\n\n\tnew_root = btrfs_read_fs_root_no_name(root->fs_info, &location);\n\tif (IS_ERR(new_root)) {\n\t\tret = PTR_ERR(new_root);\n\t\tgoto out;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tpath->leave_spinning = 1;\n\n\ttrans = btrfs_start_transaction(root, 1);\n\tif (IS_ERR(trans)) {\n\t\tbtrfs_free_path(path);\n\t\tret = PTR_ERR(trans);\n\t\tgoto out;\n\t}\n\n\tdir_id = btrfs_super_root_dir(root->fs_info->super_copy);\n\tdi = btrfs_lookup_dir_item(trans, root->fs_info->tree_root, path,\n\t\t\t\t   dir_id, \"default\", 7, 1);\n\tif (IS_ERR_OR_NULL(di)) {\n\t\tbtrfs_free_path(path);\n\t\tbtrfs_end_transaction(trans, root);\n\t\tbtrfs_err(new_root->fs_info, \"Umm, you don't have the default dir\"\n\t\t\t   \"item, this isn't going to work\");\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tbtrfs_cpu_key_to_disk(&disk_key, &new_root->root_key);\n\tbtrfs_set_dir_item_key(path->nodes[0], di, &disk_key);\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\n\tbtrfs_free_path(path);\n\n\tbtrfs_set_fs_incompat(root->fs_info, DEFAULT_SUBVOL);\n\tbtrfs_end_transaction(trans, root);\nout:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_default_subvol(struct file *file, void __user *argp)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_root *new_root;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key location;\n\tstruct btrfs_disk_key disk_key;\n\tu64 objectid = 0;\n\tu64 dir_id;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_from_user(&objectid, argp, sizeof(objectid))) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (!objectid)\n\t\tobjectid = BTRFS_FS_TREE_OBJECTID;\n\n\tlocation.objectid = objectid;\n\tlocation.type = BTRFS_ROOT_ITEM_KEY;\n\tlocation.offset = (u64)-1;\n\n\tnew_root = btrfs_read_fs_root_no_name(root->fs_info, &location);\n\tif (IS_ERR(new_root)) {\n\t\tret = PTR_ERR(new_root);\n\t\tgoto out;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tpath->leave_spinning = 1;\n\n\ttrans = btrfs_start_transaction(root, 1);\n\tif (IS_ERR(trans)) {\n\t\tbtrfs_free_path(path);\n\t\tret = PTR_ERR(trans);\n\t\tgoto out;\n\t}\n\n\tdir_id = btrfs_super_root_dir(root->fs_info->super_copy);\n\tdi = btrfs_lookup_dir_item(trans, root->fs_info->tree_root, path,\n\t\t\t\t   dir_id, \"default\", 7, 1);\n\tif (IS_ERR_OR_NULL(di)) {\n\t\tbtrfs_free_path(path);\n\t\tbtrfs_end_transaction(trans, root);\n\t\tbtrfs_err(new_root->fs_info, \"Umm, you don't have the default dir\"\n\t\t\t   \"item, this isn't going to work\");\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tbtrfs_cpu_key_to_disk(&disk_key, &new_root->root_key);\n\tbtrfs_set_dir_item_key(path->nodes[0], di, &disk_key);\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\n\tbtrfs_free_path(path);\n\n\tbtrfs_set_fs_incompat(root->fs_info, DEFAULT_SUBVOL);\n\tbtrfs_end_transaction(trans, root);\nout:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_subvol_setflags",
          "args": [
            "file",
            "argp"
          ],
          "line": 5226
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_subvol_setflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "1751-1837",
          "snippet": "static noinline int btrfs_ioctl_subvol_setflags(struct file *file,\n\t\t\t\t\t      void __user *arg)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_trans_handle *trans;\n\tu64 root_flags;\n\tu64 flags;\n\tint ret = 0;\n\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\tgoto out;\n\n\tif (btrfs_ino(inode) != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tret = -EINVAL;\n\t\tgoto out_drop_write;\n\t}\n\n\tif (copy_from_user(&flags, arg, sizeof(flags))) {\n\t\tret = -EFAULT;\n\t\tgoto out_drop_write;\n\t}\n\n\tif (flags & BTRFS_SUBVOL_CREATE_ASYNC) {\n\t\tret = -EINVAL;\n\t\tgoto out_drop_write;\n\t}\n\n\tif (flags & ~BTRFS_SUBVOL_RDONLY) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out_drop_write;\n\t}\n\n\tdown_write(&root->fs_info->subvol_sem);\n\n\t/* nothing to do */\n\tif (!!(flags & BTRFS_SUBVOL_RDONLY) == btrfs_root_readonly(root))\n\t\tgoto out_drop_sem;\n\n\troot_flags = btrfs_root_flags(&root->root_item);\n\tif (flags & BTRFS_SUBVOL_RDONLY) {\n\t\tbtrfs_set_root_flags(&root->root_item,\n\t\t\t\t     root_flags | BTRFS_ROOT_SUBVOL_RDONLY);\n\t} else {\n\t\t/*\n\t\t * Block RO -> RW transition if this subvolume is involved in\n\t\t * send\n\t\t */\n\t\tspin_lock(&root->root_item_lock);\n\t\tif (root->send_in_progress == 0) {\n\t\t\tbtrfs_set_root_flags(&root->root_item,\n\t\t\t\t     root_flags & ~BTRFS_ROOT_SUBVOL_RDONLY);\n\t\t\tspin_unlock(&root->root_item_lock);\n\t\t} else {\n\t\t\tspin_unlock(&root->root_item_lock);\n\t\t\tbtrfs_warn(root->fs_info,\n\t\t\t\"Attempt to set subvolume %llu read-write during send\",\n\t\t\t\t\troot->root_key.objectid);\n\t\t\tret = -EPERM;\n\t\t\tgoto out_drop_sem;\n\t\t}\n\t}\n\n\ttrans = btrfs_start_transaction(root, 1);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out_reset;\n\t}\n\n\tret = btrfs_update_root(trans, root->fs_info->tree_root,\n\t\t\t\t&root->root_key, &root->root_item);\n\n\tbtrfs_commit_transaction(trans, root);\nout_reset:\n\tif (ret)\n\t\tbtrfs_set_root_flags(&root->root_item, root_flags);\nout_drop_sem:\n\tup_write(&root->fs_info->subvol_sem);\nout_drop_write:\n\tmnt_drop_write_file(file);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic noinline int btrfs_ioctl_subvol_setflags(struct file *file,\n\t\t\t\t\t      void __user *arg)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_trans_handle *trans;\n\tu64 root_flags;\n\tu64 flags;\n\tint ret = 0;\n\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\tgoto out;\n\n\tif (btrfs_ino(inode) != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tret = -EINVAL;\n\t\tgoto out_drop_write;\n\t}\n\n\tif (copy_from_user(&flags, arg, sizeof(flags))) {\n\t\tret = -EFAULT;\n\t\tgoto out_drop_write;\n\t}\n\n\tif (flags & BTRFS_SUBVOL_CREATE_ASYNC) {\n\t\tret = -EINVAL;\n\t\tgoto out_drop_write;\n\t}\n\n\tif (flags & ~BTRFS_SUBVOL_RDONLY) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out_drop_write;\n\t}\n\n\tdown_write(&root->fs_info->subvol_sem);\n\n\t/* nothing to do */\n\tif (!!(flags & BTRFS_SUBVOL_RDONLY) == btrfs_root_readonly(root))\n\t\tgoto out_drop_sem;\n\n\troot_flags = btrfs_root_flags(&root->root_item);\n\tif (flags & BTRFS_SUBVOL_RDONLY) {\n\t\tbtrfs_set_root_flags(&root->root_item,\n\t\t\t\t     root_flags | BTRFS_ROOT_SUBVOL_RDONLY);\n\t} else {\n\t\t/*\n\t\t * Block RO -> RW transition if this subvolume is involved in\n\t\t * send\n\t\t */\n\t\tspin_lock(&root->root_item_lock);\n\t\tif (root->send_in_progress == 0) {\n\t\t\tbtrfs_set_root_flags(&root->root_item,\n\t\t\t\t     root_flags & ~BTRFS_ROOT_SUBVOL_RDONLY);\n\t\t\tspin_unlock(&root->root_item_lock);\n\t\t} else {\n\t\t\tspin_unlock(&root->root_item_lock);\n\t\t\tbtrfs_warn(root->fs_info,\n\t\t\t\"Attempt to set subvolume %llu read-write during send\",\n\t\t\t\t\troot->root_key.objectid);\n\t\t\tret = -EPERM;\n\t\t\tgoto out_drop_sem;\n\t\t}\n\t}\n\n\ttrans = btrfs_start_transaction(root, 1);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out_reset;\n\t}\n\n\tret = btrfs_update_root(trans, root->fs_info->tree_root,\n\t\t\t\t&root->root_key, &root->root_item);\n\n\tbtrfs_commit_transaction(trans, root);\nout_reset:\n\tif (ret)\n\t\tbtrfs_set_root_flags(&root->root_item, root_flags);\nout_drop_sem:\n\tup_write(&root->fs_info->subvol_sem);\nout_drop_write:\n\tmnt_drop_write_file(file);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_subvol_getflags",
          "args": [
            "file",
            "argp"
          ],
          "line": 5224
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_subvol_getflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "1729-1749",
          "snippet": "static noinline int btrfs_ioctl_subvol_getflags(struct file *file,\n\t\t\t\t\t\tvoid __user *arg)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tint ret = 0;\n\tu64 flags = 0;\n\n\tif (btrfs_ino(inode) != BTRFS_FIRST_FREE_OBJECTID)\n\t\treturn -EINVAL;\n\n\tdown_read(&root->fs_info->subvol_sem);\n\tif (btrfs_root_readonly(root))\n\t\tflags |= BTRFS_SUBVOL_RDONLY;\n\tup_read(&root->fs_info->subvol_sem);\n\n\tif (copy_to_user(arg, &flags, sizeof(flags)))\n\t\tret = -EFAULT;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic noinline int btrfs_ioctl_subvol_getflags(struct file *file,\n\t\t\t\t\t\tvoid __user *arg)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tint ret = 0;\n\tu64 flags = 0;\n\n\tif (btrfs_ino(inode) != BTRFS_FIRST_FREE_OBJECTID)\n\t\treturn -EINVAL;\n\n\tdown_read(&root->fs_info->subvol_sem);\n\tif (btrfs_root_readonly(root))\n\t\tflags |= BTRFS_SUBVOL_RDONLY;\n\tup_read(&root->fs_info->subvol_sem);\n\n\tif (copy_to_user(arg, &flags, sizeof(flags)))\n\t\tret = -EFAULT;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_snap_destroy",
          "args": [
            "file",
            "argp"
          ],
          "line": 5222
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_snap_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "2292-2523",
          "snippet": "static noinline int btrfs_ioctl_snap_destroy(struct file *file,\n\t\t\t\t\t     void __user *arg)\n{\n\tstruct dentry *parent = file->f_path.dentry;\n\tstruct dentry *dentry;\n\tstruct inode *dir = parent->d_inode;\n\tstruct inode *inode;\n\tstruct btrfs_root *root = BTRFS_I(dir)->root;\n\tstruct btrfs_root *dest = NULL;\n\tstruct btrfs_ioctl_vol_args *vol_args;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_block_rsv block_rsv;\n\tu64 root_flags;\n\tu64 qgroup_reserved;\n\tint namelen;\n\tint ret;\n\tint err = 0;\n\n\tvol_args = memdup_user(arg, sizeof(*vol_args));\n\tif (IS_ERR(vol_args))\n\t\treturn PTR_ERR(vol_args);\n\n\tvol_args->name[BTRFS_PATH_NAME_MAX] = '\\0';\n\tnamelen = strlen(vol_args->name);\n\tif (strchr(vol_args->name, '/') ||\n\t    strncmp(vol_args->name, \"..\", namelen) == 0) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = mnt_want_write_file(file);\n\tif (err)\n\t\tgoto out;\n\n\n\terr = mutex_lock_killable_nested(&dir->i_mutex, I_MUTEX_PARENT);\n\tif (err == -EINTR)\n\t\tgoto out_drop_write;\n\tdentry = lookup_one_len(vol_args->name, parent, namelen);\n\tif (IS_ERR(dentry)) {\n\t\terr = PTR_ERR(dentry);\n\t\tgoto out_unlock_dir;\n\t}\n\n\tif (!dentry->d_inode) {\n\t\terr = -ENOENT;\n\t\tgoto out_dput;\n\t}\n\n\tinode = dentry->d_inode;\n\tdest = BTRFS_I(inode)->root;\n\tif (!capable(CAP_SYS_ADMIN)) {\n\t\t/*\n\t\t * Regular user.  Only allow this with a special mount\n\t\t * option, when the user has write+exec access to the\n\t\t * subvol root, and when rmdir(2) would have been\n\t\t * allowed.\n\t\t *\n\t\t * Note that this is _not_ check that the subvol is\n\t\t * empty or doesn't contain data that we wouldn't\n\t\t * otherwise be able to delete.\n\t\t *\n\t\t * Users who want to delete empty subvols should try\n\t\t * rmdir(2).\n\t\t */\n\t\terr = -EPERM;\n\t\tif (!btrfs_test_opt(root, USER_SUBVOL_RM_ALLOWED))\n\t\t\tgoto out_dput;\n\n\t\t/*\n\t\t * Do not allow deletion if the parent dir is the same\n\t\t * as the dir to be deleted.  That means the ioctl\n\t\t * must be called on the dentry referencing the root\n\t\t * of the subvol, not a random directory contained\n\t\t * within it.\n\t\t */\n\t\terr = -EINVAL;\n\t\tif (root == dest)\n\t\t\tgoto out_dput;\n\n\t\terr = inode_permission(inode, MAY_WRITE | MAY_EXEC);\n\t\tif (err)\n\t\t\tgoto out_dput;\n\t}\n\n\t/* check if subvolume may be deleted by a user */\n\terr = btrfs_may_delete(dir, dentry, 1);\n\tif (err)\n\t\tgoto out_dput;\n\n\tif (btrfs_ino(inode) != BTRFS_FIRST_FREE_OBJECTID) {\n\t\terr = -EINVAL;\n\t\tgoto out_dput;\n\t}\n\n\tmutex_lock(&inode->i_mutex);\n\n\t/*\n\t * Don't allow to delete a subvolume with send in progress. This is\n\t * inside the i_mutex so the error handling that has to drop the bit\n\t * again is not run concurrently.\n\t */\n\tspin_lock(&dest->root_item_lock);\n\troot_flags = btrfs_root_flags(&dest->root_item);\n\tif (dest->send_in_progress == 0) {\n\t\tbtrfs_set_root_flags(&dest->root_item,\n\t\t\t\troot_flags | BTRFS_ROOT_SUBVOL_DEAD);\n\t\tspin_unlock(&dest->root_item_lock);\n\t} else {\n\t\tspin_unlock(&dest->root_item_lock);\n\t\tbtrfs_warn(root->fs_info,\n\t\t\t\"Attempt to delete subvolume %llu during send\",\n\t\t\tdest->root_key.objectid);\n\t\terr = -EPERM;\n\t\tgoto out_dput;\n\t}\n\n\td_invalidate(dentry);\n\n\tdown_write(&root->fs_info->subvol_sem);\n\n\terr = may_destroy_subvol(dest);\n\tif (err)\n\t\tgoto out_up_write;\n\n\tbtrfs_init_block_rsv(&block_rsv, BTRFS_BLOCK_RSV_TEMP);\n\t/*\n\t * One for dir inode, two for dir entries, two for root\n\t * ref/backref.\n\t */\n\terr = btrfs_subvolume_reserve_metadata(root, &block_rsv,\n\t\t\t\t\t       5, &qgroup_reserved, true);\n\tif (err)\n\t\tgoto out_up_write;\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\terr = PTR_ERR(trans);\n\t\tgoto out_release;\n\t}\n\ttrans->block_rsv = &block_rsv;\n\ttrans->bytes_reserved = block_rsv.size;\n\n\tret = btrfs_unlink_subvol(trans, root, dir,\n\t\t\t\tdest->root_key.objectid,\n\t\t\t\tdentry->d_name.name,\n\t\t\t\tdentry->d_name.len);\n\tif (ret) {\n\t\terr = ret;\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto out_end_trans;\n\t}\n\n\tbtrfs_record_root_in_trans(trans, dest);\n\n\tmemset(&dest->root_item.drop_progress, 0,\n\t\tsizeof(dest->root_item.drop_progress));\n\tdest->root_item.drop_level = 0;\n\tbtrfs_set_root_refs(&dest->root_item, 0);\n\n\tif (!test_and_set_bit(BTRFS_ROOT_ORPHAN_ITEM_INSERTED, &dest->state)) {\n\t\tret = btrfs_insert_orphan_item(trans,\n\t\t\t\t\troot->fs_info->tree_root,\n\t\t\t\t\tdest->root_key.objectid);\n\t\tif (ret) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\terr = ret;\n\t\t\tgoto out_end_trans;\n\t\t}\n\t}\n\n\tret = btrfs_uuid_tree_rem(trans, root->fs_info->uuid_root,\n\t\t\t\t  dest->root_item.uuid, BTRFS_UUID_KEY_SUBVOL,\n\t\t\t\t  dest->root_key.objectid);\n\tif (ret && ret != -ENOENT) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\terr = ret;\n\t\tgoto out_end_trans;\n\t}\n\tif (!btrfs_is_empty_uuid(dest->root_item.received_uuid)) {\n\t\tret = btrfs_uuid_tree_rem(trans, root->fs_info->uuid_root,\n\t\t\t\t\t  dest->root_item.received_uuid,\n\t\t\t\t\t  BTRFS_UUID_KEY_RECEIVED_SUBVOL,\n\t\t\t\t\t  dest->root_key.objectid);\n\t\tif (ret && ret != -ENOENT) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\terr = ret;\n\t\t\tgoto out_end_trans;\n\t\t}\n\t}\n\nout_end_trans:\n\ttrans->block_rsv = NULL;\n\ttrans->bytes_reserved = 0;\n\tret = btrfs_end_transaction(trans, root);\n\tif (ret && !err)\n\t\terr = ret;\n\tinode->i_flags |= S_DEAD;\nout_release:\n\tbtrfs_subvolume_release_metadata(root, &block_rsv, qgroup_reserved);\nout_up_write:\n\tup_write(&root->fs_info->subvol_sem);\n\tif (err) {\n\t\tspin_lock(&dest->root_item_lock);\n\t\troot_flags = btrfs_root_flags(&dest->root_item);\n\t\tbtrfs_set_root_flags(&dest->root_item,\n\t\t\t\troot_flags & ~BTRFS_ROOT_SUBVOL_DEAD);\n\t\tspin_unlock(&dest->root_item_lock);\n\t}\n\tmutex_unlock(&inode->i_mutex);\n\tif (!err) {\n\t\tshrink_dcache_sb(root->fs_info->sb);\n\t\tbtrfs_invalidate_inodes(dest);\n\t\td_delete(dentry);\n\t\tASSERT(dest->send_in_progress == 0);\n\n\t\t/* the last ref */\n\t\tif (dest->ino_cache_inode) {\n\t\t\tiput(dest->ino_cache_inode);\n\t\t\tdest->ino_cache_inode = NULL;\n\t\t}\n\t}\nout_dput:\n\tdput(dentry);\nout_unlock_dir:\n\tmutex_unlock(&dir->i_mutex);\nout_drop_write:\n\tmnt_drop_write_file(file);\nout:\n\tkfree(vol_args);\n\treturn err;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic noinline int btrfs_ioctl_snap_destroy(struct file *file,\n\t\t\t\t\t     void __user *arg)\n{\n\tstruct dentry *parent = file->f_path.dentry;\n\tstruct dentry *dentry;\n\tstruct inode *dir = parent->d_inode;\n\tstruct inode *inode;\n\tstruct btrfs_root *root = BTRFS_I(dir)->root;\n\tstruct btrfs_root *dest = NULL;\n\tstruct btrfs_ioctl_vol_args *vol_args;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_block_rsv block_rsv;\n\tu64 root_flags;\n\tu64 qgroup_reserved;\n\tint namelen;\n\tint ret;\n\tint err = 0;\n\n\tvol_args = memdup_user(arg, sizeof(*vol_args));\n\tif (IS_ERR(vol_args))\n\t\treturn PTR_ERR(vol_args);\n\n\tvol_args->name[BTRFS_PATH_NAME_MAX] = '\\0';\n\tnamelen = strlen(vol_args->name);\n\tif (strchr(vol_args->name, '/') ||\n\t    strncmp(vol_args->name, \"..\", namelen) == 0) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = mnt_want_write_file(file);\n\tif (err)\n\t\tgoto out;\n\n\n\terr = mutex_lock_killable_nested(&dir->i_mutex, I_MUTEX_PARENT);\n\tif (err == -EINTR)\n\t\tgoto out_drop_write;\n\tdentry = lookup_one_len(vol_args->name, parent, namelen);\n\tif (IS_ERR(dentry)) {\n\t\terr = PTR_ERR(dentry);\n\t\tgoto out_unlock_dir;\n\t}\n\n\tif (!dentry->d_inode) {\n\t\terr = -ENOENT;\n\t\tgoto out_dput;\n\t}\n\n\tinode = dentry->d_inode;\n\tdest = BTRFS_I(inode)->root;\n\tif (!capable(CAP_SYS_ADMIN)) {\n\t\t/*\n\t\t * Regular user.  Only allow this with a special mount\n\t\t * option, when the user has write+exec access to the\n\t\t * subvol root, and when rmdir(2) would have been\n\t\t * allowed.\n\t\t *\n\t\t * Note that this is _not_ check that the subvol is\n\t\t * empty or doesn't contain data that we wouldn't\n\t\t * otherwise be able to delete.\n\t\t *\n\t\t * Users who want to delete empty subvols should try\n\t\t * rmdir(2).\n\t\t */\n\t\terr = -EPERM;\n\t\tif (!btrfs_test_opt(root, USER_SUBVOL_RM_ALLOWED))\n\t\t\tgoto out_dput;\n\n\t\t/*\n\t\t * Do not allow deletion if the parent dir is the same\n\t\t * as the dir to be deleted.  That means the ioctl\n\t\t * must be called on the dentry referencing the root\n\t\t * of the subvol, not a random directory contained\n\t\t * within it.\n\t\t */\n\t\terr = -EINVAL;\n\t\tif (root == dest)\n\t\t\tgoto out_dput;\n\n\t\terr = inode_permission(inode, MAY_WRITE | MAY_EXEC);\n\t\tif (err)\n\t\t\tgoto out_dput;\n\t}\n\n\t/* check if subvolume may be deleted by a user */\n\terr = btrfs_may_delete(dir, dentry, 1);\n\tif (err)\n\t\tgoto out_dput;\n\n\tif (btrfs_ino(inode) != BTRFS_FIRST_FREE_OBJECTID) {\n\t\terr = -EINVAL;\n\t\tgoto out_dput;\n\t}\n\n\tmutex_lock(&inode->i_mutex);\n\n\t/*\n\t * Don't allow to delete a subvolume with send in progress. This is\n\t * inside the i_mutex so the error handling that has to drop the bit\n\t * again is not run concurrently.\n\t */\n\tspin_lock(&dest->root_item_lock);\n\troot_flags = btrfs_root_flags(&dest->root_item);\n\tif (dest->send_in_progress == 0) {\n\t\tbtrfs_set_root_flags(&dest->root_item,\n\t\t\t\troot_flags | BTRFS_ROOT_SUBVOL_DEAD);\n\t\tspin_unlock(&dest->root_item_lock);\n\t} else {\n\t\tspin_unlock(&dest->root_item_lock);\n\t\tbtrfs_warn(root->fs_info,\n\t\t\t\"Attempt to delete subvolume %llu during send\",\n\t\t\tdest->root_key.objectid);\n\t\terr = -EPERM;\n\t\tgoto out_dput;\n\t}\n\n\td_invalidate(dentry);\n\n\tdown_write(&root->fs_info->subvol_sem);\n\n\terr = may_destroy_subvol(dest);\n\tif (err)\n\t\tgoto out_up_write;\n\n\tbtrfs_init_block_rsv(&block_rsv, BTRFS_BLOCK_RSV_TEMP);\n\t/*\n\t * One for dir inode, two for dir entries, two for root\n\t * ref/backref.\n\t */\n\terr = btrfs_subvolume_reserve_metadata(root, &block_rsv,\n\t\t\t\t\t       5, &qgroup_reserved, true);\n\tif (err)\n\t\tgoto out_up_write;\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\terr = PTR_ERR(trans);\n\t\tgoto out_release;\n\t}\n\ttrans->block_rsv = &block_rsv;\n\ttrans->bytes_reserved = block_rsv.size;\n\n\tret = btrfs_unlink_subvol(trans, root, dir,\n\t\t\t\tdest->root_key.objectid,\n\t\t\t\tdentry->d_name.name,\n\t\t\t\tdentry->d_name.len);\n\tif (ret) {\n\t\terr = ret;\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto out_end_trans;\n\t}\n\n\tbtrfs_record_root_in_trans(trans, dest);\n\n\tmemset(&dest->root_item.drop_progress, 0,\n\t\tsizeof(dest->root_item.drop_progress));\n\tdest->root_item.drop_level = 0;\n\tbtrfs_set_root_refs(&dest->root_item, 0);\n\n\tif (!test_and_set_bit(BTRFS_ROOT_ORPHAN_ITEM_INSERTED, &dest->state)) {\n\t\tret = btrfs_insert_orphan_item(trans,\n\t\t\t\t\troot->fs_info->tree_root,\n\t\t\t\t\tdest->root_key.objectid);\n\t\tif (ret) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\terr = ret;\n\t\t\tgoto out_end_trans;\n\t\t}\n\t}\n\n\tret = btrfs_uuid_tree_rem(trans, root->fs_info->uuid_root,\n\t\t\t\t  dest->root_item.uuid, BTRFS_UUID_KEY_SUBVOL,\n\t\t\t\t  dest->root_key.objectid);\n\tif (ret && ret != -ENOENT) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\terr = ret;\n\t\tgoto out_end_trans;\n\t}\n\tif (!btrfs_is_empty_uuid(dest->root_item.received_uuid)) {\n\t\tret = btrfs_uuid_tree_rem(trans, root->fs_info->uuid_root,\n\t\t\t\t\t  dest->root_item.received_uuid,\n\t\t\t\t\t  BTRFS_UUID_KEY_RECEIVED_SUBVOL,\n\t\t\t\t\t  dest->root_key.objectid);\n\t\tif (ret && ret != -ENOENT) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\terr = ret;\n\t\t\tgoto out_end_trans;\n\t\t}\n\t}\n\nout_end_trans:\n\ttrans->block_rsv = NULL;\n\ttrans->bytes_reserved = 0;\n\tret = btrfs_end_transaction(trans, root);\n\tif (ret && !err)\n\t\terr = ret;\n\tinode->i_flags |= S_DEAD;\nout_release:\n\tbtrfs_subvolume_release_metadata(root, &block_rsv, qgroup_reserved);\nout_up_write:\n\tup_write(&root->fs_info->subvol_sem);\n\tif (err) {\n\t\tspin_lock(&dest->root_item_lock);\n\t\troot_flags = btrfs_root_flags(&dest->root_item);\n\t\tbtrfs_set_root_flags(&dest->root_item,\n\t\t\t\troot_flags & ~BTRFS_ROOT_SUBVOL_DEAD);\n\t\tspin_unlock(&dest->root_item_lock);\n\t}\n\tmutex_unlock(&inode->i_mutex);\n\tif (!err) {\n\t\tshrink_dcache_sb(root->fs_info->sb);\n\t\tbtrfs_invalidate_inodes(dest);\n\t\td_delete(dentry);\n\t\tASSERT(dest->send_in_progress == 0);\n\n\t\t/* the last ref */\n\t\tif (dest->ino_cache_inode) {\n\t\t\tiput(dest->ino_cache_inode);\n\t\t\tdest->ino_cache_inode = NULL;\n\t\t}\n\t}\nout_dput:\n\tdput(dentry);\nout_unlock_dir:\n\tmutex_unlock(&dir->i_mutex);\nout_drop_write:\n\tmnt_drop_write_file(file);\nout:\n\tkfree(vol_args);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_snap_create_v2",
          "args": [
            "file",
            "argp",
            "1"
          ],
          "line": 5220
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_snap_create_v2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "1672-1727",
          "snippet": "static noinline int btrfs_ioctl_snap_create_v2(struct file *file,\n\t\t\t\t\t       void __user *arg, int subvol)\n{\n\tstruct btrfs_ioctl_vol_args_v2 *vol_args;\n\tint ret;\n\tu64 transid = 0;\n\tu64 *ptr = NULL;\n\tbool readonly = false;\n\tstruct btrfs_qgroup_inherit *inherit = NULL;\n\n\tvol_args = memdup_user(arg, sizeof(*vol_args));\n\tif (IS_ERR(vol_args))\n\t\treturn PTR_ERR(vol_args);\n\tvol_args->name[BTRFS_SUBVOL_NAME_MAX] = '\\0';\n\n\tif (vol_args->flags &\n\t    ~(BTRFS_SUBVOL_CREATE_ASYNC | BTRFS_SUBVOL_RDONLY |\n\t      BTRFS_SUBVOL_QGROUP_INHERIT)) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto free_args;\n\t}\n\n\tif (vol_args->flags & BTRFS_SUBVOL_CREATE_ASYNC)\n\t\tptr = &transid;\n\tif (vol_args->flags & BTRFS_SUBVOL_RDONLY)\n\t\treadonly = true;\n\tif (vol_args->flags & BTRFS_SUBVOL_QGROUP_INHERIT) {\n\t\tif (vol_args->size > PAGE_CACHE_SIZE) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto free_args;\n\t\t}\n\t\tinherit = memdup_user(vol_args->qgroup_inherit, vol_args->size);\n\t\tif (IS_ERR(inherit)) {\n\t\t\tret = PTR_ERR(inherit);\n\t\t\tgoto free_args;\n\t\t}\n\t}\n\n\tret = btrfs_ioctl_snap_create_transid(file, vol_args->name,\n\t\t\t\t\t      vol_args->fd, subvol, ptr,\n\t\t\t\t\t      readonly, inherit);\n\tif (ret)\n\t\tgoto free_inherit;\n\n\tif (ptr && copy_to_user(arg +\n\t\t\t\toffsetof(struct btrfs_ioctl_vol_args_v2,\n\t\t\t\t\ttransid),\n\t\t\t\tptr, sizeof(*ptr)))\n\t\tret = -EFAULT;\n\nfree_inherit:\n\tkfree(inherit);\nfree_args:\n\tkfree(vol_args);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic noinline int btrfs_ioctl_snap_create_v2(struct file *file,\n\t\t\t\t\t       void __user *arg, int subvol)\n{\n\tstruct btrfs_ioctl_vol_args_v2 *vol_args;\n\tint ret;\n\tu64 transid = 0;\n\tu64 *ptr = NULL;\n\tbool readonly = false;\n\tstruct btrfs_qgroup_inherit *inherit = NULL;\n\n\tvol_args = memdup_user(arg, sizeof(*vol_args));\n\tif (IS_ERR(vol_args))\n\t\treturn PTR_ERR(vol_args);\n\tvol_args->name[BTRFS_SUBVOL_NAME_MAX] = '\\0';\n\n\tif (vol_args->flags &\n\t    ~(BTRFS_SUBVOL_CREATE_ASYNC | BTRFS_SUBVOL_RDONLY |\n\t      BTRFS_SUBVOL_QGROUP_INHERIT)) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto free_args;\n\t}\n\n\tif (vol_args->flags & BTRFS_SUBVOL_CREATE_ASYNC)\n\t\tptr = &transid;\n\tif (vol_args->flags & BTRFS_SUBVOL_RDONLY)\n\t\treadonly = true;\n\tif (vol_args->flags & BTRFS_SUBVOL_QGROUP_INHERIT) {\n\t\tif (vol_args->size > PAGE_CACHE_SIZE) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto free_args;\n\t\t}\n\t\tinherit = memdup_user(vol_args->qgroup_inherit, vol_args->size);\n\t\tif (IS_ERR(inherit)) {\n\t\t\tret = PTR_ERR(inherit);\n\t\t\tgoto free_args;\n\t\t}\n\t}\n\n\tret = btrfs_ioctl_snap_create_transid(file, vol_args->name,\n\t\t\t\t\t      vol_args->fd, subvol, ptr,\n\t\t\t\t\t      readonly, inherit);\n\tif (ret)\n\t\tgoto free_inherit;\n\n\tif (ptr && copy_to_user(arg +\n\t\t\t\toffsetof(struct btrfs_ioctl_vol_args_v2,\n\t\t\t\t\ttransid),\n\t\t\t\tptr, sizeof(*ptr)))\n\t\tret = -EFAULT;\n\nfree_inherit:\n\tkfree(inherit);\nfree_args:\n\tkfree(vol_args);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_fitrim",
          "args": [
            "file",
            "argp"
          ],
          "line": 5212
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_fitrim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "372-418",
          "snippet": "static noinline int btrfs_ioctl_fitrim(struct file *file, void __user *arg)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(file_inode(file)->i_sb);\n\tstruct btrfs_device *device;\n\tstruct request_queue *q;\n\tstruct fstrim_range range;\n\tu64 minlen = ULLONG_MAX;\n\tu64 num_devices = 0;\n\tu64 total_bytes = btrfs_super_total_bytes(fs_info->super_copy);\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(device, &fs_info->fs_devices->devices,\n\t\t\t\tdev_list) {\n\t\tif (!device->bdev)\n\t\t\tcontinue;\n\t\tq = bdev_get_queue(device->bdev);\n\t\tif (blk_queue_discard(q)) {\n\t\t\tnum_devices++;\n\t\t\tminlen = min((u64)q->limits.discard_granularity,\n\t\t\t\t     minlen);\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (!num_devices)\n\t\treturn -EOPNOTSUPP;\n\tif (copy_from_user(&range, arg, sizeof(range)))\n\t\treturn -EFAULT;\n\tif (range.start > total_bytes ||\n\t    range.len < fs_info->sb->s_blocksize)\n\t\treturn -EINVAL;\n\n\trange.len = min(range.len, total_bytes - range.start);\n\trange.minlen = max(range.minlen, minlen);\n\tret = btrfs_trim_fs(fs_info->tree_root, &range);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (copy_to_user(arg, &range, sizeof(range)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic noinline int btrfs_ioctl_fitrim(struct file *file, void __user *arg)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(file_inode(file)->i_sb);\n\tstruct btrfs_device *device;\n\tstruct request_queue *q;\n\tstruct fstrim_range range;\n\tu64 minlen = ULLONG_MAX;\n\tu64 num_devices = 0;\n\tu64 total_bytes = btrfs_super_total_bytes(fs_info->super_copy);\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(device, &fs_info->fs_devices->devices,\n\t\t\t\tdev_list) {\n\t\tif (!device->bdev)\n\t\t\tcontinue;\n\t\tq = bdev_get_queue(device->bdev);\n\t\tif (blk_queue_discard(q)) {\n\t\t\tnum_devices++;\n\t\t\tminlen = min((u64)q->limits.discard_granularity,\n\t\t\t\t     minlen);\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (!num_devices)\n\t\treturn -EOPNOTSUPP;\n\tif (copy_from_user(&range, arg, sizeof(range)))\n\t\treturn -EFAULT;\n\tif (range.start > total_bytes ||\n\t    range.len < fs_info->sb->s_blocksize)\n\t\treturn -EINVAL;\n\n\trange.len = min(range.len, total_bytes - range.start);\n\trange.minlen = max(range.minlen, minlen);\n\tret = btrfs_trim_fs(fs_info->tree_root, &range);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (copy_to_user(arg, &range, sizeof(range)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_getversion",
          "args": [
            "file",
            "argp"
          ],
          "line": 5210
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_getversion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "365-370",
          "snippet": "static int btrfs_ioctl_getversion(struct file *file, int __user *arg)\n{\n\tstruct inode *inode = file_inode(file);\n\n\treturn put_user(inode->i_generation, arg);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_ioctl_getversion(struct file *file, int __user *arg)\n{\n\tstruct inode *inode = file_inode(file);\n\n\treturn put_user(inode->i_generation, arg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_setflags",
          "args": [
            "file",
            "argp"
          ],
          "line": 5208
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_setflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "213-363",
          "snippet": "static int btrfs_ioctl_setflags(struct file *file, void __user *arg)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_inode *ip = BTRFS_I(inode);\n\tstruct btrfs_root *root = ip->root;\n\tstruct btrfs_trans_handle *trans;\n\tunsigned int flags, oldflags;\n\tint ret;\n\tu64 ip_oldflags;\n\tunsigned int i_oldflags;\n\tumode_t mode;\n\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EPERM;\n\n\tif (btrfs_root_readonly(root))\n\t\treturn -EROFS;\n\n\tif (copy_from_user(&flags, arg, sizeof(flags)))\n\t\treturn -EFAULT;\n\n\tret = check_flags(flags);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&inode->i_mutex);\n\n\tip_oldflags = ip->flags;\n\ti_oldflags = inode->i_flags;\n\tmode = inode->i_mode;\n\n\tflags = btrfs_mask_flags(inode->i_mode, flags);\n\toldflags = btrfs_flags_to_ioctl(ip->flags);\n\tif ((flags ^ oldflags) & (FS_APPEND_FL | FS_IMMUTABLE_FL)) {\n\t\tif (!capable(CAP_LINUX_IMMUTABLE)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tif (flags & FS_SYNC_FL)\n\t\tip->flags |= BTRFS_INODE_SYNC;\n\telse\n\t\tip->flags &= ~BTRFS_INODE_SYNC;\n\tif (flags & FS_IMMUTABLE_FL)\n\t\tip->flags |= BTRFS_INODE_IMMUTABLE;\n\telse\n\t\tip->flags &= ~BTRFS_INODE_IMMUTABLE;\n\tif (flags & FS_APPEND_FL)\n\t\tip->flags |= BTRFS_INODE_APPEND;\n\telse\n\t\tip->flags &= ~BTRFS_INODE_APPEND;\n\tif (flags & FS_NODUMP_FL)\n\t\tip->flags |= BTRFS_INODE_NODUMP;\n\telse\n\t\tip->flags &= ~BTRFS_INODE_NODUMP;\n\tif (flags & FS_NOATIME_FL)\n\t\tip->flags |= BTRFS_INODE_NOATIME;\n\telse\n\t\tip->flags &= ~BTRFS_INODE_NOATIME;\n\tif (flags & FS_DIRSYNC_FL)\n\t\tip->flags |= BTRFS_INODE_DIRSYNC;\n\telse\n\t\tip->flags &= ~BTRFS_INODE_DIRSYNC;\n\tif (flags & FS_NOCOW_FL) {\n\t\tif (S_ISREG(mode)) {\n\t\t\t/*\n\t\t\t * It's safe to turn csums off here, no extents exist.\n\t\t\t * Otherwise we want the flag to reflect the real COW\n\t\t\t * status of the file and will not set it.\n\t\t\t */\n\t\t\tif (inode->i_size == 0)\n\t\t\t\tip->flags |= BTRFS_INODE_NODATACOW\n\t\t\t\t\t   | BTRFS_INODE_NODATASUM;\n\t\t} else {\n\t\t\tip->flags |= BTRFS_INODE_NODATACOW;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Revert back under same assuptions as above\n\t\t */\n\t\tif (S_ISREG(mode)) {\n\t\t\tif (inode->i_size == 0)\n\t\t\t\tip->flags &= ~(BTRFS_INODE_NODATACOW\n\t\t\t\t             | BTRFS_INODE_NODATASUM);\n\t\t} else {\n\t\t\tip->flags &= ~BTRFS_INODE_NODATACOW;\n\t\t}\n\t}\n\n\t/*\n\t * The COMPRESS flag can only be changed by users, while the NOCOMPRESS\n\t * flag may be changed automatically if compression code won't make\n\t * things smaller.\n\t */\n\tif (flags & FS_NOCOMP_FL) {\n\t\tip->flags &= ~BTRFS_INODE_COMPRESS;\n\t\tip->flags |= BTRFS_INODE_NOCOMPRESS;\n\n\t\tret = btrfs_set_prop(inode, \"btrfs.compression\", NULL, 0, 0);\n\t\tif (ret && ret != -ENODATA)\n\t\t\tgoto out_drop;\n\t} else if (flags & FS_COMPR_FL) {\n\t\tconst char *comp;\n\n\t\tip->flags |= BTRFS_INODE_COMPRESS;\n\t\tip->flags &= ~BTRFS_INODE_NOCOMPRESS;\n\n\t\tif (root->fs_info->compress_type == BTRFS_COMPRESS_LZO)\n\t\t\tcomp = \"lzo\";\n\t\telse\n\t\t\tcomp = \"zlib\";\n\t\tret = btrfs_set_prop(inode, \"btrfs.compression\",\n\t\t\t\t     comp, strlen(comp), 0);\n\t\tif (ret)\n\t\t\tgoto out_drop;\n\n\t} else {\n\t\tret = btrfs_set_prop(inode, \"btrfs.compression\", NULL, 0, 0);\n\t\tif (ret && ret != -ENODATA)\n\t\t\tgoto out_drop;\n\t\tip->flags &= ~(BTRFS_INODE_COMPRESS | BTRFS_INODE_NOCOMPRESS);\n\t}\n\n\ttrans = btrfs_start_transaction(root, 1);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out_drop;\n\t}\n\n\tbtrfs_update_iflags(inode);\n\tinode_inc_iversion(inode);\n\tinode->i_ctime = CURRENT_TIME;\n\tret = btrfs_update_inode(trans, root, inode);\n\n\tbtrfs_end_transaction(trans, root);\n out_drop:\n\tif (ret) {\n\t\tip->flags = ip_oldflags;\n\t\tinode->i_flags = i_oldflags;\n\t}\n\n out_unlock:\n\tmutex_unlock(&inode->i_mutex);\n\tmnt_drop_write_file(file);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_ioctl_setflags(struct file *file, void __user *arg)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_inode *ip = BTRFS_I(inode);\n\tstruct btrfs_root *root = ip->root;\n\tstruct btrfs_trans_handle *trans;\n\tunsigned int flags, oldflags;\n\tint ret;\n\tu64 ip_oldflags;\n\tunsigned int i_oldflags;\n\tumode_t mode;\n\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EPERM;\n\n\tif (btrfs_root_readonly(root))\n\t\treturn -EROFS;\n\n\tif (copy_from_user(&flags, arg, sizeof(flags)))\n\t\treturn -EFAULT;\n\n\tret = check_flags(flags);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&inode->i_mutex);\n\n\tip_oldflags = ip->flags;\n\ti_oldflags = inode->i_flags;\n\tmode = inode->i_mode;\n\n\tflags = btrfs_mask_flags(inode->i_mode, flags);\n\toldflags = btrfs_flags_to_ioctl(ip->flags);\n\tif ((flags ^ oldflags) & (FS_APPEND_FL | FS_IMMUTABLE_FL)) {\n\t\tif (!capable(CAP_LINUX_IMMUTABLE)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tif (flags & FS_SYNC_FL)\n\t\tip->flags |= BTRFS_INODE_SYNC;\n\telse\n\t\tip->flags &= ~BTRFS_INODE_SYNC;\n\tif (flags & FS_IMMUTABLE_FL)\n\t\tip->flags |= BTRFS_INODE_IMMUTABLE;\n\telse\n\t\tip->flags &= ~BTRFS_INODE_IMMUTABLE;\n\tif (flags & FS_APPEND_FL)\n\t\tip->flags |= BTRFS_INODE_APPEND;\n\telse\n\t\tip->flags &= ~BTRFS_INODE_APPEND;\n\tif (flags & FS_NODUMP_FL)\n\t\tip->flags |= BTRFS_INODE_NODUMP;\n\telse\n\t\tip->flags &= ~BTRFS_INODE_NODUMP;\n\tif (flags & FS_NOATIME_FL)\n\t\tip->flags |= BTRFS_INODE_NOATIME;\n\telse\n\t\tip->flags &= ~BTRFS_INODE_NOATIME;\n\tif (flags & FS_DIRSYNC_FL)\n\t\tip->flags |= BTRFS_INODE_DIRSYNC;\n\telse\n\t\tip->flags &= ~BTRFS_INODE_DIRSYNC;\n\tif (flags & FS_NOCOW_FL) {\n\t\tif (S_ISREG(mode)) {\n\t\t\t/*\n\t\t\t * It's safe to turn csums off here, no extents exist.\n\t\t\t * Otherwise we want the flag to reflect the real COW\n\t\t\t * status of the file and will not set it.\n\t\t\t */\n\t\t\tif (inode->i_size == 0)\n\t\t\t\tip->flags |= BTRFS_INODE_NODATACOW\n\t\t\t\t\t   | BTRFS_INODE_NODATASUM;\n\t\t} else {\n\t\t\tip->flags |= BTRFS_INODE_NODATACOW;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Revert back under same assuptions as above\n\t\t */\n\t\tif (S_ISREG(mode)) {\n\t\t\tif (inode->i_size == 0)\n\t\t\t\tip->flags &= ~(BTRFS_INODE_NODATACOW\n\t\t\t\t             | BTRFS_INODE_NODATASUM);\n\t\t} else {\n\t\t\tip->flags &= ~BTRFS_INODE_NODATACOW;\n\t\t}\n\t}\n\n\t/*\n\t * The COMPRESS flag can only be changed by users, while the NOCOMPRESS\n\t * flag may be changed automatically if compression code won't make\n\t * things smaller.\n\t */\n\tif (flags & FS_NOCOMP_FL) {\n\t\tip->flags &= ~BTRFS_INODE_COMPRESS;\n\t\tip->flags |= BTRFS_INODE_NOCOMPRESS;\n\n\t\tret = btrfs_set_prop(inode, \"btrfs.compression\", NULL, 0, 0);\n\t\tif (ret && ret != -ENODATA)\n\t\t\tgoto out_drop;\n\t} else if (flags & FS_COMPR_FL) {\n\t\tconst char *comp;\n\n\t\tip->flags |= BTRFS_INODE_COMPRESS;\n\t\tip->flags &= ~BTRFS_INODE_NOCOMPRESS;\n\n\t\tif (root->fs_info->compress_type == BTRFS_COMPRESS_LZO)\n\t\t\tcomp = \"lzo\";\n\t\telse\n\t\t\tcomp = \"zlib\";\n\t\tret = btrfs_set_prop(inode, \"btrfs.compression\",\n\t\t\t\t     comp, strlen(comp), 0);\n\t\tif (ret)\n\t\t\tgoto out_drop;\n\n\t} else {\n\t\tret = btrfs_set_prop(inode, \"btrfs.compression\", NULL, 0, 0);\n\t\tif (ret && ret != -ENODATA)\n\t\t\tgoto out_drop;\n\t\tip->flags &= ~(BTRFS_INODE_COMPRESS | BTRFS_INODE_NOCOMPRESS);\n\t}\n\n\ttrans = btrfs_start_transaction(root, 1);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out_drop;\n\t}\n\n\tbtrfs_update_iflags(inode);\n\tinode_inc_iversion(inode);\n\tinode->i_ctime = CURRENT_TIME;\n\tret = btrfs_update_inode(trans, root, inode);\n\n\tbtrfs_end_transaction(trans, root);\n out_drop:\n\tif (ret) {\n\t\tip->flags = ip_oldflags;\n\t\tinode->i_flags = i_oldflags;\n\t}\n\n out_unlock:\n\tmutex_unlock(&inode->i_mutex);\n\tmnt_drop_write_file(file);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_getflags",
          "args": [
            "file",
            "argp"
          ],
          "line": 5206
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_getflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "188-196",
          "snippet": "static int btrfs_ioctl_getflags(struct file *file, void __user *arg)\n{\n\tstruct btrfs_inode *ip = BTRFS_I(file_inode(file));\n\tunsigned int flags = btrfs_flags_to_ioctl(ip->flags);\n\n\tif (copy_to_user(arg, &flags, sizeof(flags)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_ioctl_getflags(struct file *file, void __user *arg)\n{\n\tstruct btrfs_inode *ip = BTRFS_I(file_inode(file));\n\tunsigned int flags = btrfs_flags_to_ioctl(ip->flags);\n\n\tif (copy_to_user(arg, &flags, sizeof(flags)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "file_inode(file)"
          ],
          "line": 5201
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\n#define BTRFS_IOC_SET_RECEIVED_SUBVOL_32 _IOWR(BTRFS_IOCTL_MAGIC, 37, \\\n\t\t\t\tstruct btrfs_ioctl_received_subvol_args_32)\n\nlong btrfs_ioctl(struct file *file, unsigned int\n\t\tcmd, unsigned long arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tvoid __user *argp = (void __user *)arg;\n\n\tswitch (cmd) {\n\tcase FS_IOC_GETFLAGS:\n\t\treturn btrfs_ioctl_getflags(file, argp);\n\tcase FS_IOC_SETFLAGS:\n\t\treturn btrfs_ioctl_setflags(file, argp);\n\tcase FS_IOC_GETVERSION:\n\t\treturn btrfs_ioctl_getversion(file, argp);\n\tcase FITRIM:\n\t\treturn btrfs_ioctl_fitrim(file, argp);\n\tcase BTRFS_IOC_SNAP_CREATE:\n\t\treturn btrfs_ioctl_snap_create(file, argp, 0);\n\tcase BTRFS_IOC_SNAP_CREATE_V2:\n\t\treturn btrfs_ioctl_snap_create_v2(file, argp, 0);\n\tcase BTRFS_IOC_SUBVOL_CREATE:\n\t\treturn btrfs_ioctl_snap_create(file, argp, 1);\n\tcase BTRFS_IOC_SUBVOL_CREATE_V2:\n\t\treturn btrfs_ioctl_snap_create_v2(file, argp, 1);\n\tcase BTRFS_IOC_SNAP_DESTROY:\n\t\treturn btrfs_ioctl_snap_destroy(file, argp);\n\tcase BTRFS_IOC_SUBVOL_GETFLAGS:\n\t\treturn btrfs_ioctl_subvol_getflags(file, argp);\n\tcase BTRFS_IOC_SUBVOL_SETFLAGS:\n\t\treturn btrfs_ioctl_subvol_setflags(file, argp);\n\tcase BTRFS_IOC_DEFAULT_SUBVOL:\n\t\treturn btrfs_ioctl_default_subvol(file, argp);\n\tcase BTRFS_IOC_DEFRAG:\n\t\treturn btrfs_ioctl_defrag(file, NULL);\n\tcase BTRFS_IOC_DEFRAG_RANGE:\n\t\treturn btrfs_ioctl_defrag(file, argp);\n\tcase BTRFS_IOC_RESIZE:\n\t\treturn btrfs_ioctl_resize(file, argp);\n\tcase BTRFS_IOC_ADD_DEV:\n\t\treturn btrfs_ioctl_add_dev(root, argp);\n\tcase BTRFS_IOC_RM_DEV:\n\t\treturn btrfs_ioctl_rm_dev(file, argp);\n\tcase BTRFS_IOC_FS_INFO:\n\t\treturn btrfs_ioctl_fs_info(root, argp);\n\tcase BTRFS_IOC_DEV_INFO:\n\t\treturn btrfs_ioctl_dev_info(root, argp);\n\tcase BTRFS_IOC_BALANCE:\n\t\treturn btrfs_ioctl_balance(file, NULL);\n\tcase BTRFS_IOC_CLONE:\n\t\treturn btrfs_ioctl_clone(file, arg, 0, 0, 0);\n\tcase BTRFS_IOC_CLONE_RANGE:\n\t\treturn btrfs_ioctl_clone_range(file, argp);\n\tcase BTRFS_IOC_TRANS_START:\n\t\treturn btrfs_ioctl_trans_start(file);\n\tcase BTRFS_IOC_TRANS_END:\n\t\treturn btrfs_ioctl_trans_end(file);\n\tcase BTRFS_IOC_TREE_SEARCH:\n\t\treturn btrfs_ioctl_tree_search(file, argp);\n\tcase BTRFS_IOC_TREE_SEARCH_V2:\n\t\treturn btrfs_ioctl_tree_search_v2(file, argp);\n\tcase BTRFS_IOC_INO_LOOKUP:\n\t\treturn btrfs_ioctl_ino_lookup(file, argp);\n\tcase BTRFS_IOC_INO_PATHS:\n\t\treturn btrfs_ioctl_ino_to_path(root, argp);\n\tcase BTRFS_IOC_LOGICAL_INO:\n\t\treturn btrfs_ioctl_logical_to_ino(root, argp);\n\tcase BTRFS_IOC_SPACE_INFO:\n\t\treturn btrfs_ioctl_space_info(root, argp);\n\tcase BTRFS_IOC_SYNC: {\n\t\tint ret;\n\n\t\tret = btrfs_start_delalloc_roots(root->fs_info, 0, -1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = btrfs_sync_fs(file_inode(file)->i_sb, 1);\n\t\t/*\n\t\t * The transaction thread may want to do more work,\n\t\t * namely it pokes the cleaner ktread that will start\n\t\t * processing uncleaned subvols.\n\t\t */\n\t\twake_up_process(root->fs_info->transaction_kthread);\n\t\treturn ret;\n\t}\n\tcase BTRFS_IOC_START_SYNC:\n\t\treturn btrfs_ioctl_start_sync(root, argp);\n\tcase BTRFS_IOC_WAIT_SYNC:\n\t\treturn btrfs_ioctl_wait_sync(root, argp);\n\tcase BTRFS_IOC_SCRUB:\n\t\treturn btrfs_ioctl_scrub(file, argp);\n\tcase BTRFS_IOC_SCRUB_CANCEL:\n\t\treturn btrfs_ioctl_scrub_cancel(root, argp);\n\tcase BTRFS_IOC_SCRUB_PROGRESS:\n\t\treturn btrfs_ioctl_scrub_progress(root, argp);\n\tcase BTRFS_IOC_BALANCE_V2:\n\t\treturn btrfs_ioctl_balance(file, argp);\n\tcase BTRFS_IOC_BALANCE_CTL:\n\t\treturn btrfs_ioctl_balance_ctl(root, arg);\n\tcase BTRFS_IOC_BALANCE_PROGRESS:\n\t\treturn btrfs_ioctl_balance_progress(root, argp);\n\tcase BTRFS_IOC_SET_RECEIVED_SUBVOL:\n\t\treturn btrfs_ioctl_set_received_subvol(file, argp);\n#ifdef CONFIG_64BIT\n\tcase BTRFS_IOC_SET_RECEIVED_SUBVOL_32:\n\t\treturn btrfs_ioctl_set_received_subvol_32(file, argp);\n#endif\n\tcase BTRFS_IOC_SEND:\n\t\treturn btrfs_ioctl_send(file, argp);\n\tcase BTRFS_IOC_GET_DEV_STATS:\n\t\treturn btrfs_ioctl_get_dev_stats(root, argp);\n\tcase BTRFS_IOC_QUOTA_CTL:\n\t\treturn btrfs_ioctl_quota_ctl(file, argp);\n\tcase BTRFS_IOC_QGROUP_ASSIGN:\n\t\treturn btrfs_ioctl_qgroup_assign(file, argp);\n\tcase BTRFS_IOC_QGROUP_CREATE:\n\t\treturn btrfs_ioctl_qgroup_create(file, argp);\n\tcase BTRFS_IOC_QGROUP_LIMIT:\n\t\treturn btrfs_ioctl_qgroup_limit(file, argp);\n\tcase BTRFS_IOC_QUOTA_RESCAN:\n\t\treturn btrfs_ioctl_quota_rescan(file, argp);\n\tcase BTRFS_IOC_QUOTA_RESCAN_STATUS:\n\t\treturn btrfs_ioctl_quota_rescan_status(file, argp);\n\tcase BTRFS_IOC_QUOTA_RESCAN_WAIT:\n\t\treturn btrfs_ioctl_quota_rescan_wait(file, argp);\n\tcase BTRFS_IOC_DEV_REPLACE:\n\t\treturn btrfs_ioctl_dev_replace(root, argp);\n\tcase BTRFS_IOC_GET_FSLABEL:\n\t\treturn btrfs_ioctl_get_fslabel(file, argp);\n\tcase BTRFS_IOC_SET_FSLABEL:\n\t\treturn btrfs_ioctl_set_fslabel(file, argp);\n\tcase BTRFS_IOC_FILE_EXTENT_SAME:\n\t\treturn btrfs_ioctl_file_extent_same(file, argp);\n\tcase BTRFS_IOC_GET_SUPPORTED_FEATURES:\n\t\treturn btrfs_ioctl_get_supported_features(file, argp);\n\tcase BTRFS_IOC_GET_FEATURES:\n\t\treturn btrfs_ioctl_get_features(file, argp);\n\tcase BTRFS_IOC_SET_FEATURES:\n\t\treturn btrfs_ioctl_set_features(file, argp);\n\t}\n\n\treturn -ENOTTY;\n}"
  },
  {
    "function_name": "btrfs_ioctl_set_features",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "5139-5196",
    "snippet": "static int btrfs_ioctl_set_features(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tstruct btrfs_super_block *super_block = root->fs_info->super_copy;\n\tstruct btrfs_ioctl_feature_flags flags[2];\n\tstruct btrfs_trans_handle *trans;\n\tu64 newflags;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (copy_from_user(flags, arg, sizeof(flags)))\n\t\treturn -EFAULT;\n\n\t/* Nothing to do */\n\tif (!flags[0].compat_flags && !flags[0].compat_ro_flags &&\n\t    !flags[0].incompat_flags)\n\t\treturn 0;\n\n\tret = check_feature(root, flags[0].compat_flags,\n\t\t\t    flags[1].compat_flags, COMPAT);\n\tif (ret)\n\t\treturn ret;\n\n\tret = check_feature(root, flags[0].compat_ro_flags,\n\t\t\t    flags[1].compat_ro_flags, COMPAT_RO);\n\tif (ret)\n\t\treturn ret;\n\n\tret = check_feature(root, flags[0].incompat_flags,\n\t\t\t    flags[1].incompat_flags, INCOMPAT);\n\tif (ret)\n\t\treturn ret;\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\n\tspin_lock(&root->fs_info->super_lock);\n\tnewflags = btrfs_super_compat_flags(super_block);\n\tnewflags |= flags[0].compat_flags & flags[1].compat_flags;\n\tnewflags &= ~(flags[0].compat_flags & ~flags[1].compat_flags);\n\tbtrfs_set_super_compat_flags(super_block, newflags);\n\n\tnewflags = btrfs_super_compat_ro_flags(super_block);\n\tnewflags |= flags[0].compat_ro_flags & flags[1].compat_ro_flags;\n\tnewflags &= ~(flags[0].compat_ro_flags & ~flags[1].compat_ro_flags);\n\tbtrfs_set_super_compat_ro_flags(super_block, newflags);\n\n\tnewflags = btrfs_super_incompat_flags(super_block);\n\tnewflags |= flags[0].incompat_flags & flags[1].incompat_flags;\n\tnewflags &= ~(flags[0].incompat_flags & ~flags[1].incompat_flags);\n\tbtrfs_set_super_incompat_flags(super_block, newflags);\n\tspin_unlock(&root->fs_info->super_lock);\n\n\treturn btrfs_commit_transaction(trans, root);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_commit_transaction",
          "args": [
            "trans",
            "root"
          ],
          "line": 5195
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_commit_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "1764-2099",
          "snippet": "int btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&root->fs_info->super_lock"
          ],
          "line": 5193
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_super_incompat_flags",
          "args": [
            "super_block",
            "newflags"
          ],
          "line": 5192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_incompat_flags",
          "args": [
            "super_block"
          ],
          "line": 5189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_super_compat_ro_flags",
          "args": [
            "super_block",
            "newflags"
          ],
          "line": 5187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_compat_ro_flags",
          "args": [
            "super_block"
          ],
          "line": 5184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_super_compat_flags",
          "args": [
            "super_block",
            "newflags"
          ],
          "line": 5182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_compat_flags",
          "args": [
            "super_block"
          ],
          "line": 5179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&root->fs_info->super_lock"
          ],
          "line": 5178
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 5176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 5175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_start_transaction",
          "args": [
            "root",
            "0"
          ],
          "line": 5174
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_transaction_lflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "569-574",
          "snippet": "struct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_feature",
          "args": [
            "root",
            "flags[0].incompat_flags",
            "flags[1].incompat_flags",
            "INCOMPAT"
          ],
          "line": 5169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_feature",
          "args": [
            "root",
            "flags[0].compat_ro_flags",
            "flags[1].compat_ro_flags",
            "COMPAT_RO"
          ],
          "line": 5164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_feature",
          "args": [
            "root",
            "flags[0].compat_flags",
            "flags[1].compat_flags",
            "COMPAT"
          ],
          "line": 5159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "flags",
            "arg",
            "sizeof(flags)"
          ],
          "line": 5151
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 5148
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "file_inode(file)"
          ],
          "line": 5141
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 5141
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_ioctl_set_features(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tstruct btrfs_super_block *super_block = root->fs_info->super_copy;\n\tstruct btrfs_ioctl_feature_flags flags[2];\n\tstruct btrfs_trans_handle *trans;\n\tu64 newflags;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (copy_from_user(flags, arg, sizeof(flags)))\n\t\treturn -EFAULT;\n\n\t/* Nothing to do */\n\tif (!flags[0].compat_flags && !flags[0].compat_ro_flags &&\n\t    !flags[0].incompat_flags)\n\t\treturn 0;\n\n\tret = check_feature(root, flags[0].compat_flags,\n\t\t\t    flags[1].compat_flags, COMPAT);\n\tif (ret)\n\t\treturn ret;\n\n\tret = check_feature(root, flags[0].compat_ro_flags,\n\t\t\t    flags[1].compat_ro_flags, COMPAT_RO);\n\tif (ret)\n\t\treturn ret;\n\n\tret = check_feature(root, flags[0].incompat_flags,\n\t\t\t    flags[1].incompat_flags, INCOMPAT);\n\tif (ret)\n\t\treturn ret;\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\n\tspin_lock(&root->fs_info->super_lock);\n\tnewflags = btrfs_super_compat_flags(super_block);\n\tnewflags |= flags[0].compat_flags & flags[1].compat_flags;\n\tnewflags &= ~(flags[0].compat_flags & ~flags[1].compat_flags);\n\tbtrfs_set_super_compat_flags(super_block, newflags);\n\n\tnewflags = btrfs_super_compat_ro_flags(super_block);\n\tnewflags |= flags[0].compat_ro_flags & flags[1].compat_ro_flags;\n\tnewflags &= ~(flags[0].compat_ro_flags & ~flags[1].compat_ro_flags);\n\tbtrfs_set_super_compat_ro_flags(super_block, newflags);\n\n\tnewflags = btrfs_super_incompat_flags(super_block);\n\tnewflags |= flags[0].incompat_flags & flags[1].incompat_flags;\n\tnewflags &= ~(flags[0].incompat_flags & ~flags[1].incompat_flags);\n\tbtrfs_set_super_incompat_flags(super_block, newflags);\n\tspin_unlock(&root->fs_info->super_lock);\n\n\treturn btrfs_commit_transaction(trans, root);\n}"
  },
  {
    "function_name": "check_feature_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "5074-5131",
    "snippet": "static int check_feature_bits(struct btrfs_root *root,\n\t\t\t      enum btrfs_feature_set set,\n\t\t\t      u64 change_mask, u64 flags, u64 supported_flags,\n\t\t\t      u64 safe_set, u64 safe_clear)\n{\n\tconst char *type = btrfs_feature_set_names[set];\n\tchar *names;\n\tu64 disallowed, unsupported;\n\tu64 set_mask = flags & change_mask;\n\tu64 clear_mask = ~flags & change_mask;\n\n\tunsupported = set_mask & ~supported_flags;\n\tif (unsupported) {\n\t\tnames = btrfs_printable_features(set, unsupported);\n\t\tif (names) {\n\t\t\tbtrfs_warn(root->fs_info,\n\t\t\t   \"this kernel does not support the %s feature bit%s\",\n\t\t\t   names, strchr(names, ',') ? \"s\" : \"\");\n\t\t\tkfree(names);\n\t\t} else\n\t\t\tbtrfs_warn(root->fs_info,\n\t\t\t   \"this kernel does not support %s bits 0x%llx\",\n\t\t\t   type, unsupported);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tdisallowed = set_mask & ~safe_set;\n\tif (disallowed) {\n\t\tnames = btrfs_printable_features(set, disallowed);\n\t\tif (names) {\n\t\t\tbtrfs_warn(root->fs_info,\n\t\t\t   \"can't set the %s feature bit%s while mounted\",\n\t\t\t   names, strchr(names, ',') ? \"s\" : \"\");\n\t\t\tkfree(names);\n\t\t} else\n\t\t\tbtrfs_warn(root->fs_info,\n\t\t\t   \"can't set %s bits 0x%llx while mounted\",\n\t\t\t   type, disallowed);\n\t\treturn -EPERM;\n\t}\n\n\tdisallowed = clear_mask & ~safe_clear;\n\tif (disallowed) {\n\t\tnames = btrfs_printable_features(set, disallowed);\n\t\tif (names) {\n\t\t\tbtrfs_warn(root->fs_info,\n\t\t\t   \"can't clear the %s feature bit%s while mounted\",\n\t\t\t   names, strchr(names, ',') ? \"s\" : \"\");\n\t\t\tkfree(names);\n\t\t} else\n\t\t\tbtrfs_warn(root->fs_info,\n\t\t\t   \"can't clear %s bits 0x%llx while mounted\",\n\t\t\t   type, disallowed);\n\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_warn",
          "args": [
            "root->fs_info",
            "\"can't clear %s bits 0x%llx while mounted\"",
            "type",
            "disallowed"
          ],
          "line": 5124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "names"
          ],
          "line": 5122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_warn",
          "args": [
            "root->fs_info",
            "\"can't clear the %s feature bit%s while mounted\"",
            "names",
            "strchr(names, ',') ? \"s\" : \"\""
          ],
          "line": 5119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "names",
            "','"
          ],
          "line": 5121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_printable_features",
          "args": [
            "set",
            "disallowed"
          ],
          "line": 5117
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printable_features",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/sysfs.c",
          "lines": "536-559",
          "snippet": "char *btrfs_printable_features(enum btrfs_feature_set set, u64 flags)\n{\n\tsize_t bufsize = 4096; /* safe max, 64 names * 64 bytes */\n\tint len = 0;\n\tint i;\n\tchar *str;\n\n\tstr = kmalloc(bufsize, GFP_KERNEL);\n\tif (!str)\n\t\treturn str;\n\n\tfor (i = 0; i < ARRAY_SIZE(btrfs_feature_attrs[set]); i++) {\n\t\tconst char *name;\n\n\t\tif (!(flags & (1ULL << i)))\n\t\t\tcontinue;\n\n\t\tname = btrfs_feature_attrs[set][i].kobj_attr.attr.name;\n\t\tlen += snprintf(str + len, bufsize - len, \"%s%s\",\n\t\t\t\tlen ? \",\" : \"\", name);\n\t}\n\n\treturn str;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"sysfs.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bug.h>",
            "#include <linux/kobject.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct btrfs_feature_attr btrfs_feature_attrs[3][NUM_FEATURE_BITS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"sysfs.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/debugfs.h>\n#include <linux/genhd.h>\n#include <linux/bug.h>\n#include <linux/kobject.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct btrfs_feature_attr btrfs_feature_attrs[3][NUM_FEATURE_BITS];\n\nchar *btrfs_printable_features(enum btrfs_feature_set set, u64 flags)\n{\n\tsize_t bufsize = 4096; /* safe max, 64 names * 64 bytes */\n\tint len = 0;\n\tint i;\n\tchar *str;\n\n\tstr = kmalloc(bufsize, GFP_KERNEL);\n\tif (!str)\n\t\treturn str;\n\n\tfor (i = 0; i < ARRAY_SIZE(btrfs_feature_attrs[set]); i++) {\n\t\tconst char *name;\n\n\t\tif (!(flags & (1ULL << i)))\n\t\t\tcontinue;\n\n\t\tname = btrfs_feature_attrs[set][i].kobj_attr.attr.name;\n\t\tlen += snprintf(str + len, bufsize - len, \"%s%s\",\n\t\t\t\tlen ? \",\" : \"\", name);\n\t}\n\n\treturn str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_warn",
          "args": [
            "root->fs_info",
            "\"can't set %s bits 0x%llx while mounted\"",
            "type",
            "disallowed"
          ],
          "line": 5109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "names"
          ],
          "line": 5107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_warn",
          "args": [
            "root->fs_info",
            "\"can't set the %s feature bit%s while mounted\"",
            "names",
            "strchr(names, ',') ? \"s\" : \"\""
          ],
          "line": 5104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "names",
            "','"
          ],
          "line": 5106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_warn",
          "args": [
            "root->fs_info",
            "\"this kernel does not support %s bits 0x%llx\"",
            "type",
            "unsupported"
          ],
          "line": 5094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "names"
          ],
          "line": 5092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_warn",
          "args": [
            "root->fs_info",
            "\"this kernel does not support the %s feature bit%s\"",
            "names",
            "strchr(names, ',') ? \"s\" : \"\""
          ],
          "line": 5089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "names",
            "','"
          ],
          "line": 5091
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int check_feature_bits(struct btrfs_root *root,\n\t\t\t      enum btrfs_feature_set set,\n\t\t\t      u64 change_mask, u64 flags, u64 supported_flags,\n\t\t\t      u64 safe_set, u64 safe_clear)\n{\n\tconst char *type = btrfs_feature_set_names[set];\n\tchar *names;\n\tu64 disallowed, unsupported;\n\tu64 set_mask = flags & change_mask;\n\tu64 clear_mask = ~flags & change_mask;\n\n\tunsupported = set_mask & ~supported_flags;\n\tif (unsupported) {\n\t\tnames = btrfs_printable_features(set, unsupported);\n\t\tif (names) {\n\t\t\tbtrfs_warn(root->fs_info,\n\t\t\t   \"this kernel does not support the %s feature bit%s\",\n\t\t\t   names, strchr(names, ',') ? \"s\" : \"\");\n\t\t\tkfree(names);\n\t\t} else\n\t\t\tbtrfs_warn(root->fs_info,\n\t\t\t   \"this kernel does not support %s bits 0x%llx\",\n\t\t\t   type, unsupported);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tdisallowed = set_mask & ~safe_set;\n\tif (disallowed) {\n\t\tnames = btrfs_printable_features(set, disallowed);\n\t\tif (names) {\n\t\t\tbtrfs_warn(root->fs_info,\n\t\t\t   \"can't set the %s feature bit%s while mounted\",\n\t\t\t   names, strchr(names, ',') ? \"s\" : \"\");\n\t\t\tkfree(names);\n\t\t} else\n\t\t\tbtrfs_warn(root->fs_info,\n\t\t\t   \"can't set %s bits 0x%llx while mounted\",\n\t\t\t   type, disallowed);\n\t\treturn -EPERM;\n\t}\n\n\tdisallowed = clear_mask & ~safe_clear;\n\tif (disallowed) {\n\t\tnames = btrfs_printable_features(set, disallowed);\n\t\tif (names) {\n\t\t\tbtrfs_warn(root->fs_info,\n\t\t\t   \"can't clear the %s feature bit%s while mounted\",\n\t\t\t   names, strchr(names, ',') ? \"s\" : \"\");\n\t\t\tkfree(names);\n\t\t} else\n\t\t\tbtrfs_warn(root->fs_info,\n\t\t\t   \"can't clear %s bits 0x%llx while mounted\",\n\t\t\t   type, disallowed);\n\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_ioctl_get_features",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "5058-5072",
    "snippet": "static int btrfs_ioctl_get_features(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tstruct btrfs_super_block *super_block = root->fs_info->super_copy;\n\tstruct btrfs_ioctl_feature_flags features;\n\n\tfeatures.compat_flags = btrfs_super_compat_flags(super_block);\n\tfeatures.compat_ro_flags = btrfs_super_compat_ro_flags(super_block);\n\tfeatures.incompat_flags = btrfs_super_incompat_flags(super_block);\n\n\tif (copy_to_user(arg, &features, sizeof(features)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "arg",
            "&features",
            "sizeof(features)"
          ],
          "line": 5068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_incompat_flags",
          "args": [
            "super_block"
          ],
          "line": 5066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_compat_ro_flags",
          "args": [
            "super_block"
          ],
          "line": 5065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_compat_flags",
          "args": [
            "super_block"
          ],
          "line": 5064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "file_inode(file)"
          ],
          "line": 5060
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 5060
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_ioctl_get_features(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tstruct btrfs_super_block *super_block = root->fs_info->super_copy;\n\tstruct btrfs_ioctl_feature_flags features;\n\n\tfeatures.compat_flags = btrfs_super_compat_flags(super_block);\n\tfeatures.compat_ro_flags = btrfs_super_compat_ro_flags(super_block);\n\tfeatures.incompat_flags = btrfs_super_incompat_flags(super_block);\n\n\tif (copy_to_user(arg, &features, sizeof(features)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_ioctl_get_supported_features",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "5043-5056",
    "snippet": "static int btrfs_ioctl_get_supported_features(struct file *file,\n\t\t\t\t\t      void __user *arg)\n{\n\tstatic struct btrfs_ioctl_feature_flags features[3] = {\n\t\tINIT_FEATURE_FLAGS(SUPP),\n\t\tINIT_FEATURE_FLAGS(SAFE_SET),\n\t\tINIT_FEATURE_FLAGS(SAFE_CLEAR)\n\t};\n\n\tif (copy_to_user(arg, &features, sizeof(features)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "arg",
            "&features",
            "sizeof(features)"
          ],
          "line": 5052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_FEATURE_FLAGS",
          "args": [
            "SAFE_CLEAR"
          ],
          "line": 5049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_FEATURE_FLAGS",
          "args": [
            "SAFE_SET"
          ],
          "line": 5048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_FEATURE_FLAGS",
          "args": [
            "SUPP"
          ],
          "line": 5047
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_ioctl_get_supported_features(struct file *file,\n\t\t\t\t\t      void __user *arg)\n{\n\tstatic struct btrfs_ioctl_feature_flags features[3] = {\n\t\tINIT_FEATURE_FLAGS(SUPP),\n\t\tINIT_FEATURE_FLAGS(SAFE_SET),\n\t\tINIT_FEATURE_FLAGS(SAFE_CLEAR)\n\t};\n\n\tif (copy_to_user(arg, &features, sizeof(features)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_ioctl_set_fslabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "4998-5036",
    "snippet": "static int btrfs_ioctl_set_fslabel(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tstruct btrfs_super_block *super_block = root->fs_info->super_copy;\n\tstruct btrfs_trans_handle *trans;\n\tchar label[BTRFS_LABEL_SIZE];\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (copy_from_user(label, arg, sizeof(label)))\n\t\treturn -EFAULT;\n\n\tif (strnlen(label, BTRFS_LABEL_SIZE) == BTRFS_LABEL_SIZE) {\n\t\tbtrfs_err(root->fs_info, \"unable to set label with more than %d bytes\",\n\t\t       BTRFS_LABEL_SIZE - 1);\n\t\treturn -EINVAL;\n\t}\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out_unlock;\n\t}\n\n\tspin_lock(&root->fs_info->super_lock);\n\tstrcpy(super_block->label, label);\n\tspin_unlock(&root->fs_info->super_lock);\n\tret = btrfs_commit_transaction(trans, root);\n\nout_unlock:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "file"
          ],
          "line": 5034
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_commit_transaction",
          "args": [
            "trans",
            "root"
          ],
          "line": 5031
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_commit_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "1764-2099",
          "snippet": "int btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&root->fs_info->super_lock"
          ],
          "line": 5030
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "super_block->label",
            "label"
          ],
          "line": 5029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&root->fs_info->super_lock"
          ],
          "line": 5028
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 5024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 5023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_start_transaction",
          "args": [
            "root",
            "0"
          ],
          "line": 5022
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_transaction_lflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "569-574",
          "snippet": "struct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "file"
          ],
          "line": 5018
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "root->fs_info",
            "\"unable to set label with more than %d bytes\"",
            "BTRFS_LABEL_SIZE - 1"
          ],
          "line": 5013
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_error_unpin_extent_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "9705-9708",
          "snippet": "int btrfs_error_unpin_extent_range(struct btrfs_root *root, u64 start, u64 end)\n{\n\treturn unpin_extent_range(root, start, end, false);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_error_unpin_extent_range(struct btrfs_root *root, u64 start, u64 end)\n{\n\treturn unpin_extent_range(root, start, end, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "label",
            "BTRFS_LABEL_SIZE"
          ],
          "line": 5012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "label",
            "arg",
            "sizeof(label)"
          ],
          "line": 5009
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 5006
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "file_inode(file)"
          ],
          "line": 5000
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 5000
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_ioctl_set_fslabel(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tstruct btrfs_super_block *super_block = root->fs_info->super_copy;\n\tstruct btrfs_trans_handle *trans;\n\tchar label[BTRFS_LABEL_SIZE];\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (copy_from_user(label, arg, sizeof(label)))\n\t\treturn -EFAULT;\n\n\tif (strnlen(label, BTRFS_LABEL_SIZE) == BTRFS_LABEL_SIZE) {\n\t\tbtrfs_err(root->fs_info, \"unable to set label with more than %d bytes\",\n\t\t       BTRFS_LABEL_SIZE - 1);\n\t\treturn -EINVAL;\n\t}\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out_unlock;\n\t}\n\n\tspin_lock(&root->fs_info->super_lock);\n\tstrcpy(super_block->label, label);\n\tspin_unlock(&root->fs_info->super_lock);\n\tret = btrfs_commit_transaction(trans, root);\n\nout_unlock:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_ioctl_get_fslabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "4975-4996",
    "snippet": "static int btrfs_ioctl_get_fslabel(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tsize_t len;\n\tint ret;\n\tchar label[BTRFS_LABEL_SIZE];\n\n\tspin_lock(&root->fs_info->super_lock);\n\tmemcpy(label, root->fs_info->super_copy->label, BTRFS_LABEL_SIZE);\n\tspin_unlock(&root->fs_info->super_lock);\n\n\tlen = strnlen(label, BTRFS_LABEL_SIZE);\n\n\tif (len == BTRFS_LABEL_SIZE) {\n\t\tbtrfs_warn(root->fs_info,\n\t\t\t\"label is too long, return the first %zu bytes\", --len);\n\t}\n\n\tret = copy_to_user(arg, label, len);\n\n\treturn ret ? -EFAULT : 0;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "arg",
            "label",
            "len"
          ],
          "line": 4993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_warn",
          "args": [
            "root->fs_info",
            "\"label is too long, return the first %zu bytes\"",
            "--len"
          ],
          "line": 4989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "label",
            "BTRFS_LABEL_SIZE"
          ],
          "line": 4986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&root->fs_info->super_lock"
          ],
          "line": 4984
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "label",
            "root->fs_info->super_copy->label",
            "BTRFS_LABEL_SIZE"
          ],
          "line": 4983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&root->fs_info->super_lock"
          ],
          "line": 4982
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "file_inode(file)"
          ],
          "line": 4977
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 4977
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_ioctl_get_fslabel(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tsize_t len;\n\tint ret;\n\tchar label[BTRFS_LABEL_SIZE];\n\n\tspin_lock(&root->fs_info->super_lock);\n\tmemcpy(label, root->fs_info->super_copy->label, BTRFS_LABEL_SIZE);\n\tspin_unlock(&root->fs_info->super_lock);\n\n\tlen = strnlen(label, BTRFS_LABEL_SIZE);\n\n\tif (len == BTRFS_LABEL_SIZE) {\n\t\tbtrfs_warn(root->fs_info,\n\t\t\t\"label is too long, return the first %zu bytes\", --len);\n\t}\n\n\tret = copy_to_user(arg, label, len);\n\n\treturn ret ? -EFAULT : 0;\n}"
  },
  {
    "function_name": "btrfs_ioctl_set_received_subvol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "4948-4973",
    "snippet": "static long btrfs_ioctl_set_received_subvol(struct file *file,\n\t\t\t\t\t    void __user *arg)\n{\n\tstruct btrfs_ioctl_received_subvol_args *sa = NULL;\n\tint ret = 0;\n\n\tsa = memdup_user(arg, sizeof(*sa));\n\tif (IS_ERR(sa)) {\n\t\tret = PTR_ERR(sa);\n\t\tsa = NULL;\n\t\tgoto out;\n\t}\n\n\tret = _btrfs_ioctl_set_received_subvol(file, sa);\n\n\tif (ret)\n\t\tgoto out;\n\n\tret = copy_to_user(arg, sa, sizeof(*sa));\n\tif (ret)\n\t\tret = -EFAULT;\n\nout:\n\tkfree(sa);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sa"
          ],
          "line": 4971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "arg",
            "sa",
            "sizeof(*sa)"
          ],
          "line": 4966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_btrfs_ioctl_set_received_subvol",
          "args": [
            "file",
            "sa"
          ],
          "line": 4961
        },
        "resolved": true,
        "details": {
          "function_name": "_btrfs_ioctl_set_received_subvol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "4805-4892",
          "snippet": "static long _btrfs_ioctl_set_received_subvol(struct file *file,\n\t\t\t\t\t    struct btrfs_ioctl_received_subvol_args *sa)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_root_item *root_item = &root->root_item;\n\tstruct btrfs_trans_handle *trans;\n\tstruct timespec ct = CURRENT_TIME;\n\tint ret = 0;\n\tint received_uuid_changed;\n\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdown_write(&root->fs_info->subvol_sem);\n\n\tif (btrfs_ino(inode) != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (btrfs_root_readonly(root)) {\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * 1 - root item\n\t * 2 - uuid items (received uuid + subvol uuid)\n\t */\n\ttrans = btrfs_start_transaction(root, 3);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\ttrans = NULL;\n\t\tgoto out;\n\t}\n\n\tsa->rtransid = trans->transid;\n\tsa->rtime.sec = ct.tv_sec;\n\tsa->rtime.nsec = ct.tv_nsec;\n\n\treceived_uuid_changed = memcmp(root_item->received_uuid, sa->uuid,\n\t\t\t\t       BTRFS_UUID_SIZE);\n\tif (received_uuid_changed &&\n\t    !btrfs_is_empty_uuid(root_item->received_uuid))\n\t\tbtrfs_uuid_tree_rem(trans, root->fs_info->uuid_root,\n\t\t\t\t    root_item->received_uuid,\n\t\t\t\t    BTRFS_UUID_KEY_RECEIVED_SUBVOL,\n\t\t\t\t    root->root_key.objectid);\n\tmemcpy(root_item->received_uuid, sa->uuid, BTRFS_UUID_SIZE);\n\tbtrfs_set_root_stransid(root_item, sa->stransid);\n\tbtrfs_set_root_rtransid(root_item, sa->rtransid);\n\tbtrfs_set_stack_timespec_sec(&root_item->stime, sa->stime.sec);\n\tbtrfs_set_stack_timespec_nsec(&root_item->stime, sa->stime.nsec);\n\tbtrfs_set_stack_timespec_sec(&root_item->rtime, sa->rtime.sec);\n\tbtrfs_set_stack_timespec_nsec(&root_item->rtime, sa->rtime.nsec);\n\n\tret = btrfs_update_root(trans, root->fs_info->tree_root,\n\t\t\t\t&root->root_key, &root->root_item);\n\tif (ret < 0) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\tgoto out;\n\t}\n\tif (received_uuid_changed && !btrfs_is_empty_uuid(sa->uuid)) {\n\t\tret = btrfs_uuid_tree_add(trans, root->fs_info->uuid_root,\n\t\t\t\t\t  sa->uuid,\n\t\t\t\t\t  BTRFS_UUID_KEY_RECEIVED_SUBVOL,\n\t\t\t\t\t  root->root_key.objectid);\n\t\tif (ret < 0 && ret != -EEXIST) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tret = btrfs_commit_transaction(trans, root);\n\tif (ret < 0) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto out;\n\t}\n\nout:\n\tup_write(&root->fs_info->subvol_sem);\n\tmnt_drop_write_file(file);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long _btrfs_ioctl_set_received_subvol(struct file *file,\n\t\t\t\t\t    struct btrfs_ioctl_received_subvol_args *sa)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_root_item *root_item = &root->root_item;\n\tstruct btrfs_trans_handle *trans;\n\tstruct timespec ct = CURRENT_TIME;\n\tint ret = 0;\n\tint received_uuid_changed;\n\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdown_write(&root->fs_info->subvol_sem);\n\n\tif (btrfs_ino(inode) != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (btrfs_root_readonly(root)) {\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * 1 - root item\n\t * 2 - uuid items (received uuid + subvol uuid)\n\t */\n\ttrans = btrfs_start_transaction(root, 3);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\ttrans = NULL;\n\t\tgoto out;\n\t}\n\n\tsa->rtransid = trans->transid;\n\tsa->rtime.sec = ct.tv_sec;\n\tsa->rtime.nsec = ct.tv_nsec;\n\n\treceived_uuid_changed = memcmp(root_item->received_uuid, sa->uuid,\n\t\t\t\t       BTRFS_UUID_SIZE);\n\tif (received_uuid_changed &&\n\t    !btrfs_is_empty_uuid(root_item->received_uuid))\n\t\tbtrfs_uuid_tree_rem(trans, root->fs_info->uuid_root,\n\t\t\t\t    root_item->received_uuid,\n\t\t\t\t    BTRFS_UUID_KEY_RECEIVED_SUBVOL,\n\t\t\t\t    root->root_key.objectid);\n\tmemcpy(root_item->received_uuid, sa->uuid, BTRFS_UUID_SIZE);\n\tbtrfs_set_root_stransid(root_item, sa->stransid);\n\tbtrfs_set_root_rtransid(root_item, sa->rtransid);\n\tbtrfs_set_stack_timespec_sec(&root_item->stime, sa->stime.sec);\n\tbtrfs_set_stack_timespec_nsec(&root_item->stime, sa->stime.nsec);\n\tbtrfs_set_stack_timespec_sec(&root_item->rtime, sa->rtime.sec);\n\tbtrfs_set_stack_timespec_nsec(&root_item->rtime, sa->rtime.nsec);\n\n\tret = btrfs_update_root(trans, root->fs_info->tree_root,\n\t\t\t\t&root->root_key, &root->root_item);\n\tif (ret < 0) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\tgoto out;\n\t}\n\tif (received_uuid_changed && !btrfs_is_empty_uuid(sa->uuid)) {\n\t\tret = btrfs_uuid_tree_add(trans, root->fs_info->uuid_root,\n\t\t\t\t\t  sa->uuid,\n\t\t\t\t\t  BTRFS_UUID_KEY_RECEIVED_SUBVOL,\n\t\t\t\t\t  root->root_key.objectid);\n\t\tif (ret < 0 && ret != -EEXIST) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tret = btrfs_commit_transaction(trans, root);\n\tif (ret < 0) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto out;\n\t}\n\nout:\n\tup_write(&root->fs_info->subvol_sem);\n\tmnt_drop_write_file(file);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "sa"
          ],
          "line": 4956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "sa"
          ],
          "line": 4955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user",
          "args": [
            "arg",
            "sizeof(*sa)"
          ],
          "line": 4954
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_set_received_subvol(struct file *file,\n\t\t\t\t\t    void __user *arg)\n{\n\tstruct btrfs_ioctl_received_subvol_args *sa = NULL;\n\tint ret = 0;\n\n\tsa = memdup_user(arg, sizeof(*sa));\n\tif (IS_ERR(sa)) {\n\t\tret = PTR_ERR(sa);\n\t\tsa = NULL;\n\t\tgoto out;\n\t}\n\n\tret = _btrfs_ioctl_set_received_subvol(file, sa);\n\n\tif (ret)\n\t\tgoto out;\n\n\tret = copy_to_user(arg, sa, sizeof(*sa));\n\tif (ret)\n\t\tret = -EFAULT;\n\nout:\n\tkfree(sa);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_ioctl_set_received_subvol_32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "4895-4945",
    "snippet": "static long btrfs_ioctl_set_received_subvol_32(struct file *file,\n\t\t\t\t\t\tvoid __user *arg)\n{\n\tstruct btrfs_ioctl_received_subvol_args_32 *args32 = NULL;\n\tstruct btrfs_ioctl_received_subvol_args *args64 = NULL;\n\tint ret = 0;\n\n\targs32 = memdup_user(arg, sizeof(*args32));\n\tif (IS_ERR(args32)) {\n\t\tret = PTR_ERR(args32);\n\t\targs32 = NULL;\n\t\tgoto out;\n\t}\n\n\targs64 = kmalloc(sizeof(*args64), GFP_NOFS);\n\tif (!args64) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmemcpy(args64->uuid, args32->uuid, BTRFS_UUID_SIZE);\n\targs64->stransid = args32->stransid;\n\targs64->rtransid = args32->rtransid;\n\targs64->stime.sec = args32->stime.sec;\n\targs64->stime.nsec = args32->stime.nsec;\n\targs64->rtime.sec = args32->rtime.sec;\n\targs64->rtime.nsec = args32->rtime.nsec;\n\targs64->flags = args32->flags;\n\n\tret = _btrfs_ioctl_set_received_subvol(file, args64);\n\tif (ret)\n\t\tgoto out;\n\n\tmemcpy(args32->uuid, args64->uuid, BTRFS_UUID_SIZE);\n\targs32->stransid = args64->stransid;\n\targs32->rtransid = args64->rtransid;\n\targs32->stime.sec = args64->stime.sec;\n\targs32->stime.nsec = args64->stime.nsec;\n\targs32->rtime.sec = args64->rtime.sec;\n\targs32->rtime.nsec = args64->rtime.nsec;\n\targs32->flags = args64->flags;\n\n\tret = copy_to_user(arg, args32, sizeof(*args32));\n\tif (ret)\n\t\tret = -EFAULT;\n\nout:\n\tkfree(args32);\n\tkfree(args64);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "args64"
          ],
          "line": 4943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "args32"
          ],
          "line": 4942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "arg",
            "args32",
            "sizeof(*args32)"
          ],
          "line": 4937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "args32->uuid",
            "args64->uuid",
            "BTRFS_UUID_SIZE"
          ],
          "line": 4928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_btrfs_ioctl_set_received_subvol",
          "args": [
            "file",
            "args64"
          ],
          "line": 4924
        },
        "resolved": true,
        "details": {
          "function_name": "_btrfs_ioctl_set_received_subvol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "4805-4892",
          "snippet": "static long _btrfs_ioctl_set_received_subvol(struct file *file,\n\t\t\t\t\t    struct btrfs_ioctl_received_subvol_args *sa)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_root_item *root_item = &root->root_item;\n\tstruct btrfs_trans_handle *trans;\n\tstruct timespec ct = CURRENT_TIME;\n\tint ret = 0;\n\tint received_uuid_changed;\n\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdown_write(&root->fs_info->subvol_sem);\n\n\tif (btrfs_ino(inode) != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (btrfs_root_readonly(root)) {\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * 1 - root item\n\t * 2 - uuid items (received uuid + subvol uuid)\n\t */\n\ttrans = btrfs_start_transaction(root, 3);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\ttrans = NULL;\n\t\tgoto out;\n\t}\n\n\tsa->rtransid = trans->transid;\n\tsa->rtime.sec = ct.tv_sec;\n\tsa->rtime.nsec = ct.tv_nsec;\n\n\treceived_uuid_changed = memcmp(root_item->received_uuid, sa->uuid,\n\t\t\t\t       BTRFS_UUID_SIZE);\n\tif (received_uuid_changed &&\n\t    !btrfs_is_empty_uuid(root_item->received_uuid))\n\t\tbtrfs_uuid_tree_rem(trans, root->fs_info->uuid_root,\n\t\t\t\t    root_item->received_uuid,\n\t\t\t\t    BTRFS_UUID_KEY_RECEIVED_SUBVOL,\n\t\t\t\t    root->root_key.objectid);\n\tmemcpy(root_item->received_uuid, sa->uuid, BTRFS_UUID_SIZE);\n\tbtrfs_set_root_stransid(root_item, sa->stransid);\n\tbtrfs_set_root_rtransid(root_item, sa->rtransid);\n\tbtrfs_set_stack_timespec_sec(&root_item->stime, sa->stime.sec);\n\tbtrfs_set_stack_timespec_nsec(&root_item->stime, sa->stime.nsec);\n\tbtrfs_set_stack_timespec_sec(&root_item->rtime, sa->rtime.sec);\n\tbtrfs_set_stack_timespec_nsec(&root_item->rtime, sa->rtime.nsec);\n\n\tret = btrfs_update_root(trans, root->fs_info->tree_root,\n\t\t\t\t&root->root_key, &root->root_item);\n\tif (ret < 0) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\tgoto out;\n\t}\n\tif (received_uuid_changed && !btrfs_is_empty_uuid(sa->uuid)) {\n\t\tret = btrfs_uuid_tree_add(trans, root->fs_info->uuid_root,\n\t\t\t\t\t  sa->uuid,\n\t\t\t\t\t  BTRFS_UUID_KEY_RECEIVED_SUBVOL,\n\t\t\t\t\t  root->root_key.objectid);\n\t\tif (ret < 0 && ret != -EEXIST) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tret = btrfs_commit_transaction(trans, root);\n\tif (ret < 0) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto out;\n\t}\n\nout:\n\tup_write(&root->fs_info->subvol_sem);\n\tmnt_drop_write_file(file);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long _btrfs_ioctl_set_received_subvol(struct file *file,\n\t\t\t\t\t    struct btrfs_ioctl_received_subvol_args *sa)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_root_item *root_item = &root->root_item;\n\tstruct btrfs_trans_handle *trans;\n\tstruct timespec ct = CURRENT_TIME;\n\tint ret = 0;\n\tint received_uuid_changed;\n\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdown_write(&root->fs_info->subvol_sem);\n\n\tif (btrfs_ino(inode) != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (btrfs_root_readonly(root)) {\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * 1 - root item\n\t * 2 - uuid items (received uuid + subvol uuid)\n\t */\n\ttrans = btrfs_start_transaction(root, 3);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\ttrans = NULL;\n\t\tgoto out;\n\t}\n\n\tsa->rtransid = trans->transid;\n\tsa->rtime.sec = ct.tv_sec;\n\tsa->rtime.nsec = ct.tv_nsec;\n\n\treceived_uuid_changed = memcmp(root_item->received_uuid, sa->uuid,\n\t\t\t\t       BTRFS_UUID_SIZE);\n\tif (received_uuid_changed &&\n\t    !btrfs_is_empty_uuid(root_item->received_uuid))\n\t\tbtrfs_uuid_tree_rem(trans, root->fs_info->uuid_root,\n\t\t\t\t    root_item->received_uuid,\n\t\t\t\t    BTRFS_UUID_KEY_RECEIVED_SUBVOL,\n\t\t\t\t    root->root_key.objectid);\n\tmemcpy(root_item->received_uuid, sa->uuid, BTRFS_UUID_SIZE);\n\tbtrfs_set_root_stransid(root_item, sa->stransid);\n\tbtrfs_set_root_rtransid(root_item, sa->rtransid);\n\tbtrfs_set_stack_timespec_sec(&root_item->stime, sa->stime.sec);\n\tbtrfs_set_stack_timespec_nsec(&root_item->stime, sa->stime.nsec);\n\tbtrfs_set_stack_timespec_sec(&root_item->rtime, sa->rtime.sec);\n\tbtrfs_set_stack_timespec_nsec(&root_item->rtime, sa->rtime.nsec);\n\n\tret = btrfs_update_root(trans, root->fs_info->tree_root,\n\t\t\t\t&root->root_key, &root->root_item);\n\tif (ret < 0) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\tgoto out;\n\t}\n\tif (received_uuid_changed && !btrfs_is_empty_uuid(sa->uuid)) {\n\t\tret = btrfs_uuid_tree_add(trans, root->fs_info->uuid_root,\n\t\t\t\t\t  sa->uuid,\n\t\t\t\t\t  BTRFS_UUID_KEY_RECEIVED_SUBVOL,\n\t\t\t\t\t  root->root_key.objectid);\n\t\tif (ret < 0 && ret != -EEXIST) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tret = btrfs_commit_transaction(trans, root);\n\tif (ret < 0) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto out;\n\t}\n\nout:\n\tup_write(&root->fs_info->subvol_sem);\n\tmnt_drop_write_file(file);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "args64->uuid",
            "args32->uuid",
            "BTRFS_UUID_SIZE"
          ],
          "line": 4915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*args64)",
            "GFP_NOFS"
          ],
          "line": 4909
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "args32"
          ],
          "line": 4904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "args32"
          ],
          "line": 4903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user",
          "args": [
            "arg",
            "sizeof(*args32)"
          ],
          "line": 4902
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_set_received_subvol_32(struct file *file,\n\t\t\t\t\t\tvoid __user *arg)\n{\n\tstruct btrfs_ioctl_received_subvol_args_32 *args32 = NULL;\n\tstruct btrfs_ioctl_received_subvol_args *args64 = NULL;\n\tint ret = 0;\n\n\targs32 = memdup_user(arg, sizeof(*args32));\n\tif (IS_ERR(args32)) {\n\t\tret = PTR_ERR(args32);\n\t\targs32 = NULL;\n\t\tgoto out;\n\t}\n\n\targs64 = kmalloc(sizeof(*args64), GFP_NOFS);\n\tif (!args64) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmemcpy(args64->uuid, args32->uuid, BTRFS_UUID_SIZE);\n\targs64->stransid = args32->stransid;\n\targs64->rtransid = args32->rtransid;\n\targs64->stime.sec = args32->stime.sec;\n\targs64->stime.nsec = args32->stime.nsec;\n\targs64->rtime.sec = args32->rtime.sec;\n\targs64->rtime.nsec = args32->rtime.nsec;\n\targs64->flags = args32->flags;\n\n\tret = _btrfs_ioctl_set_received_subvol(file, args64);\n\tif (ret)\n\t\tgoto out;\n\n\tmemcpy(args32->uuid, args64->uuid, BTRFS_UUID_SIZE);\n\targs32->stransid = args64->stransid;\n\targs32->rtransid = args64->rtransid;\n\targs32->stime.sec = args64->stime.sec;\n\targs32->stime.nsec = args64->stime.nsec;\n\targs32->rtime.sec = args64->rtime.sec;\n\targs32->rtime.nsec = args64->rtime.nsec;\n\targs32->flags = args64->flags;\n\n\tret = copy_to_user(arg, args32, sizeof(*args32));\n\tif (ret)\n\t\tret = -EFAULT;\n\nout:\n\tkfree(args32);\n\tkfree(args64);\n\treturn ret;\n}"
  },
  {
    "function_name": "_btrfs_ioctl_set_received_subvol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "4805-4892",
    "snippet": "static long _btrfs_ioctl_set_received_subvol(struct file *file,\n\t\t\t\t\t    struct btrfs_ioctl_received_subvol_args *sa)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_root_item *root_item = &root->root_item;\n\tstruct btrfs_trans_handle *trans;\n\tstruct timespec ct = CURRENT_TIME;\n\tint ret = 0;\n\tint received_uuid_changed;\n\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdown_write(&root->fs_info->subvol_sem);\n\n\tif (btrfs_ino(inode) != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (btrfs_root_readonly(root)) {\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * 1 - root item\n\t * 2 - uuid items (received uuid + subvol uuid)\n\t */\n\ttrans = btrfs_start_transaction(root, 3);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\ttrans = NULL;\n\t\tgoto out;\n\t}\n\n\tsa->rtransid = trans->transid;\n\tsa->rtime.sec = ct.tv_sec;\n\tsa->rtime.nsec = ct.tv_nsec;\n\n\treceived_uuid_changed = memcmp(root_item->received_uuid, sa->uuid,\n\t\t\t\t       BTRFS_UUID_SIZE);\n\tif (received_uuid_changed &&\n\t    !btrfs_is_empty_uuid(root_item->received_uuid))\n\t\tbtrfs_uuid_tree_rem(trans, root->fs_info->uuid_root,\n\t\t\t\t    root_item->received_uuid,\n\t\t\t\t    BTRFS_UUID_KEY_RECEIVED_SUBVOL,\n\t\t\t\t    root->root_key.objectid);\n\tmemcpy(root_item->received_uuid, sa->uuid, BTRFS_UUID_SIZE);\n\tbtrfs_set_root_stransid(root_item, sa->stransid);\n\tbtrfs_set_root_rtransid(root_item, sa->rtransid);\n\tbtrfs_set_stack_timespec_sec(&root_item->stime, sa->stime.sec);\n\tbtrfs_set_stack_timespec_nsec(&root_item->stime, sa->stime.nsec);\n\tbtrfs_set_stack_timespec_sec(&root_item->rtime, sa->rtime.sec);\n\tbtrfs_set_stack_timespec_nsec(&root_item->rtime, sa->rtime.nsec);\n\n\tret = btrfs_update_root(trans, root->fs_info->tree_root,\n\t\t\t\t&root->root_key, &root->root_item);\n\tif (ret < 0) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\tgoto out;\n\t}\n\tif (received_uuid_changed && !btrfs_is_empty_uuid(sa->uuid)) {\n\t\tret = btrfs_uuid_tree_add(trans, root->fs_info->uuid_root,\n\t\t\t\t\t  sa->uuid,\n\t\t\t\t\t  BTRFS_UUID_KEY_RECEIVED_SUBVOL,\n\t\t\t\t\t  root->root_key.objectid);\n\t\tif (ret < 0 && ret != -EEXIST) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tret = btrfs_commit_transaction(trans, root);\n\tif (ret < 0) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto out;\n\t}\n\nout:\n\tup_write(&root->fs_info->subvol_sem);\n\tmnt_drop_write_file(file);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "file"
          ],
          "line": 4890
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&root->fs_info->subvol_sem"
          ],
          "line": 4889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 4884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_commit_transaction",
          "args": [
            "trans",
            "root"
          ],
          "line": 4882
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_commit_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "1764-2099",
          "snippet": "int btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 4878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_uuid_tree_add",
          "args": [
            "trans",
            "root->fs_info->uuid_root",
            "sa->uuid",
            "BTRFS_UUID_KEY_RECEIVED_SUBVOL",
            "root->root_key.objectid"
          ],
          "line": 4873
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_uuid_tree_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/uuid-tree.c",
          "lines": "93-155",
          "snippet": "int btrfs_uuid_tree_add(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_root *uuid_root, u8 *uuid, u8 type,\n\t\t\tu64 subid_cpu)\n{\n\tint ret;\n\tstruct btrfs_path *path = NULL;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tunsigned long offset;\n\t__le64 subid_le;\n\n\tret = btrfs_uuid_tree_lookup(uuid_root, uuid, type, subid_cpu);\n\tif (ret != -ENOENT)\n\t\treturn ret;\n\n\tif (WARN_ON_ONCE(!uuid_root)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tbtrfs_uuid_to_key(uuid, type, &key);\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_insert_empty_item(trans, uuid_root, path, &key,\n\t\t\t\t      sizeof(subid_le));\n\tif (ret >= 0) {\n\t\t/* Add an item for the type for the first time */\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\toffset = btrfs_item_ptr_offset(eb, slot);\n\t} else if (ret == -EEXIST) {\n\t\t/*\n\t\t * An item with that type already exists.\n\t\t * Extend the item and store the new subid at the end.\n\t\t */\n\t\tbtrfs_extend_item(uuid_root, path, sizeof(subid_le));\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\toffset = btrfs_item_ptr_offset(eb, slot);\n\t\toffset += btrfs_item_size_nr(eb, slot) - sizeof(subid_le);\n\t} else if (ret < 0) {\n\t\tbtrfs_warn(uuid_root->fs_info, \"insert uuid item failed %d \"\n\t\t\t\"(0x%016llx, 0x%016llx) type %u!\",\n\t\t\tret, (unsigned long long)key.objectid,\n\t\t\t(unsigned long long)key.offset, type);\n\t\tgoto out;\n\t}\n\n\tret = 0;\n\tsubid_le = cpu_to_le64(subid_cpu);\n\twrite_extent_buffer(eb, &subid_le, offset, sizeof(subid_le));\n\tbtrfs_mark_buffer_dirty(eb);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/uuid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/uuid.h>\n\nint btrfs_uuid_tree_add(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_root *uuid_root, u8 *uuid, u8 type,\n\t\t\tu64 subid_cpu)\n{\n\tint ret;\n\tstruct btrfs_path *path = NULL;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tunsigned long offset;\n\t__le64 subid_le;\n\n\tret = btrfs_uuid_tree_lookup(uuid_root, uuid, type, subid_cpu);\n\tif (ret != -ENOENT)\n\t\treturn ret;\n\n\tif (WARN_ON_ONCE(!uuid_root)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tbtrfs_uuid_to_key(uuid, type, &key);\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_insert_empty_item(trans, uuid_root, path, &key,\n\t\t\t\t      sizeof(subid_le));\n\tif (ret >= 0) {\n\t\t/* Add an item for the type for the first time */\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\toffset = btrfs_item_ptr_offset(eb, slot);\n\t} else if (ret == -EEXIST) {\n\t\t/*\n\t\t * An item with that type already exists.\n\t\t * Extend the item and store the new subid at the end.\n\t\t */\n\t\tbtrfs_extend_item(uuid_root, path, sizeof(subid_le));\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\toffset = btrfs_item_ptr_offset(eb, slot);\n\t\toffset += btrfs_item_size_nr(eb, slot) - sizeof(subid_le);\n\t} else if (ret < 0) {\n\t\tbtrfs_warn(uuid_root->fs_info, \"insert uuid item failed %d \"\n\t\t\t\"(0x%016llx, 0x%016llx) type %u!\",\n\t\t\tret, (unsigned long long)key.objectid,\n\t\t\t(unsigned long long)key.offset, type);\n\t\tgoto out;\n\t}\n\n\tret = 0;\n\tsubid_le = cpu_to_le64(subid_cpu);\n\twrite_extent_buffer(eb, &subid_le, offset, sizeof(subid_le));\n\tbtrfs_mark_buffer_dirty(eb);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_is_empty_uuid",
          "args": [
            "sa->uuid"
          ],
          "line": 4872
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_is_empty_uuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "420-429",
          "snippet": "int btrfs_is_empty_uuid(u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_UUID_SIZE; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nint btrfs_is_empty_uuid(u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_UUID_SIZE; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_end_transaction",
          "args": [
            "trans",
            "root"
          ],
          "line": 4869
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_end_transaction_throttle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "846-850",
          "snippet": "int btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_update_root",
          "args": [
            "trans",
            "root->fs_info->tree_root",
            "&root->root_key",
            "&root->root_item"
          ],
          "line": 4866
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_update_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/root-tree.c",
          "lines": "135-210",
          "snippet": "int btrfs_update_root(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_root_item\n\t\t      *item)\n{\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *l;\n\tint ret;\n\tint slot;\n\tunsigned long ptr;\n\tint old_len;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_search_slot(trans, root, key, path, 0, 1);\n\tif (ret < 0) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto out;\n\t}\n\n\tif (ret != 0) {\n\t\tbtrfs_print_leaf(root, path->nodes[0]);\n\t\tbtrfs_crit(root->fs_info, \"unable to update root key %llu %u %llu\",\n\t\t       key->objectid, key->type, key->offset);\n\t\tBUG_ON(1);\n\t}\n\n\tl = path->nodes[0];\n\tslot = path->slots[0];\n\tptr = btrfs_item_ptr_offset(l, slot);\n\told_len = btrfs_item_size_nr(l, slot);\n\n\t/*\n\t * If this is the first time we update the root item which originated\n\t * from an older kernel, we need to enlarge the item size to make room\n\t * for the added fields.\n\t */\n\tif (old_len < sizeof(*item)) {\n\t\tbtrfs_release_path(path);\n\t\tret = btrfs_search_slot(trans, root, key, path,\n\t\t\t\t-1, 1);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = btrfs_del_item(trans, root, path);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\t\tbtrfs_release_path(path);\n\t\tret = btrfs_insert_empty_item(trans, root, path,\n\t\t\t\tkey, sizeof(*item));\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\t\tl = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tptr = btrfs_item_ptr_offset(l, slot);\n\t}\n\n\t/*\n\t * Update generation_v2 so at the next mount we know the new root\n\t * fields are valid.\n\t */\n\tbtrfs_set_root_generation_v2(item, btrfs_root_generation(item));\n\n\twrite_extent_buffer(l, item, ptr, sizeof(*item));\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/err.h>\n\nint btrfs_update_root(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_root_item\n\t\t      *item)\n{\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *l;\n\tint ret;\n\tint slot;\n\tunsigned long ptr;\n\tint old_len;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_search_slot(trans, root, key, path, 0, 1);\n\tif (ret < 0) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto out;\n\t}\n\n\tif (ret != 0) {\n\t\tbtrfs_print_leaf(root, path->nodes[0]);\n\t\tbtrfs_crit(root->fs_info, \"unable to update root key %llu %u %llu\",\n\t\t       key->objectid, key->type, key->offset);\n\t\tBUG_ON(1);\n\t}\n\n\tl = path->nodes[0];\n\tslot = path->slots[0];\n\tptr = btrfs_item_ptr_offset(l, slot);\n\told_len = btrfs_item_size_nr(l, slot);\n\n\t/*\n\t * If this is the first time we update the root item which originated\n\t * from an older kernel, we need to enlarge the item size to make room\n\t * for the added fields.\n\t */\n\tif (old_len < sizeof(*item)) {\n\t\tbtrfs_release_path(path);\n\t\tret = btrfs_search_slot(trans, root, key, path,\n\t\t\t\t-1, 1);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = btrfs_del_item(trans, root, path);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\t\tbtrfs_release_path(path);\n\t\tret = btrfs_insert_empty_item(trans, root, path,\n\t\t\t\tkey, sizeof(*item));\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\t\tl = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tptr = btrfs_item_ptr_offset(l, slot);\n\t}\n\n\t/*\n\t * Update generation_v2 so at the next mount we know the new root\n\t * fields are valid.\n\t */\n\tbtrfs_set_root_generation_v2(item, btrfs_root_generation(item));\n\n\twrite_extent_buffer(l, item, ptr, sizeof(*item));\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_timespec_nsec",
          "args": [
            "&root_item->rtime",
            "sa->rtime.nsec"
          ],
          "line": 4864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_timespec_sec",
          "args": [
            "&root_item->rtime",
            "sa->rtime.sec"
          ],
          "line": 4863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_timespec_nsec",
          "args": [
            "&root_item->stime",
            "sa->stime.nsec"
          ],
          "line": 4862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_timespec_sec",
          "args": [
            "&root_item->stime",
            "sa->stime.sec"
          ],
          "line": 4861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_rtransid",
          "args": [
            "root_item",
            "sa->rtransid"
          ],
          "line": 4860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_stransid",
          "args": [
            "root_item",
            "sa->stransid"
          ],
          "line": 4859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "root_item->received_uuid",
            "sa->uuid",
            "BTRFS_UUID_SIZE"
          ],
          "line": 4858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_uuid_tree_rem",
          "args": [
            "trans",
            "root->fs_info->uuid_root",
            "root_item->received_uuid",
            "BTRFS_UUID_KEY_RECEIVED_SUBVOL",
            "root->root_key.objectid"
          ],
          "line": 4854
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_uuid_tree_rem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/uuid-tree.c",
          "lines": "157-236",
          "snippet": "int btrfs_uuid_tree_rem(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_root *uuid_root, u8 *uuid, u8 type,\n\t\t\tu64 subid)\n{\n\tint ret;\n\tstruct btrfs_path *path = NULL;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tunsigned long offset;\n\tu32 item_size;\n\tunsigned long move_dst;\n\tunsigned long move_src;\n\tunsigned long move_len;\n\n\tif (WARN_ON_ONCE(!uuid_root)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tbtrfs_uuid_to_key(uuid, type, &key);\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_search_slot(trans, uuid_root, &key, path, -1, 1);\n\tif (ret < 0) {\n\t\tbtrfs_warn(uuid_root->fs_info, \"error %d while searching for uuid item!\",\n\t\t\tret);\n\t\tgoto out;\n\t}\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\toffset = btrfs_item_ptr_offset(eb, slot);\n\titem_size = btrfs_item_size_nr(eb, slot);\n\tif (!IS_ALIGNED(item_size, sizeof(u64))) {\n\t\tbtrfs_warn(uuid_root->fs_info, \"uuid item with illegal size %lu!\",\n\t\t\t(unsigned long)item_size);\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\twhile (item_size) {\n\t\t__le64 read_subid;\n\n\t\tread_extent_buffer(eb, &read_subid, offset, sizeof(read_subid));\n\t\tif (le64_to_cpu(read_subid) == subid)\n\t\t\tbreak;\n\t\toffset += sizeof(read_subid);\n\t\titem_size -= sizeof(read_subid);\n\t}\n\n\tif (!item_size) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\titem_size = btrfs_item_size_nr(eb, slot);\n\tif (item_size == sizeof(subid)) {\n\t\tret = btrfs_del_item(trans, uuid_root, path);\n\t\tgoto out;\n\t}\n\n\tmove_dst = offset;\n\tmove_src = offset + sizeof(subid);\n\tmove_len = item_size - (move_src - btrfs_item_ptr_offset(eb, slot));\n\tmemmove_extent_buffer(eb, move_dst, move_src, move_len);\n\tbtrfs_truncate_item(uuid_root, path, item_size - sizeof(subid), 1);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/uuid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/uuid.h>\n\nint btrfs_uuid_tree_rem(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_root *uuid_root, u8 *uuid, u8 type,\n\t\t\tu64 subid)\n{\n\tint ret;\n\tstruct btrfs_path *path = NULL;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tunsigned long offset;\n\tu32 item_size;\n\tunsigned long move_dst;\n\tunsigned long move_src;\n\tunsigned long move_len;\n\n\tif (WARN_ON_ONCE(!uuid_root)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tbtrfs_uuid_to_key(uuid, type, &key);\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_search_slot(trans, uuid_root, &key, path, -1, 1);\n\tif (ret < 0) {\n\t\tbtrfs_warn(uuid_root->fs_info, \"error %d while searching for uuid item!\",\n\t\t\tret);\n\t\tgoto out;\n\t}\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\toffset = btrfs_item_ptr_offset(eb, slot);\n\titem_size = btrfs_item_size_nr(eb, slot);\n\tif (!IS_ALIGNED(item_size, sizeof(u64))) {\n\t\tbtrfs_warn(uuid_root->fs_info, \"uuid item with illegal size %lu!\",\n\t\t\t(unsigned long)item_size);\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\twhile (item_size) {\n\t\t__le64 read_subid;\n\n\t\tread_extent_buffer(eb, &read_subid, offset, sizeof(read_subid));\n\t\tif (le64_to_cpu(read_subid) == subid)\n\t\t\tbreak;\n\t\toffset += sizeof(read_subid);\n\t\titem_size -= sizeof(read_subid);\n\t}\n\n\tif (!item_size) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\titem_size = btrfs_item_size_nr(eb, slot);\n\tif (item_size == sizeof(subid)) {\n\t\tret = btrfs_del_item(trans, uuid_root, path);\n\t\tgoto out;\n\t}\n\n\tmove_dst = offset;\n\tmove_src = offset + sizeof(subid);\n\tmove_len = item_size - (move_src - btrfs_item_ptr_offset(eb, slot));\n\tmemmove_extent_buffer(eb, move_dst, move_src, move_len);\n\tbtrfs_truncate_item(uuid_root, path, item_size - sizeof(subid), 1);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "root_item->received_uuid",
            "sa->uuid",
            "BTRFS_UUID_SIZE"
          ],
          "line": 4850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 4841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 4840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_start_transaction",
          "args": [
            "root",
            "3"
          ],
          "line": 4839
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_transaction_lflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "569-574",
          "snippet": "struct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_root_readonly",
          "args": [
            "root"
          ],
          "line": 4830
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_root_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2876-2879",
          "snippet": "static inline bool btrfs_root_readonly(struct btrfs_root *root)\n{\n\treturn (root->root_item.flags & cpu_to_le64(BTRFS_ROOT_SUBVOL_RDONLY)) != 0;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_ROOT_SUBVOL_RDONLY\t(1ULL << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_ROOT_SUBVOL_RDONLY\t(1ULL << 0)\n\nstatic inline bool btrfs_root_readonly(struct btrfs_root *root)\n{\n\treturn (root->root_item.flags & cpu_to_le64(BTRFS_ROOT_SUBVOL_RDONLY)) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ino",
          "args": [
            "inode"
          ],
          "line": 4825
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_resume_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "311-316",
          "snippet": "static inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [
            "#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\n#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10\n\nstatic inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&root->fs_info->subvol_sem"
          ],
          "line": 4823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "file"
          ],
          "line": 4819
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_owner_or_capable",
          "args": [
            "inode"
          ],
          "line": 4816
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 4809
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 4808
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long _btrfs_ioctl_set_received_subvol(struct file *file,\n\t\t\t\t\t    struct btrfs_ioctl_received_subvol_args *sa)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_root_item *root_item = &root->root_item;\n\tstruct btrfs_trans_handle *trans;\n\tstruct timespec ct = CURRENT_TIME;\n\tint ret = 0;\n\tint received_uuid_changed;\n\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdown_write(&root->fs_info->subvol_sem);\n\n\tif (btrfs_ino(inode) != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (btrfs_root_readonly(root)) {\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * 1 - root item\n\t * 2 - uuid items (received uuid + subvol uuid)\n\t */\n\ttrans = btrfs_start_transaction(root, 3);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\ttrans = NULL;\n\t\tgoto out;\n\t}\n\n\tsa->rtransid = trans->transid;\n\tsa->rtime.sec = ct.tv_sec;\n\tsa->rtime.nsec = ct.tv_nsec;\n\n\treceived_uuid_changed = memcmp(root_item->received_uuid, sa->uuid,\n\t\t\t\t       BTRFS_UUID_SIZE);\n\tif (received_uuid_changed &&\n\t    !btrfs_is_empty_uuid(root_item->received_uuid))\n\t\tbtrfs_uuid_tree_rem(trans, root->fs_info->uuid_root,\n\t\t\t\t    root_item->received_uuid,\n\t\t\t\t    BTRFS_UUID_KEY_RECEIVED_SUBVOL,\n\t\t\t\t    root->root_key.objectid);\n\tmemcpy(root_item->received_uuid, sa->uuid, BTRFS_UUID_SIZE);\n\tbtrfs_set_root_stransid(root_item, sa->stransid);\n\tbtrfs_set_root_rtransid(root_item, sa->rtransid);\n\tbtrfs_set_stack_timespec_sec(&root_item->stime, sa->stime.sec);\n\tbtrfs_set_stack_timespec_nsec(&root_item->stime, sa->stime.nsec);\n\tbtrfs_set_stack_timespec_sec(&root_item->rtime, sa->rtime.sec);\n\tbtrfs_set_stack_timespec_nsec(&root_item->rtime, sa->rtime.nsec);\n\n\tret = btrfs_update_root(trans, root->fs_info->tree_root,\n\t\t\t\t&root->root_key, &root->root_item);\n\tif (ret < 0) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\tgoto out;\n\t}\n\tif (received_uuid_changed && !btrfs_is_empty_uuid(sa->uuid)) {\n\t\tret = btrfs_uuid_tree_add(trans, root->fs_info->uuid_root,\n\t\t\t\t\t  sa->uuid,\n\t\t\t\t\t  BTRFS_UUID_KEY_RECEIVED_SUBVOL,\n\t\t\t\t\t  root->root_key.objectid);\n\t\tif (ret < 0 && ret != -EEXIST) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tret = btrfs_commit_transaction(trans, root);\n\tif (ret < 0) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto out;\n\t}\n\nout:\n\tup_write(&root->fs_info->subvol_sem);\n\tmnt_drop_write_file(file);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_ioctl_quota_rescan_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "4795-4803",
    "snippet": "static long btrfs_ioctl_quota_rescan_wait(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\treturn btrfs_qgroup_wait_for_completion(root->fs_info);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_qgroup_wait_for_completion",
          "args": [
            "root->fs_info"
          ],
          "line": 4802
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_qgroup_wait_for_completion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "2798-2814",
          "snippet": "int btrfs_qgroup_wait_for_completion(struct btrfs_fs_info *fs_info)\n{\n\tint running;\n\tint ret = 0;\n\n\tmutex_lock(&fs_info->qgroup_rescan_lock);\n\tspin_lock(&fs_info->qgroup_lock);\n\trunning = fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN;\n\tspin_unlock(&fs_info->qgroup_lock);\n\tmutex_unlock(&fs_info->qgroup_rescan_lock);\n\n\tif (running)\n\t\tret = wait_for_completion_interruptible(\n\t\t\t\t\t&fs_info->qgroup_rescan_completion);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nint btrfs_qgroup_wait_for_completion(struct btrfs_fs_info *fs_info)\n{\n\tint running;\n\tint ret = 0;\n\n\tmutex_lock(&fs_info->qgroup_rescan_lock);\n\tspin_lock(&fs_info->qgroup_lock);\n\trunning = fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN;\n\tspin_unlock(&fs_info->qgroup_lock);\n\tmutex_unlock(&fs_info->qgroup_rescan_lock);\n\n\tif (running)\n\t\tret = wait_for_completion_interruptible(\n\t\t\t\t\t&fs_info->qgroup_rescan_completion);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 4799
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "file_inode(file)"
          ],
          "line": 4797
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 4797
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_quota_rescan_wait(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\treturn btrfs_qgroup_wait_for_completion(root->fs_info);\n}"
  },
  {
    "function_name": "btrfs_ioctl_quota_rescan_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "4770-4793",
    "snippet": "static long btrfs_ioctl_quota_rescan_status(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tstruct btrfs_ioctl_quota_rescan_args *qsa;\n\tint ret = 0;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tqsa = kzalloc(sizeof(*qsa), GFP_NOFS);\n\tif (!qsa)\n\t\treturn -ENOMEM;\n\n\tif (root->fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN) {\n\t\tqsa->flags = 1;\n\t\tqsa->progress = root->fs_info->qgroup_rescan_progress.objectid;\n\t}\n\n\tif (copy_to_user(arg, qsa, sizeof(*qsa)))\n\t\tret = -EFAULT;\n\n\tkfree(qsa);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "qsa"
          ],
          "line": 4791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "arg",
            "qsa",
            "sizeof(*qsa)"
          ],
          "line": 4788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*qsa)",
            "GFP_NOFS"
          ],
          "line": 4779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 4776
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "file_inode(file)"
          ],
          "line": 4772
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 4772
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_quota_rescan_status(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tstruct btrfs_ioctl_quota_rescan_args *qsa;\n\tint ret = 0;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tqsa = kzalloc(sizeof(*qsa), GFP_NOFS);\n\tif (!qsa)\n\t\treturn -ENOMEM;\n\n\tif (root->fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN) {\n\t\tqsa->flags = 1;\n\t\tqsa->progress = root->fs_info->qgroup_rescan_progress.objectid;\n\t}\n\n\tif (copy_to_user(arg, qsa, sizeof(*qsa)))\n\t\tret = -EFAULT;\n\n\tkfree(qsa);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_ioctl_quota_rescan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "4737-4768",
    "snippet": "static long btrfs_ioctl_quota_rescan(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tstruct btrfs_ioctl_quota_rescan_args *qsa;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tqsa = memdup_user(arg, sizeof(*qsa));\n\tif (IS_ERR(qsa)) {\n\t\tret = PTR_ERR(qsa);\n\t\tgoto drop_write;\n\t}\n\n\tif (qsa->flags) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_qgroup_rescan(root->fs_info);\n\nout:\n\tkfree(qsa);\ndrop_write:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "file"
          ],
          "line": 4766
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "qsa"
          ],
          "line": 4764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_qgroup_rescan",
          "args": [
            "root->fs_info"
          ],
          "line": 4761
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_qgroup_rescan_resume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "2820-2826",
          "snippet": "void\nbtrfs_qgroup_rescan_resume(struct btrfs_fs_info *fs_info)\n{\n\tif (fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN)\n\t\tbtrfs_queue_work(fs_info->qgroup_rescan_workers,\n\t\t\t\t &fs_info->qgroup_rescan_work);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nvoid\nbtrfs_qgroup_rescan_resume(struct btrfs_fs_info *fs_info)\n{\n\tif (fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN)\n\t\tbtrfs_queue_work(fs_info->qgroup_rescan_workers,\n\t\t\t\t &fs_info->qgroup_rescan_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "qsa"
          ],
          "line": 4752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "qsa"
          ],
          "line": 4751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user",
          "args": [
            "arg",
            "sizeof(*qsa)"
          ],
          "line": 4750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "file"
          ],
          "line": 4746
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 4743
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "file_inode(file)"
          ],
          "line": 4739
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 4739
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_quota_rescan(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tstruct btrfs_ioctl_quota_rescan_args *qsa;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tqsa = memdup_user(arg, sizeof(*qsa));\n\tif (IS_ERR(qsa)) {\n\t\tret = PTR_ERR(qsa);\n\t\tgoto drop_write;\n\t}\n\n\tif (qsa->flags) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_qgroup_rescan(root->fs_info);\n\nout:\n\tkfree(qsa);\ndrop_write:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_ioctl_qgroup_limit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "4689-4735",
    "snippet": "static long btrfs_ioctl_qgroup_limit(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tstruct btrfs_ioctl_qgroup_limit_args *sa;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\tint err;\n\tu64 qgroupid;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tsa = memdup_user(arg, sizeof(*sa));\n\tif (IS_ERR(sa)) {\n\t\tret = PTR_ERR(sa);\n\t\tgoto drop_write;\n\t}\n\n\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out;\n\t}\n\n\tqgroupid = sa->qgroupid;\n\tif (!qgroupid) {\n\t\t/* take the current subvol as qgroup */\n\t\tqgroupid = root->root_key.objectid;\n\t}\n\n\t/* FIXME: check if the IDs really exist */\n\tret = btrfs_limit_qgroup(trans, root->fs_info, qgroupid, &sa->lim);\n\n\terr = btrfs_end_transaction(trans, root);\n\tif (err && !ret)\n\t\tret = err;\n\nout:\n\tkfree(sa);\ndrop_write:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "file"
          ],
          "line": 4733
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sa"
          ],
          "line": 4731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_end_transaction",
          "args": [
            "trans",
            "root"
          ],
          "line": 4726
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_end_transaction_throttle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "846-850",
          "snippet": "int btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_limit_qgroup",
          "args": [
            "trans",
            "root->fs_info",
            "qgroupid",
            "&sa->lim"
          ],
          "line": 4724
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_limit_qgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "1167-1207",
          "snippet": "int btrfs_limit_qgroup(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_fs_info *fs_info, u64 qgroupid,\n\t\t       struct btrfs_qgroup_limit *limit)\n{\n\tstruct btrfs_root *quota_root;\n\tstruct btrfs_qgroup *qgroup;\n\tint ret = 0;\n\n\tmutex_lock(&fs_info->qgroup_ioctl_lock);\n\tquota_root = fs_info->quota_root;\n\tif (!quota_root) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tqgroup = find_qgroup_rb(fs_info, qgroupid);\n\tif (!qgroup) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tret = update_qgroup_limit_item(trans, quota_root, qgroupid,\n\t\t\t\t       limit->flags, limit->max_rfer,\n\t\t\t\t       limit->max_excl, limit->rsv_rfer,\n\t\t\t\t       limit->rsv_excl);\n\tif (ret) {\n\t\tfs_info->qgroup_flags |= BTRFS_QGROUP_STATUS_FLAG_INCONSISTENT;\n\t\tbtrfs_info(fs_info, \"unable to update quota limit for %llu\",\n\t\t       qgroupid);\n\t}\n\n\tspin_lock(&fs_info->qgroup_lock);\n\tqgroup->lim_flags = limit->flags;\n\tqgroup->max_rfer = limit->max_rfer;\n\tqgroup->max_excl = limit->max_excl;\n\tqgroup->rsv_rfer = limit->rsv_rfer;\n\tqgroup->rsv_excl = limit->rsv_excl;\n\tspin_unlock(&fs_info->qgroup_lock);\nout:\n\tmutex_unlock(&fs_info->qgroup_ioctl_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nint btrfs_limit_qgroup(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_fs_info *fs_info, u64 qgroupid,\n\t\t       struct btrfs_qgroup_limit *limit)\n{\n\tstruct btrfs_root *quota_root;\n\tstruct btrfs_qgroup *qgroup;\n\tint ret = 0;\n\n\tmutex_lock(&fs_info->qgroup_ioctl_lock);\n\tquota_root = fs_info->quota_root;\n\tif (!quota_root) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tqgroup = find_qgroup_rb(fs_info, qgroupid);\n\tif (!qgroup) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tret = update_qgroup_limit_item(trans, quota_root, qgroupid,\n\t\t\t\t       limit->flags, limit->max_rfer,\n\t\t\t\t       limit->max_excl, limit->rsv_rfer,\n\t\t\t\t       limit->rsv_excl);\n\tif (ret) {\n\t\tfs_info->qgroup_flags |= BTRFS_QGROUP_STATUS_FLAG_INCONSISTENT;\n\t\tbtrfs_info(fs_info, \"unable to update quota limit for %llu\",\n\t\t       qgroupid);\n\t}\n\n\tspin_lock(&fs_info->qgroup_lock);\n\tqgroup->lim_flags = limit->flags;\n\tqgroup->max_rfer = limit->max_rfer;\n\tqgroup->max_excl = limit->max_excl;\n\tqgroup->rsv_rfer = limit->rsv_rfer;\n\tqgroup->rsv_excl = limit->rsv_excl;\n\tspin_unlock(&fs_info->qgroup_lock);\nout:\n\tmutex_unlock(&fs_info->qgroup_ioctl_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 4713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 4712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_join_transaction",
          "args": [
            "root"
          ],
          "line": 4711
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_join_transaction_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "581-584",
          "snippet": "struct btrfs_trans_handle *btrfs_join_transaction_nolock(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_JOIN_NOLOCK, 0);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_join_transaction_nolock(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_JOIN_NOLOCK, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "sa"
          ],
          "line": 4707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "sa"
          ],
          "line": 4706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user",
          "args": [
            "arg",
            "sizeof(*sa)"
          ],
          "line": 4705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "file"
          ],
          "line": 4701
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 4698
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "file_inode(file)"
          ],
          "line": 4691
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 4691
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_qgroup_limit(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tstruct btrfs_ioctl_qgroup_limit_args *sa;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\tint err;\n\tu64 qgroupid;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tsa = memdup_user(arg, sizeof(*sa));\n\tif (IS_ERR(sa)) {\n\t\tret = PTR_ERR(sa);\n\t\tgoto drop_write;\n\t}\n\n\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out;\n\t}\n\n\tqgroupid = sa->qgroupid;\n\tif (!qgroupid) {\n\t\t/* take the current subvol as qgroup */\n\t\tqgroupid = root->root_key.objectid;\n\t}\n\n\t/* FIXME: check if the IDs really exist */\n\tret = btrfs_limit_qgroup(trans, root->fs_info, qgroupid, &sa->lim);\n\n\terr = btrfs_end_transaction(trans, root);\n\tif (err && !ret)\n\t\tret = err;\n\nout:\n\tkfree(sa);\ndrop_write:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_ioctl_qgroup_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "4638-4687",
    "snippet": "static long btrfs_ioctl_qgroup_create(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tstruct btrfs_ioctl_qgroup_create_args *sa;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\tint err;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tsa = memdup_user(arg, sizeof(*sa));\n\tif (IS_ERR(sa)) {\n\t\tret = PTR_ERR(sa);\n\t\tgoto drop_write;\n\t}\n\n\tif (!sa->qgroupid) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out;\n\t}\n\n\t/* FIXME: check if the IDs really exist */\n\tif (sa->create) {\n\t\tret = btrfs_create_qgroup(trans, root->fs_info, sa->qgroupid,\n\t\t\t\t\t  NULL);\n\t} else {\n\t\tret = btrfs_remove_qgroup(trans, root->fs_info, sa->qgroupid);\n\t}\n\n\terr = btrfs_end_transaction(trans, root);\n\tif (err && !ret)\n\t\tret = err;\n\nout:\n\tkfree(sa);\ndrop_write:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "file"
          ],
          "line": 4685
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sa"
          ],
          "line": 4683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_end_transaction",
          "args": [
            "trans",
            "root"
          ],
          "line": 4678
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_end_transaction_throttle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "846-850",
          "snippet": "int btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_remove_qgroup",
          "args": [
            "trans",
            "root->fs_info",
            "sa->qgroupid"
          ],
          "line": 4675
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_remove_qgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "1131-1165",
          "snippet": "int btrfs_remove_qgroup(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_fs_info *fs_info, u64 qgroupid)\n{\n\tstruct btrfs_root *quota_root;\n\tstruct btrfs_qgroup *qgroup;\n\tint ret = 0;\n\n\tmutex_lock(&fs_info->qgroup_ioctl_lock);\n\tquota_root = fs_info->quota_root;\n\tif (!quota_root) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tqgroup = find_qgroup_rb(fs_info, qgroupid);\n\tif (!qgroup) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t} else {\n\t\t/* check if there are no relations to this qgroup */\n\t\tif (!list_empty(&qgroup->groups) ||\n\t\t    !list_empty(&qgroup->members)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tret = del_qgroup_item(trans, quota_root, qgroupid);\n\n\tspin_lock(&fs_info->qgroup_lock);\n\tdel_qgroup_rb(quota_root->fs_info, qgroupid);\n\tspin_unlock(&fs_info->qgroup_lock);\nout:\n\tmutex_unlock(&fs_info->qgroup_ioctl_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nint btrfs_remove_qgroup(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_fs_info *fs_info, u64 qgroupid)\n{\n\tstruct btrfs_root *quota_root;\n\tstruct btrfs_qgroup *qgroup;\n\tint ret = 0;\n\n\tmutex_lock(&fs_info->qgroup_ioctl_lock);\n\tquota_root = fs_info->quota_root;\n\tif (!quota_root) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tqgroup = find_qgroup_rb(fs_info, qgroupid);\n\tif (!qgroup) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t} else {\n\t\t/* check if there are no relations to this qgroup */\n\t\tif (!list_empty(&qgroup->groups) ||\n\t\t    !list_empty(&qgroup->members)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tret = del_qgroup_item(trans, quota_root, qgroupid);\n\n\tspin_lock(&fs_info->qgroup_lock);\n\tdel_qgroup_rb(quota_root->fs_info, qgroupid);\n\tspin_unlock(&fs_info->qgroup_lock);\nout:\n\tmutex_unlock(&fs_info->qgroup_ioctl_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_create_qgroup",
          "args": [
            "trans",
            "root->fs_info",
            "sa->qgroupid",
            "NULL"
          ],
          "line": 4672
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_create_qgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "1097-1129",
          "snippet": "int btrfs_create_qgroup(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_fs_info *fs_info, u64 qgroupid, char *name)\n{\n\tstruct btrfs_root *quota_root;\n\tstruct btrfs_qgroup *qgroup;\n\tint ret = 0;\n\n\tmutex_lock(&fs_info->qgroup_ioctl_lock);\n\tquota_root = fs_info->quota_root;\n\tif (!quota_root) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tqgroup = find_qgroup_rb(fs_info, qgroupid);\n\tif (qgroup) {\n\t\tret = -EEXIST;\n\t\tgoto out;\n\t}\n\n\tret = add_qgroup_item(trans, quota_root, qgroupid);\n\tif (ret)\n\t\tgoto out;\n\n\tspin_lock(&fs_info->qgroup_lock);\n\tqgroup = add_qgroup_rb(fs_info, qgroupid);\n\tspin_unlock(&fs_info->qgroup_lock);\n\n\tif (IS_ERR(qgroup))\n\t\tret = PTR_ERR(qgroup);\nout:\n\tmutex_unlock(&fs_info->qgroup_ioctl_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nint btrfs_create_qgroup(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_fs_info *fs_info, u64 qgroupid, char *name)\n{\n\tstruct btrfs_root *quota_root;\n\tstruct btrfs_qgroup *qgroup;\n\tint ret = 0;\n\n\tmutex_lock(&fs_info->qgroup_ioctl_lock);\n\tquota_root = fs_info->quota_root;\n\tif (!quota_root) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tqgroup = find_qgroup_rb(fs_info, qgroupid);\n\tif (qgroup) {\n\t\tret = -EEXIST;\n\t\tgoto out;\n\t}\n\n\tret = add_qgroup_item(trans, quota_root, qgroupid);\n\tif (ret)\n\t\tgoto out;\n\n\tspin_lock(&fs_info->qgroup_lock);\n\tqgroup = add_qgroup_rb(fs_info, qgroupid);\n\tspin_unlock(&fs_info->qgroup_lock);\n\n\tif (IS_ERR(qgroup))\n\t\tret = PTR_ERR(qgroup);\nout:\n\tmutex_unlock(&fs_info->qgroup_ioctl_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 4666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 4665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_join_transaction",
          "args": [
            "root"
          ],
          "line": 4664
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_join_transaction_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "581-584",
          "snippet": "struct btrfs_trans_handle *btrfs_join_transaction_nolock(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_JOIN_NOLOCK, 0);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_join_transaction_nolock(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_JOIN_NOLOCK, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "sa"
          ],
          "line": 4655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "sa"
          ],
          "line": 4654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user",
          "args": [
            "arg",
            "sizeof(*sa)"
          ],
          "line": 4653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "file"
          ],
          "line": 4649
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 4646
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "file_inode(file)"
          ],
          "line": 4640
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 4640
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_qgroup_create(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tstruct btrfs_ioctl_qgroup_create_args *sa;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\tint err;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tsa = memdup_user(arg, sizeof(*sa));\n\tif (IS_ERR(sa)) {\n\t\tret = PTR_ERR(sa);\n\t\tgoto drop_write;\n\t}\n\n\tif (!sa->qgroupid) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out;\n\t}\n\n\t/* FIXME: check if the IDs really exist */\n\tif (sa->create) {\n\t\tret = btrfs_create_qgroup(trans, root->fs_info, sa->qgroupid,\n\t\t\t\t\t  NULL);\n\t} else {\n\t\tret = btrfs_remove_qgroup(trans, root->fs_info, sa->qgroupid);\n\t}\n\n\terr = btrfs_end_transaction(trans, root);\n\tif (err && !ret)\n\t\tret = err;\n\nout:\n\tkfree(sa);\ndrop_write:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_ioctl_qgroup_assign",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "4591-4636",
    "snippet": "static long btrfs_ioctl_qgroup_assign(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tstruct btrfs_ioctl_qgroup_assign_args *sa;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\tint err;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tsa = memdup_user(arg, sizeof(*sa));\n\tif (IS_ERR(sa)) {\n\t\tret = PTR_ERR(sa);\n\t\tgoto drop_write;\n\t}\n\n\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out;\n\t}\n\n\t/* FIXME: check if the IDs really exist */\n\tif (sa->assign) {\n\t\tret = btrfs_add_qgroup_relation(trans, root->fs_info,\n\t\t\t\t\t\tsa->src, sa->dst);\n\t} else {\n\t\tret = btrfs_del_qgroup_relation(trans, root->fs_info,\n\t\t\t\t\t\tsa->src, sa->dst);\n\t}\n\n\terr = btrfs_end_transaction(trans, root);\n\tif (err && !ret)\n\t\tret = err;\n\nout:\n\tkfree(sa);\ndrop_write:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "file"
          ],
          "line": 4634
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sa"
          ],
          "line": 4632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_end_transaction",
          "args": [
            "trans",
            "root"
          ],
          "line": 4627
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_end_transaction_throttle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "846-850",
          "snippet": "int btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_del_qgroup_relation",
          "args": [
            "trans",
            "root->fs_info",
            "sa->src",
            "sa->dst"
          ],
          "line": 4623
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_del_qgroup_relation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "1052-1095",
          "snippet": "int btrfs_del_qgroup_relation(struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_fs_info *fs_info, u64 src, u64 dst)\n{\n\tstruct btrfs_root *quota_root;\n\tstruct btrfs_qgroup *parent;\n\tstruct btrfs_qgroup *member;\n\tstruct btrfs_qgroup_list *list;\n\tint ret = 0;\n\tint err;\n\n\tmutex_lock(&fs_info->qgroup_ioctl_lock);\n\tquota_root = fs_info->quota_root;\n\tif (!quota_root) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmember = find_qgroup_rb(fs_info, src);\n\tparent = find_qgroup_rb(fs_info, dst);\n\tif (!member || !parent) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* check if such qgroup relation exist firstly */\n\tlist_for_each_entry(list, &member->groups, next_group) {\n\t\tif (list->group == parent)\n\t\t\tgoto exist;\n\t}\n\tret = -ENOENT;\n\tgoto out;\nexist:\n\tret = del_qgroup_relation_item(trans, quota_root, src, dst);\n\terr = del_qgroup_relation_item(trans, quota_root, dst, src);\n\tif (err && !ret)\n\t\tret = err;\n\n\tspin_lock(&fs_info->qgroup_lock);\n\tdel_relation_rb(fs_info, src, dst);\n\tspin_unlock(&fs_info->qgroup_lock);\nout:\n\tmutex_unlock(&fs_info->qgroup_ioctl_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nint btrfs_del_qgroup_relation(struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_fs_info *fs_info, u64 src, u64 dst)\n{\n\tstruct btrfs_root *quota_root;\n\tstruct btrfs_qgroup *parent;\n\tstruct btrfs_qgroup *member;\n\tstruct btrfs_qgroup_list *list;\n\tint ret = 0;\n\tint err;\n\n\tmutex_lock(&fs_info->qgroup_ioctl_lock);\n\tquota_root = fs_info->quota_root;\n\tif (!quota_root) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmember = find_qgroup_rb(fs_info, src);\n\tparent = find_qgroup_rb(fs_info, dst);\n\tif (!member || !parent) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* check if such qgroup relation exist firstly */\n\tlist_for_each_entry(list, &member->groups, next_group) {\n\t\tif (list->group == parent)\n\t\t\tgoto exist;\n\t}\n\tret = -ENOENT;\n\tgoto out;\nexist:\n\tret = del_qgroup_relation_item(trans, quota_root, src, dst);\n\terr = del_qgroup_relation_item(trans, quota_root, dst, src);\n\tif (err && !ret)\n\t\tret = err;\n\n\tspin_lock(&fs_info->qgroup_lock);\n\tdel_relation_rb(fs_info, src, dst);\n\tspin_unlock(&fs_info->qgroup_lock);\nout:\n\tmutex_unlock(&fs_info->qgroup_ioctl_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_add_qgroup_relation",
          "args": [
            "trans",
            "root->fs_info",
            "sa->src",
            "sa->dst"
          ],
          "line": 4620
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_add_qgroup_relation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "1004-1050",
          "snippet": "int btrfs_add_qgroup_relation(struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_fs_info *fs_info, u64 src, u64 dst)\n{\n\tstruct btrfs_root *quota_root;\n\tstruct btrfs_qgroup *parent;\n\tstruct btrfs_qgroup *member;\n\tstruct btrfs_qgroup_list *list;\n\tint ret = 0;\n\n\tmutex_lock(&fs_info->qgroup_ioctl_lock);\n\tquota_root = fs_info->quota_root;\n\tif (!quota_root) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tmember = find_qgroup_rb(fs_info, src);\n\tparent = find_qgroup_rb(fs_info, dst);\n\tif (!member || !parent) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* check if such qgroup relation exist firstly */\n\tlist_for_each_entry(list, &member->groups, next_group) {\n\t\tif (list->group == parent) {\n\t\t\tret = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = add_qgroup_relation_item(trans, quota_root, src, dst);\n\tif (ret)\n\t\tgoto out;\n\n\tret = add_qgroup_relation_item(trans, quota_root, dst, src);\n\tif (ret) {\n\t\tdel_qgroup_relation_item(trans, quota_root, src, dst);\n\t\tgoto out;\n\t}\n\n\tspin_lock(&fs_info->qgroup_lock);\n\tret = add_relation_rb(quota_root->fs_info, src, dst);\n\tspin_unlock(&fs_info->qgroup_lock);\nout:\n\tmutex_unlock(&fs_info->qgroup_ioctl_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nint btrfs_add_qgroup_relation(struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_fs_info *fs_info, u64 src, u64 dst)\n{\n\tstruct btrfs_root *quota_root;\n\tstruct btrfs_qgroup *parent;\n\tstruct btrfs_qgroup *member;\n\tstruct btrfs_qgroup_list *list;\n\tint ret = 0;\n\n\tmutex_lock(&fs_info->qgroup_ioctl_lock);\n\tquota_root = fs_info->quota_root;\n\tif (!quota_root) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tmember = find_qgroup_rb(fs_info, src);\n\tparent = find_qgroup_rb(fs_info, dst);\n\tif (!member || !parent) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* check if such qgroup relation exist firstly */\n\tlist_for_each_entry(list, &member->groups, next_group) {\n\t\tif (list->group == parent) {\n\t\t\tret = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = add_qgroup_relation_item(trans, quota_root, src, dst);\n\tif (ret)\n\t\tgoto out;\n\n\tret = add_qgroup_relation_item(trans, quota_root, dst, src);\n\tif (ret) {\n\t\tdel_qgroup_relation_item(trans, quota_root, src, dst);\n\t\tgoto out;\n\t}\n\n\tspin_lock(&fs_info->qgroup_lock);\n\tret = add_relation_rb(quota_root->fs_info, src, dst);\n\tspin_unlock(&fs_info->qgroup_lock);\nout:\n\tmutex_unlock(&fs_info->qgroup_ioctl_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 4614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 4613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_join_transaction",
          "args": [
            "root"
          ],
          "line": 4612
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_join_transaction_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "581-584",
          "snippet": "struct btrfs_trans_handle *btrfs_join_transaction_nolock(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_JOIN_NOLOCK, 0);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_join_transaction_nolock(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_JOIN_NOLOCK, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "sa"
          ],
          "line": 4608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "sa"
          ],
          "line": 4607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user",
          "args": [
            "arg",
            "sizeof(*sa)"
          ],
          "line": 4606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "file"
          ],
          "line": 4602
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 4599
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "file_inode(file)"
          ],
          "line": 4593
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 4593
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_qgroup_assign(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tstruct btrfs_ioctl_qgroup_assign_args *sa;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\tint err;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tsa = memdup_user(arg, sizeof(*sa));\n\tif (IS_ERR(sa)) {\n\t\tret = PTR_ERR(sa);\n\t\tgoto drop_write;\n\t}\n\n\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out;\n\t}\n\n\t/* FIXME: check if the IDs really exist */\n\tif (sa->assign) {\n\t\tret = btrfs_add_qgroup_relation(trans, root->fs_info,\n\t\t\t\t\t\tsa->src, sa->dst);\n\t} else {\n\t\tret = btrfs_del_qgroup_relation(trans, root->fs_info,\n\t\t\t\t\t\tsa->src, sa->dst);\n\t}\n\n\terr = btrfs_end_transaction(trans, root);\n\tif (err && !ret)\n\t\tret = err;\n\nout:\n\tkfree(sa);\ndrop_write:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_ioctl_quota_ctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "4540-4589",
    "snippet": "static long btrfs_ioctl_quota_ctl(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tstruct btrfs_ioctl_quota_ctl_args *sa;\n\tstruct btrfs_trans_handle *trans = NULL;\n\tint ret;\n\tint err;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tsa = memdup_user(arg, sizeof(*sa));\n\tif (IS_ERR(sa)) {\n\t\tret = PTR_ERR(sa);\n\t\tgoto drop_write;\n\t}\n\n\tdown_write(&root->fs_info->subvol_sem);\n\ttrans = btrfs_start_transaction(root->fs_info->tree_root, 2);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out;\n\t}\n\n\tswitch (sa->cmd) {\n\tcase BTRFS_QUOTA_CTL_ENABLE:\n\t\tret = btrfs_quota_enable(trans, root->fs_info);\n\t\tbreak;\n\tcase BTRFS_QUOTA_CTL_DISABLE:\n\t\tret = btrfs_quota_disable(trans, root->fs_info);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\terr = btrfs_commit_transaction(trans, root->fs_info->tree_root);\n\tif (err && !ret)\n\t\tret = err;\nout:\n\tkfree(sa);\n\tup_write(&root->fs_info->subvol_sem);\ndrop_write:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "file"
          ],
          "line": 4587
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&root->fs_info->subvol_sem"
          ],
          "line": 4585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sa"
          ],
          "line": 4584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_commit_transaction",
          "args": [
            "trans",
            "root->fs_info->tree_root"
          ],
          "line": 4580
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_commit_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "1764-2099",
          "snippet": "int btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_quota_disable",
          "args": [
            "trans",
            "root->fs_info"
          ],
          "line": 4573
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_quota_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "955-995",
          "snippet": "int btrfs_quota_disable(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *tree_root = fs_info->tree_root;\n\tstruct btrfs_root *quota_root;\n\tint ret = 0;\n\n\tmutex_lock(&fs_info->qgroup_ioctl_lock);\n\tif (!fs_info->quota_root)\n\t\tgoto out;\n\tspin_lock(&fs_info->qgroup_lock);\n\tfs_info->quota_enabled = 0;\n\tfs_info->pending_quota_state = 0;\n\tquota_root = fs_info->quota_root;\n\tfs_info->quota_root = NULL;\n\tspin_unlock(&fs_info->qgroup_lock);\n\n\tbtrfs_free_qgroup_config(fs_info);\n\n\tret = btrfs_clean_quota_tree(trans, quota_root);\n\tif (ret)\n\t\tgoto out;\n\n\tret = btrfs_del_root(trans, tree_root, &quota_root->root_key);\n\tif (ret)\n\t\tgoto out;\n\n\tlist_del(&quota_root->dirty_list);\n\n\tbtrfs_tree_lock(quota_root->node);\n\tclean_tree_block(trans, tree_root, quota_root->node);\n\tbtrfs_tree_unlock(quota_root->node);\n\tbtrfs_free_tree_block(trans, quota_root, quota_root->node, 0, 1);\n\n\tfree_extent_buffer(quota_root->node);\n\tfree_extent_buffer(quota_root->commit_root);\n\tkfree(quota_root);\nout:\n\tmutex_unlock(&fs_info->qgroup_ioctl_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nint btrfs_quota_disable(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *tree_root = fs_info->tree_root;\n\tstruct btrfs_root *quota_root;\n\tint ret = 0;\n\n\tmutex_lock(&fs_info->qgroup_ioctl_lock);\n\tif (!fs_info->quota_root)\n\t\tgoto out;\n\tspin_lock(&fs_info->qgroup_lock);\n\tfs_info->quota_enabled = 0;\n\tfs_info->pending_quota_state = 0;\n\tquota_root = fs_info->quota_root;\n\tfs_info->quota_root = NULL;\n\tspin_unlock(&fs_info->qgroup_lock);\n\n\tbtrfs_free_qgroup_config(fs_info);\n\n\tret = btrfs_clean_quota_tree(trans, quota_root);\n\tif (ret)\n\t\tgoto out;\n\n\tret = btrfs_del_root(trans, tree_root, &quota_root->root_key);\n\tif (ret)\n\t\tgoto out;\n\n\tlist_del(&quota_root->dirty_list);\n\n\tbtrfs_tree_lock(quota_root->node);\n\tclean_tree_block(trans, tree_root, quota_root->node);\n\tbtrfs_tree_unlock(quota_root->node);\n\tbtrfs_free_tree_block(trans, quota_root, quota_root->node, 0, 1);\n\n\tfree_extent_buffer(quota_root->node);\n\tfree_extent_buffer(quota_root->commit_root);\n\tkfree(quota_root);\nout:\n\tmutex_unlock(&fs_info->qgroup_ioctl_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_quota_enable",
          "args": [
            "trans",
            "root->fs_info"
          ],
          "line": 4570
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_quota_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "824-953",
          "snippet": "int btrfs_quota_enable(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *quota_root;\n\tstruct btrfs_root *tree_root = fs_info->tree_root;\n\tstruct btrfs_path *path = NULL;\n\tstruct btrfs_qgroup_status_item *ptr;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_qgroup *qgroup = NULL;\n\tint ret = 0;\n\tint slot;\n\n\tmutex_lock(&fs_info->qgroup_ioctl_lock);\n\tif (fs_info->quota_root) {\n\t\tfs_info->pending_quota_state = 1;\n\t\tgoto out;\n\t}\n\n\tfs_info->qgroup_ulist = ulist_alloc(GFP_NOFS);\n\tif (!fs_info->qgroup_ulist) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * initially create the quota tree\n\t */\n\tquota_root = btrfs_create_tree(trans, fs_info,\n\t\t\t\t       BTRFS_QUOTA_TREE_OBJECTID);\n\tif (IS_ERR(quota_root)) {\n\t\tret =  PTR_ERR(quota_root);\n\t\tgoto out;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_root;\n\t}\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_QGROUP_STATUS_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_insert_empty_item(trans, quota_root, path, &key,\n\t\t\t\t      sizeof(*ptr));\n\tif (ret)\n\t\tgoto out_free_path;\n\n\tleaf = path->nodes[0];\n\tptr = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t struct btrfs_qgroup_status_item);\n\tbtrfs_set_qgroup_status_generation(leaf, ptr, trans->transid);\n\tbtrfs_set_qgroup_status_version(leaf, ptr, BTRFS_QGROUP_STATUS_VERSION);\n\tfs_info->qgroup_flags = BTRFS_QGROUP_STATUS_FLAG_ON |\n\t\t\t\tBTRFS_QGROUP_STATUS_FLAG_INCONSISTENT;\n\tbtrfs_set_qgroup_status_flags(leaf, ptr, fs_info->qgroup_flags);\n\tbtrfs_set_qgroup_status_rescan(leaf, ptr, 0);\n\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_ROOT_REF_KEY;\n\tkey.offset = 0;\n\n\tbtrfs_release_path(path);\n\tret = btrfs_search_slot_for_read(tree_root, &key, path, 1, 0);\n\tif (ret > 0)\n\t\tgoto out_add_root;\n\tif (ret < 0)\n\t\tgoto out_free_path;\n\n\n\twhile (1) {\n\t\tslot = path->slots[0];\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, slot);\n\n\t\tif (found_key.type == BTRFS_ROOT_REF_KEY) {\n\t\t\tret = add_qgroup_item(trans, quota_root,\n\t\t\t\t\t      found_key.offset);\n\t\t\tif (ret)\n\t\t\t\tgoto out_free_path;\n\n\t\t\tqgroup = add_qgroup_rb(fs_info, found_key.offset);\n\t\t\tif (IS_ERR(qgroup)) {\n\t\t\t\tret = PTR_ERR(qgroup);\n\t\t\t\tgoto out_free_path;\n\t\t\t}\n\t\t}\n\t\tret = btrfs_next_item(tree_root, path);\n\t\tif (ret < 0)\n\t\t\tgoto out_free_path;\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\nout_add_root:\n\tbtrfs_release_path(path);\n\tret = add_qgroup_item(trans, quota_root, BTRFS_FS_TREE_OBJECTID);\n\tif (ret)\n\t\tgoto out_free_path;\n\n\tqgroup = add_qgroup_rb(fs_info, BTRFS_FS_TREE_OBJECTID);\n\tif (IS_ERR(qgroup)) {\n\t\tret = PTR_ERR(qgroup);\n\t\tgoto out_free_path;\n\t}\n\tspin_lock(&fs_info->qgroup_lock);\n\tfs_info->quota_root = quota_root;\n\tfs_info->pending_quota_state = 1;\n\tspin_unlock(&fs_info->qgroup_lock);\nout_free_path:\n\tbtrfs_free_path(path);\nout_free_root:\n\tif (ret) {\n\t\tfree_extent_buffer(quota_root->node);\n\t\tfree_extent_buffer(quota_root->commit_root);\n\t\tkfree(quota_root);\n\t}\nout:\n\tif (ret) {\n\t\tulist_free(fs_info->qgroup_ulist);\n\t\tfs_info->qgroup_ulist = NULL;\n\t}\n\tmutex_unlock(&fs_info->qgroup_ioctl_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nint btrfs_quota_enable(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *quota_root;\n\tstruct btrfs_root *tree_root = fs_info->tree_root;\n\tstruct btrfs_path *path = NULL;\n\tstruct btrfs_qgroup_status_item *ptr;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_qgroup *qgroup = NULL;\n\tint ret = 0;\n\tint slot;\n\n\tmutex_lock(&fs_info->qgroup_ioctl_lock);\n\tif (fs_info->quota_root) {\n\t\tfs_info->pending_quota_state = 1;\n\t\tgoto out;\n\t}\n\n\tfs_info->qgroup_ulist = ulist_alloc(GFP_NOFS);\n\tif (!fs_info->qgroup_ulist) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * initially create the quota tree\n\t */\n\tquota_root = btrfs_create_tree(trans, fs_info,\n\t\t\t\t       BTRFS_QUOTA_TREE_OBJECTID);\n\tif (IS_ERR(quota_root)) {\n\t\tret =  PTR_ERR(quota_root);\n\t\tgoto out;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_root;\n\t}\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_QGROUP_STATUS_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_insert_empty_item(trans, quota_root, path, &key,\n\t\t\t\t      sizeof(*ptr));\n\tif (ret)\n\t\tgoto out_free_path;\n\n\tleaf = path->nodes[0];\n\tptr = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t struct btrfs_qgroup_status_item);\n\tbtrfs_set_qgroup_status_generation(leaf, ptr, trans->transid);\n\tbtrfs_set_qgroup_status_version(leaf, ptr, BTRFS_QGROUP_STATUS_VERSION);\n\tfs_info->qgroup_flags = BTRFS_QGROUP_STATUS_FLAG_ON |\n\t\t\t\tBTRFS_QGROUP_STATUS_FLAG_INCONSISTENT;\n\tbtrfs_set_qgroup_status_flags(leaf, ptr, fs_info->qgroup_flags);\n\tbtrfs_set_qgroup_status_rescan(leaf, ptr, 0);\n\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_ROOT_REF_KEY;\n\tkey.offset = 0;\n\n\tbtrfs_release_path(path);\n\tret = btrfs_search_slot_for_read(tree_root, &key, path, 1, 0);\n\tif (ret > 0)\n\t\tgoto out_add_root;\n\tif (ret < 0)\n\t\tgoto out_free_path;\n\n\n\twhile (1) {\n\t\tslot = path->slots[0];\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, slot);\n\n\t\tif (found_key.type == BTRFS_ROOT_REF_KEY) {\n\t\t\tret = add_qgroup_item(trans, quota_root,\n\t\t\t\t\t      found_key.offset);\n\t\t\tif (ret)\n\t\t\t\tgoto out_free_path;\n\n\t\t\tqgroup = add_qgroup_rb(fs_info, found_key.offset);\n\t\t\tif (IS_ERR(qgroup)) {\n\t\t\t\tret = PTR_ERR(qgroup);\n\t\t\t\tgoto out_free_path;\n\t\t\t}\n\t\t}\n\t\tret = btrfs_next_item(tree_root, path);\n\t\tif (ret < 0)\n\t\t\tgoto out_free_path;\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\nout_add_root:\n\tbtrfs_release_path(path);\n\tret = add_qgroup_item(trans, quota_root, BTRFS_FS_TREE_OBJECTID);\n\tif (ret)\n\t\tgoto out_free_path;\n\n\tqgroup = add_qgroup_rb(fs_info, BTRFS_FS_TREE_OBJECTID);\n\tif (IS_ERR(qgroup)) {\n\t\tret = PTR_ERR(qgroup);\n\t\tgoto out_free_path;\n\t}\n\tspin_lock(&fs_info->qgroup_lock);\n\tfs_info->quota_root = quota_root;\n\tfs_info->pending_quota_state = 1;\n\tspin_unlock(&fs_info->qgroup_lock);\nout_free_path:\n\tbtrfs_free_path(path);\nout_free_root:\n\tif (ret) {\n\t\tfree_extent_buffer(quota_root->node);\n\t\tfree_extent_buffer(quota_root->commit_root);\n\t\tkfree(quota_root);\n\t}\nout:\n\tif (ret) {\n\t\tulist_free(fs_info->qgroup_ulist);\n\t\tfs_info->qgroup_ulist = NULL;\n\t}\n\tmutex_unlock(&fs_info->qgroup_ioctl_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 4564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 4563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_start_transaction",
          "args": [
            "root->fs_info->tree_root",
            "2"
          ],
          "line": 4562
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_transaction_lflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "569-574",
          "snippet": "struct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&root->fs_info->subvol_sem"
          ],
          "line": 4561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "sa"
          ],
          "line": 4557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "sa"
          ],
          "line": 4556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user",
          "args": [
            "arg",
            "sizeof(*sa)"
          ],
          "line": 4555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "file"
          ],
          "line": 4551
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 4548
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "file_inode(file)"
          ],
          "line": 4542
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 4542
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_quota_ctl(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tstruct btrfs_ioctl_quota_ctl_args *sa;\n\tstruct btrfs_trans_handle *trans = NULL;\n\tint ret;\n\tint err;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tsa = memdup_user(arg, sizeof(*sa));\n\tif (IS_ERR(sa)) {\n\t\tret = PTR_ERR(sa);\n\t\tgoto drop_write;\n\t}\n\n\tdown_write(&root->fs_info->subvol_sem);\n\ttrans = btrfs_start_transaction(root->fs_info->tree_root, 2);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out;\n\t}\n\n\tswitch (sa->cmd) {\n\tcase BTRFS_QUOTA_CTL_ENABLE:\n\t\tret = btrfs_quota_enable(trans, root->fs_info);\n\t\tbreak;\n\tcase BTRFS_QUOTA_CTL_DISABLE:\n\t\tret = btrfs_quota_disable(trans, root->fs_info);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\terr = btrfs_commit_transaction(trans, root->fs_info->tree_root);\n\tif (err && !ret)\n\t\tret = err;\nout:\n\tkfree(sa);\n\tup_write(&root->fs_info->subvol_sem);\ndrop_write:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_ioctl_balance_progress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "4507-4538",
    "snippet": "static long btrfs_ioctl_balance_progress(struct btrfs_root *root,\n\t\t\t\t\t void __user *arg)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_ioctl_balance_args *bargs;\n\tint ret = 0;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tmutex_lock(&fs_info->balance_mutex);\n\tif (!fs_info->balance_ctl) {\n\t\tret = -ENOTCONN;\n\t\tgoto out;\n\t}\n\n\tbargs = kzalloc(sizeof(*bargs), GFP_NOFS);\n\tif (!bargs) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tupdate_ioctl_balance_args(fs_info, 1, bargs);\n\n\tif (copy_to_user(arg, bargs, sizeof(*bargs)))\n\t\tret = -EFAULT;\n\n\tkfree(bargs);\nout:\n\tmutex_unlock(&fs_info->balance_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->balance_mutex"
          ],
          "line": 4536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bargs"
          ],
          "line": 4534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "arg",
            "bargs",
            "sizeof(*bargs)"
          ],
          "line": 4531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_ioctl_balance_args",
          "args": [
            "fs_info",
            "1",
            "bargs"
          ],
          "line": 4529
        },
        "resolved": true,
        "details": {
          "function_name": "update_ioctl_balance_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "4324-4349",
          "snippet": "void update_ioctl_balance_args(struct btrfs_fs_info *fs_info, int lock,\n\t\t\t       struct btrfs_ioctl_balance_args *bargs)\n{\n\tstruct btrfs_balance_control *bctl = fs_info->balance_ctl;\n\n\tbargs->flags = bctl->flags;\n\n\tif (atomic_read(&fs_info->balance_running))\n\t\tbargs->state |= BTRFS_BALANCE_STATE_RUNNING;\n\tif (atomic_read(&fs_info->balance_pause_req))\n\t\tbargs->state |= BTRFS_BALANCE_STATE_PAUSE_REQ;\n\tif (atomic_read(&fs_info->balance_cancel_req))\n\t\tbargs->state |= BTRFS_BALANCE_STATE_CANCEL_REQ;\n\n\tmemcpy(&bargs->data, &bctl->data, sizeof(bargs->data));\n\tmemcpy(&bargs->meta, &bctl->meta, sizeof(bargs->meta));\n\tmemcpy(&bargs->sys, &bctl->sys, sizeof(bargs->sys));\n\n\tif (lock) {\n\t\tspin_lock(&fs_info->balance_lock);\n\t\tmemcpy(&bargs->stat, &bctl->stat, sizeof(bargs->stat));\n\t\tspin_unlock(&fs_info->balance_lock);\n\t} else {\n\t\tmemcpy(&bargs->stat, &bctl->stat, sizeof(bargs->stat));\n\t}\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nvoid update_ioctl_balance_args(struct btrfs_fs_info *fs_info, int lock,\n\t\t\t       struct btrfs_ioctl_balance_args *bargs)\n{\n\tstruct btrfs_balance_control *bctl = fs_info->balance_ctl;\n\n\tbargs->flags = bctl->flags;\n\n\tif (atomic_read(&fs_info->balance_running))\n\t\tbargs->state |= BTRFS_BALANCE_STATE_RUNNING;\n\tif (atomic_read(&fs_info->balance_pause_req))\n\t\tbargs->state |= BTRFS_BALANCE_STATE_PAUSE_REQ;\n\tif (atomic_read(&fs_info->balance_cancel_req))\n\t\tbargs->state |= BTRFS_BALANCE_STATE_CANCEL_REQ;\n\n\tmemcpy(&bargs->data, &bctl->data, sizeof(bargs->data));\n\tmemcpy(&bargs->meta, &bctl->meta, sizeof(bargs->meta));\n\tmemcpy(&bargs->sys, &bctl->sys, sizeof(bargs->sys));\n\n\tif (lock) {\n\t\tspin_lock(&fs_info->balance_lock);\n\t\tmemcpy(&bargs->stat, &bctl->stat, sizeof(bargs->stat));\n\t\tspin_unlock(&fs_info->balance_lock);\n\t} else {\n\t\tmemcpy(&bargs->stat, &bctl->stat, sizeof(bargs->stat));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*bargs)",
            "GFP_NOFS"
          ],
          "line": 4523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->balance_mutex"
          ],
          "line": 4517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 4514
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_balance_progress(struct btrfs_root *root,\n\t\t\t\t\t void __user *arg)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_ioctl_balance_args *bargs;\n\tint ret = 0;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tmutex_lock(&fs_info->balance_mutex);\n\tif (!fs_info->balance_ctl) {\n\t\tret = -ENOTCONN;\n\t\tgoto out;\n\t}\n\n\tbargs = kzalloc(sizeof(*bargs), GFP_NOFS);\n\tif (!bargs) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tupdate_ioctl_balance_args(fs_info, 1, bargs);\n\n\tif (copy_to_user(arg, bargs, sizeof(*bargs)))\n\t\tret = -EFAULT;\n\n\tkfree(bargs);\nout:\n\tmutex_unlock(&fs_info->balance_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_ioctl_balance_ctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "4492-4505",
    "snippet": "static long btrfs_ioctl_balance_ctl(struct btrfs_root *root, int cmd)\n{\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tswitch (cmd) {\n\tcase BTRFS_BALANCE_CTL_PAUSE:\n\t\treturn btrfs_pause_balance(root->fs_info);\n\tcase BTRFS_BALANCE_CTL_CANCEL:\n\t\treturn btrfs_cancel_balance(root->fs_info);\n\t}\n\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_cancel_balance",
          "args": [
            "root->fs_info"
          ],
          "line": 4501
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_cancel_balance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "3653-3690",
          "snippet": "int btrfs_cancel_balance(struct btrfs_fs_info *fs_info)\n{\n\tif (fs_info->sb->s_flags & MS_RDONLY)\n\t\treturn -EROFS;\n\n\tmutex_lock(&fs_info->balance_mutex);\n\tif (!fs_info->balance_ctl) {\n\t\tmutex_unlock(&fs_info->balance_mutex);\n\t\treturn -ENOTCONN;\n\t}\n\n\tatomic_inc(&fs_info->balance_cancel_req);\n\t/*\n\t * if we are running just wait and return, balance item is\n\t * deleted in btrfs_balance in this case\n\t */\n\tif (atomic_read(&fs_info->balance_running)) {\n\t\tmutex_unlock(&fs_info->balance_mutex);\n\t\twait_event(fs_info->balance_wait_q,\n\t\t\t   atomic_read(&fs_info->balance_running) == 0);\n\t\tmutex_lock(&fs_info->balance_mutex);\n\t} else {\n\t\t/* __cancel_balance needs volume_mutex */\n\t\tmutex_unlock(&fs_info->balance_mutex);\n\t\tmutex_lock(&fs_info->volume_mutex);\n\t\tmutex_lock(&fs_info->balance_mutex);\n\n\t\tif (fs_info->balance_ctl)\n\t\t\t__cancel_balance(fs_info);\n\n\t\tmutex_unlock(&fs_info->volume_mutex);\n\t}\n\n\tBUG_ON(fs_info->balance_ctl || atomic_read(&fs_info->balance_running));\n\tatomic_dec(&fs_info->balance_cancel_req);\n\tmutex_unlock(&fs_info->balance_mutex);\n\treturn 0;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_cancel_balance(struct btrfs_fs_info *fs_info)\n{\n\tif (fs_info->sb->s_flags & MS_RDONLY)\n\t\treturn -EROFS;\n\n\tmutex_lock(&fs_info->balance_mutex);\n\tif (!fs_info->balance_ctl) {\n\t\tmutex_unlock(&fs_info->balance_mutex);\n\t\treturn -ENOTCONN;\n\t}\n\n\tatomic_inc(&fs_info->balance_cancel_req);\n\t/*\n\t * if we are running just wait and return, balance item is\n\t * deleted in btrfs_balance in this case\n\t */\n\tif (atomic_read(&fs_info->balance_running)) {\n\t\tmutex_unlock(&fs_info->balance_mutex);\n\t\twait_event(fs_info->balance_wait_q,\n\t\t\t   atomic_read(&fs_info->balance_running) == 0);\n\t\tmutex_lock(&fs_info->balance_mutex);\n\t} else {\n\t\t/* __cancel_balance needs volume_mutex */\n\t\tmutex_unlock(&fs_info->balance_mutex);\n\t\tmutex_lock(&fs_info->volume_mutex);\n\t\tmutex_lock(&fs_info->balance_mutex);\n\n\t\tif (fs_info->balance_ctl)\n\t\t\t__cancel_balance(fs_info);\n\n\t\tmutex_unlock(&fs_info->volume_mutex);\n\t}\n\n\tBUG_ON(fs_info->balance_ctl || atomic_read(&fs_info->balance_running));\n\tatomic_dec(&fs_info->balance_cancel_req);\n\tmutex_unlock(&fs_info->balance_mutex);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_pause_balance",
          "args": [
            "root->fs_info"
          ],
          "line": 4499
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_pause_balance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "3624-3651",
          "snippet": "int btrfs_pause_balance(struct btrfs_fs_info *fs_info)\n{\n\tint ret = 0;\n\n\tmutex_lock(&fs_info->balance_mutex);\n\tif (!fs_info->balance_ctl) {\n\t\tmutex_unlock(&fs_info->balance_mutex);\n\t\treturn -ENOTCONN;\n\t}\n\n\tif (atomic_read(&fs_info->balance_running)) {\n\t\tatomic_inc(&fs_info->balance_pause_req);\n\t\tmutex_unlock(&fs_info->balance_mutex);\n\n\t\twait_event(fs_info->balance_wait_q,\n\t\t\t   atomic_read(&fs_info->balance_running) == 0);\n\n\t\tmutex_lock(&fs_info->balance_mutex);\n\t\t/* we are good with balance_ctl ripped off from under us */\n\t\tBUG_ON(atomic_read(&fs_info->balance_running));\n\t\tatomic_dec(&fs_info->balance_pause_req);\n\t} else {\n\t\tret = -ENOTCONN;\n\t}\n\n\tmutex_unlock(&fs_info->balance_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_pause_balance(struct btrfs_fs_info *fs_info)\n{\n\tint ret = 0;\n\n\tmutex_lock(&fs_info->balance_mutex);\n\tif (!fs_info->balance_ctl) {\n\t\tmutex_unlock(&fs_info->balance_mutex);\n\t\treturn -ENOTCONN;\n\t}\n\n\tif (atomic_read(&fs_info->balance_running)) {\n\t\tatomic_inc(&fs_info->balance_pause_req);\n\t\tmutex_unlock(&fs_info->balance_mutex);\n\n\t\twait_event(fs_info->balance_wait_q,\n\t\t\t   atomic_read(&fs_info->balance_running) == 0);\n\n\t\tmutex_lock(&fs_info->balance_mutex);\n\t\t/* we are good with balance_ctl ripped off from under us */\n\t\tBUG_ON(atomic_read(&fs_info->balance_running));\n\t\tatomic_dec(&fs_info->balance_pause_req);\n\t} else {\n\t\tret = -ENOTCONN;\n\t}\n\n\tmutex_unlock(&fs_info->balance_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 4494
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_balance_ctl(struct btrfs_root *root, int cmd)\n{\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tswitch (cmd) {\n\tcase BTRFS_BALANCE_CTL_PAUSE:\n\t\treturn btrfs_pause_balance(root->fs_info);\n\tcase BTRFS_BALANCE_CTL_CANCEL:\n\t\treturn btrfs_cancel_balance(root->fs_info);\n\t}\n\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "btrfs_ioctl_balance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "4351-4490",
    "snippet": "static long btrfs_ioctl_balance(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_ioctl_balance_args *bargs;\n\tstruct btrfs_balance_control *bctl;\n\tbool need_unlock; /* for mut. excl. ops lock */\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\nagain:\n\tif (!atomic_xchg(&fs_info->mutually_exclusive_operation_running, 1)) {\n\t\tmutex_lock(&fs_info->volume_mutex);\n\t\tmutex_lock(&fs_info->balance_mutex);\n\t\tneed_unlock = true;\n\t\tgoto locked;\n\t}\n\n\t/*\n\t * mut. excl. ops lock is locked.  Three possibilites:\n\t *   (1) some other op is running\n\t *   (2) balance is running\n\t *   (3) balance is paused -- special case (think resume)\n\t */\n\tmutex_lock(&fs_info->balance_mutex);\n\tif (fs_info->balance_ctl) {\n\t\t/* this is either (2) or (3) */\n\t\tif (!atomic_read(&fs_info->balance_running)) {\n\t\t\tmutex_unlock(&fs_info->balance_mutex);\n\t\t\tif (!mutex_trylock(&fs_info->volume_mutex))\n\t\t\t\tgoto again;\n\t\t\tmutex_lock(&fs_info->balance_mutex);\n\n\t\t\tif (fs_info->balance_ctl &&\n\t\t\t    !atomic_read(&fs_info->balance_running)) {\n\t\t\t\t/* this is (3) */\n\t\t\t\tneed_unlock = false;\n\t\t\t\tgoto locked;\n\t\t\t}\n\n\t\t\tmutex_unlock(&fs_info->balance_mutex);\n\t\t\tmutex_unlock(&fs_info->volume_mutex);\n\t\t\tgoto again;\n\t\t} else {\n\t\t\t/* this is (2) */\n\t\t\tmutex_unlock(&fs_info->balance_mutex);\n\t\t\tret = -EINPROGRESS;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/* this is (1) */\n\t\tmutex_unlock(&fs_info->balance_mutex);\n\t\tret = BTRFS_ERROR_DEV_EXCL_RUN_IN_PROGRESS;\n\t\tgoto out;\n\t}\n\nlocked:\n\tBUG_ON(!atomic_read(&fs_info->mutually_exclusive_operation_running));\n\n\tif (arg) {\n\t\tbargs = memdup_user(arg, sizeof(*bargs));\n\t\tif (IS_ERR(bargs)) {\n\t\t\tret = PTR_ERR(bargs);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (bargs->flags & BTRFS_BALANCE_RESUME) {\n\t\t\tif (!fs_info->balance_ctl) {\n\t\t\t\tret = -ENOTCONN;\n\t\t\t\tgoto out_bargs;\n\t\t\t}\n\n\t\t\tbctl = fs_info->balance_ctl;\n\t\t\tspin_lock(&fs_info->balance_lock);\n\t\t\tbctl->flags |= BTRFS_BALANCE_RESUME;\n\t\t\tspin_unlock(&fs_info->balance_lock);\n\n\t\t\tgoto do_balance;\n\t\t}\n\t} else {\n\t\tbargs = NULL;\n\t}\n\n\tif (fs_info->balance_ctl) {\n\t\tret = -EINPROGRESS;\n\t\tgoto out_bargs;\n\t}\n\n\tbctl = kzalloc(sizeof(*bctl), GFP_NOFS);\n\tif (!bctl) {\n\t\tret = -ENOMEM;\n\t\tgoto out_bargs;\n\t}\n\n\tbctl->fs_info = fs_info;\n\tif (arg) {\n\t\tmemcpy(&bctl->data, &bargs->data, sizeof(bctl->data));\n\t\tmemcpy(&bctl->meta, &bargs->meta, sizeof(bctl->meta));\n\t\tmemcpy(&bctl->sys, &bargs->sys, sizeof(bctl->sys));\n\n\t\tbctl->flags = bargs->flags;\n\t} else {\n\t\t/* balance everything - no filters */\n\t\tbctl->flags |= BTRFS_BALANCE_TYPE_MASK;\n\t}\n\ndo_balance:\n\t/*\n\t * Ownership of bctl and mutually_exclusive_operation_running\n\t * goes to to btrfs_balance.  bctl is freed in __cancel_balance,\n\t * or, if restriper was paused all the way until unmount, in\n\t * free_fs_info.  mutually_exclusive_operation_running is\n\t * cleared in __cancel_balance.\n\t */\n\tneed_unlock = false;\n\n\tret = btrfs_balance(bctl, bargs);\n\n\tif (arg) {\n\t\tif (copy_to_user(arg, bargs, sizeof(*bargs)))\n\t\t\tret = -EFAULT;\n\t}\n\nout_bargs:\n\tkfree(bargs);\nout_unlock:\n\tmutex_unlock(&fs_info->balance_mutex);\n\tmutex_unlock(&fs_info->volume_mutex);\n\tif (need_unlock)\n\t\tatomic_set(&fs_info->mutually_exclusive_operation_running, 0);\nout:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "file"
          ],
          "line": 4488
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&fs_info->mutually_exclusive_operation_running",
            "0"
          ],
          "line": 4486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->volume_mutex"
          ],
          "line": 4484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->balance_mutex"
          ],
          "line": 4483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bargs"
          ],
          "line": 4481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "arg",
            "bargs",
            "sizeof(*bargs)"
          ],
          "line": 4476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_balance",
          "args": [
            "bctl",
            "bargs"
          ],
          "line": 4473
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_balance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "3340-3523",
          "snippet": "int btrfs_balance(struct btrfs_balance_control *bctl,\n\t\t  struct btrfs_ioctl_balance_args *bargs)\n{\n\tstruct btrfs_fs_info *fs_info = bctl->fs_info;\n\tu64 allowed;\n\tint mixed = 0;\n\tint ret;\n\tu64 num_devices;\n\tunsigned seq;\n\n\tif (btrfs_fs_closing(fs_info) ||\n\t    atomic_read(&fs_info->balance_pause_req) ||\n\t    atomic_read(&fs_info->balance_cancel_req)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tallowed = btrfs_super_incompat_flags(fs_info->super_copy);\n\tif (allowed & BTRFS_FEATURE_INCOMPAT_MIXED_GROUPS)\n\t\tmixed = 1;\n\n\t/*\n\t * In case of mixed groups both data and meta should be picked,\n\t * and identical options should be given for both of them.\n\t */\n\tallowed = BTRFS_BALANCE_DATA | BTRFS_BALANCE_METADATA;\n\tif (mixed && (bctl->flags & allowed)) {\n\t\tif (!(bctl->flags & BTRFS_BALANCE_DATA) ||\n\t\t    !(bctl->flags & BTRFS_BALANCE_METADATA) ||\n\t\t    memcmp(&bctl->data, &bctl->meta, sizeof(bctl->data))) {\n\t\t\tbtrfs_err(fs_info, \"with mixed groups data and \"\n\t\t\t\t   \"metadata balance options must be the same\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tnum_devices = fs_info->fs_devices->num_devices;\n\tbtrfs_dev_replace_lock(&fs_info->dev_replace);\n\tif (btrfs_dev_replace_is_ongoing(&fs_info->dev_replace)) {\n\t\tBUG_ON(num_devices < 1);\n\t\tnum_devices--;\n\t}\n\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\tallowed = BTRFS_AVAIL_ALLOC_BIT_SINGLE;\n\tif (num_devices == 1)\n\t\tallowed |= BTRFS_BLOCK_GROUP_DUP;\n\telse if (num_devices > 1)\n\t\tallowed |= (BTRFS_BLOCK_GROUP_RAID0 | BTRFS_BLOCK_GROUP_RAID1);\n\tif (num_devices > 2)\n\t\tallowed |= BTRFS_BLOCK_GROUP_RAID5;\n\tif (num_devices > 3)\n\t\tallowed |= (BTRFS_BLOCK_GROUP_RAID10 |\n\t\t\t    BTRFS_BLOCK_GROUP_RAID6);\n\tif ((bctl->data.flags & BTRFS_BALANCE_ARGS_CONVERT) &&\n\t    (!alloc_profile_is_valid(bctl->data.target, 1) ||\n\t     (bctl->data.target & ~allowed))) {\n\t\tbtrfs_err(fs_info, \"unable to start balance with target \"\n\t\t\t   \"data profile %llu\",\n\t\t       bctl->data.target);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif ((bctl->meta.flags & BTRFS_BALANCE_ARGS_CONVERT) &&\n\t    (!alloc_profile_is_valid(bctl->meta.target, 1) ||\n\t     (bctl->meta.target & ~allowed))) {\n\t\tbtrfs_err(fs_info,\n\t\t\t   \"unable to start balance with target metadata profile %llu\",\n\t\t       bctl->meta.target);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif ((bctl->sys.flags & BTRFS_BALANCE_ARGS_CONVERT) &&\n\t    (!alloc_profile_is_valid(bctl->sys.target, 1) ||\n\t     (bctl->sys.target & ~allowed))) {\n\t\tbtrfs_err(fs_info,\n\t\t\t   \"unable to start balance with target system profile %llu\",\n\t\t       bctl->sys.target);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* allow dup'ed data chunks only in mixed mode */\n\tif (!mixed && (bctl->data.flags & BTRFS_BALANCE_ARGS_CONVERT) &&\n\t    (bctl->data.target & BTRFS_BLOCK_GROUP_DUP)) {\n\t\tbtrfs_err(fs_info, \"dup for data is not allowed\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* allow to reduce meta or sys integrity only if force set */\n\tallowed = BTRFS_BLOCK_GROUP_DUP | BTRFS_BLOCK_GROUP_RAID1 |\n\t\t\tBTRFS_BLOCK_GROUP_RAID10 |\n\t\t\tBTRFS_BLOCK_GROUP_RAID5 |\n\t\t\tBTRFS_BLOCK_GROUP_RAID6;\n\tdo {\n\t\tseq = read_seqbegin(&fs_info->profiles_lock);\n\n\t\tif (((bctl->sys.flags & BTRFS_BALANCE_ARGS_CONVERT) &&\n\t\t     (fs_info->avail_system_alloc_bits & allowed) &&\n\t\t     !(bctl->sys.target & allowed)) ||\n\t\t    ((bctl->meta.flags & BTRFS_BALANCE_ARGS_CONVERT) &&\n\t\t     (fs_info->avail_metadata_alloc_bits & allowed) &&\n\t\t     !(bctl->meta.target & allowed))) {\n\t\t\tif (bctl->flags & BTRFS_BALANCE_FORCE) {\n\t\t\t\tbtrfs_info(fs_info, \"force reducing metadata integrity\");\n\t\t\t} else {\n\t\t\t\tbtrfs_err(fs_info, \"balance will reduce metadata \"\n\t\t\t\t\t   \"integrity, use force if you want this\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t} while (read_seqretry(&fs_info->profiles_lock, seq));\n\n\tif (bctl->sys.flags & BTRFS_BALANCE_ARGS_CONVERT) {\n\t\tint num_tolerated_disk_barrier_failures;\n\t\tu64 target = bctl->sys.target;\n\n\t\tnum_tolerated_disk_barrier_failures =\n\t\t\tbtrfs_calc_num_tolerated_disk_barrier_failures(fs_info);\n\t\tif (num_tolerated_disk_barrier_failures > 0 &&\n\t\t    (target &\n\t\t     (BTRFS_BLOCK_GROUP_DUP | BTRFS_BLOCK_GROUP_RAID0 |\n\t\t      BTRFS_AVAIL_ALLOC_BIT_SINGLE)))\n\t\t\tnum_tolerated_disk_barrier_failures = 0;\n\t\telse if (num_tolerated_disk_barrier_failures > 1 &&\n\t\t\t (target &\n\t\t\t  (BTRFS_BLOCK_GROUP_RAID1 | BTRFS_BLOCK_GROUP_RAID10)))\n\t\t\tnum_tolerated_disk_barrier_failures = 1;\n\n\t\tfs_info->num_tolerated_disk_barrier_failures =\n\t\t\tnum_tolerated_disk_barrier_failures;\n\t}\n\n\tret = insert_balance_item(fs_info->tree_root, bctl);\n\tif (ret && ret != -EEXIST)\n\t\tgoto out;\n\n\tif (!(bctl->flags & BTRFS_BALANCE_RESUME)) {\n\t\tBUG_ON(ret == -EEXIST);\n\t\tset_balance_control(bctl);\n\t} else {\n\t\tBUG_ON(ret != -EEXIST);\n\t\tspin_lock(&fs_info->balance_lock);\n\t\tupdate_balance_args(bctl);\n\t\tspin_unlock(&fs_info->balance_lock);\n\t}\n\n\tatomic_inc(&fs_info->balance_running);\n\tmutex_unlock(&fs_info->balance_mutex);\n\n\tret = __btrfs_balance(fs_info);\n\n\tmutex_lock(&fs_info->balance_mutex);\n\tatomic_dec(&fs_info->balance_running);\n\n\tif (bctl->sys.flags & BTRFS_BALANCE_ARGS_CONVERT) {\n\t\tfs_info->num_tolerated_disk_barrier_failures =\n\t\t\tbtrfs_calc_num_tolerated_disk_barrier_failures(fs_info);\n\t}\n\n\tif (bargs) {\n\t\tmemset(bargs, 0, sizeof(*bargs));\n\t\tupdate_ioctl_balance_args(fs_info, 0, bargs);\n\t}\n\n\tif ((ret && ret != -ECANCELED && ret != -ENOSPC) ||\n\t    balance_need_close(fs_info)) {\n\t\t__cancel_balance(fs_info);\n\t}\n\n\twake_up(&fs_info->balance_wait_q);\n\n\treturn ret;\nout:\n\tif (bctl->flags & BTRFS_BALANCE_RESUME)\n\t\t__cancel_balance(fs_info);\n\telse {\n\t\tkfree(bctl);\n\t\tatomic_set(&fs_info->mutually_exclusive_operation_running, 0);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_balance(struct btrfs_balance_control *bctl,\n\t\t  struct btrfs_ioctl_balance_args *bargs)\n{\n\tstruct btrfs_fs_info *fs_info = bctl->fs_info;\n\tu64 allowed;\n\tint mixed = 0;\n\tint ret;\n\tu64 num_devices;\n\tunsigned seq;\n\n\tif (btrfs_fs_closing(fs_info) ||\n\t    atomic_read(&fs_info->balance_pause_req) ||\n\t    atomic_read(&fs_info->balance_cancel_req)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tallowed = btrfs_super_incompat_flags(fs_info->super_copy);\n\tif (allowed & BTRFS_FEATURE_INCOMPAT_MIXED_GROUPS)\n\t\tmixed = 1;\n\n\t/*\n\t * In case of mixed groups both data and meta should be picked,\n\t * and identical options should be given for both of them.\n\t */\n\tallowed = BTRFS_BALANCE_DATA | BTRFS_BALANCE_METADATA;\n\tif (mixed && (bctl->flags & allowed)) {\n\t\tif (!(bctl->flags & BTRFS_BALANCE_DATA) ||\n\t\t    !(bctl->flags & BTRFS_BALANCE_METADATA) ||\n\t\t    memcmp(&bctl->data, &bctl->meta, sizeof(bctl->data))) {\n\t\t\tbtrfs_err(fs_info, \"with mixed groups data and \"\n\t\t\t\t   \"metadata balance options must be the same\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tnum_devices = fs_info->fs_devices->num_devices;\n\tbtrfs_dev_replace_lock(&fs_info->dev_replace);\n\tif (btrfs_dev_replace_is_ongoing(&fs_info->dev_replace)) {\n\t\tBUG_ON(num_devices < 1);\n\t\tnum_devices--;\n\t}\n\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\tallowed = BTRFS_AVAIL_ALLOC_BIT_SINGLE;\n\tif (num_devices == 1)\n\t\tallowed |= BTRFS_BLOCK_GROUP_DUP;\n\telse if (num_devices > 1)\n\t\tallowed |= (BTRFS_BLOCK_GROUP_RAID0 | BTRFS_BLOCK_GROUP_RAID1);\n\tif (num_devices > 2)\n\t\tallowed |= BTRFS_BLOCK_GROUP_RAID5;\n\tif (num_devices > 3)\n\t\tallowed |= (BTRFS_BLOCK_GROUP_RAID10 |\n\t\t\t    BTRFS_BLOCK_GROUP_RAID6);\n\tif ((bctl->data.flags & BTRFS_BALANCE_ARGS_CONVERT) &&\n\t    (!alloc_profile_is_valid(bctl->data.target, 1) ||\n\t     (bctl->data.target & ~allowed))) {\n\t\tbtrfs_err(fs_info, \"unable to start balance with target \"\n\t\t\t   \"data profile %llu\",\n\t\t       bctl->data.target);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif ((bctl->meta.flags & BTRFS_BALANCE_ARGS_CONVERT) &&\n\t    (!alloc_profile_is_valid(bctl->meta.target, 1) ||\n\t     (bctl->meta.target & ~allowed))) {\n\t\tbtrfs_err(fs_info,\n\t\t\t   \"unable to start balance with target metadata profile %llu\",\n\t\t       bctl->meta.target);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif ((bctl->sys.flags & BTRFS_BALANCE_ARGS_CONVERT) &&\n\t    (!alloc_profile_is_valid(bctl->sys.target, 1) ||\n\t     (bctl->sys.target & ~allowed))) {\n\t\tbtrfs_err(fs_info,\n\t\t\t   \"unable to start balance with target system profile %llu\",\n\t\t       bctl->sys.target);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* allow dup'ed data chunks only in mixed mode */\n\tif (!mixed && (bctl->data.flags & BTRFS_BALANCE_ARGS_CONVERT) &&\n\t    (bctl->data.target & BTRFS_BLOCK_GROUP_DUP)) {\n\t\tbtrfs_err(fs_info, \"dup for data is not allowed\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* allow to reduce meta or sys integrity only if force set */\n\tallowed = BTRFS_BLOCK_GROUP_DUP | BTRFS_BLOCK_GROUP_RAID1 |\n\t\t\tBTRFS_BLOCK_GROUP_RAID10 |\n\t\t\tBTRFS_BLOCK_GROUP_RAID5 |\n\t\t\tBTRFS_BLOCK_GROUP_RAID6;\n\tdo {\n\t\tseq = read_seqbegin(&fs_info->profiles_lock);\n\n\t\tif (((bctl->sys.flags & BTRFS_BALANCE_ARGS_CONVERT) &&\n\t\t     (fs_info->avail_system_alloc_bits & allowed) &&\n\t\t     !(bctl->sys.target & allowed)) ||\n\t\t    ((bctl->meta.flags & BTRFS_BALANCE_ARGS_CONVERT) &&\n\t\t     (fs_info->avail_metadata_alloc_bits & allowed) &&\n\t\t     !(bctl->meta.target & allowed))) {\n\t\t\tif (bctl->flags & BTRFS_BALANCE_FORCE) {\n\t\t\t\tbtrfs_info(fs_info, \"force reducing metadata integrity\");\n\t\t\t} else {\n\t\t\t\tbtrfs_err(fs_info, \"balance will reduce metadata \"\n\t\t\t\t\t   \"integrity, use force if you want this\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t} while (read_seqretry(&fs_info->profiles_lock, seq));\n\n\tif (bctl->sys.flags & BTRFS_BALANCE_ARGS_CONVERT) {\n\t\tint num_tolerated_disk_barrier_failures;\n\t\tu64 target = bctl->sys.target;\n\n\t\tnum_tolerated_disk_barrier_failures =\n\t\t\tbtrfs_calc_num_tolerated_disk_barrier_failures(fs_info);\n\t\tif (num_tolerated_disk_barrier_failures > 0 &&\n\t\t    (target &\n\t\t     (BTRFS_BLOCK_GROUP_DUP | BTRFS_BLOCK_GROUP_RAID0 |\n\t\t      BTRFS_AVAIL_ALLOC_BIT_SINGLE)))\n\t\t\tnum_tolerated_disk_barrier_failures = 0;\n\t\telse if (num_tolerated_disk_barrier_failures > 1 &&\n\t\t\t (target &\n\t\t\t  (BTRFS_BLOCK_GROUP_RAID1 | BTRFS_BLOCK_GROUP_RAID10)))\n\t\t\tnum_tolerated_disk_barrier_failures = 1;\n\n\t\tfs_info->num_tolerated_disk_barrier_failures =\n\t\t\tnum_tolerated_disk_barrier_failures;\n\t}\n\n\tret = insert_balance_item(fs_info->tree_root, bctl);\n\tif (ret && ret != -EEXIST)\n\t\tgoto out;\n\n\tif (!(bctl->flags & BTRFS_BALANCE_RESUME)) {\n\t\tBUG_ON(ret == -EEXIST);\n\t\tset_balance_control(bctl);\n\t} else {\n\t\tBUG_ON(ret != -EEXIST);\n\t\tspin_lock(&fs_info->balance_lock);\n\t\tupdate_balance_args(bctl);\n\t\tspin_unlock(&fs_info->balance_lock);\n\t}\n\n\tatomic_inc(&fs_info->balance_running);\n\tmutex_unlock(&fs_info->balance_mutex);\n\n\tret = __btrfs_balance(fs_info);\n\n\tmutex_lock(&fs_info->balance_mutex);\n\tatomic_dec(&fs_info->balance_running);\n\n\tif (bctl->sys.flags & BTRFS_BALANCE_ARGS_CONVERT) {\n\t\tfs_info->num_tolerated_disk_barrier_failures =\n\t\t\tbtrfs_calc_num_tolerated_disk_barrier_failures(fs_info);\n\t}\n\n\tif (bargs) {\n\t\tmemset(bargs, 0, sizeof(*bargs));\n\t\tupdate_ioctl_balance_args(fs_info, 0, bargs);\n\t}\n\n\tif ((ret && ret != -ECANCELED && ret != -ENOSPC) ||\n\t    balance_need_close(fs_info)) {\n\t\t__cancel_balance(fs_info);\n\t}\n\n\twake_up(&fs_info->balance_wait_q);\n\n\treturn ret;\nout:\n\tif (bctl->flags & BTRFS_BALANCE_RESUME)\n\t\t__cancel_balance(fs_info);\n\telse {\n\t\tkfree(bctl);\n\t\tatomic_set(&fs_info->mutually_exclusive_operation_running, 0);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&bctl->sys",
            "&bargs->sys",
            "sizeof(bctl->sys)"
          ],
          "line": 4455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&bctl->meta",
            "&bargs->meta",
            "sizeof(bctl->meta)"
          ],
          "line": 4454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&bctl->data",
            "&bargs->data",
            "sizeof(bctl->data)"
          ],
          "line": 4453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*bctl)",
            "GFP_NOFS"
          ],
          "line": 4445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->balance_lock"
          ],
          "line": 4432
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->balance_lock"
          ],
          "line": 4430
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bargs"
          ],
          "line": 4419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bargs"
          ],
          "line": 4418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user",
          "args": [
            "arg",
            "sizeof(*bargs)"
          ],
          "line": 4417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!atomic_read(&fs_info->mutually_exclusive_operation_running)"
          ],
          "line": 4414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&fs_info->mutually_exclusive_operation_running"
          ],
          "line": 4414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->balance_mutex"
          ],
          "line": 4408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->balance_mutex"
          ],
          "line": 4402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->volume_mutex"
          ],
          "line": 4398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->balance_mutex"
          ],
          "line": 4397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&fs_info->balance_running"
          ],
          "line": 4391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->balance_mutex"
          ],
          "line": 4388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_trylock",
          "args": [
            "&fs_info->volume_mutex"
          ],
          "line": 4386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->balance_mutex"
          ],
          "line": 4385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&fs_info->balance_running"
          ],
          "line": 4384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->balance_mutex"
          ],
          "line": 4381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->balance_mutex"
          ],
          "line": 4370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->volume_mutex"
          ],
          "line": 4369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_xchg",
          "args": [
            "&fs_info->mutually_exclusive_operation_running",
            "1"
          ],
          "line": 4368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "file"
          ],
          "line": 4363
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 4360
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "file_inode(file)"
          ],
          "line": 4353
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 4353
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_balance(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_ioctl_balance_args *bargs;\n\tstruct btrfs_balance_control *bctl;\n\tbool need_unlock; /* for mut. excl. ops lock */\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\nagain:\n\tif (!atomic_xchg(&fs_info->mutually_exclusive_operation_running, 1)) {\n\t\tmutex_lock(&fs_info->volume_mutex);\n\t\tmutex_lock(&fs_info->balance_mutex);\n\t\tneed_unlock = true;\n\t\tgoto locked;\n\t}\n\n\t/*\n\t * mut. excl. ops lock is locked.  Three possibilites:\n\t *   (1) some other op is running\n\t *   (2) balance is running\n\t *   (3) balance is paused -- special case (think resume)\n\t */\n\tmutex_lock(&fs_info->balance_mutex);\n\tif (fs_info->balance_ctl) {\n\t\t/* this is either (2) or (3) */\n\t\tif (!atomic_read(&fs_info->balance_running)) {\n\t\t\tmutex_unlock(&fs_info->balance_mutex);\n\t\t\tif (!mutex_trylock(&fs_info->volume_mutex))\n\t\t\t\tgoto again;\n\t\t\tmutex_lock(&fs_info->balance_mutex);\n\n\t\t\tif (fs_info->balance_ctl &&\n\t\t\t    !atomic_read(&fs_info->balance_running)) {\n\t\t\t\t/* this is (3) */\n\t\t\t\tneed_unlock = false;\n\t\t\t\tgoto locked;\n\t\t\t}\n\n\t\t\tmutex_unlock(&fs_info->balance_mutex);\n\t\t\tmutex_unlock(&fs_info->volume_mutex);\n\t\t\tgoto again;\n\t\t} else {\n\t\t\t/* this is (2) */\n\t\t\tmutex_unlock(&fs_info->balance_mutex);\n\t\t\tret = -EINPROGRESS;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/* this is (1) */\n\t\tmutex_unlock(&fs_info->balance_mutex);\n\t\tret = BTRFS_ERROR_DEV_EXCL_RUN_IN_PROGRESS;\n\t\tgoto out;\n\t}\n\nlocked:\n\tBUG_ON(!atomic_read(&fs_info->mutually_exclusive_operation_running));\n\n\tif (arg) {\n\t\tbargs = memdup_user(arg, sizeof(*bargs));\n\t\tif (IS_ERR(bargs)) {\n\t\t\tret = PTR_ERR(bargs);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (bargs->flags & BTRFS_BALANCE_RESUME) {\n\t\t\tif (!fs_info->balance_ctl) {\n\t\t\t\tret = -ENOTCONN;\n\t\t\t\tgoto out_bargs;\n\t\t\t}\n\n\t\t\tbctl = fs_info->balance_ctl;\n\t\t\tspin_lock(&fs_info->balance_lock);\n\t\t\tbctl->flags |= BTRFS_BALANCE_RESUME;\n\t\t\tspin_unlock(&fs_info->balance_lock);\n\n\t\t\tgoto do_balance;\n\t\t}\n\t} else {\n\t\tbargs = NULL;\n\t}\n\n\tif (fs_info->balance_ctl) {\n\t\tret = -EINPROGRESS;\n\t\tgoto out_bargs;\n\t}\n\n\tbctl = kzalloc(sizeof(*bctl), GFP_NOFS);\n\tif (!bctl) {\n\t\tret = -ENOMEM;\n\t\tgoto out_bargs;\n\t}\n\n\tbctl->fs_info = fs_info;\n\tif (arg) {\n\t\tmemcpy(&bctl->data, &bargs->data, sizeof(bctl->data));\n\t\tmemcpy(&bctl->meta, &bargs->meta, sizeof(bctl->meta));\n\t\tmemcpy(&bctl->sys, &bargs->sys, sizeof(bctl->sys));\n\n\t\tbctl->flags = bargs->flags;\n\t} else {\n\t\t/* balance everything - no filters */\n\t\tbctl->flags |= BTRFS_BALANCE_TYPE_MASK;\n\t}\n\ndo_balance:\n\t/*\n\t * Ownership of bctl and mutually_exclusive_operation_running\n\t * goes to to btrfs_balance.  bctl is freed in __cancel_balance,\n\t * or, if restriper was paused all the way until unmount, in\n\t * free_fs_info.  mutually_exclusive_operation_running is\n\t * cleared in __cancel_balance.\n\t */\n\tneed_unlock = false;\n\n\tret = btrfs_balance(bctl, bargs);\n\n\tif (arg) {\n\t\tif (copy_to_user(arg, bargs, sizeof(*bargs)))\n\t\t\tret = -EFAULT;\n\t}\n\nout_bargs:\n\tkfree(bargs);\nout_unlock:\n\tmutex_unlock(&fs_info->balance_mutex);\n\tmutex_unlock(&fs_info->volume_mutex);\n\tif (need_unlock)\n\t\tatomic_set(&fs_info->mutually_exclusive_operation_running, 0);\nout:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}"
  },
  {
    "function_name": "update_ioctl_balance_args",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "4324-4349",
    "snippet": "void update_ioctl_balance_args(struct btrfs_fs_info *fs_info, int lock,\n\t\t\t       struct btrfs_ioctl_balance_args *bargs)\n{\n\tstruct btrfs_balance_control *bctl = fs_info->balance_ctl;\n\n\tbargs->flags = bctl->flags;\n\n\tif (atomic_read(&fs_info->balance_running))\n\t\tbargs->state |= BTRFS_BALANCE_STATE_RUNNING;\n\tif (atomic_read(&fs_info->balance_pause_req))\n\t\tbargs->state |= BTRFS_BALANCE_STATE_PAUSE_REQ;\n\tif (atomic_read(&fs_info->balance_cancel_req))\n\t\tbargs->state |= BTRFS_BALANCE_STATE_CANCEL_REQ;\n\n\tmemcpy(&bargs->data, &bctl->data, sizeof(bargs->data));\n\tmemcpy(&bargs->meta, &bctl->meta, sizeof(bargs->meta));\n\tmemcpy(&bargs->sys, &bctl->sys, sizeof(bargs->sys));\n\n\tif (lock) {\n\t\tspin_lock(&fs_info->balance_lock);\n\t\tmemcpy(&bargs->stat, &bctl->stat, sizeof(bargs->stat));\n\t\tspin_unlock(&fs_info->balance_lock);\n\t} else {\n\t\tmemcpy(&bargs->stat, &bctl->stat, sizeof(bargs->stat));\n\t}\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&bargs->stat",
            "&bctl->stat",
            "sizeof(bargs->stat)"
          ],
          "line": 4347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->balance_lock"
          ],
          "line": 4345
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&bargs->stat",
            "&bctl->stat",
            "sizeof(bargs->stat)"
          ],
          "line": 4344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->balance_lock"
          ],
          "line": 4343
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&bargs->sys",
            "&bctl->sys",
            "sizeof(bargs->sys)"
          ],
          "line": 4340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&bargs->meta",
            "&bctl->meta",
            "sizeof(bargs->meta)"
          ],
          "line": 4339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&bargs->data",
            "&bctl->data",
            "sizeof(bargs->data)"
          ],
          "line": 4338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&fs_info->balance_cancel_req"
          ],
          "line": 4335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&fs_info->balance_pause_req"
          ],
          "line": 4333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&fs_info->balance_running"
          ],
          "line": 4331
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nvoid update_ioctl_balance_args(struct btrfs_fs_info *fs_info, int lock,\n\t\t\t       struct btrfs_ioctl_balance_args *bargs)\n{\n\tstruct btrfs_balance_control *bctl = fs_info->balance_ctl;\n\n\tbargs->flags = bctl->flags;\n\n\tif (atomic_read(&fs_info->balance_running))\n\t\tbargs->state |= BTRFS_BALANCE_STATE_RUNNING;\n\tif (atomic_read(&fs_info->balance_pause_req))\n\t\tbargs->state |= BTRFS_BALANCE_STATE_PAUSE_REQ;\n\tif (atomic_read(&fs_info->balance_cancel_req))\n\t\tbargs->state |= BTRFS_BALANCE_STATE_CANCEL_REQ;\n\n\tmemcpy(&bargs->data, &bctl->data, sizeof(bargs->data));\n\tmemcpy(&bargs->meta, &bctl->meta, sizeof(bargs->meta));\n\tmemcpy(&bargs->sys, &bctl->sys, sizeof(bargs->sys));\n\n\tif (lock) {\n\t\tspin_lock(&fs_info->balance_lock);\n\t\tmemcpy(&bargs->stat, &bctl->stat, sizeof(bargs->stat));\n\t\tspin_unlock(&fs_info->balance_lock);\n\t} else {\n\t\tmemcpy(&bargs->stat, &bctl->stat, sizeof(bargs->stat));\n\t}\n}"
  },
  {
    "function_name": "btrfs_ioctl_logical_to_ino",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "4271-4322",
    "snippet": "static long btrfs_ioctl_logical_to_ino(struct btrfs_root *root,\n\t\t\t\t\tvoid __user *arg)\n{\n\tint ret = 0;\n\tint size;\n\tstruct btrfs_ioctl_logical_ino_args *loi;\n\tstruct btrfs_data_container *inodes = NULL;\n\tstruct btrfs_path *path = NULL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tloi = memdup_user(arg, sizeof(*loi));\n\tif (IS_ERR(loi)) {\n\t\tret = PTR_ERR(loi);\n\t\tloi = NULL;\n\t\tgoto out;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsize = min_t(u32, loi->size, 64 * 1024);\n\tinodes = init_data_container(size);\n\tif (IS_ERR(inodes)) {\n\t\tret = PTR_ERR(inodes);\n\t\tinodes = NULL;\n\t\tgoto out;\n\t}\n\n\tret = iterate_inodes_from_logical(loi->logical, root->fs_info, path,\n\t\t\t\t\t  build_ino_list, inodes);\n\tif (ret == -EINVAL)\n\t\tret = -ENOENT;\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = copy_to_user((void *)(unsigned long)loi->inodes,\n\t\t\t   (void *)(unsigned long)inodes, size);\n\tif (ret)\n\t\tret = -EFAULT;\n\nout:\n\tbtrfs_free_path(path);\n\tvfree(inodes);\n\tkfree(loi);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "loi"
          ],
          "line": 4319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "inodes"
          ],
          "line": 4318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 4317
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "(void *)(unsigned long)loi->inodes",
            "(void *)(unsigned long)inodes",
            "size"
          ],
          "line": 4311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iterate_inodes_from_logical",
          "args": [
            "loi->logical",
            "root->fs_info",
            "path",
            "build_ino_list",
            "inodes"
          ],
          "line": 4304
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_inodes_from_logical",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "1667-1690",
          "snippet": "int iterate_inodes_from_logical(u64 logical, struct btrfs_fs_info *fs_info,\n\t\t\t\tstruct btrfs_path *path,\n\t\t\t\titerate_extent_inodes_t *iterate, void *ctx)\n{\n\tint ret;\n\tu64 extent_item_pos;\n\tu64 flags = 0;\n\tstruct btrfs_key found_key;\n\tint search_commit_root = path->search_commit_root;\n\n\tret = extent_from_logical(fs_info, logical, path, &found_key, &flags);\n\tbtrfs_release_path(path);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK)\n\t\treturn -EINVAL;\n\n\textent_item_pos = logical - found_key.objectid;\n\tret = iterate_extent_inodes(fs_info, found_key.objectid,\n\t\t\t\t\textent_item_pos, search_commit_root,\n\t\t\t\t\titerate, ctx);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nint iterate_inodes_from_logical(u64 logical, struct btrfs_fs_info *fs_info,\n\t\t\t\tstruct btrfs_path *path,\n\t\t\t\titerate_extent_inodes_t *iterate, void *ctx)\n{\n\tint ret;\n\tu64 extent_item_pos;\n\tu64 flags = 0;\n\tstruct btrfs_key found_key;\n\tint search_commit_root = path->search_commit_root;\n\n\tret = extent_from_logical(fs_info, logical, path, &found_key, &flags);\n\tbtrfs_release_path(path);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK)\n\t\treturn -EINVAL;\n\n\textent_item_pos = logical - found_key.objectid;\n\tret = iterate_extent_inodes(fs_info, found_key.objectid,\n\t\t\t\t\textent_item_pos, search_commit_root,\n\t\t\t\t\titerate, ctx);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inodes"
          ],
          "line": 4299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inodes"
          ],
          "line": 4298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_data_container",
          "args": [
            "size"
          ],
          "line": 4297
        },
        "resolved": true,
        "details": {
          "function_name": "init_data_container",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "1902-1924",
          "snippet": "struct btrfs_data_container *init_data_container(u32 total_bytes)\n{\n\tstruct btrfs_data_container *data;\n\tsize_t alloc_bytes;\n\n\talloc_bytes = max_t(size_t, total_bytes, sizeof(*data));\n\tdata = vmalloc(alloc_bytes);\n\tif (!data)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (total_bytes >= sizeof(*data)) {\n\t\tdata->bytes_left = total_bytes - sizeof(*data);\n\t\tdata->bytes_missing = 0;\n\t} else {\n\t\tdata->bytes_missing = sizeof(*data) - total_bytes;\n\t\tdata->bytes_left = 0;\n\t}\n\n\tdata->elem_cnt = 0;\n\tdata->elem_missed = 0;\n\n\treturn data;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nstruct btrfs_data_container *init_data_container(u32 total_bytes)\n{\n\tstruct btrfs_data_container *data;\n\tsize_t alloc_bytes;\n\n\talloc_bytes = max_t(size_t, total_bytes, sizeof(*data));\n\tdata = vmalloc(alloc_bytes);\n\tif (!data)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (total_bytes >= sizeof(*data)) {\n\t\tdata->bytes_left = total_bytes - sizeof(*data);\n\t\tdata->bytes_missing = 0;\n\t} else {\n\t\tdata->bytes_missing = sizeof(*data) - total_bytes;\n\t\tdata->bytes_left = 0;\n\t}\n\n\tdata->elem_cnt = 0;\n\tdata->elem_missed = 0;\n\n\treturn data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "loi->size",
            "64 * 1024"
          ],
          "line": 4296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 4290
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "loi"
          ],
          "line": 4285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "loi"
          ],
          "line": 4284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user",
          "args": [
            "arg",
            "sizeof(*loi)"
          ],
          "line": 4283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 4280
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_logical_to_ino(struct btrfs_root *root,\n\t\t\t\t\tvoid __user *arg)\n{\n\tint ret = 0;\n\tint size;\n\tstruct btrfs_ioctl_logical_ino_args *loi;\n\tstruct btrfs_data_container *inodes = NULL;\n\tstruct btrfs_path *path = NULL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tloi = memdup_user(arg, sizeof(*loi));\n\tif (IS_ERR(loi)) {\n\t\tret = PTR_ERR(loi);\n\t\tloi = NULL;\n\t\tgoto out;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsize = min_t(u32, loi->size, 64 * 1024);\n\tinodes = init_data_container(size);\n\tif (IS_ERR(inodes)) {\n\t\tret = PTR_ERR(inodes);\n\t\tinodes = NULL;\n\t\tgoto out;\n\t}\n\n\tret = iterate_inodes_from_logical(loi->logical, root->fs_info, path,\n\t\t\t\t\t  build_ino_list, inodes);\n\tif (ret == -EINVAL)\n\t\tret = -ENOENT;\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = copy_to_user((void *)(unsigned long)loi->inodes,\n\t\t\t   (void *)(unsigned long)inodes, size);\n\tif (ret)\n\t\tret = -EFAULT;\n\nout:\n\tbtrfs_free_path(path);\n\tvfree(inodes);\n\tkfree(loi);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "build_ino_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "4251-4269",
    "snippet": "static int build_ino_list(u64 inum, u64 offset, u64 root, void *ctx)\n{\n\tstruct btrfs_data_container *inodes = ctx;\n\tconst size_t c = 3 * sizeof(u64);\n\n\tif (inodes->bytes_left >= c) {\n\t\tinodes->bytes_left -= c;\n\t\tinodes->val[inodes->elem_cnt] = inum;\n\t\tinodes->val[inodes->elem_cnt + 1] = offset;\n\t\tinodes->val[inodes->elem_cnt + 2] = root;\n\t\tinodes->elem_cnt += 3;\n\t} else {\n\t\tinodes->bytes_missing += c - inodes->bytes_left;\n\t\tinodes->bytes_left = 0;\n\t\tinodes->elem_missed += 3;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int build_ino_list(u64 inum, u64 offset, u64 root, void *ctx)\n{\n\tstruct btrfs_data_container *inodes = ctx;\n\tconst size_t c = 3 * sizeof(u64);\n\n\tif (inodes->bytes_left >= c) {\n\t\tinodes->bytes_left -= c;\n\t\tinodes->val[inodes->elem_cnt] = inum;\n\t\tinodes->val[inodes->elem_cnt + 1] = offset;\n\t\tinodes->val[inodes->elem_cnt + 2] = root;\n\t\tinodes->elem_cnt += 3;\n\t} else {\n\t\tinodes->bytes_missing += c - inodes->bytes_left;\n\t\tinodes->bytes_left = 0;\n\t\tinodes->elem_missed += 3;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_ioctl_ino_to_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "4192-4249",
    "snippet": "static long btrfs_ioctl_ino_to_path(struct btrfs_root *root, void __user *arg)\n{\n\tint ret = 0;\n\tint i;\n\tu64 rel_ptr;\n\tint size;\n\tstruct btrfs_ioctl_ino_path_args *ipa = NULL;\n\tstruct inode_fs_paths *ipath = NULL;\n\tstruct btrfs_path *path;\n\n\tif (!capable(CAP_DAC_READ_SEARCH))\n\t\treturn -EPERM;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tipa = memdup_user(arg, sizeof(*ipa));\n\tif (IS_ERR(ipa)) {\n\t\tret = PTR_ERR(ipa);\n\t\tipa = NULL;\n\t\tgoto out;\n\t}\n\n\tsize = min_t(u32, ipa->size, 4096);\n\tipath = init_ipath(size, root, path);\n\tif (IS_ERR(ipath)) {\n\t\tret = PTR_ERR(ipath);\n\t\tipath = NULL;\n\t\tgoto out;\n\t}\n\n\tret = paths_from_inode(ipa->inum, ipath);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tfor (i = 0; i < ipath->fspath->elem_cnt; ++i) {\n\t\trel_ptr = ipath->fspath->val[i] -\n\t\t\t  (u64)(unsigned long)ipath->fspath->val;\n\t\tipath->fspath->val[i] = rel_ptr;\n\t}\n\n\tret = copy_to_user((void *)(unsigned long)ipa->fspath,\n\t\t\t   (void *)(unsigned long)ipath->fspath, size);\n\tif (ret) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\tfree_ipath(ipath);\n\tkfree(ipa);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ipa"
          ],
          "line": 4246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_ipath",
          "args": [
            "ipath"
          ],
          "line": 4245
        },
        "resolved": true,
        "details": {
          "function_name": "free_ipath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "1955-1961",
          "snippet": "void free_ipath(struct inode_fs_paths *ipath)\n{\n\tif (!ipath)\n\t\treturn;\n\tvfree(ipath->fspath);\n\tkfree(ipath);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nvoid free_ipath(struct inode_fs_paths *ipath)\n{\n\tif (!ipath)\n\t\treturn;\n\tvfree(ipath->fspath);\n\tkfree(ipath);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 4244
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "(void *)(unsigned long)ipa->fspath",
            "(void *)(unsigned long)ipath->fspath",
            "size"
          ],
          "line": 4236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paths_from_inode",
          "args": [
            "ipa->inum",
            "ipath"
          ],
          "line": 4226
        },
        "resolved": true,
        "details": {
          "function_name": "paths_from_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "1896-1900",
          "snippet": "int paths_from_inode(u64 inum, struct inode_fs_paths *ipath)\n{\n\treturn iterate_irefs(inum, ipath->fs_root, ipath->btrfs_path,\n\t\t\t     inode_to_path, ipath);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nint paths_from_inode(u64 inum, struct inode_fs_paths *ipath)\n{\n\treturn iterate_irefs(inum, ipath->fs_root, ipath->btrfs_path,\n\t\t\t     inode_to_path, ipath);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ipath"
          ],
          "line": 4221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ipath"
          ],
          "line": 4220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_ipath",
          "args": [
            "size",
            "root",
            "path"
          ],
          "line": 4219
        },
        "resolved": true,
        "details": {
          "function_name": "init_ipath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "1932-1953",
          "snippet": "struct inode_fs_paths *init_ipath(s32 total_bytes, struct btrfs_root *fs_root,\n\t\t\t\t\tstruct btrfs_path *path)\n{\n\tstruct inode_fs_paths *ifp;\n\tstruct btrfs_data_container *fspath;\n\n\tfspath = init_data_container(total_bytes);\n\tif (IS_ERR(fspath))\n\t\treturn (void *)fspath;\n\n\tifp = kmalloc(sizeof(*ifp), GFP_NOFS);\n\tif (!ifp) {\n\t\tkfree(fspath);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tifp->btrfs_path = path;\n\tifp->fspath = fspath;\n\tifp->fs_root = fs_root;\n\n\treturn ifp;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nstruct inode_fs_paths *init_ipath(s32 total_bytes, struct btrfs_root *fs_root,\n\t\t\t\t\tstruct btrfs_path *path)\n{\n\tstruct inode_fs_paths *ifp;\n\tstruct btrfs_data_container *fspath;\n\n\tfspath = init_data_container(total_bytes);\n\tif (IS_ERR(fspath))\n\t\treturn (void *)fspath;\n\n\tifp = kmalloc(sizeof(*ifp), GFP_NOFS);\n\tif (!ifp) {\n\t\tkfree(fspath);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tifp->btrfs_path = path;\n\tifp->fspath = fspath;\n\tifp->fs_root = fs_root;\n\n\treturn ifp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "ipa->size",
            "4096"
          ],
          "line": 4218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ipa"
          ],
          "line": 4213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ipa"
          ],
          "line": 4212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user",
          "args": [
            "arg",
            "sizeof(*ipa)"
          ],
          "line": 4211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 4205
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_DAC_READ_SEARCH"
          ],
          "line": 4202
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_ino_to_path(struct btrfs_root *root, void __user *arg)\n{\n\tint ret = 0;\n\tint i;\n\tu64 rel_ptr;\n\tint size;\n\tstruct btrfs_ioctl_ino_path_args *ipa = NULL;\n\tstruct inode_fs_paths *ipath = NULL;\n\tstruct btrfs_path *path;\n\n\tif (!capable(CAP_DAC_READ_SEARCH))\n\t\treturn -EPERM;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tipa = memdup_user(arg, sizeof(*ipa));\n\tif (IS_ERR(ipa)) {\n\t\tret = PTR_ERR(ipa);\n\t\tipa = NULL;\n\t\tgoto out;\n\t}\n\n\tsize = min_t(u32, ipa->size, 4096);\n\tipath = init_ipath(size, root, path);\n\tif (IS_ERR(ipath)) {\n\t\tret = PTR_ERR(ipath);\n\t\tipath = NULL;\n\t\tgoto out;\n\t}\n\n\tret = paths_from_inode(ipa->inum, ipath);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tfor (i = 0; i < ipath->fspath->elem_cnt; ++i) {\n\t\trel_ptr = ipath->fspath->val[i] -\n\t\t\t  (u64)(unsigned long)ipath->fspath->val;\n\t\tipath->fspath->val[i] = rel_ptr;\n\t}\n\n\tret = copy_to_user((void *)(unsigned long)ipa->fspath,\n\t\t\t   (void *)(unsigned long)ipath->fspath, size);\n\tif (ret) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\tfree_ipath(ipath);\n\tkfree(ipa);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_ioctl_dev_replace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "4144-4190",
    "snippet": "static long btrfs_ioctl_dev_replace(struct btrfs_root *root, void __user *arg)\n{\n\tstruct btrfs_ioctl_dev_replace_args *p;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tp = memdup_user(arg, sizeof(*p));\n\tif (IS_ERR(p))\n\t\treturn PTR_ERR(p);\n\n\tswitch (p->cmd) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_CMD_START:\n\t\tif (root->fs_info->sb->s_flags & MS_RDONLY) {\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t\tif (atomic_xchg(\n\t\t\t&root->fs_info->mutually_exclusive_operation_running,\n\t\t\t1)) {\n\t\t\tret = BTRFS_ERROR_DEV_EXCL_RUN_IN_PROGRESS;\n\t\t} else {\n\t\t\tret = btrfs_dev_replace_start(root, p);\n\t\t\tatomic_set(\n\t\t\t &root->fs_info->mutually_exclusive_operation_running,\n\t\t\t 0);\n\t\t}\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_CMD_STATUS:\n\t\tbtrfs_dev_replace_status(root->fs_info, p);\n\t\tret = 0;\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_CMD_CANCEL:\n\t\tret = btrfs_dev_replace_cancel(root->fs_info, p);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (copy_to_user(arg, p, sizeof(*p)))\n\t\tret = -EFAULT;\nout:\n\tkfree(p);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "p"
          ],
          "line": 4188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "arg",
            "p",
            "sizeof(*p)"
          ],
          "line": 4185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_cancel",
          "args": [
            "root->fs_info",
            "p"
          ],
          "line": 4178
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_replace_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "680-685",
          "snippet": "int btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info,\n\t\t\t     struct btrfs_ioctl_dev_replace_args *args)\n{\n\targs->result = __btrfs_dev_replace_cancel(fs_info);\n\treturn 0;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);",
            "static int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);\nstatic int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);\n\nint btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info,\n\t\t\t     struct btrfs_ioctl_dev_replace_args *args)\n{\n\targs->result = __btrfs_dev_replace_cancel(fs_info);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_status",
          "args": [
            "root->fs_info",
            "p"
          ],
          "line": 4174
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_replace_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "645-678",
          "snippet": "void btrfs_dev_replace_status(struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_ioctl_dev_replace_args *args)\n{\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\tstruct btrfs_device *srcdev;\n\n\tbtrfs_dev_replace_lock(dev_replace);\n\t/* even if !dev_replace_is_valid, the values are good enough for\n\t * the replace_status ioctl */\n\targs->result = BTRFS_IOCTL_DEV_REPLACE_RESULT_NO_ERROR;\n\targs->status.replace_state = dev_replace->replace_state;\n\targs->status.time_started = dev_replace->time_started;\n\targs->status.time_stopped = dev_replace->time_stopped;\n\targs->status.num_write_errors =\n\t\tatomic64_read(&dev_replace->num_write_errors);\n\targs->status.num_uncorrectable_read_errors =\n\t\tatomic64_read(&dev_replace->num_uncorrectable_read_errors);\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\t\targs->status.progress_1000 = 0;\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\t\targs->status.progress_1000 = 1000;\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\tsrcdev = dev_replace->srcdev;\n\t\targs->status.progress_1000 = div64_u64(dev_replace->cursor_left,\n\t\t\tdiv64_u64(btrfs_device_get_total_bytes(srcdev), 1000));\n\t\tbreak;\n\t}\n\tbtrfs_dev_replace_unlock(dev_replace);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);",
            "static int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);\nstatic int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);\n\nvoid btrfs_dev_replace_status(struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_ioctl_dev_replace_args *args)\n{\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\tstruct btrfs_device *srcdev;\n\n\tbtrfs_dev_replace_lock(dev_replace);\n\t/* even if !dev_replace_is_valid, the values are good enough for\n\t * the replace_status ioctl */\n\targs->result = BTRFS_IOCTL_DEV_REPLACE_RESULT_NO_ERROR;\n\targs->status.replace_state = dev_replace->replace_state;\n\targs->status.time_started = dev_replace->time_started;\n\targs->status.time_stopped = dev_replace->time_stopped;\n\targs->status.num_write_errors =\n\t\tatomic64_read(&dev_replace->num_write_errors);\n\targs->status.num_uncorrectable_read_errors =\n\t\tatomic64_read(&dev_replace->num_uncorrectable_read_errors);\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\t\targs->status.progress_1000 = 0;\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\t\targs->status.progress_1000 = 1000;\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\tsrcdev = dev_replace->srcdev;\n\t\targs->status.progress_1000 = div64_u64(dev_replace->cursor_left,\n\t\t\tdiv64_u64(btrfs_device_get_total_bytes(srcdev), 1000));\n\t\tbreak;\n\t}\n\tbtrfs_dev_replace_unlock(dev_replace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&root->fs_info->mutually_exclusive_operation_running",
            "0"
          ],
          "line": 4168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_start",
          "args": [
            "root",
            "p"
          ],
          "line": 4167
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_replace_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "309-436",
          "snippet": "int btrfs_dev_replace_start(struct btrfs_root *root,\n\t\t\t    struct btrfs_ioctl_dev_replace_args *args)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\tint ret;\n\tstruct btrfs_device *tgt_device = NULL;\n\tstruct btrfs_device *src_device = NULL;\n\n\tswitch (args->start.cont_reading_from_srcdev_mode) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_CONT_READING_FROM_SRCDEV_MODE_ALWAYS:\n\tcase BTRFS_IOCTL_DEV_REPLACE_CONT_READING_FROM_SRCDEV_MODE_AVOID:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif ((args->start.srcdevid == 0 && args->start.srcdev_name[0] == '\\0') ||\n\t    args->start.tgtdev_name[0] == '\\0')\n\t\treturn -EINVAL;\n\n\t/*\n\t * Here we commit the transaction to make sure commit_total_bytes\n\t * of all the devices are updated.\n\t */\n\ttrans = btrfs_attach_transaction(root);\n\tif (!IS_ERR(trans)) {\n\t\tret = btrfs_commit_transaction(trans, root);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else if (PTR_ERR(trans) != -ENOENT) {\n\t\treturn PTR_ERR(trans);\n\t}\n\n\t/* the disk copy procedure reuses the scrub code */\n\tmutex_lock(&fs_info->volume_mutex);\n\tret = btrfs_dev_replace_find_srcdev(root, args->start.srcdevid,\n\t\t\t\t\t    args->start.srcdev_name,\n\t\t\t\t\t    &src_device);\n\tif (ret) {\n\t\tmutex_unlock(&fs_info->volume_mutex);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_init_dev_replace_tgtdev(root, args->start.tgtdev_name,\n\t\t\t\t\t    src_device, &tgt_device);\n\tmutex_unlock(&fs_info->volume_mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tbtrfs_dev_replace_lock(dev_replace);\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\targs->result = BTRFS_IOCTL_DEV_REPLACE_RESULT_ALREADY_STARTED;\n\t\tgoto leave;\n\t}\n\n\tdev_replace->cont_reading_from_srcdev_mode =\n\t\targs->start.cont_reading_from_srcdev_mode;\n\tWARN_ON(!src_device);\n\tdev_replace->srcdev = src_device;\n\tWARN_ON(!tgt_device);\n\tdev_replace->tgtdev = tgt_device;\n\n\tprintk_in_rcu(KERN_INFO\n\t\t      \"BTRFS: dev_replace from %s (devid %llu) to %s started\\n\",\n\t\t      src_device->missing ? \"<missing disk>\" :\n\t\t        rcu_str_deref(src_device->name),\n\t\t      src_device->devid,\n\t\t      rcu_str_deref(tgt_device->name));\n\n\t/*\n\t * from now on, the writes to the srcdev are all duplicated to\n\t * go to the tgtdev as well (refer to btrfs_map_block()).\n\t */\n\tdev_replace->replace_state = BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED;\n\tdev_replace->time_started = get_seconds();\n\tdev_replace->cursor_left = 0;\n\tdev_replace->committed_cursor_left = 0;\n\tdev_replace->cursor_left_last_write_of_item = 0;\n\tdev_replace->cursor_right = 0;\n\tdev_replace->is_valid = 1;\n\tdev_replace->item_needs_writeback = 1;\n\targs->result = BTRFS_IOCTL_DEV_REPLACE_RESULT_NO_ERROR;\n\tbtrfs_dev_replace_unlock(dev_replace);\n\n\tbtrfs_wait_ordered_roots(root->fs_info, -1);\n\n\t/* force writing the updated state information to disk */\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tbtrfs_dev_replace_lock(dev_replace);\n\t\tgoto leave;\n\t}\n\n\tret = btrfs_commit_transaction(trans, root);\n\tWARN_ON(ret);\n\n\t/* the disk copy procedure reuses the scrub code */\n\tret = btrfs_scrub_dev(fs_info, src_device->devid, 0,\n\t\t\t      btrfs_device_get_total_bytes(src_device),\n\t\t\t      &dev_replace->scrub_progress, 0, 1);\n\n\tret = btrfs_dev_replace_finishing(root->fs_info, ret);\n\t/* don't warn if EINPROGRESS, someone else might be running scrub */\n\tif (ret == -EINPROGRESS) {\n\t\targs->result = BTRFS_IOCTL_DEV_REPLACE_RESULT_SCRUB_INPROGRESS;\n\t\tret = 0;\n\t} else {\n\t\tWARN_ON(ret);\n\t}\n\n\treturn ret;\n\nleave:\n\tdev_replace->srcdev = NULL;\n\tdev_replace->tgtdev = NULL;\n\tbtrfs_dev_replace_unlock(dev_replace);\n\tbtrfs_destroy_dev_replace_tgtdev(fs_info, tgt_device);\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev);",
            "static u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);",
            "static int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev);\nstatic u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);\nstatic int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);\n\nint btrfs_dev_replace_start(struct btrfs_root *root,\n\t\t\t    struct btrfs_ioctl_dev_replace_args *args)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\tint ret;\n\tstruct btrfs_device *tgt_device = NULL;\n\tstruct btrfs_device *src_device = NULL;\n\n\tswitch (args->start.cont_reading_from_srcdev_mode) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_CONT_READING_FROM_SRCDEV_MODE_ALWAYS:\n\tcase BTRFS_IOCTL_DEV_REPLACE_CONT_READING_FROM_SRCDEV_MODE_AVOID:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif ((args->start.srcdevid == 0 && args->start.srcdev_name[0] == '\\0') ||\n\t    args->start.tgtdev_name[0] == '\\0')\n\t\treturn -EINVAL;\n\n\t/*\n\t * Here we commit the transaction to make sure commit_total_bytes\n\t * of all the devices are updated.\n\t */\n\ttrans = btrfs_attach_transaction(root);\n\tif (!IS_ERR(trans)) {\n\t\tret = btrfs_commit_transaction(trans, root);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else if (PTR_ERR(trans) != -ENOENT) {\n\t\treturn PTR_ERR(trans);\n\t}\n\n\t/* the disk copy procedure reuses the scrub code */\n\tmutex_lock(&fs_info->volume_mutex);\n\tret = btrfs_dev_replace_find_srcdev(root, args->start.srcdevid,\n\t\t\t\t\t    args->start.srcdev_name,\n\t\t\t\t\t    &src_device);\n\tif (ret) {\n\t\tmutex_unlock(&fs_info->volume_mutex);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_init_dev_replace_tgtdev(root, args->start.tgtdev_name,\n\t\t\t\t\t    src_device, &tgt_device);\n\tmutex_unlock(&fs_info->volume_mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tbtrfs_dev_replace_lock(dev_replace);\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\targs->result = BTRFS_IOCTL_DEV_REPLACE_RESULT_ALREADY_STARTED;\n\t\tgoto leave;\n\t}\n\n\tdev_replace->cont_reading_from_srcdev_mode =\n\t\targs->start.cont_reading_from_srcdev_mode;\n\tWARN_ON(!src_device);\n\tdev_replace->srcdev = src_device;\n\tWARN_ON(!tgt_device);\n\tdev_replace->tgtdev = tgt_device;\n\n\tprintk_in_rcu(KERN_INFO\n\t\t      \"BTRFS: dev_replace from %s (devid %llu) to %s started\\n\",\n\t\t      src_device->missing ? \"<missing disk>\" :\n\t\t        rcu_str_deref(src_device->name),\n\t\t      src_device->devid,\n\t\t      rcu_str_deref(tgt_device->name));\n\n\t/*\n\t * from now on, the writes to the srcdev are all duplicated to\n\t * go to the tgtdev as well (refer to btrfs_map_block()).\n\t */\n\tdev_replace->replace_state = BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED;\n\tdev_replace->time_started = get_seconds();\n\tdev_replace->cursor_left = 0;\n\tdev_replace->committed_cursor_left = 0;\n\tdev_replace->cursor_left_last_write_of_item = 0;\n\tdev_replace->cursor_right = 0;\n\tdev_replace->is_valid = 1;\n\tdev_replace->item_needs_writeback = 1;\n\targs->result = BTRFS_IOCTL_DEV_REPLACE_RESULT_NO_ERROR;\n\tbtrfs_dev_replace_unlock(dev_replace);\n\n\tbtrfs_wait_ordered_roots(root->fs_info, -1);\n\n\t/* force writing the updated state information to disk */\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tbtrfs_dev_replace_lock(dev_replace);\n\t\tgoto leave;\n\t}\n\n\tret = btrfs_commit_transaction(trans, root);\n\tWARN_ON(ret);\n\n\t/* the disk copy procedure reuses the scrub code */\n\tret = btrfs_scrub_dev(fs_info, src_device->devid, 0,\n\t\t\t      btrfs_device_get_total_bytes(src_device),\n\t\t\t      &dev_replace->scrub_progress, 0, 1);\n\n\tret = btrfs_dev_replace_finishing(root->fs_info, ret);\n\t/* don't warn if EINPROGRESS, someone else might be running scrub */\n\tif (ret == -EINPROGRESS) {\n\t\targs->result = BTRFS_IOCTL_DEV_REPLACE_RESULT_SCRUB_INPROGRESS;\n\t\tret = 0;\n\t} else {\n\t\tWARN_ON(ret);\n\t}\n\n\treturn ret;\n\nleave:\n\tdev_replace->srcdev = NULL;\n\tdev_replace->tgtdev = NULL;\n\tbtrfs_dev_replace_unlock(dev_replace);\n\tbtrfs_destroy_dev_replace_tgtdev(fs_info, tgt_device);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_xchg",
          "args": [
            "&root->fs_info->mutually_exclusive_operation_running",
            "1"
          ],
          "line": 4162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "p"
          ],
          "line": 4154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "p"
          ],
          "line": 4153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user",
          "args": [
            "arg",
            "sizeof(*p)"
          ],
          "line": 4152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 4149
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_dev_replace(struct btrfs_root *root, void __user *arg)\n{\n\tstruct btrfs_ioctl_dev_replace_args *p;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tp = memdup_user(arg, sizeof(*p));\n\tif (IS_ERR(p))\n\t\treturn PTR_ERR(p);\n\n\tswitch (p->cmd) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_CMD_START:\n\t\tif (root->fs_info->sb->s_flags & MS_RDONLY) {\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t\tif (atomic_xchg(\n\t\t\t&root->fs_info->mutually_exclusive_operation_running,\n\t\t\t1)) {\n\t\t\tret = BTRFS_ERROR_DEV_EXCL_RUN_IN_PROGRESS;\n\t\t} else {\n\t\t\tret = btrfs_dev_replace_start(root, p);\n\t\t\tatomic_set(\n\t\t\t &root->fs_info->mutually_exclusive_operation_running,\n\t\t\t 0);\n\t\t}\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_CMD_STATUS:\n\t\tbtrfs_dev_replace_status(root->fs_info, p);\n\t\tret = 0;\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_CMD_CANCEL:\n\t\tret = btrfs_dev_replace_cancel(root->fs_info, p);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (copy_to_user(arg, p, sizeof(*p)))\n\t\tret = -EFAULT;\nout:\n\tkfree(p);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_ioctl_get_dev_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "4120-4142",
    "snippet": "static long btrfs_ioctl_get_dev_stats(struct btrfs_root *root,\n\t\t\t\t      void __user *arg)\n{\n\tstruct btrfs_ioctl_get_dev_stats *sa;\n\tint ret;\n\n\tsa = memdup_user(arg, sizeof(*sa));\n\tif (IS_ERR(sa))\n\t\treturn PTR_ERR(sa);\n\n\tif ((sa->flags & BTRFS_DEV_STATS_RESET) && !capable(CAP_SYS_ADMIN)) {\n\t\tkfree(sa);\n\t\treturn -EPERM;\n\t}\n\n\tret = btrfs_get_dev_stats(root, sa);\n\n\tif (copy_to_user(arg, sa, sizeof(*sa)))\n\t\tret = -EFAULT;\n\n\tkfree(sa);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sa"
          ],
          "line": 4140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "arg",
            "sa",
            "sizeof(*sa)"
          ],
          "line": 4137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_get_dev_stats",
          "args": [
            "root",
            "sa"
          ],
          "line": 4135
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_dev_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "6635-6668",
          "snippet": "int btrfs_get_dev_stats(struct btrfs_root *root,\n\t\t\tstruct btrfs_ioctl_get_dev_stats *stats)\n{\n\tstruct btrfs_device *dev;\n\tstruct btrfs_fs_devices *fs_devices = root->fs_info->fs_devices;\n\tint i;\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tdev = btrfs_find_device(root->fs_info, stats->devid, NULL, NULL);\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\tif (!dev) {\n\t\tbtrfs_warn(root->fs_info, \"get dev_stats failed, device not found\");\n\t\treturn -ENODEV;\n\t} else if (!dev->dev_stats_valid) {\n\t\tbtrfs_warn(root->fs_info, \"get dev_stats failed, not yet valid\");\n\t\treturn -ENODEV;\n\t} else if (stats->flags & BTRFS_DEV_STATS_RESET) {\n\t\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++) {\n\t\t\tif (stats->nr_items > i)\n\t\t\t\tstats->values[i] =\n\t\t\t\t\tbtrfs_dev_stat_read_and_reset(dev, i);\n\t\t\telse\n\t\t\t\tbtrfs_dev_stat_reset(dev, i);\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++)\n\t\t\tif (stats->nr_items > i)\n\t\t\t\tstats->values[i] = btrfs_dev_stat_read(dev, i);\n\t}\n\tif (stats->nr_items > BTRFS_DEV_STAT_VALUES_MAX)\n\t\tstats->nr_items = BTRFS_DEV_STAT_VALUES_MAX;\n\treturn 0;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_get_dev_stats(struct btrfs_root *root,\n\t\t\tstruct btrfs_ioctl_get_dev_stats *stats)\n{\n\tstruct btrfs_device *dev;\n\tstruct btrfs_fs_devices *fs_devices = root->fs_info->fs_devices;\n\tint i;\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tdev = btrfs_find_device(root->fs_info, stats->devid, NULL, NULL);\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\tif (!dev) {\n\t\tbtrfs_warn(root->fs_info, \"get dev_stats failed, device not found\");\n\t\treturn -ENODEV;\n\t} else if (!dev->dev_stats_valid) {\n\t\tbtrfs_warn(root->fs_info, \"get dev_stats failed, not yet valid\");\n\t\treturn -ENODEV;\n\t} else if (stats->flags & BTRFS_DEV_STATS_RESET) {\n\t\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++) {\n\t\t\tif (stats->nr_items > i)\n\t\t\t\tstats->values[i] =\n\t\t\t\t\tbtrfs_dev_stat_read_and_reset(dev, i);\n\t\t\telse\n\t\t\t\tbtrfs_dev_stat_reset(dev, i);\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++)\n\t\t\tif (stats->nr_items > i)\n\t\t\t\tstats->values[i] = btrfs_dev_stat_read(dev, i);\n\t}\n\tif (stats->nr_items > BTRFS_DEV_STAT_VALUES_MAX)\n\t\tstats->nr_items = BTRFS_DEV_STAT_VALUES_MAX;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sa"
          ],
          "line": 4131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 4130
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "sa"
          ],
          "line": 4128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "sa"
          ],
          "line": 4127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user",
          "args": [
            "arg",
            "sizeof(*sa)"
          ],
          "line": 4126
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_get_dev_stats(struct btrfs_root *root,\n\t\t\t\t      void __user *arg)\n{\n\tstruct btrfs_ioctl_get_dev_stats *sa;\n\tint ret;\n\n\tsa = memdup_user(arg, sizeof(*sa));\n\tif (IS_ERR(sa))\n\t\treturn PTR_ERR(sa);\n\n\tif ((sa->flags & BTRFS_DEV_STATS_RESET) && !capable(CAP_SYS_ADMIN)) {\n\t\tkfree(sa);\n\t\treturn -EPERM;\n\t}\n\n\tret = btrfs_get_dev_stats(root, sa);\n\n\tif (copy_to_user(arg, sa, sizeof(*sa)))\n\t\tret = -EFAULT;\n\n\tkfree(sa);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_ioctl_scrub_progress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "4098-4118",
    "snippet": "static long btrfs_ioctl_scrub_progress(struct btrfs_root *root,\n\t\t\t\t       void __user *arg)\n{\n\tstruct btrfs_ioctl_scrub_args *sa;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tsa = memdup_user(arg, sizeof(*sa));\n\tif (IS_ERR(sa))\n\t\treturn PTR_ERR(sa);\n\n\tret = btrfs_scrub_progress(root, sa->devid, &sa->progress);\n\n\tif (copy_to_user(arg, sa, sizeof(*sa)))\n\t\tret = -EFAULT;\n\n\tkfree(sa);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sa"
          ],
          "line": 4116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "arg",
            "sa",
            "sizeof(*sa)"
          ],
          "line": 4113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_scrub_progress",
          "args": [
            "root",
            "sa->devid",
            "&sa->progress"
          ],
          "line": 4111
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_scrub_progress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "3825-3840",
          "snippet": "int btrfs_scrub_progress(struct btrfs_root *root, u64 devid,\n\t\t\t struct btrfs_scrub_progress *progress)\n{\n\tstruct btrfs_device *dev;\n\tstruct scrub_ctx *sctx = NULL;\n\n\tmutex_lock(&root->fs_info->fs_devices->device_list_mutex);\n\tdev = btrfs_find_device(root->fs_info, devid, NULL, NULL);\n\tif (dev)\n\t\tsctx = dev->scrub_device;\n\tif (sctx)\n\t\tmemcpy(progress, &sctx->stat, sizeof(*progress));\n\tmutex_unlock(&root->fs_info->fs_devices->device_list_mutex);\n\n\treturn dev ? (sctx ? 0 : -ENOTCONN) : -ENODEV;\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nint btrfs_scrub_progress(struct btrfs_root *root, u64 devid,\n\t\t\t struct btrfs_scrub_progress *progress)\n{\n\tstruct btrfs_device *dev;\n\tstruct scrub_ctx *sctx = NULL;\n\n\tmutex_lock(&root->fs_info->fs_devices->device_list_mutex);\n\tdev = btrfs_find_device(root->fs_info, devid, NULL, NULL);\n\tif (dev)\n\t\tsctx = dev->scrub_device;\n\tif (sctx)\n\t\tmemcpy(progress, &sctx->stat, sizeof(*progress));\n\tmutex_unlock(&root->fs_info->fs_devices->device_list_mutex);\n\n\treturn dev ? (sctx ? 0 : -ENOTCONN) : -ENODEV;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "sa"
          ],
          "line": 4109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "sa"
          ],
          "line": 4108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user",
          "args": [
            "arg",
            "sizeof(*sa)"
          ],
          "line": 4107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 4104
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_scrub_progress(struct btrfs_root *root,\n\t\t\t\t       void __user *arg)\n{\n\tstruct btrfs_ioctl_scrub_args *sa;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tsa = memdup_user(arg, sizeof(*sa));\n\tif (IS_ERR(sa))\n\t\treturn PTR_ERR(sa);\n\n\tret = btrfs_scrub_progress(root, sa->devid, &sa->progress);\n\n\tif (copy_to_user(arg, sa, sizeof(*sa)))\n\t\tret = -EFAULT;\n\n\tkfree(sa);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_ioctl_scrub_cancel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "4090-4096",
    "snippet": "static long btrfs_ioctl_scrub_cancel(struct btrfs_root *root, void __user *arg)\n{\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\treturn btrfs_scrub_cancel(root->fs_info);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_scrub_cancel",
          "args": [
            "root->fs_info"
          ],
          "line": 4095
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_scrub_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "3781-3800",
          "snippet": "int btrfs_scrub_cancel(struct btrfs_fs_info *fs_info)\n{\n\tmutex_lock(&fs_info->scrub_lock);\n\tif (!atomic_read(&fs_info->scrubs_running)) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\treturn -ENOTCONN;\n\t}\n\n\tatomic_inc(&fs_info->scrub_cancel_req);\n\twhile (atomic_read(&fs_info->scrubs_running)) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\twait_event(fs_info->scrub_pause_wait,\n\t\t\t   atomic_read(&fs_info->scrubs_running) == 0);\n\t\tmutex_lock(&fs_info->scrub_lock);\n\t}\n\tatomic_dec(&fs_info->scrub_cancel_req);\n\tmutex_unlock(&fs_info->scrub_lock);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic noinline_for_stack\nstruct;\n\nint btrfs_scrub_cancel(struct btrfs_fs_info *fs_info)\n{\n\tmutex_lock(&fs_info->scrub_lock);\n\tif (!atomic_read(&fs_info->scrubs_running)) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\treturn -ENOTCONN;\n\t}\n\n\tatomic_inc(&fs_info->scrub_cancel_req);\n\twhile (atomic_read(&fs_info->scrubs_running)) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\twait_event(fs_info->scrub_pause_wait,\n\t\t\t   atomic_read(&fs_info->scrubs_running) == 0);\n\t\tmutex_lock(&fs_info->scrub_lock);\n\t}\n\tatomic_dec(&fs_info->scrub_cancel_req);\n\tmutex_unlock(&fs_info->scrub_lock);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 4092
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_scrub_cancel(struct btrfs_root *root, void __user *arg)\n{\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\treturn btrfs_scrub_cancel(root->fs_info);\n}"
  },
  {
    "function_name": "btrfs_ioctl_scrub",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "4057-4088",
    "snippet": "static long btrfs_ioctl_scrub(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tstruct btrfs_ioctl_scrub_args *sa;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tsa = memdup_user(arg, sizeof(*sa));\n\tif (IS_ERR(sa))\n\t\treturn PTR_ERR(sa);\n\n\tif (!(sa->flags & BTRFS_SCRUB_READONLY)) {\n\t\tret = mnt_want_write_file(file);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tret = btrfs_scrub_dev(root->fs_info, sa->devid, sa->start, sa->end,\n\t\t\t      &sa->progress, sa->flags & BTRFS_SCRUB_READONLY,\n\t\t\t      0);\n\n\tif (copy_to_user(arg, sa, sizeof(*sa)))\n\t\tret = -EFAULT;\n\n\tif (!(sa->flags & BTRFS_SCRUB_READONLY))\n\t\tmnt_drop_write_file(file);\nout:\n\tkfree(sa);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sa"
          ],
          "line": 4086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "file"
          ],
          "line": 4084
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "arg",
            "sa",
            "sizeof(*sa)"
          ],
          "line": 4080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_scrub_dev",
          "args": [
            "root->fs_info",
            "sa->devid",
            "sa->start",
            "sa->end",
            "&sa->progress",
            "sa->flags & BTRFS_SCRUB_READONLY",
            "0"
          ],
          "line": 4076
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_scrub_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "3611-3754",
          "snippet": "int btrfs_scrub_dev(struct btrfs_fs_info *fs_info, u64 devid, u64 start,\n\t\t    u64 end, struct btrfs_scrub_progress *progress,\n\t\t    int readonly, int is_dev_replace)\n{\n\tstruct scrub_ctx *sctx;\n\tint ret;\n\tstruct btrfs_device *dev;\n\tstruct rcu_string *name;\n\n\tif (btrfs_fs_closing(fs_info))\n\t\treturn -EINVAL;\n\n\tif (fs_info->chunk_root->nodesize > BTRFS_STRIPE_LEN) {\n\t\t/*\n\t\t * in this case scrub is unable to calculate the checksum\n\t\t * the way scrub is implemented. Do not handle this\n\t\t * situation at all because it won't ever happen.\n\t\t */\n\t\tbtrfs_err(fs_info,\n\t\t\t   \"scrub: size assumption nodesize <= BTRFS_STRIPE_LEN (%d <= %d) fails\",\n\t\t       fs_info->chunk_root->nodesize, BTRFS_STRIPE_LEN);\n\t\treturn -EINVAL;\n\t}\n\n\tif (fs_info->chunk_root->sectorsize != PAGE_SIZE) {\n\t\t/* not supported for data w/o checksums */\n\t\tbtrfs_err(fs_info,\n\t\t\t   \"scrub: size assumption sectorsize != PAGE_SIZE \"\n\t\t\t   \"(%d != %lu) fails\",\n\t\t       fs_info->chunk_root->sectorsize, PAGE_SIZE);\n\t\treturn -EINVAL;\n\t}\n\n\tif (fs_info->chunk_root->nodesize >\n\t    PAGE_SIZE * SCRUB_MAX_PAGES_PER_BLOCK ||\n\t    fs_info->chunk_root->sectorsize >\n\t    PAGE_SIZE * SCRUB_MAX_PAGES_PER_BLOCK) {\n\t\t/*\n\t\t * would exhaust the array bounds of pagev member in\n\t\t * struct scrub_block\n\t\t */\n\t\tbtrfs_err(fs_info, \"scrub: size assumption nodesize and sectorsize \"\n\t\t\t   \"<= SCRUB_MAX_PAGES_PER_BLOCK (%d <= %d && %d <= %d) fails\",\n\t\t       fs_info->chunk_root->nodesize,\n\t\t       SCRUB_MAX_PAGES_PER_BLOCK,\n\t\t       fs_info->chunk_root->sectorsize,\n\t\t       SCRUB_MAX_PAGES_PER_BLOCK);\n\t\treturn -EINVAL;\n\t}\n\n\n\tmutex_lock(&fs_info->fs_devices->device_list_mutex);\n\tdev = btrfs_find_device(fs_info, devid, NULL, NULL);\n\tif (!dev || (dev->missing && !is_dev_replace)) {\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tif (!is_dev_replace && !readonly && !dev->writeable) {\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\trcu_read_lock();\n\t\tname = rcu_dereference(dev->name);\n\t\tbtrfs_err(fs_info, \"scrub: device %s is not writable\",\n\t\t\t  name->str);\n\t\trcu_read_unlock();\n\t\treturn -EROFS;\n\t}\n\n\tmutex_lock(&fs_info->scrub_lock);\n\tif (!dev->in_fs_metadata || dev->is_tgtdev_for_dev_replace) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\treturn -EIO;\n\t}\n\n\tbtrfs_dev_replace_lock(&fs_info->dev_replace);\n\tif (dev->scrub_device ||\n\t    (!is_dev_replace &&\n\t     btrfs_dev_replace_is_ongoing(&fs_info->dev_replace))) {\n\t\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\treturn -EINPROGRESS;\n\t}\n\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\n\tret = scrub_workers_get(fs_info, is_dev_replace);\n\tif (ret) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\treturn ret;\n\t}\n\n\tsctx = scrub_setup_ctx(dev, is_dev_replace);\n\tif (IS_ERR(sctx)) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\tscrub_workers_put(fs_info);\n\t\treturn PTR_ERR(sctx);\n\t}\n\tsctx->readonly = readonly;\n\tdev->scrub_device = sctx;\n\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\n\t/*\n\t * checking @scrub_pause_req here, we can avoid\n\t * race between committing transaction and scrubbing.\n\t */\n\t__scrub_blocked_if_needed(fs_info);\n\tatomic_inc(&fs_info->scrubs_running);\n\tmutex_unlock(&fs_info->scrub_lock);\n\n\tif (!is_dev_replace) {\n\t\t/*\n\t\t * by holding device list mutex, we can\n\t\t * kick off writing super in log tree sync.\n\t\t */\n\t\tmutex_lock(&fs_info->fs_devices->device_list_mutex);\n\t\tret = scrub_supers(sctx, dev);\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t}\n\n\tif (!ret)\n\t\tret = scrub_enumerate_chunks(sctx, dev, start, end,\n\t\t\t\t\t     is_dev_replace);\n\n\twait_event(sctx->list_wait, atomic_read(&sctx->bios_in_flight) == 0);\n\tatomic_dec(&fs_info->scrubs_running);\n\twake_up(&fs_info->scrub_pause_wait);\n\n\twait_event(sctx->list_wait, atomic_read(&sctx->workers_pending) == 0);\n\n\tif (progress)\n\t\tmemcpy(progress, &sctx->stat, sizeof(*progress));\n\n\tmutex_lock(&fs_info->scrub_lock);\n\tdev->scrub_device = NULL;\n\tscrub_workers_put(fs_info);\n\tmutex_unlock(&fs_info->scrub_lock);\n\n\tscrub_put_ctx(sctx);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [
            "#define SCRUB_MAX_PAGES_PER_BLOCK\t16\t/* 64k per node/leaf/sector */"
          ],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\n#define SCRUB_MAX_PAGES_PER_BLOCK\t16\t/* 64k per node/leaf/sector */\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic int scrub_setup_wr_ctx(struct scrub_ctx *sctx,\n\t\t\t      struct scrub_wr_ctx *wr_ctx,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_device *dev,\n\t\t\t      int is_dev_replace);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nint btrfs_scrub_dev(struct btrfs_fs_info *fs_info, u64 devid, u64 start,\n\t\t    u64 end, struct btrfs_scrub_progress *progress,\n\t\t    int readonly, int is_dev_replace)\n{\n\tstruct scrub_ctx *sctx;\n\tint ret;\n\tstruct btrfs_device *dev;\n\tstruct rcu_string *name;\n\n\tif (btrfs_fs_closing(fs_info))\n\t\treturn -EINVAL;\n\n\tif (fs_info->chunk_root->nodesize > BTRFS_STRIPE_LEN) {\n\t\t/*\n\t\t * in this case scrub is unable to calculate the checksum\n\t\t * the way scrub is implemented. Do not handle this\n\t\t * situation at all because it won't ever happen.\n\t\t */\n\t\tbtrfs_err(fs_info,\n\t\t\t   \"scrub: size assumption nodesize <= BTRFS_STRIPE_LEN (%d <= %d) fails\",\n\t\t       fs_info->chunk_root->nodesize, BTRFS_STRIPE_LEN);\n\t\treturn -EINVAL;\n\t}\n\n\tif (fs_info->chunk_root->sectorsize != PAGE_SIZE) {\n\t\t/* not supported for data w/o checksums */\n\t\tbtrfs_err(fs_info,\n\t\t\t   \"scrub: size assumption sectorsize != PAGE_SIZE \"\n\t\t\t   \"(%d != %lu) fails\",\n\t\t       fs_info->chunk_root->sectorsize, PAGE_SIZE);\n\t\treturn -EINVAL;\n\t}\n\n\tif (fs_info->chunk_root->nodesize >\n\t    PAGE_SIZE * SCRUB_MAX_PAGES_PER_BLOCK ||\n\t    fs_info->chunk_root->sectorsize >\n\t    PAGE_SIZE * SCRUB_MAX_PAGES_PER_BLOCK) {\n\t\t/*\n\t\t * would exhaust the array bounds of pagev member in\n\t\t * struct scrub_block\n\t\t */\n\t\tbtrfs_err(fs_info, \"scrub: size assumption nodesize and sectorsize \"\n\t\t\t   \"<= SCRUB_MAX_PAGES_PER_BLOCK (%d <= %d && %d <= %d) fails\",\n\t\t       fs_info->chunk_root->nodesize,\n\t\t       SCRUB_MAX_PAGES_PER_BLOCK,\n\t\t       fs_info->chunk_root->sectorsize,\n\t\t       SCRUB_MAX_PAGES_PER_BLOCK);\n\t\treturn -EINVAL;\n\t}\n\n\n\tmutex_lock(&fs_info->fs_devices->device_list_mutex);\n\tdev = btrfs_find_device(fs_info, devid, NULL, NULL);\n\tif (!dev || (dev->missing && !is_dev_replace)) {\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tif (!is_dev_replace && !readonly && !dev->writeable) {\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\trcu_read_lock();\n\t\tname = rcu_dereference(dev->name);\n\t\tbtrfs_err(fs_info, \"scrub: device %s is not writable\",\n\t\t\t  name->str);\n\t\trcu_read_unlock();\n\t\treturn -EROFS;\n\t}\n\n\tmutex_lock(&fs_info->scrub_lock);\n\tif (!dev->in_fs_metadata || dev->is_tgtdev_for_dev_replace) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\treturn -EIO;\n\t}\n\n\tbtrfs_dev_replace_lock(&fs_info->dev_replace);\n\tif (dev->scrub_device ||\n\t    (!is_dev_replace &&\n\t     btrfs_dev_replace_is_ongoing(&fs_info->dev_replace))) {\n\t\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\treturn -EINPROGRESS;\n\t}\n\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\n\tret = scrub_workers_get(fs_info, is_dev_replace);\n\tif (ret) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\treturn ret;\n\t}\n\n\tsctx = scrub_setup_ctx(dev, is_dev_replace);\n\tif (IS_ERR(sctx)) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t\tscrub_workers_put(fs_info);\n\t\treturn PTR_ERR(sctx);\n\t}\n\tsctx->readonly = readonly;\n\tdev->scrub_device = sctx;\n\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\n\t/*\n\t * checking @scrub_pause_req here, we can avoid\n\t * race between committing transaction and scrubbing.\n\t */\n\t__scrub_blocked_if_needed(fs_info);\n\tatomic_inc(&fs_info->scrubs_running);\n\tmutex_unlock(&fs_info->scrub_lock);\n\n\tif (!is_dev_replace) {\n\t\t/*\n\t\t * by holding device list mutex, we can\n\t\t * kick off writing super in log tree sync.\n\t\t */\n\t\tmutex_lock(&fs_info->fs_devices->device_list_mutex);\n\t\tret = scrub_supers(sctx, dev);\n\t\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\t}\n\n\tif (!ret)\n\t\tret = scrub_enumerate_chunks(sctx, dev, start, end,\n\t\t\t\t\t     is_dev_replace);\n\n\twait_event(sctx->list_wait, atomic_read(&sctx->bios_in_flight) == 0);\n\tatomic_dec(&fs_info->scrubs_running);\n\twake_up(&fs_info->scrub_pause_wait);\n\n\twait_event(sctx->list_wait, atomic_read(&sctx->workers_pending) == 0);\n\n\tif (progress)\n\t\tmemcpy(progress, &sctx->stat, sizeof(*progress));\n\n\tmutex_lock(&fs_info->scrub_lock);\n\tdev->scrub_device = NULL;\n\tscrub_workers_put(fs_info);\n\tmutex_unlock(&fs_info->scrub_lock);\n\n\tscrub_put_ctx(sctx);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "file"
          ],
          "line": 4071
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "sa"
          ],
          "line": 4068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "sa"
          ],
          "line": 4067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user",
          "args": [
            "arg",
            "sizeof(*sa)"
          ],
          "line": 4066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 4063
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "file_inode(file)"
          ],
          "line": 4059
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 4059
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_scrub(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tstruct btrfs_ioctl_scrub_args *sa;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tsa = memdup_user(arg, sizeof(*sa));\n\tif (IS_ERR(sa))\n\t\treturn PTR_ERR(sa);\n\n\tif (!(sa->flags & BTRFS_SCRUB_READONLY)) {\n\t\tret = mnt_want_write_file(file);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tret = btrfs_scrub_dev(root->fs_info, sa->devid, sa->start, sa->end,\n\t\t\t      &sa->progress, sa->flags & BTRFS_SCRUB_READONLY,\n\t\t\t      0);\n\n\tif (copy_to_user(arg, sa, sizeof(*sa)))\n\t\tret = -EFAULT;\n\n\tif (!(sa->flags & BTRFS_SCRUB_READONLY))\n\t\tmnt_drop_write_file(file);\nout:\n\tkfree(sa);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_ioctl_wait_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "4043-4055",
    "snippet": "static noinline long btrfs_ioctl_wait_sync(struct btrfs_root *root,\n\t\t\t\t\t   void __user *argp)\n{\n\tu64 transid;\n\n\tif (argp) {\n\t\tif (copy_from_user(&transid, argp, sizeof(transid)))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\ttransid = 0;  /* current trans */\n\t}\n\treturn btrfs_wait_for_commit(root, transid);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_wait_for_commit",
          "args": [
            "root",
            "transid"
          ],
          "line": 4054
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_wait_for_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "635-691",
          "snippet": "int btrfs_wait_for_commit(struct btrfs_root *root, u64 transid)\n{\n\tstruct btrfs_transaction *cur_trans = NULL, *t;\n\tint ret = 0;\n\n\tif (transid) {\n\t\tif (transid <= root->fs_info->last_trans_committed)\n\t\t\tgoto out;\n\n\t\t/* find specified transaction */\n\t\tspin_lock(&root->fs_info->trans_lock);\n\t\tlist_for_each_entry(t, &root->fs_info->trans_list, list) {\n\t\t\tif (t->transid == transid) {\n\t\t\t\tcur_trans = t;\n\t\t\t\tatomic_inc(&cur_trans->use_count);\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (t->transid > transid) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t/*\n\t\t * The specified transaction doesn't exist, or we\n\t\t * raced with btrfs_commit_transaction\n\t\t */\n\t\tif (!cur_trans) {\n\t\t\tif (transid > root->fs_info->last_trans_committed)\n\t\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/* find newest transaction that is committing | committed */\n\t\tspin_lock(&root->fs_info->trans_lock);\n\t\tlist_for_each_entry_reverse(t, &root->fs_info->trans_list,\n\t\t\t\t\t    list) {\n\t\t\tif (t->state >= TRANS_STATE_COMMIT_START) {\n\t\t\t\tif (t->state == TRANS_STATE_COMPLETED)\n\t\t\t\t\tbreak;\n\t\t\t\tcur_trans = t;\n\t\t\t\tatomic_inc(&cur_trans->use_count);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tif (!cur_trans)\n\t\t\tgoto out;  /* nothing committing|committed */\n\t}\n\n\twait_for_commit(root, cur_trans);\n\tbtrfs_put_transaction(cur_trans);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_wait_for_commit(struct btrfs_root *root, u64 transid)\n{\n\tstruct btrfs_transaction *cur_trans = NULL, *t;\n\tint ret = 0;\n\n\tif (transid) {\n\t\tif (transid <= root->fs_info->last_trans_committed)\n\t\t\tgoto out;\n\n\t\t/* find specified transaction */\n\t\tspin_lock(&root->fs_info->trans_lock);\n\t\tlist_for_each_entry(t, &root->fs_info->trans_list, list) {\n\t\t\tif (t->transid == transid) {\n\t\t\t\tcur_trans = t;\n\t\t\t\tatomic_inc(&cur_trans->use_count);\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (t->transid > transid) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t/*\n\t\t * The specified transaction doesn't exist, or we\n\t\t * raced with btrfs_commit_transaction\n\t\t */\n\t\tif (!cur_trans) {\n\t\t\tif (transid > root->fs_info->last_trans_committed)\n\t\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/* find newest transaction that is committing | committed */\n\t\tspin_lock(&root->fs_info->trans_lock);\n\t\tlist_for_each_entry_reverse(t, &root->fs_info->trans_list,\n\t\t\t\t\t    list) {\n\t\t\tif (t->state >= TRANS_STATE_COMMIT_START) {\n\t\t\t\tif (t->state == TRANS_STATE_COMPLETED)\n\t\t\t\t\tbreak;\n\t\t\t\tcur_trans = t;\n\t\t\t\tatomic_inc(&cur_trans->use_count);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tif (!cur_trans)\n\t\t\tgoto out;  /* nothing committing|committed */\n\t}\n\n\twait_for_commit(root, cur_trans);\n\tbtrfs_put_transaction(cur_trans);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&transid",
            "argp",
            "sizeof(transid)"
          ],
          "line": 4049
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic noinline long btrfs_ioctl_wait_sync(struct btrfs_root *root,\n\t\t\t\t\t   void __user *argp)\n{\n\tu64 transid;\n\n\tif (argp) {\n\t\tif (copy_from_user(&transid, argp, sizeof(transid)))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\ttransid = 0;  /* current trans */\n\t}\n\treturn btrfs_wait_for_commit(root, transid);\n}"
  },
  {
    "function_name": "btrfs_ioctl_start_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "4014-4041",
    "snippet": "static noinline long btrfs_ioctl_start_sync(struct btrfs_root *root,\n\t\t\t\t\t    void __user *argp)\n{\n\tstruct btrfs_trans_handle *trans;\n\tu64 transid;\n\tint ret;\n\n\ttrans = btrfs_attach_transaction_barrier(root);\n\tif (IS_ERR(trans)) {\n\t\tif (PTR_ERR(trans) != -ENOENT)\n\t\t\treturn PTR_ERR(trans);\n\n\t\t/* No running transaction, don't bother */\n\t\ttransid = root->fs_info->last_trans_committed;\n\t\tgoto out;\n\t}\n\ttransid = trans->transid;\n\tret = btrfs_commit_transaction_async(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\nout:\n\tif (argp)\n\t\tif (copy_to_user(argp, &transid, sizeof(transid)))\n\t\t\treturn -EFAULT;\n\treturn 0;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "argp",
            "&transid",
            "sizeof(transid)"
          ],
          "line": 4038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_end_transaction",
          "args": [
            "trans",
            "root"
          ],
          "line": 4033
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_end_transaction_throttle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "846-850",
          "snippet": "int btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_commit_transaction_async",
          "args": [
            "trans",
            "root",
            "0"
          ],
          "line": 4031
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_commit_transaction_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "1627-1675",
          "snippet": "int btrfs_commit_transaction_async(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root,\n\t\t\t\t   int wait_for_unblock)\n{\n\tstruct btrfs_async_commit *ac;\n\tstruct btrfs_transaction *cur_trans;\n\n\tac = kmalloc(sizeof(*ac), GFP_NOFS);\n\tif (!ac)\n\t\treturn -ENOMEM;\n\n\tINIT_WORK(&ac->work, do_async_commit);\n\tac->root = root;\n\tac->newtrans = btrfs_join_transaction(root);\n\tif (IS_ERR(ac->newtrans)) {\n\t\tint err = PTR_ERR(ac->newtrans);\n\t\tkfree(ac);\n\t\treturn err;\n\t}\n\n\t/* take transaction reference */\n\tcur_trans = trans->transaction;\n\tatomic_inc(&cur_trans->use_count);\n\n\tbtrfs_end_transaction(trans, root);\n\n\t/*\n\t * Tell lockdep we've released the freeze rwsem, since the\n\t * async commit thread will be the one to unlock it.\n\t */\n\tif (ac->newtrans->type & __TRANS_FREEZABLE)\n\t\trwsem_release(\n\t\t\t&root->fs_info->sb->s_writers.lock_map[SB_FREEZE_FS-1],\n\t\t\t1, _THIS_IP_);\n\n\tschedule_work(&ac->work);\n\n\t/* wait for transaction to start and unblock */\n\tif (wait_for_unblock)\n\t\twait_current_trans_commit_start_and_unblock(root, cur_trans);\n\telse\n\t\twait_current_trans_commit_start(root, cur_trans);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tbtrfs_put_transaction(cur_trans);\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_commit_transaction_async(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root,\n\t\t\t\t   int wait_for_unblock)\n{\n\tstruct btrfs_async_commit *ac;\n\tstruct btrfs_transaction *cur_trans;\n\n\tac = kmalloc(sizeof(*ac), GFP_NOFS);\n\tif (!ac)\n\t\treturn -ENOMEM;\n\n\tINIT_WORK(&ac->work, do_async_commit);\n\tac->root = root;\n\tac->newtrans = btrfs_join_transaction(root);\n\tif (IS_ERR(ac->newtrans)) {\n\t\tint err = PTR_ERR(ac->newtrans);\n\t\tkfree(ac);\n\t\treturn err;\n\t}\n\n\t/* take transaction reference */\n\tcur_trans = trans->transaction;\n\tatomic_inc(&cur_trans->use_count);\n\n\tbtrfs_end_transaction(trans, root);\n\n\t/*\n\t * Tell lockdep we've released the freeze rwsem, since the\n\t * async commit thread will be the one to unlock it.\n\t */\n\tif (ac->newtrans->type & __TRANS_FREEZABLE)\n\t\trwsem_release(\n\t\t\t&root->fs_info->sb->s_writers.lock_map[SB_FREEZE_FS-1],\n\t\t\t1, _THIS_IP_);\n\n\tschedule_work(&ac->work);\n\n\t/* wait for transaction to start and unblock */\n\tif (wait_for_unblock)\n\t\twait_current_trans_commit_start_and_unblock(root, cur_trans);\n\telse\n\t\twait_current_trans_commit_start(root, cur_trans);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tbtrfs_put_transaction(cur_trans);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 4024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 4023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 4022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_attach_transaction_barrier",
          "args": [
            "root"
          ],
          "line": 4021
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_attach_transaction_barrier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "616-626",
          "snippet": "struct btrfs_trans_handle *\nbtrfs_attach_transaction_barrier(struct btrfs_root *root)\n{\n\tstruct btrfs_trans_handle *trans;\n\n\ttrans = start_transaction(root, 0, TRANS_ATTACH, 0);\n\tif (IS_ERR(trans) && PTR_ERR(trans) == -ENOENT)\n\t\tbtrfs_wait_for_commit(root, 0);\n\n\treturn trans;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *\nbtrfs_attach_transaction_barrier(struct btrfs_root *root)\n{\n\tstruct btrfs_trans_handle *trans;\n\n\ttrans = start_transaction(root, 0, TRANS_ATTACH, 0);\n\tif (IS_ERR(trans) && PTR_ERR(trans) == -ENOENT)\n\t\tbtrfs_wait_for_commit(root, 0);\n\n\treturn trans;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic noinline long btrfs_ioctl_start_sync(struct btrfs_root *root,\n\t\t\t\t\t    void __user *argp)\n{\n\tstruct btrfs_trans_handle *trans;\n\tu64 transid;\n\tint ret;\n\n\ttrans = btrfs_attach_transaction_barrier(root);\n\tif (IS_ERR(trans)) {\n\t\tif (PTR_ERR(trans) != -ENOENT)\n\t\t\treturn PTR_ERR(trans);\n\n\t\t/* No running transaction, don't bother */\n\t\ttransid = root->fs_info->last_trans_committed;\n\t\tgoto out;\n\t}\n\ttransid = trans->transid;\n\tret = btrfs_commit_transaction_async(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\nout:\n\tif (argp)\n\t\tif (copy_to_user(argp, &transid, sizeof(transid)))\n\t\t\treturn -EFAULT;\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_ioctl_trans_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "3995-4012",
    "snippet": "long btrfs_ioctl_trans_end(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_trans_handle *trans;\n\n\ttrans = file->private_data;\n\tif (!trans)\n\t\treturn -EINVAL;\n\tfile->private_data = NULL;\n\n\tbtrfs_end_transaction(trans, root);\n\n\tatomic_dec(&root->fs_info->open_ioctl_trans);\n\n\tmnt_drop_write_file(file);\n\treturn 0;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "file"
          ],
          "line": 4010
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&root->fs_info->open_ioctl_trans"
          ],
          "line": 4008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_end_transaction",
          "args": [
            "trans",
            "root"
          ],
          "line": 4006
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_end_transaction_throttle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "846-850",
          "snippet": "int btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 3998
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 3997
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nlong btrfs_ioctl_trans_end(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_trans_handle *trans;\n\n\ttrans = file->private_data;\n\tif (!trans)\n\t\treturn -EINVAL;\n\tfile->private_data = NULL;\n\n\tbtrfs_end_transaction(trans, root);\n\n\tatomic_dec(&root->fs_info->open_ioctl_trans);\n\n\tmnt_drop_write_file(file);\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_ioctl_space_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "3849-3987",
    "snippet": "static long btrfs_ioctl_space_info(struct btrfs_root *root, void __user *arg)\n{\n\tstruct btrfs_ioctl_space_args space_args;\n\tstruct btrfs_ioctl_space_info space;\n\tstruct btrfs_ioctl_space_info *dest;\n\tstruct btrfs_ioctl_space_info *dest_orig;\n\tstruct btrfs_ioctl_space_info __user *user_dest;\n\tstruct btrfs_space_info *info;\n\tu64 types[] = {BTRFS_BLOCK_GROUP_DATA,\n\t\t       BTRFS_BLOCK_GROUP_SYSTEM,\n\t\t       BTRFS_BLOCK_GROUP_METADATA,\n\t\t       BTRFS_BLOCK_GROUP_DATA | BTRFS_BLOCK_GROUP_METADATA};\n\tint num_types = 4;\n\tint alloc_size;\n\tint ret = 0;\n\tu64 slot_count = 0;\n\tint i, c;\n\n\tif (copy_from_user(&space_args,\n\t\t\t   (struct btrfs_ioctl_space_args __user *)arg,\n\t\t\t   sizeof(space_args)))\n\t\treturn -EFAULT;\n\n\tfor (i = 0; i < num_types; i++) {\n\t\tstruct btrfs_space_info *tmp;\n\n\t\tinfo = NULL;\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(tmp, &root->fs_info->space_info,\n\t\t\t\t\tlist) {\n\t\t\tif (tmp->flags == types[i]) {\n\t\t\t\tinfo = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tif (!info)\n\t\t\tcontinue;\n\n\t\tdown_read(&info->groups_sem);\n\t\tfor (c = 0; c < BTRFS_NR_RAID_TYPES; c++) {\n\t\t\tif (!list_empty(&info->block_groups[c]))\n\t\t\t\tslot_count++;\n\t\t}\n\t\tup_read(&info->groups_sem);\n\t}\n\n\t/*\n\t * Global block reserve, exported as a space_info\n\t */\n\tslot_count++;\n\n\t/* space_slots == 0 means they are asking for a count */\n\tif (space_args.space_slots == 0) {\n\t\tspace_args.total_spaces = slot_count;\n\t\tgoto out;\n\t}\n\n\tslot_count = min_t(u64, space_args.space_slots, slot_count);\n\n\talloc_size = sizeof(*dest) * slot_count;\n\n\t/* we generally have at most 6 or so space infos, one for each raid\n\t * level.  So, a whole page should be more than enough for everyone\n\t */\n\tif (alloc_size > PAGE_CACHE_SIZE)\n\t\treturn -ENOMEM;\n\n\tspace_args.total_spaces = 0;\n\tdest = kmalloc(alloc_size, GFP_NOFS);\n\tif (!dest)\n\t\treturn -ENOMEM;\n\tdest_orig = dest;\n\n\t/* now we have a buffer to copy into */\n\tfor (i = 0; i < num_types; i++) {\n\t\tstruct btrfs_space_info *tmp;\n\n\t\tif (!slot_count)\n\t\t\tbreak;\n\n\t\tinfo = NULL;\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(tmp, &root->fs_info->space_info,\n\t\t\t\t\tlist) {\n\t\t\tif (tmp->flags == types[i]) {\n\t\t\t\tinfo = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tif (!info)\n\t\t\tcontinue;\n\t\tdown_read(&info->groups_sem);\n\t\tfor (c = 0; c < BTRFS_NR_RAID_TYPES; c++) {\n\t\t\tif (!list_empty(&info->block_groups[c])) {\n\t\t\t\tbtrfs_get_block_group_info(\n\t\t\t\t\t&info->block_groups[c], &space);\n\t\t\t\tmemcpy(dest, &space, sizeof(space));\n\t\t\t\tdest++;\n\t\t\t\tspace_args.total_spaces++;\n\t\t\t\tslot_count--;\n\t\t\t}\n\t\t\tif (!slot_count)\n\t\t\t\tbreak;\n\t\t}\n\t\tup_read(&info->groups_sem);\n\t}\n\n\t/*\n\t * Add global block reserve\n\t */\n\tif (slot_count) {\n\t\tstruct btrfs_block_rsv *block_rsv = &root->fs_info->global_block_rsv;\n\n\t\tspin_lock(&block_rsv->lock);\n\t\tspace.total_bytes = block_rsv->size;\n\t\tspace.used_bytes = block_rsv->size - block_rsv->reserved;\n\t\tspin_unlock(&block_rsv->lock);\n\t\tspace.flags = BTRFS_SPACE_INFO_GLOBAL_RSV;\n\t\tmemcpy(dest, &space, sizeof(space));\n\t\tspace_args.total_spaces++;\n\t}\n\n\tuser_dest = (struct btrfs_ioctl_space_info __user *)\n\t\t(arg + sizeof(struct btrfs_ioctl_space_args));\n\n\tif (copy_to_user(user_dest, dest_orig, alloc_size))\n\t\tret = -EFAULT;\n\n\tkfree(dest_orig);\nout:\n\tif (ret == 0 && copy_to_user(arg, &space_args, sizeof(space_args)))\n\t\tret = -EFAULT;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "arg",
            "&space_args",
            "sizeof(space_args)"
          ],
          "line": 3983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dest_orig"
          ],
          "line": 3981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "user_dest",
            "dest_orig",
            "alloc_size"
          ],
          "line": 3978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dest",
            "&space",
            "sizeof(space)"
          ],
          "line": 3971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&block_rsv->lock"
          ],
          "line": 3969
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&block_rsv->lock"
          ],
          "line": 3966
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&info->groups_sem"
          ],
          "line": 3957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dest",
            "&space",
            "sizeof(space)"
          ],
          "line": 3949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_get_block_group_info",
          "args": [
            "&info->block_groups[c]",
            "&space"
          ],
          "line": 3947
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_block_group_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "3833-3847",
          "snippet": "void btrfs_get_block_group_info(struct list_head *groups_list,\n\t\t\t\tstruct btrfs_ioctl_space_info *space)\n{\n\tstruct btrfs_block_group_cache *block_group;\n\n\tspace->total_bytes = 0;\n\tspace->used_bytes = 0;\n\tspace->flags = 0;\n\tlist_for_each_entry(block_group, groups_list, list) {\n\t\tspace->flags = block_group->flags;\n\t\tspace->total_bytes += block_group->key.offset;\n\t\tspace->used_bytes +=\n\t\t\tbtrfs_block_group_used(&block_group->item);\n\t}\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nvoid btrfs_get_block_group_info(struct list_head *groups_list,\n\t\t\t\tstruct btrfs_ioctl_space_info *space)\n{\n\tstruct btrfs_block_group_cache *block_group;\n\n\tspace->total_bytes = 0;\n\tspace->used_bytes = 0;\n\tspace->flags = 0;\n\tlist_for_each_entry(block_group, groups_list, list) {\n\t\tspace->flags = block_group->flags;\n\t\tspace->total_bytes += block_group->key.offset;\n\t\tspace->used_bytes +=\n\t\t\tbtrfs_block_group_used(&block_group->item);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&info->block_groups[c]"
          ],
          "line": 3946
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&info->groups_sem"
          ],
          "line": 3944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 3940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "tmp",
            "&root->fs_info->space_info",
            "list"
          ],
          "line": 3933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 3932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "alloc_size",
            "GFP_NOFS"
          ],
          "line": 3919
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u64",
            "space_args.space_slots",
            "slot_count"
          ],
          "line": 3908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&info->groups_sem"
          ],
          "line": 3894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&info->groups_sem"
          ],
          "line": 3889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 3884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "tmp",
            "&root->fs_info->space_info",
            "list"
          ],
          "line": 3877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 3876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&space_args",
            "(struct btrfs_ioctl_space_args __user *)arg",
            "sizeof(space_args)"
          ],
          "line": 3867
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_space_info(struct btrfs_root *root, void __user *arg)\n{\n\tstruct btrfs_ioctl_space_args space_args;\n\tstruct btrfs_ioctl_space_info space;\n\tstruct btrfs_ioctl_space_info *dest;\n\tstruct btrfs_ioctl_space_info *dest_orig;\n\tstruct btrfs_ioctl_space_info __user *user_dest;\n\tstruct btrfs_space_info *info;\n\tu64 types[] = {BTRFS_BLOCK_GROUP_DATA,\n\t\t       BTRFS_BLOCK_GROUP_SYSTEM,\n\t\t       BTRFS_BLOCK_GROUP_METADATA,\n\t\t       BTRFS_BLOCK_GROUP_DATA | BTRFS_BLOCK_GROUP_METADATA};\n\tint num_types = 4;\n\tint alloc_size;\n\tint ret = 0;\n\tu64 slot_count = 0;\n\tint i, c;\n\n\tif (copy_from_user(&space_args,\n\t\t\t   (struct btrfs_ioctl_space_args __user *)arg,\n\t\t\t   sizeof(space_args)))\n\t\treturn -EFAULT;\n\n\tfor (i = 0; i < num_types; i++) {\n\t\tstruct btrfs_space_info *tmp;\n\n\t\tinfo = NULL;\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(tmp, &root->fs_info->space_info,\n\t\t\t\t\tlist) {\n\t\t\tif (tmp->flags == types[i]) {\n\t\t\t\tinfo = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tif (!info)\n\t\t\tcontinue;\n\n\t\tdown_read(&info->groups_sem);\n\t\tfor (c = 0; c < BTRFS_NR_RAID_TYPES; c++) {\n\t\t\tif (!list_empty(&info->block_groups[c]))\n\t\t\t\tslot_count++;\n\t\t}\n\t\tup_read(&info->groups_sem);\n\t}\n\n\t/*\n\t * Global block reserve, exported as a space_info\n\t */\n\tslot_count++;\n\n\t/* space_slots == 0 means they are asking for a count */\n\tif (space_args.space_slots == 0) {\n\t\tspace_args.total_spaces = slot_count;\n\t\tgoto out;\n\t}\n\n\tslot_count = min_t(u64, space_args.space_slots, slot_count);\n\n\talloc_size = sizeof(*dest) * slot_count;\n\n\t/* we generally have at most 6 or so space infos, one for each raid\n\t * level.  So, a whole page should be more than enough for everyone\n\t */\n\tif (alloc_size > PAGE_CACHE_SIZE)\n\t\treturn -ENOMEM;\n\n\tspace_args.total_spaces = 0;\n\tdest = kmalloc(alloc_size, GFP_NOFS);\n\tif (!dest)\n\t\treturn -ENOMEM;\n\tdest_orig = dest;\n\n\t/* now we have a buffer to copy into */\n\tfor (i = 0; i < num_types; i++) {\n\t\tstruct btrfs_space_info *tmp;\n\n\t\tif (!slot_count)\n\t\t\tbreak;\n\n\t\tinfo = NULL;\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(tmp, &root->fs_info->space_info,\n\t\t\t\t\tlist) {\n\t\t\tif (tmp->flags == types[i]) {\n\t\t\t\tinfo = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tif (!info)\n\t\t\tcontinue;\n\t\tdown_read(&info->groups_sem);\n\t\tfor (c = 0; c < BTRFS_NR_RAID_TYPES; c++) {\n\t\t\tif (!list_empty(&info->block_groups[c])) {\n\t\t\t\tbtrfs_get_block_group_info(\n\t\t\t\t\t&info->block_groups[c], &space);\n\t\t\t\tmemcpy(dest, &space, sizeof(space));\n\t\t\t\tdest++;\n\t\t\t\tspace_args.total_spaces++;\n\t\t\t\tslot_count--;\n\t\t\t}\n\t\t\tif (!slot_count)\n\t\t\t\tbreak;\n\t\t}\n\t\tup_read(&info->groups_sem);\n\t}\n\n\t/*\n\t * Add global block reserve\n\t */\n\tif (slot_count) {\n\t\tstruct btrfs_block_rsv *block_rsv = &root->fs_info->global_block_rsv;\n\n\t\tspin_lock(&block_rsv->lock);\n\t\tspace.total_bytes = block_rsv->size;\n\t\tspace.used_bytes = block_rsv->size - block_rsv->reserved;\n\t\tspin_unlock(&block_rsv->lock);\n\t\tspace.flags = BTRFS_SPACE_INFO_GLOBAL_RSV;\n\t\tmemcpy(dest, &space, sizeof(space));\n\t\tspace_args.total_spaces++;\n\t}\n\n\tuser_dest = (struct btrfs_ioctl_space_info __user *)\n\t\t(arg + sizeof(struct btrfs_ioctl_space_args));\n\n\tif (copy_to_user(user_dest, dest_orig, alloc_size))\n\t\tret = -EFAULT;\n\n\tkfree(dest_orig);\nout:\n\tif (ret == 0 && copy_to_user(arg, &space_args, sizeof(space_args)))\n\t\tret = -EFAULT;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_get_block_group_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "3833-3847",
    "snippet": "void btrfs_get_block_group_info(struct list_head *groups_list,\n\t\t\t\tstruct btrfs_ioctl_space_info *space)\n{\n\tstruct btrfs_block_group_cache *block_group;\n\n\tspace->total_bytes = 0;\n\tspace->used_bytes = 0;\n\tspace->flags = 0;\n\tlist_for_each_entry(block_group, groups_list, list) {\n\t\tspace->flags = block_group->flags;\n\t\tspace->total_bytes += block_group->key.offset;\n\t\tspace->used_bytes +=\n\t\t\tbtrfs_block_group_used(&block_group->item);\n\t}\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_block_group_used",
          "args": [
            "&block_group->item"
          ],
          "line": 3845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "block_group",
            "groups_list",
            "list"
          ],
          "line": 3841
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nvoid btrfs_get_block_group_info(struct list_head *groups_list,\n\t\t\t\tstruct btrfs_ioctl_space_info *space)\n{\n\tstruct btrfs_block_group_cache *block_group;\n\n\tspace->total_bytes = 0;\n\tspace->used_bytes = 0;\n\tspace->flags = 0;\n\tlist_for_each_entry(block_group, groups_list, list) {\n\t\tspace->flags = block_group->flags;\n\t\tspace->total_bytes += block_group->key.offset;\n\t\tspace->used_bytes +=\n\t\t\tbtrfs_block_group_used(&block_group->item);\n\t}\n}"
  },
  {
    "function_name": "btrfs_ioctl_default_subvol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "3756-3831",
    "snippet": "static long btrfs_ioctl_default_subvol(struct file *file, void __user *argp)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_root *new_root;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key location;\n\tstruct btrfs_disk_key disk_key;\n\tu64 objectid = 0;\n\tu64 dir_id;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_from_user(&objectid, argp, sizeof(objectid))) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (!objectid)\n\t\tobjectid = BTRFS_FS_TREE_OBJECTID;\n\n\tlocation.objectid = objectid;\n\tlocation.type = BTRFS_ROOT_ITEM_KEY;\n\tlocation.offset = (u64)-1;\n\n\tnew_root = btrfs_read_fs_root_no_name(root->fs_info, &location);\n\tif (IS_ERR(new_root)) {\n\t\tret = PTR_ERR(new_root);\n\t\tgoto out;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tpath->leave_spinning = 1;\n\n\ttrans = btrfs_start_transaction(root, 1);\n\tif (IS_ERR(trans)) {\n\t\tbtrfs_free_path(path);\n\t\tret = PTR_ERR(trans);\n\t\tgoto out;\n\t}\n\n\tdir_id = btrfs_super_root_dir(root->fs_info->super_copy);\n\tdi = btrfs_lookup_dir_item(trans, root->fs_info->tree_root, path,\n\t\t\t\t   dir_id, \"default\", 7, 1);\n\tif (IS_ERR_OR_NULL(di)) {\n\t\tbtrfs_free_path(path);\n\t\tbtrfs_end_transaction(trans, root);\n\t\tbtrfs_err(new_root->fs_info, \"Umm, you don't have the default dir\"\n\t\t\t   \"item, this isn't going to work\");\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tbtrfs_cpu_key_to_disk(&disk_key, &new_root->root_key);\n\tbtrfs_set_dir_item_key(path->nodes[0], di, &disk_key);\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\n\tbtrfs_free_path(path);\n\n\tbtrfs_set_fs_incompat(root->fs_info, DEFAULT_SUBVOL);\n\tbtrfs_end_transaction(trans, root);\nout:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "file"
          ],
          "line": 3829
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_end_transaction",
          "args": [
            "trans",
            "root"
          ],
          "line": 3827
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_end_transaction_throttle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "846-850",
          "snippet": "int btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_fs_incompat",
          "args": [
            "root->fs_info",
            "DEFAULT_SUBVOL"
          ],
          "line": 3826
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_set_fs_incompat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "4040-4059",
          "snippet": "static inline void __btrfs_set_fs_incompat(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t   u64 flag)\n{\n\tstruct btrfs_super_block *disk_super;\n\tu64 features;\n\n\tdisk_super = fs_info->super_copy;\n\tfeatures = btrfs_super_incompat_flags(disk_super);\n\tif (!(features & flag)) {\n\t\tspin_lock(&fs_info->super_lock);\n\t\tfeatures = btrfs_super_incompat_flags(disk_super);\n\t\tif (!(features & flag)) {\n\t\t\tfeatures |= flag;\n\t\t\tbtrfs_set_super_incompat_flags(disk_super, features);\n\t\t\tbtrfs_info(fs_info, \"setting %llu feature flag\",\n\t\t\t\t\t flag);\n\t\t}\n\t\tspin_unlock(&fs_info->super_lock);\n\t}\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void __btrfs_set_fs_incompat(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t   u64 flag)\n{\n\tstruct btrfs_super_block *disk_super;\n\tu64 features;\n\n\tdisk_super = fs_info->super_copy;\n\tfeatures = btrfs_super_incompat_flags(disk_super);\n\tif (!(features & flag)) {\n\t\tspin_lock(&fs_info->super_lock);\n\t\tfeatures = btrfs_super_incompat_flags(disk_super);\n\t\tif (!(features & flag)) {\n\t\t\tfeatures |= flag;\n\t\t\tbtrfs_set_super_incompat_flags(disk_super, features);\n\t\t\tbtrfs_info(fs_info, \"setting %llu feature flag\",\n\t\t\t\t\t flag);\n\t\t}\n\t\tspin_unlock(&fs_info->super_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 3824
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "path->nodes[0]"
          ],
          "line": 3823
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_dir_item_key",
          "args": [
            "path->nodes[0]",
            "di",
            "&disk_key"
          ],
          "line": 3822
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_dir_item_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2697-2702",
          "snippet": "static inline void btrfs_set_dir_item_key(struct extent_buffer *eb,\n\t\t\t\t\t  struct btrfs_dir_item *item,\n\t\t\t\t\t  struct btrfs_disk_key *key)\n{\n\twrite_eb_member(eb, item, struct btrfs_dir_item, location, key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_set_dir_item_key(struct extent_buffer *eb,\n\t\t\t\t\t  struct btrfs_dir_item *item,\n\t\t\t\t\t  struct btrfs_disk_key *key)\n{\n\twrite_eb_member(eb, item, struct btrfs_dir_item, location, key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_cpu_key_to_disk",
          "args": [
            "&disk_key",
            "&new_root->root_key"
          ],
          "line": 3821
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_cpu_key_to_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2739-2745",
          "snippet": "static inline void btrfs_cpu_key_to_disk(struct btrfs_disk_key *disk,\n\t\t\t\t\t struct btrfs_key *cpu)\n{\n\tdisk->offset = cpu_to_le64(cpu->offset);\n\tdisk->type = cpu->type;\n\tdisk->objectid = cpu_to_le64(cpu->objectid);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_cpu_key_to_disk(struct btrfs_disk_key *disk,\n\t\t\t\t\t struct btrfs_key *cpu)\n{\n\tdisk->offset = cpu_to_le64(cpu->offset);\n\tdisk->type = cpu->type;\n\tdisk->objectid = cpu_to_le64(cpu->objectid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "new_root->fs_info",
            "\"Umm, you don't have the default dir\"\n\t\t\t   \"item, this isn't going to work\""
          ],
          "line": 3815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR_OR_NULL",
          "args": [
            "di"
          ],
          "line": 3812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_dir_item",
          "args": [
            "trans",
            "root->fs_info->tree_root",
            "path",
            "dir_id",
            "\"default\"",
            "7",
            "1"
          ],
          "line": 3810
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_dir_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dir-item.c",
          "lines": "191-214",
          "snippet": "struct btrfs_dir_item *btrfs_lookup_dir_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t\t     struct btrfs_path *path, u64 dir,\n\t\t\t\t\t     const char *name, int name_len,\n\t\t\t\t\t     int mod)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_ITEM_KEY;\n\n\tkey.offset = btrfs_name_hash(name, name_len);\n\n\tret = btrfs_search_slot(trans, root, &key, path, ins_len, cow);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tif (ret > 0)\n\t\treturn NULL;\n\n\treturn btrfs_match_dir_item_name(root, path, name, name_len);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n\nstruct btrfs_dir_item *btrfs_lookup_dir_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t\t     struct btrfs_path *path, u64 dir,\n\t\t\t\t\t     const char *name, int name_len,\n\t\t\t\t\t     int mod)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_ITEM_KEY;\n\n\tkey.offset = btrfs_name_hash(name, name_len);\n\n\tret = btrfs_search_slot(trans, root, &key, path, ins_len, cow);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tif (ret > 0)\n\t\treturn NULL;\n\n\treturn btrfs_match_dir_item_name(root, path, name, name_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_super_root_dir",
          "args": [
            "root->fs_info->super_copy"
          ],
          "line": 3809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 3805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 3803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_start_transaction",
          "args": [
            "root",
            "1"
          ],
          "line": 3802
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_transaction_lflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "569-574",
          "snippet": "struct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 3795
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "new_root"
          ],
          "line": 3791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new_root"
          ],
          "line": 3790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_read_fs_root_no_name",
          "args": [
            "root->fs_info",
            "&location"
          ],
          "line": 3789
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_read_fs_root_no_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.h",
          "lines": "76-81",
          "snippet": "static inline struct btrfs_root *\nbtrfs_read_fs_root_no_name(struct btrfs_fs_info *fs_info,\n\t\t\t   struct btrfs_key *location)\n{\n\treturn btrfs_get_fs_root(fs_info, location, true);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct btrfs_root *\nbtrfs_read_fs_root_no_name(struct btrfs_fs_info *fs_info,\n\t\t\t   struct btrfs_key *location)\n{\n\treturn btrfs_get_fs_root(fs_info, location, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&objectid",
            "argp",
            "sizeof(objectid)"
          ],
          "line": 3777
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "file"
          ],
          "line": 3773
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 3770
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 3759
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 3758
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_default_subvol(struct file *file, void __user *argp)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_root *new_root;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key location;\n\tstruct btrfs_disk_key disk_key;\n\tu64 objectid = 0;\n\tu64 dir_id;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tif (copy_from_user(&objectid, argp, sizeof(objectid))) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (!objectid)\n\t\tobjectid = BTRFS_FS_TREE_OBJECTID;\n\n\tlocation.objectid = objectid;\n\tlocation.type = BTRFS_ROOT_ITEM_KEY;\n\tlocation.offset = (u64)-1;\n\n\tnew_root = btrfs_read_fs_root_no_name(root->fs_info, &location);\n\tif (IS_ERR(new_root)) {\n\t\tret = PTR_ERR(new_root);\n\t\tgoto out;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tpath->leave_spinning = 1;\n\n\ttrans = btrfs_start_transaction(root, 1);\n\tif (IS_ERR(trans)) {\n\t\tbtrfs_free_path(path);\n\t\tret = PTR_ERR(trans);\n\t\tgoto out;\n\t}\n\n\tdir_id = btrfs_super_root_dir(root->fs_info->super_copy);\n\tdi = btrfs_lookup_dir_item(trans, root->fs_info->tree_root, path,\n\t\t\t\t   dir_id, \"default\", 7, 1);\n\tif (IS_ERR_OR_NULL(di)) {\n\t\tbtrfs_free_path(path);\n\t\tbtrfs_end_transaction(trans, root);\n\t\tbtrfs_err(new_root->fs_info, \"Umm, you don't have the default dir\"\n\t\t\t   \"item, this isn't going to work\");\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tbtrfs_cpu_key_to_disk(&disk_key, &new_root->root_key);\n\tbtrfs_set_dir_item_key(path->nodes[0], di, &disk_key);\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\n\tbtrfs_free_path(path);\n\n\tbtrfs_set_fs_incompat(root->fs_info, DEFAULT_SUBVOL);\n\tbtrfs_end_transaction(trans, root);\nout:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_ioctl_trans_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "3716-3754",
    "snippet": "static long btrfs_ioctl_trans_start(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\n\tret = -EPERM;\n\tif (!capable(CAP_SYS_ADMIN))\n\t\tgoto out;\n\n\tret = -EINPROGRESS;\n\tif (file->private_data)\n\t\tgoto out;\n\n\tret = -EROFS;\n\tif (btrfs_root_readonly(root))\n\t\tgoto out;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\tgoto out;\n\n\tatomic_inc(&root->fs_info->open_ioctl_trans);\n\n\tret = -ENOMEM;\n\ttrans = btrfs_start_ioctl_transaction(root);\n\tif (IS_ERR(trans))\n\t\tgoto out_drop;\n\n\tfile->private_data = trans;\n\treturn 0;\n\nout_drop:\n\tatomic_dec(&root->fs_info->open_ioctl_trans);\n\tmnt_drop_write_file(file);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "file"
          ],
          "line": 3751
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&root->fs_info->open_ioctl_trans"
          ],
          "line": 3750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 3743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_start_ioctl_transaction",
          "args": [
            "root"
          ],
          "line": 3742
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_ioctl_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "586-589",
          "snippet": "struct btrfs_trans_handle *btrfs_start_ioctl_transaction(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_USERSPACE, 0);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_start_ioctl_transaction(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_USERSPACE, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&root->fs_info->open_ioctl_trans"
          ],
          "line": 3739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "file"
          ],
          "line": 3735
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_root_readonly",
          "args": [
            "root"
          ],
          "line": 3732
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_root_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2876-2879",
          "snippet": "static inline bool btrfs_root_readonly(struct btrfs_root *root)\n{\n\treturn (root->root_item.flags & cpu_to_le64(BTRFS_ROOT_SUBVOL_RDONLY)) != 0;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_ROOT_SUBVOL_RDONLY\t(1ULL << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_ROOT_SUBVOL_RDONLY\t(1ULL << 0)\n\nstatic inline bool btrfs_root_readonly(struct btrfs_root *root)\n{\n\treturn (root->root_item.flags & cpu_to_le64(BTRFS_ROOT_SUBVOL_RDONLY)) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 3724
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 3719
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 3718
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_trans_start(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\n\tret = -EPERM;\n\tif (!capable(CAP_SYS_ADMIN))\n\t\tgoto out;\n\n\tret = -EINPROGRESS;\n\tif (file->private_data)\n\t\tgoto out;\n\n\tret = -EROFS;\n\tif (btrfs_root_readonly(root))\n\t\tgoto out;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\tgoto out;\n\n\tatomic_inc(&root->fs_info->open_ioctl_trans);\n\n\tret = -ENOMEM;\n\ttrans = btrfs_start_ioctl_transaction(root);\n\tif (IS_ERR(trans))\n\t\tgoto out_drop;\n\n\tfile->private_data = trans;\n\treturn 0;\n\nout_drop:\n\tatomic_dec(&root->fs_info->open_ioctl_trans);\n\tmnt_drop_write_file(file);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_ioctl_clone_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "3700-3708",
    "snippet": "static long btrfs_ioctl_clone_range(struct file *file, void __user *argp)\n{\n\tstruct btrfs_ioctl_clone_range_args args;\n\n\tif (copy_from_user(&args, argp, sizeof(args)))\n\t\treturn -EFAULT;\n\treturn btrfs_ioctl_clone(file, args.src_fd, args.src_offset,\n\t\t\t\t args.src_length, args.dest_offset);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_ioctl_clone",
          "args": [
            "file",
            "args.src_fd",
            "args.src_offset",
            "args.src_length",
            "args.dest_offset"
          ],
          "line": 3706
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_clone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "3540-3698",
          "snippet": "static noinline long btrfs_ioctl_clone(struct file *file, unsigned long srcfd,\n\t\t\t\t       u64 off, u64 olen, u64 destoff)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct fd src_file;\n\tstruct inode *src;\n\tint ret;\n\tu64 len = olen;\n\tu64 bs = root->fs_info->sb->s_blocksize;\n\tint same_inode = 0;\n\n\t/*\n\t * TODO:\n\t * - split compressed inline extents.  annoying: we need to\n\t *   decompress into destination's address_space (the file offset\n\t *   may change, so source mapping won't do), then recompress (or\n\t *   otherwise reinsert) a subrange.\n\t *\n\t * - split destination inode's inline extents.  The inline extents can\n\t *   be either compressed or non-compressed.\n\t */\n\n\t/* the destination must be opened for writing */\n\tif (!(file->f_mode & FMODE_WRITE) || (file->f_flags & O_APPEND))\n\t\treturn -EINVAL;\n\n\tif (btrfs_root_readonly(root))\n\t\treturn -EROFS;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tsrc_file = fdget(srcfd);\n\tif (!src_file.file) {\n\t\tret = -EBADF;\n\t\tgoto out_drop_write;\n\t}\n\n\tret = -EXDEV;\n\tif (src_file.file->f_path.mnt != file->f_path.mnt)\n\t\tgoto out_fput;\n\n\tsrc = file_inode(src_file.file);\n\n\tret = -EINVAL;\n\tif (src == inode)\n\t\tsame_inode = 1;\n\n\t/* the src must be open for reading */\n\tif (!(src_file.file->f_mode & FMODE_READ))\n\t\tgoto out_fput;\n\n\t/* don't make the dst file partly checksummed */\n\tif ((BTRFS_I(src)->flags & BTRFS_INODE_NODATASUM) !=\n\t    (BTRFS_I(inode)->flags & BTRFS_INODE_NODATASUM))\n\t\tgoto out_fput;\n\n\tret = -EISDIR;\n\tif (S_ISDIR(src->i_mode) || S_ISDIR(inode->i_mode))\n\t\tgoto out_fput;\n\n\tret = -EXDEV;\n\tif (src->i_sb != inode->i_sb)\n\t\tgoto out_fput;\n\n\tif (!same_inode) {\n\t\tif (inode < src) {\n\t\t\tmutex_lock_nested(&inode->i_mutex, I_MUTEX_PARENT);\n\t\t\tmutex_lock_nested(&src->i_mutex, I_MUTEX_CHILD);\n\t\t} else {\n\t\t\tmutex_lock_nested(&src->i_mutex, I_MUTEX_PARENT);\n\t\t\tmutex_lock_nested(&inode->i_mutex, I_MUTEX_CHILD);\n\t\t}\n\t} else {\n\t\tmutex_lock(&src->i_mutex);\n\t}\n\n\t/* determine range to clone */\n\tret = -EINVAL;\n\tif (off + len > src->i_size || off + len < off)\n\t\tgoto out_unlock;\n\tif (len == 0)\n\t\tolen = len = src->i_size - off;\n\t/* if we extend to eof, continue to block boundary */\n\tif (off + len == src->i_size)\n\t\tlen = ALIGN(src->i_size, bs) - off;\n\n\t/* verify the end result is block aligned */\n\tif (!IS_ALIGNED(off, bs) || !IS_ALIGNED(off + len, bs) ||\n\t    !IS_ALIGNED(destoff, bs))\n\t\tgoto out_unlock;\n\n\t/* verify if ranges are overlapped within the same file */\n\tif (same_inode) {\n\t\tif (destoff + len > off && destoff < off + len)\n\t\t\tgoto out_unlock;\n\t}\n\n\tif (destoff > inode->i_size) {\n\t\tret = btrfs_cont_expand(inode, inode->i_size, destoff);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Lock the target range too. Right after we replace the file extent\n\t * items in the fs tree (which now point to the cloned data), we might\n\t * have a worker replace them with extent items relative to a write\n\t * operation that was issued before this clone operation (i.e. confront\n\t * with inode.c:btrfs_finish_ordered_io).\n\t */\n\tif (same_inode) {\n\t\tu64 lock_start = min_t(u64, off, destoff);\n\t\tu64 lock_len = max_t(u64, off, destoff) + len - lock_start;\n\n\t\tlock_extent_range(src, lock_start, lock_len);\n\t} else {\n\t\tlock_extent_range(src, off, len);\n\t\tlock_extent_range(inode, destoff, len);\n\t}\n\n\tret = btrfs_clone(src, inode, off, olen, len, destoff);\n\n\tif (same_inode) {\n\t\tu64 lock_start = min_t(u64, off, destoff);\n\t\tu64 lock_end = max_t(u64, off, destoff) + len - 1;\n\n\t\tunlock_extent(&BTRFS_I(src)->io_tree, lock_start, lock_end);\n\t} else {\n\t\tunlock_extent(&BTRFS_I(src)->io_tree, off, off + len - 1);\n\t\tunlock_extent(&BTRFS_I(inode)->io_tree, destoff,\n\t\t\t      destoff + len - 1);\n\t}\n\t/*\n\t * Truncate page cache pages so that future reads will see the cloned\n\t * data immediately and not the previous data.\n\t */\n\ttruncate_inode_pages_range(&inode->i_data, destoff,\n\t\t\t\t   PAGE_CACHE_ALIGN(destoff + len) - 1);\nout_unlock:\n\tif (!same_inode) {\n\t\tif (inode < src) {\n\t\t\tmutex_unlock(&src->i_mutex);\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t} else {\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\tmutex_unlock(&src->i_mutex);\n\t\t}\n\t} else {\n\t\tmutex_unlock(&src->i_mutex);\n\t}\nout_fput:\n\tfdput(src_file);\nout_drop_write:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_clone(struct inode *src, struct inode *inode,\n\t\t       u64 off, u64 olen, u64 olen_aligned, u64 destoff);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_clone(struct inode *src, struct inode *inode,\n\t\t       u64 off, u64 olen, u64 olen_aligned, u64 destoff);\n\nstatic noinline long btrfs_ioctl_clone(struct file *file, unsigned long srcfd,\n\t\t\t\t       u64 off, u64 olen, u64 destoff)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct fd src_file;\n\tstruct inode *src;\n\tint ret;\n\tu64 len = olen;\n\tu64 bs = root->fs_info->sb->s_blocksize;\n\tint same_inode = 0;\n\n\t/*\n\t * TODO:\n\t * - split compressed inline extents.  annoying: we need to\n\t *   decompress into destination's address_space (the file offset\n\t *   may change, so source mapping won't do), then recompress (or\n\t *   otherwise reinsert) a subrange.\n\t *\n\t * - split destination inode's inline extents.  The inline extents can\n\t *   be either compressed or non-compressed.\n\t */\n\n\t/* the destination must be opened for writing */\n\tif (!(file->f_mode & FMODE_WRITE) || (file->f_flags & O_APPEND))\n\t\treturn -EINVAL;\n\n\tif (btrfs_root_readonly(root))\n\t\treturn -EROFS;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tsrc_file = fdget(srcfd);\n\tif (!src_file.file) {\n\t\tret = -EBADF;\n\t\tgoto out_drop_write;\n\t}\n\n\tret = -EXDEV;\n\tif (src_file.file->f_path.mnt != file->f_path.mnt)\n\t\tgoto out_fput;\n\n\tsrc = file_inode(src_file.file);\n\n\tret = -EINVAL;\n\tif (src == inode)\n\t\tsame_inode = 1;\n\n\t/* the src must be open for reading */\n\tif (!(src_file.file->f_mode & FMODE_READ))\n\t\tgoto out_fput;\n\n\t/* don't make the dst file partly checksummed */\n\tif ((BTRFS_I(src)->flags & BTRFS_INODE_NODATASUM) !=\n\t    (BTRFS_I(inode)->flags & BTRFS_INODE_NODATASUM))\n\t\tgoto out_fput;\n\n\tret = -EISDIR;\n\tif (S_ISDIR(src->i_mode) || S_ISDIR(inode->i_mode))\n\t\tgoto out_fput;\n\n\tret = -EXDEV;\n\tif (src->i_sb != inode->i_sb)\n\t\tgoto out_fput;\n\n\tif (!same_inode) {\n\t\tif (inode < src) {\n\t\t\tmutex_lock_nested(&inode->i_mutex, I_MUTEX_PARENT);\n\t\t\tmutex_lock_nested(&src->i_mutex, I_MUTEX_CHILD);\n\t\t} else {\n\t\t\tmutex_lock_nested(&src->i_mutex, I_MUTEX_PARENT);\n\t\t\tmutex_lock_nested(&inode->i_mutex, I_MUTEX_CHILD);\n\t\t}\n\t} else {\n\t\tmutex_lock(&src->i_mutex);\n\t}\n\n\t/* determine range to clone */\n\tret = -EINVAL;\n\tif (off + len > src->i_size || off + len < off)\n\t\tgoto out_unlock;\n\tif (len == 0)\n\t\tolen = len = src->i_size - off;\n\t/* if we extend to eof, continue to block boundary */\n\tif (off + len == src->i_size)\n\t\tlen = ALIGN(src->i_size, bs) - off;\n\n\t/* verify the end result is block aligned */\n\tif (!IS_ALIGNED(off, bs) || !IS_ALIGNED(off + len, bs) ||\n\t    !IS_ALIGNED(destoff, bs))\n\t\tgoto out_unlock;\n\n\t/* verify if ranges are overlapped within the same file */\n\tif (same_inode) {\n\t\tif (destoff + len > off && destoff < off + len)\n\t\t\tgoto out_unlock;\n\t}\n\n\tif (destoff > inode->i_size) {\n\t\tret = btrfs_cont_expand(inode, inode->i_size, destoff);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Lock the target range too. Right after we replace the file extent\n\t * items in the fs tree (which now point to the cloned data), we might\n\t * have a worker replace them with extent items relative to a write\n\t * operation that was issued before this clone operation (i.e. confront\n\t * with inode.c:btrfs_finish_ordered_io).\n\t */\n\tif (same_inode) {\n\t\tu64 lock_start = min_t(u64, off, destoff);\n\t\tu64 lock_len = max_t(u64, off, destoff) + len - lock_start;\n\n\t\tlock_extent_range(src, lock_start, lock_len);\n\t} else {\n\t\tlock_extent_range(src, off, len);\n\t\tlock_extent_range(inode, destoff, len);\n\t}\n\n\tret = btrfs_clone(src, inode, off, olen, len, destoff);\n\n\tif (same_inode) {\n\t\tu64 lock_start = min_t(u64, off, destoff);\n\t\tu64 lock_end = max_t(u64, off, destoff) + len - 1;\n\n\t\tunlock_extent(&BTRFS_I(src)->io_tree, lock_start, lock_end);\n\t} else {\n\t\tunlock_extent(&BTRFS_I(src)->io_tree, off, off + len - 1);\n\t\tunlock_extent(&BTRFS_I(inode)->io_tree, destoff,\n\t\t\t      destoff + len - 1);\n\t}\n\t/*\n\t * Truncate page cache pages so that future reads will see the cloned\n\t * data immediately and not the previous data.\n\t */\n\ttruncate_inode_pages_range(&inode->i_data, destoff,\n\t\t\t\t   PAGE_CACHE_ALIGN(destoff + len) - 1);\nout_unlock:\n\tif (!same_inode) {\n\t\tif (inode < src) {\n\t\t\tmutex_unlock(&src->i_mutex);\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t} else {\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\tmutex_unlock(&src->i_mutex);\n\t\t}\n\t} else {\n\t\tmutex_unlock(&src->i_mutex);\n\t}\nout_fput:\n\tfdput(src_file);\nout_drop_write:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&args",
            "argp",
            "sizeof(args)"
          ],
          "line": 3704
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_clone_range(struct file *file, void __user *argp)\n{\n\tstruct btrfs_ioctl_clone_range_args args;\n\n\tif (copy_from_user(&args, argp, sizeof(args)))\n\t\treturn -EFAULT;\n\treturn btrfs_ioctl_clone(file, args.src_fd, args.src_offset,\n\t\t\t\t args.src_length, args.dest_offset);\n}"
  },
  {
    "function_name": "btrfs_ioctl_clone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "3540-3698",
    "snippet": "static noinline long btrfs_ioctl_clone(struct file *file, unsigned long srcfd,\n\t\t\t\t       u64 off, u64 olen, u64 destoff)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct fd src_file;\n\tstruct inode *src;\n\tint ret;\n\tu64 len = olen;\n\tu64 bs = root->fs_info->sb->s_blocksize;\n\tint same_inode = 0;\n\n\t/*\n\t * TODO:\n\t * - split compressed inline extents.  annoying: we need to\n\t *   decompress into destination's address_space (the file offset\n\t *   may change, so source mapping won't do), then recompress (or\n\t *   otherwise reinsert) a subrange.\n\t *\n\t * - split destination inode's inline extents.  The inline extents can\n\t *   be either compressed or non-compressed.\n\t */\n\n\t/* the destination must be opened for writing */\n\tif (!(file->f_mode & FMODE_WRITE) || (file->f_flags & O_APPEND))\n\t\treturn -EINVAL;\n\n\tif (btrfs_root_readonly(root))\n\t\treturn -EROFS;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tsrc_file = fdget(srcfd);\n\tif (!src_file.file) {\n\t\tret = -EBADF;\n\t\tgoto out_drop_write;\n\t}\n\n\tret = -EXDEV;\n\tif (src_file.file->f_path.mnt != file->f_path.mnt)\n\t\tgoto out_fput;\n\n\tsrc = file_inode(src_file.file);\n\n\tret = -EINVAL;\n\tif (src == inode)\n\t\tsame_inode = 1;\n\n\t/* the src must be open for reading */\n\tif (!(src_file.file->f_mode & FMODE_READ))\n\t\tgoto out_fput;\n\n\t/* don't make the dst file partly checksummed */\n\tif ((BTRFS_I(src)->flags & BTRFS_INODE_NODATASUM) !=\n\t    (BTRFS_I(inode)->flags & BTRFS_INODE_NODATASUM))\n\t\tgoto out_fput;\n\n\tret = -EISDIR;\n\tif (S_ISDIR(src->i_mode) || S_ISDIR(inode->i_mode))\n\t\tgoto out_fput;\n\n\tret = -EXDEV;\n\tif (src->i_sb != inode->i_sb)\n\t\tgoto out_fput;\n\n\tif (!same_inode) {\n\t\tif (inode < src) {\n\t\t\tmutex_lock_nested(&inode->i_mutex, I_MUTEX_PARENT);\n\t\t\tmutex_lock_nested(&src->i_mutex, I_MUTEX_CHILD);\n\t\t} else {\n\t\t\tmutex_lock_nested(&src->i_mutex, I_MUTEX_PARENT);\n\t\t\tmutex_lock_nested(&inode->i_mutex, I_MUTEX_CHILD);\n\t\t}\n\t} else {\n\t\tmutex_lock(&src->i_mutex);\n\t}\n\n\t/* determine range to clone */\n\tret = -EINVAL;\n\tif (off + len > src->i_size || off + len < off)\n\t\tgoto out_unlock;\n\tif (len == 0)\n\t\tolen = len = src->i_size - off;\n\t/* if we extend to eof, continue to block boundary */\n\tif (off + len == src->i_size)\n\t\tlen = ALIGN(src->i_size, bs) - off;\n\n\t/* verify the end result is block aligned */\n\tif (!IS_ALIGNED(off, bs) || !IS_ALIGNED(off + len, bs) ||\n\t    !IS_ALIGNED(destoff, bs))\n\t\tgoto out_unlock;\n\n\t/* verify if ranges are overlapped within the same file */\n\tif (same_inode) {\n\t\tif (destoff + len > off && destoff < off + len)\n\t\t\tgoto out_unlock;\n\t}\n\n\tif (destoff > inode->i_size) {\n\t\tret = btrfs_cont_expand(inode, inode->i_size, destoff);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Lock the target range too. Right after we replace the file extent\n\t * items in the fs tree (which now point to the cloned data), we might\n\t * have a worker replace them with extent items relative to a write\n\t * operation that was issued before this clone operation (i.e. confront\n\t * with inode.c:btrfs_finish_ordered_io).\n\t */\n\tif (same_inode) {\n\t\tu64 lock_start = min_t(u64, off, destoff);\n\t\tu64 lock_len = max_t(u64, off, destoff) + len - lock_start;\n\n\t\tlock_extent_range(src, lock_start, lock_len);\n\t} else {\n\t\tlock_extent_range(src, off, len);\n\t\tlock_extent_range(inode, destoff, len);\n\t}\n\n\tret = btrfs_clone(src, inode, off, olen, len, destoff);\n\n\tif (same_inode) {\n\t\tu64 lock_start = min_t(u64, off, destoff);\n\t\tu64 lock_end = max_t(u64, off, destoff) + len - 1;\n\n\t\tunlock_extent(&BTRFS_I(src)->io_tree, lock_start, lock_end);\n\t} else {\n\t\tunlock_extent(&BTRFS_I(src)->io_tree, off, off + len - 1);\n\t\tunlock_extent(&BTRFS_I(inode)->io_tree, destoff,\n\t\t\t      destoff + len - 1);\n\t}\n\t/*\n\t * Truncate page cache pages so that future reads will see the cloned\n\t * data immediately and not the previous data.\n\t */\n\ttruncate_inode_pages_range(&inode->i_data, destoff,\n\t\t\t\t   PAGE_CACHE_ALIGN(destoff + len) - 1);\nout_unlock:\n\tif (!same_inode) {\n\t\tif (inode < src) {\n\t\t\tmutex_unlock(&src->i_mutex);\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t} else {\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\tmutex_unlock(&src->i_mutex);\n\t\t}\n\t} else {\n\t\tmutex_unlock(&src->i_mutex);\n\t}\nout_fput:\n\tfdput(src_file);\nout_drop_write:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btrfs_clone(struct inode *src, struct inode *inode,\n\t\t       u64 off, u64 olen, u64 olen_aligned, u64 destoff);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "file"
          ],
          "line": 3696
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "src_file"
          ],
          "line": 3694
        },
        "resolved": true,
        "details": {
          "function_name": "fdput_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "273-278",
          "snippet": "static inline void fdput_pos(struct fd f)\n{\n\tif (f.flags & FDPUT_POS_UNLOCK)\n\t\tmutex_unlock(&f.file->f_pos_lock);\n\tfdput(f);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic inline void fdput_pos(struct fd f)\n{\n\tif (f.flags & FDPUT_POS_UNLOCK)\n\t\tmutex_unlock(&f.file->f_pos_lock);\n\tfdput(f);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&src->i_mutex"
          ],
          "line": 3691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&src->i_mutex"
          ],
          "line": 3688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 3687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 3685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&src->i_mutex"
          ],
          "line": 3684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages_range",
          "args": [
            "&inode->i_data",
            "destoff",
            "PAGE_CACHE_ALIGN(destoff + len) - 1"
          ],
          "line": 3679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_CACHE_ALIGN",
          "args": [
            "destoff + len"
          ],
          "line": 3680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_extent",
          "args": [
            "&BTRFS_I(inode)->io_tree",
            "destoff",
            "destoff + len - 1"
          ],
          "line": 3672
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1380-1384",
          "snippet": "int unlock_extent(struct extent_io_tree *tree, u64 start, u64 end)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, NULL,\n\t\t\t\tGFP_NOFS);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint unlock_extent(struct extent_io_tree *tree, u64 start, u64 end)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, NULL,\n\t\t\t\tGFP_NOFS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 3672
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "u64",
            "off",
            "destoff"
          ],
          "line": 3667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u64",
            "off",
            "destoff"
          ],
          "line": 3666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_clone",
          "args": [
            "src",
            "inode",
            "off",
            "olen",
            "len",
            "destoff"
          ],
          "line": 3663
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_clone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "3169-3538",
          "snippet": "static int btrfs_clone(struct inode *src, struct inode *inode,\n\t\t       const u64 off, const u64 olen, const u64 olen_aligned,\n\t\t       const u64 destoff)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_path *path = NULL;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_trans_handle *trans;\n\tchar *buf = NULL;\n\tstruct btrfs_key key;\n\tu32 nritems;\n\tint slot;\n\tint ret;\n\tint no_quota;\n\tconst u64 len = olen_aligned;\n\tu64 last_disko = 0;\n\tu64 last_dest_end = destoff;\n\n\tret = -ENOMEM;\n\tbuf = vmalloc(root->nodesize);\n\tif (!buf)\n\t\treturn ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tvfree(buf);\n\t\treturn ret;\n\t}\n\n\tpath->reada = 2;\n\t/* clone data */\n\tkey.objectid = btrfs_ino(src);\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = off;\n\n\twhile (1) {\n\t\t/*\n\t\t * note the key will change type as we walk through the\n\t\t * tree.\n\t\t */\n\t\tpath->leave_spinning = 1;\n\t\tret = btrfs_search_slot(NULL, BTRFS_I(src)->root, &key, path,\n\t\t\t\t0, 0);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\t/*\n\t\t * First search, if no extent item that starts at offset off was\n\t\t * found but the previous item is an extent item, it's possible\n\t\t * it might overlap our target range, therefore process it.\n\t\t */\n\t\tif (key.offset == off && ret > 0 && path->slots[0] > 0) {\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key,\n\t\t\t\t\t      path->slots[0] - 1);\n\t\t\tif (key.type == BTRFS_EXTENT_DATA_KEY)\n\t\t\t\tpath->slots[0]--;\n\t\t}\n\n\t\tnritems = btrfs_header_nritems(path->nodes[0]);\nprocess_slot:\n\t\tno_quota = 1;\n\t\tif (path->slots[0] >= nritems) {\n\t\t\tret = btrfs_next_leaf(BTRFS_I(src)->root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret > 0)\n\t\t\t\tbreak;\n\t\t\tnritems = btrfs_header_nritems(path->nodes[0]);\n\t\t}\n\t\tleaf = path->nodes[0];\n\t\tslot = path->slots[0];\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\t\tif (key.type > BTRFS_EXTENT_DATA_KEY ||\n\t\t    key.objectid != btrfs_ino(src))\n\t\t\tbreak;\n\n\t\tif (key.type == BTRFS_EXTENT_DATA_KEY) {\n\t\t\tstruct btrfs_file_extent_item *extent;\n\t\t\tint type;\n\t\t\tu32 size;\n\t\t\tstruct btrfs_key new_key;\n\t\t\tu64 disko = 0, diskl = 0;\n\t\t\tu64 datao = 0, datal = 0;\n\t\t\tu8 comp;\n\t\t\tu64 drop_start;\n\n\t\t\textent = btrfs_item_ptr(leaf, slot,\n\t\t\t\t\t\tstruct btrfs_file_extent_item);\n\t\t\tcomp = btrfs_file_extent_compression(leaf, extent);\n\t\t\ttype = btrfs_file_extent_type(leaf, extent);\n\t\t\tif (type == BTRFS_FILE_EXTENT_REG ||\n\t\t\t    type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\t\t\tdisko = btrfs_file_extent_disk_bytenr(leaf,\n\t\t\t\t\t\t\t\t      extent);\n\t\t\t\tdiskl = btrfs_file_extent_disk_num_bytes(leaf,\n\t\t\t\t\t\t\t\t extent);\n\t\t\t\tdatao = btrfs_file_extent_offset(leaf, extent);\n\t\t\t\tdatal = btrfs_file_extent_num_bytes(leaf,\n\t\t\t\t\t\t\t\t    extent);\n\t\t\t} else if (type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\t/* take upper bound, may be compressed */\n\t\t\t\tdatal = btrfs_file_extent_ram_bytes(leaf,\n\t\t\t\t\t\t\t\t    extent);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The first search might have left us at an extent\n\t\t\t * item that ends before our target range's start, can\n\t\t\t * happen if we have holes and NO_HOLES feature enabled.\n\t\t\t */\n\t\t\tif (key.offset + datal <= off) {\n\t\t\t\tpath->slots[0]++;\n\t\t\t\tgoto process_slot;\n\t\t\t} else if (key.offset >= off + len) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tsize = btrfs_item_size_nr(leaf, slot);\n\t\t\tread_extent_buffer(leaf, buf,\n\t\t\t\t\t   btrfs_item_ptr_offset(leaf, slot),\n\t\t\t\t\t   size);\n\n\t\t\tbtrfs_release_path(path);\n\t\t\tpath->leave_spinning = 0;\n\n\t\t\tmemcpy(&new_key, &key, sizeof(new_key));\n\t\t\tnew_key.objectid = btrfs_ino(inode);\n\t\t\tif (off <= key.offset)\n\t\t\t\tnew_key.offset = key.offset + destoff - off;\n\t\t\telse\n\t\t\t\tnew_key.offset = destoff;\n\n\t\t\t/*\n\t\t\t * Deal with a hole that doesn't have an extent item\n\t\t\t * that represents it (NO_HOLES feature enabled).\n\t\t\t * This hole is either in the middle of the cloning\n\t\t\t * range or at the beginning (fully overlaps it or\n\t\t\t * partially overlaps it).\n\t\t\t */\n\t\t\tif (new_key.offset != last_dest_end)\n\t\t\t\tdrop_start = last_dest_end;\n\t\t\telse\n\t\t\t\tdrop_start = new_key.offset;\n\n\t\t\t/*\n\t\t\t * 1 - adjusting old extent (we may have to split it)\n\t\t\t * 1 - add new extent\n\t\t\t * 1 - inode update\n\t\t\t */\n\t\t\ttrans = btrfs_start_transaction(root, 3);\n\t\t\tif (IS_ERR(trans)) {\n\t\t\t\tret = PTR_ERR(trans);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (type == BTRFS_FILE_EXTENT_REG ||\n\t\t\t    type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\t\t\t/*\n\t\t\t\t *    a  | --- range to clone ---|  b\n\t\t\t\t * | ------------- extent ------------- |\n\t\t\t\t */\n\n\t\t\t\t/* subtract range b */\n\t\t\t\tif (key.offset + datal > off + len)\n\t\t\t\t\tdatal = off + len - key.offset;\n\n\t\t\t\t/* subtract range a */\n\t\t\t\tif (off > key.offset) {\n\t\t\t\t\tdatao += off - key.offset;\n\t\t\t\t\tdatal -= off - key.offset;\n\t\t\t\t}\n\n\t\t\t\tret = btrfs_drop_extents(trans, root, inode,\n\t\t\t\t\t\t\t drop_start,\n\t\t\t\t\t\t\t new_key.offset + datal,\n\t\t\t\t\t\t\t 1);\n\t\t\t\tif (ret) {\n\t\t\t\t\tif (ret != -EOPNOTSUPP)\n\t\t\t\t\t\tbtrfs_abort_transaction(trans,\n\t\t\t\t\t\t\t\troot, ret);\n\t\t\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tret = btrfs_insert_empty_item(trans, root, path,\n\t\t\t\t\t\t\t      &new_key, size);\n\t\t\t\tif (ret) {\n\t\t\t\t\tbtrfs_abort_transaction(trans, root,\n\t\t\t\t\t\t\t\tret);\n\t\t\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tleaf = path->nodes[0];\n\t\t\t\tslot = path->slots[0];\n\t\t\t\twrite_extent_buffer(leaf, buf,\n\t\t\t\t\t    btrfs_item_ptr_offset(leaf, slot),\n\t\t\t\t\t    size);\n\n\t\t\t\textent = btrfs_item_ptr(leaf, slot,\n\t\t\t\t\t\tstruct btrfs_file_extent_item);\n\n\t\t\t\t/* disko == 0 means it's a hole */\n\t\t\t\tif (!disko)\n\t\t\t\t\tdatao = 0;\n\n\t\t\t\tbtrfs_set_file_extent_offset(leaf, extent,\n\t\t\t\t\t\t\t     datao);\n\t\t\t\tbtrfs_set_file_extent_num_bytes(leaf, extent,\n\t\t\t\t\t\t\t\tdatal);\n\n\t\t\t\t/*\n\t\t\t\t * We need to look up the roots that point at\n\t\t\t\t * this bytenr and see if the new root does.  If\n\t\t\t\t * it does not we need to make sure we update\n\t\t\t\t * quotas appropriately.\n\t\t\t\t */\n\t\t\t\tif (disko && root != BTRFS_I(src)->root &&\n\t\t\t\t    disko != last_disko) {\n\t\t\t\t\tno_quota = check_ref(trans, root,\n\t\t\t\t\t\t\t     disko);\n\t\t\t\t\tif (no_quota < 0) {\n\t\t\t\t\t\tbtrfs_abort_transaction(trans,\n\t\t\t\t\t\t\t\t\troot,\n\t\t\t\t\t\t\t\t\tret);\n\t\t\t\t\t\tbtrfs_end_transaction(trans,\n\t\t\t\t\t\t\t\t      root);\n\t\t\t\t\t\tret = no_quota;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (disko) {\n\t\t\t\t\tinode_add_bytes(inode, datal);\n\t\t\t\t\tret = btrfs_inc_extent_ref(trans, root,\n\t\t\t\t\t\t\tdisko, diskl, 0,\n\t\t\t\t\t\t\troot->root_key.objectid,\n\t\t\t\t\t\t\tbtrfs_ino(inode),\n\t\t\t\t\t\t\tnew_key.offset - datao,\n\t\t\t\t\t\t\tno_quota);\n\t\t\t\t\tif (ret) {\n\t\t\t\t\t\tbtrfs_abort_transaction(trans,\n\t\t\t\t\t\t\t\t\troot,\n\t\t\t\t\t\t\t\t\tret);\n\t\t\t\t\t\tbtrfs_end_transaction(trans,\n\t\t\t\t\t\t\t\t      root);\n\t\t\t\t\t\tgoto out;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tu64 skip = 0;\n\t\t\t\tu64 trim = 0;\n\t\t\t\tu64 aligned_end = 0;\n\n\t\t\t\tif (off > key.offset) {\n\t\t\t\t\tskip = off - key.offset;\n\t\t\t\t\tnew_key.offset += skip;\n\t\t\t\t}\n\n\t\t\t\tif (key.offset + datal > off + len)\n\t\t\t\t\ttrim = key.offset + datal - (off + len);\n\n\t\t\t\tif (comp && (skip || trim)) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tsize -= skip + trim;\n\t\t\t\tdatal -= skip + trim;\n\n\t\t\t\taligned_end = ALIGN(new_key.offset + datal,\n\t\t\t\t\t\t    root->sectorsize);\n\t\t\t\tret = btrfs_drop_extents(trans, root, inode,\n\t\t\t\t\t\t\t drop_start,\n\t\t\t\t\t\t\t aligned_end,\n\t\t\t\t\t\t\t 1);\n\t\t\t\tif (ret) {\n\t\t\t\t\tif (ret != -EOPNOTSUPP)\n\t\t\t\t\t\tbtrfs_abort_transaction(trans,\n\t\t\t\t\t\t\troot, ret);\n\t\t\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tret = btrfs_insert_empty_item(trans, root, path,\n\t\t\t\t\t\t\t      &new_key, size);\n\t\t\t\tif (ret) {\n\t\t\t\t\tbtrfs_abort_transaction(trans, root,\n\t\t\t\t\t\t\t\tret);\n\t\t\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tif (skip) {\n\t\t\t\t\tu32 start =\n\t\t\t\t\t  btrfs_file_extent_calc_inline_size(0);\n\t\t\t\t\tmemmove(buf+start, buf+start+skip,\n\t\t\t\t\t\tdatal);\n\t\t\t\t}\n\n\t\t\t\tleaf = path->nodes[0];\n\t\t\t\tslot = path->slots[0];\n\t\t\t\twrite_extent_buffer(leaf, buf,\n\t\t\t\t\t    btrfs_item_ptr_offset(leaf, slot),\n\t\t\t\t\t    size);\n\t\t\t\tinode_add_bytes(inode, datal);\n\t\t\t}\n\n\t\t\t/* If we have an implicit hole (NO_HOLES feature). */\n\t\t\tif (drop_start < new_key.offset)\n\t\t\t\tclone_update_extent_map(inode, trans,\n\t\t\t\t\t\tNULL, drop_start,\n\t\t\t\t\t\tnew_key.offset - drop_start);\n\n\t\t\tclone_update_extent_map(inode, trans, path, 0, 0);\n\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t\tbtrfs_release_path(path);\n\n\t\t\tlast_dest_end = ALIGN(new_key.offset + datal,\n\t\t\t\t\t      root->sectorsize);\n\t\t\tret = clone_finish_inode_update(trans, inode,\n\t\t\t\t\t\t\tlast_dest_end,\n\t\t\t\t\t\t\tdestoff, olen);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tif (new_key.offset + datal >= destoff + len)\n\t\t\t\tbreak;\n\t\t}\n\t\tbtrfs_release_path(path);\n\t\tkey.offset++;\n\t}\n\tret = 0;\n\n\tif (last_dest_end < destoff + len) {\n\t\t/*\n\t\t * We have an implicit hole (NO_HOLES feature is enabled) that\n\t\t * fully or partially overlaps our cloning range at its end.\n\t\t */\n\t\tbtrfs_release_path(path);\n\n\t\t/*\n\t\t * 1 - remove extent(s)\n\t\t * 1 - inode update\n\t\t */\n\t\ttrans = btrfs_start_transaction(root, 2);\n\t\tif (IS_ERR(trans)) {\n\t\t\tret = PTR_ERR(trans);\n\t\t\tgoto out;\n\t\t}\n\t\tret = btrfs_drop_extents(trans, root, inode,\n\t\t\t\t\t last_dest_end, destoff + len, 1);\n\t\tif (ret) {\n\t\t\tif (ret != -EOPNOTSUPP)\n\t\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\tgoto out;\n\t\t}\n\t\tclone_update_extent_map(inode, trans, NULL, last_dest_end,\n\t\t\t\t\tdestoff + len - last_dest_end);\n\t\tret = clone_finish_inode_update(trans, inode, destoff + len,\n\t\t\t\t\t\tdestoff, olen);\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\tvfree(buf);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_clone(struct inode *src, struct inode *inode,\n\t\t       u64 off, u64 olen, u64 olen_aligned, u64 destoff);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_clone(struct inode *src, struct inode *inode,\n\t\t       u64 off, u64 olen, u64 olen_aligned, u64 destoff);\n\nstatic int btrfs_clone(struct inode *src, struct inode *inode,\n\t\t       const u64 off, const u64 olen, const u64 olen_aligned,\n\t\t       const u64 destoff)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_path *path = NULL;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_trans_handle *trans;\n\tchar *buf = NULL;\n\tstruct btrfs_key key;\n\tu32 nritems;\n\tint slot;\n\tint ret;\n\tint no_quota;\n\tconst u64 len = olen_aligned;\n\tu64 last_disko = 0;\n\tu64 last_dest_end = destoff;\n\n\tret = -ENOMEM;\n\tbuf = vmalloc(root->nodesize);\n\tif (!buf)\n\t\treturn ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tvfree(buf);\n\t\treturn ret;\n\t}\n\n\tpath->reada = 2;\n\t/* clone data */\n\tkey.objectid = btrfs_ino(src);\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = off;\n\n\twhile (1) {\n\t\t/*\n\t\t * note the key will change type as we walk through the\n\t\t * tree.\n\t\t */\n\t\tpath->leave_spinning = 1;\n\t\tret = btrfs_search_slot(NULL, BTRFS_I(src)->root, &key, path,\n\t\t\t\t0, 0);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\t/*\n\t\t * First search, if no extent item that starts at offset off was\n\t\t * found but the previous item is an extent item, it's possible\n\t\t * it might overlap our target range, therefore process it.\n\t\t */\n\t\tif (key.offset == off && ret > 0 && path->slots[0] > 0) {\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key,\n\t\t\t\t\t      path->slots[0] - 1);\n\t\t\tif (key.type == BTRFS_EXTENT_DATA_KEY)\n\t\t\t\tpath->slots[0]--;\n\t\t}\n\n\t\tnritems = btrfs_header_nritems(path->nodes[0]);\nprocess_slot:\n\t\tno_quota = 1;\n\t\tif (path->slots[0] >= nritems) {\n\t\t\tret = btrfs_next_leaf(BTRFS_I(src)->root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret > 0)\n\t\t\t\tbreak;\n\t\t\tnritems = btrfs_header_nritems(path->nodes[0]);\n\t\t}\n\t\tleaf = path->nodes[0];\n\t\tslot = path->slots[0];\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\t\tif (key.type > BTRFS_EXTENT_DATA_KEY ||\n\t\t    key.objectid != btrfs_ino(src))\n\t\t\tbreak;\n\n\t\tif (key.type == BTRFS_EXTENT_DATA_KEY) {\n\t\t\tstruct btrfs_file_extent_item *extent;\n\t\t\tint type;\n\t\t\tu32 size;\n\t\t\tstruct btrfs_key new_key;\n\t\t\tu64 disko = 0, diskl = 0;\n\t\t\tu64 datao = 0, datal = 0;\n\t\t\tu8 comp;\n\t\t\tu64 drop_start;\n\n\t\t\textent = btrfs_item_ptr(leaf, slot,\n\t\t\t\t\t\tstruct btrfs_file_extent_item);\n\t\t\tcomp = btrfs_file_extent_compression(leaf, extent);\n\t\t\ttype = btrfs_file_extent_type(leaf, extent);\n\t\t\tif (type == BTRFS_FILE_EXTENT_REG ||\n\t\t\t    type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\t\t\tdisko = btrfs_file_extent_disk_bytenr(leaf,\n\t\t\t\t\t\t\t\t      extent);\n\t\t\t\tdiskl = btrfs_file_extent_disk_num_bytes(leaf,\n\t\t\t\t\t\t\t\t extent);\n\t\t\t\tdatao = btrfs_file_extent_offset(leaf, extent);\n\t\t\t\tdatal = btrfs_file_extent_num_bytes(leaf,\n\t\t\t\t\t\t\t\t    extent);\n\t\t\t} else if (type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\t/* take upper bound, may be compressed */\n\t\t\t\tdatal = btrfs_file_extent_ram_bytes(leaf,\n\t\t\t\t\t\t\t\t    extent);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The first search might have left us at an extent\n\t\t\t * item that ends before our target range's start, can\n\t\t\t * happen if we have holes and NO_HOLES feature enabled.\n\t\t\t */\n\t\t\tif (key.offset + datal <= off) {\n\t\t\t\tpath->slots[0]++;\n\t\t\t\tgoto process_slot;\n\t\t\t} else if (key.offset >= off + len) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tsize = btrfs_item_size_nr(leaf, slot);\n\t\t\tread_extent_buffer(leaf, buf,\n\t\t\t\t\t   btrfs_item_ptr_offset(leaf, slot),\n\t\t\t\t\t   size);\n\n\t\t\tbtrfs_release_path(path);\n\t\t\tpath->leave_spinning = 0;\n\n\t\t\tmemcpy(&new_key, &key, sizeof(new_key));\n\t\t\tnew_key.objectid = btrfs_ino(inode);\n\t\t\tif (off <= key.offset)\n\t\t\t\tnew_key.offset = key.offset + destoff - off;\n\t\t\telse\n\t\t\t\tnew_key.offset = destoff;\n\n\t\t\t/*\n\t\t\t * Deal with a hole that doesn't have an extent item\n\t\t\t * that represents it (NO_HOLES feature enabled).\n\t\t\t * This hole is either in the middle of the cloning\n\t\t\t * range or at the beginning (fully overlaps it or\n\t\t\t * partially overlaps it).\n\t\t\t */\n\t\t\tif (new_key.offset != last_dest_end)\n\t\t\t\tdrop_start = last_dest_end;\n\t\t\telse\n\t\t\t\tdrop_start = new_key.offset;\n\n\t\t\t/*\n\t\t\t * 1 - adjusting old extent (we may have to split it)\n\t\t\t * 1 - add new extent\n\t\t\t * 1 - inode update\n\t\t\t */\n\t\t\ttrans = btrfs_start_transaction(root, 3);\n\t\t\tif (IS_ERR(trans)) {\n\t\t\t\tret = PTR_ERR(trans);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (type == BTRFS_FILE_EXTENT_REG ||\n\t\t\t    type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\t\t\t/*\n\t\t\t\t *    a  | --- range to clone ---|  b\n\t\t\t\t * | ------------- extent ------------- |\n\t\t\t\t */\n\n\t\t\t\t/* subtract range b */\n\t\t\t\tif (key.offset + datal > off + len)\n\t\t\t\t\tdatal = off + len - key.offset;\n\n\t\t\t\t/* subtract range a */\n\t\t\t\tif (off > key.offset) {\n\t\t\t\t\tdatao += off - key.offset;\n\t\t\t\t\tdatal -= off - key.offset;\n\t\t\t\t}\n\n\t\t\t\tret = btrfs_drop_extents(trans, root, inode,\n\t\t\t\t\t\t\t drop_start,\n\t\t\t\t\t\t\t new_key.offset + datal,\n\t\t\t\t\t\t\t 1);\n\t\t\t\tif (ret) {\n\t\t\t\t\tif (ret != -EOPNOTSUPP)\n\t\t\t\t\t\tbtrfs_abort_transaction(trans,\n\t\t\t\t\t\t\t\troot, ret);\n\t\t\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tret = btrfs_insert_empty_item(trans, root, path,\n\t\t\t\t\t\t\t      &new_key, size);\n\t\t\t\tif (ret) {\n\t\t\t\t\tbtrfs_abort_transaction(trans, root,\n\t\t\t\t\t\t\t\tret);\n\t\t\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tleaf = path->nodes[0];\n\t\t\t\tslot = path->slots[0];\n\t\t\t\twrite_extent_buffer(leaf, buf,\n\t\t\t\t\t    btrfs_item_ptr_offset(leaf, slot),\n\t\t\t\t\t    size);\n\n\t\t\t\textent = btrfs_item_ptr(leaf, slot,\n\t\t\t\t\t\tstruct btrfs_file_extent_item);\n\n\t\t\t\t/* disko == 0 means it's a hole */\n\t\t\t\tif (!disko)\n\t\t\t\t\tdatao = 0;\n\n\t\t\t\tbtrfs_set_file_extent_offset(leaf, extent,\n\t\t\t\t\t\t\t     datao);\n\t\t\t\tbtrfs_set_file_extent_num_bytes(leaf, extent,\n\t\t\t\t\t\t\t\tdatal);\n\n\t\t\t\t/*\n\t\t\t\t * We need to look up the roots that point at\n\t\t\t\t * this bytenr and see if the new root does.  If\n\t\t\t\t * it does not we need to make sure we update\n\t\t\t\t * quotas appropriately.\n\t\t\t\t */\n\t\t\t\tif (disko && root != BTRFS_I(src)->root &&\n\t\t\t\t    disko != last_disko) {\n\t\t\t\t\tno_quota = check_ref(trans, root,\n\t\t\t\t\t\t\t     disko);\n\t\t\t\t\tif (no_quota < 0) {\n\t\t\t\t\t\tbtrfs_abort_transaction(trans,\n\t\t\t\t\t\t\t\t\troot,\n\t\t\t\t\t\t\t\t\tret);\n\t\t\t\t\t\tbtrfs_end_transaction(trans,\n\t\t\t\t\t\t\t\t      root);\n\t\t\t\t\t\tret = no_quota;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (disko) {\n\t\t\t\t\tinode_add_bytes(inode, datal);\n\t\t\t\t\tret = btrfs_inc_extent_ref(trans, root,\n\t\t\t\t\t\t\tdisko, diskl, 0,\n\t\t\t\t\t\t\troot->root_key.objectid,\n\t\t\t\t\t\t\tbtrfs_ino(inode),\n\t\t\t\t\t\t\tnew_key.offset - datao,\n\t\t\t\t\t\t\tno_quota);\n\t\t\t\t\tif (ret) {\n\t\t\t\t\t\tbtrfs_abort_transaction(trans,\n\t\t\t\t\t\t\t\t\troot,\n\t\t\t\t\t\t\t\t\tret);\n\t\t\t\t\t\tbtrfs_end_transaction(trans,\n\t\t\t\t\t\t\t\t      root);\n\t\t\t\t\t\tgoto out;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tu64 skip = 0;\n\t\t\t\tu64 trim = 0;\n\t\t\t\tu64 aligned_end = 0;\n\n\t\t\t\tif (off > key.offset) {\n\t\t\t\t\tskip = off - key.offset;\n\t\t\t\t\tnew_key.offset += skip;\n\t\t\t\t}\n\n\t\t\t\tif (key.offset + datal > off + len)\n\t\t\t\t\ttrim = key.offset + datal - (off + len);\n\n\t\t\t\tif (comp && (skip || trim)) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tsize -= skip + trim;\n\t\t\t\tdatal -= skip + trim;\n\n\t\t\t\taligned_end = ALIGN(new_key.offset + datal,\n\t\t\t\t\t\t    root->sectorsize);\n\t\t\t\tret = btrfs_drop_extents(trans, root, inode,\n\t\t\t\t\t\t\t drop_start,\n\t\t\t\t\t\t\t aligned_end,\n\t\t\t\t\t\t\t 1);\n\t\t\t\tif (ret) {\n\t\t\t\t\tif (ret != -EOPNOTSUPP)\n\t\t\t\t\t\tbtrfs_abort_transaction(trans,\n\t\t\t\t\t\t\troot, ret);\n\t\t\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tret = btrfs_insert_empty_item(trans, root, path,\n\t\t\t\t\t\t\t      &new_key, size);\n\t\t\t\tif (ret) {\n\t\t\t\t\tbtrfs_abort_transaction(trans, root,\n\t\t\t\t\t\t\t\tret);\n\t\t\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tif (skip) {\n\t\t\t\t\tu32 start =\n\t\t\t\t\t  btrfs_file_extent_calc_inline_size(0);\n\t\t\t\t\tmemmove(buf+start, buf+start+skip,\n\t\t\t\t\t\tdatal);\n\t\t\t\t}\n\n\t\t\t\tleaf = path->nodes[0];\n\t\t\t\tslot = path->slots[0];\n\t\t\t\twrite_extent_buffer(leaf, buf,\n\t\t\t\t\t    btrfs_item_ptr_offset(leaf, slot),\n\t\t\t\t\t    size);\n\t\t\t\tinode_add_bytes(inode, datal);\n\t\t\t}\n\n\t\t\t/* If we have an implicit hole (NO_HOLES feature). */\n\t\t\tif (drop_start < new_key.offset)\n\t\t\t\tclone_update_extent_map(inode, trans,\n\t\t\t\t\t\tNULL, drop_start,\n\t\t\t\t\t\tnew_key.offset - drop_start);\n\n\t\t\tclone_update_extent_map(inode, trans, path, 0, 0);\n\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t\tbtrfs_release_path(path);\n\n\t\t\tlast_dest_end = ALIGN(new_key.offset + datal,\n\t\t\t\t\t      root->sectorsize);\n\t\t\tret = clone_finish_inode_update(trans, inode,\n\t\t\t\t\t\t\tlast_dest_end,\n\t\t\t\t\t\t\tdestoff, olen);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tif (new_key.offset + datal >= destoff + len)\n\t\t\t\tbreak;\n\t\t}\n\t\tbtrfs_release_path(path);\n\t\tkey.offset++;\n\t}\n\tret = 0;\n\n\tif (last_dest_end < destoff + len) {\n\t\t/*\n\t\t * We have an implicit hole (NO_HOLES feature is enabled) that\n\t\t * fully or partially overlaps our cloning range at its end.\n\t\t */\n\t\tbtrfs_release_path(path);\n\n\t\t/*\n\t\t * 1 - remove extent(s)\n\t\t * 1 - inode update\n\t\t */\n\t\ttrans = btrfs_start_transaction(root, 2);\n\t\tif (IS_ERR(trans)) {\n\t\t\tret = PTR_ERR(trans);\n\t\t\tgoto out;\n\t\t}\n\t\tret = btrfs_drop_extents(trans, root, inode,\n\t\t\t\t\t last_dest_end, destoff + len, 1);\n\t\tif (ret) {\n\t\t\tif (ret != -EOPNOTSUPP)\n\t\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\tgoto out;\n\t\t}\n\t\tclone_update_extent_map(inode, trans, NULL, last_dest_end,\n\t\t\t\t\tdestoff + len - last_dest_end);\n\t\tret = clone_finish_inode_update(trans, inode, destoff + len,\n\t\t\t\t\t\tdestoff, olen);\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\tvfree(buf);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_extent_range",
          "args": [
            "inode",
            "destoff",
            "len"
          ],
          "line": 3660
        },
        "resolved": true,
        "details": {
          "function_name": "lock_extent_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "2778-2801",
          "snippet": "static inline void lock_extent_range(struct inode *inode, u64 off, u64 len)\n{\n\t/* do any pending delalloc/csum calc on src, one way or\n\t   another, and lock file content */\n\twhile (1) {\n\t\tstruct btrfs_ordered_extent *ordered;\n\t\tlock_extent(&BTRFS_I(inode)->io_tree, off, off + len - 1);\n\t\tordered = btrfs_lookup_first_ordered_extent(inode,\n\t\t\t\t\t\t\t    off + len - 1);\n\t\tif ((!ordered ||\n\t\t     ordered->file_offset + ordered->len <= off ||\n\t\t     ordered->file_offset >= off + len) &&\n\t\t    !test_range_bit(&BTRFS_I(inode)->io_tree, off,\n\t\t\t\t    off + len - 1, EXTENT_DELALLOC, 0, NULL)) {\n\t\t\tif (ordered)\n\t\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tunlock_extent(&BTRFS_I(inode)->io_tree, off, off + len - 1);\n\t\tif (ordered)\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\tbtrfs_wait_ordered_range(inode, off, len);\n\t}\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic inline void lock_extent_range(struct inode *inode, u64 off, u64 len)\n{\n\t/* do any pending delalloc/csum calc on src, one way or\n\t   another, and lock file content */\n\twhile (1) {\n\t\tstruct btrfs_ordered_extent *ordered;\n\t\tlock_extent(&BTRFS_I(inode)->io_tree, off, off + len - 1);\n\t\tordered = btrfs_lookup_first_ordered_extent(inode,\n\t\t\t\t\t\t\t    off + len - 1);\n\t\tif ((!ordered ||\n\t\t     ordered->file_offset + ordered->len <= off ||\n\t\t     ordered->file_offset >= off + len) &&\n\t\t    !test_range_bit(&BTRFS_I(inode)->io_tree, off,\n\t\t\t\t    off + len - 1, EXTENT_DELALLOC, 0, NULL)) {\n\t\t\tif (ordered)\n\t\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tunlock_extent(&BTRFS_I(inode)->io_tree, off, off + len - 1);\n\t\tif (ordered)\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\tbtrfs_wait_ordered_range(inode, off, len);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "u64",
            "off",
            "destoff"
          ],
          "line": 3655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u64",
            "off",
            "destoff"
          ],
          "line": 3654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_cont_expand",
          "args": [
            "inode",
            "inode->i_size",
            "destoff"
          ],
          "line": 3641
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_cont_expand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "4585-4688",
          "snippet": "int btrfs_cont_expand(struct inode *inode, loff_t oldsize, loff_t size)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct extent_io_tree *io_tree = &BTRFS_I(inode)->io_tree;\n\tstruct extent_map *em = NULL;\n\tstruct extent_state *cached_state = NULL;\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tu64 hole_start = ALIGN(oldsize, root->sectorsize);\n\tu64 block_end = ALIGN(size, root->sectorsize);\n\tu64 last_byte;\n\tu64 cur_offset;\n\tu64 hole_size;\n\tint err = 0;\n\n\t/*\n\t * If our size started in the middle of a page we need to zero out the\n\t * rest of the page before we expand the i_size, otherwise we could\n\t * expose stale data.\n\t */\n\terr = btrfs_truncate_page(inode, oldsize, 0, 0);\n\tif (err)\n\t\treturn err;\n\n\tif (size <= hole_start)\n\t\treturn 0;\n\n\twhile (1) {\n\t\tstruct btrfs_ordered_extent *ordered;\n\n\t\tlock_extent_bits(io_tree, hole_start, block_end - 1, 0,\n\t\t\t\t &cached_state);\n\t\tordered = btrfs_lookup_ordered_range(inode, hole_start,\n\t\t\t\t\t\t     block_end - hole_start);\n\t\tif (!ordered)\n\t\t\tbreak;\n\t\tunlock_extent_cached(io_tree, hole_start, block_end - 1,\n\t\t\t\t     &cached_state, GFP_NOFS);\n\t\tbtrfs_start_ordered_extent(inode, ordered, 1);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t}\n\n\tcur_offset = hole_start;\n\twhile (1) {\n\t\tem = btrfs_get_extent(inode, NULL, 0, cur_offset,\n\t\t\t\tblock_end - cur_offset, 0);\n\t\tif (IS_ERR(em)) {\n\t\t\terr = PTR_ERR(em);\n\t\t\tem = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tlast_byte = min(extent_map_end(em), block_end);\n\t\tlast_byte = ALIGN(last_byte , root->sectorsize);\n\t\tif (!test_bit(EXTENT_FLAG_PREALLOC, &em->flags)) {\n\t\t\tstruct extent_map *hole_em;\n\t\t\thole_size = last_byte - cur_offset;\n\n\t\t\terr = maybe_insert_hole(root, inode, cur_offset,\n\t\t\t\t\t\thole_size);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tbtrfs_drop_extent_cache(inode, cur_offset,\n\t\t\t\t\t\tcur_offset + hole_size - 1, 0);\n\t\t\thole_em = alloc_extent_map();\n\t\t\tif (!hole_em) {\n\t\t\t\tset_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t\t\t&BTRFS_I(inode)->runtime_flags);\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\thole_em->start = cur_offset;\n\t\t\thole_em->len = hole_size;\n\t\t\thole_em->orig_start = cur_offset;\n\n\t\t\thole_em->block_start = EXTENT_MAP_HOLE;\n\t\t\thole_em->block_len = 0;\n\t\t\thole_em->orig_block_len = 0;\n\t\t\thole_em->ram_bytes = hole_size;\n\t\t\thole_em->bdev = root->fs_info->fs_devices->latest_bdev;\n\t\t\thole_em->compress_type = BTRFS_COMPRESS_NONE;\n\t\t\thole_em->generation = root->fs_info->generation;\n\n\t\t\twhile (1) {\n\t\t\t\twrite_lock(&em_tree->lock);\n\t\t\t\terr = add_extent_mapping(em_tree, hole_em, 1);\n\t\t\t\twrite_unlock(&em_tree->lock);\n\t\t\t\tif (err != -EEXIST)\n\t\t\t\t\tbreak;\n\t\t\t\tbtrfs_drop_extent_cache(inode, cur_offset,\n\t\t\t\t\t\t\tcur_offset +\n\t\t\t\t\t\t\thole_size - 1, 0);\n\t\t\t}\n\t\t\tfree_extent_map(hole_em);\n\t\t}\nnext:\n\t\tfree_extent_map(em);\n\t\tem = NULL;\n\t\tcur_offset = last_byte;\n\t\tif (cur_offset >= block_end)\n\t\t\tbreak;\n\t}\n\tfree_extent_map(em);\n\tunlock_extent_cached(io_tree, hole_start, block_end - 1, &cached_state,\n\t\t\t     GFP_NOFS);\n\treturn err;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nint btrfs_cont_expand(struct inode *inode, loff_t oldsize, loff_t size)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct extent_io_tree *io_tree = &BTRFS_I(inode)->io_tree;\n\tstruct extent_map *em = NULL;\n\tstruct extent_state *cached_state = NULL;\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tu64 hole_start = ALIGN(oldsize, root->sectorsize);\n\tu64 block_end = ALIGN(size, root->sectorsize);\n\tu64 last_byte;\n\tu64 cur_offset;\n\tu64 hole_size;\n\tint err = 0;\n\n\t/*\n\t * If our size started in the middle of a page we need to zero out the\n\t * rest of the page before we expand the i_size, otherwise we could\n\t * expose stale data.\n\t */\n\terr = btrfs_truncate_page(inode, oldsize, 0, 0);\n\tif (err)\n\t\treturn err;\n\n\tif (size <= hole_start)\n\t\treturn 0;\n\n\twhile (1) {\n\t\tstruct btrfs_ordered_extent *ordered;\n\n\t\tlock_extent_bits(io_tree, hole_start, block_end - 1, 0,\n\t\t\t\t &cached_state);\n\t\tordered = btrfs_lookup_ordered_range(inode, hole_start,\n\t\t\t\t\t\t     block_end - hole_start);\n\t\tif (!ordered)\n\t\t\tbreak;\n\t\tunlock_extent_cached(io_tree, hole_start, block_end - 1,\n\t\t\t\t     &cached_state, GFP_NOFS);\n\t\tbtrfs_start_ordered_extent(inode, ordered, 1);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t}\n\n\tcur_offset = hole_start;\n\twhile (1) {\n\t\tem = btrfs_get_extent(inode, NULL, 0, cur_offset,\n\t\t\t\tblock_end - cur_offset, 0);\n\t\tif (IS_ERR(em)) {\n\t\t\terr = PTR_ERR(em);\n\t\t\tem = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tlast_byte = min(extent_map_end(em), block_end);\n\t\tlast_byte = ALIGN(last_byte , root->sectorsize);\n\t\tif (!test_bit(EXTENT_FLAG_PREALLOC, &em->flags)) {\n\t\t\tstruct extent_map *hole_em;\n\t\t\thole_size = last_byte - cur_offset;\n\n\t\t\terr = maybe_insert_hole(root, inode, cur_offset,\n\t\t\t\t\t\thole_size);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tbtrfs_drop_extent_cache(inode, cur_offset,\n\t\t\t\t\t\tcur_offset + hole_size - 1, 0);\n\t\t\thole_em = alloc_extent_map();\n\t\t\tif (!hole_em) {\n\t\t\t\tset_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t\t\t&BTRFS_I(inode)->runtime_flags);\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\thole_em->start = cur_offset;\n\t\t\thole_em->len = hole_size;\n\t\t\thole_em->orig_start = cur_offset;\n\n\t\t\thole_em->block_start = EXTENT_MAP_HOLE;\n\t\t\thole_em->block_len = 0;\n\t\t\thole_em->orig_block_len = 0;\n\t\t\thole_em->ram_bytes = hole_size;\n\t\t\thole_em->bdev = root->fs_info->fs_devices->latest_bdev;\n\t\t\thole_em->compress_type = BTRFS_COMPRESS_NONE;\n\t\t\thole_em->generation = root->fs_info->generation;\n\n\t\t\twhile (1) {\n\t\t\t\twrite_lock(&em_tree->lock);\n\t\t\t\terr = add_extent_mapping(em_tree, hole_em, 1);\n\t\t\t\twrite_unlock(&em_tree->lock);\n\t\t\t\tif (err != -EEXIST)\n\t\t\t\t\tbreak;\n\t\t\t\tbtrfs_drop_extent_cache(inode, cur_offset,\n\t\t\t\t\t\t\tcur_offset +\n\t\t\t\t\t\t\thole_size - 1, 0);\n\t\t\t}\n\t\t\tfree_extent_map(hole_em);\n\t\t}\nnext:\n\t\tfree_extent_map(em);\n\t\tem = NULL;\n\t\tcur_offset = last_byte;\n\t\tif (cur_offset >= block_end)\n\t\t\tbreak;\n\t}\n\tfree_extent_map(em);\n\tunlock_extent_cached(io_tree, hole_start, block_end - 1, &cached_state,\n\t\t\t     GFP_NOFS);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "destoff",
            "bs"
          ],
          "line": 3631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "off + len",
            "bs"
          ],
          "line": 3630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "off",
            "bs"
          ],
          "line": 3630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "src->i_size",
            "bs"
          ],
          "line": 3627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&src->i_mutex"
          ],
          "line": 3616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&inode->i_mutex",
            "I_MUTEX_CHILD"
          ],
          "line": 3613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&src->i_mutex",
            "I_MUTEX_PARENT"
          ],
          "line": 3612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&src->i_mutex",
            "I_MUTEX_CHILD"
          ],
          "line": 3610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&inode->i_mutex",
            "I_MUTEX_PARENT"
          ],
          "line": 3609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 3600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "src->i_mode"
          ],
          "line": 3600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "src_file.file"
          ],
          "line": 3584
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "srcfd"
          ],
          "line": 3574
        },
        "resolved": true,
        "details": {
          "function_name": "__fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "706-718",
          "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "file"
          ],
          "line": 3570
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_root_readonly",
          "args": [
            "root"
          ],
          "line": 3567
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_root_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2876-2879",
          "snippet": "static inline bool btrfs_root_readonly(struct btrfs_root *root)\n{\n\treturn (root->root_item.flags & cpu_to_le64(BTRFS_ROOT_SUBVOL_RDONLY)) != 0;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_ROOT_SUBVOL_RDONLY\t(1ULL << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_ROOT_SUBVOL_RDONLY\t(1ULL << 0)\n\nstatic inline bool btrfs_root_readonly(struct btrfs_root *root)\n{\n\treturn (root->root_item.flags & cpu_to_le64(BTRFS_ROOT_SUBVOL_RDONLY)) != 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_clone(struct inode *src, struct inode *inode,\n\t\t       u64 off, u64 olen, u64 olen_aligned, u64 destoff);\n\nstatic noinline long btrfs_ioctl_clone(struct file *file, unsigned long srcfd,\n\t\t\t\t       u64 off, u64 olen, u64 destoff)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct fd src_file;\n\tstruct inode *src;\n\tint ret;\n\tu64 len = olen;\n\tu64 bs = root->fs_info->sb->s_blocksize;\n\tint same_inode = 0;\n\n\t/*\n\t * TODO:\n\t * - split compressed inline extents.  annoying: we need to\n\t *   decompress into destination's address_space (the file offset\n\t *   may change, so source mapping won't do), then recompress (or\n\t *   otherwise reinsert) a subrange.\n\t *\n\t * - split destination inode's inline extents.  The inline extents can\n\t *   be either compressed or non-compressed.\n\t */\n\n\t/* the destination must be opened for writing */\n\tif (!(file->f_mode & FMODE_WRITE) || (file->f_flags & O_APPEND))\n\t\treturn -EINVAL;\n\n\tif (btrfs_root_readonly(root))\n\t\treturn -EROFS;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tsrc_file = fdget(srcfd);\n\tif (!src_file.file) {\n\t\tret = -EBADF;\n\t\tgoto out_drop_write;\n\t}\n\n\tret = -EXDEV;\n\tif (src_file.file->f_path.mnt != file->f_path.mnt)\n\t\tgoto out_fput;\n\n\tsrc = file_inode(src_file.file);\n\n\tret = -EINVAL;\n\tif (src == inode)\n\t\tsame_inode = 1;\n\n\t/* the src must be open for reading */\n\tif (!(src_file.file->f_mode & FMODE_READ))\n\t\tgoto out_fput;\n\n\t/* don't make the dst file partly checksummed */\n\tif ((BTRFS_I(src)->flags & BTRFS_INODE_NODATASUM) !=\n\t    (BTRFS_I(inode)->flags & BTRFS_INODE_NODATASUM))\n\t\tgoto out_fput;\n\n\tret = -EISDIR;\n\tif (S_ISDIR(src->i_mode) || S_ISDIR(inode->i_mode))\n\t\tgoto out_fput;\n\n\tret = -EXDEV;\n\tif (src->i_sb != inode->i_sb)\n\t\tgoto out_fput;\n\n\tif (!same_inode) {\n\t\tif (inode < src) {\n\t\t\tmutex_lock_nested(&inode->i_mutex, I_MUTEX_PARENT);\n\t\t\tmutex_lock_nested(&src->i_mutex, I_MUTEX_CHILD);\n\t\t} else {\n\t\t\tmutex_lock_nested(&src->i_mutex, I_MUTEX_PARENT);\n\t\t\tmutex_lock_nested(&inode->i_mutex, I_MUTEX_CHILD);\n\t\t}\n\t} else {\n\t\tmutex_lock(&src->i_mutex);\n\t}\n\n\t/* determine range to clone */\n\tret = -EINVAL;\n\tif (off + len > src->i_size || off + len < off)\n\t\tgoto out_unlock;\n\tif (len == 0)\n\t\tolen = len = src->i_size - off;\n\t/* if we extend to eof, continue to block boundary */\n\tif (off + len == src->i_size)\n\t\tlen = ALIGN(src->i_size, bs) - off;\n\n\t/* verify the end result is block aligned */\n\tif (!IS_ALIGNED(off, bs) || !IS_ALIGNED(off + len, bs) ||\n\t    !IS_ALIGNED(destoff, bs))\n\t\tgoto out_unlock;\n\n\t/* verify if ranges are overlapped within the same file */\n\tif (same_inode) {\n\t\tif (destoff + len > off && destoff < off + len)\n\t\t\tgoto out_unlock;\n\t}\n\n\tif (destoff > inode->i_size) {\n\t\tret = btrfs_cont_expand(inode, inode->i_size, destoff);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Lock the target range too. Right after we replace the file extent\n\t * items in the fs tree (which now point to the cloned data), we might\n\t * have a worker replace them with extent items relative to a write\n\t * operation that was issued before this clone operation (i.e. confront\n\t * with inode.c:btrfs_finish_ordered_io).\n\t */\n\tif (same_inode) {\n\t\tu64 lock_start = min_t(u64, off, destoff);\n\t\tu64 lock_len = max_t(u64, off, destoff) + len - lock_start;\n\n\t\tlock_extent_range(src, lock_start, lock_len);\n\t} else {\n\t\tlock_extent_range(src, off, len);\n\t\tlock_extent_range(inode, destoff, len);\n\t}\n\n\tret = btrfs_clone(src, inode, off, olen, len, destoff);\n\n\tif (same_inode) {\n\t\tu64 lock_start = min_t(u64, off, destoff);\n\t\tu64 lock_end = max_t(u64, off, destoff) + len - 1;\n\n\t\tunlock_extent(&BTRFS_I(src)->io_tree, lock_start, lock_end);\n\t} else {\n\t\tunlock_extent(&BTRFS_I(src)->io_tree, off, off + len - 1);\n\t\tunlock_extent(&BTRFS_I(inode)->io_tree, destoff,\n\t\t\t      destoff + len - 1);\n\t}\n\t/*\n\t * Truncate page cache pages so that future reads will see the cloned\n\t * data immediately and not the previous data.\n\t */\n\ttruncate_inode_pages_range(&inode->i_data, destoff,\n\t\t\t\t   PAGE_CACHE_ALIGN(destoff + len) - 1);\nout_unlock:\n\tif (!same_inode) {\n\t\tif (inode < src) {\n\t\t\tmutex_unlock(&src->i_mutex);\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t} else {\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\tmutex_unlock(&src->i_mutex);\n\t\t}\n\t} else {\n\t\tmutex_unlock(&src->i_mutex);\n\t}\nout_fput:\n\tfdput(src_file);\nout_drop_write:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_clone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "3169-3538",
    "snippet": "static int btrfs_clone(struct inode *src, struct inode *inode,\n\t\t       const u64 off, const u64 olen, const u64 olen_aligned,\n\t\t       const u64 destoff)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_path *path = NULL;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_trans_handle *trans;\n\tchar *buf = NULL;\n\tstruct btrfs_key key;\n\tu32 nritems;\n\tint slot;\n\tint ret;\n\tint no_quota;\n\tconst u64 len = olen_aligned;\n\tu64 last_disko = 0;\n\tu64 last_dest_end = destoff;\n\n\tret = -ENOMEM;\n\tbuf = vmalloc(root->nodesize);\n\tif (!buf)\n\t\treturn ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tvfree(buf);\n\t\treturn ret;\n\t}\n\n\tpath->reada = 2;\n\t/* clone data */\n\tkey.objectid = btrfs_ino(src);\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = off;\n\n\twhile (1) {\n\t\t/*\n\t\t * note the key will change type as we walk through the\n\t\t * tree.\n\t\t */\n\t\tpath->leave_spinning = 1;\n\t\tret = btrfs_search_slot(NULL, BTRFS_I(src)->root, &key, path,\n\t\t\t\t0, 0);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\t/*\n\t\t * First search, if no extent item that starts at offset off was\n\t\t * found but the previous item is an extent item, it's possible\n\t\t * it might overlap our target range, therefore process it.\n\t\t */\n\t\tif (key.offset == off && ret > 0 && path->slots[0] > 0) {\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key,\n\t\t\t\t\t      path->slots[0] - 1);\n\t\t\tif (key.type == BTRFS_EXTENT_DATA_KEY)\n\t\t\t\tpath->slots[0]--;\n\t\t}\n\n\t\tnritems = btrfs_header_nritems(path->nodes[0]);\nprocess_slot:\n\t\tno_quota = 1;\n\t\tif (path->slots[0] >= nritems) {\n\t\t\tret = btrfs_next_leaf(BTRFS_I(src)->root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret > 0)\n\t\t\t\tbreak;\n\t\t\tnritems = btrfs_header_nritems(path->nodes[0]);\n\t\t}\n\t\tleaf = path->nodes[0];\n\t\tslot = path->slots[0];\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\t\tif (key.type > BTRFS_EXTENT_DATA_KEY ||\n\t\t    key.objectid != btrfs_ino(src))\n\t\t\tbreak;\n\n\t\tif (key.type == BTRFS_EXTENT_DATA_KEY) {\n\t\t\tstruct btrfs_file_extent_item *extent;\n\t\t\tint type;\n\t\t\tu32 size;\n\t\t\tstruct btrfs_key new_key;\n\t\t\tu64 disko = 0, diskl = 0;\n\t\t\tu64 datao = 0, datal = 0;\n\t\t\tu8 comp;\n\t\t\tu64 drop_start;\n\n\t\t\textent = btrfs_item_ptr(leaf, slot,\n\t\t\t\t\t\tstruct btrfs_file_extent_item);\n\t\t\tcomp = btrfs_file_extent_compression(leaf, extent);\n\t\t\ttype = btrfs_file_extent_type(leaf, extent);\n\t\t\tif (type == BTRFS_FILE_EXTENT_REG ||\n\t\t\t    type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\t\t\tdisko = btrfs_file_extent_disk_bytenr(leaf,\n\t\t\t\t\t\t\t\t      extent);\n\t\t\t\tdiskl = btrfs_file_extent_disk_num_bytes(leaf,\n\t\t\t\t\t\t\t\t extent);\n\t\t\t\tdatao = btrfs_file_extent_offset(leaf, extent);\n\t\t\t\tdatal = btrfs_file_extent_num_bytes(leaf,\n\t\t\t\t\t\t\t\t    extent);\n\t\t\t} else if (type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\t/* take upper bound, may be compressed */\n\t\t\t\tdatal = btrfs_file_extent_ram_bytes(leaf,\n\t\t\t\t\t\t\t\t    extent);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The first search might have left us at an extent\n\t\t\t * item that ends before our target range's start, can\n\t\t\t * happen if we have holes and NO_HOLES feature enabled.\n\t\t\t */\n\t\t\tif (key.offset + datal <= off) {\n\t\t\t\tpath->slots[0]++;\n\t\t\t\tgoto process_slot;\n\t\t\t} else if (key.offset >= off + len) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tsize = btrfs_item_size_nr(leaf, slot);\n\t\t\tread_extent_buffer(leaf, buf,\n\t\t\t\t\t   btrfs_item_ptr_offset(leaf, slot),\n\t\t\t\t\t   size);\n\n\t\t\tbtrfs_release_path(path);\n\t\t\tpath->leave_spinning = 0;\n\n\t\t\tmemcpy(&new_key, &key, sizeof(new_key));\n\t\t\tnew_key.objectid = btrfs_ino(inode);\n\t\t\tif (off <= key.offset)\n\t\t\t\tnew_key.offset = key.offset + destoff - off;\n\t\t\telse\n\t\t\t\tnew_key.offset = destoff;\n\n\t\t\t/*\n\t\t\t * Deal with a hole that doesn't have an extent item\n\t\t\t * that represents it (NO_HOLES feature enabled).\n\t\t\t * This hole is either in the middle of the cloning\n\t\t\t * range or at the beginning (fully overlaps it or\n\t\t\t * partially overlaps it).\n\t\t\t */\n\t\t\tif (new_key.offset != last_dest_end)\n\t\t\t\tdrop_start = last_dest_end;\n\t\t\telse\n\t\t\t\tdrop_start = new_key.offset;\n\n\t\t\t/*\n\t\t\t * 1 - adjusting old extent (we may have to split it)\n\t\t\t * 1 - add new extent\n\t\t\t * 1 - inode update\n\t\t\t */\n\t\t\ttrans = btrfs_start_transaction(root, 3);\n\t\t\tif (IS_ERR(trans)) {\n\t\t\t\tret = PTR_ERR(trans);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (type == BTRFS_FILE_EXTENT_REG ||\n\t\t\t    type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\t\t\t/*\n\t\t\t\t *    a  | --- range to clone ---|  b\n\t\t\t\t * | ------------- extent ------------- |\n\t\t\t\t */\n\n\t\t\t\t/* subtract range b */\n\t\t\t\tif (key.offset + datal > off + len)\n\t\t\t\t\tdatal = off + len - key.offset;\n\n\t\t\t\t/* subtract range a */\n\t\t\t\tif (off > key.offset) {\n\t\t\t\t\tdatao += off - key.offset;\n\t\t\t\t\tdatal -= off - key.offset;\n\t\t\t\t}\n\n\t\t\t\tret = btrfs_drop_extents(trans, root, inode,\n\t\t\t\t\t\t\t drop_start,\n\t\t\t\t\t\t\t new_key.offset + datal,\n\t\t\t\t\t\t\t 1);\n\t\t\t\tif (ret) {\n\t\t\t\t\tif (ret != -EOPNOTSUPP)\n\t\t\t\t\t\tbtrfs_abort_transaction(trans,\n\t\t\t\t\t\t\t\troot, ret);\n\t\t\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tret = btrfs_insert_empty_item(trans, root, path,\n\t\t\t\t\t\t\t      &new_key, size);\n\t\t\t\tif (ret) {\n\t\t\t\t\tbtrfs_abort_transaction(trans, root,\n\t\t\t\t\t\t\t\tret);\n\t\t\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tleaf = path->nodes[0];\n\t\t\t\tslot = path->slots[0];\n\t\t\t\twrite_extent_buffer(leaf, buf,\n\t\t\t\t\t    btrfs_item_ptr_offset(leaf, slot),\n\t\t\t\t\t    size);\n\n\t\t\t\textent = btrfs_item_ptr(leaf, slot,\n\t\t\t\t\t\tstruct btrfs_file_extent_item);\n\n\t\t\t\t/* disko == 0 means it's a hole */\n\t\t\t\tif (!disko)\n\t\t\t\t\tdatao = 0;\n\n\t\t\t\tbtrfs_set_file_extent_offset(leaf, extent,\n\t\t\t\t\t\t\t     datao);\n\t\t\t\tbtrfs_set_file_extent_num_bytes(leaf, extent,\n\t\t\t\t\t\t\t\tdatal);\n\n\t\t\t\t/*\n\t\t\t\t * We need to look up the roots that point at\n\t\t\t\t * this bytenr and see if the new root does.  If\n\t\t\t\t * it does not we need to make sure we update\n\t\t\t\t * quotas appropriately.\n\t\t\t\t */\n\t\t\t\tif (disko && root != BTRFS_I(src)->root &&\n\t\t\t\t    disko != last_disko) {\n\t\t\t\t\tno_quota = check_ref(trans, root,\n\t\t\t\t\t\t\t     disko);\n\t\t\t\t\tif (no_quota < 0) {\n\t\t\t\t\t\tbtrfs_abort_transaction(trans,\n\t\t\t\t\t\t\t\t\troot,\n\t\t\t\t\t\t\t\t\tret);\n\t\t\t\t\t\tbtrfs_end_transaction(trans,\n\t\t\t\t\t\t\t\t      root);\n\t\t\t\t\t\tret = no_quota;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (disko) {\n\t\t\t\t\tinode_add_bytes(inode, datal);\n\t\t\t\t\tret = btrfs_inc_extent_ref(trans, root,\n\t\t\t\t\t\t\tdisko, diskl, 0,\n\t\t\t\t\t\t\troot->root_key.objectid,\n\t\t\t\t\t\t\tbtrfs_ino(inode),\n\t\t\t\t\t\t\tnew_key.offset - datao,\n\t\t\t\t\t\t\tno_quota);\n\t\t\t\t\tif (ret) {\n\t\t\t\t\t\tbtrfs_abort_transaction(trans,\n\t\t\t\t\t\t\t\t\troot,\n\t\t\t\t\t\t\t\t\tret);\n\t\t\t\t\t\tbtrfs_end_transaction(trans,\n\t\t\t\t\t\t\t\t      root);\n\t\t\t\t\t\tgoto out;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tu64 skip = 0;\n\t\t\t\tu64 trim = 0;\n\t\t\t\tu64 aligned_end = 0;\n\n\t\t\t\tif (off > key.offset) {\n\t\t\t\t\tskip = off - key.offset;\n\t\t\t\t\tnew_key.offset += skip;\n\t\t\t\t}\n\n\t\t\t\tif (key.offset + datal > off + len)\n\t\t\t\t\ttrim = key.offset + datal - (off + len);\n\n\t\t\t\tif (comp && (skip || trim)) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tsize -= skip + trim;\n\t\t\t\tdatal -= skip + trim;\n\n\t\t\t\taligned_end = ALIGN(new_key.offset + datal,\n\t\t\t\t\t\t    root->sectorsize);\n\t\t\t\tret = btrfs_drop_extents(trans, root, inode,\n\t\t\t\t\t\t\t drop_start,\n\t\t\t\t\t\t\t aligned_end,\n\t\t\t\t\t\t\t 1);\n\t\t\t\tif (ret) {\n\t\t\t\t\tif (ret != -EOPNOTSUPP)\n\t\t\t\t\t\tbtrfs_abort_transaction(trans,\n\t\t\t\t\t\t\troot, ret);\n\t\t\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tret = btrfs_insert_empty_item(trans, root, path,\n\t\t\t\t\t\t\t      &new_key, size);\n\t\t\t\tif (ret) {\n\t\t\t\t\tbtrfs_abort_transaction(trans, root,\n\t\t\t\t\t\t\t\tret);\n\t\t\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tif (skip) {\n\t\t\t\t\tu32 start =\n\t\t\t\t\t  btrfs_file_extent_calc_inline_size(0);\n\t\t\t\t\tmemmove(buf+start, buf+start+skip,\n\t\t\t\t\t\tdatal);\n\t\t\t\t}\n\n\t\t\t\tleaf = path->nodes[0];\n\t\t\t\tslot = path->slots[0];\n\t\t\t\twrite_extent_buffer(leaf, buf,\n\t\t\t\t\t    btrfs_item_ptr_offset(leaf, slot),\n\t\t\t\t\t    size);\n\t\t\t\tinode_add_bytes(inode, datal);\n\t\t\t}\n\n\t\t\t/* If we have an implicit hole (NO_HOLES feature). */\n\t\t\tif (drop_start < new_key.offset)\n\t\t\t\tclone_update_extent_map(inode, trans,\n\t\t\t\t\t\tNULL, drop_start,\n\t\t\t\t\t\tnew_key.offset - drop_start);\n\n\t\t\tclone_update_extent_map(inode, trans, path, 0, 0);\n\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t\tbtrfs_release_path(path);\n\n\t\t\tlast_dest_end = ALIGN(new_key.offset + datal,\n\t\t\t\t\t      root->sectorsize);\n\t\t\tret = clone_finish_inode_update(trans, inode,\n\t\t\t\t\t\t\tlast_dest_end,\n\t\t\t\t\t\t\tdestoff, olen);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tif (new_key.offset + datal >= destoff + len)\n\t\t\t\tbreak;\n\t\t}\n\t\tbtrfs_release_path(path);\n\t\tkey.offset++;\n\t}\n\tret = 0;\n\n\tif (last_dest_end < destoff + len) {\n\t\t/*\n\t\t * We have an implicit hole (NO_HOLES feature is enabled) that\n\t\t * fully or partially overlaps our cloning range at its end.\n\t\t */\n\t\tbtrfs_release_path(path);\n\n\t\t/*\n\t\t * 1 - remove extent(s)\n\t\t * 1 - inode update\n\t\t */\n\t\ttrans = btrfs_start_transaction(root, 2);\n\t\tif (IS_ERR(trans)) {\n\t\t\tret = PTR_ERR(trans);\n\t\t\tgoto out;\n\t\t}\n\t\tret = btrfs_drop_extents(trans, root, inode,\n\t\t\t\t\t last_dest_end, destoff + len, 1);\n\t\tif (ret) {\n\t\t\tif (ret != -EOPNOTSUPP)\n\t\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\tgoto out;\n\t\t}\n\t\tclone_update_extent_map(inode, trans, NULL, last_dest_end,\n\t\t\t\t\tdestoff + len - last_dest_end);\n\t\tret = clone_finish_inode_update(trans, inode, destoff + len,\n\t\t\t\t\t\tdestoff, olen);\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\tvfree(buf);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btrfs_clone(struct inode *src, struct inode *inode,\n\t\t       u64 off, u64 olen, u64 olen_aligned, u64 destoff);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "buf"
          ],
          "line": 3536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 3535
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clone_finish_inode_update",
          "args": [
            "trans",
            "inode",
            "destoff + len",
            "destoff",
            "olen"
          ],
          "line": 3530
        },
        "resolved": true,
        "details": {
          "function_name": "clone_finish_inode_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "3070-3099",
          "snippet": "static int clone_finish_inode_update(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     u64 endoff,\n\t\t\t\t     const u64 destoff,\n\t\t\t\t     const u64 olen)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tint ret;\n\n\tinode_inc_iversion(inode);\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t/*\n\t * We round up to the block size at eof when determining which\n\t * extents to clone above, but shouldn't round up the file size.\n\t */\n\tif (endoff > destoff + olen)\n\t\tendoff = destoff + olen;\n\tif (endoff > inode->i_size)\n\t\tbtrfs_i_size_write(inode, endoff);\n\n\tret = btrfs_update_inode(trans, root, inode);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tbtrfs_end_transaction(trans, root);\n\t\tgoto out;\n\t}\n\tret = btrfs_end_transaction(trans, root);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_clone(struct inode *src, struct inode *inode,\n\t\t       u64 off, u64 olen, u64 olen_aligned, u64 destoff);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_clone(struct inode *src, struct inode *inode,\n\t\t       u64 off, u64 olen, u64 olen_aligned, u64 destoff);\n\nstatic int clone_finish_inode_update(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     u64 endoff,\n\t\t\t\t     const u64 destoff,\n\t\t\t\t     const u64 olen)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tint ret;\n\n\tinode_inc_iversion(inode);\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t/*\n\t * We round up to the block size at eof when determining which\n\t * extents to clone above, but shouldn't round up the file size.\n\t */\n\tif (endoff > destoff + olen)\n\t\tendoff = destoff + olen;\n\tif (endoff > inode->i_size)\n\t\tbtrfs_i_size_write(inode, endoff);\n\n\tret = btrfs_update_inode(trans, root, inode);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tbtrfs_end_transaction(trans, root);\n\t\tgoto out;\n\t}\n\tret = btrfs_end_transaction(trans, root);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clone_update_extent_map",
          "args": [
            "inode",
            "trans",
            "NULL",
            "last_dest_end",
            "destoff + len - last_dest_end"
          ],
          "line": 3528
        },
        "resolved": true,
        "details": {
          "function_name": "clone_update_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "3101-3156",
          "snippet": "static void clone_update_extent_map(struct inode *inode,\n\t\t\t\t    const struct btrfs_trans_handle *trans,\n\t\t\t\t    const struct btrfs_path *path,\n\t\t\t\t    const u64 hole_offset,\n\t\t\t\t    const u64 hole_len)\n{\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tstruct extent_map *em;\n\tint ret;\n\n\tem = alloc_extent_map();\n\tif (!em) {\n\t\tset_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t&BTRFS_I(inode)->runtime_flags);\n\t\treturn;\n\t}\n\n\tif (path) {\n\t\tstruct btrfs_file_extent_item *fi;\n\n\t\tfi = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\tbtrfs_extent_item_to_extent_map(inode, path, fi, false, em);\n\t\tem->generation = -1;\n\t\tif (btrfs_file_extent_type(path->nodes[0], fi) ==\n\t\t    BTRFS_FILE_EXTENT_INLINE)\n\t\t\tset_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t\t&BTRFS_I(inode)->runtime_flags);\n\t} else {\n\t\tem->start = hole_offset;\n\t\tem->len = hole_len;\n\t\tem->ram_bytes = em->len;\n\t\tem->orig_start = hole_offset;\n\t\tem->block_start = EXTENT_MAP_HOLE;\n\t\tem->block_len = 0;\n\t\tem->orig_block_len = 0;\n\t\tem->compress_type = BTRFS_COMPRESS_NONE;\n\t\tem->generation = trans->transid;\n\t}\n\n\twhile (1) {\n\t\twrite_lock(&em_tree->lock);\n\t\tret = add_extent_mapping(em_tree, em, 1);\n\t\twrite_unlock(&em_tree->lock);\n\t\tif (ret != -EEXIST) {\n\t\t\tfree_extent_map(em);\n\t\t\tbreak;\n\t\t}\n\t\tbtrfs_drop_extent_cache(inode, em->start,\n\t\t\t\t\tem->start + em->len - 1, 0);\n\t}\n\n\tif (ret)\n\t\tset_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t&BTRFS_I(inode)->runtime_flags);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic void clone_update_extent_map(struct inode *inode,\n\t\t\t\t    const struct btrfs_trans_handle *trans,\n\t\t\t\t    const struct btrfs_path *path,\n\t\t\t\t    const u64 hole_offset,\n\t\t\t\t    const u64 hole_len)\n{\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tstruct extent_map *em;\n\tint ret;\n\n\tem = alloc_extent_map();\n\tif (!em) {\n\t\tset_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t&BTRFS_I(inode)->runtime_flags);\n\t\treturn;\n\t}\n\n\tif (path) {\n\t\tstruct btrfs_file_extent_item *fi;\n\n\t\tfi = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\tbtrfs_extent_item_to_extent_map(inode, path, fi, false, em);\n\t\tem->generation = -1;\n\t\tif (btrfs_file_extent_type(path->nodes[0], fi) ==\n\t\t    BTRFS_FILE_EXTENT_INLINE)\n\t\t\tset_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t\t&BTRFS_I(inode)->runtime_flags);\n\t} else {\n\t\tem->start = hole_offset;\n\t\tem->len = hole_len;\n\t\tem->ram_bytes = em->len;\n\t\tem->orig_start = hole_offset;\n\t\tem->block_start = EXTENT_MAP_HOLE;\n\t\tem->block_len = 0;\n\t\tem->orig_block_len = 0;\n\t\tem->compress_type = BTRFS_COMPRESS_NONE;\n\t\tem->generation = trans->transid;\n\t}\n\n\twhile (1) {\n\t\twrite_lock(&em_tree->lock);\n\t\tret = add_extent_mapping(em_tree, em, 1);\n\t\twrite_unlock(&em_tree->lock);\n\t\tif (ret != -EEXIST) {\n\t\t\tfree_extent_map(em);\n\t\t\tbreak;\n\t\t}\n\t\tbtrfs_drop_extent_cache(inode, em->start,\n\t\t\t\t\tem->start + em->len - 1, 0);\n\t}\n\n\tif (ret)\n\t\tset_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t&BTRFS_I(inode)->runtime_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_end_transaction",
          "args": [
            "trans",
            "root"
          ],
          "line": 3525
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_end_transaction_throttle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "846-850",
          "snippet": "int btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 3524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_drop_extents",
          "args": [
            "trans",
            "root",
            "inode",
            "last_dest_end",
            "destoff + len",
            "1"
          ],
          "line": 3520
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_drop_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
          "lines": "1013-1027",
          "snippet": "int btrfs_drop_extents(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root, struct inode *inode, u64 start,\n\t\t       u64 end, int drop_cache)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tret = __btrfs_drop_extents(trans, root, inode, path, start, end, NULL,\n\t\t\t\t   drop_cache, 0, 0, NULL);\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"volumes.h\"",
            "#include \"locking.h\"",
            "#include \"tree-log.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nint btrfs_drop_extents(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root, struct inode *inode, u64 start,\n\t\t       u64 end, int drop_cache)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tret = __btrfs_drop_extents(trans, root, inode, path, start, end, NULL,\n\t\t\t\t   drop_cache, 0, 0, NULL);\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 3517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 3516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_start_transaction",
          "args": [
            "root",
            "2"
          ],
          "line": 3515
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_transaction_lflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "569-574",
          "snippet": "struct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 3509
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "new_key.offset + datal",
            "root->sectorsize"
          ],
          "line": 3489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "leaf"
          ],
          "line": 3486
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_add_bytes",
          "args": [
            "inode",
            "datal"
          ],
          "line": 3475
        },
        "resolved": true,
        "details": {
          "function_name": "inode_add_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "460-465",
          "snippet": "void inode_add_bytes(struct inode *inode, loff_t bytes)\n{\n\tspin_lock(&inode->i_lock);\n\t__inode_add_bytes(inode, bytes);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid inode_add_bytes(struct inode *inode, loff_t bytes)\n{\n\tspin_lock(&inode->i_lock);\n\t__inode_add_bytes(inode, bytes);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_extent_buffer",
          "args": [
            "leaf",
            "buf",
            "btrfs_item_ptr_offset(leaf, slot)",
            "size"
          ],
          "line": 3472
        },
        "resolved": true,
        "details": {
          "function_name": "write_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5356-5385",
          "snippet": "void write_extent_buffer(struct extent_buffer *eb, const void *srcv,\n\t\t\t unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *src = (char *)srcv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemcpy(kaddr + offset, src, cur);\n\n\t\tsrc += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid write_extent_buffer(struct extent_buffer *eb, const void *srcv,\n\t\t\t unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *src = (char *)srcv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemcpy(kaddr + offset, src, cur);\n\n\t\tsrc += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr_offset",
          "args": [
            "leaf",
            "slot"
          ],
          "line": 3473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "buf+start",
            "buf+start+skip",
            "datal"
          ],
          "line": 3466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_calc_inline_size",
          "args": [
            "0"
          ],
          "line": 3465
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_file_extent_calc_inline_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3101-3104",
          "snippet": "static inline u32 btrfs_file_extent_calc_inline_size(u32 datasize)\n{\n\treturn BTRFS_FILE_EXTENT_INLINE_DATA_START + datasize;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_FILE_EXTENT_INLINE_DATA_START\t\t\\\n\t\t(offsetof(struct btrfs_file_extent_item, disk_bytenr))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_FILE_EXTENT_INLINE_DATA_START\t\t\\\n\t\t(offsetof(struct btrfs_file_extent_item, disk_bytenr))\n\nstatic inline u32 btrfs_file_extent_calc_inline_size(u32 datasize)\n{\n\treturn BTRFS_FILE_EXTENT_INLINE_DATA_START + datasize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 3457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_insert_empty_item",
          "args": [
            "trans",
            "root",
            "path",
            "&new_key",
            "size"
          ],
          "line": 3454
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_empty_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3579-3586",
          "snippet": "static inline int btrfs_insert_empty_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  struct btrfs_key *key,\n\t\t\t\t\t  u32 data_size)\n{\n\treturn btrfs_insert_empty_items(trans, root, path, key, &data_size, 1);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_insert_empty_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  struct btrfs_key *key,\n\t\t\t\t\t  u32 data_size)\n{\n\treturn btrfs_insert_empty_items(trans, root, path, key, &data_size, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 3448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "new_key.offset + datal",
            "root->sectorsize"
          ],
          "line": 3440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 3410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inc_extent_ref",
          "args": [
            "trans",
            "root",
            "disko",
            "diskl",
            "0",
            "root->root_key.objectid",
            "btrfs_ino(inode)",
            "new_key.offset - datao",
            "no_quota"
          ],
          "line": 3403
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inc_extent_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "1942-1966",
          "snippet": "int btrfs_inc_extent_ref(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_root *root,\n\t\t\t u64 bytenr, u64 num_bytes, u64 parent,\n\t\t\t u64 root_objectid, u64 owner, u64 offset,\n\t\t\t int no_quota)\n{\n\tint ret;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tBUG_ON(owner < BTRFS_FIRST_FREE_OBJECTID &&\n\t       root_objectid == BTRFS_TREE_LOG_OBJECTID);\n\n\tif (owner < BTRFS_FIRST_FREE_OBJECTID) {\n\t\tret = btrfs_add_delayed_tree_ref(fs_info, trans, bytenr,\n\t\t\t\t\tnum_bytes,\n\t\t\t\t\tparent, root_objectid, (int)owner,\n\t\t\t\t\tBTRFS_ADD_DELAYED_REF, NULL, no_quota);\n\t} else {\n\t\tret = btrfs_add_delayed_data_ref(fs_info, trans, bytenr,\n\t\t\t\t\tnum_bytes,\n\t\t\t\t\tparent, root_objectid, owner, offset,\n\t\t\t\t\tBTRFS_ADD_DELAYED_REF, NULL, no_quota);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __btrfs_free_extent(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tu64 bytenr, u64 num_bytes, u64 parent,\n\t\t\t\tu64 root_objectid, u64 owner_objectid,\n\t\t\t\tu64 owner_offset, int refs_to_drop,\n\t\t\t\tstruct btrfs_delayed_extent_op *extra_op,\n\t\t\t\tint no_quota);",
            "static int alloc_reserved_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t     u64 parent, u64 root_objectid,\n\t\t\t\t     u64 flags, struct btrfs_disk_key *key,\n\t\t\t\t     int level, struct btrfs_key *ins,\n\t\t\t\t     int no_quota);",
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int __btrfs_free_extent(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tu64 bytenr, u64 num_bytes, u64 parent,\n\t\t\t\tu64 root_objectid, u64 owner_objectid,\n\t\t\t\tu64 owner_offset, int refs_to_drop,\n\t\t\t\tstruct btrfs_delayed_extent_op *extra_op,\n\t\t\t\tint no_quota);\nstatic int alloc_reserved_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t     u64 parent, u64 root_objectid,\n\t\t\t\t     u64 flags, struct btrfs_disk_key *key,\n\t\t\t\t     int level, struct btrfs_key *ins,\n\t\t\t\t     int no_quota);\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nstatic noinline struct;\n\nint btrfs_inc_extent_ref(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_root *root,\n\t\t\t u64 bytenr, u64 num_bytes, u64 parent,\n\t\t\t u64 root_objectid, u64 owner, u64 offset,\n\t\t\t int no_quota)\n{\n\tint ret;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tBUG_ON(owner < BTRFS_FIRST_FREE_OBJECTID &&\n\t       root_objectid == BTRFS_TREE_LOG_OBJECTID);\n\n\tif (owner < BTRFS_FIRST_FREE_OBJECTID) {\n\t\tret = btrfs_add_delayed_tree_ref(fs_info, trans, bytenr,\n\t\t\t\t\tnum_bytes,\n\t\t\t\t\tparent, root_objectid, (int)owner,\n\t\t\t\t\tBTRFS_ADD_DELAYED_REF, NULL, no_quota);\n\t} else {\n\t\tret = btrfs_add_delayed_data_ref(fs_info, trans, bytenr,\n\t\t\t\t\tnum_bytes,\n\t\t\t\t\tparent, root_objectid, owner, offset,\n\t\t\t\t\tBTRFS_ADD_DELAYED_REF, NULL, no_quota);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ino",
          "args": [
            "inode"
          ],
          "line": 3406
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_resume_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "311-316",
          "snippet": "static inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [
            "#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\n#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10\n\nstatic inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 3391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_ref",
          "args": [
            "trans",
            "root",
            "disko"
          ],
          "line": 3388
        },
        "resolved": true,
        "details": {
          "function_name": "check_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "3039-3068",
          "snippet": "static int check_ref(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t     u64 disko)\n{\n\tstruct seq_list tree_mod_seq_elem = {};\n\tstruct ulist *roots;\n\tstruct ulist_iterator uiter;\n\tstruct ulist_node *root_node = NULL;\n\tint ret;\n\n\tif (!root->fs_info->quota_enabled)\n\t\treturn 1;\n\n\tbtrfs_get_tree_mod_seq(root->fs_info, &tree_mod_seq_elem);\n\tret = btrfs_find_all_roots(trans, root->fs_info, disko,\n\t\t\t\t   tree_mod_seq_elem.seq, &roots);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = 0;\n\tULIST_ITER_INIT(&uiter);\n\twhile ((root_node = ulist_next(roots, &uiter))) {\n\t\tif (root_node->val == root->objectid) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tulist_free(roots);\nout:\n\tbtrfs_put_tree_mod_seq(root->fs_info, &tree_mod_seq_elem);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int check_ref(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t     u64 disko)\n{\n\tstruct seq_list tree_mod_seq_elem = {};\n\tstruct ulist *roots;\n\tstruct ulist_iterator uiter;\n\tstruct ulist_node *root_node = NULL;\n\tint ret;\n\n\tif (!root->fs_info->quota_enabled)\n\t\treturn 1;\n\n\tbtrfs_get_tree_mod_seq(root->fs_info, &tree_mod_seq_elem);\n\tret = btrfs_find_all_roots(trans, root->fs_info, disko,\n\t\t\t\t   tree_mod_seq_elem.seq, &roots);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = 0;\n\tULIST_ITER_INIT(&uiter);\n\twhile ((root_node = ulist_next(roots, &uiter))) {\n\t\tif (root_node->val == root->objectid) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tulist_free(roots);\nout:\n\tbtrfs_put_tree_mod_seq(root->fs_info, &tree_mod_seq_elem);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "src"
          ],
          "line": 3386
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_num_bytes",
          "args": [
            "leaf",
            "extent",
            "datal"
          ],
          "line": 3377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_offset",
          "args": [
            "leaf",
            "extent",
            "datao"
          ],
          "line": 3375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "slot",
            "structbtrfs_file_extent_item"
          ],
          "line": 3368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr_offset",
          "args": [
            "leaf",
            "slot"
          ],
          "line": 3365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 3356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 3347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 3320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 3319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&new_key",
            "&key",
            "sizeof(new_key)"
          ],
          "line": 3294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_extent_buffer",
          "args": [
            "leaf",
            "buf",
            "btrfs_item_ptr_offset(leaf, slot)",
            "size"
          ],
          "line": 3287
        },
        "resolved": true,
        "details": {
          "function_name": "btree_read_extent_buffer_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "442-497",
          "snippet": "static int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr_offset",
          "args": [
            "leaf",
            "slot"
          ],
          "line": 3288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_size_nr",
          "args": [
            "leaf",
            "slot"
          ],
          "line": 3286
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_ram_bytes",
          "args": [
            "leaf",
            "extent"
          ],
          "line": 3270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_num_bytes",
          "args": [
            "leaf",
            "extent"
          ],
          "line": 3266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_offset",
          "args": [
            "leaf",
            "extent"
          ],
          "line": 3265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_disk_num_bytes",
          "args": [
            "leaf",
            "extent"
          ],
          "line": 3263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_disk_bytenr",
          "args": [
            "leaf",
            "extent"
          ],
          "line": 3261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_type",
          "args": [
            "leaf",
            "extent"
          ],
          "line": 3258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_compression",
          "args": [
            "leaf",
            "extent"
          ],
          "line": 3257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "slot",
            "structbtrfs_file_extent_item"
          ],
          "line": 3255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "leaf",
            "&key",
            "slot"
          ],
          "line": 3240
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "path->nodes[0]"
          ],
          "line": 3235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_next_leaf",
          "args": [
            "BTRFS_I(src)->root",
            "path"
          ],
          "line": 3230
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_next_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5646-5649",
          "snippet": "int btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "path->nodes[0]"
          ],
          "line": 3226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "BTRFS_I(src)->root",
            "&key",
            "path",
            "0",
            "0"
          ],
          "line": 3210
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "buf"
          ],
          "line": 3194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 3192
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmalloc",
          "args": [
            "root->nodesize"
          ],
          "line": 3188
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_blocks_use_vmalloc(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.h",
          "lines": "292-295",
          "snippet": "tatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"os-linux.h\"\n#",
            "include \"os-ecos.h\"\n#",
            "include \"summary.h\"",
            "include \"acl.h\"\n#",
            "include \"xattr.h\"\n#",
            "include \"jffs2_fs_i.h\"\n#",
            "include \"jffs2_fs_sb.h\"\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/types.h>\n#",
            "include <linux/fs.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"os-linux.h\"\n#\ninclude \"os-ecos.h\"\n#\ninclude \"summary.h\"\ninclude \"acl.h\"\n#\ninclude \"xattr.h\"\n#\ninclude \"jffs2_fs_i.h\"\n#\ninclude \"jffs2_fs_sb.h\"\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/types.h>\n#\ninclude <linux/fs.h>\n#\n\ntatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_clone(struct inode *src, struct inode *inode,\n\t\t       u64 off, u64 olen, u64 olen_aligned, u64 destoff);\n\nstatic int btrfs_clone(struct inode *src, struct inode *inode,\n\t\t       const u64 off, const u64 olen, const u64 olen_aligned,\n\t\t       const u64 destoff)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_path *path = NULL;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_trans_handle *trans;\n\tchar *buf = NULL;\n\tstruct btrfs_key key;\n\tu32 nritems;\n\tint slot;\n\tint ret;\n\tint no_quota;\n\tconst u64 len = olen_aligned;\n\tu64 last_disko = 0;\n\tu64 last_dest_end = destoff;\n\n\tret = -ENOMEM;\n\tbuf = vmalloc(root->nodesize);\n\tif (!buf)\n\t\treturn ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tvfree(buf);\n\t\treturn ret;\n\t}\n\n\tpath->reada = 2;\n\t/* clone data */\n\tkey.objectid = btrfs_ino(src);\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = off;\n\n\twhile (1) {\n\t\t/*\n\t\t * note the key will change type as we walk through the\n\t\t * tree.\n\t\t */\n\t\tpath->leave_spinning = 1;\n\t\tret = btrfs_search_slot(NULL, BTRFS_I(src)->root, &key, path,\n\t\t\t\t0, 0);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\t/*\n\t\t * First search, if no extent item that starts at offset off was\n\t\t * found but the previous item is an extent item, it's possible\n\t\t * it might overlap our target range, therefore process it.\n\t\t */\n\t\tif (key.offset == off && ret > 0 && path->slots[0] > 0) {\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key,\n\t\t\t\t\t      path->slots[0] - 1);\n\t\t\tif (key.type == BTRFS_EXTENT_DATA_KEY)\n\t\t\t\tpath->slots[0]--;\n\t\t}\n\n\t\tnritems = btrfs_header_nritems(path->nodes[0]);\nprocess_slot:\n\t\tno_quota = 1;\n\t\tif (path->slots[0] >= nritems) {\n\t\t\tret = btrfs_next_leaf(BTRFS_I(src)->root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret > 0)\n\t\t\t\tbreak;\n\t\t\tnritems = btrfs_header_nritems(path->nodes[0]);\n\t\t}\n\t\tleaf = path->nodes[0];\n\t\tslot = path->slots[0];\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\t\tif (key.type > BTRFS_EXTENT_DATA_KEY ||\n\t\t    key.objectid != btrfs_ino(src))\n\t\t\tbreak;\n\n\t\tif (key.type == BTRFS_EXTENT_DATA_KEY) {\n\t\t\tstruct btrfs_file_extent_item *extent;\n\t\t\tint type;\n\t\t\tu32 size;\n\t\t\tstruct btrfs_key new_key;\n\t\t\tu64 disko = 0, diskl = 0;\n\t\t\tu64 datao = 0, datal = 0;\n\t\t\tu8 comp;\n\t\t\tu64 drop_start;\n\n\t\t\textent = btrfs_item_ptr(leaf, slot,\n\t\t\t\t\t\tstruct btrfs_file_extent_item);\n\t\t\tcomp = btrfs_file_extent_compression(leaf, extent);\n\t\t\ttype = btrfs_file_extent_type(leaf, extent);\n\t\t\tif (type == BTRFS_FILE_EXTENT_REG ||\n\t\t\t    type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\t\t\tdisko = btrfs_file_extent_disk_bytenr(leaf,\n\t\t\t\t\t\t\t\t      extent);\n\t\t\t\tdiskl = btrfs_file_extent_disk_num_bytes(leaf,\n\t\t\t\t\t\t\t\t extent);\n\t\t\t\tdatao = btrfs_file_extent_offset(leaf, extent);\n\t\t\t\tdatal = btrfs_file_extent_num_bytes(leaf,\n\t\t\t\t\t\t\t\t    extent);\n\t\t\t} else if (type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\t/* take upper bound, may be compressed */\n\t\t\t\tdatal = btrfs_file_extent_ram_bytes(leaf,\n\t\t\t\t\t\t\t\t    extent);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The first search might have left us at an extent\n\t\t\t * item that ends before our target range's start, can\n\t\t\t * happen if we have holes and NO_HOLES feature enabled.\n\t\t\t */\n\t\t\tif (key.offset + datal <= off) {\n\t\t\t\tpath->slots[0]++;\n\t\t\t\tgoto process_slot;\n\t\t\t} else if (key.offset >= off + len) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tsize = btrfs_item_size_nr(leaf, slot);\n\t\t\tread_extent_buffer(leaf, buf,\n\t\t\t\t\t   btrfs_item_ptr_offset(leaf, slot),\n\t\t\t\t\t   size);\n\n\t\t\tbtrfs_release_path(path);\n\t\t\tpath->leave_spinning = 0;\n\n\t\t\tmemcpy(&new_key, &key, sizeof(new_key));\n\t\t\tnew_key.objectid = btrfs_ino(inode);\n\t\t\tif (off <= key.offset)\n\t\t\t\tnew_key.offset = key.offset + destoff - off;\n\t\t\telse\n\t\t\t\tnew_key.offset = destoff;\n\n\t\t\t/*\n\t\t\t * Deal with a hole that doesn't have an extent item\n\t\t\t * that represents it (NO_HOLES feature enabled).\n\t\t\t * This hole is either in the middle of the cloning\n\t\t\t * range or at the beginning (fully overlaps it or\n\t\t\t * partially overlaps it).\n\t\t\t */\n\t\t\tif (new_key.offset != last_dest_end)\n\t\t\t\tdrop_start = last_dest_end;\n\t\t\telse\n\t\t\t\tdrop_start = new_key.offset;\n\n\t\t\t/*\n\t\t\t * 1 - adjusting old extent (we may have to split it)\n\t\t\t * 1 - add new extent\n\t\t\t * 1 - inode update\n\t\t\t */\n\t\t\ttrans = btrfs_start_transaction(root, 3);\n\t\t\tif (IS_ERR(trans)) {\n\t\t\t\tret = PTR_ERR(trans);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (type == BTRFS_FILE_EXTENT_REG ||\n\t\t\t    type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\t\t\t/*\n\t\t\t\t *    a  | --- range to clone ---|  b\n\t\t\t\t * | ------------- extent ------------- |\n\t\t\t\t */\n\n\t\t\t\t/* subtract range b */\n\t\t\t\tif (key.offset + datal > off + len)\n\t\t\t\t\tdatal = off + len - key.offset;\n\n\t\t\t\t/* subtract range a */\n\t\t\t\tif (off > key.offset) {\n\t\t\t\t\tdatao += off - key.offset;\n\t\t\t\t\tdatal -= off - key.offset;\n\t\t\t\t}\n\n\t\t\t\tret = btrfs_drop_extents(trans, root, inode,\n\t\t\t\t\t\t\t drop_start,\n\t\t\t\t\t\t\t new_key.offset + datal,\n\t\t\t\t\t\t\t 1);\n\t\t\t\tif (ret) {\n\t\t\t\t\tif (ret != -EOPNOTSUPP)\n\t\t\t\t\t\tbtrfs_abort_transaction(trans,\n\t\t\t\t\t\t\t\troot, ret);\n\t\t\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tret = btrfs_insert_empty_item(trans, root, path,\n\t\t\t\t\t\t\t      &new_key, size);\n\t\t\t\tif (ret) {\n\t\t\t\t\tbtrfs_abort_transaction(trans, root,\n\t\t\t\t\t\t\t\tret);\n\t\t\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tleaf = path->nodes[0];\n\t\t\t\tslot = path->slots[0];\n\t\t\t\twrite_extent_buffer(leaf, buf,\n\t\t\t\t\t    btrfs_item_ptr_offset(leaf, slot),\n\t\t\t\t\t    size);\n\n\t\t\t\textent = btrfs_item_ptr(leaf, slot,\n\t\t\t\t\t\tstruct btrfs_file_extent_item);\n\n\t\t\t\t/* disko == 0 means it's a hole */\n\t\t\t\tif (!disko)\n\t\t\t\t\tdatao = 0;\n\n\t\t\t\tbtrfs_set_file_extent_offset(leaf, extent,\n\t\t\t\t\t\t\t     datao);\n\t\t\t\tbtrfs_set_file_extent_num_bytes(leaf, extent,\n\t\t\t\t\t\t\t\tdatal);\n\n\t\t\t\t/*\n\t\t\t\t * We need to look up the roots that point at\n\t\t\t\t * this bytenr and see if the new root does.  If\n\t\t\t\t * it does not we need to make sure we update\n\t\t\t\t * quotas appropriately.\n\t\t\t\t */\n\t\t\t\tif (disko && root != BTRFS_I(src)->root &&\n\t\t\t\t    disko != last_disko) {\n\t\t\t\t\tno_quota = check_ref(trans, root,\n\t\t\t\t\t\t\t     disko);\n\t\t\t\t\tif (no_quota < 0) {\n\t\t\t\t\t\tbtrfs_abort_transaction(trans,\n\t\t\t\t\t\t\t\t\troot,\n\t\t\t\t\t\t\t\t\tret);\n\t\t\t\t\t\tbtrfs_end_transaction(trans,\n\t\t\t\t\t\t\t\t      root);\n\t\t\t\t\t\tret = no_quota;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (disko) {\n\t\t\t\t\tinode_add_bytes(inode, datal);\n\t\t\t\t\tret = btrfs_inc_extent_ref(trans, root,\n\t\t\t\t\t\t\tdisko, diskl, 0,\n\t\t\t\t\t\t\troot->root_key.objectid,\n\t\t\t\t\t\t\tbtrfs_ino(inode),\n\t\t\t\t\t\t\tnew_key.offset - datao,\n\t\t\t\t\t\t\tno_quota);\n\t\t\t\t\tif (ret) {\n\t\t\t\t\t\tbtrfs_abort_transaction(trans,\n\t\t\t\t\t\t\t\t\troot,\n\t\t\t\t\t\t\t\t\tret);\n\t\t\t\t\t\tbtrfs_end_transaction(trans,\n\t\t\t\t\t\t\t\t      root);\n\t\t\t\t\t\tgoto out;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tu64 skip = 0;\n\t\t\t\tu64 trim = 0;\n\t\t\t\tu64 aligned_end = 0;\n\n\t\t\t\tif (off > key.offset) {\n\t\t\t\t\tskip = off - key.offset;\n\t\t\t\t\tnew_key.offset += skip;\n\t\t\t\t}\n\n\t\t\t\tif (key.offset + datal > off + len)\n\t\t\t\t\ttrim = key.offset + datal - (off + len);\n\n\t\t\t\tif (comp && (skip || trim)) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tsize -= skip + trim;\n\t\t\t\tdatal -= skip + trim;\n\n\t\t\t\taligned_end = ALIGN(new_key.offset + datal,\n\t\t\t\t\t\t    root->sectorsize);\n\t\t\t\tret = btrfs_drop_extents(trans, root, inode,\n\t\t\t\t\t\t\t drop_start,\n\t\t\t\t\t\t\t aligned_end,\n\t\t\t\t\t\t\t 1);\n\t\t\t\tif (ret) {\n\t\t\t\t\tif (ret != -EOPNOTSUPP)\n\t\t\t\t\t\tbtrfs_abort_transaction(trans,\n\t\t\t\t\t\t\troot, ret);\n\t\t\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tret = btrfs_insert_empty_item(trans, root, path,\n\t\t\t\t\t\t\t      &new_key, size);\n\t\t\t\tif (ret) {\n\t\t\t\t\tbtrfs_abort_transaction(trans, root,\n\t\t\t\t\t\t\t\tret);\n\t\t\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tif (skip) {\n\t\t\t\t\tu32 start =\n\t\t\t\t\t  btrfs_file_extent_calc_inline_size(0);\n\t\t\t\t\tmemmove(buf+start, buf+start+skip,\n\t\t\t\t\t\tdatal);\n\t\t\t\t}\n\n\t\t\t\tleaf = path->nodes[0];\n\t\t\t\tslot = path->slots[0];\n\t\t\t\twrite_extent_buffer(leaf, buf,\n\t\t\t\t\t    btrfs_item_ptr_offset(leaf, slot),\n\t\t\t\t\t    size);\n\t\t\t\tinode_add_bytes(inode, datal);\n\t\t\t}\n\n\t\t\t/* If we have an implicit hole (NO_HOLES feature). */\n\t\t\tif (drop_start < new_key.offset)\n\t\t\t\tclone_update_extent_map(inode, trans,\n\t\t\t\t\t\tNULL, drop_start,\n\t\t\t\t\t\tnew_key.offset - drop_start);\n\n\t\t\tclone_update_extent_map(inode, trans, path, 0, 0);\n\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t\tbtrfs_release_path(path);\n\n\t\t\tlast_dest_end = ALIGN(new_key.offset + datal,\n\t\t\t\t\t      root->sectorsize);\n\t\t\tret = clone_finish_inode_update(trans, inode,\n\t\t\t\t\t\t\tlast_dest_end,\n\t\t\t\t\t\t\tdestoff, olen);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tif (new_key.offset + datal >= destoff + len)\n\t\t\t\tbreak;\n\t\t}\n\t\tbtrfs_release_path(path);\n\t\tkey.offset++;\n\t}\n\tret = 0;\n\n\tif (last_dest_end < destoff + len) {\n\t\t/*\n\t\t * We have an implicit hole (NO_HOLES feature is enabled) that\n\t\t * fully or partially overlaps our cloning range at its end.\n\t\t */\n\t\tbtrfs_release_path(path);\n\n\t\t/*\n\t\t * 1 - remove extent(s)\n\t\t * 1 - inode update\n\t\t */\n\t\ttrans = btrfs_start_transaction(root, 2);\n\t\tif (IS_ERR(trans)) {\n\t\t\tret = PTR_ERR(trans);\n\t\t\tgoto out;\n\t\t}\n\t\tret = btrfs_drop_extents(trans, root, inode,\n\t\t\t\t\t last_dest_end, destoff + len, 1);\n\t\tif (ret) {\n\t\t\tif (ret != -EOPNOTSUPP)\n\t\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\tgoto out;\n\t\t}\n\t\tclone_update_extent_map(inode, trans, NULL, last_dest_end,\n\t\t\t\t\tdestoff + len - last_dest_end);\n\t\tret = clone_finish_inode_update(trans, inode, destoff + len,\n\t\t\t\t\t\tdestoff, olen);\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\tvfree(buf);\n\treturn ret;\n}"
  },
  {
    "function_name": "clone_update_extent_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "3101-3156",
    "snippet": "static void clone_update_extent_map(struct inode *inode,\n\t\t\t\t    const struct btrfs_trans_handle *trans,\n\t\t\t\t    const struct btrfs_path *path,\n\t\t\t\t    const u64 hole_offset,\n\t\t\t\t    const u64 hole_len)\n{\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tstruct extent_map *em;\n\tint ret;\n\n\tem = alloc_extent_map();\n\tif (!em) {\n\t\tset_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t&BTRFS_I(inode)->runtime_flags);\n\t\treturn;\n\t}\n\n\tif (path) {\n\t\tstruct btrfs_file_extent_item *fi;\n\n\t\tfi = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\tbtrfs_extent_item_to_extent_map(inode, path, fi, false, em);\n\t\tem->generation = -1;\n\t\tif (btrfs_file_extent_type(path->nodes[0], fi) ==\n\t\t    BTRFS_FILE_EXTENT_INLINE)\n\t\t\tset_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t\t&BTRFS_I(inode)->runtime_flags);\n\t} else {\n\t\tem->start = hole_offset;\n\t\tem->len = hole_len;\n\t\tem->ram_bytes = em->len;\n\t\tem->orig_start = hole_offset;\n\t\tem->block_start = EXTENT_MAP_HOLE;\n\t\tem->block_len = 0;\n\t\tem->orig_block_len = 0;\n\t\tem->compress_type = BTRFS_COMPRESS_NONE;\n\t\tem->generation = trans->transid;\n\t}\n\n\twhile (1) {\n\t\twrite_lock(&em_tree->lock);\n\t\tret = add_extent_mapping(em_tree, em, 1);\n\t\twrite_unlock(&em_tree->lock);\n\t\tif (ret != -EEXIST) {\n\t\t\tfree_extent_map(em);\n\t\t\tbreak;\n\t\t}\n\t\tbtrfs_drop_extent_cache(inode, em->start,\n\t\t\t\t\tem->start + em->len - 1, 0);\n\t}\n\n\tif (ret)\n\t\tset_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t&BTRFS_I(inode)->runtime_flags);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "BTRFS_INODE_NEEDS_FULL_SYNC",
            "&BTRFS_I(inode)->runtime_flags"
          ],
          "line": 3154
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 3155
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_drop_extent_cache",
          "args": [
            "inode",
            "em->start",
            "em->start + em->len - 1",
            "0"
          ],
          "line": 3149
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_drop_extent_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
          "lines": "535-684",
          "snippet": "void btrfs_drop_extent_cache(struct inode *inode, u64 start, u64 end,\n\t\t\t     int skip_pinned)\n{\n\tstruct extent_map *em;\n\tstruct extent_map *split = NULL;\n\tstruct extent_map *split2 = NULL;\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tu64 len = end - start + 1;\n\tu64 gen;\n\tint ret;\n\tint testend = 1;\n\tunsigned long flags;\n\tint compressed = 0;\n\tbool modified;\n\n\tWARN_ON(end < start);\n\tif (end == (u64)-1) {\n\t\tlen = (u64)-1;\n\t\ttestend = 0;\n\t}\n\twhile (1) {\n\t\tint no_splits = 0;\n\n\t\tmodified = false;\n\t\tif (!split)\n\t\t\tsplit = alloc_extent_map();\n\t\tif (!split2)\n\t\t\tsplit2 = alloc_extent_map();\n\t\tif (!split || !split2)\n\t\t\tno_splits = 1;\n\n\t\twrite_lock(&em_tree->lock);\n\t\tem = lookup_extent_mapping(em_tree, start, len);\n\t\tif (!em) {\n\t\t\twrite_unlock(&em_tree->lock);\n\t\t\tbreak;\n\t\t}\n\t\tflags = em->flags;\n\t\tgen = em->generation;\n\t\tif (skip_pinned && test_bit(EXTENT_FLAG_PINNED, &em->flags)) {\n\t\t\tif (testend && em->start + em->len >= start + len) {\n\t\t\t\tfree_extent_map(em);\n\t\t\t\twrite_unlock(&em_tree->lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstart = em->start + em->len;\n\t\t\tif (testend)\n\t\t\t\tlen = start + len - (em->start + em->len);\n\t\t\tfree_extent_map(em);\n\t\t\twrite_unlock(&em_tree->lock);\n\t\t\tcontinue;\n\t\t}\n\t\tcompressed = test_bit(EXTENT_FLAG_COMPRESSED, &em->flags);\n\t\tclear_bit(EXTENT_FLAG_PINNED, &em->flags);\n\t\tclear_bit(EXTENT_FLAG_LOGGING, &flags);\n\t\tmodified = !list_empty(&em->list);\n\t\tif (no_splits)\n\t\t\tgoto next;\n\n\t\tif (em->start < start) {\n\t\t\tsplit->start = em->start;\n\t\t\tsplit->len = start - em->start;\n\n\t\t\tif (em->block_start < EXTENT_MAP_LAST_BYTE) {\n\t\t\t\tsplit->orig_start = em->orig_start;\n\t\t\t\tsplit->block_start = em->block_start;\n\n\t\t\t\tif (compressed)\n\t\t\t\t\tsplit->block_len = em->block_len;\n\t\t\t\telse\n\t\t\t\t\tsplit->block_len = split->len;\n\t\t\t\tsplit->orig_block_len = max(split->block_len,\n\t\t\t\t\t\tem->orig_block_len);\n\t\t\t\tsplit->ram_bytes = em->ram_bytes;\n\t\t\t} else {\n\t\t\t\tsplit->orig_start = split->start;\n\t\t\t\tsplit->block_len = 0;\n\t\t\t\tsplit->block_start = em->block_start;\n\t\t\t\tsplit->orig_block_len = 0;\n\t\t\t\tsplit->ram_bytes = split->len;\n\t\t\t}\n\n\t\t\tsplit->generation = gen;\n\t\t\tsplit->bdev = em->bdev;\n\t\t\tsplit->flags = flags;\n\t\t\tsplit->compress_type = em->compress_type;\n\t\t\treplace_extent_mapping(em_tree, em, split, modified);\n\t\t\tfree_extent_map(split);\n\t\t\tsplit = split2;\n\t\t\tsplit2 = NULL;\n\t\t}\n\t\tif (testend && em->start + em->len > start + len) {\n\t\t\tu64 diff = start + len - em->start;\n\n\t\t\tsplit->start = start + len;\n\t\t\tsplit->len = em->start + em->len - (start + len);\n\t\t\tsplit->bdev = em->bdev;\n\t\t\tsplit->flags = flags;\n\t\t\tsplit->compress_type = em->compress_type;\n\t\t\tsplit->generation = gen;\n\n\t\t\tif (em->block_start < EXTENT_MAP_LAST_BYTE) {\n\t\t\t\tsplit->orig_block_len = max(em->block_len,\n\t\t\t\t\t\t    em->orig_block_len);\n\n\t\t\t\tsplit->ram_bytes = em->ram_bytes;\n\t\t\t\tif (compressed) {\n\t\t\t\t\tsplit->block_len = em->block_len;\n\t\t\t\t\tsplit->block_start = em->block_start;\n\t\t\t\t\tsplit->orig_start = em->orig_start;\n\t\t\t\t} else {\n\t\t\t\t\tsplit->block_len = split->len;\n\t\t\t\t\tsplit->block_start = em->block_start\n\t\t\t\t\t\t+ diff;\n\t\t\t\t\tsplit->orig_start = em->orig_start;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsplit->ram_bytes = split->len;\n\t\t\t\tsplit->orig_start = split->start;\n\t\t\t\tsplit->block_len = 0;\n\t\t\t\tsplit->block_start = em->block_start;\n\t\t\t\tsplit->orig_block_len = 0;\n\t\t\t}\n\n\t\t\tif (extent_map_in_tree(em)) {\n\t\t\t\treplace_extent_mapping(em_tree, em, split,\n\t\t\t\t\t\t       modified);\n\t\t\t} else {\n\t\t\t\tret = add_extent_mapping(em_tree, split,\n\t\t\t\t\t\t\t modified);\n\t\t\t\tASSERT(ret == 0); /* Logic error */\n\t\t\t}\n\t\t\tfree_extent_map(split);\n\t\t\tsplit = NULL;\n\t\t}\nnext:\n\t\tif (extent_map_in_tree(em))\n\t\t\tremove_extent_mapping(em_tree, em);\n\t\twrite_unlock(&em_tree->lock);\n\n\t\t/* once for us */\n\t\tfree_extent_map(em);\n\t\t/* once for the tree*/\n\t\tfree_extent_map(em);\n\t}\n\tif (split)\n\t\tfree_extent_map(split);\n\tif (split2)\n\t\tfree_extent_map(split2);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"volumes.h\"",
            "#include \"locking.h\"",
            "#include \"tree-log.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nvoid btrfs_drop_extent_cache(struct inode *inode, u64 start, u64 end,\n\t\t\t     int skip_pinned)\n{\n\tstruct extent_map *em;\n\tstruct extent_map *split = NULL;\n\tstruct extent_map *split2 = NULL;\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tu64 len = end - start + 1;\n\tu64 gen;\n\tint ret;\n\tint testend = 1;\n\tunsigned long flags;\n\tint compressed = 0;\n\tbool modified;\n\n\tWARN_ON(end < start);\n\tif (end == (u64)-1) {\n\t\tlen = (u64)-1;\n\t\ttestend = 0;\n\t}\n\twhile (1) {\n\t\tint no_splits = 0;\n\n\t\tmodified = false;\n\t\tif (!split)\n\t\t\tsplit = alloc_extent_map();\n\t\tif (!split2)\n\t\t\tsplit2 = alloc_extent_map();\n\t\tif (!split || !split2)\n\t\t\tno_splits = 1;\n\n\t\twrite_lock(&em_tree->lock);\n\t\tem = lookup_extent_mapping(em_tree, start, len);\n\t\tif (!em) {\n\t\t\twrite_unlock(&em_tree->lock);\n\t\t\tbreak;\n\t\t}\n\t\tflags = em->flags;\n\t\tgen = em->generation;\n\t\tif (skip_pinned && test_bit(EXTENT_FLAG_PINNED, &em->flags)) {\n\t\t\tif (testend && em->start + em->len >= start + len) {\n\t\t\t\tfree_extent_map(em);\n\t\t\t\twrite_unlock(&em_tree->lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstart = em->start + em->len;\n\t\t\tif (testend)\n\t\t\t\tlen = start + len - (em->start + em->len);\n\t\t\tfree_extent_map(em);\n\t\t\twrite_unlock(&em_tree->lock);\n\t\t\tcontinue;\n\t\t}\n\t\tcompressed = test_bit(EXTENT_FLAG_COMPRESSED, &em->flags);\n\t\tclear_bit(EXTENT_FLAG_PINNED, &em->flags);\n\t\tclear_bit(EXTENT_FLAG_LOGGING, &flags);\n\t\tmodified = !list_empty(&em->list);\n\t\tif (no_splits)\n\t\t\tgoto next;\n\n\t\tif (em->start < start) {\n\t\t\tsplit->start = em->start;\n\t\t\tsplit->len = start - em->start;\n\n\t\t\tif (em->block_start < EXTENT_MAP_LAST_BYTE) {\n\t\t\t\tsplit->orig_start = em->orig_start;\n\t\t\t\tsplit->block_start = em->block_start;\n\n\t\t\t\tif (compressed)\n\t\t\t\t\tsplit->block_len = em->block_len;\n\t\t\t\telse\n\t\t\t\t\tsplit->block_len = split->len;\n\t\t\t\tsplit->orig_block_len = max(split->block_len,\n\t\t\t\t\t\tem->orig_block_len);\n\t\t\t\tsplit->ram_bytes = em->ram_bytes;\n\t\t\t} else {\n\t\t\t\tsplit->orig_start = split->start;\n\t\t\t\tsplit->block_len = 0;\n\t\t\t\tsplit->block_start = em->block_start;\n\t\t\t\tsplit->orig_block_len = 0;\n\t\t\t\tsplit->ram_bytes = split->len;\n\t\t\t}\n\n\t\t\tsplit->generation = gen;\n\t\t\tsplit->bdev = em->bdev;\n\t\t\tsplit->flags = flags;\n\t\t\tsplit->compress_type = em->compress_type;\n\t\t\treplace_extent_mapping(em_tree, em, split, modified);\n\t\t\tfree_extent_map(split);\n\t\t\tsplit = split2;\n\t\t\tsplit2 = NULL;\n\t\t}\n\t\tif (testend && em->start + em->len > start + len) {\n\t\t\tu64 diff = start + len - em->start;\n\n\t\t\tsplit->start = start + len;\n\t\t\tsplit->len = em->start + em->len - (start + len);\n\t\t\tsplit->bdev = em->bdev;\n\t\t\tsplit->flags = flags;\n\t\t\tsplit->compress_type = em->compress_type;\n\t\t\tsplit->generation = gen;\n\n\t\t\tif (em->block_start < EXTENT_MAP_LAST_BYTE) {\n\t\t\t\tsplit->orig_block_len = max(em->block_len,\n\t\t\t\t\t\t    em->orig_block_len);\n\n\t\t\t\tsplit->ram_bytes = em->ram_bytes;\n\t\t\t\tif (compressed) {\n\t\t\t\t\tsplit->block_len = em->block_len;\n\t\t\t\t\tsplit->block_start = em->block_start;\n\t\t\t\t\tsplit->orig_start = em->orig_start;\n\t\t\t\t} else {\n\t\t\t\t\tsplit->block_len = split->len;\n\t\t\t\t\tsplit->block_start = em->block_start\n\t\t\t\t\t\t+ diff;\n\t\t\t\t\tsplit->orig_start = em->orig_start;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsplit->ram_bytes = split->len;\n\t\t\t\tsplit->orig_start = split->start;\n\t\t\t\tsplit->block_len = 0;\n\t\t\t\tsplit->block_start = em->block_start;\n\t\t\t\tsplit->orig_block_len = 0;\n\t\t\t}\n\n\t\t\tif (extent_map_in_tree(em)) {\n\t\t\t\treplace_extent_mapping(em_tree, em, split,\n\t\t\t\t\t\t       modified);\n\t\t\t} else {\n\t\t\t\tret = add_extent_mapping(em_tree, split,\n\t\t\t\t\t\t\t modified);\n\t\t\t\tASSERT(ret == 0); /* Logic error */\n\t\t\t}\n\t\t\tfree_extent_map(split);\n\t\t\tsplit = NULL;\n\t\t}\nnext:\n\t\tif (extent_map_in_tree(em))\n\t\t\tremove_extent_mapping(em_tree, em);\n\t\twrite_unlock(&em_tree->lock);\n\n\t\t/* once for us */\n\t\tfree_extent_map(em);\n\t\t/* once for the tree*/\n\t\tfree_extent_map(em);\n\t}\n\tif (split)\n\t\tfree_extent_map(split);\n\tif (split2)\n\t\tfree_extent_map(split2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_extent_map",
          "args": [
            "em"
          ],
          "line": 3146
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "70-82",
          "snippet": "void free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nvoid free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&em_tree->lock"
          ],
          "line": 3144
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_write_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "350-353",
          "snippet": "static inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_extent_mapping",
          "args": [
            "em_tree",
            "em",
            "1"
          ],
          "line": 3143
        },
        "resolved": true,
        "details": {
          "function_name": "add_extent_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "345-357",
          "snippet": "int add_extent_mapping(struct extent_map_tree *tree,\n\t\t       struct extent_map *em, int modified)\n{\n\tint ret = 0;\n\n\tret = tree_insert(&tree->map, em);\n\tif (ret)\n\t\tgoto out;\n\n\tsetup_extent_mapping(tree, em, modified);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nint add_extent_mapping(struct extent_map_tree *tree,\n\t\t       struct extent_map *em, int modified)\n{\n\tint ret = 0;\n\n\tret = tree_insert(&tree->map, em);\n\tif (ret)\n\t\tgoto out;\n\n\tsetup_extent_mapping(tree, em, modified);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&em_tree->lock"
          ],
          "line": 3142
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "345-348",
          "snippet": "static inline void tree_mod_log_write_lock(struct btrfs_fs_info *fs_info)\n{\n\twrite_lock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_write_lock(struct btrfs_fs_info *fs_info)\n{\n\twrite_lock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_type",
          "args": [
            "path->nodes[0]",
            "fi"
          ],
          "line": 3125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_extent_item_to_extent_map",
          "args": [
            "inode",
            "path",
            "fi",
            "false",
            "em"
          ],
          "line": 3123
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_extent_item_to_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file-item.c",
          "lines": "879-953",
          "snippet": "void btrfs_extent_item_to_extent_map(struct inode *inode,\n\t\t\t\t     const struct btrfs_path *path,\n\t\t\t\t     struct btrfs_file_extent_item *fi,\n\t\t\t\t     const bool new_inline,\n\t\t\t\t     struct extent_map *em)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct extent_buffer *leaf = path->nodes[0];\n\tconst int slot = path->slots[0];\n\tstruct btrfs_key key;\n\tu64 extent_start, extent_end;\n\tu64 bytenr;\n\tu8 type = btrfs_file_extent_type(leaf, fi);\n\tint compress_type = btrfs_file_extent_compression(leaf, fi);\n\n\tem->bdev = root->fs_info->fs_devices->latest_bdev;\n\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\textent_start = key.offset;\n\n\tif (type == BTRFS_FILE_EXTENT_REG ||\n\t    type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\textent_end = extent_start +\n\t\t\tbtrfs_file_extent_num_bytes(leaf, fi);\n\t} else if (type == BTRFS_FILE_EXTENT_INLINE) {\n\t\tsize_t size;\n\t\tsize = btrfs_file_extent_inline_len(leaf, slot, fi);\n\t\textent_end = ALIGN(extent_start + size, root->sectorsize);\n\t}\n\n\tem->ram_bytes = btrfs_file_extent_ram_bytes(leaf, fi);\n\tif (type == BTRFS_FILE_EXTENT_REG ||\n\t    type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\tem->start = extent_start;\n\t\tem->len = extent_end - extent_start;\n\t\tem->orig_start = extent_start -\n\t\t\tbtrfs_file_extent_offset(leaf, fi);\n\t\tem->orig_block_len = btrfs_file_extent_disk_num_bytes(leaf, fi);\n\t\tbytenr = btrfs_file_extent_disk_bytenr(leaf, fi);\n\t\tif (bytenr == 0) {\n\t\t\tem->block_start = EXTENT_MAP_HOLE;\n\t\t\treturn;\n\t\t}\n\t\tif (compress_type != BTRFS_COMPRESS_NONE) {\n\t\t\tset_bit(EXTENT_FLAG_COMPRESSED, &em->flags);\n\t\t\tem->compress_type = compress_type;\n\t\t\tem->block_start = bytenr;\n\t\t\tem->block_len = em->orig_block_len;\n\t\t} else {\n\t\t\tbytenr += btrfs_file_extent_offset(leaf, fi);\n\t\t\tem->block_start = bytenr;\n\t\t\tem->block_len = em->len;\n\t\t\tif (type == BTRFS_FILE_EXTENT_PREALLOC)\n\t\t\t\tset_bit(EXTENT_FLAG_PREALLOC, &em->flags);\n\t\t}\n\t} else if (type == BTRFS_FILE_EXTENT_INLINE) {\n\t\tem->block_start = EXTENT_MAP_INLINE;\n\t\tem->start = extent_start;\n\t\tem->len = extent_end - extent_start;\n\t\t/*\n\t\t * Initialize orig_start and block_len with the same values\n\t\t * as in inode.c:btrfs_get_extent().\n\t\t */\n\t\tem->orig_start = EXTENT_MAP_HOLE;\n\t\tem->block_len = (u64)-1;\n\t\tif (!new_inline && compress_type != BTRFS_COMPRESS_NONE) {\n\t\t\tset_bit(EXTENT_FLAG_COMPRESSED, &em->flags);\n\t\t\tem->compress_type = compress_type;\n\t\t}\n\t} else {\n\t\tbtrfs_err(root->fs_info,\n\t\t\t  \"unknown file extent item type %d, inode %llu, offset %llu, root %llu\",\n\t\t\t  type, btrfs_ino(inode), extent_start,\n\t\t\t  root->root_key.objectid);\n\t}\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n\nvoid btrfs_extent_item_to_extent_map(struct inode *inode,\n\t\t\t\t     const struct btrfs_path *path,\n\t\t\t\t     struct btrfs_file_extent_item *fi,\n\t\t\t\t     const bool new_inline,\n\t\t\t\t     struct extent_map *em)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct extent_buffer *leaf = path->nodes[0];\n\tconst int slot = path->slots[0];\n\tstruct btrfs_key key;\n\tu64 extent_start, extent_end;\n\tu64 bytenr;\n\tu8 type = btrfs_file_extent_type(leaf, fi);\n\tint compress_type = btrfs_file_extent_compression(leaf, fi);\n\n\tem->bdev = root->fs_info->fs_devices->latest_bdev;\n\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\textent_start = key.offset;\n\n\tif (type == BTRFS_FILE_EXTENT_REG ||\n\t    type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\textent_end = extent_start +\n\t\t\tbtrfs_file_extent_num_bytes(leaf, fi);\n\t} else if (type == BTRFS_FILE_EXTENT_INLINE) {\n\t\tsize_t size;\n\t\tsize = btrfs_file_extent_inline_len(leaf, slot, fi);\n\t\textent_end = ALIGN(extent_start + size, root->sectorsize);\n\t}\n\n\tem->ram_bytes = btrfs_file_extent_ram_bytes(leaf, fi);\n\tif (type == BTRFS_FILE_EXTENT_REG ||\n\t    type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\tem->start = extent_start;\n\t\tem->len = extent_end - extent_start;\n\t\tem->orig_start = extent_start -\n\t\t\tbtrfs_file_extent_offset(leaf, fi);\n\t\tem->orig_block_len = btrfs_file_extent_disk_num_bytes(leaf, fi);\n\t\tbytenr = btrfs_file_extent_disk_bytenr(leaf, fi);\n\t\tif (bytenr == 0) {\n\t\t\tem->block_start = EXTENT_MAP_HOLE;\n\t\t\treturn;\n\t\t}\n\t\tif (compress_type != BTRFS_COMPRESS_NONE) {\n\t\t\tset_bit(EXTENT_FLAG_COMPRESSED, &em->flags);\n\t\t\tem->compress_type = compress_type;\n\t\t\tem->block_start = bytenr;\n\t\t\tem->block_len = em->orig_block_len;\n\t\t} else {\n\t\t\tbytenr += btrfs_file_extent_offset(leaf, fi);\n\t\t\tem->block_start = bytenr;\n\t\t\tem->block_len = em->len;\n\t\t\tif (type == BTRFS_FILE_EXTENT_PREALLOC)\n\t\t\t\tset_bit(EXTENT_FLAG_PREALLOC, &em->flags);\n\t\t}\n\t} else if (type == BTRFS_FILE_EXTENT_INLINE) {\n\t\tem->block_start = EXTENT_MAP_INLINE;\n\t\tem->start = extent_start;\n\t\tem->len = extent_end - extent_start;\n\t\t/*\n\t\t * Initialize orig_start and block_len with the same values\n\t\t * as in inode.c:btrfs_get_extent().\n\t\t */\n\t\tem->orig_start = EXTENT_MAP_HOLE;\n\t\tem->block_len = (u64)-1;\n\t\tif (!new_inline && compress_type != BTRFS_COMPRESS_NONE) {\n\t\t\tset_bit(EXTENT_FLAG_COMPRESSED, &em->flags);\n\t\t\tem->compress_type = compress_type;\n\t\t}\n\t} else {\n\t\tbtrfs_err(root->fs_info,\n\t\t\t  \"unknown file extent item type %d, inode %llu, offset %llu, root %llu\",\n\t\t\t  type, btrfs_ino(inode), extent_start,\n\t\t\t  root->root_key.objectid);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "path->nodes[0]",
            "path->slots[0]",
            "structbtrfs_file_extent_item"
          ],
          "line": 3121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_extent_map",
          "args": [],
          "line": 3111
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "48-61",
          "snippet": "struct extent_map *alloc_extent_map(void)\n{\n\tstruct extent_map *em;\n\tem = kmem_cache_zalloc(extent_map_cache, GFP_NOFS);\n\tif (!em)\n\t\treturn NULL;\n\tRB_CLEAR_NODE(&em->rb_node);\n\tem->flags = 0;\n\tem->compress_type = BTRFS_COMPRESS_NONE;\n\tem->generation = 0;\n\tatomic_set(&em->refs, 1);\n\tINIT_LIST_HEAD(&em->list);\n\treturn em;\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nstruct extent_map *alloc_extent_map(void)\n{\n\tstruct extent_map *em;\n\tem = kmem_cache_zalloc(extent_map_cache, GFP_NOFS);\n\tif (!em)\n\t\treturn NULL;\n\tRB_CLEAR_NODE(&em->rb_node);\n\tem->flags = 0;\n\tem->compress_type = BTRFS_COMPRESS_NONE;\n\tem->generation = 0;\n\tatomic_set(&em->refs, 1);\n\tINIT_LIST_HEAD(&em->list);\n\treturn em;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic void clone_update_extent_map(struct inode *inode,\n\t\t\t\t    const struct btrfs_trans_handle *trans,\n\t\t\t\t    const struct btrfs_path *path,\n\t\t\t\t    const u64 hole_offset,\n\t\t\t\t    const u64 hole_len)\n{\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tstruct extent_map *em;\n\tint ret;\n\n\tem = alloc_extent_map();\n\tif (!em) {\n\t\tset_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t&BTRFS_I(inode)->runtime_flags);\n\t\treturn;\n\t}\n\n\tif (path) {\n\t\tstruct btrfs_file_extent_item *fi;\n\n\t\tfi = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\tbtrfs_extent_item_to_extent_map(inode, path, fi, false, em);\n\t\tem->generation = -1;\n\t\tif (btrfs_file_extent_type(path->nodes[0], fi) ==\n\t\t    BTRFS_FILE_EXTENT_INLINE)\n\t\t\tset_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t\t&BTRFS_I(inode)->runtime_flags);\n\t} else {\n\t\tem->start = hole_offset;\n\t\tem->len = hole_len;\n\t\tem->ram_bytes = em->len;\n\t\tem->orig_start = hole_offset;\n\t\tem->block_start = EXTENT_MAP_HOLE;\n\t\tem->block_len = 0;\n\t\tem->orig_block_len = 0;\n\t\tem->compress_type = BTRFS_COMPRESS_NONE;\n\t\tem->generation = trans->transid;\n\t}\n\n\twhile (1) {\n\t\twrite_lock(&em_tree->lock);\n\t\tret = add_extent_mapping(em_tree, em, 1);\n\t\twrite_unlock(&em_tree->lock);\n\t\tif (ret != -EEXIST) {\n\t\t\tfree_extent_map(em);\n\t\t\tbreak;\n\t\t}\n\t\tbtrfs_drop_extent_cache(inode, em->start,\n\t\t\t\t\tem->start + em->len - 1, 0);\n\t}\n\n\tif (ret)\n\t\tset_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t&BTRFS_I(inode)->runtime_flags);\n}"
  },
  {
    "function_name": "clone_finish_inode_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "3070-3099",
    "snippet": "static int clone_finish_inode_update(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     u64 endoff,\n\t\t\t\t     const u64 destoff,\n\t\t\t\t     const u64 olen)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tint ret;\n\n\tinode_inc_iversion(inode);\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t/*\n\t * We round up to the block size at eof when determining which\n\t * extents to clone above, but shouldn't round up the file size.\n\t */\n\tif (endoff > destoff + olen)\n\t\tendoff = destoff + olen;\n\tif (endoff > inode->i_size)\n\t\tbtrfs_i_size_write(inode, endoff);\n\n\tret = btrfs_update_inode(trans, root, inode);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tbtrfs_end_transaction(trans, root);\n\t\tgoto out;\n\t}\n\tret = btrfs_end_transaction(trans, root);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btrfs_clone(struct inode *src, struct inode *inode,\n\t\t       u64 off, u64 olen, u64 olen_aligned, u64 destoff);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_end_transaction",
          "args": [
            "trans",
            "root"
          ],
          "line": 3096
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_end_transaction_throttle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "846-850",
          "snippet": "int btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 3092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_update_inode",
          "args": [
            "trans",
            "root",
            "inode"
          ],
          "line": 3090
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_update_inode_fallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3841-3851",
          "snippet": "noinline int btrfs_update_inode_fallback(struct btrfs_trans_handle *trans,\n\t\t\t\t\t struct btrfs_root *root,\n\t\t\t\t\t struct inode *inode)\n{\n\tint ret;\n\n\tret = btrfs_update_inode(trans, root, inode);\n\tif (ret == -ENOSPC)\n\t\treturn btrfs_update_inode_item(trans, root, inode);\n\treturn ret;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nnoinline int btrfs_update_inode_fallback(struct btrfs_trans_handle *trans,\n\t\t\t\t\t struct btrfs_root *root,\n\t\t\t\t\t struct inode *inode)\n{\n\tint ret;\n\n\tret = btrfs_update_inode(trans, root, inode);\n\tif (ret == -ENOSPC)\n\t\treturn btrfs_update_inode_item(trans, root, inode);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_i_size_write",
          "args": [
            "inode",
            "endoff"
          ],
          "line": 3088
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_inc_iversion",
          "args": [
            "inode"
          ],
          "line": 3079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 3076
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_clone(struct inode *src, struct inode *inode,\n\t\t       u64 off, u64 olen, u64 olen_aligned, u64 destoff);\n\nstatic int clone_finish_inode_update(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     u64 endoff,\n\t\t\t\t     const u64 destoff,\n\t\t\t\t     const u64 olen)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tint ret;\n\n\tinode_inc_iversion(inode);\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t/*\n\t * We round up to the block size at eof when determining which\n\t * extents to clone above, but shouldn't round up the file size.\n\t */\n\tif (endoff > destoff + olen)\n\t\tendoff = destoff + olen;\n\tif (endoff > inode->i_size)\n\t\tbtrfs_i_size_write(inode, endoff);\n\n\tret = btrfs_update_inode(trans, root, inode);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tbtrfs_end_transaction(trans, root);\n\t\tgoto out;\n\t}\n\tret = btrfs_end_transaction(trans, root);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "check_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "3039-3068",
    "snippet": "static int check_ref(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t     u64 disko)\n{\n\tstruct seq_list tree_mod_seq_elem = {};\n\tstruct ulist *roots;\n\tstruct ulist_iterator uiter;\n\tstruct ulist_node *root_node = NULL;\n\tint ret;\n\n\tif (!root->fs_info->quota_enabled)\n\t\treturn 1;\n\n\tbtrfs_get_tree_mod_seq(root->fs_info, &tree_mod_seq_elem);\n\tret = btrfs_find_all_roots(trans, root->fs_info, disko,\n\t\t\t\t   tree_mod_seq_elem.seq, &roots);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = 0;\n\tULIST_ITER_INIT(&uiter);\n\twhile ((root_node = ulist_next(roots, &uiter))) {\n\t\tif (root_node->val == root->objectid) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tulist_free(roots);\nout:\n\tbtrfs_put_tree_mod_seq(root->fs_info, &tree_mod_seq_elem);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_put_tree_mod_seq",
          "args": [
            "root->fs_info",
            "&tree_mod_seq_elem"
          ],
          "line": 3066
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_tree_mod_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "386-434",
          "snippet": "void btrfs_put_tree_mod_seq(struct btrfs_fs_info *fs_info,\n\t\t\t    struct seq_list *elem)\n{\n\tstruct rb_root *tm_root;\n\tstruct rb_node *node;\n\tstruct rb_node *next;\n\tstruct seq_list *cur_elem;\n\tstruct tree_mod_elem *tm;\n\tu64 min_seq = (u64)-1;\n\tu64 seq_putting = elem->seq;\n\n\tif (!seq_putting)\n\t\treturn;\n\n\tspin_lock(&fs_info->tree_mod_seq_lock);\n\tlist_del(&elem->list);\n\telem->seq = 0;\n\n\tlist_for_each_entry(cur_elem, &fs_info->tree_mod_seq_list, list) {\n\t\tif (cur_elem->seq < min_seq) {\n\t\t\tif (seq_putting > cur_elem->seq) {\n\t\t\t\t/*\n\t\t\t\t * blocker with lower sequence number exists, we\n\t\t\t\t * cannot remove anything from the log\n\t\t\t\t */\n\t\t\t\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmin_seq = cur_elem->seq;\n\t\t}\n\t}\n\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\n\t/*\n\t * anything that's lower than the lowest existing (read: blocked)\n\t * sequence number can be removed from the tree.\n\t */\n\ttree_mod_log_write_lock(fs_info);\n\ttm_root = &fs_info->tree_mod_log;\n\tfor (node = rb_first(tm_root); node; node = next) {\n\t\tnext = rb_next(node);\n\t\ttm = container_of(node, struct tree_mod_elem, node);\n\t\tif (tm->seq > min_seq)\n\t\t\tcontinue;\n\t\trb_erase(node, tm_root);\n\t\tkfree(tm);\n\t}\n\ttree_mod_log_write_unlock(fs_info);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_put_tree_mod_seq(struct btrfs_fs_info *fs_info,\n\t\t\t    struct seq_list *elem)\n{\n\tstruct rb_root *tm_root;\n\tstruct rb_node *node;\n\tstruct rb_node *next;\n\tstruct seq_list *cur_elem;\n\tstruct tree_mod_elem *tm;\n\tu64 min_seq = (u64)-1;\n\tu64 seq_putting = elem->seq;\n\n\tif (!seq_putting)\n\t\treturn;\n\n\tspin_lock(&fs_info->tree_mod_seq_lock);\n\tlist_del(&elem->list);\n\telem->seq = 0;\n\n\tlist_for_each_entry(cur_elem, &fs_info->tree_mod_seq_list, list) {\n\t\tif (cur_elem->seq < min_seq) {\n\t\t\tif (seq_putting > cur_elem->seq) {\n\t\t\t\t/*\n\t\t\t\t * blocker with lower sequence number exists, we\n\t\t\t\t * cannot remove anything from the log\n\t\t\t\t */\n\t\t\t\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmin_seq = cur_elem->seq;\n\t\t}\n\t}\n\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\n\t/*\n\t * anything that's lower than the lowest existing (read: blocked)\n\t * sequence number can be removed from the tree.\n\t */\n\ttree_mod_log_write_lock(fs_info);\n\ttm_root = &fs_info->tree_mod_log;\n\tfor (node = rb_first(tm_root); node; node = next) {\n\t\tnext = rb_next(node);\n\t\ttm = container_of(node, struct tree_mod_elem, node);\n\t\tif (tm->seq > min_seq)\n\t\t\tcontinue;\n\t\trb_erase(node, tm_root);\n\t\tkfree(tm);\n\t}\n\ttree_mod_log_write_unlock(fs_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ulist_free",
          "args": [
            "roots"
          ],
          "line": 3064
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "110-116",
          "snippet": "void ulist_free(struct ulist *ulist)\n{\n\tif (!ulist)\n\t\treturn;\n\tulist_fini(ulist);\n\tkfree(ulist);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nvoid ulist_free(struct ulist *ulist)\n{\n\tif (!ulist)\n\t\treturn;\n\tulist_fini(ulist);\n\tkfree(ulist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ulist_next",
          "args": [
            "roots",
            "&uiter"
          ],
          "line": 3058
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "228-251",
          "snippet": "struct ulist_node *ulist_next(struct ulist *ulist, struct ulist_iterator *uiter)\n{\n\tstruct ulist_node *node;\n\n\tif (list_empty(&ulist->nodes))\n\t\treturn NULL;\n\tif (uiter->cur_list && uiter->cur_list->next == &ulist->nodes)\n\t\treturn NULL;\n\tif (uiter->cur_list) {\n\t\tuiter->cur_list = uiter->cur_list->next;\n\t} else {\n\t\tuiter->cur_list = ulist->nodes.next;\n#ifdef CONFIG_BTRFS_DEBUG\n\t\tuiter->i = 0;\n#endif\n\t}\n\tnode = list_entry(uiter->cur_list, struct ulist_node, list);\n#ifdef CONFIG_BTRFS_DEBUG\n\tASSERT(node->seqnum == uiter->i);\n\tASSERT(uiter->i >= 0 && uiter->i < ulist->nnodes);\n\tuiter->i++;\n#endif\n\treturn node;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nstruct ulist_node *ulist_next(struct ulist *ulist, struct ulist_iterator *uiter)\n{\n\tstruct ulist_node *node;\n\n\tif (list_empty(&ulist->nodes))\n\t\treturn NULL;\n\tif (uiter->cur_list && uiter->cur_list->next == &ulist->nodes)\n\t\treturn NULL;\n\tif (uiter->cur_list) {\n\t\tuiter->cur_list = uiter->cur_list->next;\n\t} else {\n\t\tuiter->cur_list = ulist->nodes.next;\n#ifdef CONFIG_BTRFS_DEBUG\n\t\tuiter->i = 0;\n#endif\n\t}\n\tnode = list_entry(uiter->cur_list, struct ulist_node, list);\n#ifdef CONFIG_BTRFS_DEBUG\n\tASSERT(node->seqnum == uiter->i);\n\tASSERT(uiter->i >= 0 && uiter->i < ulist->nnodes);\n\tuiter->i++;\n#endif\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ULIST_ITER_INIT",
          "args": [
            "&uiter"
          ],
          "line": 3057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_find_all_roots",
          "args": [
            "trans",
            "root->fs_info",
            "disko",
            "tree_mod_seq_elem.seq",
            "&roots"
          ],
          "line": 3052
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_all_roots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "1187-1199",
          "snippet": "int btrfs_find_all_roots(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_fs_info *fs_info, u64 bytenr,\n\t\t\t u64 time_seq, struct ulist **roots)\n{\n\tint ret;\n\n\tif (!trans)\n\t\tdown_read(&fs_info->commit_root_sem);\n\tret = __btrfs_find_all_roots(trans, fs_info, bytenr, time_seq, roots);\n\tif (!trans)\n\t\tup_read(&fs_info->commit_root_sem);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nint btrfs_find_all_roots(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_fs_info *fs_info, u64 bytenr,\n\t\t\t u64 time_seq, struct ulist **roots)\n{\n\tint ret;\n\n\tif (!trans)\n\t\tdown_read(&fs_info->commit_root_sem);\n\tret = __btrfs_find_all_roots(trans, fs_info, bytenr, time_seq, roots);\n\tif (!trans)\n\t\tup_read(&fs_info->commit_root_sem);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_get_tree_mod_seq",
          "args": [
            "root->fs_info",
            "&tree_mod_seq_elem"
          ],
          "line": 3051
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_tree_mod_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "371-384",
          "snippet": "u64 btrfs_get_tree_mod_seq(struct btrfs_fs_info *fs_info,\n\t\t\t   struct seq_list *elem)\n{\n\ttree_mod_log_write_lock(fs_info);\n\tspin_lock(&fs_info->tree_mod_seq_lock);\n\tif (!elem->seq) {\n\t\telem->seq = btrfs_inc_tree_mod_seq(fs_info);\n\t\tlist_add_tail(&elem->list, &fs_info->tree_mod_seq_list);\n\t}\n\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\ttree_mod_log_write_unlock(fs_info);\n\n\treturn elem->seq;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nu64 btrfs_get_tree_mod_seq(struct btrfs_fs_info *fs_info,\n\t\t\t   struct seq_list *elem)\n{\n\ttree_mod_log_write_lock(fs_info);\n\tspin_lock(&fs_info->tree_mod_seq_lock);\n\tif (!elem->seq) {\n\t\telem->seq = btrfs_inc_tree_mod_seq(fs_info);\n\t\tlist_add_tail(&elem->list, &fs_info->tree_mod_seq_list);\n\t}\n\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\ttree_mod_log_write_unlock(fs_info);\n\n\treturn elem->seq;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int check_ref(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t     u64 disko)\n{\n\tstruct seq_list tree_mod_seq_elem = {};\n\tstruct ulist *roots;\n\tstruct ulist_iterator uiter;\n\tstruct ulist_node *root_node = NULL;\n\tint ret;\n\n\tif (!root->fs_info->quota_enabled)\n\t\treturn 1;\n\n\tbtrfs_get_tree_mod_seq(root->fs_info, &tree_mod_seq_elem);\n\tret = btrfs_find_all_roots(trans, root->fs_info, disko,\n\t\t\t\t   tree_mod_seq_elem.seq, &roots);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = 0;\n\tULIST_ITER_INIT(&uiter);\n\twhile ((root_node = ulist_next(roots, &uiter))) {\n\t\tif (root_node->val == root->objectid) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tulist_free(roots);\nout:\n\tbtrfs_put_tree_mod_seq(root->fs_info, &tree_mod_seq_elem);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_ioctl_file_extent_same",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "2929-3033",
    "snippet": "static long btrfs_ioctl_file_extent_same(struct file *file,\n\t\t\tstruct btrfs_ioctl_same_args __user *argp)\n{\n\tstruct btrfs_ioctl_same_args *same;\n\tstruct btrfs_ioctl_same_extent_info *info;\n\tstruct inode *src = file_inode(file);\n\tu64 off;\n\tu64 len;\n\tint i;\n\tint ret;\n\tunsigned long size;\n\tu64 bs = BTRFS_I(src)->root->fs_info->sb->s_blocksize;\n\tbool is_admin = capable(CAP_SYS_ADMIN);\n\tu16 count;\n\n\tif (!(file->f_mode & FMODE_READ))\n\t\treturn -EINVAL;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tif (get_user(count, &argp->dest_count)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tsize = offsetof(struct btrfs_ioctl_same_args __user, info[count]);\n\n\tsame = memdup_user(argp, size);\n\n\tif (IS_ERR(same)) {\n\t\tret = PTR_ERR(same);\n\t\tgoto out;\n\t}\n\n\toff = same->logical_offset;\n\tlen = same->length;\n\n\t/*\n\t * Limit the total length we will dedupe for each operation.\n\t * This is intended to bound the total time spent in this\n\t * ioctl to something sane.\n\t */\n\tif (len > BTRFS_MAX_DEDUPE_LEN)\n\t\tlen = BTRFS_MAX_DEDUPE_LEN;\n\n\tif (WARN_ON_ONCE(bs < PAGE_CACHE_SIZE)) {\n\t\t/*\n\t\t * Btrfs does not support blocksize < page_size. As a\n\t\t * result, btrfs_cmp_data() won't correctly handle\n\t\t * this situation without an update.\n\t\t */\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = -EISDIR;\n\tif (S_ISDIR(src->i_mode))\n\t\tgoto out;\n\n\tret = -EACCES;\n\tif (!S_ISREG(src->i_mode))\n\t\tgoto out;\n\n\t/* pre-format output fields to sane values */\n\tfor (i = 0; i < count; i++) {\n\t\tsame->info[i].bytes_deduped = 0ULL;\n\t\tsame->info[i].status = 0;\n\t}\n\n\tfor (i = 0, info = same->info; i < count; i++, info++) {\n\t\tstruct inode *dst;\n\t\tstruct fd dst_file = fdget(info->fd);\n\t\tif (!dst_file.file) {\n\t\t\tinfo->status = -EBADF;\n\t\t\tcontinue;\n\t\t}\n\t\tdst = file_inode(dst_file.file);\n\n\t\tif (!(is_admin || (dst_file.file->f_mode & FMODE_WRITE))) {\n\t\t\tinfo->status = -EINVAL;\n\t\t} else if (file->f_path.mnt != dst_file.file->f_path.mnt) {\n\t\t\tinfo->status = -EXDEV;\n\t\t} else if (S_ISDIR(dst->i_mode)) {\n\t\t\tinfo->status = -EISDIR;\n\t\t} else if (!S_ISREG(dst->i_mode)) {\n\t\t\tinfo->status = -EACCES;\n\t\t} else {\n\t\t\tinfo->status = btrfs_extent_same(src, off, len, dst,\n\t\t\t\t\t\t\tinfo->logical_offset);\n\t\t\tif (info->status == 0)\n\t\t\t\tinfo->bytes_deduped += len;\n\t\t}\n\t\tfdput(dst_file);\n\t}\n\n\tret = copy_to_user(argp, same, size);\n\tif (ret)\n\t\tret = -EFAULT;\n\nout:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define BTRFS_MAX_DEDUPE_LEN\t(16 * 1024 * 1024)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "file"
          ],
          "line": 3031
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "argp",
            "same",
            "size"
          ],
          "line": 3026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "dst_file"
          ],
          "line": 3023
        },
        "resolved": true,
        "details": {
          "function_name": "fdput_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "273-278",
          "snippet": "static inline void fdput_pos(struct fd f)\n{\n\tif (f.flags & FDPUT_POS_UNLOCK)\n\t\tmutex_unlock(&f.file->f_pos_lock);\n\tfdput(f);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic inline void fdput_pos(struct fd f)\n{\n\tif (f.flags & FDPUT_POS_UNLOCK)\n\t\tmutex_unlock(&f.file->f_pos_lock);\n\tfdput(f);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_extent_same",
          "args": [
            "src",
            "off",
            "len",
            "dst",
            "info->logical_offset"
          ],
          "line": 3018
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_extent_same",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "2887-2925",
          "snippet": "static int btrfs_extent_same(struct inode *src, u64 loff, u64 len,\n\t\t\t     struct inode *dst, u64 dst_loff)\n{\n\tint ret;\n\n\t/*\n\t * btrfs_clone() can't handle extents in the same file\n\t * yet. Once that works, we can drop this check and replace it\n\t * with a check for the same inode, but overlapping extents.\n\t */\n\tif (src == dst)\n\t\treturn -EINVAL;\n\n\tbtrfs_double_lock(src, loff, dst, dst_loff, len);\n\n\tret = extent_same_check_offsets(src, loff, len);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = extent_same_check_offsets(dst, dst_loff, len);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t/* don't make the dst file partly checksummed */\n\tif ((BTRFS_I(src)->flags & BTRFS_INODE_NODATASUM) !=\n\t    (BTRFS_I(dst)->flags & BTRFS_INODE_NODATASUM)) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tret = btrfs_cmp_data(src, loff, dst, dst_loff, len);\n\tif (ret == 0)\n\t\tret = btrfs_clone(src, dst, loff, len, len, dst_loff);\n\nout_unlock:\n\tbtrfs_double_unlock(src, loff, dst, dst_loff, len);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_extent_same(struct inode *src, u64 loff, u64 len,\n\t\t\t     struct inode *dst, u64 dst_loff)\n{\n\tint ret;\n\n\t/*\n\t * btrfs_clone() can't handle extents in the same file\n\t * yet. Once that works, we can drop this check and replace it\n\t * with a check for the same inode, but overlapping extents.\n\t */\n\tif (src == dst)\n\t\treturn -EINVAL;\n\n\tbtrfs_double_lock(src, loff, dst, dst_loff, len);\n\n\tret = extent_same_check_offsets(src, loff, len);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = extent_same_check_offsets(dst, dst_loff, len);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t/* don't make the dst file partly checksummed */\n\tif ((BTRFS_I(src)->flags & BTRFS_INODE_NODATASUM) !=\n\t    (BTRFS_I(dst)->flags & BTRFS_INODE_NODATASUM)) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tret = btrfs_cmp_data(src, loff, dst, dst_loff, len);\n\tif (ret == 0)\n\t\tret = btrfs_clone(src, dst, loff, len, len, dst_loff);\n\nout_unlock:\n\tbtrfs_double_unlock(src, loff, dst, dst_loff, len);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "dst->i_mode"
          ],
          "line": 3015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "dst->i_mode"
          ],
          "line": 3013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "dst_file.file"
          ],
          "line": 3007
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "info->fd"
          ],
          "line": 3002
        },
        "resolved": true,
        "details": {
          "function_name": "__fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "706-718",
          "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "src->i_mode"
          ],
          "line": 2991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "src->i_mode"
          ],
          "line": 2987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "bs < PAGE_CACHE_SIZE"
          ],
          "line": 2976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "same"
          ],
          "line": 2961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "same"
          ],
          "line": 2960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user",
          "args": [
            "argp",
            "size"
          ],
          "line": 2958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "count",
            "&argp->dest_count"
          ],
          "line": 2951
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_arg_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "399-418",
          "snippet": "static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "file"
          ],
          "line": 2947
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 2941
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "src"
          ],
          "line": 2940
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\n#define BTRFS_MAX_DEDUPE_LEN\t(16 * 1024 * 1024)\n\nstatic long btrfs_ioctl_file_extent_same(struct file *file,\n\t\t\tstruct btrfs_ioctl_same_args __user *argp)\n{\n\tstruct btrfs_ioctl_same_args *same;\n\tstruct btrfs_ioctl_same_extent_info *info;\n\tstruct inode *src = file_inode(file);\n\tu64 off;\n\tu64 len;\n\tint i;\n\tint ret;\n\tunsigned long size;\n\tu64 bs = BTRFS_I(src)->root->fs_info->sb->s_blocksize;\n\tbool is_admin = capable(CAP_SYS_ADMIN);\n\tu16 count;\n\n\tif (!(file->f_mode & FMODE_READ))\n\t\treturn -EINVAL;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tif (get_user(count, &argp->dest_count)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tsize = offsetof(struct btrfs_ioctl_same_args __user, info[count]);\n\n\tsame = memdup_user(argp, size);\n\n\tif (IS_ERR(same)) {\n\t\tret = PTR_ERR(same);\n\t\tgoto out;\n\t}\n\n\toff = same->logical_offset;\n\tlen = same->length;\n\n\t/*\n\t * Limit the total length we will dedupe for each operation.\n\t * This is intended to bound the total time spent in this\n\t * ioctl to something sane.\n\t */\n\tif (len > BTRFS_MAX_DEDUPE_LEN)\n\t\tlen = BTRFS_MAX_DEDUPE_LEN;\n\n\tif (WARN_ON_ONCE(bs < PAGE_CACHE_SIZE)) {\n\t\t/*\n\t\t * Btrfs does not support blocksize < page_size. As a\n\t\t * result, btrfs_cmp_data() won't correctly handle\n\t\t * this situation without an update.\n\t\t */\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = -EISDIR;\n\tif (S_ISDIR(src->i_mode))\n\t\tgoto out;\n\n\tret = -EACCES;\n\tif (!S_ISREG(src->i_mode))\n\t\tgoto out;\n\n\t/* pre-format output fields to sane values */\n\tfor (i = 0; i < count; i++) {\n\t\tsame->info[i].bytes_deduped = 0ULL;\n\t\tsame->info[i].status = 0;\n\t}\n\n\tfor (i = 0, info = same->info; i < count; i++, info++) {\n\t\tstruct inode *dst;\n\t\tstruct fd dst_file = fdget(info->fd);\n\t\tif (!dst_file.file) {\n\t\t\tinfo->status = -EBADF;\n\t\t\tcontinue;\n\t\t}\n\t\tdst = file_inode(dst_file.file);\n\n\t\tif (!(is_admin || (dst_file.file->f_mode & FMODE_WRITE))) {\n\t\t\tinfo->status = -EINVAL;\n\t\t} else if (file->f_path.mnt != dst_file.file->f_path.mnt) {\n\t\t\tinfo->status = -EXDEV;\n\t\t} else if (S_ISDIR(dst->i_mode)) {\n\t\t\tinfo->status = -EISDIR;\n\t\t} else if (!S_ISREG(dst->i_mode)) {\n\t\t\tinfo->status = -EACCES;\n\t\t} else {\n\t\t\tinfo->status = btrfs_extent_same(src, off, len, dst,\n\t\t\t\t\t\t\tinfo->logical_offset);\n\t\t\tif (info->status == 0)\n\t\t\t\tinfo->bytes_deduped += len;\n\t\t}\n\t\tfdput(dst_file);\n\t}\n\n\tret = copy_to_user(argp, same, size);\n\tif (ret)\n\t\tret = -EFAULT;\n\nout:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_extent_same",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "2887-2925",
    "snippet": "static int btrfs_extent_same(struct inode *src, u64 loff, u64 len,\n\t\t\t     struct inode *dst, u64 dst_loff)\n{\n\tint ret;\n\n\t/*\n\t * btrfs_clone() can't handle extents in the same file\n\t * yet. Once that works, we can drop this check and replace it\n\t * with a check for the same inode, but overlapping extents.\n\t */\n\tif (src == dst)\n\t\treturn -EINVAL;\n\n\tbtrfs_double_lock(src, loff, dst, dst_loff, len);\n\n\tret = extent_same_check_offsets(src, loff, len);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = extent_same_check_offsets(dst, dst_loff, len);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t/* don't make the dst file partly checksummed */\n\tif ((BTRFS_I(src)->flags & BTRFS_INODE_NODATASUM) !=\n\t    (BTRFS_I(dst)->flags & BTRFS_INODE_NODATASUM)) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tret = btrfs_cmp_data(src, loff, dst, dst_loff, len);\n\tif (ret == 0)\n\t\tret = btrfs_clone(src, dst, loff, len, len, dst_loff);\n\nout_unlock:\n\tbtrfs_double_unlock(src, loff, dst, dst_loff, len);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_double_unlock",
          "args": [
            "src",
            "loff",
            "dst",
            "dst_loff",
            "len"
          ],
          "line": 2922
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_double_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "2803-2811",
          "snippet": "static void btrfs_double_unlock(struct inode *inode1, u64 loff1,\n\t\t\t\tstruct inode *inode2, u64 loff2, u64 len)\n{\n\tunlock_extent(&BTRFS_I(inode1)->io_tree, loff1, loff1 + len - 1);\n\tunlock_extent(&BTRFS_I(inode2)->io_tree, loff2, loff2 + len - 1);\n\n\tmutex_unlock(&inode1->i_mutex);\n\tmutex_unlock(&inode2->i_mutex);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic void btrfs_double_unlock(struct inode *inode1, u64 loff1,\n\t\t\t\tstruct inode *inode2, u64 loff2, u64 len)\n{\n\tunlock_extent(&BTRFS_I(inode1)->io_tree, loff1, loff1 + len - 1);\n\tunlock_extent(&BTRFS_I(inode2)->io_tree, loff2, loff2 + len - 1);\n\n\tmutex_unlock(&inode1->i_mutex);\n\tmutex_unlock(&inode2->i_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_clone",
          "args": [
            "src",
            "dst",
            "loff",
            "len",
            "len",
            "dst_loff"
          ],
          "line": 2919
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_clone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "3169-3538",
          "snippet": "static int btrfs_clone(struct inode *src, struct inode *inode,\n\t\t       const u64 off, const u64 olen, const u64 olen_aligned,\n\t\t       const u64 destoff)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_path *path = NULL;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_trans_handle *trans;\n\tchar *buf = NULL;\n\tstruct btrfs_key key;\n\tu32 nritems;\n\tint slot;\n\tint ret;\n\tint no_quota;\n\tconst u64 len = olen_aligned;\n\tu64 last_disko = 0;\n\tu64 last_dest_end = destoff;\n\n\tret = -ENOMEM;\n\tbuf = vmalloc(root->nodesize);\n\tif (!buf)\n\t\treturn ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tvfree(buf);\n\t\treturn ret;\n\t}\n\n\tpath->reada = 2;\n\t/* clone data */\n\tkey.objectid = btrfs_ino(src);\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = off;\n\n\twhile (1) {\n\t\t/*\n\t\t * note the key will change type as we walk through the\n\t\t * tree.\n\t\t */\n\t\tpath->leave_spinning = 1;\n\t\tret = btrfs_search_slot(NULL, BTRFS_I(src)->root, &key, path,\n\t\t\t\t0, 0);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\t/*\n\t\t * First search, if no extent item that starts at offset off was\n\t\t * found but the previous item is an extent item, it's possible\n\t\t * it might overlap our target range, therefore process it.\n\t\t */\n\t\tif (key.offset == off && ret > 0 && path->slots[0] > 0) {\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key,\n\t\t\t\t\t      path->slots[0] - 1);\n\t\t\tif (key.type == BTRFS_EXTENT_DATA_KEY)\n\t\t\t\tpath->slots[0]--;\n\t\t}\n\n\t\tnritems = btrfs_header_nritems(path->nodes[0]);\nprocess_slot:\n\t\tno_quota = 1;\n\t\tif (path->slots[0] >= nritems) {\n\t\t\tret = btrfs_next_leaf(BTRFS_I(src)->root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret > 0)\n\t\t\t\tbreak;\n\t\t\tnritems = btrfs_header_nritems(path->nodes[0]);\n\t\t}\n\t\tleaf = path->nodes[0];\n\t\tslot = path->slots[0];\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\t\tif (key.type > BTRFS_EXTENT_DATA_KEY ||\n\t\t    key.objectid != btrfs_ino(src))\n\t\t\tbreak;\n\n\t\tif (key.type == BTRFS_EXTENT_DATA_KEY) {\n\t\t\tstruct btrfs_file_extent_item *extent;\n\t\t\tint type;\n\t\t\tu32 size;\n\t\t\tstruct btrfs_key new_key;\n\t\t\tu64 disko = 0, diskl = 0;\n\t\t\tu64 datao = 0, datal = 0;\n\t\t\tu8 comp;\n\t\t\tu64 drop_start;\n\n\t\t\textent = btrfs_item_ptr(leaf, slot,\n\t\t\t\t\t\tstruct btrfs_file_extent_item);\n\t\t\tcomp = btrfs_file_extent_compression(leaf, extent);\n\t\t\ttype = btrfs_file_extent_type(leaf, extent);\n\t\t\tif (type == BTRFS_FILE_EXTENT_REG ||\n\t\t\t    type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\t\t\tdisko = btrfs_file_extent_disk_bytenr(leaf,\n\t\t\t\t\t\t\t\t      extent);\n\t\t\t\tdiskl = btrfs_file_extent_disk_num_bytes(leaf,\n\t\t\t\t\t\t\t\t extent);\n\t\t\t\tdatao = btrfs_file_extent_offset(leaf, extent);\n\t\t\t\tdatal = btrfs_file_extent_num_bytes(leaf,\n\t\t\t\t\t\t\t\t    extent);\n\t\t\t} else if (type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\t/* take upper bound, may be compressed */\n\t\t\t\tdatal = btrfs_file_extent_ram_bytes(leaf,\n\t\t\t\t\t\t\t\t    extent);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The first search might have left us at an extent\n\t\t\t * item that ends before our target range's start, can\n\t\t\t * happen if we have holes and NO_HOLES feature enabled.\n\t\t\t */\n\t\t\tif (key.offset + datal <= off) {\n\t\t\t\tpath->slots[0]++;\n\t\t\t\tgoto process_slot;\n\t\t\t} else if (key.offset >= off + len) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tsize = btrfs_item_size_nr(leaf, slot);\n\t\t\tread_extent_buffer(leaf, buf,\n\t\t\t\t\t   btrfs_item_ptr_offset(leaf, slot),\n\t\t\t\t\t   size);\n\n\t\t\tbtrfs_release_path(path);\n\t\t\tpath->leave_spinning = 0;\n\n\t\t\tmemcpy(&new_key, &key, sizeof(new_key));\n\t\t\tnew_key.objectid = btrfs_ino(inode);\n\t\t\tif (off <= key.offset)\n\t\t\t\tnew_key.offset = key.offset + destoff - off;\n\t\t\telse\n\t\t\t\tnew_key.offset = destoff;\n\n\t\t\t/*\n\t\t\t * Deal with a hole that doesn't have an extent item\n\t\t\t * that represents it (NO_HOLES feature enabled).\n\t\t\t * This hole is either in the middle of the cloning\n\t\t\t * range or at the beginning (fully overlaps it or\n\t\t\t * partially overlaps it).\n\t\t\t */\n\t\t\tif (new_key.offset != last_dest_end)\n\t\t\t\tdrop_start = last_dest_end;\n\t\t\telse\n\t\t\t\tdrop_start = new_key.offset;\n\n\t\t\t/*\n\t\t\t * 1 - adjusting old extent (we may have to split it)\n\t\t\t * 1 - add new extent\n\t\t\t * 1 - inode update\n\t\t\t */\n\t\t\ttrans = btrfs_start_transaction(root, 3);\n\t\t\tif (IS_ERR(trans)) {\n\t\t\t\tret = PTR_ERR(trans);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (type == BTRFS_FILE_EXTENT_REG ||\n\t\t\t    type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\t\t\t/*\n\t\t\t\t *    a  | --- range to clone ---|  b\n\t\t\t\t * | ------------- extent ------------- |\n\t\t\t\t */\n\n\t\t\t\t/* subtract range b */\n\t\t\t\tif (key.offset + datal > off + len)\n\t\t\t\t\tdatal = off + len - key.offset;\n\n\t\t\t\t/* subtract range a */\n\t\t\t\tif (off > key.offset) {\n\t\t\t\t\tdatao += off - key.offset;\n\t\t\t\t\tdatal -= off - key.offset;\n\t\t\t\t}\n\n\t\t\t\tret = btrfs_drop_extents(trans, root, inode,\n\t\t\t\t\t\t\t drop_start,\n\t\t\t\t\t\t\t new_key.offset + datal,\n\t\t\t\t\t\t\t 1);\n\t\t\t\tif (ret) {\n\t\t\t\t\tif (ret != -EOPNOTSUPP)\n\t\t\t\t\t\tbtrfs_abort_transaction(trans,\n\t\t\t\t\t\t\t\troot, ret);\n\t\t\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tret = btrfs_insert_empty_item(trans, root, path,\n\t\t\t\t\t\t\t      &new_key, size);\n\t\t\t\tif (ret) {\n\t\t\t\t\tbtrfs_abort_transaction(trans, root,\n\t\t\t\t\t\t\t\tret);\n\t\t\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tleaf = path->nodes[0];\n\t\t\t\tslot = path->slots[0];\n\t\t\t\twrite_extent_buffer(leaf, buf,\n\t\t\t\t\t    btrfs_item_ptr_offset(leaf, slot),\n\t\t\t\t\t    size);\n\n\t\t\t\textent = btrfs_item_ptr(leaf, slot,\n\t\t\t\t\t\tstruct btrfs_file_extent_item);\n\n\t\t\t\t/* disko == 0 means it's a hole */\n\t\t\t\tif (!disko)\n\t\t\t\t\tdatao = 0;\n\n\t\t\t\tbtrfs_set_file_extent_offset(leaf, extent,\n\t\t\t\t\t\t\t     datao);\n\t\t\t\tbtrfs_set_file_extent_num_bytes(leaf, extent,\n\t\t\t\t\t\t\t\tdatal);\n\n\t\t\t\t/*\n\t\t\t\t * We need to look up the roots that point at\n\t\t\t\t * this bytenr and see if the new root does.  If\n\t\t\t\t * it does not we need to make sure we update\n\t\t\t\t * quotas appropriately.\n\t\t\t\t */\n\t\t\t\tif (disko && root != BTRFS_I(src)->root &&\n\t\t\t\t    disko != last_disko) {\n\t\t\t\t\tno_quota = check_ref(trans, root,\n\t\t\t\t\t\t\t     disko);\n\t\t\t\t\tif (no_quota < 0) {\n\t\t\t\t\t\tbtrfs_abort_transaction(trans,\n\t\t\t\t\t\t\t\t\troot,\n\t\t\t\t\t\t\t\t\tret);\n\t\t\t\t\t\tbtrfs_end_transaction(trans,\n\t\t\t\t\t\t\t\t      root);\n\t\t\t\t\t\tret = no_quota;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (disko) {\n\t\t\t\t\tinode_add_bytes(inode, datal);\n\t\t\t\t\tret = btrfs_inc_extent_ref(trans, root,\n\t\t\t\t\t\t\tdisko, diskl, 0,\n\t\t\t\t\t\t\troot->root_key.objectid,\n\t\t\t\t\t\t\tbtrfs_ino(inode),\n\t\t\t\t\t\t\tnew_key.offset - datao,\n\t\t\t\t\t\t\tno_quota);\n\t\t\t\t\tif (ret) {\n\t\t\t\t\t\tbtrfs_abort_transaction(trans,\n\t\t\t\t\t\t\t\t\troot,\n\t\t\t\t\t\t\t\t\tret);\n\t\t\t\t\t\tbtrfs_end_transaction(trans,\n\t\t\t\t\t\t\t\t      root);\n\t\t\t\t\t\tgoto out;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tu64 skip = 0;\n\t\t\t\tu64 trim = 0;\n\t\t\t\tu64 aligned_end = 0;\n\n\t\t\t\tif (off > key.offset) {\n\t\t\t\t\tskip = off - key.offset;\n\t\t\t\t\tnew_key.offset += skip;\n\t\t\t\t}\n\n\t\t\t\tif (key.offset + datal > off + len)\n\t\t\t\t\ttrim = key.offset + datal - (off + len);\n\n\t\t\t\tif (comp && (skip || trim)) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tsize -= skip + trim;\n\t\t\t\tdatal -= skip + trim;\n\n\t\t\t\taligned_end = ALIGN(new_key.offset + datal,\n\t\t\t\t\t\t    root->sectorsize);\n\t\t\t\tret = btrfs_drop_extents(trans, root, inode,\n\t\t\t\t\t\t\t drop_start,\n\t\t\t\t\t\t\t aligned_end,\n\t\t\t\t\t\t\t 1);\n\t\t\t\tif (ret) {\n\t\t\t\t\tif (ret != -EOPNOTSUPP)\n\t\t\t\t\t\tbtrfs_abort_transaction(trans,\n\t\t\t\t\t\t\troot, ret);\n\t\t\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tret = btrfs_insert_empty_item(trans, root, path,\n\t\t\t\t\t\t\t      &new_key, size);\n\t\t\t\tif (ret) {\n\t\t\t\t\tbtrfs_abort_transaction(trans, root,\n\t\t\t\t\t\t\t\tret);\n\t\t\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tif (skip) {\n\t\t\t\t\tu32 start =\n\t\t\t\t\t  btrfs_file_extent_calc_inline_size(0);\n\t\t\t\t\tmemmove(buf+start, buf+start+skip,\n\t\t\t\t\t\tdatal);\n\t\t\t\t}\n\n\t\t\t\tleaf = path->nodes[0];\n\t\t\t\tslot = path->slots[0];\n\t\t\t\twrite_extent_buffer(leaf, buf,\n\t\t\t\t\t    btrfs_item_ptr_offset(leaf, slot),\n\t\t\t\t\t    size);\n\t\t\t\tinode_add_bytes(inode, datal);\n\t\t\t}\n\n\t\t\t/* If we have an implicit hole (NO_HOLES feature). */\n\t\t\tif (drop_start < new_key.offset)\n\t\t\t\tclone_update_extent_map(inode, trans,\n\t\t\t\t\t\tNULL, drop_start,\n\t\t\t\t\t\tnew_key.offset - drop_start);\n\n\t\t\tclone_update_extent_map(inode, trans, path, 0, 0);\n\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t\tbtrfs_release_path(path);\n\n\t\t\tlast_dest_end = ALIGN(new_key.offset + datal,\n\t\t\t\t\t      root->sectorsize);\n\t\t\tret = clone_finish_inode_update(trans, inode,\n\t\t\t\t\t\t\tlast_dest_end,\n\t\t\t\t\t\t\tdestoff, olen);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tif (new_key.offset + datal >= destoff + len)\n\t\t\t\tbreak;\n\t\t}\n\t\tbtrfs_release_path(path);\n\t\tkey.offset++;\n\t}\n\tret = 0;\n\n\tif (last_dest_end < destoff + len) {\n\t\t/*\n\t\t * We have an implicit hole (NO_HOLES feature is enabled) that\n\t\t * fully or partially overlaps our cloning range at its end.\n\t\t */\n\t\tbtrfs_release_path(path);\n\n\t\t/*\n\t\t * 1 - remove extent(s)\n\t\t * 1 - inode update\n\t\t */\n\t\ttrans = btrfs_start_transaction(root, 2);\n\t\tif (IS_ERR(trans)) {\n\t\t\tret = PTR_ERR(trans);\n\t\t\tgoto out;\n\t\t}\n\t\tret = btrfs_drop_extents(trans, root, inode,\n\t\t\t\t\t last_dest_end, destoff + len, 1);\n\t\tif (ret) {\n\t\t\tif (ret != -EOPNOTSUPP)\n\t\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\tgoto out;\n\t\t}\n\t\tclone_update_extent_map(inode, trans, NULL, last_dest_end,\n\t\t\t\t\tdestoff + len - last_dest_end);\n\t\tret = clone_finish_inode_update(trans, inode, destoff + len,\n\t\t\t\t\t\tdestoff, olen);\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\tvfree(buf);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_clone(struct inode *src, struct inode *inode,\n\t\t       u64 off, u64 olen, u64 olen_aligned, u64 destoff);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_clone(struct inode *src, struct inode *inode,\n\t\t       u64 off, u64 olen, u64 olen_aligned, u64 destoff);\n\nstatic int btrfs_clone(struct inode *src, struct inode *inode,\n\t\t       const u64 off, const u64 olen, const u64 olen_aligned,\n\t\t       const u64 destoff)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_path *path = NULL;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_trans_handle *trans;\n\tchar *buf = NULL;\n\tstruct btrfs_key key;\n\tu32 nritems;\n\tint slot;\n\tint ret;\n\tint no_quota;\n\tconst u64 len = olen_aligned;\n\tu64 last_disko = 0;\n\tu64 last_dest_end = destoff;\n\n\tret = -ENOMEM;\n\tbuf = vmalloc(root->nodesize);\n\tif (!buf)\n\t\treturn ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tvfree(buf);\n\t\treturn ret;\n\t}\n\n\tpath->reada = 2;\n\t/* clone data */\n\tkey.objectid = btrfs_ino(src);\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = off;\n\n\twhile (1) {\n\t\t/*\n\t\t * note the key will change type as we walk through the\n\t\t * tree.\n\t\t */\n\t\tpath->leave_spinning = 1;\n\t\tret = btrfs_search_slot(NULL, BTRFS_I(src)->root, &key, path,\n\t\t\t\t0, 0);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\t/*\n\t\t * First search, if no extent item that starts at offset off was\n\t\t * found but the previous item is an extent item, it's possible\n\t\t * it might overlap our target range, therefore process it.\n\t\t */\n\t\tif (key.offset == off && ret > 0 && path->slots[0] > 0) {\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key,\n\t\t\t\t\t      path->slots[0] - 1);\n\t\t\tif (key.type == BTRFS_EXTENT_DATA_KEY)\n\t\t\t\tpath->slots[0]--;\n\t\t}\n\n\t\tnritems = btrfs_header_nritems(path->nodes[0]);\nprocess_slot:\n\t\tno_quota = 1;\n\t\tif (path->slots[0] >= nritems) {\n\t\t\tret = btrfs_next_leaf(BTRFS_I(src)->root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret > 0)\n\t\t\t\tbreak;\n\t\t\tnritems = btrfs_header_nritems(path->nodes[0]);\n\t\t}\n\t\tleaf = path->nodes[0];\n\t\tslot = path->slots[0];\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\t\tif (key.type > BTRFS_EXTENT_DATA_KEY ||\n\t\t    key.objectid != btrfs_ino(src))\n\t\t\tbreak;\n\n\t\tif (key.type == BTRFS_EXTENT_DATA_KEY) {\n\t\t\tstruct btrfs_file_extent_item *extent;\n\t\t\tint type;\n\t\t\tu32 size;\n\t\t\tstruct btrfs_key new_key;\n\t\t\tu64 disko = 0, diskl = 0;\n\t\t\tu64 datao = 0, datal = 0;\n\t\t\tu8 comp;\n\t\t\tu64 drop_start;\n\n\t\t\textent = btrfs_item_ptr(leaf, slot,\n\t\t\t\t\t\tstruct btrfs_file_extent_item);\n\t\t\tcomp = btrfs_file_extent_compression(leaf, extent);\n\t\t\ttype = btrfs_file_extent_type(leaf, extent);\n\t\t\tif (type == BTRFS_FILE_EXTENT_REG ||\n\t\t\t    type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\t\t\tdisko = btrfs_file_extent_disk_bytenr(leaf,\n\t\t\t\t\t\t\t\t      extent);\n\t\t\t\tdiskl = btrfs_file_extent_disk_num_bytes(leaf,\n\t\t\t\t\t\t\t\t extent);\n\t\t\t\tdatao = btrfs_file_extent_offset(leaf, extent);\n\t\t\t\tdatal = btrfs_file_extent_num_bytes(leaf,\n\t\t\t\t\t\t\t\t    extent);\n\t\t\t} else if (type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\t/* take upper bound, may be compressed */\n\t\t\t\tdatal = btrfs_file_extent_ram_bytes(leaf,\n\t\t\t\t\t\t\t\t    extent);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The first search might have left us at an extent\n\t\t\t * item that ends before our target range's start, can\n\t\t\t * happen if we have holes and NO_HOLES feature enabled.\n\t\t\t */\n\t\t\tif (key.offset + datal <= off) {\n\t\t\t\tpath->slots[0]++;\n\t\t\t\tgoto process_slot;\n\t\t\t} else if (key.offset >= off + len) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tsize = btrfs_item_size_nr(leaf, slot);\n\t\t\tread_extent_buffer(leaf, buf,\n\t\t\t\t\t   btrfs_item_ptr_offset(leaf, slot),\n\t\t\t\t\t   size);\n\n\t\t\tbtrfs_release_path(path);\n\t\t\tpath->leave_spinning = 0;\n\n\t\t\tmemcpy(&new_key, &key, sizeof(new_key));\n\t\t\tnew_key.objectid = btrfs_ino(inode);\n\t\t\tif (off <= key.offset)\n\t\t\t\tnew_key.offset = key.offset + destoff - off;\n\t\t\telse\n\t\t\t\tnew_key.offset = destoff;\n\n\t\t\t/*\n\t\t\t * Deal with a hole that doesn't have an extent item\n\t\t\t * that represents it (NO_HOLES feature enabled).\n\t\t\t * This hole is either in the middle of the cloning\n\t\t\t * range or at the beginning (fully overlaps it or\n\t\t\t * partially overlaps it).\n\t\t\t */\n\t\t\tif (new_key.offset != last_dest_end)\n\t\t\t\tdrop_start = last_dest_end;\n\t\t\telse\n\t\t\t\tdrop_start = new_key.offset;\n\n\t\t\t/*\n\t\t\t * 1 - adjusting old extent (we may have to split it)\n\t\t\t * 1 - add new extent\n\t\t\t * 1 - inode update\n\t\t\t */\n\t\t\ttrans = btrfs_start_transaction(root, 3);\n\t\t\tif (IS_ERR(trans)) {\n\t\t\t\tret = PTR_ERR(trans);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (type == BTRFS_FILE_EXTENT_REG ||\n\t\t\t    type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\t\t\t/*\n\t\t\t\t *    a  | --- range to clone ---|  b\n\t\t\t\t * | ------------- extent ------------- |\n\t\t\t\t */\n\n\t\t\t\t/* subtract range b */\n\t\t\t\tif (key.offset + datal > off + len)\n\t\t\t\t\tdatal = off + len - key.offset;\n\n\t\t\t\t/* subtract range a */\n\t\t\t\tif (off > key.offset) {\n\t\t\t\t\tdatao += off - key.offset;\n\t\t\t\t\tdatal -= off - key.offset;\n\t\t\t\t}\n\n\t\t\t\tret = btrfs_drop_extents(trans, root, inode,\n\t\t\t\t\t\t\t drop_start,\n\t\t\t\t\t\t\t new_key.offset + datal,\n\t\t\t\t\t\t\t 1);\n\t\t\t\tif (ret) {\n\t\t\t\t\tif (ret != -EOPNOTSUPP)\n\t\t\t\t\t\tbtrfs_abort_transaction(trans,\n\t\t\t\t\t\t\t\troot, ret);\n\t\t\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tret = btrfs_insert_empty_item(trans, root, path,\n\t\t\t\t\t\t\t      &new_key, size);\n\t\t\t\tif (ret) {\n\t\t\t\t\tbtrfs_abort_transaction(trans, root,\n\t\t\t\t\t\t\t\tret);\n\t\t\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tleaf = path->nodes[0];\n\t\t\t\tslot = path->slots[0];\n\t\t\t\twrite_extent_buffer(leaf, buf,\n\t\t\t\t\t    btrfs_item_ptr_offset(leaf, slot),\n\t\t\t\t\t    size);\n\n\t\t\t\textent = btrfs_item_ptr(leaf, slot,\n\t\t\t\t\t\tstruct btrfs_file_extent_item);\n\n\t\t\t\t/* disko == 0 means it's a hole */\n\t\t\t\tif (!disko)\n\t\t\t\t\tdatao = 0;\n\n\t\t\t\tbtrfs_set_file_extent_offset(leaf, extent,\n\t\t\t\t\t\t\t     datao);\n\t\t\t\tbtrfs_set_file_extent_num_bytes(leaf, extent,\n\t\t\t\t\t\t\t\tdatal);\n\n\t\t\t\t/*\n\t\t\t\t * We need to look up the roots that point at\n\t\t\t\t * this bytenr and see if the new root does.  If\n\t\t\t\t * it does not we need to make sure we update\n\t\t\t\t * quotas appropriately.\n\t\t\t\t */\n\t\t\t\tif (disko && root != BTRFS_I(src)->root &&\n\t\t\t\t    disko != last_disko) {\n\t\t\t\t\tno_quota = check_ref(trans, root,\n\t\t\t\t\t\t\t     disko);\n\t\t\t\t\tif (no_quota < 0) {\n\t\t\t\t\t\tbtrfs_abort_transaction(trans,\n\t\t\t\t\t\t\t\t\troot,\n\t\t\t\t\t\t\t\t\tret);\n\t\t\t\t\t\tbtrfs_end_transaction(trans,\n\t\t\t\t\t\t\t\t      root);\n\t\t\t\t\t\tret = no_quota;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (disko) {\n\t\t\t\t\tinode_add_bytes(inode, datal);\n\t\t\t\t\tret = btrfs_inc_extent_ref(trans, root,\n\t\t\t\t\t\t\tdisko, diskl, 0,\n\t\t\t\t\t\t\troot->root_key.objectid,\n\t\t\t\t\t\t\tbtrfs_ino(inode),\n\t\t\t\t\t\t\tnew_key.offset - datao,\n\t\t\t\t\t\t\tno_quota);\n\t\t\t\t\tif (ret) {\n\t\t\t\t\t\tbtrfs_abort_transaction(trans,\n\t\t\t\t\t\t\t\t\troot,\n\t\t\t\t\t\t\t\t\tret);\n\t\t\t\t\t\tbtrfs_end_transaction(trans,\n\t\t\t\t\t\t\t\t      root);\n\t\t\t\t\t\tgoto out;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tu64 skip = 0;\n\t\t\t\tu64 trim = 0;\n\t\t\t\tu64 aligned_end = 0;\n\n\t\t\t\tif (off > key.offset) {\n\t\t\t\t\tskip = off - key.offset;\n\t\t\t\t\tnew_key.offset += skip;\n\t\t\t\t}\n\n\t\t\t\tif (key.offset + datal > off + len)\n\t\t\t\t\ttrim = key.offset + datal - (off + len);\n\n\t\t\t\tif (comp && (skip || trim)) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tsize -= skip + trim;\n\t\t\t\tdatal -= skip + trim;\n\n\t\t\t\taligned_end = ALIGN(new_key.offset + datal,\n\t\t\t\t\t\t    root->sectorsize);\n\t\t\t\tret = btrfs_drop_extents(trans, root, inode,\n\t\t\t\t\t\t\t drop_start,\n\t\t\t\t\t\t\t aligned_end,\n\t\t\t\t\t\t\t 1);\n\t\t\t\tif (ret) {\n\t\t\t\t\tif (ret != -EOPNOTSUPP)\n\t\t\t\t\t\tbtrfs_abort_transaction(trans,\n\t\t\t\t\t\t\troot, ret);\n\t\t\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tret = btrfs_insert_empty_item(trans, root, path,\n\t\t\t\t\t\t\t      &new_key, size);\n\t\t\t\tif (ret) {\n\t\t\t\t\tbtrfs_abort_transaction(trans, root,\n\t\t\t\t\t\t\t\tret);\n\t\t\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tif (skip) {\n\t\t\t\t\tu32 start =\n\t\t\t\t\t  btrfs_file_extent_calc_inline_size(0);\n\t\t\t\t\tmemmove(buf+start, buf+start+skip,\n\t\t\t\t\t\tdatal);\n\t\t\t\t}\n\n\t\t\t\tleaf = path->nodes[0];\n\t\t\t\tslot = path->slots[0];\n\t\t\t\twrite_extent_buffer(leaf, buf,\n\t\t\t\t\t    btrfs_item_ptr_offset(leaf, slot),\n\t\t\t\t\t    size);\n\t\t\t\tinode_add_bytes(inode, datal);\n\t\t\t}\n\n\t\t\t/* If we have an implicit hole (NO_HOLES feature). */\n\t\t\tif (drop_start < new_key.offset)\n\t\t\t\tclone_update_extent_map(inode, trans,\n\t\t\t\t\t\tNULL, drop_start,\n\t\t\t\t\t\tnew_key.offset - drop_start);\n\n\t\t\tclone_update_extent_map(inode, trans, path, 0, 0);\n\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t\tbtrfs_release_path(path);\n\n\t\t\tlast_dest_end = ALIGN(new_key.offset + datal,\n\t\t\t\t\t      root->sectorsize);\n\t\t\tret = clone_finish_inode_update(trans, inode,\n\t\t\t\t\t\t\tlast_dest_end,\n\t\t\t\t\t\t\tdestoff, olen);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tif (new_key.offset + datal >= destoff + len)\n\t\t\t\tbreak;\n\t\t}\n\t\tbtrfs_release_path(path);\n\t\tkey.offset++;\n\t}\n\tret = 0;\n\n\tif (last_dest_end < destoff + len) {\n\t\t/*\n\t\t * We have an implicit hole (NO_HOLES feature is enabled) that\n\t\t * fully or partially overlaps our cloning range at its end.\n\t\t */\n\t\tbtrfs_release_path(path);\n\n\t\t/*\n\t\t * 1 - remove extent(s)\n\t\t * 1 - inode update\n\t\t */\n\t\ttrans = btrfs_start_transaction(root, 2);\n\t\tif (IS_ERR(trans)) {\n\t\t\tret = PTR_ERR(trans);\n\t\t\tgoto out;\n\t\t}\n\t\tret = btrfs_drop_extents(trans, root, inode,\n\t\t\t\t\t last_dest_end, destoff + len, 1);\n\t\tif (ret) {\n\t\t\tif (ret != -EOPNOTSUPP)\n\t\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\tgoto out;\n\t\t}\n\t\tclone_update_extent_map(inode, trans, NULL, last_dest_end,\n\t\t\t\t\tdestoff + len - last_dest_end);\n\t\tret = clone_finish_inode_update(trans, inode, destoff + len,\n\t\t\t\t\t\tdestoff, olen);\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\tvfree(buf);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_cmp_data",
          "args": [
            "src",
            "loff",
            "dst",
            "dst_loff",
            "len"
          ],
          "line": 2917
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_cmp_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "2829-2872",
          "snippet": "static int btrfs_cmp_data(struct inode *src, u64 loff, struct inode *dst,\n\t\t\t  u64 dst_loff, u64 len)\n{\n\tint ret = 0;\n\tstruct page *src_page, *dst_page;\n\tunsigned int cmp_len = PAGE_CACHE_SIZE;\n\tvoid *addr, *dst_addr;\n\n\twhile (len) {\n\t\tif (len < PAGE_CACHE_SIZE)\n\t\t\tcmp_len = len;\n\n\t\tsrc_page = extent_same_get_page(src, loff);\n\t\tif (!src_page)\n\t\t\treturn -EINVAL;\n\t\tdst_page = extent_same_get_page(dst, dst_loff);\n\t\tif (!dst_page) {\n\t\t\tpage_cache_release(src_page);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\taddr = kmap_atomic(src_page);\n\t\tdst_addr = kmap_atomic(dst_page);\n\n\t\tflush_dcache_page(src_page);\n\t\tflush_dcache_page(dst_page);\n\n\t\tif (memcmp(addr, dst_addr, cmp_len))\n\t\t\tret = BTRFS_SAME_DATA_DIFFERS;\n\n\t\tkunmap_atomic(addr);\n\t\tkunmap_atomic(dst_addr);\n\t\tpage_cache_release(src_page);\n\t\tpage_cache_release(dst_page);\n\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tloff += cmp_len;\n\t\tdst_loff += cmp_len;\n\t\tlen -= cmp_len;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_cmp_data(struct inode *src, u64 loff, struct inode *dst,\n\t\t\t  u64 dst_loff, u64 len)\n{\n\tint ret = 0;\n\tstruct page *src_page, *dst_page;\n\tunsigned int cmp_len = PAGE_CACHE_SIZE;\n\tvoid *addr, *dst_addr;\n\n\twhile (len) {\n\t\tif (len < PAGE_CACHE_SIZE)\n\t\t\tcmp_len = len;\n\n\t\tsrc_page = extent_same_get_page(src, loff);\n\t\tif (!src_page)\n\t\t\treturn -EINVAL;\n\t\tdst_page = extent_same_get_page(dst, dst_loff);\n\t\tif (!dst_page) {\n\t\t\tpage_cache_release(src_page);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\taddr = kmap_atomic(src_page);\n\t\tdst_addr = kmap_atomic(dst_page);\n\n\t\tflush_dcache_page(src_page);\n\t\tflush_dcache_page(dst_page);\n\n\t\tif (memcmp(addr, dst_addr, cmp_len))\n\t\t\tret = BTRFS_SAME_DATA_DIFFERS;\n\n\t\tkunmap_atomic(addr);\n\t\tkunmap_atomic(dst_addr);\n\t\tpage_cache_release(src_page);\n\t\tpage_cache_release(dst_page);\n\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tloff += cmp_len;\n\t\tdst_loff += cmp_len;\n\t\tlen -= cmp_len;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "dst"
          ],
          "line": 2912
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_same_check_offsets",
          "args": [
            "dst",
            "dst_loff",
            "len"
          ],
          "line": 2906
        },
        "resolved": true,
        "details": {
          "function_name": "extent_same_check_offsets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "2874-2885",
          "snippet": "static int extent_same_check_offsets(struct inode *inode, u64 off, u64 len)\n{\n\tu64 bs = BTRFS_I(inode)->root->fs_info->sb->s_blocksize;\n\n\tif (off + len > inode->i_size || off + len < off)\n\t\treturn -EINVAL;\n\t/* Check that we are block aligned - btrfs_clone() requires this */\n\tif (!IS_ALIGNED(off, bs) || !IS_ALIGNED(off + len, bs))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int extent_same_check_offsets(struct inode *inode, u64 off, u64 len)\n{\n\tu64 bs = BTRFS_I(inode)->root->fs_info->sb->s_blocksize;\n\n\tif (off + len > inode->i_size || off + len < off)\n\t\treturn -EINVAL;\n\t/* Check that we are block aligned - btrfs_clone() requires this */\n\tif (!IS_ALIGNED(off, bs) || !IS_ALIGNED(off + len, bs))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_double_lock",
          "args": [
            "src",
            "loff",
            "dst",
            "dst_loff",
            "len"
          ],
          "line": 2900
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_double_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "2813-2827",
          "snippet": "static void btrfs_double_lock(struct inode *inode1, u64 loff1,\n\t\t\t      struct inode *inode2, u64 loff2, u64 len)\n{\n\tif (inode1 < inode2) {\n\t\tswap(inode1, inode2);\n\t\tswap(loff1, loff2);\n\t}\n\n\tmutex_lock_nested(&inode1->i_mutex, I_MUTEX_PARENT);\n\tlock_extent_range(inode1, loff1, len);\n\tif (inode1 != inode2) {\n\t\tmutex_lock_nested(&inode2->i_mutex, I_MUTEX_CHILD);\n\t\tlock_extent_range(inode2, loff2, len);\n\t}\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic void btrfs_double_lock(struct inode *inode1, u64 loff1,\n\t\t\t      struct inode *inode2, u64 loff2, u64 len)\n{\n\tif (inode1 < inode2) {\n\t\tswap(inode1, inode2);\n\t\tswap(loff1, loff2);\n\t}\n\n\tmutex_lock_nested(&inode1->i_mutex, I_MUTEX_PARENT);\n\tlock_extent_range(inode1, loff1, len);\n\tif (inode1 != inode2) {\n\t\tmutex_lock_nested(&inode2->i_mutex, I_MUTEX_CHILD);\n\t\tlock_extent_range(inode2, loff2, len);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_extent_same(struct inode *src, u64 loff, u64 len,\n\t\t\t     struct inode *dst, u64 dst_loff)\n{\n\tint ret;\n\n\t/*\n\t * btrfs_clone() can't handle extents in the same file\n\t * yet. Once that works, we can drop this check and replace it\n\t * with a check for the same inode, but overlapping extents.\n\t */\n\tif (src == dst)\n\t\treturn -EINVAL;\n\n\tbtrfs_double_lock(src, loff, dst, dst_loff, len);\n\n\tret = extent_same_check_offsets(src, loff, len);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = extent_same_check_offsets(dst, dst_loff, len);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t/* don't make the dst file partly checksummed */\n\tif ((BTRFS_I(src)->flags & BTRFS_INODE_NODATASUM) !=\n\t    (BTRFS_I(dst)->flags & BTRFS_INODE_NODATASUM)) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tret = btrfs_cmp_data(src, loff, dst, dst_loff, len);\n\tif (ret == 0)\n\t\tret = btrfs_clone(src, dst, loff, len, len, dst_loff);\n\nout_unlock:\n\tbtrfs_double_unlock(src, loff, dst, dst_loff, len);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "extent_same_check_offsets",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "2874-2885",
    "snippet": "static int extent_same_check_offsets(struct inode *inode, u64 off, u64 len)\n{\n\tu64 bs = BTRFS_I(inode)->root->fs_info->sb->s_blocksize;\n\n\tif (off + len > inode->i_size || off + len < off)\n\t\treturn -EINVAL;\n\t/* Check that we are block aligned - btrfs_clone() requires this */\n\tif (!IS_ALIGNED(off, bs) || !IS_ALIGNED(off + len, bs))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "off + len",
            "bs"
          ],
          "line": 2881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "off",
            "bs"
          ],
          "line": 2881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 2876
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int extent_same_check_offsets(struct inode *inode, u64 off, u64 len)\n{\n\tu64 bs = BTRFS_I(inode)->root->fs_info->sb->s_blocksize;\n\n\tif (off + len > inode->i_size || off + len < off)\n\t\treturn -EINVAL;\n\t/* Check that we are block aligned - btrfs_clone() requires this */\n\tif (!IS_ALIGNED(off, bs) || !IS_ALIGNED(off + len, bs))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_cmp_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "2829-2872",
    "snippet": "static int btrfs_cmp_data(struct inode *src, u64 loff, struct inode *dst,\n\t\t\t  u64 dst_loff, u64 len)\n{\n\tint ret = 0;\n\tstruct page *src_page, *dst_page;\n\tunsigned int cmp_len = PAGE_CACHE_SIZE;\n\tvoid *addr, *dst_addr;\n\n\twhile (len) {\n\t\tif (len < PAGE_CACHE_SIZE)\n\t\t\tcmp_len = len;\n\n\t\tsrc_page = extent_same_get_page(src, loff);\n\t\tif (!src_page)\n\t\t\treturn -EINVAL;\n\t\tdst_page = extent_same_get_page(dst, dst_loff);\n\t\tif (!dst_page) {\n\t\t\tpage_cache_release(src_page);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\taddr = kmap_atomic(src_page);\n\t\tdst_addr = kmap_atomic(dst_page);\n\n\t\tflush_dcache_page(src_page);\n\t\tflush_dcache_page(dst_page);\n\n\t\tif (memcmp(addr, dst_addr, cmp_len))\n\t\t\tret = BTRFS_SAME_DATA_DIFFERS;\n\n\t\tkunmap_atomic(addr);\n\t\tkunmap_atomic(dst_addr);\n\t\tpage_cache_release(src_page);\n\t\tpage_cache_release(dst_page);\n\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tloff += cmp_len;\n\t\tdst_loff += cmp_len;\n\t\tlen -= cmp_len;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "dst_page"
          ],
          "line": 2861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "src_page"
          ],
          "line": 2860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "dst_addr"
          ],
          "line": 2859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "addr"
          ],
          "line": 2858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "addr",
            "dst_addr",
            "cmp_len"
          ],
          "line": 2855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "dst_page"
          ],
          "line": 2853
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "dst_page"
          ],
          "line": 2850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "src_page"
          ],
          "line": 2849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "src_page"
          ],
          "line": 2846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extent_same_get_page",
          "args": [
            "dst",
            "dst_loff"
          ],
          "line": 2844
        },
        "resolved": true,
        "details": {
          "function_name": "extent_same_get_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "2750-2776",
          "snippet": "static struct page *extent_same_get_page(struct inode *inode, u64 off)\n{\n\tstruct page *page;\n\tpgoff_t index;\n\tstruct extent_io_tree *tree = &BTRFS_I(inode)->io_tree;\n\n\tindex = off >> PAGE_CACHE_SHIFT;\n\n\tpage = grab_cache_page(inode->i_mapping, index);\n\tif (!page)\n\t\treturn NULL;\n\n\tif (!PageUptodate(page)) {\n\t\tif (extent_read_full_page_nolock(tree, page, btrfs_get_extent,\n\t\t\t\t\t\t 0))\n\t\t\treturn NULL;\n\t\tlock_page(page);\n\t\tif (!PageUptodate(page)) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tunlock_page(page);\n\n\treturn page;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic struct page *extent_same_get_page(struct inode *inode, u64 off)\n{\n\tstruct page *page;\n\tpgoff_t index;\n\tstruct extent_io_tree *tree = &BTRFS_I(inode)->io_tree;\n\n\tindex = off >> PAGE_CACHE_SHIFT;\n\n\tpage = grab_cache_page(inode->i_mapping, index);\n\tif (!page)\n\t\treturn NULL;\n\n\tif (!PageUptodate(page)) {\n\t\tif (extent_read_full_page_nolock(tree, page, btrfs_get_extent,\n\t\t\t\t\t\t 0))\n\t\t\treturn NULL;\n\t\tlock_page(page);\n\t\tif (!PageUptodate(page)) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tunlock_page(page);\n\n\treturn page;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_cmp_data(struct inode *src, u64 loff, struct inode *dst,\n\t\t\t  u64 dst_loff, u64 len)\n{\n\tint ret = 0;\n\tstruct page *src_page, *dst_page;\n\tunsigned int cmp_len = PAGE_CACHE_SIZE;\n\tvoid *addr, *dst_addr;\n\n\twhile (len) {\n\t\tif (len < PAGE_CACHE_SIZE)\n\t\t\tcmp_len = len;\n\n\t\tsrc_page = extent_same_get_page(src, loff);\n\t\tif (!src_page)\n\t\t\treturn -EINVAL;\n\t\tdst_page = extent_same_get_page(dst, dst_loff);\n\t\tif (!dst_page) {\n\t\t\tpage_cache_release(src_page);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\taddr = kmap_atomic(src_page);\n\t\tdst_addr = kmap_atomic(dst_page);\n\n\t\tflush_dcache_page(src_page);\n\t\tflush_dcache_page(dst_page);\n\n\t\tif (memcmp(addr, dst_addr, cmp_len))\n\t\t\tret = BTRFS_SAME_DATA_DIFFERS;\n\n\t\tkunmap_atomic(addr);\n\t\tkunmap_atomic(dst_addr);\n\t\tpage_cache_release(src_page);\n\t\tpage_cache_release(dst_page);\n\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tloff += cmp_len;\n\t\tdst_loff += cmp_len;\n\t\tlen -= cmp_len;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_double_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "2813-2827",
    "snippet": "static void btrfs_double_lock(struct inode *inode1, u64 loff1,\n\t\t\t      struct inode *inode2, u64 loff2, u64 len)\n{\n\tif (inode1 < inode2) {\n\t\tswap(inode1, inode2);\n\t\tswap(loff1, loff2);\n\t}\n\n\tmutex_lock_nested(&inode1->i_mutex, I_MUTEX_PARENT);\n\tlock_extent_range(inode1, loff1, len);\n\tif (inode1 != inode2) {\n\t\tmutex_lock_nested(&inode2->i_mutex, I_MUTEX_CHILD);\n\t\tlock_extent_range(inode2, loff2, len);\n\t}\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lock_extent_range",
          "args": [
            "inode2",
            "loff2",
            "len"
          ],
          "line": 2825
        },
        "resolved": true,
        "details": {
          "function_name": "lock_extent_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "2778-2801",
          "snippet": "static inline void lock_extent_range(struct inode *inode, u64 off, u64 len)\n{\n\t/* do any pending delalloc/csum calc on src, one way or\n\t   another, and lock file content */\n\twhile (1) {\n\t\tstruct btrfs_ordered_extent *ordered;\n\t\tlock_extent(&BTRFS_I(inode)->io_tree, off, off + len - 1);\n\t\tordered = btrfs_lookup_first_ordered_extent(inode,\n\t\t\t\t\t\t\t    off + len - 1);\n\t\tif ((!ordered ||\n\t\t     ordered->file_offset + ordered->len <= off ||\n\t\t     ordered->file_offset >= off + len) &&\n\t\t    !test_range_bit(&BTRFS_I(inode)->io_tree, off,\n\t\t\t\t    off + len - 1, EXTENT_DELALLOC, 0, NULL)) {\n\t\t\tif (ordered)\n\t\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tunlock_extent(&BTRFS_I(inode)->io_tree, off, off + len - 1);\n\t\tif (ordered)\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\tbtrfs_wait_ordered_range(inode, off, len);\n\t}\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic inline void lock_extent_range(struct inode *inode, u64 off, u64 len)\n{\n\t/* do any pending delalloc/csum calc on src, one way or\n\t   another, and lock file content */\n\twhile (1) {\n\t\tstruct btrfs_ordered_extent *ordered;\n\t\tlock_extent(&BTRFS_I(inode)->io_tree, off, off + len - 1);\n\t\tordered = btrfs_lookup_first_ordered_extent(inode,\n\t\t\t\t\t\t\t    off + len - 1);\n\t\tif ((!ordered ||\n\t\t     ordered->file_offset + ordered->len <= off ||\n\t\t     ordered->file_offset >= off + len) &&\n\t\t    !test_range_bit(&BTRFS_I(inode)->io_tree, off,\n\t\t\t\t    off + len - 1, EXTENT_DELALLOC, 0, NULL)) {\n\t\t\tif (ordered)\n\t\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tunlock_extent(&BTRFS_I(inode)->io_tree, off, off + len - 1);\n\t\tif (ordered)\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\tbtrfs_wait_ordered_range(inode, off, len);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&inode2->i_mutex",
            "I_MUTEX_CHILD"
          ],
          "line": 2824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&inode1->i_mutex",
            "I_MUTEX_PARENT"
          ],
          "line": 2821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap",
          "args": [
            "loff1",
            "loff2"
          ],
          "line": 2818
        },
        "resolved": true,
        "details": {
          "function_name": "swap_inode_boot_loader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ioctl.c",
          "lines": "96-197",
          "snippet": "static long swap_inode_boot_loader(struct super_block *sb,\n\t\t\t\tstruct inode *inode)\n{\n\thandle_t *handle;\n\tint err;\n\tstruct inode *inode_bl;\n\tstruct ext4_inode_info *ei_bl;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (inode->i_nlink != 1 || !S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\tif (!inode_owner_or_capable(inode) || !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tinode_bl = ext4_iget(sb, EXT4_BOOT_LOADER_INO);\n\tif (IS_ERR(inode_bl))\n\t\treturn PTR_ERR(inode_bl);\n\tei_bl = EXT4_I(inode_bl);\n\n\tfilemap_flush(inode->i_mapping);\n\tfilemap_flush(inode_bl->i_mapping);\n\n\t/* Protect orig inodes against a truncate and make sure,\n\t * that only 1 swap_inode_boot_loader is running. */\n\tlock_two_nondirectories(inode, inode_bl);\n\n\ttruncate_inode_pages(&inode->i_data, 0);\n\ttruncate_inode_pages(&inode_bl->i_data, 0);\n\n\t/* Wait for all existing dio workers */\n\text4_inode_block_unlocked_dio(inode);\n\text4_inode_block_unlocked_dio(inode_bl);\n\tinode_dio_wait(inode);\n\tinode_dio_wait(inode_bl);\n\n\thandle = ext4_journal_start(inode_bl, EXT4_HT_MOVE_EXTENTS, 2);\n\tif (IS_ERR(handle)) {\n\t\terr = -EINVAL;\n\t\tgoto journal_err_out;\n\t}\n\n\t/* Protect extent tree against block allocations via delalloc */\n\text4_double_down_write_data_sem(inode, inode_bl);\n\n\tif (inode_bl->i_nlink == 0) {\n\t\t/* this inode has never been used as a BOOT_LOADER */\n\t\tset_nlink(inode_bl, 1);\n\t\ti_uid_write(inode_bl, 0);\n\t\ti_gid_write(inode_bl, 0);\n\t\tinode_bl->i_flags = 0;\n\t\tei_bl->i_flags = 0;\n\t\tinode_bl->i_version = 1;\n\t\ti_size_write(inode_bl, 0);\n\t\tinode_bl->i_mode = S_IFREG;\n\t\tif (EXT4_HAS_INCOMPAT_FEATURE(sb,\n\t\t\t\t\t      EXT4_FEATURE_INCOMPAT_EXTENTS)) {\n\t\t\text4_set_inode_flag(inode_bl, EXT4_INODE_EXTENTS);\n\t\t\text4_ext_tree_init(handle, inode_bl);\n\t\t} else\n\t\t\tmemset(ei_bl->i_data, 0, sizeof(ei_bl->i_data));\n\t}\n\n\tswap_inode_data(inode, inode_bl);\n\n\tinode->i_ctime = inode_bl->i_ctime = ext4_current_time(inode);\n\n\tspin_lock(&sbi->s_next_gen_lock);\n\tinode->i_generation = sbi->s_next_generation++;\n\tinode_bl->i_generation = sbi->s_next_generation++;\n\tspin_unlock(&sbi->s_next_gen_lock);\n\n\text4_discard_preallocations(inode);\n\n\terr = ext4_mark_inode_dirty(handle, inode);\n\tif (err < 0) {\n\t\text4_warning(inode->i_sb,\n\t\t\t\"couldn't mark inode #%lu dirty (err %d)\",\n\t\t\tinode->i_ino, err);\n\t\t/* Revert all changes: */\n\t\tswap_inode_data(inode, inode_bl);\n\t} else {\n\t\terr = ext4_mark_inode_dirty(handle, inode_bl);\n\t\tif (err < 0) {\n\t\t\text4_warning(inode_bl->i_sb,\n\t\t\t\t\"couldn't mark inode #%lu dirty (err %d)\",\n\t\t\t\tinode_bl->i_ino, err);\n\t\t\t/* Revert all changes: */\n\t\t\tswap_inode_data(inode, inode_bl);\n\t\t\text4_mark_inode_dirty(handle, inode);\n\t\t}\n\t}\n\text4_journal_stop(handle);\n\text4_double_up_write_data_sem(inode, inode_bl);\n\njournal_err_out:\n\text4_inode_resume_unlocked_dio(inode);\n\text4_inode_resume_unlocked_dio(inode_bl);\n\tunlock_two_nondirectories(inode, inode_bl);\n\tiput(inode_bl);\n\treturn err;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/time.h>",
            "#include <linux/capability.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/capability.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic long swap_inode_boot_loader(struct super_block *sb,\n\t\t\t\tstruct inode *inode)\n{\n\thandle_t *handle;\n\tint err;\n\tstruct inode *inode_bl;\n\tstruct ext4_inode_info *ei_bl;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (inode->i_nlink != 1 || !S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\tif (!inode_owner_or_capable(inode) || !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tinode_bl = ext4_iget(sb, EXT4_BOOT_LOADER_INO);\n\tif (IS_ERR(inode_bl))\n\t\treturn PTR_ERR(inode_bl);\n\tei_bl = EXT4_I(inode_bl);\n\n\tfilemap_flush(inode->i_mapping);\n\tfilemap_flush(inode_bl->i_mapping);\n\n\t/* Protect orig inodes against a truncate and make sure,\n\t * that only 1 swap_inode_boot_loader is running. */\n\tlock_two_nondirectories(inode, inode_bl);\n\n\ttruncate_inode_pages(&inode->i_data, 0);\n\ttruncate_inode_pages(&inode_bl->i_data, 0);\n\n\t/* Wait for all existing dio workers */\n\text4_inode_block_unlocked_dio(inode);\n\text4_inode_block_unlocked_dio(inode_bl);\n\tinode_dio_wait(inode);\n\tinode_dio_wait(inode_bl);\n\n\thandle = ext4_journal_start(inode_bl, EXT4_HT_MOVE_EXTENTS, 2);\n\tif (IS_ERR(handle)) {\n\t\terr = -EINVAL;\n\t\tgoto journal_err_out;\n\t}\n\n\t/* Protect extent tree against block allocations via delalloc */\n\text4_double_down_write_data_sem(inode, inode_bl);\n\n\tif (inode_bl->i_nlink == 0) {\n\t\t/* this inode has never been used as a BOOT_LOADER */\n\t\tset_nlink(inode_bl, 1);\n\t\ti_uid_write(inode_bl, 0);\n\t\ti_gid_write(inode_bl, 0);\n\t\tinode_bl->i_flags = 0;\n\t\tei_bl->i_flags = 0;\n\t\tinode_bl->i_version = 1;\n\t\ti_size_write(inode_bl, 0);\n\t\tinode_bl->i_mode = S_IFREG;\n\t\tif (EXT4_HAS_INCOMPAT_FEATURE(sb,\n\t\t\t\t\t      EXT4_FEATURE_INCOMPAT_EXTENTS)) {\n\t\t\text4_set_inode_flag(inode_bl, EXT4_INODE_EXTENTS);\n\t\t\text4_ext_tree_init(handle, inode_bl);\n\t\t} else\n\t\t\tmemset(ei_bl->i_data, 0, sizeof(ei_bl->i_data));\n\t}\n\n\tswap_inode_data(inode, inode_bl);\n\n\tinode->i_ctime = inode_bl->i_ctime = ext4_current_time(inode);\n\n\tspin_lock(&sbi->s_next_gen_lock);\n\tinode->i_generation = sbi->s_next_generation++;\n\tinode_bl->i_generation = sbi->s_next_generation++;\n\tspin_unlock(&sbi->s_next_gen_lock);\n\n\text4_discard_preallocations(inode);\n\n\terr = ext4_mark_inode_dirty(handle, inode);\n\tif (err < 0) {\n\t\text4_warning(inode->i_sb,\n\t\t\t\"couldn't mark inode #%lu dirty (err %d)\",\n\t\t\tinode->i_ino, err);\n\t\t/* Revert all changes: */\n\t\tswap_inode_data(inode, inode_bl);\n\t} else {\n\t\terr = ext4_mark_inode_dirty(handle, inode_bl);\n\t\tif (err < 0) {\n\t\t\text4_warning(inode_bl->i_sb,\n\t\t\t\t\"couldn't mark inode #%lu dirty (err %d)\",\n\t\t\t\tinode_bl->i_ino, err);\n\t\t\t/* Revert all changes: */\n\t\t\tswap_inode_data(inode, inode_bl);\n\t\t\text4_mark_inode_dirty(handle, inode);\n\t\t}\n\t}\n\text4_journal_stop(handle);\n\text4_double_up_write_data_sem(inode, inode_bl);\n\njournal_err_out:\n\text4_inode_resume_unlocked_dio(inode);\n\text4_inode_resume_unlocked_dio(inode_bl);\n\tunlock_two_nondirectories(inode, inode_bl);\n\tiput(inode_bl);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic void btrfs_double_lock(struct inode *inode1, u64 loff1,\n\t\t\t      struct inode *inode2, u64 loff2, u64 len)\n{\n\tif (inode1 < inode2) {\n\t\tswap(inode1, inode2);\n\t\tswap(loff1, loff2);\n\t}\n\n\tmutex_lock_nested(&inode1->i_mutex, I_MUTEX_PARENT);\n\tlock_extent_range(inode1, loff1, len);\n\tif (inode1 != inode2) {\n\t\tmutex_lock_nested(&inode2->i_mutex, I_MUTEX_CHILD);\n\t\tlock_extent_range(inode2, loff2, len);\n\t}\n}"
  },
  {
    "function_name": "btrfs_double_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "2803-2811",
    "snippet": "static void btrfs_double_unlock(struct inode *inode1, u64 loff1,\n\t\t\t\tstruct inode *inode2, u64 loff2, u64 len)\n{\n\tunlock_extent(&BTRFS_I(inode1)->io_tree, loff1, loff1 + len - 1);\n\tunlock_extent(&BTRFS_I(inode2)->io_tree, loff2, loff2 + len - 1);\n\n\tmutex_unlock(&inode1->i_mutex);\n\tmutex_unlock(&inode2->i_mutex);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode2->i_mutex"
          ],
          "line": 2810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode1->i_mutex"
          ],
          "line": 2809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_extent",
          "args": [
            "&BTRFS_I(inode2)->io_tree",
            "loff2",
            "loff2 + len - 1"
          ],
          "line": 2807
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1380-1384",
          "snippet": "int unlock_extent(struct extent_io_tree *tree, u64 start, u64 end)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, NULL,\n\t\t\t\tGFP_NOFS);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint unlock_extent(struct extent_io_tree *tree, u64 start, u64 end)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, NULL,\n\t\t\t\tGFP_NOFS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode2"
          ],
          "line": 2807
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic void btrfs_double_unlock(struct inode *inode1, u64 loff1,\n\t\t\t\tstruct inode *inode2, u64 loff2, u64 len)\n{\n\tunlock_extent(&BTRFS_I(inode1)->io_tree, loff1, loff1 + len - 1);\n\tunlock_extent(&BTRFS_I(inode2)->io_tree, loff2, loff2 + len - 1);\n\n\tmutex_unlock(&inode1->i_mutex);\n\tmutex_unlock(&inode2->i_mutex);\n}"
  },
  {
    "function_name": "lock_extent_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "2778-2801",
    "snippet": "static inline void lock_extent_range(struct inode *inode, u64 off, u64 len)\n{\n\t/* do any pending delalloc/csum calc on src, one way or\n\t   another, and lock file content */\n\twhile (1) {\n\t\tstruct btrfs_ordered_extent *ordered;\n\t\tlock_extent(&BTRFS_I(inode)->io_tree, off, off + len - 1);\n\t\tordered = btrfs_lookup_first_ordered_extent(inode,\n\t\t\t\t\t\t\t    off + len - 1);\n\t\tif ((!ordered ||\n\t\t     ordered->file_offset + ordered->len <= off ||\n\t\t     ordered->file_offset >= off + len) &&\n\t\t    !test_range_bit(&BTRFS_I(inode)->io_tree, off,\n\t\t\t\t    off + len - 1, EXTENT_DELALLOC, 0, NULL)) {\n\t\t\tif (ordered)\n\t\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tunlock_extent(&BTRFS_I(inode)->io_tree, off, off + len - 1);\n\t\tif (ordered)\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\tbtrfs_wait_ordered_range(inode, off, len);\n\t}\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_wait_ordered_range",
          "args": [
            "inode",
            "off",
            "len"
          ],
          "line": 2799
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_wait_ordered_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "722-771",
          "snippet": "int btrfs_wait_ordered_range(struct inode *inode, u64 start, u64 len)\n{\n\tint ret = 0;\n\tu64 end;\n\tu64 orig_end;\n\tstruct btrfs_ordered_extent *ordered;\n\n\tif (start + len < start) {\n\t\torig_end = INT_LIMIT(loff_t);\n\t} else {\n\t\torig_end = start + len - 1;\n\t\tif (orig_end > INT_LIMIT(loff_t))\n\t\t\torig_end = INT_LIMIT(loff_t);\n\t}\n\n\t/* start IO across the range first to instantiate any delalloc\n\t * extents\n\t */\n\tret = btrfs_fdatawrite_range(inode, start, orig_end);\n\tif (ret)\n\t\treturn ret;\n\n\tret = filemap_fdatawait_range(inode->i_mapping, start, orig_end);\n\tif (ret)\n\t\treturn ret;\n\n\tend = orig_end;\n\twhile (1) {\n\t\tordered = btrfs_lookup_first_ordered_extent(inode, end);\n\t\tif (!ordered)\n\t\t\tbreak;\n\t\tif (ordered->file_offset > orig_end) {\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tif (ordered->file_offset + ordered->len <= start) {\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tbtrfs_start_ordered_extent(inode, ordered, 1);\n\t\tend = ordered->file_offset;\n\t\tif (test_bit(BTRFS_ORDERED_IOERR, &ordered->flags))\n\t\t\tret = -EIO;\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tif (ret || end == 0 || end == start)\n\t\t\tbreak;\n\t\tend--;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nint btrfs_wait_ordered_range(struct inode *inode, u64 start, u64 len)\n{\n\tint ret = 0;\n\tu64 end;\n\tu64 orig_end;\n\tstruct btrfs_ordered_extent *ordered;\n\n\tif (start + len < start) {\n\t\torig_end = INT_LIMIT(loff_t);\n\t} else {\n\t\torig_end = start + len - 1;\n\t\tif (orig_end > INT_LIMIT(loff_t))\n\t\t\torig_end = INT_LIMIT(loff_t);\n\t}\n\n\t/* start IO across the range first to instantiate any delalloc\n\t * extents\n\t */\n\tret = btrfs_fdatawrite_range(inode, start, orig_end);\n\tif (ret)\n\t\treturn ret;\n\n\tret = filemap_fdatawait_range(inode->i_mapping, start, orig_end);\n\tif (ret)\n\t\treturn ret;\n\n\tend = orig_end;\n\twhile (1) {\n\t\tordered = btrfs_lookup_first_ordered_extent(inode, end);\n\t\tif (!ordered)\n\t\t\tbreak;\n\t\tif (ordered->file_offset > orig_end) {\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tif (ordered->file_offset + ordered->len <= start) {\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tbtrfs_start_ordered_extent(inode, ordered, 1);\n\t\tend = ordered->file_offset;\n\t\tif (test_bit(BTRFS_ORDERED_IOERR, &ordered->flags))\n\t\t\tret = -EIO;\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tif (ret || end == 0 || end == start)\n\t\t\tbreak;\n\t\tend--;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_put_ordered_extent",
          "args": [
            "ordered"
          ],
          "line": 2798
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_ordered_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "540-558",
          "snippet": "void btrfs_put_ordered_extent(struct btrfs_ordered_extent *entry)\n{\n\tstruct list_head *cur;\n\tstruct btrfs_ordered_sum *sum;\n\n\ttrace_btrfs_ordered_extent_put(entry->inode, entry);\n\n\tif (atomic_dec_and_test(&entry->refs)) {\n\t\tif (entry->inode)\n\t\t\tbtrfs_add_delayed_iput(entry->inode);\n\t\twhile (!list_empty(&entry->list)) {\n\t\t\tcur = entry->list.next;\n\t\t\tsum = list_entry(cur, struct btrfs_ordered_sum, list);\n\t\t\tlist_del(&sum->list);\n\t\t\tkfree(sum);\n\t\t}\n\t\tkmem_cache_free(btrfs_ordered_extent_cache, entry);\n\t}\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *btrfs_ordered_extent_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *btrfs_ordered_extent_cache;\n\nvoid btrfs_put_ordered_extent(struct btrfs_ordered_extent *entry)\n{\n\tstruct list_head *cur;\n\tstruct btrfs_ordered_sum *sum;\n\n\ttrace_btrfs_ordered_extent_put(entry->inode, entry);\n\n\tif (atomic_dec_and_test(&entry->refs)) {\n\t\tif (entry->inode)\n\t\t\tbtrfs_add_delayed_iput(entry->inode);\n\t\twhile (!list_empty(&entry->list)) {\n\t\t\tcur = entry->list.next;\n\t\t\tsum = list_entry(cur, struct btrfs_ordered_sum, list);\n\t\t\tlist_del(&sum->list);\n\t\t\tkfree(sum);\n\t\t}\n\t\tkmem_cache_free(btrfs_ordered_extent_cache, entry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_extent",
          "args": [
            "&BTRFS_I(inode)->io_tree",
            "off",
            "off + len - 1"
          ],
          "line": 2796
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1380-1384",
          "snippet": "int unlock_extent(struct extent_io_tree *tree, u64 start, u64 end)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, NULL,\n\t\t\t\tGFP_NOFS);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint unlock_extent(struct extent_io_tree *tree, u64 start, u64 end)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, NULL,\n\t\t\t\tGFP_NOFS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 2796
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_range_bit",
          "args": [
            "&BTRFS_I(inode)->io_tree",
            "off",
            "off + len - 1",
            "EXTENT_DELALLOC",
            "0",
            "NULL"
          ],
          "line": 2790
        },
        "resolved": true,
        "details": {
          "function_name": "test_range_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1931-1979",
          "snippet": "int test_range_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t   unsigned bits, int filled, struct extent_state *cached)\n{\n\tstruct extent_state *state = NULL;\n\tstruct rb_node *node;\n\tint bitset = 0;\n\n\tspin_lock(&tree->lock);\n\tif (cached && extent_state_in_tree(cached) && cached->start <= start &&\n\t    cached->end > start)\n\t\tnode = &cached->rb_node;\n\telse\n\t\tnode = tree_search(tree, start);\n\twhile (node && start <= end) {\n\t\tstate = rb_entry(node, struct extent_state, rb_node);\n\n\t\tif (filled && state->start > start) {\n\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (state->start > end)\n\t\t\tbreak;\n\n\t\tif (state->state & bits) {\n\t\t\tbitset = 1;\n\t\t\tif (!filled)\n\t\t\t\tbreak;\n\t\t} else if (filled) {\n\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (state->end == (u64)-1)\n\t\t\tbreak;\n\n\t\tstart = state->end + 1;\n\t\tif (start > end)\n\t\t\tbreak;\n\t\tnode = rb_next(node);\n\t\tif (!node) {\n\t\t\tif (filled)\n\t\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&tree->lock);\n\treturn bitset;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint test_range_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t   unsigned bits, int filled, struct extent_state *cached)\n{\n\tstruct extent_state *state = NULL;\n\tstruct rb_node *node;\n\tint bitset = 0;\n\n\tspin_lock(&tree->lock);\n\tif (cached && extent_state_in_tree(cached) && cached->start <= start &&\n\t    cached->end > start)\n\t\tnode = &cached->rb_node;\n\telse\n\t\tnode = tree_search(tree, start);\n\twhile (node && start <= end) {\n\t\tstate = rb_entry(node, struct extent_state, rb_node);\n\n\t\tif (filled && state->start > start) {\n\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (state->start > end)\n\t\t\tbreak;\n\n\t\tif (state->state & bits) {\n\t\t\tbitset = 1;\n\t\t\tif (!filled)\n\t\t\t\tbreak;\n\t\t} else if (filled) {\n\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (state->end == (u64)-1)\n\t\t\tbreak;\n\n\t\tstart = state->end + 1;\n\t\tif (start > end)\n\t\t\tbreak;\n\t\tnode = rb_next(node);\n\t\tif (!node) {\n\t\t\tif (filled)\n\t\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&tree->lock);\n\treturn bitset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_first_ordered_extent",
          "args": [
            "inode",
            "off + len - 1"
          ],
          "line": 2785
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_first_ordered_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "845-863",
          "snippet": "struct btrfs_ordered_extent *\nbtrfs_lookup_first_ordered_extent(struct inode *inode, u64 file_offset)\n{\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct rb_node *node;\n\tstruct btrfs_ordered_extent *entry = NULL;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tspin_lock_irq(&tree->lock);\n\tnode = tree_search(tree, file_offset);\n\tif (!node)\n\t\tgoto out;\n\n\tentry = rb_entry(node, struct btrfs_ordered_extent, rb_node);\n\tatomic_inc(&entry->refs);\nout:\n\tspin_unlock_irq(&tree->lock);\n\treturn entry;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstruct btrfs_ordered_extent *\nbtrfs_lookup_first_ordered_extent(struct inode *inode, u64 file_offset)\n{\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct rb_node *node;\n\tstruct btrfs_ordered_extent *entry = NULL;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tspin_lock_irq(&tree->lock);\n\tnode = tree_search(tree, file_offset);\n\tif (!node)\n\t\tgoto out;\n\n\tentry = rb_entry(node, struct btrfs_ordered_extent, rb_node);\n\tatomic_inc(&entry->refs);\nout:\n\tspin_unlock_irq(&tree->lock);\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_extent",
          "args": [
            "&BTRFS_I(inode)->io_tree",
            "off",
            "off + len - 1"
          ],
          "line": 2784
        },
        "resolved": true,
        "details": {
          "function_name": "lock_extent_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "2778-2801",
          "snippet": "static inline void lock_extent_range(struct inode *inode, u64 off, u64 len)\n{\n\t/* do any pending delalloc/csum calc on src, one way or\n\t   another, and lock file content */\n\twhile (1) {\n\t\tstruct btrfs_ordered_extent *ordered;\n\t\tlock_extent(&BTRFS_I(inode)->io_tree, off, off + len - 1);\n\t\tordered = btrfs_lookup_first_ordered_extent(inode,\n\t\t\t\t\t\t\t    off + len - 1);\n\t\tif ((!ordered ||\n\t\t     ordered->file_offset + ordered->len <= off ||\n\t\t     ordered->file_offset >= off + len) &&\n\t\t    !test_range_bit(&BTRFS_I(inode)->io_tree, off,\n\t\t\t\t    off + len - 1, EXTENT_DELALLOC, 0, NULL)) {\n\t\t\tif (ordered)\n\t\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tunlock_extent(&BTRFS_I(inode)->io_tree, off, off + len - 1);\n\t\tif (ordered)\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\tbtrfs_wait_ordered_range(inode, off, len);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic inline void lock_extent_range(struct inode *inode, u64 off, u64 len)\n{\n\t/* do any pending delalloc/csum calc on src, one way or\n\t   another, and lock file content */\n\twhile (1) {\n\t\tstruct btrfs_ordered_extent *ordered;\n\t\tlock_extent(&BTRFS_I(inode)->io_tree, off, off + len - 1);\n\t\tordered = btrfs_lookup_first_ordered_extent(inode,\n\t\t\t\t\t\t\t    off + len - 1);\n\t\tif ((!ordered ||\n\t\t     ordered->file_offset + ordered->len <= off ||\n\t\t     ordered->file_offset >= off + len) &&\n\t\t    !test_range_bit(&BTRFS_I(inode)->io_tree, off,\n\t\t\t\t    off + len - 1, EXTENT_DELALLOC, 0, NULL)) {\n\t\t\tif (ordered)\n\t\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tunlock_extent(&BTRFS_I(inode)->io_tree, off, off + len - 1);\n\t\tif (ordered)\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\tbtrfs_wait_ordered_range(inode, off, len);\n\t}\n}"
  },
  {
    "function_name": "extent_same_get_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "2750-2776",
    "snippet": "static struct page *extent_same_get_page(struct inode *inode, u64 off)\n{\n\tstruct page *page;\n\tpgoff_t index;\n\tstruct extent_io_tree *tree = &BTRFS_I(inode)->io_tree;\n\n\tindex = off >> PAGE_CACHE_SHIFT;\n\n\tpage = grab_cache_page(inode->i_mapping, index);\n\tif (!page)\n\t\treturn NULL;\n\n\tif (!PageUptodate(page)) {\n\t\tif (extent_read_full_page_nolock(tree, page, btrfs_get_extent,\n\t\t\t\t\t\t 0))\n\t\t\treturn NULL;\n\t\tlock_page(page);\n\t\tif (!PageUptodate(page)) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tunlock_page(page);\n\n\treturn page;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2773
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 2769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 2767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extent_read_full_page_nolock",
          "args": [
            "tree",
            "page",
            "btrfs_get_extent",
            "0"
          ],
          "line": 2763
        },
        "resolved": true,
        "details": {
          "function_name": "extent_read_full_page_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "3189-3201",
          "snippet": "int extent_read_full_page_nolock(struct extent_io_tree *tree, struct page *page,\n\t\t\t\t get_extent_t *get_extent, int mirror_num)\n{\n\tstruct bio *bio = NULL;\n\tunsigned long bio_flags = EXTENT_BIO_PARENT_LOCKED;\n\tint ret;\n\n\tret = __do_readpage(tree, page, get_extent, NULL, &bio, mirror_num,\n\t\t\t\t      &bio_flags, READ);\n\tif (bio)\n\t\tret = submit_one_bio(READ, bio, mirror_num, bio_flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint extent_read_full_page_nolock(struct extent_io_tree *tree, struct page *page,\n\t\t\t\t get_extent_t *get_extent, int mirror_num)\n{\n\tstruct bio *bio = NULL;\n\tunsigned long bio_flags = EXTENT_BIO_PARENT_LOCKED;\n\tint ret;\n\n\tret = __do_readpage(tree, page, get_extent, NULL, &bio, mirror_num,\n\t\t\t\t      &bio_flags, READ);\n\tif (bio)\n\t\tret = submit_one_bio(READ, bio, mirror_num, bio_flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 2762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_cache_page",
          "args": [
            "inode->i_mapping",
            "index"
          ],
          "line": 2758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 2754
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic struct page *extent_same_get_page(struct inode *inode, u64 off)\n{\n\tstruct page *page;\n\tpgoff_t index;\n\tstruct extent_io_tree *tree = &BTRFS_I(inode)->io_tree;\n\n\tindex = off >> PAGE_CACHE_SHIFT;\n\n\tpage = grab_cache_page(inode->i_mapping, index);\n\tif (!page)\n\t\treturn NULL;\n\n\tif (!PageUptodate(page)) {\n\t\tif (extent_read_full_page_nolock(tree, page, btrfs_get_extent,\n\t\t\t\t\t\t 0))\n\t\t\treturn NULL;\n\t\tlock_page(page);\n\t\tif (!PageUptodate(page)) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tunlock_page(page);\n\n\treturn page;\n}"
  },
  {
    "function_name": "btrfs_ioctl_dev_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "2702-2748",
    "snippet": "static long btrfs_ioctl_dev_info(struct btrfs_root *root, void __user *arg)\n{\n\tstruct btrfs_ioctl_dev_info_args *di_args;\n\tstruct btrfs_device *dev;\n\tstruct btrfs_fs_devices *fs_devices = root->fs_info->fs_devices;\n\tint ret = 0;\n\tchar *s_uuid = NULL;\n\n\tdi_args = memdup_user(arg, sizeof(*di_args));\n\tif (IS_ERR(di_args))\n\t\treturn PTR_ERR(di_args);\n\n\tif (!btrfs_is_empty_uuid(di_args->uuid))\n\t\ts_uuid = di_args->uuid;\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tdev = btrfs_find_device(root->fs_info, di_args->devid, s_uuid, NULL);\n\n\tif (!dev) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tdi_args->devid = dev->devid;\n\tdi_args->bytes_used = btrfs_device_get_bytes_used(dev);\n\tdi_args->total_bytes = btrfs_device_get_total_bytes(dev);\n\tmemcpy(di_args->uuid, dev->uuid, sizeof(di_args->uuid));\n\tif (dev->name) {\n\t\tstruct rcu_string *name;\n\n\t\trcu_read_lock();\n\t\tname = rcu_dereference(dev->name);\n\t\tstrncpy(di_args->path, name->str, sizeof(di_args->path));\n\t\trcu_read_unlock();\n\t\tdi_args->path[sizeof(di_args->path) - 1] = 0;\n\t} else {\n\t\tdi_args->path[0] = '\\0';\n\t}\n\nout:\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\tif (ret == 0 && copy_to_user(arg, di_args, sizeof(*di_args)))\n\t\tret = -EFAULT;\n\n\tkfree(di_args);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "di_args"
          ],
          "line": 2746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "arg",
            "di_args",
            "sizeof(*di_args)"
          ],
          "line": 2743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_devices->device_list_mutex"
          ],
          "line": 2742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "di_args->path",
            "name->str",
            "sizeof(di_args->path)"
          ],
          "line": 2734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "dev->name"
          ],
          "line": 2733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 2732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "di_args->uuid",
            "dev->uuid",
            "sizeof(di_args->uuid)"
          ],
          "line": 2728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_device_get_total_bytes",
          "args": [
            "dev"
          ],
          "line": 2727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_device_get_bytes_used",
          "args": [
            "dev"
          ],
          "line": 2726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_find_device",
          "args": [
            "root->fs_info",
            "di_args->devid",
            "s_uuid",
            "NULL"
          ],
          "line": 2718
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "5918-5936",
          "snippet": "struct btrfs_device *btrfs_find_device(struct btrfs_fs_info *fs_info, u64 devid,\n\t\t\t\t       u8 *uuid, u8 *fsid)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_fs_devices *cur_devices;\n\n\tcur_devices = fs_info->fs_devices;\n\twhile (cur_devices) {\n\t\tif (!fsid ||\n\t\t    !memcmp(cur_devices->fsid, fsid, BTRFS_UUID_SIZE)) {\n\t\t\tdevice = __find_device(&cur_devices->devices,\n\t\t\t\t\t       devid, uuid);\n\t\t\tif (device)\n\t\t\t\treturn device;\n\t\t}\n\t\tcur_devices = cur_devices->seed;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstruct btrfs_device *btrfs_find_device(struct btrfs_fs_info *fs_info, u64 devid,\n\t\t\t\t       u8 *uuid, u8 *fsid)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_fs_devices *cur_devices;\n\n\tcur_devices = fs_info->fs_devices;\n\twhile (cur_devices) {\n\t\tif (!fsid ||\n\t\t    !memcmp(cur_devices->fsid, fsid, BTRFS_UUID_SIZE)) {\n\t\t\tdevice = __find_device(&cur_devices->devices,\n\t\t\t\t\t       devid, uuid);\n\t\t\tif (device)\n\t\t\t\treturn device;\n\t\t}\n\t\tcur_devices = cur_devices->seed;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_devices->device_list_mutex"
          ],
          "line": 2717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_is_empty_uuid",
          "args": [
            "di_args->uuid"
          ],
          "line": 2714
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_is_empty_uuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "420-429",
          "snippet": "int btrfs_is_empty_uuid(u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_UUID_SIZE; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nint btrfs_is_empty_uuid(u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_UUID_SIZE; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "di_args"
          ],
          "line": 2712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "di_args"
          ],
          "line": 2711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user",
          "args": [
            "arg",
            "sizeof(*di_args)"
          ],
          "line": 2710
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_dev_info(struct btrfs_root *root, void __user *arg)\n{\n\tstruct btrfs_ioctl_dev_info_args *di_args;\n\tstruct btrfs_device *dev;\n\tstruct btrfs_fs_devices *fs_devices = root->fs_info->fs_devices;\n\tint ret = 0;\n\tchar *s_uuid = NULL;\n\n\tdi_args = memdup_user(arg, sizeof(*di_args));\n\tif (IS_ERR(di_args))\n\t\treturn PTR_ERR(di_args);\n\n\tif (!btrfs_is_empty_uuid(di_args->uuid))\n\t\ts_uuid = di_args->uuid;\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tdev = btrfs_find_device(root->fs_info, di_args->devid, s_uuid, NULL);\n\n\tif (!dev) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tdi_args->devid = dev->devid;\n\tdi_args->bytes_used = btrfs_device_get_bytes_used(dev);\n\tdi_args->total_bytes = btrfs_device_get_total_bytes(dev);\n\tmemcpy(di_args->uuid, dev->uuid, sizeof(di_args->uuid));\n\tif (dev->name) {\n\t\tstruct rcu_string *name;\n\n\t\trcu_read_lock();\n\t\tname = rcu_dereference(dev->name);\n\t\tstrncpy(di_args->path, name->str, sizeof(di_args->path));\n\t\trcu_read_unlock();\n\t\tdi_args->path[sizeof(di_args->path) - 1] = 0;\n\t} else {\n\t\tdi_args->path[0] = '\\0';\n\t}\n\nout:\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\tif (ret == 0 && copy_to_user(arg, di_args, sizeof(*di_args)))\n\t\tret = -EFAULT;\n\n\tkfree(di_args);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_ioctl_fs_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "2669-2700",
    "snippet": "static long btrfs_ioctl_fs_info(struct btrfs_root *root, void __user *arg)\n{\n\tstruct btrfs_ioctl_fs_info_args *fi_args;\n\tstruct btrfs_device *device;\n\tstruct btrfs_device *next;\n\tstruct btrfs_fs_devices *fs_devices = root->fs_info->fs_devices;\n\tint ret = 0;\n\n\tfi_args = kzalloc(sizeof(*fi_args), GFP_KERNEL);\n\tif (!fi_args)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tfi_args->num_devices = fs_devices->num_devices;\n\tmemcpy(&fi_args->fsid, root->fs_info->fsid, sizeof(fi_args->fsid));\n\n\tlist_for_each_entry_safe(device, next, &fs_devices->devices, dev_list) {\n\t\tif (device->devid > fi_args->max_id)\n\t\t\tfi_args->max_id = device->devid;\n\t}\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\tfi_args->nodesize = root->fs_info->super_copy->nodesize;\n\tfi_args->sectorsize = root->fs_info->super_copy->sectorsize;\n\tfi_args->clone_alignment = root->fs_info->super_copy->sectorsize;\n\n\tif (copy_to_user(arg, fi_args, sizeof(*fi_args)))\n\t\tret = -EFAULT;\n\n\tkfree(fi_args);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fi_args"
          ],
          "line": 2698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "arg",
            "fi_args",
            "sizeof(*fi_args)"
          ],
          "line": 2695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_devices->device_list_mutex"
          ],
          "line": 2689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "device",
            "next",
            "&fs_devices->devices",
            "dev_list"
          ],
          "line": 2685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&fi_args->fsid",
            "root->fs_info->fsid",
            "sizeof(fi_args->fsid)"
          ],
          "line": 2683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_devices->device_list_mutex"
          ],
          "line": 2681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*fi_args)",
            "GFP_KERNEL"
          ],
          "line": 2677
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_fs_info(struct btrfs_root *root, void __user *arg)\n{\n\tstruct btrfs_ioctl_fs_info_args *fi_args;\n\tstruct btrfs_device *device;\n\tstruct btrfs_device *next;\n\tstruct btrfs_fs_devices *fs_devices = root->fs_info->fs_devices;\n\tint ret = 0;\n\n\tfi_args = kzalloc(sizeof(*fi_args), GFP_KERNEL);\n\tif (!fi_args)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tfi_args->num_devices = fs_devices->num_devices;\n\tmemcpy(&fi_args->fsid, root->fs_info->fsid, sizeof(fi_args->fsid));\n\n\tlist_for_each_entry_safe(device, next, &fs_devices->devices, dev_list) {\n\t\tif (device->devid > fi_args->max_id)\n\t\t\tfi_args->max_id = device->devid;\n\t}\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\tfi_args->nodesize = root->fs_info->super_copy->nodesize;\n\tfi_args->sectorsize = root->fs_info->super_copy->sectorsize;\n\tfi_args->clone_alignment = root->fs_info->super_copy->sectorsize;\n\n\tif (copy_to_user(arg, fi_args, sizeof(*fi_args)))\n\t\tret = -EFAULT;\n\n\tkfree(fi_args);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_ioctl_rm_dev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "2627-2667",
    "snippet": "static long btrfs_ioctl_rm_dev(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tstruct btrfs_ioctl_vol_args *vol_args;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tvol_args = memdup_user(arg, sizeof(*vol_args));\n\tif (IS_ERR(vol_args)) {\n\t\tret = PTR_ERR(vol_args);\n\t\tgoto err_drop;\n\t}\n\n\tvol_args->name[BTRFS_PATH_NAME_MAX] = '\\0';\n\n\tif (atomic_xchg(&root->fs_info->mutually_exclusive_operation_running,\n\t\t\t1)) {\n\t\tret = BTRFS_ERROR_DEV_EXCL_RUN_IN_PROGRESS;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&root->fs_info->volume_mutex);\n\tret = btrfs_rm_device(root, vol_args->name);\n\tmutex_unlock(&root->fs_info->volume_mutex);\n\tatomic_set(&root->fs_info->mutually_exclusive_operation_running, 0);\n\n\tif (!ret)\n\t\tbtrfs_info(root->fs_info, \"disk deleted %s\",vol_args->name);\n\nout:\n\tkfree(vol_args);\nerr_drop:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "file"
          ],
          "line": 2665
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "vol_args"
          ],
          "line": 2663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_info",
          "args": [
            "root->fs_info",
            "\"disk deleted %s\"",
            "vol_args->name"
          ],
          "line": 2660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&root->fs_info->mutually_exclusive_operation_running",
            "0"
          ],
          "line": 2657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->fs_info->volume_mutex"
          ],
          "line": 2656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_rm_device",
          "args": [
            "root",
            "vol_args->name"
          ],
          "line": 2655
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_rm_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "1538-1799",
          "snippet": "int btrfs_rm_device(struct btrfs_root *root, char *device_path)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_device *next_device;\n\tstruct block_device *bdev;\n\tstruct buffer_head *bh = NULL;\n\tstruct btrfs_super_block *disk_super;\n\tstruct btrfs_fs_devices *cur_devices;\n\tu64 all_avail;\n\tu64 devid;\n\tu64 num_devices;\n\tu8 *dev_uuid;\n\tunsigned seq;\n\tint ret = 0;\n\tbool clear_super = false;\n\n\tmutex_lock(&uuid_mutex);\n\n\tdo {\n\t\tseq = read_seqbegin(&root->fs_info->profiles_lock);\n\n\t\tall_avail = root->fs_info->avail_data_alloc_bits |\n\t\t\t    root->fs_info->avail_system_alloc_bits |\n\t\t\t    root->fs_info->avail_metadata_alloc_bits;\n\t} while (read_seqretry(&root->fs_info->profiles_lock, seq));\n\n\tnum_devices = root->fs_info->fs_devices->num_devices;\n\tbtrfs_dev_replace_lock(&root->fs_info->dev_replace);\n\tif (btrfs_dev_replace_is_ongoing(&root->fs_info->dev_replace)) {\n\t\tWARN_ON(num_devices < 1);\n\t\tnum_devices--;\n\t}\n\tbtrfs_dev_replace_unlock(&root->fs_info->dev_replace);\n\n\tif ((all_avail & BTRFS_BLOCK_GROUP_RAID10) && num_devices <= 4) {\n\t\tret = BTRFS_ERROR_DEV_RAID10_MIN_NOT_MET;\n\t\tgoto out;\n\t}\n\n\tif ((all_avail & BTRFS_BLOCK_GROUP_RAID1) && num_devices <= 2) {\n\t\tret = BTRFS_ERROR_DEV_RAID1_MIN_NOT_MET;\n\t\tgoto out;\n\t}\n\n\tif ((all_avail & BTRFS_BLOCK_GROUP_RAID5) &&\n\t    root->fs_info->fs_devices->rw_devices <= 2) {\n\t\tret = BTRFS_ERROR_DEV_RAID5_MIN_NOT_MET;\n\t\tgoto out;\n\t}\n\tif ((all_avail & BTRFS_BLOCK_GROUP_RAID6) &&\n\t    root->fs_info->fs_devices->rw_devices <= 3) {\n\t\tret = BTRFS_ERROR_DEV_RAID6_MIN_NOT_MET;\n\t\tgoto out;\n\t}\n\n\tif (strcmp(device_path, \"missing\") == 0) {\n\t\tstruct list_head *devices;\n\t\tstruct btrfs_device *tmp;\n\n\t\tdevice = NULL;\n\t\tdevices = &root->fs_info->fs_devices->devices;\n\t\t/*\n\t\t * It is safe to read the devices since the volume_mutex\n\t\t * is held.\n\t\t */\n\t\tlist_for_each_entry(tmp, devices, dev_list) {\n\t\t\tif (tmp->in_fs_metadata &&\n\t\t\t    !tmp->is_tgtdev_for_dev_replace &&\n\t\t\t    !tmp->bdev) {\n\t\t\t\tdevice = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbdev = NULL;\n\t\tbh = NULL;\n\t\tdisk_super = NULL;\n\t\tif (!device) {\n\t\t\tret = BTRFS_ERROR_DEV_MISSING_NOT_FOUND;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tret = btrfs_get_bdev_and_sb(device_path,\n\t\t\t\t\t    FMODE_WRITE | FMODE_EXCL,\n\t\t\t\t\t    root->fs_info->bdev_holder, 0,\n\t\t\t\t\t    &bdev, &bh);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tdisk_super = (struct btrfs_super_block *)bh->b_data;\n\t\tdevid = btrfs_stack_device_id(&disk_super->dev_item);\n\t\tdev_uuid = disk_super->dev_item.uuid;\n\t\tdevice = btrfs_find_device(root->fs_info, devid, dev_uuid,\n\t\t\t\t\t   disk_super->fsid);\n\t\tif (!device) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto error_brelse;\n\t\t}\n\t}\n\n\tif (device->is_tgtdev_for_dev_replace) {\n\t\tret = BTRFS_ERROR_DEV_TGT_REPLACE;\n\t\tgoto error_brelse;\n\t}\n\n\tif (device->writeable && root->fs_info->fs_devices->rw_devices == 1) {\n\t\tret = BTRFS_ERROR_DEV_ONLY_WRITABLE;\n\t\tgoto error_brelse;\n\t}\n\n\tif (device->writeable) {\n\t\tlock_chunks(root);\n\t\tlist_del_init(&device->dev_alloc_list);\n\t\tdevice->fs_devices->rw_devices--;\n\t\tunlock_chunks(root);\n\t\tclear_super = true;\n\t}\n\n\tmutex_unlock(&uuid_mutex);\n\tret = btrfs_shrink_device(device, 0);\n\tmutex_lock(&uuid_mutex);\n\tif (ret)\n\t\tgoto error_undo;\n\n\t/*\n\t * TODO: the superblock still includes this device in its num_devices\n\t * counter although write_all_supers() is not locked out. This\n\t * could give a filesystem state which requires a degraded mount.\n\t */\n\tret = btrfs_rm_dev_item(root->fs_info->chunk_root, device);\n\tif (ret)\n\t\tgoto error_undo;\n\n\tdevice->in_fs_metadata = 0;\n\tbtrfs_scrub_cancel_dev(root->fs_info, device);\n\n\t/*\n\t * the device list mutex makes sure that we don't change\n\t * the device list while someone else is writing out all\n\t * the device supers. Whoever is writing all supers, should\n\t * lock the device list mutex before getting the number of\n\t * devices in the super block (super_copy). Conversely,\n\t * whoever updates the number of devices in the super block\n\t * (super_copy) should hold the device list mutex.\n\t */\n\n\tcur_devices = device->fs_devices;\n\tmutex_lock(&root->fs_info->fs_devices->device_list_mutex);\n\tlist_del_rcu(&device->dev_list);\n\n\tdevice->fs_devices->num_devices--;\n\tdevice->fs_devices->total_devices--;\n\n\tif (device->missing)\n\t\tdevice->fs_devices->missing_devices--;\n\n\tnext_device = list_entry(root->fs_info->fs_devices->devices.next,\n\t\t\t\t struct btrfs_device, dev_list);\n\tif (device->bdev == root->fs_info->sb->s_bdev)\n\t\troot->fs_info->sb->s_bdev = next_device->bdev;\n\tif (device->bdev == root->fs_info->fs_devices->latest_bdev)\n\t\troot->fs_info->fs_devices->latest_bdev = next_device->bdev;\n\n\tif (device->bdev) {\n\t\tdevice->fs_devices->open_devices--;\n\t\t/* remove sysfs entry */\n\t\tbtrfs_kobj_rm_device(root->fs_info, device);\n\t}\n\n\tcall_rcu(&device->rcu, free_device);\n\n\tnum_devices = btrfs_super_num_devices(root->fs_info->super_copy) - 1;\n\tbtrfs_set_super_num_devices(root->fs_info->super_copy, num_devices);\n\tmutex_unlock(&root->fs_info->fs_devices->device_list_mutex);\n\n\tif (cur_devices->open_devices == 0) {\n\t\tstruct btrfs_fs_devices *fs_devices;\n\t\tfs_devices = root->fs_info->fs_devices;\n\t\twhile (fs_devices) {\n\t\t\tif (fs_devices->seed == cur_devices) {\n\t\t\t\tfs_devices->seed = cur_devices->seed;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfs_devices = fs_devices->seed;\n\t\t}\n\t\tcur_devices->seed = NULL;\n\t\t__btrfs_close_devices(cur_devices);\n\t\tfree_fs_devices(cur_devices);\n\t}\n\n\troot->fs_info->num_tolerated_disk_barrier_failures =\n\t\tbtrfs_calc_num_tolerated_disk_barrier_failures(root->fs_info);\n\n\t/*\n\t * at this point, the device is zero sized.  We want to\n\t * remove it from the devices list and zero out the old super\n\t */\n\tif (clear_super && disk_super) {\n\t\tu64 bytenr;\n\t\tint i;\n\n\t\t/* make sure this device isn't detected as part of\n\t\t * the FS anymore\n\t\t */\n\t\tmemset(&disk_super->magic, 0, sizeof(disk_super->magic));\n\t\tset_buffer_dirty(bh);\n\t\tsync_dirty_buffer(bh);\n\n\t\t/* clear the mirror copies of super block on the disk\n\t\t * being removed, 0th copy is been taken care above and\n\t\t * the below would take of the rest\n\t\t */\n\t\tfor (i = 1; i < BTRFS_SUPER_MIRROR_MAX; i++) {\n\t\t\tbytenr = btrfs_sb_offset(i);\n\t\t\tif (bytenr + BTRFS_SUPER_INFO_SIZE >=\n\t\t\t\t\ti_size_read(bdev->bd_inode))\n\t\t\t\tbreak;\n\n\t\t\tbrelse(bh);\n\t\t\tbh = __bread(bdev, bytenr / 4096,\n\t\t\t\t\tBTRFS_SUPER_INFO_SIZE);\n\t\t\tif (!bh)\n\t\t\t\tcontinue;\n\n\t\t\tdisk_super = (struct btrfs_super_block *)bh->b_data;\n\n\t\t\tif (btrfs_super_bytenr(disk_super) != bytenr ||\n\t\t\t\tbtrfs_super_magic(disk_super) != BTRFS_MAGIC) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmemset(&disk_super->magic, 0,\n\t\t\t\t\t\tsizeof(disk_super->magic));\n\t\t\tset_buffer_dirty(bh);\n\t\t\tsync_dirty_buffer(bh);\n\t\t}\n\t}\n\n\tret = 0;\n\n\tif (bdev) {\n\t\t/* Notify udev that device has changed */\n\t\tbtrfs_kobject_uevent(bdev, KOBJ_CHANGE);\n\n\t\t/* Update ctime/mtime for device path for libblkid */\n\t\tupdate_dev_time(device_path);\n\t}\n\nerror_brelse:\n\tbrelse(bh);\n\tif (bdev)\n\t\tblkdev_put(bdev, FMODE_READ | FMODE_EXCL);\nout:\n\tmutex_unlock(&uuid_mutex);\n\treturn ret;\nerror_undo:\n\tif (device->writeable) {\n\t\tlock_chunks(root);\n\t\tlist_add(&device->dev_alloc_list,\n\t\t\t &root->fs_info->fs_devices->alloc_list);\n\t\tdevice->fs_devices->rw_devices++;\n\t\tunlock_chunks(root);\n\t}\n\tgoto error_brelse;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_rm_device(struct btrfs_root *root, char *device_path)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_device *next_device;\n\tstruct block_device *bdev;\n\tstruct buffer_head *bh = NULL;\n\tstruct btrfs_super_block *disk_super;\n\tstruct btrfs_fs_devices *cur_devices;\n\tu64 all_avail;\n\tu64 devid;\n\tu64 num_devices;\n\tu8 *dev_uuid;\n\tunsigned seq;\n\tint ret = 0;\n\tbool clear_super = false;\n\n\tmutex_lock(&uuid_mutex);\n\n\tdo {\n\t\tseq = read_seqbegin(&root->fs_info->profiles_lock);\n\n\t\tall_avail = root->fs_info->avail_data_alloc_bits |\n\t\t\t    root->fs_info->avail_system_alloc_bits |\n\t\t\t    root->fs_info->avail_metadata_alloc_bits;\n\t} while (read_seqretry(&root->fs_info->profiles_lock, seq));\n\n\tnum_devices = root->fs_info->fs_devices->num_devices;\n\tbtrfs_dev_replace_lock(&root->fs_info->dev_replace);\n\tif (btrfs_dev_replace_is_ongoing(&root->fs_info->dev_replace)) {\n\t\tWARN_ON(num_devices < 1);\n\t\tnum_devices--;\n\t}\n\tbtrfs_dev_replace_unlock(&root->fs_info->dev_replace);\n\n\tif ((all_avail & BTRFS_BLOCK_GROUP_RAID10) && num_devices <= 4) {\n\t\tret = BTRFS_ERROR_DEV_RAID10_MIN_NOT_MET;\n\t\tgoto out;\n\t}\n\n\tif ((all_avail & BTRFS_BLOCK_GROUP_RAID1) && num_devices <= 2) {\n\t\tret = BTRFS_ERROR_DEV_RAID1_MIN_NOT_MET;\n\t\tgoto out;\n\t}\n\n\tif ((all_avail & BTRFS_BLOCK_GROUP_RAID5) &&\n\t    root->fs_info->fs_devices->rw_devices <= 2) {\n\t\tret = BTRFS_ERROR_DEV_RAID5_MIN_NOT_MET;\n\t\tgoto out;\n\t}\n\tif ((all_avail & BTRFS_BLOCK_GROUP_RAID6) &&\n\t    root->fs_info->fs_devices->rw_devices <= 3) {\n\t\tret = BTRFS_ERROR_DEV_RAID6_MIN_NOT_MET;\n\t\tgoto out;\n\t}\n\n\tif (strcmp(device_path, \"missing\") == 0) {\n\t\tstruct list_head *devices;\n\t\tstruct btrfs_device *tmp;\n\n\t\tdevice = NULL;\n\t\tdevices = &root->fs_info->fs_devices->devices;\n\t\t/*\n\t\t * It is safe to read the devices since the volume_mutex\n\t\t * is held.\n\t\t */\n\t\tlist_for_each_entry(tmp, devices, dev_list) {\n\t\t\tif (tmp->in_fs_metadata &&\n\t\t\t    !tmp->is_tgtdev_for_dev_replace &&\n\t\t\t    !tmp->bdev) {\n\t\t\t\tdevice = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbdev = NULL;\n\t\tbh = NULL;\n\t\tdisk_super = NULL;\n\t\tif (!device) {\n\t\t\tret = BTRFS_ERROR_DEV_MISSING_NOT_FOUND;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tret = btrfs_get_bdev_and_sb(device_path,\n\t\t\t\t\t    FMODE_WRITE | FMODE_EXCL,\n\t\t\t\t\t    root->fs_info->bdev_holder, 0,\n\t\t\t\t\t    &bdev, &bh);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tdisk_super = (struct btrfs_super_block *)bh->b_data;\n\t\tdevid = btrfs_stack_device_id(&disk_super->dev_item);\n\t\tdev_uuid = disk_super->dev_item.uuid;\n\t\tdevice = btrfs_find_device(root->fs_info, devid, dev_uuid,\n\t\t\t\t\t   disk_super->fsid);\n\t\tif (!device) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto error_brelse;\n\t\t}\n\t}\n\n\tif (device->is_tgtdev_for_dev_replace) {\n\t\tret = BTRFS_ERROR_DEV_TGT_REPLACE;\n\t\tgoto error_brelse;\n\t}\n\n\tif (device->writeable && root->fs_info->fs_devices->rw_devices == 1) {\n\t\tret = BTRFS_ERROR_DEV_ONLY_WRITABLE;\n\t\tgoto error_brelse;\n\t}\n\n\tif (device->writeable) {\n\t\tlock_chunks(root);\n\t\tlist_del_init(&device->dev_alloc_list);\n\t\tdevice->fs_devices->rw_devices--;\n\t\tunlock_chunks(root);\n\t\tclear_super = true;\n\t}\n\n\tmutex_unlock(&uuid_mutex);\n\tret = btrfs_shrink_device(device, 0);\n\tmutex_lock(&uuid_mutex);\n\tif (ret)\n\t\tgoto error_undo;\n\n\t/*\n\t * TODO: the superblock still includes this device in its num_devices\n\t * counter although write_all_supers() is not locked out. This\n\t * could give a filesystem state which requires a degraded mount.\n\t */\n\tret = btrfs_rm_dev_item(root->fs_info->chunk_root, device);\n\tif (ret)\n\t\tgoto error_undo;\n\n\tdevice->in_fs_metadata = 0;\n\tbtrfs_scrub_cancel_dev(root->fs_info, device);\n\n\t/*\n\t * the device list mutex makes sure that we don't change\n\t * the device list while someone else is writing out all\n\t * the device supers. Whoever is writing all supers, should\n\t * lock the device list mutex before getting the number of\n\t * devices in the super block (super_copy). Conversely,\n\t * whoever updates the number of devices in the super block\n\t * (super_copy) should hold the device list mutex.\n\t */\n\n\tcur_devices = device->fs_devices;\n\tmutex_lock(&root->fs_info->fs_devices->device_list_mutex);\n\tlist_del_rcu(&device->dev_list);\n\n\tdevice->fs_devices->num_devices--;\n\tdevice->fs_devices->total_devices--;\n\n\tif (device->missing)\n\t\tdevice->fs_devices->missing_devices--;\n\n\tnext_device = list_entry(root->fs_info->fs_devices->devices.next,\n\t\t\t\t struct btrfs_device, dev_list);\n\tif (device->bdev == root->fs_info->sb->s_bdev)\n\t\troot->fs_info->sb->s_bdev = next_device->bdev;\n\tif (device->bdev == root->fs_info->fs_devices->latest_bdev)\n\t\troot->fs_info->fs_devices->latest_bdev = next_device->bdev;\n\n\tif (device->bdev) {\n\t\tdevice->fs_devices->open_devices--;\n\t\t/* remove sysfs entry */\n\t\tbtrfs_kobj_rm_device(root->fs_info, device);\n\t}\n\n\tcall_rcu(&device->rcu, free_device);\n\n\tnum_devices = btrfs_super_num_devices(root->fs_info->super_copy) - 1;\n\tbtrfs_set_super_num_devices(root->fs_info->super_copy, num_devices);\n\tmutex_unlock(&root->fs_info->fs_devices->device_list_mutex);\n\n\tif (cur_devices->open_devices == 0) {\n\t\tstruct btrfs_fs_devices *fs_devices;\n\t\tfs_devices = root->fs_info->fs_devices;\n\t\twhile (fs_devices) {\n\t\t\tif (fs_devices->seed == cur_devices) {\n\t\t\t\tfs_devices->seed = cur_devices->seed;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfs_devices = fs_devices->seed;\n\t\t}\n\t\tcur_devices->seed = NULL;\n\t\t__btrfs_close_devices(cur_devices);\n\t\tfree_fs_devices(cur_devices);\n\t}\n\n\troot->fs_info->num_tolerated_disk_barrier_failures =\n\t\tbtrfs_calc_num_tolerated_disk_barrier_failures(root->fs_info);\n\n\t/*\n\t * at this point, the device is zero sized.  We want to\n\t * remove it from the devices list and zero out the old super\n\t */\n\tif (clear_super && disk_super) {\n\t\tu64 bytenr;\n\t\tint i;\n\n\t\t/* make sure this device isn't detected as part of\n\t\t * the FS anymore\n\t\t */\n\t\tmemset(&disk_super->magic, 0, sizeof(disk_super->magic));\n\t\tset_buffer_dirty(bh);\n\t\tsync_dirty_buffer(bh);\n\n\t\t/* clear the mirror copies of super block on the disk\n\t\t * being removed, 0th copy is been taken care above and\n\t\t * the below would take of the rest\n\t\t */\n\t\tfor (i = 1; i < BTRFS_SUPER_MIRROR_MAX; i++) {\n\t\t\tbytenr = btrfs_sb_offset(i);\n\t\t\tif (bytenr + BTRFS_SUPER_INFO_SIZE >=\n\t\t\t\t\ti_size_read(bdev->bd_inode))\n\t\t\t\tbreak;\n\n\t\t\tbrelse(bh);\n\t\t\tbh = __bread(bdev, bytenr / 4096,\n\t\t\t\t\tBTRFS_SUPER_INFO_SIZE);\n\t\t\tif (!bh)\n\t\t\t\tcontinue;\n\n\t\t\tdisk_super = (struct btrfs_super_block *)bh->b_data;\n\n\t\t\tif (btrfs_super_bytenr(disk_super) != bytenr ||\n\t\t\t\tbtrfs_super_magic(disk_super) != BTRFS_MAGIC) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmemset(&disk_super->magic, 0,\n\t\t\t\t\t\tsizeof(disk_super->magic));\n\t\t\tset_buffer_dirty(bh);\n\t\t\tsync_dirty_buffer(bh);\n\t\t}\n\t}\n\n\tret = 0;\n\n\tif (bdev) {\n\t\t/* Notify udev that device has changed */\n\t\tbtrfs_kobject_uevent(bdev, KOBJ_CHANGE);\n\n\t\t/* Update ctime/mtime for device path for libblkid */\n\t\tupdate_dev_time(device_path);\n\t}\n\nerror_brelse:\n\tbrelse(bh);\n\tif (bdev)\n\t\tblkdev_put(bdev, FMODE_READ | FMODE_EXCL);\nout:\n\tmutex_unlock(&uuid_mutex);\n\treturn ret;\nerror_undo:\n\tif (device->writeable) {\n\t\tlock_chunks(root);\n\t\tlist_add(&device->dev_alloc_list,\n\t\t\t &root->fs_info->fs_devices->alloc_list);\n\t\tdevice->fs_devices->rw_devices++;\n\t\tunlock_chunks(root);\n\t}\n\tgoto error_brelse;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&root->fs_info->volume_mutex"
          ],
          "line": 2654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_xchg",
          "args": [
            "&root->fs_info->mutually_exclusive_operation_running",
            "1"
          ],
          "line": 2648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "vol_args"
          ],
          "line": 2642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "vol_args"
          ],
          "line": 2641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user",
          "args": [
            "arg",
            "sizeof(*vol_args)"
          ],
          "line": 2640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "file"
          ],
          "line": 2636
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 2633
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "file_inode(file)"
          ],
          "line": 2629
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 2629
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_rm_dev(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tstruct btrfs_ioctl_vol_args *vol_args;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tvol_args = memdup_user(arg, sizeof(*vol_args));\n\tif (IS_ERR(vol_args)) {\n\t\tret = PTR_ERR(vol_args);\n\t\tgoto err_drop;\n\t}\n\n\tvol_args->name[BTRFS_PATH_NAME_MAX] = '\\0';\n\n\tif (atomic_xchg(&root->fs_info->mutually_exclusive_operation_running,\n\t\t\t1)) {\n\t\tret = BTRFS_ERROR_DEV_EXCL_RUN_IN_PROGRESS;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&root->fs_info->volume_mutex);\n\tret = btrfs_rm_device(root, vol_args->name);\n\tmutex_unlock(&root->fs_info->volume_mutex);\n\tatomic_set(&root->fs_info->mutually_exclusive_operation_running, 0);\n\n\tif (!ret)\n\t\tbtrfs_info(root->fs_info, \"disk deleted %s\",vol_args->name);\n\nout:\n\tkfree(vol_args);\nerr_drop:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_ioctl_add_dev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "2594-2625",
    "snippet": "static long btrfs_ioctl_add_dev(struct btrfs_root *root, void __user *arg)\n{\n\tstruct btrfs_ioctl_vol_args *vol_args;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (atomic_xchg(&root->fs_info->mutually_exclusive_operation_running,\n\t\t\t1)) {\n\t\treturn BTRFS_ERROR_DEV_EXCL_RUN_IN_PROGRESS;\n\t}\n\n\tmutex_lock(&root->fs_info->volume_mutex);\n\tvol_args = memdup_user(arg, sizeof(*vol_args));\n\tif (IS_ERR(vol_args)) {\n\t\tret = PTR_ERR(vol_args);\n\t\tgoto out;\n\t}\n\n\tvol_args->name[BTRFS_PATH_NAME_MAX] = '\\0';\n\tret = btrfs_init_new_device(root, vol_args->name);\n\n\tif (!ret)\n\t\tbtrfs_info(root->fs_info, \"disk added %s\",vol_args->name);\n\n\tkfree(vol_args);\nout:\n\tmutex_unlock(&root->fs_info->volume_mutex);\n\tatomic_set(&root->fs_info->mutually_exclusive_operation_running, 0);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&root->fs_info->mutually_exclusive_operation_running",
            "0"
          ],
          "line": 2623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->fs_info->volume_mutex"
          ],
          "line": 2622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "vol_args"
          ],
          "line": 2620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_info",
          "args": [
            "root->fs_info",
            "\"disk added %s\"",
            "vol_args->name"
          ],
          "line": 2618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_init_new_device",
          "args": [
            "root",
            "vol_args->name"
          ],
          "line": 2615
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_new_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "2088-2294",
          "snippet": "int btrfs_init_new_device(struct btrfs_root *root, char *device_path)\n{\n\tstruct request_queue *q;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_device *device;\n\tstruct block_device *bdev;\n\tstruct list_head *devices;\n\tstruct super_block *sb = root->fs_info->sb;\n\tstruct rcu_string *name;\n\tu64 tmp;\n\tint seeding_dev = 0;\n\tint ret = 0;\n\n\tif ((sb->s_flags & MS_RDONLY) && !root->fs_info->fs_devices->seeding)\n\t\treturn -EROFS;\n\n\tbdev = blkdev_get_by_path(device_path, FMODE_WRITE | FMODE_EXCL,\n\t\t\t\t  root->fs_info->bdev_holder);\n\tif (IS_ERR(bdev))\n\t\treturn PTR_ERR(bdev);\n\n\tif (root->fs_info->fs_devices->seeding) {\n\t\tseeding_dev = 1;\n\t\tdown_write(&sb->s_umount);\n\t\tmutex_lock(&uuid_mutex);\n\t}\n\n\tfilemap_write_and_wait(bdev->bd_inode->i_mapping);\n\n\tdevices = &root->fs_info->fs_devices->devices;\n\n\tmutex_lock(&root->fs_info->fs_devices->device_list_mutex);\n\tlist_for_each_entry(device, devices, dev_list) {\n\t\tif (device->bdev == bdev) {\n\t\t\tret = -EEXIST;\n\t\t\tmutex_unlock(\n\t\t\t\t&root->fs_info->fs_devices->device_list_mutex);\n\t\t\tgoto error;\n\t\t}\n\t}\n\tmutex_unlock(&root->fs_info->fs_devices->device_list_mutex);\n\n\tdevice = btrfs_alloc_device(root->fs_info, NULL, NULL);\n\tif (IS_ERR(device)) {\n\t\t/* we can safely leave the fs_devices entry around */\n\t\tret = PTR_ERR(device);\n\t\tgoto error;\n\t}\n\n\tname = rcu_string_strdup(device_path, GFP_NOFS);\n\tif (!name) {\n\t\tkfree(device);\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\trcu_assign_pointer(device->name, name);\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\trcu_string_free(device->name);\n\t\tkfree(device);\n\t\tret = PTR_ERR(trans);\n\t\tgoto error;\n\t}\n\n\tq = bdev_get_queue(bdev);\n\tif (blk_queue_discard(q))\n\t\tdevice->can_discard = 1;\n\tdevice->writeable = 1;\n\tdevice->generation = trans->transid;\n\tdevice->io_width = root->sectorsize;\n\tdevice->io_align = root->sectorsize;\n\tdevice->sector_size = root->sectorsize;\n\tdevice->total_bytes = i_size_read(bdev->bd_inode);\n\tdevice->disk_total_bytes = device->total_bytes;\n\tdevice->commit_total_bytes = device->total_bytes;\n\tdevice->dev_root = root->fs_info->dev_root;\n\tdevice->bdev = bdev;\n\tdevice->in_fs_metadata = 1;\n\tdevice->is_tgtdev_for_dev_replace = 0;\n\tdevice->mode = FMODE_EXCL;\n\tdevice->dev_stats_valid = 1;\n\tset_blocksize(device->bdev, 4096);\n\n\tif (seeding_dev) {\n\t\tsb->s_flags &= ~MS_RDONLY;\n\t\tret = btrfs_prepare_sprout(root);\n\t\tBUG_ON(ret); /* -ENOMEM */\n\t}\n\n\tdevice->fs_devices = root->fs_info->fs_devices;\n\n\tmutex_lock(&root->fs_info->fs_devices->device_list_mutex);\n\tlock_chunks(root);\n\tlist_add_rcu(&device->dev_list, &root->fs_info->fs_devices->devices);\n\tlist_add(&device->dev_alloc_list,\n\t\t &root->fs_info->fs_devices->alloc_list);\n\troot->fs_info->fs_devices->num_devices++;\n\troot->fs_info->fs_devices->open_devices++;\n\troot->fs_info->fs_devices->rw_devices++;\n\troot->fs_info->fs_devices->total_devices++;\n\troot->fs_info->fs_devices->total_rw_bytes += device->total_bytes;\n\n\tspin_lock(&root->fs_info->free_chunk_lock);\n\troot->fs_info->free_chunk_space += device->total_bytes;\n\tspin_unlock(&root->fs_info->free_chunk_lock);\n\n\tif (!blk_queue_nonrot(bdev_get_queue(bdev)))\n\t\troot->fs_info->fs_devices->rotating = 1;\n\n\ttmp = btrfs_super_total_bytes(root->fs_info->super_copy);\n\tbtrfs_set_super_total_bytes(root->fs_info->super_copy,\n\t\t\t\t    tmp + device->total_bytes);\n\n\ttmp = btrfs_super_num_devices(root->fs_info->super_copy);\n\tbtrfs_set_super_num_devices(root->fs_info->super_copy,\n\t\t\t\t    tmp + 1);\n\n\t/* add sysfs device entry */\n\tbtrfs_kobj_add_device(root->fs_info, device);\n\n\t/*\n\t * we've got more storage, clear any full flags on the space\n\t * infos\n\t */\n\tbtrfs_clear_space_info_full(root->fs_info);\n\n\tunlock_chunks(root);\n\tmutex_unlock(&root->fs_info->fs_devices->device_list_mutex);\n\n\tif (seeding_dev) {\n\t\tlock_chunks(root);\n\t\tret = init_first_rw_device(trans, root, device);\n\t\tunlock_chunks(root);\n\t\tif (ret) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto error_trans;\n\t\t}\n\t}\n\n\tret = btrfs_add_device(trans, root, device);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto error_trans;\n\t}\n\n\tif (seeding_dev) {\n\t\tchar fsid_buf[BTRFS_UUID_UNPARSED_SIZE];\n\n\t\tret = btrfs_finish_sprout(trans, root);\n\t\tif (ret) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto error_trans;\n\t\t}\n\n\t\t/* Sprouting would change fsid of the mounted root,\n\t\t * so rename the fsid on the sysfs\n\t\t */\n\t\tsnprintf(fsid_buf, BTRFS_UUID_UNPARSED_SIZE, \"%pU\",\n\t\t\t\t\t\troot->fs_info->fsid);\n\t\tif (kobject_rename(&root->fs_info->super_kobj, fsid_buf))\n\t\t\tgoto error_trans;\n\t}\n\n\troot->fs_info->num_tolerated_disk_barrier_failures =\n\t\tbtrfs_calc_num_tolerated_disk_barrier_failures(root->fs_info);\n\tret = btrfs_commit_transaction(trans, root);\n\n\tif (seeding_dev) {\n\t\tmutex_unlock(&uuid_mutex);\n\t\tup_write(&sb->s_umount);\n\n\t\tif (ret) /* transaction commit */\n\t\t\treturn ret;\n\n\t\tret = btrfs_relocate_sys_chunks(root);\n\t\tif (ret < 0)\n\t\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t\t    \"Failed to relocate sys chunks after \"\n\t\t\t\t    \"device initialization. This can be fixed \"\n\t\t\t\t    \"using the \\\"btrfs balance\\\" command.\");\n\t\ttrans = btrfs_attach_transaction(root);\n\t\tif (IS_ERR(trans)) {\n\t\t\tif (PTR_ERR(trans) == -ENOENT)\n\t\t\t\treturn 0;\n\t\t\treturn PTR_ERR(trans);\n\t\t}\n\t\tret = btrfs_commit_transaction(trans, root);\n\t}\n\n\t/* Update ctime/mtime for libblkid */\n\tupdate_dev_time(device_path);\n\treturn ret;\n\nerror_trans:\n\tbtrfs_end_transaction(trans, root);\n\trcu_string_free(device->name);\n\tbtrfs_kobj_rm_device(root->fs_info, device);\n\tkfree(device);\nerror:\n\tblkdev_put(bdev, FMODE_EXCL);\n\tif (seeding_dev) {\n\t\tmutex_unlock(&uuid_mutex);\n\t\tup_write(&sb->s_umount);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_init_new_device(struct btrfs_root *root, char *device_path)\n{\n\tstruct request_queue *q;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_device *device;\n\tstruct block_device *bdev;\n\tstruct list_head *devices;\n\tstruct super_block *sb = root->fs_info->sb;\n\tstruct rcu_string *name;\n\tu64 tmp;\n\tint seeding_dev = 0;\n\tint ret = 0;\n\n\tif ((sb->s_flags & MS_RDONLY) && !root->fs_info->fs_devices->seeding)\n\t\treturn -EROFS;\n\n\tbdev = blkdev_get_by_path(device_path, FMODE_WRITE | FMODE_EXCL,\n\t\t\t\t  root->fs_info->bdev_holder);\n\tif (IS_ERR(bdev))\n\t\treturn PTR_ERR(bdev);\n\n\tif (root->fs_info->fs_devices->seeding) {\n\t\tseeding_dev = 1;\n\t\tdown_write(&sb->s_umount);\n\t\tmutex_lock(&uuid_mutex);\n\t}\n\n\tfilemap_write_and_wait(bdev->bd_inode->i_mapping);\n\n\tdevices = &root->fs_info->fs_devices->devices;\n\n\tmutex_lock(&root->fs_info->fs_devices->device_list_mutex);\n\tlist_for_each_entry(device, devices, dev_list) {\n\t\tif (device->bdev == bdev) {\n\t\t\tret = -EEXIST;\n\t\t\tmutex_unlock(\n\t\t\t\t&root->fs_info->fs_devices->device_list_mutex);\n\t\t\tgoto error;\n\t\t}\n\t}\n\tmutex_unlock(&root->fs_info->fs_devices->device_list_mutex);\n\n\tdevice = btrfs_alloc_device(root->fs_info, NULL, NULL);\n\tif (IS_ERR(device)) {\n\t\t/* we can safely leave the fs_devices entry around */\n\t\tret = PTR_ERR(device);\n\t\tgoto error;\n\t}\n\n\tname = rcu_string_strdup(device_path, GFP_NOFS);\n\tif (!name) {\n\t\tkfree(device);\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\trcu_assign_pointer(device->name, name);\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\trcu_string_free(device->name);\n\t\tkfree(device);\n\t\tret = PTR_ERR(trans);\n\t\tgoto error;\n\t}\n\n\tq = bdev_get_queue(bdev);\n\tif (blk_queue_discard(q))\n\t\tdevice->can_discard = 1;\n\tdevice->writeable = 1;\n\tdevice->generation = trans->transid;\n\tdevice->io_width = root->sectorsize;\n\tdevice->io_align = root->sectorsize;\n\tdevice->sector_size = root->sectorsize;\n\tdevice->total_bytes = i_size_read(bdev->bd_inode);\n\tdevice->disk_total_bytes = device->total_bytes;\n\tdevice->commit_total_bytes = device->total_bytes;\n\tdevice->dev_root = root->fs_info->dev_root;\n\tdevice->bdev = bdev;\n\tdevice->in_fs_metadata = 1;\n\tdevice->is_tgtdev_for_dev_replace = 0;\n\tdevice->mode = FMODE_EXCL;\n\tdevice->dev_stats_valid = 1;\n\tset_blocksize(device->bdev, 4096);\n\n\tif (seeding_dev) {\n\t\tsb->s_flags &= ~MS_RDONLY;\n\t\tret = btrfs_prepare_sprout(root);\n\t\tBUG_ON(ret); /* -ENOMEM */\n\t}\n\n\tdevice->fs_devices = root->fs_info->fs_devices;\n\n\tmutex_lock(&root->fs_info->fs_devices->device_list_mutex);\n\tlock_chunks(root);\n\tlist_add_rcu(&device->dev_list, &root->fs_info->fs_devices->devices);\n\tlist_add(&device->dev_alloc_list,\n\t\t &root->fs_info->fs_devices->alloc_list);\n\troot->fs_info->fs_devices->num_devices++;\n\troot->fs_info->fs_devices->open_devices++;\n\troot->fs_info->fs_devices->rw_devices++;\n\troot->fs_info->fs_devices->total_devices++;\n\troot->fs_info->fs_devices->total_rw_bytes += device->total_bytes;\n\n\tspin_lock(&root->fs_info->free_chunk_lock);\n\troot->fs_info->free_chunk_space += device->total_bytes;\n\tspin_unlock(&root->fs_info->free_chunk_lock);\n\n\tif (!blk_queue_nonrot(bdev_get_queue(bdev)))\n\t\troot->fs_info->fs_devices->rotating = 1;\n\n\ttmp = btrfs_super_total_bytes(root->fs_info->super_copy);\n\tbtrfs_set_super_total_bytes(root->fs_info->super_copy,\n\t\t\t\t    tmp + device->total_bytes);\n\n\ttmp = btrfs_super_num_devices(root->fs_info->super_copy);\n\tbtrfs_set_super_num_devices(root->fs_info->super_copy,\n\t\t\t\t    tmp + 1);\n\n\t/* add sysfs device entry */\n\tbtrfs_kobj_add_device(root->fs_info, device);\n\n\t/*\n\t * we've got more storage, clear any full flags on the space\n\t * infos\n\t */\n\tbtrfs_clear_space_info_full(root->fs_info);\n\n\tunlock_chunks(root);\n\tmutex_unlock(&root->fs_info->fs_devices->device_list_mutex);\n\n\tif (seeding_dev) {\n\t\tlock_chunks(root);\n\t\tret = init_first_rw_device(trans, root, device);\n\t\tunlock_chunks(root);\n\t\tif (ret) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto error_trans;\n\t\t}\n\t}\n\n\tret = btrfs_add_device(trans, root, device);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto error_trans;\n\t}\n\n\tif (seeding_dev) {\n\t\tchar fsid_buf[BTRFS_UUID_UNPARSED_SIZE];\n\n\t\tret = btrfs_finish_sprout(trans, root);\n\t\tif (ret) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto error_trans;\n\t\t}\n\n\t\t/* Sprouting would change fsid of the mounted root,\n\t\t * so rename the fsid on the sysfs\n\t\t */\n\t\tsnprintf(fsid_buf, BTRFS_UUID_UNPARSED_SIZE, \"%pU\",\n\t\t\t\t\t\troot->fs_info->fsid);\n\t\tif (kobject_rename(&root->fs_info->super_kobj, fsid_buf))\n\t\t\tgoto error_trans;\n\t}\n\n\troot->fs_info->num_tolerated_disk_barrier_failures =\n\t\tbtrfs_calc_num_tolerated_disk_barrier_failures(root->fs_info);\n\tret = btrfs_commit_transaction(trans, root);\n\n\tif (seeding_dev) {\n\t\tmutex_unlock(&uuid_mutex);\n\t\tup_write(&sb->s_umount);\n\n\t\tif (ret) /* transaction commit */\n\t\t\treturn ret;\n\n\t\tret = btrfs_relocate_sys_chunks(root);\n\t\tif (ret < 0)\n\t\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t\t    \"Failed to relocate sys chunks after \"\n\t\t\t\t    \"device initialization. This can be fixed \"\n\t\t\t\t    \"using the \\\"btrfs balance\\\" command.\");\n\t\ttrans = btrfs_attach_transaction(root);\n\t\tif (IS_ERR(trans)) {\n\t\t\tif (PTR_ERR(trans) == -ENOENT)\n\t\t\t\treturn 0;\n\t\t\treturn PTR_ERR(trans);\n\t\t}\n\t\tret = btrfs_commit_transaction(trans, root);\n\t}\n\n\t/* Update ctime/mtime for libblkid */\n\tupdate_dev_time(device_path);\n\treturn ret;\n\nerror_trans:\n\tbtrfs_end_transaction(trans, root);\n\trcu_string_free(device->name);\n\tbtrfs_kobj_rm_device(root->fs_info, device);\n\tkfree(device);\nerror:\n\tblkdev_put(bdev, FMODE_EXCL);\n\tif (seeding_dev) {\n\t\tmutex_unlock(&uuid_mutex);\n\t\tup_write(&sb->s_umount);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "vol_args"
          ],
          "line": 2610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "vol_args"
          ],
          "line": 2609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user",
          "args": [
            "arg",
            "sizeof(*vol_args)"
          ],
          "line": 2608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&root->fs_info->volume_mutex"
          ],
          "line": 2607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_xchg",
          "args": [
            "&root->fs_info->mutually_exclusive_operation_running",
            "1"
          ],
          "line": 2602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 2599
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic long btrfs_ioctl_add_dev(struct btrfs_root *root, void __user *arg)\n{\n\tstruct btrfs_ioctl_vol_args *vol_args;\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (atomic_xchg(&root->fs_info->mutually_exclusive_operation_running,\n\t\t\t1)) {\n\t\treturn BTRFS_ERROR_DEV_EXCL_RUN_IN_PROGRESS;\n\t}\n\n\tmutex_lock(&root->fs_info->volume_mutex);\n\tvol_args = memdup_user(arg, sizeof(*vol_args));\n\tif (IS_ERR(vol_args)) {\n\t\tret = PTR_ERR(vol_args);\n\t\tgoto out;\n\t}\n\n\tvol_args->name[BTRFS_PATH_NAME_MAX] = '\\0';\n\tret = btrfs_init_new_device(root, vol_args->name);\n\n\tif (!ret)\n\t\tbtrfs_info(root->fs_info, \"disk added %s\",vol_args->name);\n\n\tkfree(vol_args);\nout:\n\tmutex_unlock(&root->fs_info->volume_mutex);\n\tatomic_set(&root->fs_info->mutually_exclusive_operation_running, 0);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_ioctl_defrag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "2525-2592",
    "snippet": "static int btrfs_ioctl_defrag(struct file *file, void __user *argp)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_ioctl_defrag_range_args *range;\n\tint ret;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tif (btrfs_root_readonly(root)) {\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tif (!capable(CAP_SYS_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = btrfs_defrag_root(root);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tret = btrfs_defrag_root(root->fs_info->extent_root);\n\t\tbreak;\n\tcase S_IFREG:\n\t\tif (!(file->f_mode & FMODE_WRITE)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\trange = kzalloc(sizeof(*range), GFP_KERNEL);\n\t\tif (!range) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (argp) {\n\t\t\tif (copy_from_user(range, argp,\n\t\t\t\t\t   sizeof(*range))) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tkfree(range);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t/* compression requires us to start the IO */\n\t\t\tif ((range->flags & BTRFS_DEFRAG_RANGE_COMPRESS)) {\n\t\t\t\trange->flags |= BTRFS_DEFRAG_RANGE_START_IO;\n\t\t\t\trange->extent_thresh = (u32)-1;\n\t\t\t}\n\t\t} else {\n\t\t\t/* the rest are all set to zero by kzalloc */\n\t\t\trange->len = (u64)-1;\n\t\t}\n\t\tret = btrfs_defrag_file(file_inode(file), file,\n\t\t\t\t\trange, 0, 0);\n\t\tif (ret > 0)\n\t\t\tret = 0;\n\t\tkfree(range);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\nout:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "file"
          ],
          "line": 2590
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "range"
          ],
          "line": 2584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_defrag_file",
          "args": [
            "file_inode(file)",
            "file",
            "range",
            "0",
            "0"
          ],
          "line": 2580
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_defrag_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "1231-1448",
          "snippet": "int btrfs_defrag_file(struct inode *inode, struct file *file,\n\t\t      struct btrfs_ioctl_defrag_range_args *range,\n\t\t      u64 newer_than, unsigned long max_to_defrag)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct file_ra_state *ra = NULL;\n\tunsigned long last_index;\n\tu64 isize = i_size_read(inode);\n\tu64 last_len = 0;\n\tu64 skip = 0;\n\tu64 defrag_end = 0;\n\tu64 newer_off = range->start;\n\tunsigned long i;\n\tunsigned long ra_index = 0;\n\tint ret;\n\tint defrag_count = 0;\n\tint compress_type = BTRFS_COMPRESS_ZLIB;\n\tu32 extent_thresh = range->extent_thresh;\n\tunsigned long max_cluster = (256 * 1024) >> PAGE_CACHE_SHIFT;\n\tunsigned long cluster = max_cluster;\n\tu64 new_align = ~((u64)128 * 1024 - 1);\n\tstruct page **pages = NULL;\n\n\tif (isize == 0)\n\t\treturn 0;\n\n\tif (range->start >= isize)\n\t\treturn -EINVAL;\n\n\tif (range->flags & BTRFS_DEFRAG_RANGE_COMPRESS) {\n\t\tif (range->compress_type > BTRFS_COMPRESS_TYPES)\n\t\t\treturn -EINVAL;\n\t\tif (range->compress_type)\n\t\t\tcompress_type = range->compress_type;\n\t}\n\n\tif (extent_thresh == 0)\n\t\textent_thresh = 256 * 1024;\n\n\t/*\n\t * if we were not given a file, allocate a readahead\n\t * context\n\t */\n\tif (!file) {\n\t\tra = kzalloc(sizeof(*ra), GFP_NOFS);\n\t\tif (!ra)\n\t\t\treturn -ENOMEM;\n\t\tfile_ra_state_init(ra, inode->i_mapping);\n\t} else {\n\t\tra = &file->f_ra;\n\t}\n\n\tpages = kmalloc_array(max_cluster, sizeof(struct page *),\n\t\t\tGFP_NOFS);\n\tif (!pages) {\n\t\tret = -ENOMEM;\n\t\tgoto out_ra;\n\t}\n\n\t/* find the last page to defrag */\n\tif (range->start + range->len > range->start) {\n\t\tlast_index = min_t(u64, isize - 1,\n\t\t\t range->start + range->len - 1) >> PAGE_CACHE_SHIFT;\n\t} else {\n\t\tlast_index = (isize - 1) >> PAGE_CACHE_SHIFT;\n\t}\n\n\tif (newer_than) {\n\t\tret = find_new_extents(root, inode, newer_than,\n\t\t\t\t       &newer_off, 64 * 1024);\n\t\tif (!ret) {\n\t\t\trange->start = newer_off;\n\t\t\t/*\n\t\t\t * we always align our defrag to help keep\n\t\t\t * the extents in the file evenly spaced\n\t\t\t */\n\t\t\ti = (newer_off & new_align) >> PAGE_CACHE_SHIFT;\n\t\t} else\n\t\t\tgoto out_ra;\n\t} else {\n\t\ti = range->start >> PAGE_CACHE_SHIFT;\n\t}\n\tif (!max_to_defrag)\n\t\tmax_to_defrag = last_index + 1;\n\n\t/*\n\t * make writeback starts from i, so the defrag range can be\n\t * written sequentially.\n\t */\n\tif (i < inode->i_mapping->writeback_index)\n\t\tinode->i_mapping->writeback_index = i;\n\n\twhile (i <= last_index && defrag_count < max_to_defrag &&\n\t       (i < DIV_ROUND_UP(i_size_read(inode), PAGE_CACHE_SIZE))) {\n\t\t/*\n\t\t * make sure we stop running if someone unmounts\n\t\t * the FS\n\t\t */\n\t\tif (!(inode->i_sb->s_flags & MS_ACTIVE))\n\t\t\tbreak;\n\n\t\tif (btrfs_defrag_cancelled(root->fs_info)) {\n\t\t\tprintk(KERN_DEBUG \"BTRFS: defrag_file cancelled\\n\");\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!should_defrag_range(inode, (u64)i << PAGE_CACHE_SHIFT,\n\t\t\t\t\t extent_thresh, &last_len, &skip,\n\t\t\t\t\t &defrag_end, range->flags &\n\t\t\t\t\t BTRFS_DEFRAG_RANGE_COMPRESS)) {\n\t\t\tunsigned long next;\n\t\t\t/*\n\t\t\t * the should_defrag function tells us how much to skip\n\t\t\t * bump our counter by the suggested amount\n\t\t\t */\n\t\t\tnext = DIV_ROUND_UP(skip, PAGE_CACHE_SIZE);\n\t\t\ti = max(i + 1, next);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!newer_than) {\n\t\t\tcluster = (PAGE_CACHE_ALIGN(defrag_end) >>\n\t\t\t\t   PAGE_CACHE_SHIFT) - i;\n\t\t\tcluster = min(cluster, max_cluster);\n\t\t} else {\n\t\t\tcluster = max_cluster;\n\t\t}\n\n\t\tif (i + cluster > ra_index) {\n\t\t\tra_index = max(i, ra_index);\n\t\t\tbtrfs_force_ra(inode->i_mapping, ra, file, ra_index,\n\t\t\t\t       cluster);\n\t\t\tra_index += max_cluster;\n\t\t}\n\n\t\tmutex_lock(&inode->i_mutex);\n\t\tif (range->flags & BTRFS_DEFRAG_RANGE_COMPRESS)\n\t\t\tBTRFS_I(inode)->force_compress = compress_type;\n\t\tret = cluster_pages_for_defrag(inode, pages, i, cluster);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\tgoto out_ra;\n\t\t}\n\n\t\tdefrag_count += ret;\n\t\tbalance_dirty_pages_ratelimited(inode->i_mapping);\n\t\tmutex_unlock(&inode->i_mutex);\n\n\t\tif (newer_than) {\n\t\t\tif (newer_off == (u64)-1)\n\t\t\t\tbreak;\n\n\t\t\tif (ret > 0)\n\t\t\t\ti += ret;\n\n\t\t\tnewer_off = max(newer_off + 1,\n\t\t\t\t\t(u64)i << PAGE_CACHE_SHIFT);\n\n\t\t\tret = find_new_extents(root, inode,\n\t\t\t\t\t       newer_than, &newer_off,\n\t\t\t\t\t       64 * 1024);\n\t\t\tif (!ret) {\n\t\t\t\trange->start = newer_off;\n\t\t\t\ti = (newer_off & new_align) >> PAGE_CACHE_SHIFT;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (ret > 0) {\n\t\t\t\ti += ret;\n\t\t\t\tlast_len += ret << PAGE_CACHE_SHIFT;\n\t\t\t} else {\n\t\t\t\ti++;\n\t\t\t\tlast_len = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((range->flags & BTRFS_DEFRAG_RANGE_START_IO)) {\n\t\tfilemap_flush(inode->i_mapping);\n\t\tif (test_bit(BTRFS_INODE_HAS_ASYNC_EXTENT,\n\t\t\t     &BTRFS_I(inode)->runtime_flags))\n\t\t\tfilemap_flush(inode->i_mapping);\n\t}\n\n\tif ((range->flags & BTRFS_DEFRAG_RANGE_COMPRESS)) {\n\t\t/* the filemap_flush will queue IO into the worker threads, but\n\t\t * we have to make sure the IO is actually started and that\n\t\t * ordered extents get created before we return\n\t\t */\n\t\tatomic_inc(&root->fs_info->async_submit_draining);\n\t\twhile (atomic_read(&root->fs_info->nr_async_submits) ||\n\t\t      atomic_read(&root->fs_info->async_delalloc_pages)) {\n\t\t\twait_event(root->fs_info->async_submit_wait,\n\t\t\t   (atomic_read(&root->fs_info->nr_async_submits) == 0 &&\n\t\t\t    atomic_read(&root->fs_info->async_delalloc_pages) == 0));\n\t\t}\n\t\tatomic_dec(&root->fs_info->async_submit_draining);\n\t}\n\n\tif (range->compress_type == BTRFS_COMPRESS_LZO) {\n\t\tbtrfs_set_fs_incompat(root->fs_info, COMPRESS_LZO);\n\t}\n\n\tret = defrag_count;\n\nout_ra:\n\tif (range->flags & BTRFS_DEFRAG_RANGE_COMPRESS) {\n\t\tmutex_lock(&inode->i_mutex);\n\t\tBTRFS_I(inode)->force_compress = BTRFS_COMPRESS_NONE;\n\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\tif (!file)\n\t\tkfree(ra);\n\tkfree(pages);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nint btrfs_defrag_file(struct inode *inode, struct file *file,\n\t\t      struct btrfs_ioctl_defrag_range_args *range,\n\t\t      u64 newer_than, unsigned long max_to_defrag)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct file_ra_state *ra = NULL;\n\tunsigned long last_index;\n\tu64 isize = i_size_read(inode);\n\tu64 last_len = 0;\n\tu64 skip = 0;\n\tu64 defrag_end = 0;\n\tu64 newer_off = range->start;\n\tunsigned long i;\n\tunsigned long ra_index = 0;\n\tint ret;\n\tint defrag_count = 0;\n\tint compress_type = BTRFS_COMPRESS_ZLIB;\n\tu32 extent_thresh = range->extent_thresh;\n\tunsigned long max_cluster = (256 * 1024) >> PAGE_CACHE_SHIFT;\n\tunsigned long cluster = max_cluster;\n\tu64 new_align = ~((u64)128 * 1024 - 1);\n\tstruct page **pages = NULL;\n\n\tif (isize == 0)\n\t\treturn 0;\n\n\tif (range->start >= isize)\n\t\treturn -EINVAL;\n\n\tif (range->flags & BTRFS_DEFRAG_RANGE_COMPRESS) {\n\t\tif (range->compress_type > BTRFS_COMPRESS_TYPES)\n\t\t\treturn -EINVAL;\n\t\tif (range->compress_type)\n\t\t\tcompress_type = range->compress_type;\n\t}\n\n\tif (extent_thresh == 0)\n\t\textent_thresh = 256 * 1024;\n\n\t/*\n\t * if we were not given a file, allocate a readahead\n\t * context\n\t */\n\tif (!file) {\n\t\tra = kzalloc(sizeof(*ra), GFP_NOFS);\n\t\tif (!ra)\n\t\t\treturn -ENOMEM;\n\t\tfile_ra_state_init(ra, inode->i_mapping);\n\t} else {\n\t\tra = &file->f_ra;\n\t}\n\n\tpages = kmalloc_array(max_cluster, sizeof(struct page *),\n\t\t\tGFP_NOFS);\n\tif (!pages) {\n\t\tret = -ENOMEM;\n\t\tgoto out_ra;\n\t}\n\n\t/* find the last page to defrag */\n\tif (range->start + range->len > range->start) {\n\t\tlast_index = min_t(u64, isize - 1,\n\t\t\t range->start + range->len - 1) >> PAGE_CACHE_SHIFT;\n\t} else {\n\t\tlast_index = (isize - 1) >> PAGE_CACHE_SHIFT;\n\t}\n\n\tif (newer_than) {\n\t\tret = find_new_extents(root, inode, newer_than,\n\t\t\t\t       &newer_off, 64 * 1024);\n\t\tif (!ret) {\n\t\t\trange->start = newer_off;\n\t\t\t/*\n\t\t\t * we always align our defrag to help keep\n\t\t\t * the extents in the file evenly spaced\n\t\t\t */\n\t\t\ti = (newer_off & new_align) >> PAGE_CACHE_SHIFT;\n\t\t} else\n\t\t\tgoto out_ra;\n\t} else {\n\t\ti = range->start >> PAGE_CACHE_SHIFT;\n\t}\n\tif (!max_to_defrag)\n\t\tmax_to_defrag = last_index + 1;\n\n\t/*\n\t * make writeback starts from i, so the defrag range can be\n\t * written sequentially.\n\t */\n\tif (i < inode->i_mapping->writeback_index)\n\t\tinode->i_mapping->writeback_index = i;\n\n\twhile (i <= last_index && defrag_count < max_to_defrag &&\n\t       (i < DIV_ROUND_UP(i_size_read(inode), PAGE_CACHE_SIZE))) {\n\t\t/*\n\t\t * make sure we stop running if someone unmounts\n\t\t * the FS\n\t\t */\n\t\tif (!(inode->i_sb->s_flags & MS_ACTIVE))\n\t\t\tbreak;\n\n\t\tif (btrfs_defrag_cancelled(root->fs_info)) {\n\t\t\tprintk(KERN_DEBUG \"BTRFS: defrag_file cancelled\\n\");\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!should_defrag_range(inode, (u64)i << PAGE_CACHE_SHIFT,\n\t\t\t\t\t extent_thresh, &last_len, &skip,\n\t\t\t\t\t &defrag_end, range->flags &\n\t\t\t\t\t BTRFS_DEFRAG_RANGE_COMPRESS)) {\n\t\t\tunsigned long next;\n\t\t\t/*\n\t\t\t * the should_defrag function tells us how much to skip\n\t\t\t * bump our counter by the suggested amount\n\t\t\t */\n\t\t\tnext = DIV_ROUND_UP(skip, PAGE_CACHE_SIZE);\n\t\t\ti = max(i + 1, next);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!newer_than) {\n\t\t\tcluster = (PAGE_CACHE_ALIGN(defrag_end) >>\n\t\t\t\t   PAGE_CACHE_SHIFT) - i;\n\t\t\tcluster = min(cluster, max_cluster);\n\t\t} else {\n\t\t\tcluster = max_cluster;\n\t\t}\n\n\t\tif (i + cluster > ra_index) {\n\t\t\tra_index = max(i, ra_index);\n\t\t\tbtrfs_force_ra(inode->i_mapping, ra, file, ra_index,\n\t\t\t\t       cluster);\n\t\t\tra_index += max_cluster;\n\t\t}\n\n\t\tmutex_lock(&inode->i_mutex);\n\t\tif (range->flags & BTRFS_DEFRAG_RANGE_COMPRESS)\n\t\t\tBTRFS_I(inode)->force_compress = compress_type;\n\t\tret = cluster_pages_for_defrag(inode, pages, i, cluster);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\tgoto out_ra;\n\t\t}\n\n\t\tdefrag_count += ret;\n\t\tbalance_dirty_pages_ratelimited(inode->i_mapping);\n\t\tmutex_unlock(&inode->i_mutex);\n\n\t\tif (newer_than) {\n\t\t\tif (newer_off == (u64)-1)\n\t\t\t\tbreak;\n\n\t\t\tif (ret > 0)\n\t\t\t\ti += ret;\n\n\t\t\tnewer_off = max(newer_off + 1,\n\t\t\t\t\t(u64)i << PAGE_CACHE_SHIFT);\n\n\t\t\tret = find_new_extents(root, inode,\n\t\t\t\t\t       newer_than, &newer_off,\n\t\t\t\t\t       64 * 1024);\n\t\t\tif (!ret) {\n\t\t\t\trange->start = newer_off;\n\t\t\t\ti = (newer_off & new_align) >> PAGE_CACHE_SHIFT;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (ret > 0) {\n\t\t\t\ti += ret;\n\t\t\t\tlast_len += ret << PAGE_CACHE_SHIFT;\n\t\t\t} else {\n\t\t\t\ti++;\n\t\t\t\tlast_len = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((range->flags & BTRFS_DEFRAG_RANGE_START_IO)) {\n\t\tfilemap_flush(inode->i_mapping);\n\t\tif (test_bit(BTRFS_INODE_HAS_ASYNC_EXTENT,\n\t\t\t     &BTRFS_I(inode)->runtime_flags))\n\t\t\tfilemap_flush(inode->i_mapping);\n\t}\n\n\tif ((range->flags & BTRFS_DEFRAG_RANGE_COMPRESS)) {\n\t\t/* the filemap_flush will queue IO into the worker threads, but\n\t\t * we have to make sure the IO is actually started and that\n\t\t * ordered extents get created before we return\n\t\t */\n\t\tatomic_inc(&root->fs_info->async_submit_draining);\n\t\twhile (atomic_read(&root->fs_info->nr_async_submits) ||\n\t\t      atomic_read(&root->fs_info->async_delalloc_pages)) {\n\t\t\twait_event(root->fs_info->async_submit_wait,\n\t\t\t   (atomic_read(&root->fs_info->nr_async_submits) == 0 &&\n\t\t\t    atomic_read(&root->fs_info->async_delalloc_pages) == 0));\n\t\t}\n\t\tatomic_dec(&root->fs_info->async_submit_draining);\n\t}\n\n\tif (range->compress_type == BTRFS_COMPRESS_LZO) {\n\t\tbtrfs_set_fs_incompat(root->fs_info, COMPRESS_LZO);\n\t}\n\n\tret = defrag_count;\n\nout_ra:\n\tif (range->flags & BTRFS_DEFRAG_RANGE_COMPRESS) {\n\t\tmutex_lock(&inode->i_mutex);\n\t\tBTRFS_I(inode)->force_compress = BTRFS_COMPRESS_NONE;\n\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\tif (!file)\n\t\tkfree(ra);\n\tkfree(pages);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 2580
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "range"
          ],
          "line": 2568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "range",
            "argp",
            "sizeof(*range)"
          ],
          "line": 2565
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*range)",
            "GFP_KERNEL"
          ],
          "line": 2558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_defrag_root",
          "args": [
            "root->fs_info->extent_root"
          ],
          "line": 2550
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_defrag_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "1205-1236",
          "snippet": "int btrfs_defrag_root(struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *info = root->fs_info;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\n\tif (test_and_set_bit(BTRFS_ROOT_DEFRAG_RUNNING, &root->state))\n\t\treturn 0;\n\n\twhile (1) {\n\t\ttrans = btrfs_start_transaction(root, 0);\n\t\tif (IS_ERR(trans))\n\t\t\treturn PTR_ERR(trans);\n\n\t\tret = btrfs_defrag_leaves(trans, root);\n\n\t\tbtrfs_end_transaction(trans, root);\n\t\tbtrfs_btree_balance_dirty(info->tree_root);\n\t\tcond_resched();\n\n\t\tif (btrfs_fs_closing(root->fs_info) || ret != -EAGAIN)\n\t\t\tbreak;\n\n\t\tif (btrfs_defrag_cancelled(root->fs_info)) {\n\t\t\tpr_debug(\"BTRFS: defrag_root cancelled\\n\");\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t}\n\tclear_bit(BTRFS_ROOT_DEFRAG_RUNNING, &root->state);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_defrag_root(struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *info = root->fs_info;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\n\tif (test_and_set_bit(BTRFS_ROOT_DEFRAG_RUNNING, &root->state))\n\t\treturn 0;\n\n\twhile (1) {\n\t\ttrans = btrfs_start_transaction(root, 0);\n\t\tif (IS_ERR(trans))\n\t\t\treturn PTR_ERR(trans);\n\n\t\tret = btrfs_defrag_leaves(trans, root);\n\n\t\tbtrfs_end_transaction(trans, root);\n\t\tbtrfs_btree_balance_dirty(info->tree_root);\n\t\tcond_resched();\n\n\t\tif (btrfs_fs_closing(root->fs_info) || ret != -EAGAIN)\n\t\t\tbreak;\n\n\t\tif (btrfs_defrag_cancelled(root->fs_info)) {\n\t\t\tpr_debug(\"BTRFS: defrag_root cancelled\\n\");\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t}\n\tclear_bit(BTRFS_ROOT_DEFRAG_RUNNING, &root->state);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 2543
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_root_readonly",
          "args": [
            "root"
          ],
          "line": 2536
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_root_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2876-2879",
          "snippet": "static inline bool btrfs_root_readonly(struct btrfs_root *root)\n{\n\treturn (root->root_item.flags & cpu_to_le64(BTRFS_ROOT_SUBVOL_RDONLY)) != 0;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_ROOT_SUBVOL_RDONLY\t(1ULL << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_ROOT_SUBVOL_RDONLY\t(1ULL << 0)\n\nstatic inline bool btrfs_root_readonly(struct btrfs_root *root)\n{\n\treturn (root->root_item.flags & cpu_to_le64(BTRFS_ROOT_SUBVOL_RDONLY)) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "file"
          ],
          "line": 2532
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 2528
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_ioctl_defrag(struct file *file, void __user *argp)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_ioctl_defrag_range_args *range;\n\tint ret;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tif (btrfs_root_readonly(root)) {\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tif (!capable(CAP_SYS_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = btrfs_defrag_root(root);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tret = btrfs_defrag_root(root->fs_info->extent_root);\n\t\tbreak;\n\tcase S_IFREG:\n\t\tif (!(file->f_mode & FMODE_WRITE)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\trange = kzalloc(sizeof(*range), GFP_KERNEL);\n\t\tif (!range) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (argp) {\n\t\t\tif (copy_from_user(range, argp,\n\t\t\t\t\t   sizeof(*range))) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tkfree(range);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t/* compression requires us to start the IO */\n\t\t\tif ((range->flags & BTRFS_DEFRAG_RANGE_COMPRESS)) {\n\t\t\t\trange->flags |= BTRFS_DEFRAG_RANGE_START_IO;\n\t\t\t\trange->extent_thresh = (u32)-1;\n\t\t\t}\n\t\t} else {\n\t\t\t/* the rest are all set to zero by kzalloc */\n\t\t\trange->len = (u64)-1;\n\t\t}\n\t\tret = btrfs_defrag_file(file_inode(file), file,\n\t\t\t\t\trange, 0, 0);\n\t\tif (ret > 0)\n\t\t\tret = 0;\n\t\tkfree(range);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\nout:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_ioctl_snap_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "2292-2523",
    "snippet": "static noinline int btrfs_ioctl_snap_destroy(struct file *file,\n\t\t\t\t\t     void __user *arg)\n{\n\tstruct dentry *parent = file->f_path.dentry;\n\tstruct dentry *dentry;\n\tstruct inode *dir = parent->d_inode;\n\tstruct inode *inode;\n\tstruct btrfs_root *root = BTRFS_I(dir)->root;\n\tstruct btrfs_root *dest = NULL;\n\tstruct btrfs_ioctl_vol_args *vol_args;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_block_rsv block_rsv;\n\tu64 root_flags;\n\tu64 qgroup_reserved;\n\tint namelen;\n\tint ret;\n\tint err = 0;\n\n\tvol_args = memdup_user(arg, sizeof(*vol_args));\n\tif (IS_ERR(vol_args))\n\t\treturn PTR_ERR(vol_args);\n\n\tvol_args->name[BTRFS_PATH_NAME_MAX] = '\\0';\n\tnamelen = strlen(vol_args->name);\n\tif (strchr(vol_args->name, '/') ||\n\t    strncmp(vol_args->name, \"..\", namelen) == 0) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = mnt_want_write_file(file);\n\tif (err)\n\t\tgoto out;\n\n\n\terr = mutex_lock_killable_nested(&dir->i_mutex, I_MUTEX_PARENT);\n\tif (err == -EINTR)\n\t\tgoto out_drop_write;\n\tdentry = lookup_one_len(vol_args->name, parent, namelen);\n\tif (IS_ERR(dentry)) {\n\t\terr = PTR_ERR(dentry);\n\t\tgoto out_unlock_dir;\n\t}\n\n\tif (!dentry->d_inode) {\n\t\terr = -ENOENT;\n\t\tgoto out_dput;\n\t}\n\n\tinode = dentry->d_inode;\n\tdest = BTRFS_I(inode)->root;\n\tif (!capable(CAP_SYS_ADMIN)) {\n\t\t/*\n\t\t * Regular user.  Only allow this with a special mount\n\t\t * option, when the user has write+exec access to the\n\t\t * subvol root, and when rmdir(2) would have been\n\t\t * allowed.\n\t\t *\n\t\t * Note that this is _not_ check that the subvol is\n\t\t * empty or doesn't contain data that we wouldn't\n\t\t * otherwise be able to delete.\n\t\t *\n\t\t * Users who want to delete empty subvols should try\n\t\t * rmdir(2).\n\t\t */\n\t\terr = -EPERM;\n\t\tif (!btrfs_test_opt(root, USER_SUBVOL_RM_ALLOWED))\n\t\t\tgoto out_dput;\n\n\t\t/*\n\t\t * Do not allow deletion if the parent dir is the same\n\t\t * as the dir to be deleted.  That means the ioctl\n\t\t * must be called on the dentry referencing the root\n\t\t * of the subvol, not a random directory contained\n\t\t * within it.\n\t\t */\n\t\terr = -EINVAL;\n\t\tif (root == dest)\n\t\t\tgoto out_dput;\n\n\t\terr = inode_permission(inode, MAY_WRITE | MAY_EXEC);\n\t\tif (err)\n\t\t\tgoto out_dput;\n\t}\n\n\t/* check if subvolume may be deleted by a user */\n\terr = btrfs_may_delete(dir, dentry, 1);\n\tif (err)\n\t\tgoto out_dput;\n\n\tif (btrfs_ino(inode) != BTRFS_FIRST_FREE_OBJECTID) {\n\t\terr = -EINVAL;\n\t\tgoto out_dput;\n\t}\n\n\tmutex_lock(&inode->i_mutex);\n\n\t/*\n\t * Don't allow to delete a subvolume with send in progress. This is\n\t * inside the i_mutex so the error handling that has to drop the bit\n\t * again is not run concurrently.\n\t */\n\tspin_lock(&dest->root_item_lock);\n\troot_flags = btrfs_root_flags(&dest->root_item);\n\tif (dest->send_in_progress == 0) {\n\t\tbtrfs_set_root_flags(&dest->root_item,\n\t\t\t\troot_flags | BTRFS_ROOT_SUBVOL_DEAD);\n\t\tspin_unlock(&dest->root_item_lock);\n\t} else {\n\t\tspin_unlock(&dest->root_item_lock);\n\t\tbtrfs_warn(root->fs_info,\n\t\t\t\"Attempt to delete subvolume %llu during send\",\n\t\t\tdest->root_key.objectid);\n\t\terr = -EPERM;\n\t\tgoto out_dput;\n\t}\n\n\td_invalidate(dentry);\n\n\tdown_write(&root->fs_info->subvol_sem);\n\n\terr = may_destroy_subvol(dest);\n\tif (err)\n\t\tgoto out_up_write;\n\n\tbtrfs_init_block_rsv(&block_rsv, BTRFS_BLOCK_RSV_TEMP);\n\t/*\n\t * One for dir inode, two for dir entries, two for root\n\t * ref/backref.\n\t */\n\terr = btrfs_subvolume_reserve_metadata(root, &block_rsv,\n\t\t\t\t\t       5, &qgroup_reserved, true);\n\tif (err)\n\t\tgoto out_up_write;\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\terr = PTR_ERR(trans);\n\t\tgoto out_release;\n\t}\n\ttrans->block_rsv = &block_rsv;\n\ttrans->bytes_reserved = block_rsv.size;\n\n\tret = btrfs_unlink_subvol(trans, root, dir,\n\t\t\t\tdest->root_key.objectid,\n\t\t\t\tdentry->d_name.name,\n\t\t\t\tdentry->d_name.len);\n\tif (ret) {\n\t\terr = ret;\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto out_end_trans;\n\t}\n\n\tbtrfs_record_root_in_trans(trans, dest);\n\n\tmemset(&dest->root_item.drop_progress, 0,\n\t\tsizeof(dest->root_item.drop_progress));\n\tdest->root_item.drop_level = 0;\n\tbtrfs_set_root_refs(&dest->root_item, 0);\n\n\tif (!test_and_set_bit(BTRFS_ROOT_ORPHAN_ITEM_INSERTED, &dest->state)) {\n\t\tret = btrfs_insert_orphan_item(trans,\n\t\t\t\t\troot->fs_info->tree_root,\n\t\t\t\t\tdest->root_key.objectid);\n\t\tif (ret) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\terr = ret;\n\t\t\tgoto out_end_trans;\n\t\t}\n\t}\n\n\tret = btrfs_uuid_tree_rem(trans, root->fs_info->uuid_root,\n\t\t\t\t  dest->root_item.uuid, BTRFS_UUID_KEY_SUBVOL,\n\t\t\t\t  dest->root_key.objectid);\n\tif (ret && ret != -ENOENT) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\terr = ret;\n\t\tgoto out_end_trans;\n\t}\n\tif (!btrfs_is_empty_uuid(dest->root_item.received_uuid)) {\n\t\tret = btrfs_uuid_tree_rem(trans, root->fs_info->uuid_root,\n\t\t\t\t\t  dest->root_item.received_uuid,\n\t\t\t\t\t  BTRFS_UUID_KEY_RECEIVED_SUBVOL,\n\t\t\t\t\t  dest->root_key.objectid);\n\t\tif (ret && ret != -ENOENT) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\terr = ret;\n\t\t\tgoto out_end_trans;\n\t\t}\n\t}\n\nout_end_trans:\n\ttrans->block_rsv = NULL;\n\ttrans->bytes_reserved = 0;\n\tret = btrfs_end_transaction(trans, root);\n\tif (ret && !err)\n\t\terr = ret;\n\tinode->i_flags |= S_DEAD;\nout_release:\n\tbtrfs_subvolume_release_metadata(root, &block_rsv, qgroup_reserved);\nout_up_write:\n\tup_write(&root->fs_info->subvol_sem);\n\tif (err) {\n\t\tspin_lock(&dest->root_item_lock);\n\t\troot_flags = btrfs_root_flags(&dest->root_item);\n\t\tbtrfs_set_root_flags(&dest->root_item,\n\t\t\t\troot_flags & ~BTRFS_ROOT_SUBVOL_DEAD);\n\t\tspin_unlock(&dest->root_item_lock);\n\t}\n\tmutex_unlock(&inode->i_mutex);\n\tif (!err) {\n\t\tshrink_dcache_sb(root->fs_info->sb);\n\t\tbtrfs_invalidate_inodes(dest);\n\t\td_delete(dentry);\n\t\tASSERT(dest->send_in_progress == 0);\n\n\t\t/* the last ref */\n\t\tif (dest->ino_cache_inode) {\n\t\t\tiput(dest->ino_cache_inode);\n\t\t\tdest->ino_cache_inode = NULL;\n\t\t}\n\t}\nout_dput:\n\tdput(dentry);\nout_unlock_dir:\n\tmutex_unlock(&dir->i_mutex);\nout_drop_write:\n\tmnt_drop_write_file(file);\nout:\n\tkfree(vol_args);\n\treturn err;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "vol_args"
          ],
          "line": 2521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "file"
          ],
          "line": 2519
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dir->i_mutex"
          ],
          "line": 2517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 2515
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "dest->ino_cache_inode"
          ],
          "line": 2510
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_run_delayed_iputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3100-3123",
          "snippet": "void btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nvoid btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dest->send_in_progress == 0"
          ],
          "line": 2506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_delete",
          "args": [
            "dentry"
          ],
          "line": 2505
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_delayed_delete_inode_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "1862-1903",
          "snippet": "int btrfs_delayed_delete_inode_ref(struct inode *inode)\n{\n\tstruct btrfs_delayed_node *delayed_node;\n\n\t/*\n\t * we don't do delayed inode updates during log recovery because it\n\t * leads to enospc problems.  This means we also can't do\n\t * delayed inode refs\n\t */\n\tif (BTRFS_I(inode)->root->fs_info->log_root_recovering)\n\t\treturn -EAGAIN;\n\n\tdelayed_node = btrfs_get_or_create_delayed_node(inode);\n\tif (IS_ERR(delayed_node))\n\t\treturn PTR_ERR(delayed_node);\n\n\t/*\n\t * We don't reserve space for inode ref deletion is because:\n\t * - We ONLY do async inode ref deletion for the inode who has only\n\t *   one link(i_nlink == 1), it means there is only one inode ref.\n\t *   And in most case, the inode ref and the inode item are in the\n\t *   same leaf, and we will deal with them at the same time.\n\t *   Since we are sure we will reserve the space for the inode item,\n\t *   it is unnecessary to reserve space for inode ref deletion.\n\t * - If the inode ref and the inode item are not in the same leaf,\n\t *   We also needn't worry about enospc problem, because we reserve\n\t *   much more space for the inode update than it needs.\n\t * - At the worst, we can steal some space from the global reservation.\n\t *   It is very rare.\n\t */\n\tmutex_lock(&delayed_node->mutex);\n\tif (test_bit(BTRFS_DELAYED_NODE_DEL_IREF, &delayed_node->flags))\n\t\tgoto release_node;\n\n\tset_bit(BTRFS_DELAYED_NODE_DEL_IREF, &delayed_node->flags);\n\tdelayed_node->count++;\n\tatomic_inc(&BTRFS_I(inode)->root->fs_info->delayed_root->items);\nrelease_node:\n\tmutex_unlock(&delayed_node->mutex);\n\tbtrfs_release_delayed_node(delayed_node);\n\treturn 0;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nint btrfs_delayed_delete_inode_ref(struct inode *inode)\n{\n\tstruct btrfs_delayed_node *delayed_node;\n\n\t/*\n\t * we don't do delayed inode updates during log recovery because it\n\t * leads to enospc problems.  This means we also can't do\n\t * delayed inode refs\n\t */\n\tif (BTRFS_I(inode)->root->fs_info->log_root_recovering)\n\t\treturn -EAGAIN;\n\n\tdelayed_node = btrfs_get_or_create_delayed_node(inode);\n\tif (IS_ERR(delayed_node))\n\t\treturn PTR_ERR(delayed_node);\n\n\t/*\n\t * We don't reserve space for inode ref deletion is because:\n\t * - We ONLY do async inode ref deletion for the inode who has only\n\t *   one link(i_nlink == 1), it means there is only one inode ref.\n\t *   And in most case, the inode ref and the inode item are in the\n\t *   same leaf, and we will deal with them at the same time.\n\t *   Since we are sure we will reserve the space for the inode item,\n\t *   it is unnecessary to reserve space for inode ref deletion.\n\t * - If the inode ref and the inode item are not in the same leaf,\n\t *   We also needn't worry about enospc problem, because we reserve\n\t *   much more space for the inode update than it needs.\n\t * - At the worst, we can steal some space from the global reservation.\n\t *   It is very rare.\n\t */\n\tmutex_lock(&delayed_node->mutex);\n\tif (test_bit(BTRFS_DELAYED_NODE_DEL_IREF, &delayed_node->flags))\n\t\tgoto release_node;\n\n\tset_bit(BTRFS_DELAYED_NODE_DEL_IREF, &delayed_node->flags);\n\tdelayed_node->count++;\n\tatomic_inc(&BTRFS_I(inode)->root->fs_info->delayed_root->items);\nrelease_node:\n\tmutex_unlock(&delayed_node->mutex);\n\tbtrfs_release_delayed_node(delayed_node);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_invalidate_inodes",
          "args": [
            "dest"
          ],
          "line": 2504
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_invalidate_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "5212-5273",
          "snippet": "void btrfs_invalidate_inodes(struct btrfs_root *root)\n{\n\tstruct rb_node *node;\n\tstruct rb_node *prev;\n\tstruct btrfs_inode *entry;\n\tstruct inode *inode;\n\tu64 objectid = 0;\n\n\tif (!test_bit(BTRFS_FS_STATE_ERROR, &root->fs_info->fs_state))\n\t\tWARN_ON(btrfs_root_refs(&root->root_item) != 0);\n\n\tspin_lock(&root->inode_lock);\nagain:\n\tnode = root->inode_tree.rb_node;\n\tprev = NULL;\n\twhile (node) {\n\t\tprev = node;\n\t\tentry = rb_entry(node, struct btrfs_inode, rb_node);\n\n\t\tif (objectid < btrfs_ino(&entry->vfs_inode))\n\t\t\tnode = node->rb_left;\n\t\telse if (objectid > btrfs_ino(&entry->vfs_inode))\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (!node) {\n\t\twhile (prev) {\n\t\t\tentry = rb_entry(prev, struct btrfs_inode, rb_node);\n\t\t\tif (objectid <= btrfs_ino(&entry->vfs_inode)) {\n\t\t\t\tnode = prev;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprev = rb_next(prev);\n\t\t}\n\t}\n\twhile (node) {\n\t\tentry = rb_entry(node, struct btrfs_inode, rb_node);\n\t\tobjectid = btrfs_ino(&entry->vfs_inode) + 1;\n\t\tinode = igrab(&entry->vfs_inode);\n\t\tif (inode) {\n\t\t\tspin_unlock(&root->inode_lock);\n\t\t\tif (atomic_read(&inode->i_count) > 1)\n\t\t\t\td_prune_aliases(inode);\n\t\t\t/*\n\t\t\t * btrfs_drop_inode will have it removed from\n\t\t\t * the inode cache when its usage count\n\t\t\t * hits zero.\n\t\t\t */\n\t\t\tiput(inode);\n\t\t\tcond_resched();\n\t\t\tspin_lock(&root->inode_lock);\n\t\t\tgoto again;\n\t\t}\n\n\t\tif (cond_resched_lock(&root->inode_lock))\n\t\t\tgoto again;\n\n\t\tnode = rb_next(node);\n\t}\n\tspin_unlock(&root->inode_lock);\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nvoid btrfs_invalidate_inodes(struct btrfs_root *root)\n{\n\tstruct rb_node *node;\n\tstruct rb_node *prev;\n\tstruct btrfs_inode *entry;\n\tstruct inode *inode;\n\tu64 objectid = 0;\n\n\tif (!test_bit(BTRFS_FS_STATE_ERROR, &root->fs_info->fs_state))\n\t\tWARN_ON(btrfs_root_refs(&root->root_item) != 0);\n\n\tspin_lock(&root->inode_lock);\nagain:\n\tnode = root->inode_tree.rb_node;\n\tprev = NULL;\n\twhile (node) {\n\t\tprev = node;\n\t\tentry = rb_entry(node, struct btrfs_inode, rb_node);\n\n\t\tif (objectid < btrfs_ino(&entry->vfs_inode))\n\t\t\tnode = node->rb_left;\n\t\telse if (objectid > btrfs_ino(&entry->vfs_inode))\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (!node) {\n\t\twhile (prev) {\n\t\t\tentry = rb_entry(prev, struct btrfs_inode, rb_node);\n\t\t\tif (objectid <= btrfs_ino(&entry->vfs_inode)) {\n\t\t\t\tnode = prev;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprev = rb_next(prev);\n\t\t}\n\t}\n\twhile (node) {\n\t\tentry = rb_entry(node, struct btrfs_inode, rb_node);\n\t\tobjectid = btrfs_ino(&entry->vfs_inode) + 1;\n\t\tinode = igrab(&entry->vfs_inode);\n\t\tif (inode) {\n\t\t\tspin_unlock(&root->inode_lock);\n\t\t\tif (atomic_read(&inode->i_count) > 1)\n\t\t\t\td_prune_aliases(inode);\n\t\t\t/*\n\t\t\t * btrfs_drop_inode will have it removed from\n\t\t\t * the inode cache when its usage count\n\t\t\t * hits zero.\n\t\t\t */\n\t\t\tiput(inode);\n\t\t\tcond_resched();\n\t\t\tspin_lock(&root->inode_lock);\n\t\t\tgoto again;\n\t\t}\n\n\t\tif (cond_resched_lock(&root->inode_lock))\n\t\t\tgoto again;\n\n\t\tnode = rb_next(node);\n\t}\n\tspin_unlock(&root->inode_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "shrink_dcache_sb",
          "args": [
            "root->fs_info->sb"
          ],
          "line": 2503
        },
        "resolved": true,
        "details": {
          "function_name": "shrink_dcache_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1094-1107",
          "snippet": "void shrink_dcache_sb(struct super_block *sb)\n{\n\tlong freed;\n\n\tdo {\n\t\tLIST_HEAD(dispose);\n\n\t\tfreed = list_lru_walk(&sb->s_dentry_lru,\n\t\t\tdentry_lru_isolate_shrink, &dispose, UINT_MAX);\n\n\t\tthis_cpu_sub(nr_dentry_unused, freed);\n\t\tshrink_dentry_list(&dispose);\n\t} while (freed > 0);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(long, nr_dentry_unused);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic DEFINE_PER_CPU(long, nr_dentry_unused);\n\nvoid shrink_dcache_sb(struct super_block *sb)\n{\n\tlong freed;\n\n\tdo {\n\t\tLIST_HEAD(dispose);\n\n\t\tfreed = list_lru_walk(&sb->s_dentry_lru,\n\t\t\tdentry_lru_isolate_shrink, &dispose, UINT_MAX);\n\n\t\tthis_cpu_sub(nr_dentry_unused, freed);\n\t\tshrink_dentry_list(&dispose);\n\t} while (freed > 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 2501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dest->root_item_lock"
          ],
          "line": 2499
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_flags",
          "args": [
            "&dest->root_item",
            "root_flags & ~BTRFS_ROOT_SUBVOL_DEAD"
          ],
          "line": 2497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_root_flags",
          "args": [
            "&dest->root_item"
          ],
          "line": 2496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dest->root_item_lock"
          ],
          "line": 2495
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&root->fs_info->subvol_sem"
          ],
          "line": 2493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_subvolume_release_metadata",
          "args": [
            "root",
            "&block_rsv",
            "qgroup_reserved"
          ],
          "line": 2491
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_subvolume_release_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "4996-5003",
          "snippet": "void btrfs_subvolume_release_metadata(struct btrfs_root *root,\n\t\t\t\t      struct btrfs_block_rsv *rsv,\n\t\t\t\t      u64 qgroup_reserved)\n{\n\tbtrfs_block_rsv_release(root, rsv, (u64)-1);\n\tif (qgroup_reserved)\n\t\tbtrfs_qgroup_free(root, qgroup_reserved);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_subvolume_release_metadata(struct btrfs_root *root,\n\t\t\t\t      struct btrfs_block_rsv *rsv,\n\t\t\t\t      u64 qgroup_reserved)\n{\n\tbtrfs_block_rsv_release(root, rsv, (u64)-1);\n\tif (qgroup_reserved)\n\t\tbtrfs_qgroup_free(root, qgroup_reserved);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_end_transaction",
          "args": [
            "trans",
            "root"
          ],
          "line": 2486
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_end_transaction_throttle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "846-850",
          "snippet": "int btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 2477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_uuid_tree_rem",
          "args": [
            "trans",
            "root->fs_info->uuid_root",
            "dest->root_item.received_uuid",
            "BTRFS_UUID_KEY_RECEIVED_SUBVOL",
            "dest->root_key.objectid"
          ],
          "line": 2472
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_uuid_tree_rem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/uuid-tree.c",
          "lines": "157-236",
          "snippet": "int btrfs_uuid_tree_rem(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_root *uuid_root, u8 *uuid, u8 type,\n\t\t\tu64 subid)\n{\n\tint ret;\n\tstruct btrfs_path *path = NULL;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tunsigned long offset;\n\tu32 item_size;\n\tunsigned long move_dst;\n\tunsigned long move_src;\n\tunsigned long move_len;\n\n\tif (WARN_ON_ONCE(!uuid_root)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tbtrfs_uuid_to_key(uuid, type, &key);\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_search_slot(trans, uuid_root, &key, path, -1, 1);\n\tif (ret < 0) {\n\t\tbtrfs_warn(uuid_root->fs_info, \"error %d while searching for uuid item!\",\n\t\t\tret);\n\t\tgoto out;\n\t}\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\toffset = btrfs_item_ptr_offset(eb, slot);\n\titem_size = btrfs_item_size_nr(eb, slot);\n\tif (!IS_ALIGNED(item_size, sizeof(u64))) {\n\t\tbtrfs_warn(uuid_root->fs_info, \"uuid item with illegal size %lu!\",\n\t\t\t(unsigned long)item_size);\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\twhile (item_size) {\n\t\t__le64 read_subid;\n\n\t\tread_extent_buffer(eb, &read_subid, offset, sizeof(read_subid));\n\t\tif (le64_to_cpu(read_subid) == subid)\n\t\t\tbreak;\n\t\toffset += sizeof(read_subid);\n\t\titem_size -= sizeof(read_subid);\n\t}\n\n\tif (!item_size) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\titem_size = btrfs_item_size_nr(eb, slot);\n\tif (item_size == sizeof(subid)) {\n\t\tret = btrfs_del_item(trans, uuid_root, path);\n\t\tgoto out;\n\t}\n\n\tmove_dst = offset;\n\tmove_src = offset + sizeof(subid);\n\tmove_len = item_size - (move_src - btrfs_item_ptr_offset(eb, slot));\n\tmemmove_extent_buffer(eb, move_dst, move_src, move_len);\n\tbtrfs_truncate_item(uuid_root, path, item_size - sizeof(subid), 1);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/uuid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/uuid.h>\n\nint btrfs_uuid_tree_rem(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_root *uuid_root, u8 *uuid, u8 type,\n\t\t\tu64 subid)\n{\n\tint ret;\n\tstruct btrfs_path *path = NULL;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tunsigned long offset;\n\tu32 item_size;\n\tunsigned long move_dst;\n\tunsigned long move_src;\n\tunsigned long move_len;\n\n\tif (WARN_ON_ONCE(!uuid_root)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tbtrfs_uuid_to_key(uuid, type, &key);\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_search_slot(trans, uuid_root, &key, path, -1, 1);\n\tif (ret < 0) {\n\t\tbtrfs_warn(uuid_root->fs_info, \"error %d while searching for uuid item!\",\n\t\t\tret);\n\t\tgoto out;\n\t}\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\toffset = btrfs_item_ptr_offset(eb, slot);\n\titem_size = btrfs_item_size_nr(eb, slot);\n\tif (!IS_ALIGNED(item_size, sizeof(u64))) {\n\t\tbtrfs_warn(uuid_root->fs_info, \"uuid item with illegal size %lu!\",\n\t\t\t(unsigned long)item_size);\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\twhile (item_size) {\n\t\t__le64 read_subid;\n\n\t\tread_extent_buffer(eb, &read_subid, offset, sizeof(read_subid));\n\t\tif (le64_to_cpu(read_subid) == subid)\n\t\t\tbreak;\n\t\toffset += sizeof(read_subid);\n\t\titem_size -= sizeof(read_subid);\n\t}\n\n\tif (!item_size) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\titem_size = btrfs_item_size_nr(eb, slot);\n\tif (item_size == sizeof(subid)) {\n\t\tret = btrfs_del_item(trans, uuid_root, path);\n\t\tgoto out;\n\t}\n\n\tmove_dst = offset;\n\tmove_src = offset + sizeof(subid);\n\tmove_len = item_size - (move_src - btrfs_item_ptr_offset(eb, slot));\n\tmemmove_extent_buffer(eb, move_dst, move_src, move_len);\n\tbtrfs_truncate_item(uuid_root, path, item_size - sizeof(subid), 1);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_is_empty_uuid",
          "args": [
            "dest->root_item.received_uuid"
          ],
          "line": 2471
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_is_empty_uuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "420-429",
          "snippet": "int btrfs_is_empty_uuid(u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_UUID_SIZE; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nint btrfs_is_empty_uuid(u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_UUID_SIZE; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 2467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 2457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_insert_orphan_item",
          "args": [
            "trans",
            "root->fs_info->tree_root",
            "dest->root_key.objectid"
          ],
          "line": 2453
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_orphan_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/orphan.c",
          "lines": "22-41",
          "snippet": "int btrfs_insert_orphan_item(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root, u64 offset)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tint ret = 0;\n\n\tkey.objectid = BTRFS_ORPHAN_OBJECTID;\n\tkey.type = BTRFS_ORPHAN_ITEM_KEY;\n\tkey.offset = offset;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_insert_empty_item(trans, root, path, &key, 0);\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"ctree.h\"\n\nint btrfs_insert_orphan_item(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root, u64 offset)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tint ret = 0;\n\n\tkey.objectid = BTRFS_ORPHAN_OBJECTID;\n\tkey.type = BTRFS_ORPHAN_ITEM_KEY;\n\tkey.offset = offset;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_insert_empty_item(trans, root, path, &key, 0);\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "BTRFS_ROOT_ORPHAN_ITEM_INSERTED",
            "&dest->state"
          ],
          "line": 2452
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_refs",
          "args": [
            "&dest->root_item",
            "0"
          ],
          "line": 2450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&dest->root_item.drop_progress",
            "0",
            "sizeof(dest->root_item.drop_progress)"
          ],
          "line": 2447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_record_root_in_trans",
          "args": [
            "trans",
            "dest"
          ],
          "line": 2445
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_record_root_in_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "330-350",
          "snippet": "int btrfs_record_root_in_trans(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root)\n{\n\tif (!test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\treturn 0;\n\n\t/*\n\t * see record_root_in_trans for comments about IN_TRANS_SETUP usage\n\t * and barriers\n\t */\n\tsmp_rmb();\n\tif (root->last_trans == trans->transid &&\n\t    !test_bit(BTRFS_ROOT_IN_TRANS_SETUP, &root->state))\n\t\treturn 0;\n\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\trecord_root_in_trans(trans, root);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_record_root_in_trans(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root)\n{\n\tif (!test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\treturn 0;\n\n\t/*\n\t * see record_root_in_trans for comments about IN_TRANS_SETUP usage\n\t * and barriers\n\t */\n\tsmp_rmb();\n\tif (root->last_trans == trans->transid &&\n\t    !test_bit(BTRFS_ROOT_IN_TRANS_SETUP, &root->state))\n\t\treturn 0;\n\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\trecord_root_in_trans(trans, root);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 2441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_unlink_subvol",
          "args": [
            "trans",
            "root",
            "dir",
            "dest->root_key.objectid",
            "dentry->d_name.name",
            "dentry->d_name.len"
          ],
          "line": 2435
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_unlink_subvol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "4045-4123",
          "snippet": "int btrfs_unlink_subvol(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_root *root,\n\t\t\tstruct inode *dir, u64 objectid,\n\t\t\tconst char *name, int name_len)\n{\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_key key;\n\tu64 index;\n\tint ret;\n\tu64 dir_ino = btrfs_ino(dir);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tdi = btrfs_lookup_dir_item(trans, root, path, dir_ino,\n\t\t\t\t   name, name_len, -1);\n\tif (IS_ERR_OR_NULL(di)) {\n\t\tif (!di)\n\t\t\tret = -ENOENT;\n\t\telse\n\t\t\tret = PTR_ERR(di);\n\t\tgoto out;\n\t}\n\n\tleaf = path->nodes[0];\n\tbtrfs_dir_item_key_to_cpu(leaf, di, &key);\n\tWARN_ON(key.type != BTRFS_ROOT_ITEM_KEY || key.objectid != objectid);\n\tret = btrfs_delete_one_dir_name(trans, root, path, di);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto out;\n\t}\n\tbtrfs_release_path(path);\n\n\tret = btrfs_del_root_ref(trans, root->fs_info->tree_root,\n\t\t\t\t objectid, root->root_key.objectid,\n\t\t\t\t dir_ino, &index, name, name_len);\n\tif (ret < 0) {\n\t\tif (ret != -ENOENT) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\t\tdi = btrfs_search_dir_index_item(root, path, dir_ino,\n\t\t\t\t\t\t name, name_len);\n\t\tif (IS_ERR_OR_NULL(di)) {\n\t\t\tif (!di)\n\t\t\t\tret = -ENOENT;\n\t\t\telse\n\t\t\t\tret = PTR_ERR(di);\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tbtrfs_release_path(path);\n\t\tindex = key.offset;\n\t}\n\tbtrfs_release_path(path);\n\n\tret = btrfs_delete_delayed_dir_index(trans, root, dir, index);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto out;\n\t}\n\n\tbtrfs_i_size_write(dir, dir->i_size - name_len * 2);\n\tinode_inc_iversion(dir);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME;\n\tret = btrfs_update_inode_fallback(trans, root, dir);\n\tif (ret)\n\t\tbtrfs_abort_transaction(trans, root, ret);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static struct extent_map *create_pinned_em(struct inode *inode, u64 start,\n\t\t\t\t\t   u64 len, u64 orig_start,\n\t\t\t\t\t   u64 block_start, u64 block_len,\n\t\t\t\t\t   u64 orig_block_len, u64 ram_bytes,\n\t\t\t\t\t   int type);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic struct extent_map *create_pinned_em(struct inode *inode, u64 start,\n\t\t\t\t\t   u64 len, u64 orig_start,\n\t\t\t\t\t   u64 block_start, u64 block_len,\n\t\t\t\t\t   u64 orig_block_len, u64 ram_bytes,\n\t\t\t\t\t   int type);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nint btrfs_unlink_subvol(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_root *root,\n\t\t\tstruct inode *dir, u64 objectid,\n\t\t\tconst char *name, int name_len)\n{\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_key key;\n\tu64 index;\n\tint ret;\n\tu64 dir_ino = btrfs_ino(dir);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tdi = btrfs_lookup_dir_item(trans, root, path, dir_ino,\n\t\t\t\t   name, name_len, -1);\n\tif (IS_ERR_OR_NULL(di)) {\n\t\tif (!di)\n\t\t\tret = -ENOENT;\n\t\telse\n\t\t\tret = PTR_ERR(di);\n\t\tgoto out;\n\t}\n\n\tleaf = path->nodes[0];\n\tbtrfs_dir_item_key_to_cpu(leaf, di, &key);\n\tWARN_ON(key.type != BTRFS_ROOT_ITEM_KEY || key.objectid != objectid);\n\tret = btrfs_delete_one_dir_name(trans, root, path, di);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto out;\n\t}\n\tbtrfs_release_path(path);\n\n\tret = btrfs_del_root_ref(trans, root->fs_info->tree_root,\n\t\t\t\t objectid, root->root_key.objectid,\n\t\t\t\t dir_ino, &index, name, name_len);\n\tif (ret < 0) {\n\t\tif (ret != -ENOENT) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\t\tdi = btrfs_search_dir_index_item(root, path, dir_ino,\n\t\t\t\t\t\t name, name_len);\n\t\tif (IS_ERR_OR_NULL(di)) {\n\t\t\tif (!di)\n\t\t\t\tret = -ENOENT;\n\t\t\telse\n\t\t\t\tret = PTR_ERR(di);\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tbtrfs_release_path(path);\n\t\tindex = key.offset;\n\t}\n\tbtrfs_release_path(path);\n\n\tret = btrfs_delete_delayed_dir_index(trans, root, dir, index);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto out;\n\t}\n\n\tbtrfs_i_size_write(dir, dir->i_size - name_len * 2);\n\tinode_inc_iversion(dir);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME;\n\tret = btrfs_update_inode_fallback(trans, root, dir);\n\tif (ret)\n\t\tbtrfs_abort_transaction(trans, root, ret);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 2429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 2428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_start_transaction",
          "args": [
            "root",
            "0"
          ],
          "line": 2427
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_transaction_lflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "569-574",
          "snippet": "struct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_subvolume_reserve_metadata",
          "args": [
            "root",
            "&block_rsv",
            "5",
            "&qgroup_reserved",
            "true"
          ],
          "line": 2422
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_subvolume_reserve_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "4957-4994",
          "snippet": "int btrfs_subvolume_reserve_metadata(struct btrfs_root *root,\n\t\t\t\t     struct btrfs_block_rsv *rsv,\n\t\t\t\t     int items,\n\t\t\t\t     u64 *qgroup_reserved,\n\t\t\t\t     bool use_global_rsv)\n{\n\tu64 num_bytes;\n\tint ret;\n\tstruct btrfs_block_rsv *global_rsv = &root->fs_info->global_block_rsv;\n\n\tif (root->fs_info->quota_enabled) {\n\t\t/* One for parent inode, two for dir entries */\n\t\tnum_bytes = 3 * root->nodesize;\n\t\tret = btrfs_qgroup_reserve(root, num_bytes);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tnum_bytes = 0;\n\t}\n\n\t*qgroup_reserved = num_bytes;\n\n\tnum_bytes = btrfs_calc_trans_metadata_size(root, items);\n\trsv->space_info = __find_space_info(root->fs_info,\n\t\t\t\t\t    BTRFS_BLOCK_GROUP_METADATA);\n\tret = btrfs_block_rsv_add(root, rsv, num_bytes,\n\t\t\t\t  BTRFS_RESERVE_FLUSH_ALL);\n\n\tif (ret == -ENOSPC && use_global_rsv)\n\t\tret = btrfs_block_rsv_migrate(global_rsv, rsv, num_bytes);\n\n\tif (ret) {\n\t\tif (*qgroup_reserved)\n\t\t\tbtrfs_qgroup_free(root, *qgroup_reserved);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nstatic noinline struct;\n\nint btrfs_subvolume_reserve_metadata(struct btrfs_root *root,\n\t\t\t\t     struct btrfs_block_rsv *rsv,\n\t\t\t\t     int items,\n\t\t\t\t     u64 *qgroup_reserved,\n\t\t\t\t     bool use_global_rsv)\n{\n\tu64 num_bytes;\n\tint ret;\n\tstruct btrfs_block_rsv *global_rsv = &root->fs_info->global_block_rsv;\n\n\tif (root->fs_info->quota_enabled) {\n\t\t/* One for parent inode, two for dir entries */\n\t\tnum_bytes = 3 * root->nodesize;\n\t\tret = btrfs_qgroup_reserve(root, num_bytes);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tnum_bytes = 0;\n\t}\n\n\t*qgroup_reserved = num_bytes;\n\n\tnum_bytes = btrfs_calc_trans_metadata_size(root, items);\n\trsv->space_info = __find_space_info(root->fs_info,\n\t\t\t\t\t    BTRFS_BLOCK_GROUP_METADATA);\n\tret = btrfs_block_rsv_add(root, rsv, num_bytes,\n\t\t\t\t  BTRFS_RESERVE_FLUSH_ALL);\n\n\tif (ret == -ENOSPC && use_global_rsv)\n\t\tret = btrfs_block_rsv_migrate(global_rsv, rsv, num_bytes);\n\n\tif (ret) {\n\t\tif (*qgroup_reserved)\n\t\t\tbtrfs_qgroup_free(root, *qgroup_reserved);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_init_block_rsv",
          "args": [
            "&block_rsv",
            "BTRFS_BLOCK_RSV_TEMP"
          ],
          "line": 2417
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_block_rsv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "4671-4676",
          "snippet": "void btrfs_init_block_rsv(struct btrfs_block_rsv *rsv, unsigned short type)\n{\n\tmemset(rsv, 0, sizeof(*rsv));\n\tspin_lock_init(&rsv->lock);\n\trsv->type = type;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_init_block_rsv(struct btrfs_block_rsv *rsv, unsigned short type)\n{\n\tmemset(rsv, 0, sizeof(*rsv));\n\tspin_lock_init(&rsv->lock);\n\trsv->type = type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "may_destroy_subvol",
          "args": [
            "dest"
          ],
          "line": 2413
        },
        "resolved": true,
        "details": {
          "function_name": "may_destroy_subvol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "1842-1890",
          "snippet": "static noinline int may_destroy_subvol(struct btrfs_root *root)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_key key;\n\tu64 dir_id;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\t/* Make sure this root isn't set as the default subvol */\n\tdir_id = btrfs_super_root_dir(root->fs_info->super_copy);\n\tdi = btrfs_lookup_dir_item(NULL, root->fs_info->tree_root, path,\n\t\t\t\t   dir_id, \"default\", 7, 0);\n\tif (di && !IS_ERR(di)) {\n\t\tbtrfs_dir_item_key_to_cpu(path->nodes[0], di, &key);\n\t\tif (key.objectid == root->root_key.objectid) {\n\t\t\tret = -EPERM;\n\t\t\tbtrfs_err(root->fs_info, \"deleting default subvolume \"\n\t\t\t\t  \"%llu is not allowed\", key.objectid);\n\t\t\tgoto out;\n\t\t}\n\t\tbtrfs_release_path(path);\n\t}\n\n\tkey.objectid = root->root_key.objectid;\n\tkey.type = BTRFS_ROOT_REF_KEY;\n\tkey.offset = (u64)-1;\n\n\tret = btrfs_search_slot(NULL, root->fs_info->tree_root,\n\t\t\t\t&key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tBUG_ON(ret == 0);\n\n\tret = 0;\n\tif (path->slots[0] > 0) {\n\t\tpath->slots[0]--;\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\n\t\tif (key.objectid == root->root_key.objectid &&\n\t\t    key.type == BTRFS_ROOT_REF_KEY)\n\t\t\tret = -ENOTEMPTY;\n\t}\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic noinline int may_destroy_subvol(struct btrfs_root *root)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_key key;\n\tu64 dir_id;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\t/* Make sure this root isn't set as the default subvol */\n\tdir_id = btrfs_super_root_dir(root->fs_info->super_copy);\n\tdi = btrfs_lookup_dir_item(NULL, root->fs_info->tree_root, path,\n\t\t\t\t   dir_id, \"default\", 7, 0);\n\tif (di && !IS_ERR(di)) {\n\t\tbtrfs_dir_item_key_to_cpu(path->nodes[0], di, &key);\n\t\tif (key.objectid == root->root_key.objectid) {\n\t\t\tret = -EPERM;\n\t\t\tbtrfs_err(root->fs_info, \"deleting default subvolume \"\n\t\t\t\t  \"%llu is not allowed\", key.objectid);\n\t\t\tgoto out;\n\t\t}\n\t\tbtrfs_release_path(path);\n\t}\n\n\tkey.objectid = root->root_key.objectid;\n\tkey.type = BTRFS_ROOT_REF_KEY;\n\tkey.offset = (u64)-1;\n\n\tret = btrfs_search_slot(NULL, root->fs_info->tree_root,\n\t\t\t\t&key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tBUG_ON(ret == 0);\n\n\tret = 0;\n\tif (path->slots[0] > 0) {\n\t\tpath->slots[0]--;\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\n\t\tif (key.objectid == root->root_key.objectid &&\n\t\t    key.type == BTRFS_ROOT_REF_KEY)\n\t\t\tret = -ENOTEMPTY;\n\t}\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&root->fs_info->subvol_sem"
          ],
          "line": 2411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_invalidate",
          "args": [
            "dentry"
          ],
          "line": 2409
        },
        "resolved": true,
        "details": {
          "function_name": "d_invalidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1465-1506",
          "snippet": "void d_invalidate(struct dentry *dentry)\n{\n\t/*\n\t * If it's already been dropped, return OK.\n\t */\n\tspin_lock(&dentry->d_lock);\n\tif (d_unhashed(dentry)) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\treturn;\n\t}\n\tspin_unlock(&dentry->d_lock);\n\n\t/* Negative dentries can be dropped without further checks */\n\tif (!dentry->d_inode) {\n\t\td_drop(dentry);\n\t\treturn;\n\t}\n\n\tfor (;;) {\n\t\tstruct detach_data data;\n\n\t\tdata.mountpoint = NULL;\n\t\tINIT_LIST_HEAD(&data.select.dispose);\n\t\tdata.select.start = dentry;\n\t\tdata.select.found = 0;\n\n\t\td_walk(dentry, &data, detach_and_collect, check_and_drop);\n\n\t\tif (data.select.found)\n\t\t\tshrink_dentry_list(&data.select.dispose);\n\n\t\tif (data.mountpoint) {\n\t\t\tdetach_mounts(data.mountpoint);\n\t\t\tdput(data.mountpoint);\n\t\t}\n\n\t\tif (!data.mountpoint && !data.select.found)\n\t\t\tbreak;\n\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid d_invalidate(struct dentry *dentry)\n{\n\t/*\n\t * If it's already been dropped, return OK.\n\t */\n\tspin_lock(&dentry->d_lock);\n\tif (d_unhashed(dentry)) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\treturn;\n\t}\n\tspin_unlock(&dentry->d_lock);\n\n\t/* Negative dentries can be dropped without further checks */\n\tif (!dentry->d_inode) {\n\t\td_drop(dentry);\n\t\treturn;\n\t}\n\n\tfor (;;) {\n\t\tstruct detach_data data;\n\n\t\tdata.mountpoint = NULL;\n\t\tINIT_LIST_HEAD(&data.select.dispose);\n\t\tdata.select.start = dentry;\n\t\tdata.select.found = 0;\n\n\t\td_walk(dentry, &data, detach_and_collect, check_and_drop);\n\n\t\tif (data.select.found)\n\t\t\tshrink_dentry_list(&data.select.dispose);\n\n\t\tif (data.mountpoint) {\n\t\t\tdetach_mounts(data.mountpoint);\n\t\t\tdput(data.mountpoint);\n\t\t}\n\n\t\tif (!data.mountpoint && !data.select.found)\n\t\t\tbreak;\n\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_warn",
          "args": [
            "root->fs_info",
            "\"Attempt to delete subvolume %llu during send\"",
            "dest->root_key.objectid"
          ],
          "line": 2402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_flags",
          "args": [
            "&dest->root_item",
            "root_flags | BTRFS_ROOT_SUBVOL_DEAD"
          ],
          "line": 2397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_root_flags",
          "args": [
            "&dest->root_item"
          ],
          "line": 2395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 2387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_ino",
          "args": [
            "inode"
          ],
          "line": 2382
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_resume_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "311-316",
          "snippet": "static inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [
            "#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\n#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10\n\nstatic inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_may_delete",
          "args": [
            "dir",
            "dentry",
            "1"
          ],
          "line": 2378
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_may_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "760-790",
          "snippet": "static int btrfs_may_delete(struct inode *dir, struct dentry *victim, int isdir)\n{\n\tint error;\n\n\tif (!victim->d_inode)\n\t\treturn -ENOENT;\n\n\tBUG_ON(victim->d_parent->d_inode != dir);\n\taudit_inode_child(dir, victim, AUDIT_TYPE_CHILD_DELETE);\n\n\terror = inode_permission(dir, MAY_WRITE | MAY_EXEC);\n\tif (error)\n\t\treturn error;\n\tif (IS_APPEND(dir))\n\t\treturn -EPERM;\n\tif (check_sticky(dir, victim->d_inode) || IS_APPEND(victim->d_inode) ||\n\t    IS_IMMUTABLE(victim->d_inode) || IS_SWAPFILE(victim->d_inode))\n\t\treturn -EPERM;\n\tif (isdir) {\n\t\tif (!d_is_dir(victim))\n\t\t\treturn -ENOTDIR;\n\t\tif (IS_ROOT(victim))\n\t\t\treturn -EBUSY;\n\t} else if (d_is_dir(victim))\n\t\treturn -EISDIR;\n\tif (IS_DEADDIR(dir))\n\t\treturn -ENOENT;\n\tif (victim->d_flags & DCACHE_NFSFS_RENAMED)\n\t\treturn -EBUSY;\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_may_delete(struct inode *dir, struct dentry *victim, int isdir)\n{\n\tint error;\n\n\tif (!victim->d_inode)\n\t\treturn -ENOENT;\n\n\tBUG_ON(victim->d_parent->d_inode != dir);\n\taudit_inode_child(dir, victim, AUDIT_TYPE_CHILD_DELETE);\n\n\terror = inode_permission(dir, MAY_WRITE | MAY_EXEC);\n\tif (error)\n\t\treturn error;\n\tif (IS_APPEND(dir))\n\t\treturn -EPERM;\n\tif (check_sticky(dir, victim->d_inode) || IS_APPEND(victim->d_inode) ||\n\t    IS_IMMUTABLE(victim->d_inode) || IS_SWAPFILE(victim->d_inode))\n\t\treturn -EPERM;\n\tif (isdir) {\n\t\tif (!d_is_dir(victim))\n\t\t\treturn -ENOTDIR;\n\t\tif (IS_ROOT(victim))\n\t\t\treturn -EBUSY;\n\t} else if (d_is_dir(victim))\n\t\treturn -EISDIR;\n\tif (IS_DEADDIR(dir))\n\t\treturn -ENOENT;\n\tif (victim->d_flags & DCACHE_NFSFS_RENAMED)\n\t\treturn -EBUSY;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_permission",
          "args": [
            "inode",
            "MAY_WRITE | MAY_EXEC"
          ],
          "line": 2372
        },
        "resolved": true,
        "details": {
          "function_name": "inode_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "459-467",
          "snippet": "int inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\treturn __inode_permission(inode, mask);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\treturn __inode_permission(inode, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "USER_SUBVOL_RM_ALLOWED"
          ],
          "line": 2358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 2343
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 2342
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry"
          ],
          "line": 2332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 2331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_one_len",
          "args": [
            "vol_args->name",
            "parent",
            "namelen"
          ],
          "line": 2330
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_one_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2145-2184",
          "snippet": "struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstruct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_killable_nested",
          "args": [
            "&dir->i_mutex",
            "I_MUTEX_PARENT"
          ],
          "line": 2327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "file"
          ],
          "line": 2322
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "vol_args->name",
            "\"..\"",
            "namelen"
          ],
          "line": 2317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "vol_args->name",
            "'/'"
          ],
          "line": 2316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "vol_args->name"
          ],
          "line": 2315
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "vol_args"
          ],
          "line": 2312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "vol_args"
          ],
          "line": 2311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user",
          "args": [
            "arg",
            "sizeof(*vol_args)"
          ],
          "line": 2310
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic noinline int btrfs_ioctl_snap_destroy(struct file *file,\n\t\t\t\t\t     void __user *arg)\n{\n\tstruct dentry *parent = file->f_path.dentry;\n\tstruct dentry *dentry;\n\tstruct inode *dir = parent->d_inode;\n\tstruct inode *inode;\n\tstruct btrfs_root *root = BTRFS_I(dir)->root;\n\tstruct btrfs_root *dest = NULL;\n\tstruct btrfs_ioctl_vol_args *vol_args;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_block_rsv block_rsv;\n\tu64 root_flags;\n\tu64 qgroup_reserved;\n\tint namelen;\n\tint ret;\n\tint err = 0;\n\n\tvol_args = memdup_user(arg, sizeof(*vol_args));\n\tif (IS_ERR(vol_args))\n\t\treturn PTR_ERR(vol_args);\n\n\tvol_args->name[BTRFS_PATH_NAME_MAX] = '\\0';\n\tnamelen = strlen(vol_args->name);\n\tif (strchr(vol_args->name, '/') ||\n\t    strncmp(vol_args->name, \"..\", namelen) == 0) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = mnt_want_write_file(file);\n\tif (err)\n\t\tgoto out;\n\n\n\terr = mutex_lock_killable_nested(&dir->i_mutex, I_MUTEX_PARENT);\n\tif (err == -EINTR)\n\t\tgoto out_drop_write;\n\tdentry = lookup_one_len(vol_args->name, parent, namelen);\n\tif (IS_ERR(dentry)) {\n\t\terr = PTR_ERR(dentry);\n\t\tgoto out_unlock_dir;\n\t}\n\n\tif (!dentry->d_inode) {\n\t\terr = -ENOENT;\n\t\tgoto out_dput;\n\t}\n\n\tinode = dentry->d_inode;\n\tdest = BTRFS_I(inode)->root;\n\tif (!capable(CAP_SYS_ADMIN)) {\n\t\t/*\n\t\t * Regular user.  Only allow this with a special mount\n\t\t * option, when the user has write+exec access to the\n\t\t * subvol root, and when rmdir(2) would have been\n\t\t * allowed.\n\t\t *\n\t\t * Note that this is _not_ check that the subvol is\n\t\t * empty or doesn't contain data that we wouldn't\n\t\t * otherwise be able to delete.\n\t\t *\n\t\t * Users who want to delete empty subvols should try\n\t\t * rmdir(2).\n\t\t */\n\t\terr = -EPERM;\n\t\tif (!btrfs_test_opt(root, USER_SUBVOL_RM_ALLOWED))\n\t\t\tgoto out_dput;\n\n\t\t/*\n\t\t * Do not allow deletion if the parent dir is the same\n\t\t * as the dir to be deleted.  That means the ioctl\n\t\t * must be called on the dentry referencing the root\n\t\t * of the subvol, not a random directory contained\n\t\t * within it.\n\t\t */\n\t\terr = -EINVAL;\n\t\tif (root == dest)\n\t\t\tgoto out_dput;\n\n\t\terr = inode_permission(inode, MAY_WRITE | MAY_EXEC);\n\t\tif (err)\n\t\t\tgoto out_dput;\n\t}\n\n\t/* check if subvolume may be deleted by a user */\n\terr = btrfs_may_delete(dir, dentry, 1);\n\tif (err)\n\t\tgoto out_dput;\n\n\tif (btrfs_ino(inode) != BTRFS_FIRST_FREE_OBJECTID) {\n\t\terr = -EINVAL;\n\t\tgoto out_dput;\n\t}\n\n\tmutex_lock(&inode->i_mutex);\n\n\t/*\n\t * Don't allow to delete a subvolume with send in progress. This is\n\t * inside the i_mutex so the error handling that has to drop the bit\n\t * again is not run concurrently.\n\t */\n\tspin_lock(&dest->root_item_lock);\n\troot_flags = btrfs_root_flags(&dest->root_item);\n\tif (dest->send_in_progress == 0) {\n\t\tbtrfs_set_root_flags(&dest->root_item,\n\t\t\t\troot_flags | BTRFS_ROOT_SUBVOL_DEAD);\n\t\tspin_unlock(&dest->root_item_lock);\n\t} else {\n\t\tspin_unlock(&dest->root_item_lock);\n\t\tbtrfs_warn(root->fs_info,\n\t\t\t\"Attempt to delete subvolume %llu during send\",\n\t\t\tdest->root_key.objectid);\n\t\terr = -EPERM;\n\t\tgoto out_dput;\n\t}\n\n\td_invalidate(dentry);\n\n\tdown_write(&root->fs_info->subvol_sem);\n\n\terr = may_destroy_subvol(dest);\n\tif (err)\n\t\tgoto out_up_write;\n\n\tbtrfs_init_block_rsv(&block_rsv, BTRFS_BLOCK_RSV_TEMP);\n\t/*\n\t * One for dir inode, two for dir entries, two for root\n\t * ref/backref.\n\t */\n\terr = btrfs_subvolume_reserve_metadata(root, &block_rsv,\n\t\t\t\t\t       5, &qgroup_reserved, true);\n\tif (err)\n\t\tgoto out_up_write;\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\terr = PTR_ERR(trans);\n\t\tgoto out_release;\n\t}\n\ttrans->block_rsv = &block_rsv;\n\ttrans->bytes_reserved = block_rsv.size;\n\n\tret = btrfs_unlink_subvol(trans, root, dir,\n\t\t\t\tdest->root_key.objectid,\n\t\t\t\tdentry->d_name.name,\n\t\t\t\tdentry->d_name.len);\n\tif (ret) {\n\t\terr = ret;\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto out_end_trans;\n\t}\n\n\tbtrfs_record_root_in_trans(trans, dest);\n\n\tmemset(&dest->root_item.drop_progress, 0,\n\t\tsizeof(dest->root_item.drop_progress));\n\tdest->root_item.drop_level = 0;\n\tbtrfs_set_root_refs(&dest->root_item, 0);\n\n\tif (!test_and_set_bit(BTRFS_ROOT_ORPHAN_ITEM_INSERTED, &dest->state)) {\n\t\tret = btrfs_insert_orphan_item(trans,\n\t\t\t\t\troot->fs_info->tree_root,\n\t\t\t\t\tdest->root_key.objectid);\n\t\tif (ret) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\terr = ret;\n\t\t\tgoto out_end_trans;\n\t\t}\n\t}\n\n\tret = btrfs_uuid_tree_rem(trans, root->fs_info->uuid_root,\n\t\t\t\t  dest->root_item.uuid, BTRFS_UUID_KEY_SUBVOL,\n\t\t\t\t  dest->root_key.objectid);\n\tif (ret && ret != -ENOENT) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\terr = ret;\n\t\tgoto out_end_trans;\n\t}\n\tif (!btrfs_is_empty_uuid(dest->root_item.received_uuid)) {\n\t\tret = btrfs_uuid_tree_rem(trans, root->fs_info->uuid_root,\n\t\t\t\t\t  dest->root_item.received_uuid,\n\t\t\t\t\t  BTRFS_UUID_KEY_RECEIVED_SUBVOL,\n\t\t\t\t\t  dest->root_key.objectid);\n\t\tif (ret && ret != -ENOENT) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\terr = ret;\n\t\t\tgoto out_end_trans;\n\t\t}\n\t}\n\nout_end_trans:\n\ttrans->block_rsv = NULL;\n\ttrans->bytes_reserved = 0;\n\tret = btrfs_end_transaction(trans, root);\n\tif (ret && !err)\n\t\terr = ret;\n\tinode->i_flags |= S_DEAD;\nout_release:\n\tbtrfs_subvolume_release_metadata(root, &block_rsv, qgroup_reserved);\nout_up_write:\n\tup_write(&root->fs_info->subvol_sem);\n\tif (err) {\n\t\tspin_lock(&dest->root_item_lock);\n\t\troot_flags = btrfs_root_flags(&dest->root_item);\n\t\tbtrfs_set_root_flags(&dest->root_item,\n\t\t\t\troot_flags & ~BTRFS_ROOT_SUBVOL_DEAD);\n\t\tspin_unlock(&dest->root_item_lock);\n\t}\n\tmutex_unlock(&inode->i_mutex);\n\tif (!err) {\n\t\tshrink_dcache_sb(root->fs_info->sb);\n\t\tbtrfs_invalidate_inodes(dest);\n\t\td_delete(dentry);\n\t\tASSERT(dest->send_in_progress == 0);\n\n\t\t/* the last ref */\n\t\tif (dest->ino_cache_inode) {\n\t\t\tiput(dest->ino_cache_inode);\n\t\t\tdest->ino_cache_inode = NULL;\n\t\t}\n\t}\nout_dput:\n\tdput(dentry);\nout_unlock_dir:\n\tmutex_unlock(&dir->i_mutex);\nout_drop_write:\n\tmnt_drop_write_file(file);\nout:\n\tkfree(vol_args);\n\treturn err;\n}"
  },
  {
    "function_name": "btrfs_ioctl_ino_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "2262-2290",
    "snippet": "static noinline int btrfs_ioctl_ino_lookup(struct file *file,\n\t\t\t\t\t   void __user *argp)\n{\n\t struct btrfs_ioctl_ino_lookup_args *args;\n\t struct inode *inode;\n\t int ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\targs = memdup_user(argp, sizeof(*args));\n\tif (IS_ERR(args))\n\t\treturn PTR_ERR(args);\n\n\tinode = file_inode(file);\n\n\tif (args->treeid == 0)\n\t\targs->treeid = BTRFS_I(inode)->root->root_key.objectid;\n\n\tret = btrfs_search_path_in_tree(BTRFS_I(inode)->root->fs_info,\n\t\t\t\t\targs->treeid, args->objectid,\n\t\t\t\t\targs->name);\n\n\tif (ret == 0 && copy_to_user(argp, args, sizeof(*args)))\n\t\tret = -EFAULT;\n\n\tkfree(args);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "args"
          ],
          "line": 2288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "argp",
            "args",
            "sizeof(*args)"
          ],
          "line": 2285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_path_in_tree",
          "args": [
            "BTRFS_I(inode)->root->fs_info",
            "args->treeid",
            "args->objectid",
            "args->name"
          ],
          "line": 2281
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_path_in_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "2176-2260",
          "snippet": "static noinline int btrfs_search_path_in_tree(struct btrfs_fs_info *info,\n\t\t\t\tu64 tree_id, u64 dirid, char *name)\n{\n\tstruct btrfs_root *root;\n\tstruct btrfs_key key;\n\tchar *ptr;\n\tint ret = -1;\n\tint slot;\n\tint len;\n\tint total_len = 0;\n\tstruct btrfs_inode_ref *iref;\n\tstruct extent_buffer *l;\n\tstruct btrfs_path *path;\n\n\tif (dirid == BTRFS_FIRST_FREE_OBJECTID) {\n\t\tname[0]='\\0';\n\t\treturn 0;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tptr = &name[BTRFS_INO_LOOKUP_PATH_MAX];\n\n\tkey.objectid = tree_id;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tkey.offset = (u64)-1;\n\troot = btrfs_read_fs_root_no_name(info, &key);\n\tif (IS_ERR(root)) {\n\t\tprintk(KERN_ERR \"BTRFS: could not find root %llu\\n\", tree_id);\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tkey.objectid = dirid;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\tkey.offset = (u64)-1;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\telse if (ret > 0) {\n\t\t\tret = btrfs_previous_item(root, path, dirid,\n\t\t\t\t\t\t  BTRFS_INODE_REF_KEY);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\telse if (ret > 0) {\n\t\t\t\tret = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tl = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tbtrfs_item_key_to_cpu(l, &key, slot);\n\n\t\tiref = btrfs_item_ptr(l, slot, struct btrfs_inode_ref);\n\t\tlen = btrfs_inode_ref_name_len(l, iref);\n\t\tptr -= len + 1;\n\t\ttotal_len += len + 1;\n\t\tif (ptr < name) {\n\t\t\tret = -ENAMETOOLONG;\n\t\t\tgoto out;\n\t\t}\n\n\t\t*(ptr + len) = '/';\n\t\tread_extent_buffer(l, ptr, (unsigned long)(iref + 1), len);\n\n\t\tif (key.offset == BTRFS_FIRST_FREE_OBJECTID)\n\t\t\tbreak;\n\n\t\tbtrfs_release_path(path);\n\t\tkey.objectid = key.offset;\n\t\tkey.offset = (u64)-1;\n\t\tdirid = key.objectid;\n\t}\n\tmemmove(name, ptr, total_len);\n\tname[total_len] = '\\0';\n\tret = 0;\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic noinline int btrfs_search_path_in_tree(struct btrfs_fs_info *info,\n\t\t\t\tu64 tree_id, u64 dirid, char *name)\n{\n\tstruct btrfs_root *root;\n\tstruct btrfs_key key;\n\tchar *ptr;\n\tint ret = -1;\n\tint slot;\n\tint len;\n\tint total_len = 0;\n\tstruct btrfs_inode_ref *iref;\n\tstruct extent_buffer *l;\n\tstruct btrfs_path *path;\n\n\tif (dirid == BTRFS_FIRST_FREE_OBJECTID) {\n\t\tname[0]='\\0';\n\t\treturn 0;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tptr = &name[BTRFS_INO_LOOKUP_PATH_MAX];\n\n\tkey.objectid = tree_id;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tkey.offset = (u64)-1;\n\troot = btrfs_read_fs_root_no_name(info, &key);\n\tif (IS_ERR(root)) {\n\t\tprintk(KERN_ERR \"BTRFS: could not find root %llu\\n\", tree_id);\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tkey.objectid = dirid;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\tkey.offset = (u64)-1;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\telse if (ret > 0) {\n\t\t\tret = btrfs_previous_item(root, path, dirid,\n\t\t\t\t\t\t  BTRFS_INODE_REF_KEY);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\telse if (ret > 0) {\n\t\t\t\tret = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tl = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tbtrfs_item_key_to_cpu(l, &key, slot);\n\n\t\tiref = btrfs_item_ptr(l, slot, struct btrfs_inode_ref);\n\t\tlen = btrfs_inode_ref_name_len(l, iref);\n\t\tptr -= len + 1;\n\t\ttotal_len += len + 1;\n\t\tif (ptr < name) {\n\t\t\tret = -ENAMETOOLONG;\n\t\t\tgoto out;\n\t\t}\n\n\t\t*(ptr + len) = '/';\n\t\tread_extent_buffer(l, ptr, (unsigned long)(iref + 1), len);\n\n\t\tif (key.offset == BTRFS_FIRST_FREE_OBJECTID)\n\t\t\tbreak;\n\n\t\tbtrfs_release_path(path);\n\t\tkey.objectid = key.offset;\n\t\tkey.offset = (u64)-1;\n\t\tdirid = key.objectid;\n\t}\n\tmemmove(name, ptr, total_len);\n\tname[total_len] = '\\0';\n\tret = 0;\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 2281
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 2276
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "args"
          ],
          "line": 2274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "args"
          ],
          "line": 2273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user",
          "args": [
            "argp",
            "sizeof(*args)"
          ],
          "line": 2272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 2269
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic noinline int btrfs_ioctl_ino_lookup(struct file *file,\n\t\t\t\t\t   void __user *argp)\n{\n\t struct btrfs_ioctl_ino_lookup_args *args;\n\t struct inode *inode;\n\t int ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\targs = memdup_user(argp, sizeof(*args));\n\tif (IS_ERR(args))\n\t\treturn PTR_ERR(args);\n\n\tinode = file_inode(file);\n\n\tif (args->treeid == 0)\n\t\targs->treeid = BTRFS_I(inode)->root->root_key.objectid;\n\n\tret = btrfs_search_path_in_tree(BTRFS_I(inode)->root->fs_info,\n\t\t\t\t\targs->treeid, args->objectid,\n\t\t\t\t\targs->name);\n\n\tif (ret == 0 && copy_to_user(argp, args, sizeof(*args)))\n\t\tret = -EFAULT;\n\n\tkfree(args);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_search_path_in_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "2176-2260",
    "snippet": "static noinline int btrfs_search_path_in_tree(struct btrfs_fs_info *info,\n\t\t\t\tu64 tree_id, u64 dirid, char *name)\n{\n\tstruct btrfs_root *root;\n\tstruct btrfs_key key;\n\tchar *ptr;\n\tint ret = -1;\n\tint slot;\n\tint len;\n\tint total_len = 0;\n\tstruct btrfs_inode_ref *iref;\n\tstruct extent_buffer *l;\n\tstruct btrfs_path *path;\n\n\tif (dirid == BTRFS_FIRST_FREE_OBJECTID) {\n\t\tname[0]='\\0';\n\t\treturn 0;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tptr = &name[BTRFS_INO_LOOKUP_PATH_MAX];\n\n\tkey.objectid = tree_id;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tkey.offset = (u64)-1;\n\troot = btrfs_read_fs_root_no_name(info, &key);\n\tif (IS_ERR(root)) {\n\t\tprintk(KERN_ERR \"BTRFS: could not find root %llu\\n\", tree_id);\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tkey.objectid = dirid;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\tkey.offset = (u64)-1;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\telse if (ret > 0) {\n\t\t\tret = btrfs_previous_item(root, path, dirid,\n\t\t\t\t\t\t  BTRFS_INODE_REF_KEY);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\telse if (ret > 0) {\n\t\t\t\tret = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tl = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tbtrfs_item_key_to_cpu(l, &key, slot);\n\n\t\tiref = btrfs_item_ptr(l, slot, struct btrfs_inode_ref);\n\t\tlen = btrfs_inode_ref_name_len(l, iref);\n\t\tptr -= len + 1;\n\t\ttotal_len += len + 1;\n\t\tif (ptr < name) {\n\t\t\tret = -ENAMETOOLONG;\n\t\t\tgoto out;\n\t\t}\n\n\t\t*(ptr + len) = '/';\n\t\tread_extent_buffer(l, ptr, (unsigned long)(iref + 1), len);\n\n\t\tif (key.offset == BTRFS_FIRST_FREE_OBJECTID)\n\t\t\tbreak;\n\n\t\tbtrfs_release_path(path);\n\t\tkey.objectid = key.offset;\n\t\tkey.offset = (u64)-1;\n\t\tdirid = key.objectid;\n\t}\n\tmemmove(name, ptr, total_len);\n\tname[total_len] = '\\0';\n\tret = 0;\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 2258
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "name",
            "ptr",
            "total_len"
          ],
          "line": 2254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 2249
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_extent_buffer",
          "args": [
            "l",
            "ptr",
            "(unsigned long)(iref + 1)",
            "len"
          ],
          "line": 2244
        },
        "resolved": true,
        "details": {
          "function_name": "btree_read_extent_buffer_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "442-497",
          "snippet": "static int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_inode_ref_name_len",
          "args": [
            "l",
            "iref"
          ],
          "line": 2235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "l",
            "slot",
            "structbtrfs_inode_ref"
          ],
          "line": 2234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "l",
            "&key",
            "slot"
          ],
          "line": 2232
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_previous_item",
          "args": [
            "root",
            "path",
            "dirid",
            "BTRFS_INODE_REF_KEY"
          ],
          "line": 2220
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_previous_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5830-5865",
          "snippet": "int btrfs_previous_item(struct btrfs_root *root,\n\t\t\tstruct btrfs_path *path, u64 min_objectid,\n\t\t\tint type)\n{\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *leaf;\n\tu32 nritems;\n\tint ret;\n\n\twhile (1) {\n\t\tif (path->slots[0] == 0) {\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tret = btrfs_prev_leaf(root, path);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tpath->slots[0]--;\n\t\t}\n\t\tleaf = path->nodes[0];\n\t\tnritems = btrfs_header_nritems(leaf);\n\t\tif (nritems == 0)\n\t\t\treturn 1;\n\t\tif (path->slots[0] == nritems)\n\t\t\tpath->slots[0]--;\n\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\tif (found_key.objectid < min_objectid)\n\t\t\tbreak;\n\t\tif (found_key.type == type)\n\t\t\treturn 0;\n\t\tif (found_key.objectid == min_objectid &&\n\t\t    found_key.type < type)\n\t\t\tbreak;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_previous_item(struct btrfs_root *root,\n\t\t\tstruct btrfs_path *path, u64 min_objectid,\n\t\t\tint type)\n{\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *leaf;\n\tu32 nritems;\n\tint ret;\n\n\twhile (1) {\n\t\tif (path->slots[0] == 0) {\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tret = btrfs_prev_leaf(root, path);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tpath->slots[0]--;\n\t\t}\n\t\tleaf = path->nodes[0];\n\t\tnritems = btrfs_header_nritems(leaf);\n\t\tif (nritems == 0)\n\t\t\treturn 1;\n\t\tif (path->slots[0] == nritems)\n\t\t\tpath->slots[0]--;\n\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\tif (found_key.objectid < min_objectid)\n\t\t\tbreak;\n\t\tif (found_key.type == type)\n\t\t\treturn 0;\n\t\tif (found_key.objectid == min_objectid &&\n\t\t    found_key.type < type)\n\t\t\tbreak;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "root",
            "&key",
            "path",
            "0",
            "0"
          ],
          "line": 2216
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"BTRFS: could not find root %llu\\n\"",
            "tree_id"
          ],
          "line": 2206
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "root"
          ],
          "line": 2205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_read_fs_root_no_name",
          "args": [
            "info",
            "&key"
          ],
          "line": 2204
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_read_fs_root_no_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.h",
          "lines": "76-81",
          "snippet": "static inline struct btrfs_root *\nbtrfs_read_fs_root_no_name(struct btrfs_fs_info *fs_info,\n\t\t\t   struct btrfs_key *location)\n{\n\treturn btrfs_get_fs_root(fs_info, location, true);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct btrfs_root *\nbtrfs_read_fs_root_no_name(struct btrfs_fs_info *fs_info,\n\t\t\t   struct btrfs_key *location)\n{\n\treturn btrfs_get_fs_root(fs_info, location, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 2195
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic noinline int btrfs_search_path_in_tree(struct btrfs_fs_info *info,\n\t\t\t\tu64 tree_id, u64 dirid, char *name)\n{\n\tstruct btrfs_root *root;\n\tstruct btrfs_key key;\n\tchar *ptr;\n\tint ret = -1;\n\tint slot;\n\tint len;\n\tint total_len = 0;\n\tstruct btrfs_inode_ref *iref;\n\tstruct extent_buffer *l;\n\tstruct btrfs_path *path;\n\n\tif (dirid == BTRFS_FIRST_FREE_OBJECTID) {\n\t\tname[0]='\\0';\n\t\treturn 0;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tptr = &name[BTRFS_INO_LOOKUP_PATH_MAX];\n\n\tkey.objectid = tree_id;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tkey.offset = (u64)-1;\n\troot = btrfs_read_fs_root_no_name(info, &key);\n\tif (IS_ERR(root)) {\n\t\tprintk(KERN_ERR \"BTRFS: could not find root %llu\\n\", tree_id);\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tkey.objectid = dirid;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\tkey.offset = (u64)-1;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\telse if (ret > 0) {\n\t\t\tret = btrfs_previous_item(root, path, dirid,\n\t\t\t\t\t\t  BTRFS_INODE_REF_KEY);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\telse if (ret > 0) {\n\t\t\t\tret = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tl = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tbtrfs_item_key_to_cpu(l, &key, slot);\n\n\t\tiref = btrfs_item_ptr(l, slot, struct btrfs_inode_ref);\n\t\tlen = btrfs_inode_ref_name_len(l, iref);\n\t\tptr -= len + 1;\n\t\ttotal_len += len + 1;\n\t\tif (ptr < name) {\n\t\t\tret = -ENAMETOOLONG;\n\t\t\tgoto out;\n\t\t}\n\n\t\t*(ptr + len) = '/';\n\t\tread_extent_buffer(l, ptr, (unsigned long)(iref + 1), len);\n\n\t\tif (key.offset == BTRFS_FIRST_FREE_OBJECTID)\n\t\t\tbreak;\n\n\t\tbtrfs_release_path(path);\n\t\tkey.objectid = key.offset;\n\t\tkey.offset = (u64)-1;\n\t\tdirid = key.objectid;\n\t}\n\tmemmove(name, ptr, total_len);\n\tname[total_len] = '\\0';\n\tret = 0;\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_ioctl_tree_search_v2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "2133-2170",
    "snippet": "static noinline int btrfs_ioctl_tree_search_v2(struct file *file,\n\t\t\t\t\t       void __user *argp)\n{\n\tstruct btrfs_ioctl_search_args_v2 __user *uarg;\n\tstruct btrfs_ioctl_search_args_v2 args;\n\tstruct inode *inode;\n\tint ret;\n\tsize_t buf_size;\n\tconst size_t buf_limit = 16 * 1024 * 1024;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t/* copy search header and buffer size */\n\tuarg = (struct btrfs_ioctl_search_args_v2 __user *)argp;\n\tif (copy_from_user(&args, uarg, sizeof(args)))\n\t\treturn -EFAULT;\n\n\tbuf_size = args.buf_size;\n\n\tif (buf_size < sizeof(struct btrfs_ioctl_search_header))\n\t\treturn -EOVERFLOW;\n\n\t/* limit result size to 16MB */\n\tif (buf_size > buf_limit)\n\t\tbuf_size = buf_limit;\n\n\tinode = file_inode(file);\n\tret = search_ioctl(inode, &args.key, &buf_size,\n\t\t\t   (char *)(&uarg->buf[0]));\n\tif (ret == 0 && copy_to_user(&uarg->key, &args.key, sizeof(args.key)))\n\t\tret = -EFAULT;\n\telse if (ret == -EOVERFLOW &&\n\t\tcopy_to_user(&uarg->buf_size, &buf_size, sizeof(buf_size)))\n\t\tret = -EFAULT;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "&uarg->buf_size",
            "&buf_size",
            "sizeof(buf_size)"
          ],
          "line": 2166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "&uarg->key",
            "&args.key",
            "sizeof(args.key)"
          ],
          "line": 2163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "search_ioctl",
          "args": [
            "inode",
            "&args.key",
            "&buf_size",
            "(char *)(&uarg->buf[0])"
          ],
          "line": 2161
        },
        "resolved": true,
        "details": {
          "function_name": "search_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "2035-2097",
          "snippet": "static noinline int search_ioctl(struct inode *inode,\n\t\t\t\t struct btrfs_ioctl_search_key *sk,\n\t\t\t\t size_t *buf_size,\n\t\t\t\t char __user *ubuf)\n{\n\tstruct btrfs_root *root;\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\tstruct btrfs_fs_info *info = BTRFS_I(inode)->root->fs_info;\n\tint ret;\n\tint num_found = 0;\n\tunsigned long sk_offset = 0;\n\n\tif (*buf_size < sizeof(struct btrfs_ioctl_search_header)) {\n\t\t*buf_size = sizeof(struct btrfs_ioctl_search_header);\n\t\treturn -EOVERFLOW;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tif (sk->tree_id == 0) {\n\t\t/* search the root of the inode that was passed */\n\t\troot = BTRFS_I(inode)->root;\n\t} else {\n\t\tkey.objectid = sk->tree_id;\n\t\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\t\tkey.offset = (u64)-1;\n\t\troot = btrfs_read_fs_root_no_name(info, &key);\n\t\tif (IS_ERR(root)) {\n\t\t\tprintk(KERN_ERR \"BTRFS: could not find root %llu\\n\",\n\t\t\t       sk->tree_id);\n\t\t\tbtrfs_free_path(path);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\tkey.objectid = sk->min_objectid;\n\tkey.type = sk->min_type;\n\tkey.offset = sk->min_offset;\n\n\twhile (1) {\n\t\tret = btrfs_search_forward(root, &key, path, sk->min_transid);\n\t\tif (ret != 0) {\n\t\t\tif (ret > 0)\n\t\t\t\tret = 0;\n\t\t\tgoto err;\n\t\t}\n\t\tret = copy_to_sk(root, path, &key, sk, buf_size, ubuf,\n\t\t\t\t &sk_offset, &num_found);\n\t\tbtrfs_release_path(path);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t}\n\tif (ret > 0)\n\t\tret = 0;\nerr:\n\tsk->nr_items = num_found;\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic noinline int search_ioctl(struct inode *inode,\n\t\t\t\t struct btrfs_ioctl_search_key *sk,\n\t\t\t\t size_t *buf_size,\n\t\t\t\t char __user *ubuf)\n{\n\tstruct btrfs_root *root;\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\tstruct btrfs_fs_info *info = BTRFS_I(inode)->root->fs_info;\n\tint ret;\n\tint num_found = 0;\n\tunsigned long sk_offset = 0;\n\n\tif (*buf_size < sizeof(struct btrfs_ioctl_search_header)) {\n\t\t*buf_size = sizeof(struct btrfs_ioctl_search_header);\n\t\treturn -EOVERFLOW;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tif (sk->tree_id == 0) {\n\t\t/* search the root of the inode that was passed */\n\t\troot = BTRFS_I(inode)->root;\n\t} else {\n\t\tkey.objectid = sk->tree_id;\n\t\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\t\tkey.offset = (u64)-1;\n\t\troot = btrfs_read_fs_root_no_name(info, &key);\n\t\tif (IS_ERR(root)) {\n\t\t\tprintk(KERN_ERR \"BTRFS: could not find root %llu\\n\",\n\t\t\t       sk->tree_id);\n\t\t\tbtrfs_free_path(path);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\tkey.objectid = sk->min_objectid;\n\tkey.type = sk->min_type;\n\tkey.offset = sk->min_offset;\n\n\twhile (1) {\n\t\tret = btrfs_search_forward(root, &key, path, sk->min_transid);\n\t\tif (ret != 0) {\n\t\t\tif (ret > 0)\n\t\t\t\tret = 0;\n\t\t\tgoto err;\n\t\t}\n\t\tret = copy_to_sk(root, path, &key, sk, buf_size, ubuf,\n\t\t\t\t &sk_offset, &num_found);\n\t\tbtrfs_release_path(path);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t}\n\tif (ret > 0)\n\t\tret = 0;\nerr:\n\tsk->nr_items = num_found;\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 2160
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&args",
            "uarg",
            "sizeof(args)"
          ],
          "line": 2148
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 2143
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic noinline int btrfs_ioctl_tree_search_v2(struct file *file,\n\t\t\t\t\t       void __user *argp)\n{\n\tstruct btrfs_ioctl_search_args_v2 __user *uarg;\n\tstruct btrfs_ioctl_search_args_v2 args;\n\tstruct inode *inode;\n\tint ret;\n\tsize_t buf_size;\n\tconst size_t buf_limit = 16 * 1024 * 1024;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t/* copy search header and buffer size */\n\tuarg = (struct btrfs_ioctl_search_args_v2 __user *)argp;\n\tif (copy_from_user(&args, uarg, sizeof(args)))\n\t\treturn -EFAULT;\n\n\tbuf_size = args.buf_size;\n\n\tif (buf_size < sizeof(struct btrfs_ioctl_search_header))\n\t\treturn -EOVERFLOW;\n\n\t/* limit result size to 16MB */\n\tif (buf_size > buf_limit)\n\t\tbuf_size = buf_limit;\n\n\tinode = file_inode(file);\n\tret = search_ioctl(inode, &args.key, &buf_size,\n\t\t\t   (char *)(&uarg->buf[0]));\n\tif (ret == 0 && copy_to_user(&uarg->key, &args.key, sizeof(args.key)))\n\t\tret = -EFAULT;\n\telse if (ret == -EOVERFLOW &&\n\t\tcopy_to_user(&uarg->buf_size, &buf_size, sizeof(buf_size)))\n\t\tret = -EFAULT;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_ioctl_tree_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "2099-2131",
    "snippet": "static noinline int btrfs_ioctl_tree_search(struct file *file,\n\t\t\t\t\t   void __user *argp)\n{\n\tstruct btrfs_ioctl_search_args __user *uargs;\n\tstruct btrfs_ioctl_search_key sk;\n\tstruct inode *inode;\n\tint ret;\n\tsize_t buf_size;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tuargs = (struct btrfs_ioctl_search_args __user *)argp;\n\n\tif (copy_from_user(&sk, &uargs->key, sizeof(sk)))\n\t\treturn -EFAULT;\n\n\tbuf_size = sizeof(uargs->buf);\n\n\tinode = file_inode(file);\n\tret = search_ioctl(inode, &sk, &buf_size, uargs->buf);\n\n\t/*\n\t * In the origin implementation an overflow is handled by returning a\n\t * search header with a len of zero, so reset ret.\n\t */\n\tif (ret == -EOVERFLOW)\n\t\tret = 0;\n\n\tif (ret == 0 && copy_to_user(&uargs->key, &sk, sizeof(sk)))\n\t\tret = -EFAULT;\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "&uargs->key",
            "&sk",
            "sizeof(sk)"
          ],
          "line": 2128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "search_ioctl",
          "args": [
            "inode",
            "&sk",
            "&buf_size",
            "uargs->buf"
          ],
          "line": 2119
        },
        "resolved": true,
        "details": {
          "function_name": "search_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "2035-2097",
          "snippet": "static noinline int search_ioctl(struct inode *inode,\n\t\t\t\t struct btrfs_ioctl_search_key *sk,\n\t\t\t\t size_t *buf_size,\n\t\t\t\t char __user *ubuf)\n{\n\tstruct btrfs_root *root;\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\tstruct btrfs_fs_info *info = BTRFS_I(inode)->root->fs_info;\n\tint ret;\n\tint num_found = 0;\n\tunsigned long sk_offset = 0;\n\n\tif (*buf_size < sizeof(struct btrfs_ioctl_search_header)) {\n\t\t*buf_size = sizeof(struct btrfs_ioctl_search_header);\n\t\treturn -EOVERFLOW;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tif (sk->tree_id == 0) {\n\t\t/* search the root of the inode that was passed */\n\t\troot = BTRFS_I(inode)->root;\n\t} else {\n\t\tkey.objectid = sk->tree_id;\n\t\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\t\tkey.offset = (u64)-1;\n\t\troot = btrfs_read_fs_root_no_name(info, &key);\n\t\tif (IS_ERR(root)) {\n\t\t\tprintk(KERN_ERR \"BTRFS: could not find root %llu\\n\",\n\t\t\t       sk->tree_id);\n\t\t\tbtrfs_free_path(path);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\tkey.objectid = sk->min_objectid;\n\tkey.type = sk->min_type;\n\tkey.offset = sk->min_offset;\n\n\twhile (1) {\n\t\tret = btrfs_search_forward(root, &key, path, sk->min_transid);\n\t\tif (ret != 0) {\n\t\t\tif (ret > 0)\n\t\t\t\tret = 0;\n\t\t\tgoto err;\n\t\t}\n\t\tret = copy_to_sk(root, path, &key, sk, buf_size, ubuf,\n\t\t\t\t &sk_offset, &num_found);\n\t\tbtrfs_release_path(path);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t}\n\tif (ret > 0)\n\t\tret = 0;\nerr:\n\tsk->nr_items = num_found;\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic noinline int search_ioctl(struct inode *inode,\n\t\t\t\t struct btrfs_ioctl_search_key *sk,\n\t\t\t\t size_t *buf_size,\n\t\t\t\t char __user *ubuf)\n{\n\tstruct btrfs_root *root;\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\tstruct btrfs_fs_info *info = BTRFS_I(inode)->root->fs_info;\n\tint ret;\n\tint num_found = 0;\n\tunsigned long sk_offset = 0;\n\n\tif (*buf_size < sizeof(struct btrfs_ioctl_search_header)) {\n\t\t*buf_size = sizeof(struct btrfs_ioctl_search_header);\n\t\treturn -EOVERFLOW;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tif (sk->tree_id == 0) {\n\t\t/* search the root of the inode that was passed */\n\t\troot = BTRFS_I(inode)->root;\n\t} else {\n\t\tkey.objectid = sk->tree_id;\n\t\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\t\tkey.offset = (u64)-1;\n\t\troot = btrfs_read_fs_root_no_name(info, &key);\n\t\tif (IS_ERR(root)) {\n\t\t\tprintk(KERN_ERR \"BTRFS: could not find root %llu\\n\",\n\t\t\t       sk->tree_id);\n\t\t\tbtrfs_free_path(path);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\tkey.objectid = sk->min_objectid;\n\tkey.type = sk->min_type;\n\tkey.offset = sk->min_offset;\n\n\twhile (1) {\n\t\tret = btrfs_search_forward(root, &key, path, sk->min_transid);\n\t\tif (ret != 0) {\n\t\t\tif (ret > 0)\n\t\t\t\tret = 0;\n\t\t\tgoto err;\n\t\t}\n\t\tret = copy_to_sk(root, path, &key, sk, buf_size, ubuf,\n\t\t\t\t &sk_offset, &num_found);\n\t\tbtrfs_release_path(path);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t}\n\tif (ret > 0)\n\t\tret = 0;\nerr:\n\tsk->nr_items = num_found;\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 2118
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&sk",
            "&uargs->key",
            "sizeof(sk)"
          ],
          "line": 2113
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 2108
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic noinline int btrfs_ioctl_tree_search(struct file *file,\n\t\t\t\t\t   void __user *argp)\n{\n\tstruct btrfs_ioctl_search_args __user *uargs;\n\tstruct btrfs_ioctl_search_key sk;\n\tstruct inode *inode;\n\tint ret;\n\tsize_t buf_size;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tuargs = (struct btrfs_ioctl_search_args __user *)argp;\n\n\tif (copy_from_user(&sk, &uargs->key, sizeof(sk)))\n\t\treturn -EFAULT;\n\n\tbuf_size = sizeof(uargs->buf);\n\n\tinode = file_inode(file);\n\tret = search_ioctl(inode, &sk, &buf_size, uargs->buf);\n\n\t/*\n\t * In the origin implementation an overflow is handled by returning a\n\t * search header with a len of zero, so reset ret.\n\t */\n\tif (ret == -EOVERFLOW)\n\t\tret = 0;\n\n\tif (ret == 0 && copy_to_user(&uargs->key, &sk, sizeof(sk)))\n\t\tret = -EFAULT;\n\treturn ret;\n}"
  },
  {
    "function_name": "search_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "2035-2097",
    "snippet": "static noinline int search_ioctl(struct inode *inode,\n\t\t\t\t struct btrfs_ioctl_search_key *sk,\n\t\t\t\t size_t *buf_size,\n\t\t\t\t char __user *ubuf)\n{\n\tstruct btrfs_root *root;\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\tstruct btrfs_fs_info *info = BTRFS_I(inode)->root->fs_info;\n\tint ret;\n\tint num_found = 0;\n\tunsigned long sk_offset = 0;\n\n\tif (*buf_size < sizeof(struct btrfs_ioctl_search_header)) {\n\t\t*buf_size = sizeof(struct btrfs_ioctl_search_header);\n\t\treturn -EOVERFLOW;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tif (sk->tree_id == 0) {\n\t\t/* search the root of the inode that was passed */\n\t\troot = BTRFS_I(inode)->root;\n\t} else {\n\t\tkey.objectid = sk->tree_id;\n\t\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\t\tkey.offset = (u64)-1;\n\t\troot = btrfs_read_fs_root_no_name(info, &key);\n\t\tif (IS_ERR(root)) {\n\t\t\tprintk(KERN_ERR \"BTRFS: could not find root %llu\\n\",\n\t\t\t       sk->tree_id);\n\t\t\tbtrfs_free_path(path);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\tkey.objectid = sk->min_objectid;\n\tkey.type = sk->min_type;\n\tkey.offset = sk->min_offset;\n\n\twhile (1) {\n\t\tret = btrfs_search_forward(root, &key, path, sk->min_transid);\n\t\tif (ret != 0) {\n\t\t\tif (ret > 0)\n\t\t\t\tret = 0;\n\t\t\tgoto err;\n\t\t}\n\t\tret = copy_to_sk(root, path, &key, sk, buf_size, ubuf,\n\t\t\t\t &sk_offset, &num_found);\n\t\tbtrfs_release_path(path);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t}\n\tif (ret > 0)\n\t\tret = 0;\nerr:\n\tsk->nr_items = num_found;\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 2095
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 2086
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_sk",
          "args": [
            "root",
            "path",
            "&key",
            "sk",
            "buf_size",
            "ubuf",
            "&sk_offset",
            "&num_found"
          ],
          "line": 2084
        },
        "resolved": true,
        "details": {
          "function_name": "copy_to_sk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "1916-2033",
          "snippet": "static noinline int copy_to_sk(struct btrfs_root *root,\n\t\t\t       struct btrfs_path *path,\n\t\t\t       struct btrfs_key *key,\n\t\t\t       struct btrfs_ioctl_search_key *sk,\n\t\t\t       size_t *buf_size,\n\t\t\t       char __user *ubuf,\n\t\t\t       unsigned long *sk_offset,\n\t\t\t       int *num_found)\n{\n\tu64 found_transid;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_ioctl_search_header sh;\n\tunsigned long item_off;\n\tunsigned long item_len;\n\tint nritems;\n\tint i;\n\tint slot;\n\tint ret = 0;\n\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\tnritems = btrfs_header_nritems(leaf);\n\n\tif (btrfs_header_generation(leaf) > sk->max_transid) {\n\t\ti = nritems;\n\t\tgoto advance_key;\n\t}\n\tfound_transid = btrfs_header_generation(leaf);\n\n\tfor (i = slot; i < nritems; i++) {\n\t\titem_off = btrfs_item_ptr_offset(leaf, i);\n\t\titem_len = btrfs_item_size_nr(leaf, i);\n\n\t\tbtrfs_item_key_to_cpu(leaf, key, i);\n\t\tif (!key_in_sk(key, sk))\n\t\t\tcontinue;\n\n\t\tif (sizeof(sh) + item_len > *buf_size) {\n\t\t\tif (*num_found) {\n\t\t\t\tret = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * return one empty item back for v1, which does not\n\t\t\t * handle -EOVERFLOW\n\t\t\t */\n\n\t\t\t*buf_size = sizeof(sh) + item_len;\n\t\t\titem_len = 0;\n\t\t\tret = -EOVERFLOW;\n\t\t}\n\n\t\tif (sizeof(sh) + item_len + *sk_offset > *buf_size) {\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsh.objectid = key->objectid;\n\t\tsh.offset = key->offset;\n\t\tsh.type = key->type;\n\t\tsh.len = item_len;\n\t\tsh.transid = found_transid;\n\n\t\t/* copy search result header */\n\t\tif (copy_to_user(ubuf + *sk_offset, &sh, sizeof(sh))) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\t*sk_offset += sizeof(sh);\n\n\t\tif (item_len) {\n\t\t\tchar __user *up = ubuf + *sk_offset;\n\t\t\t/* copy the item */\n\t\t\tif (read_extent_buffer_to_user(leaf, up,\n\t\t\t\t\t\t       item_off, item_len)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t*sk_offset += item_len;\n\t\t}\n\t\t(*num_found)++;\n\n\t\tif (ret) /* -EOVERFLOW from above */\n\t\t\tgoto out;\n\n\t\tif (*num_found >= sk->nr_items) {\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\t}\nadvance_key:\n\tret = 0;\n\tif (key->offset < (u64)-1 && key->offset < sk->max_offset)\n\t\tkey->offset++;\n\telse if (key->type < (u8)-1 && key->type < sk->max_type) {\n\t\tkey->offset = 0;\n\t\tkey->type++;\n\t} else if (key->objectid < (u64)-1 && key->objectid < sk->max_objectid) {\n\t\tkey->offset = 0;\n\t\tkey->type = 0;\n\t\tkey->objectid++;\n\t} else\n\t\tret = 1;\nout:\n\t/*\n\t *  0: all items from this leaf copied, continue with next\n\t *  1: * more items can be copied, but unused buffer is too small\n\t *     * all items were found\n\t *     Either way, it will stops the loop which iterates to the next\n\t *     leaf\n\t *  -EOVERFLOW: item was to large for buffer\n\t *  -EFAULT: could not copy extent buffer back to userspace\n\t */\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic noinline int copy_to_sk(struct btrfs_root *root,\n\t\t\t       struct btrfs_path *path,\n\t\t\t       struct btrfs_key *key,\n\t\t\t       struct btrfs_ioctl_search_key *sk,\n\t\t\t       size_t *buf_size,\n\t\t\t       char __user *ubuf,\n\t\t\t       unsigned long *sk_offset,\n\t\t\t       int *num_found)\n{\n\tu64 found_transid;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_ioctl_search_header sh;\n\tunsigned long item_off;\n\tunsigned long item_len;\n\tint nritems;\n\tint i;\n\tint slot;\n\tint ret = 0;\n\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\tnritems = btrfs_header_nritems(leaf);\n\n\tif (btrfs_header_generation(leaf) > sk->max_transid) {\n\t\ti = nritems;\n\t\tgoto advance_key;\n\t}\n\tfound_transid = btrfs_header_generation(leaf);\n\n\tfor (i = slot; i < nritems; i++) {\n\t\titem_off = btrfs_item_ptr_offset(leaf, i);\n\t\titem_len = btrfs_item_size_nr(leaf, i);\n\n\t\tbtrfs_item_key_to_cpu(leaf, key, i);\n\t\tif (!key_in_sk(key, sk))\n\t\t\tcontinue;\n\n\t\tif (sizeof(sh) + item_len > *buf_size) {\n\t\t\tif (*num_found) {\n\t\t\t\tret = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * return one empty item back for v1, which does not\n\t\t\t * handle -EOVERFLOW\n\t\t\t */\n\n\t\t\t*buf_size = sizeof(sh) + item_len;\n\t\t\titem_len = 0;\n\t\t\tret = -EOVERFLOW;\n\t\t}\n\n\t\tif (sizeof(sh) + item_len + *sk_offset > *buf_size) {\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsh.objectid = key->objectid;\n\t\tsh.offset = key->offset;\n\t\tsh.type = key->type;\n\t\tsh.len = item_len;\n\t\tsh.transid = found_transid;\n\n\t\t/* copy search result header */\n\t\tif (copy_to_user(ubuf + *sk_offset, &sh, sizeof(sh))) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\t*sk_offset += sizeof(sh);\n\n\t\tif (item_len) {\n\t\t\tchar __user *up = ubuf + *sk_offset;\n\t\t\t/* copy the item */\n\t\t\tif (read_extent_buffer_to_user(leaf, up,\n\t\t\t\t\t\t       item_off, item_len)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t*sk_offset += item_len;\n\t\t}\n\t\t(*num_found)++;\n\n\t\tif (ret) /* -EOVERFLOW from above */\n\t\t\tgoto out;\n\n\t\tif (*num_found >= sk->nr_items) {\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\t}\nadvance_key:\n\tret = 0;\n\tif (key->offset < (u64)-1 && key->offset < sk->max_offset)\n\t\tkey->offset++;\n\telse if (key->type < (u8)-1 && key->type < sk->max_type) {\n\t\tkey->offset = 0;\n\t\tkey->type++;\n\t} else if (key->objectid < (u64)-1 && key->objectid < sk->max_objectid) {\n\t\tkey->offset = 0;\n\t\tkey->type = 0;\n\t\tkey->objectid++;\n\t} else\n\t\tret = 1;\nout:\n\t/*\n\t *  0: all items from this leaf copied, continue with next\n\t *  1: * more items can be copied, but unused buffer is too small\n\t *     * all items were found\n\t *     Either way, it will stops the loop which iterates to the next\n\t *     leaf\n\t *  -EOVERFLOW: item was to large for buffer\n\t *  -EFAULT: could not copy extent buffer back to userspace\n\t */\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_search_forward",
          "args": [
            "root",
            "&key",
            "path",
            "sk->min_transid"
          ],
          "line": 2078
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_forward",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5113-5211",
          "snippet": "int btrfs_search_forward(struct btrfs_root *root, struct btrfs_key *min_key,\n\t\t\t struct btrfs_path *path,\n\t\t\t u64 min_trans)\n{\n\tstruct extent_buffer *cur;\n\tstruct btrfs_key found_key;\n\tint slot;\n\tint sret;\n\tu32 nritems;\n\tint level;\n\tint ret = 1;\n\tint keep_locks = path->keep_locks;\n\n\tpath->keep_locks = 1;\nagain:\n\tcur = btrfs_read_lock_root_node(root);\n\tlevel = btrfs_header_level(cur);\n\tWARN_ON(path->nodes[level]);\n\tpath->nodes[level] = cur;\n\tpath->locks[level] = BTRFS_READ_LOCK;\n\n\tif (btrfs_header_generation(cur) < min_trans) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\twhile (1) {\n\t\tnritems = btrfs_header_nritems(cur);\n\t\tlevel = btrfs_header_level(cur);\n\t\tsret = bin_search(cur, min_key, level, &slot);\n\n\t\t/* at the lowest level, we're done, setup the path and exit */\n\t\tif (level == path->lowest_level) {\n\t\t\tif (slot >= nritems)\n\t\t\t\tgoto find_next_key;\n\t\t\tret = 0;\n\t\t\tpath->slots[level] = slot;\n\t\t\tbtrfs_item_key_to_cpu(cur, &found_key, slot);\n\t\t\tgoto out;\n\t\t}\n\t\tif (sret && slot > 0)\n\t\t\tslot--;\n\t\t/*\n\t\t * check this node pointer against the min_trans parameters.\n\t\t * If it is too old, old, skip to the next one.\n\t\t */\n\t\twhile (slot < nritems) {\n\t\t\tu64 gen;\n\n\t\t\tgen = btrfs_node_ptr_generation(cur, slot);\n\t\t\tif (gen < min_trans) {\n\t\t\t\tslot++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\nfind_next_key:\n\t\t/*\n\t\t * we didn't find a candidate key in this node, walk forward\n\t\t * and find another one\n\t\t */\n\t\tif (slot >= nritems) {\n\t\t\tpath->slots[level] = slot;\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tsret = btrfs_find_next_key(root, path, min_key, level,\n\t\t\t\t\t\t  min_trans);\n\t\t\tif (sret == 0) {\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tgoto again;\n\t\t\t} else {\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\t/* save our key for returning back */\n\t\tbtrfs_node_key_to_cpu(cur, &found_key, slot);\n\t\tpath->slots[level] = slot;\n\t\tif (level == path->lowest_level) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tbtrfs_set_path_blocking(path);\n\t\tcur = read_node_slot(root, cur, slot);\n\t\tBUG_ON(!cur); /* -ENOMEM */\n\n\t\tbtrfs_tree_read_lock(cur);\n\n\t\tpath->locks[level - 1] = BTRFS_READ_LOCK;\n\t\tpath->nodes[level - 1] = cur;\n\t\tunlock_up(path, level, 1, 0, NULL);\n\t\tbtrfs_clear_path_blocking(path, NULL, 0);\n\t}\nout:\n\tpath->keep_locks = keep_locks;\n\tif (ret == 0) {\n\t\tbtrfs_unlock_up_safe(path, path->lowest_level + 1);\n\t\tbtrfs_set_path_blocking(path);\n\t\tmemcpy(min_key, &found_key, sizeof(found_key));\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_forward(struct btrfs_root *root, struct btrfs_key *min_key,\n\t\t\t struct btrfs_path *path,\n\t\t\t u64 min_trans)\n{\n\tstruct extent_buffer *cur;\n\tstruct btrfs_key found_key;\n\tint slot;\n\tint sret;\n\tu32 nritems;\n\tint level;\n\tint ret = 1;\n\tint keep_locks = path->keep_locks;\n\n\tpath->keep_locks = 1;\nagain:\n\tcur = btrfs_read_lock_root_node(root);\n\tlevel = btrfs_header_level(cur);\n\tWARN_ON(path->nodes[level]);\n\tpath->nodes[level] = cur;\n\tpath->locks[level] = BTRFS_READ_LOCK;\n\n\tif (btrfs_header_generation(cur) < min_trans) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\twhile (1) {\n\t\tnritems = btrfs_header_nritems(cur);\n\t\tlevel = btrfs_header_level(cur);\n\t\tsret = bin_search(cur, min_key, level, &slot);\n\n\t\t/* at the lowest level, we're done, setup the path and exit */\n\t\tif (level == path->lowest_level) {\n\t\t\tif (slot >= nritems)\n\t\t\t\tgoto find_next_key;\n\t\t\tret = 0;\n\t\t\tpath->slots[level] = slot;\n\t\t\tbtrfs_item_key_to_cpu(cur, &found_key, slot);\n\t\t\tgoto out;\n\t\t}\n\t\tif (sret && slot > 0)\n\t\t\tslot--;\n\t\t/*\n\t\t * check this node pointer against the min_trans parameters.\n\t\t * If it is too old, old, skip to the next one.\n\t\t */\n\t\twhile (slot < nritems) {\n\t\t\tu64 gen;\n\n\t\t\tgen = btrfs_node_ptr_generation(cur, slot);\n\t\t\tif (gen < min_trans) {\n\t\t\t\tslot++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\nfind_next_key:\n\t\t/*\n\t\t * we didn't find a candidate key in this node, walk forward\n\t\t * and find another one\n\t\t */\n\t\tif (slot >= nritems) {\n\t\t\tpath->slots[level] = slot;\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tsret = btrfs_find_next_key(root, path, min_key, level,\n\t\t\t\t\t\t  min_trans);\n\t\t\tif (sret == 0) {\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tgoto again;\n\t\t\t} else {\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\t/* save our key for returning back */\n\t\tbtrfs_node_key_to_cpu(cur, &found_key, slot);\n\t\tpath->slots[level] = slot;\n\t\tif (level == path->lowest_level) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tbtrfs_set_path_blocking(path);\n\t\tcur = read_node_slot(root, cur, slot);\n\t\tBUG_ON(!cur); /* -ENOMEM */\n\n\t\tbtrfs_tree_read_lock(cur);\n\n\t\tpath->locks[level - 1] = BTRFS_READ_LOCK;\n\t\tpath->nodes[level - 1] = cur;\n\t\tunlock_up(path, level, 1, 0, NULL);\n\t\tbtrfs_clear_path_blocking(path, NULL, 0);\n\t}\nout:\n\tpath->keep_locks = keep_locks;\n\tif (ret == 0) {\n\t\tbtrfs_unlock_up_safe(path, path->lowest_level + 1);\n\t\tbtrfs_set_path_blocking(path);\n\t\tmemcpy(min_key, &found_key, sizeof(found_key));\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"BTRFS: could not find root %llu\\n\"",
            "sk->tree_id"
          ],
          "line": 2066
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "root"
          ],
          "line": 2065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_read_fs_root_no_name",
          "args": [
            "info",
            "&key"
          ],
          "line": 2064
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_read_fs_root_no_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.h",
          "lines": "76-81",
          "snippet": "static inline struct btrfs_root *\nbtrfs_read_fs_root_no_name(struct btrfs_fs_info *fs_info,\n\t\t\t   struct btrfs_key *location)\n{\n\treturn btrfs_get_fs_root(fs_info, location, true);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct btrfs_root *\nbtrfs_read_fs_root_no_name(struct btrfs_fs_info *fs_info,\n\t\t\t   struct btrfs_key *location)\n{\n\treturn btrfs_get_fs_root(fs_info, location, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 2059
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 2053
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic noinline int search_ioctl(struct inode *inode,\n\t\t\t\t struct btrfs_ioctl_search_key *sk,\n\t\t\t\t size_t *buf_size,\n\t\t\t\t char __user *ubuf)\n{\n\tstruct btrfs_root *root;\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\tstruct btrfs_fs_info *info = BTRFS_I(inode)->root->fs_info;\n\tint ret;\n\tint num_found = 0;\n\tunsigned long sk_offset = 0;\n\n\tif (*buf_size < sizeof(struct btrfs_ioctl_search_header)) {\n\t\t*buf_size = sizeof(struct btrfs_ioctl_search_header);\n\t\treturn -EOVERFLOW;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tif (sk->tree_id == 0) {\n\t\t/* search the root of the inode that was passed */\n\t\troot = BTRFS_I(inode)->root;\n\t} else {\n\t\tkey.objectid = sk->tree_id;\n\t\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\t\tkey.offset = (u64)-1;\n\t\troot = btrfs_read_fs_root_no_name(info, &key);\n\t\tif (IS_ERR(root)) {\n\t\t\tprintk(KERN_ERR \"BTRFS: could not find root %llu\\n\",\n\t\t\t       sk->tree_id);\n\t\t\tbtrfs_free_path(path);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\tkey.objectid = sk->min_objectid;\n\tkey.type = sk->min_type;\n\tkey.offset = sk->min_offset;\n\n\twhile (1) {\n\t\tret = btrfs_search_forward(root, &key, path, sk->min_transid);\n\t\tif (ret != 0) {\n\t\t\tif (ret > 0)\n\t\t\t\tret = 0;\n\t\t\tgoto err;\n\t\t}\n\t\tret = copy_to_sk(root, path, &key, sk, buf_size, ubuf,\n\t\t\t\t &sk_offset, &num_found);\n\t\tbtrfs_release_path(path);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t}\n\tif (ret > 0)\n\t\tret = 0;\nerr:\n\tsk->nr_items = num_found;\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "copy_to_sk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "1916-2033",
    "snippet": "static noinline int copy_to_sk(struct btrfs_root *root,\n\t\t\t       struct btrfs_path *path,\n\t\t\t       struct btrfs_key *key,\n\t\t\t       struct btrfs_ioctl_search_key *sk,\n\t\t\t       size_t *buf_size,\n\t\t\t       char __user *ubuf,\n\t\t\t       unsigned long *sk_offset,\n\t\t\t       int *num_found)\n{\n\tu64 found_transid;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_ioctl_search_header sh;\n\tunsigned long item_off;\n\tunsigned long item_len;\n\tint nritems;\n\tint i;\n\tint slot;\n\tint ret = 0;\n\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\tnritems = btrfs_header_nritems(leaf);\n\n\tif (btrfs_header_generation(leaf) > sk->max_transid) {\n\t\ti = nritems;\n\t\tgoto advance_key;\n\t}\n\tfound_transid = btrfs_header_generation(leaf);\n\n\tfor (i = slot; i < nritems; i++) {\n\t\titem_off = btrfs_item_ptr_offset(leaf, i);\n\t\titem_len = btrfs_item_size_nr(leaf, i);\n\n\t\tbtrfs_item_key_to_cpu(leaf, key, i);\n\t\tif (!key_in_sk(key, sk))\n\t\t\tcontinue;\n\n\t\tif (sizeof(sh) + item_len > *buf_size) {\n\t\t\tif (*num_found) {\n\t\t\t\tret = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * return one empty item back for v1, which does not\n\t\t\t * handle -EOVERFLOW\n\t\t\t */\n\n\t\t\t*buf_size = sizeof(sh) + item_len;\n\t\t\titem_len = 0;\n\t\t\tret = -EOVERFLOW;\n\t\t}\n\n\t\tif (sizeof(sh) + item_len + *sk_offset > *buf_size) {\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsh.objectid = key->objectid;\n\t\tsh.offset = key->offset;\n\t\tsh.type = key->type;\n\t\tsh.len = item_len;\n\t\tsh.transid = found_transid;\n\n\t\t/* copy search result header */\n\t\tif (copy_to_user(ubuf + *sk_offset, &sh, sizeof(sh))) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\t*sk_offset += sizeof(sh);\n\n\t\tif (item_len) {\n\t\t\tchar __user *up = ubuf + *sk_offset;\n\t\t\t/* copy the item */\n\t\t\tif (read_extent_buffer_to_user(leaf, up,\n\t\t\t\t\t\t       item_off, item_len)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t*sk_offset += item_len;\n\t\t}\n\t\t(*num_found)++;\n\n\t\tif (ret) /* -EOVERFLOW from above */\n\t\t\tgoto out;\n\n\t\tif (*num_found >= sk->nr_items) {\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\t}\nadvance_key:\n\tret = 0;\n\tif (key->offset < (u64)-1 && key->offset < sk->max_offset)\n\t\tkey->offset++;\n\telse if (key->type < (u8)-1 && key->type < sk->max_type) {\n\t\tkey->offset = 0;\n\t\tkey->type++;\n\t} else if (key->objectid < (u64)-1 && key->objectid < sk->max_objectid) {\n\t\tkey->offset = 0;\n\t\tkey->type = 0;\n\t\tkey->objectid++;\n\t} else\n\t\tret = 1;\nout:\n\t/*\n\t *  0: all items from this leaf copied, continue with next\n\t *  1: * more items can be copied, but unused buffer is too small\n\t *     * all items were found\n\t *     Either way, it will stops the loop which iterates to the next\n\t *     leaf\n\t *  -EOVERFLOW: item was to large for buffer\n\t *  -EFAULT: could not copy extent buffer back to userspace\n\t */\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_extent_buffer_to_user",
          "args": [
            "leaf",
            "up",
            "item_off",
            "item_len"
          ],
          "line": 1991
        },
        "resolved": true,
        "details": {
          "function_name": "read_extent_buffer_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5245-5280",
          "snippet": "int read_extent_buffer_to_user(struct extent_buffer *eb, void __user *dstv,\n\t\t\tunsigned long start,\n\t\t\tunsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar __user *dst = (char __user *)dstv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\tint ret = 0;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\n\t\tcur = min(len, (PAGE_CACHE_SIZE - offset));\n\t\tkaddr = page_address(page);\n\t\tif (copy_to_user(dst, kaddr + offset, cur)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tdst += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint read_extent_buffer_to_user(struct extent_buffer *eb, void __user *dstv,\n\t\t\tunsigned long start,\n\t\t\tunsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar __user *dst = (char __user *)dstv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\tint ret = 0;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\n\t\tcur = min(len, (PAGE_CACHE_SIZE - offset));\n\t\tkaddr = page_address(page);\n\t\tif (copy_to_user(dst, kaddr + offset, cur)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tdst += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "ubuf + *sk_offset",
            "&sh",
            "sizeof(sh)"
          ],
          "line": 1981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_in_sk",
          "args": [
            "key",
            "sk"
          ],
          "line": 1950
        },
        "resolved": true,
        "details": {
          "function_name": "key_in_sk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "1892-1914",
          "snippet": "static noinline int key_in_sk(struct btrfs_key *key,\n\t\t\t      struct btrfs_ioctl_search_key *sk)\n{\n\tstruct btrfs_key test;\n\tint ret;\n\n\ttest.objectid = sk->min_objectid;\n\ttest.type = sk->min_type;\n\ttest.offset = sk->min_offset;\n\n\tret = btrfs_comp_cpu_keys(key, &test);\n\tif (ret < 0)\n\t\treturn 0;\n\n\ttest.objectid = sk->max_objectid;\n\ttest.type = sk->max_type;\n\ttest.offset = sk->max_offset;\n\n\tret = btrfs_comp_cpu_keys(key, &test);\n\tif (ret > 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic noinline int key_in_sk(struct btrfs_key *key,\n\t\t\t      struct btrfs_ioctl_search_key *sk)\n{\n\tstruct btrfs_key test;\n\tint ret;\n\n\ttest.objectid = sk->min_objectid;\n\ttest.type = sk->min_type;\n\ttest.offset = sk->min_offset;\n\n\tret = btrfs_comp_cpu_keys(key, &test);\n\tif (ret < 0)\n\t\treturn 0;\n\n\ttest.objectid = sk->max_objectid;\n\ttest.type = sk->max_type;\n\ttest.offset = sk->max_offset;\n\n\tret = btrfs_comp_cpu_keys(key, &test);\n\tif (ret > 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "leaf",
            "key",
            "i"
          ],
          "line": 1949
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_size_nr",
          "args": [
            "leaf",
            "i"
          ],
          "line": 1947
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr_offset",
          "args": [
            "leaf",
            "i"
          ],
          "line": 1946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_generation",
          "args": [
            "leaf"
          ],
          "line": 1943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_generation",
          "args": [
            "leaf"
          ],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "leaf"
          ],
          "line": 1937
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic noinline int copy_to_sk(struct btrfs_root *root,\n\t\t\t       struct btrfs_path *path,\n\t\t\t       struct btrfs_key *key,\n\t\t\t       struct btrfs_ioctl_search_key *sk,\n\t\t\t       size_t *buf_size,\n\t\t\t       char __user *ubuf,\n\t\t\t       unsigned long *sk_offset,\n\t\t\t       int *num_found)\n{\n\tu64 found_transid;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_ioctl_search_header sh;\n\tunsigned long item_off;\n\tunsigned long item_len;\n\tint nritems;\n\tint i;\n\tint slot;\n\tint ret = 0;\n\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\tnritems = btrfs_header_nritems(leaf);\n\n\tif (btrfs_header_generation(leaf) > sk->max_transid) {\n\t\ti = nritems;\n\t\tgoto advance_key;\n\t}\n\tfound_transid = btrfs_header_generation(leaf);\n\n\tfor (i = slot; i < nritems; i++) {\n\t\titem_off = btrfs_item_ptr_offset(leaf, i);\n\t\titem_len = btrfs_item_size_nr(leaf, i);\n\n\t\tbtrfs_item_key_to_cpu(leaf, key, i);\n\t\tif (!key_in_sk(key, sk))\n\t\t\tcontinue;\n\n\t\tif (sizeof(sh) + item_len > *buf_size) {\n\t\t\tif (*num_found) {\n\t\t\t\tret = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * return one empty item back for v1, which does not\n\t\t\t * handle -EOVERFLOW\n\t\t\t */\n\n\t\t\t*buf_size = sizeof(sh) + item_len;\n\t\t\titem_len = 0;\n\t\t\tret = -EOVERFLOW;\n\t\t}\n\n\t\tif (sizeof(sh) + item_len + *sk_offset > *buf_size) {\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsh.objectid = key->objectid;\n\t\tsh.offset = key->offset;\n\t\tsh.type = key->type;\n\t\tsh.len = item_len;\n\t\tsh.transid = found_transid;\n\n\t\t/* copy search result header */\n\t\tif (copy_to_user(ubuf + *sk_offset, &sh, sizeof(sh))) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\t*sk_offset += sizeof(sh);\n\n\t\tif (item_len) {\n\t\t\tchar __user *up = ubuf + *sk_offset;\n\t\t\t/* copy the item */\n\t\t\tif (read_extent_buffer_to_user(leaf, up,\n\t\t\t\t\t\t       item_off, item_len)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t*sk_offset += item_len;\n\t\t}\n\t\t(*num_found)++;\n\n\t\tif (ret) /* -EOVERFLOW from above */\n\t\t\tgoto out;\n\n\t\tif (*num_found >= sk->nr_items) {\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\t}\nadvance_key:\n\tret = 0;\n\tif (key->offset < (u64)-1 && key->offset < sk->max_offset)\n\t\tkey->offset++;\n\telse if (key->type < (u8)-1 && key->type < sk->max_type) {\n\t\tkey->offset = 0;\n\t\tkey->type++;\n\t} else if (key->objectid < (u64)-1 && key->objectid < sk->max_objectid) {\n\t\tkey->offset = 0;\n\t\tkey->type = 0;\n\t\tkey->objectid++;\n\t} else\n\t\tret = 1;\nout:\n\t/*\n\t *  0: all items from this leaf copied, continue with next\n\t *  1: * more items can be copied, but unused buffer is too small\n\t *     * all items were found\n\t *     Either way, it will stops the loop which iterates to the next\n\t *     leaf\n\t *  -EOVERFLOW: item was to large for buffer\n\t *  -EFAULT: could not copy extent buffer back to userspace\n\t */\n\treturn ret;\n}"
  },
  {
    "function_name": "key_in_sk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "1892-1914",
    "snippet": "static noinline int key_in_sk(struct btrfs_key *key,\n\t\t\t      struct btrfs_ioctl_search_key *sk)\n{\n\tstruct btrfs_key test;\n\tint ret;\n\n\ttest.objectid = sk->min_objectid;\n\ttest.type = sk->min_type;\n\ttest.offset = sk->min_offset;\n\n\tret = btrfs_comp_cpu_keys(key, &test);\n\tif (ret < 0)\n\t\treturn 0;\n\n\ttest.objectid = sk->max_objectid;\n\ttest.type = sk->max_type;\n\ttest.offset = sk->max_offset;\n\n\tret = btrfs_comp_cpu_keys(key, &test);\n\tif (ret > 0)\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_comp_cpu_keys",
          "args": [
            "key",
            "&test"
          ],
          "line": 1910
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_comp_cpu_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1598-1613",
          "snippet": "int btrfs_comp_cpu_keys(struct btrfs_key *k1, struct btrfs_key *k2)\n{\n\tif (k1->objectid > k2->objectid)\n\t\treturn 1;\n\tif (k1->objectid < k2->objectid)\n\t\treturn -1;\n\tif (k1->type > k2->type)\n\t\treturn 1;\n\tif (k1->type < k2->type)\n\t\treturn -1;\n\tif (k1->offset > k2->offset)\n\t\treturn 1;\n\tif (k1->offset < k2->offset)\n\t\treturn -1;\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_comp_cpu_keys(struct btrfs_key *k1, struct btrfs_key *k2)\n{\n\tif (k1->objectid > k2->objectid)\n\t\treturn 1;\n\tif (k1->objectid < k2->objectid)\n\t\treturn -1;\n\tif (k1->type > k2->type)\n\t\treturn 1;\n\tif (k1->type < k2->type)\n\t\treturn -1;\n\tif (k1->offset > k2->offset)\n\t\treturn 1;\n\tif (k1->offset < k2->offset)\n\t\treturn -1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic noinline int key_in_sk(struct btrfs_key *key,\n\t\t\t      struct btrfs_ioctl_search_key *sk)\n{\n\tstruct btrfs_key test;\n\tint ret;\n\n\ttest.objectid = sk->min_objectid;\n\ttest.type = sk->min_type;\n\ttest.offset = sk->min_offset;\n\n\tret = btrfs_comp_cpu_keys(key, &test);\n\tif (ret < 0)\n\t\treturn 0;\n\n\ttest.objectid = sk->max_objectid;\n\ttest.type = sk->max_type;\n\ttest.offset = sk->max_offset;\n\n\tret = btrfs_comp_cpu_keys(key, &test);\n\tif (ret > 0)\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "may_destroy_subvol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "1842-1890",
    "snippet": "static noinline int may_destroy_subvol(struct btrfs_root *root)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_key key;\n\tu64 dir_id;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\t/* Make sure this root isn't set as the default subvol */\n\tdir_id = btrfs_super_root_dir(root->fs_info->super_copy);\n\tdi = btrfs_lookup_dir_item(NULL, root->fs_info->tree_root, path,\n\t\t\t\t   dir_id, \"default\", 7, 0);\n\tif (di && !IS_ERR(di)) {\n\t\tbtrfs_dir_item_key_to_cpu(path->nodes[0], di, &key);\n\t\tif (key.objectid == root->root_key.objectid) {\n\t\t\tret = -EPERM;\n\t\t\tbtrfs_err(root->fs_info, \"deleting default subvolume \"\n\t\t\t\t  \"%llu is not allowed\", key.objectid);\n\t\t\tgoto out;\n\t\t}\n\t\tbtrfs_release_path(path);\n\t}\n\n\tkey.objectid = root->root_key.objectid;\n\tkey.type = BTRFS_ROOT_REF_KEY;\n\tkey.offset = (u64)-1;\n\n\tret = btrfs_search_slot(NULL, root->fs_info->tree_root,\n\t\t\t\t&key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tBUG_ON(ret == 0);\n\n\tret = 0;\n\tif (path->slots[0] > 0) {\n\t\tpath->slots[0]--;\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\n\t\tif (key.objectid == root->root_key.objectid &&\n\t\t    key.type == BTRFS_ROOT_REF_KEY)\n\t\t\tret = -ENOTEMPTY;\n\t}\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 1888
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "path->nodes[0]",
            "&key",
            "path->slots[0]"
          ],
          "line": 1882
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret == 0"
          ],
          "line": 1877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "root->fs_info->tree_root",
            "&key",
            "path",
            "0",
            "0"
          ],
          "line": 1873
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 1866
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "root->fs_info",
            "\"deleting default subvolume \"\n\t\t\t\t  \"%llu is not allowed\"",
            "key.objectid"
          ],
          "line": 1862
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_error_unpin_extent_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "9705-9708",
          "snippet": "int btrfs_error_unpin_extent_range(struct btrfs_root *root, u64 start, u64 end)\n{\n\treturn unpin_extent_range(root, start, end, false);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_error_unpin_extent_range(struct btrfs_root *root, u64 start, u64 end)\n{\n\treturn unpin_extent_range(root, start, end, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dir_item_key_to_cpu",
          "args": [
            "path->nodes[0]",
            "di",
            "&key"
          ],
          "line": 1859
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dir_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2763-2770",
          "snippet": "static inline void btrfs_dir_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t      struct btrfs_dir_item *item,\n\t\t\t\t      struct btrfs_key *key)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_dir_item_key(eb, item, &disk_key);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_dir_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t      struct btrfs_dir_item *item,\n\t\t\t\t      struct btrfs_key *key)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_dir_item_key(eb, item, &disk_key);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "di"
          ],
          "line": 1858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_dir_item",
          "args": [
            "NULL",
            "root->fs_info->tree_root",
            "path",
            "dir_id",
            "\"default\"",
            "7",
            "0"
          ],
          "line": 1856
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_dir_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dir-item.c",
          "lines": "191-214",
          "snippet": "struct btrfs_dir_item *btrfs_lookup_dir_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t\t     struct btrfs_path *path, u64 dir,\n\t\t\t\t\t     const char *name, int name_len,\n\t\t\t\t\t     int mod)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_ITEM_KEY;\n\n\tkey.offset = btrfs_name_hash(name, name_len);\n\n\tret = btrfs_search_slot(trans, root, &key, path, ins_len, cow);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tif (ret > 0)\n\t\treturn NULL;\n\n\treturn btrfs_match_dir_item_name(root, path, name, name_len);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n\nstruct btrfs_dir_item *btrfs_lookup_dir_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t\t     struct btrfs_path *path, u64 dir,\n\t\t\t\t\t     const char *name, int name_len,\n\t\t\t\t\t     int mod)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_ITEM_KEY;\n\n\tkey.offset = btrfs_name_hash(name, name_len);\n\n\tret = btrfs_search_slot(trans, root, &key, path, ins_len, cow);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tif (ret > 0)\n\t\treturn NULL;\n\n\treturn btrfs_match_dir_item_name(root, path, name, name_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_super_root_dir",
          "args": [
            "root->fs_info->super_copy"
          ],
          "line": 1855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 1850
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic noinline int may_destroy_subvol(struct btrfs_root *root)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_key key;\n\tu64 dir_id;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\t/* Make sure this root isn't set as the default subvol */\n\tdir_id = btrfs_super_root_dir(root->fs_info->super_copy);\n\tdi = btrfs_lookup_dir_item(NULL, root->fs_info->tree_root, path,\n\t\t\t\t   dir_id, \"default\", 7, 0);\n\tif (di && !IS_ERR(di)) {\n\t\tbtrfs_dir_item_key_to_cpu(path->nodes[0], di, &key);\n\t\tif (key.objectid == root->root_key.objectid) {\n\t\t\tret = -EPERM;\n\t\t\tbtrfs_err(root->fs_info, \"deleting default subvolume \"\n\t\t\t\t  \"%llu is not allowed\", key.objectid);\n\t\t\tgoto out;\n\t\t}\n\t\tbtrfs_release_path(path);\n\t}\n\n\tkey.objectid = root->root_key.objectid;\n\tkey.type = BTRFS_ROOT_REF_KEY;\n\tkey.offset = (u64)-1;\n\n\tret = btrfs_search_slot(NULL, root->fs_info->tree_root,\n\t\t\t\t&key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tBUG_ON(ret == 0);\n\n\tret = 0;\n\tif (path->slots[0] > 0) {\n\t\tpath->slots[0]--;\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\n\t\tif (key.objectid == root->root_key.objectid &&\n\t\t    key.type == BTRFS_ROOT_REF_KEY)\n\t\t\tret = -ENOTEMPTY;\n\t}\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_ioctl_subvol_setflags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "1751-1837",
    "snippet": "static noinline int btrfs_ioctl_subvol_setflags(struct file *file,\n\t\t\t\t\t      void __user *arg)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_trans_handle *trans;\n\tu64 root_flags;\n\tu64 flags;\n\tint ret = 0;\n\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\tgoto out;\n\n\tif (btrfs_ino(inode) != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tret = -EINVAL;\n\t\tgoto out_drop_write;\n\t}\n\n\tif (copy_from_user(&flags, arg, sizeof(flags))) {\n\t\tret = -EFAULT;\n\t\tgoto out_drop_write;\n\t}\n\n\tif (flags & BTRFS_SUBVOL_CREATE_ASYNC) {\n\t\tret = -EINVAL;\n\t\tgoto out_drop_write;\n\t}\n\n\tif (flags & ~BTRFS_SUBVOL_RDONLY) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out_drop_write;\n\t}\n\n\tdown_write(&root->fs_info->subvol_sem);\n\n\t/* nothing to do */\n\tif (!!(flags & BTRFS_SUBVOL_RDONLY) == btrfs_root_readonly(root))\n\t\tgoto out_drop_sem;\n\n\troot_flags = btrfs_root_flags(&root->root_item);\n\tif (flags & BTRFS_SUBVOL_RDONLY) {\n\t\tbtrfs_set_root_flags(&root->root_item,\n\t\t\t\t     root_flags | BTRFS_ROOT_SUBVOL_RDONLY);\n\t} else {\n\t\t/*\n\t\t * Block RO -> RW transition if this subvolume is involved in\n\t\t * send\n\t\t */\n\t\tspin_lock(&root->root_item_lock);\n\t\tif (root->send_in_progress == 0) {\n\t\t\tbtrfs_set_root_flags(&root->root_item,\n\t\t\t\t     root_flags & ~BTRFS_ROOT_SUBVOL_RDONLY);\n\t\t\tspin_unlock(&root->root_item_lock);\n\t\t} else {\n\t\t\tspin_unlock(&root->root_item_lock);\n\t\t\tbtrfs_warn(root->fs_info,\n\t\t\t\"Attempt to set subvolume %llu read-write during send\",\n\t\t\t\t\troot->root_key.objectid);\n\t\t\tret = -EPERM;\n\t\t\tgoto out_drop_sem;\n\t\t}\n\t}\n\n\ttrans = btrfs_start_transaction(root, 1);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out_reset;\n\t}\n\n\tret = btrfs_update_root(trans, root->fs_info->tree_root,\n\t\t\t\t&root->root_key, &root->root_item);\n\n\tbtrfs_commit_transaction(trans, root);\nout_reset:\n\tif (ret)\n\t\tbtrfs_set_root_flags(&root->root_item, root_flags);\nout_drop_sem:\n\tup_write(&root->fs_info->subvol_sem);\nout_drop_write:\n\tmnt_drop_write_file(file);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "file"
          ],
          "line": 1834
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&root->fs_info->subvol_sem"
          ],
          "line": 1832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_flags",
          "args": [
            "&root->root_item",
            "root_flags"
          ],
          "line": 1830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_commit_transaction",
          "args": [
            "trans",
            "root"
          ],
          "line": 1827
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_commit_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "1764-2099",
          "snippet": "int btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_update_root",
          "args": [
            "trans",
            "root->fs_info->tree_root",
            "&root->root_key",
            "&root->root_item"
          ],
          "line": 1824
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_update_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/root-tree.c",
          "lines": "135-210",
          "snippet": "int btrfs_update_root(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_root_item\n\t\t      *item)\n{\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *l;\n\tint ret;\n\tint slot;\n\tunsigned long ptr;\n\tint old_len;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_search_slot(trans, root, key, path, 0, 1);\n\tif (ret < 0) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto out;\n\t}\n\n\tif (ret != 0) {\n\t\tbtrfs_print_leaf(root, path->nodes[0]);\n\t\tbtrfs_crit(root->fs_info, \"unable to update root key %llu %u %llu\",\n\t\t       key->objectid, key->type, key->offset);\n\t\tBUG_ON(1);\n\t}\n\n\tl = path->nodes[0];\n\tslot = path->slots[0];\n\tptr = btrfs_item_ptr_offset(l, slot);\n\told_len = btrfs_item_size_nr(l, slot);\n\n\t/*\n\t * If this is the first time we update the root item which originated\n\t * from an older kernel, we need to enlarge the item size to make room\n\t * for the added fields.\n\t */\n\tif (old_len < sizeof(*item)) {\n\t\tbtrfs_release_path(path);\n\t\tret = btrfs_search_slot(trans, root, key, path,\n\t\t\t\t-1, 1);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = btrfs_del_item(trans, root, path);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\t\tbtrfs_release_path(path);\n\t\tret = btrfs_insert_empty_item(trans, root, path,\n\t\t\t\tkey, sizeof(*item));\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\t\tl = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tptr = btrfs_item_ptr_offset(l, slot);\n\t}\n\n\t/*\n\t * Update generation_v2 so at the next mount we know the new root\n\t * fields are valid.\n\t */\n\tbtrfs_set_root_generation_v2(item, btrfs_root_generation(item));\n\n\twrite_extent_buffer(l, item, ptr, sizeof(*item));\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/err.h>\n\nint btrfs_update_root(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_root_item\n\t\t      *item)\n{\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *l;\n\tint ret;\n\tint slot;\n\tunsigned long ptr;\n\tint old_len;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_search_slot(trans, root, key, path, 0, 1);\n\tif (ret < 0) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto out;\n\t}\n\n\tif (ret != 0) {\n\t\tbtrfs_print_leaf(root, path->nodes[0]);\n\t\tbtrfs_crit(root->fs_info, \"unable to update root key %llu %u %llu\",\n\t\t       key->objectid, key->type, key->offset);\n\t\tBUG_ON(1);\n\t}\n\n\tl = path->nodes[0];\n\tslot = path->slots[0];\n\tptr = btrfs_item_ptr_offset(l, slot);\n\told_len = btrfs_item_size_nr(l, slot);\n\n\t/*\n\t * If this is the first time we update the root item which originated\n\t * from an older kernel, we need to enlarge the item size to make room\n\t * for the added fields.\n\t */\n\tif (old_len < sizeof(*item)) {\n\t\tbtrfs_release_path(path);\n\t\tret = btrfs_search_slot(trans, root, key, path,\n\t\t\t\t-1, 1);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = btrfs_del_item(trans, root, path);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\t\tbtrfs_release_path(path);\n\t\tret = btrfs_insert_empty_item(trans, root, path,\n\t\t\t\tkey, sizeof(*item));\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\t\tl = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tptr = btrfs_item_ptr_offset(l, slot);\n\t}\n\n\t/*\n\t * Update generation_v2 so at the next mount we know the new root\n\t * fields are valid.\n\t */\n\tbtrfs_set_root_generation_v2(item, btrfs_root_generation(item));\n\n\twrite_extent_buffer(l, item, ptr, sizeof(*item));\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 1819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_start_transaction",
          "args": [
            "root",
            "1"
          ],
          "line": 1818
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_transaction_lflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "569-574",
          "snippet": "struct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_warn",
          "args": [
            "root->fs_info",
            "\"Attempt to set subvolume %llu read-write during send\"",
            "root->root_key.objectid"
          ],
          "line": 1810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&root->root_item_lock"
          ],
          "line": 1809
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_flags",
          "args": [
            "&root->root_item",
            "root_flags & ~BTRFS_ROOT_SUBVOL_RDONLY"
          ],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&root->root_item_lock"
          ],
          "line": 1803
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_flags",
          "args": [
            "&root->root_item",
            "root_flags | BTRFS_ROOT_SUBVOL_RDONLY"
          ],
          "line": 1796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_root_flags",
          "args": [
            "&root->root_item"
          ],
          "line": 1794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_root_readonly",
          "args": [
            "root"
          ],
          "line": 1791
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_root_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2876-2879",
          "snippet": "static inline bool btrfs_root_readonly(struct btrfs_root *root)\n{\n\treturn (root->root_item.flags & cpu_to_le64(BTRFS_ROOT_SUBVOL_RDONLY)) != 0;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_ROOT_SUBVOL_RDONLY\t(1ULL << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_ROOT_SUBVOL_RDONLY\t(1ULL << 0)\n\nstatic inline bool btrfs_root_readonly(struct btrfs_root *root)\n{\n\treturn (root->root_item.flags & cpu_to_le64(BTRFS_ROOT_SUBVOL_RDONLY)) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&root->fs_info->subvol_sem"
          ],
          "line": 1788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&flags",
            "arg",
            "sizeof(flags)"
          ],
          "line": 1773
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ino",
          "args": [
            "inode"
          ],
          "line": 1768
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_resume_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "311-316",
          "snippet": "static inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [
            "#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\n#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10\n\nstatic inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "file"
          ],
          "line": 1764
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_owner_or_capable",
          "args": [
            "inode"
          ],
          "line": 1761
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 1755
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1754
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic noinline int btrfs_ioctl_subvol_setflags(struct file *file,\n\t\t\t\t\t      void __user *arg)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_trans_handle *trans;\n\tu64 root_flags;\n\tu64 flags;\n\tint ret = 0;\n\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\tgoto out;\n\n\tif (btrfs_ino(inode) != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tret = -EINVAL;\n\t\tgoto out_drop_write;\n\t}\n\n\tif (copy_from_user(&flags, arg, sizeof(flags))) {\n\t\tret = -EFAULT;\n\t\tgoto out_drop_write;\n\t}\n\n\tif (flags & BTRFS_SUBVOL_CREATE_ASYNC) {\n\t\tret = -EINVAL;\n\t\tgoto out_drop_write;\n\t}\n\n\tif (flags & ~BTRFS_SUBVOL_RDONLY) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out_drop_write;\n\t}\n\n\tdown_write(&root->fs_info->subvol_sem);\n\n\t/* nothing to do */\n\tif (!!(flags & BTRFS_SUBVOL_RDONLY) == btrfs_root_readonly(root))\n\t\tgoto out_drop_sem;\n\n\troot_flags = btrfs_root_flags(&root->root_item);\n\tif (flags & BTRFS_SUBVOL_RDONLY) {\n\t\tbtrfs_set_root_flags(&root->root_item,\n\t\t\t\t     root_flags | BTRFS_ROOT_SUBVOL_RDONLY);\n\t} else {\n\t\t/*\n\t\t * Block RO -> RW transition if this subvolume is involved in\n\t\t * send\n\t\t */\n\t\tspin_lock(&root->root_item_lock);\n\t\tif (root->send_in_progress == 0) {\n\t\t\tbtrfs_set_root_flags(&root->root_item,\n\t\t\t\t     root_flags & ~BTRFS_ROOT_SUBVOL_RDONLY);\n\t\t\tspin_unlock(&root->root_item_lock);\n\t\t} else {\n\t\t\tspin_unlock(&root->root_item_lock);\n\t\t\tbtrfs_warn(root->fs_info,\n\t\t\t\"Attempt to set subvolume %llu read-write during send\",\n\t\t\t\t\troot->root_key.objectid);\n\t\t\tret = -EPERM;\n\t\t\tgoto out_drop_sem;\n\t\t}\n\t}\n\n\ttrans = btrfs_start_transaction(root, 1);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out_reset;\n\t}\n\n\tret = btrfs_update_root(trans, root->fs_info->tree_root,\n\t\t\t\t&root->root_key, &root->root_item);\n\n\tbtrfs_commit_transaction(trans, root);\nout_reset:\n\tif (ret)\n\t\tbtrfs_set_root_flags(&root->root_item, root_flags);\nout_drop_sem:\n\tup_write(&root->fs_info->subvol_sem);\nout_drop_write:\n\tmnt_drop_write_file(file);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_ioctl_subvol_getflags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "1729-1749",
    "snippet": "static noinline int btrfs_ioctl_subvol_getflags(struct file *file,\n\t\t\t\t\t\tvoid __user *arg)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tint ret = 0;\n\tu64 flags = 0;\n\n\tif (btrfs_ino(inode) != BTRFS_FIRST_FREE_OBJECTID)\n\t\treturn -EINVAL;\n\n\tdown_read(&root->fs_info->subvol_sem);\n\tif (btrfs_root_readonly(root))\n\t\tflags |= BTRFS_SUBVOL_RDONLY;\n\tup_read(&root->fs_info->subvol_sem);\n\n\tif (copy_to_user(arg, &flags, sizeof(flags)))\n\t\tret = -EFAULT;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "arg",
            "&flags",
            "sizeof(flags)"
          ],
          "line": 1745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&root->fs_info->subvol_sem"
          ],
          "line": 1743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_root_readonly",
          "args": [
            "root"
          ],
          "line": 1741
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_root_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2876-2879",
          "snippet": "static inline bool btrfs_root_readonly(struct btrfs_root *root)\n{\n\treturn (root->root_item.flags & cpu_to_le64(BTRFS_ROOT_SUBVOL_RDONLY)) != 0;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_ROOT_SUBVOL_RDONLY\t(1ULL << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_ROOT_SUBVOL_RDONLY\t(1ULL << 0)\n\nstatic inline bool btrfs_root_readonly(struct btrfs_root *root)\n{\n\treturn (root->root_item.flags & cpu_to_le64(BTRFS_ROOT_SUBVOL_RDONLY)) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&root->fs_info->subvol_sem"
          ],
          "line": 1740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_ino",
          "args": [
            "inode"
          ],
          "line": 1737
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_resume_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "311-316",
          "snippet": "static inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [
            "#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\n#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10\n\nstatic inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 1733
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1732
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic noinline int btrfs_ioctl_subvol_getflags(struct file *file,\n\t\t\t\t\t\tvoid __user *arg)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tint ret = 0;\n\tu64 flags = 0;\n\n\tif (btrfs_ino(inode) != BTRFS_FIRST_FREE_OBJECTID)\n\t\treturn -EINVAL;\n\n\tdown_read(&root->fs_info->subvol_sem);\n\tif (btrfs_root_readonly(root))\n\t\tflags |= BTRFS_SUBVOL_RDONLY;\n\tup_read(&root->fs_info->subvol_sem);\n\n\tif (copy_to_user(arg, &flags, sizeof(flags)))\n\t\tret = -EFAULT;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_ioctl_snap_create_v2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "1672-1727",
    "snippet": "static noinline int btrfs_ioctl_snap_create_v2(struct file *file,\n\t\t\t\t\t       void __user *arg, int subvol)\n{\n\tstruct btrfs_ioctl_vol_args_v2 *vol_args;\n\tint ret;\n\tu64 transid = 0;\n\tu64 *ptr = NULL;\n\tbool readonly = false;\n\tstruct btrfs_qgroup_inherit *inherit = NULL;\n\n\tvol_args = memdup_user(arg, sizeof(*vol_args));\n\tif (IS_ERR(vol_args))\n\t\treturn PTR_ERR(vol_args);\n\tvol_args->name[BTRFS_SUBVOL_NAME_MAX] = '\\0';\n\n\tif (vol_args->flags &\n\t    ~(BTRFS_SUBVOL_CREATE_ASYNC | BTRFS_SUBVOL_RDONLY |\n\t      BTRFS_SUBVOL_QGROUP_INHERIT)) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto free_args;\n\t}\n\n\tif (vol_args->flags & BTRFS_SUBVOL_CREATE_ASYNC)\n\t\tptr = &transid;\n\tif (vol_args->flags & BTRFS_SUBVOL_RDONLY)\n\t\treadonly = true;\n\tif (vol_args->flags & BTRFS_SUBVOL_QGROUP_INHERIT) {\n\t\tif (vol_args->size > PAGE_CACHE_SIZE) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto free_args;\n\t\t}\n\t\tinherit = memdup_user(vol_args->qgroup_inherit, vol_args->size);\n\t\tif (IS_ERR(inherit)) {\n\t\t\tret = PTR_ERR(inherit);\n\t\t\tgoto free_args;\n\t\t}\n\t}\n\n\tret = btrfs_ioctl_snap_create_transid(file, vol_args->name,\n\t\t\t\t\t      vol_args->fd, subvol, ptr,\n\t\t\t\t\t      readonly, inherit);\n\tif (ret)\n\t\tgoto free_inherit;\n\n\tif (ptr && copy_to_user(arg +\n\t\t\t\toffsetof(struct btrfs_ioctl_vol_args_v2,\n\t\t\t\t\ttransid),\n\t\t\t\tptr, sizeof(*ptr)))\n\t\tret = -EFAULT;\n\nfree_inherit:\n\tkfree(inherit);\nfree_args:\n\tkfree(vol_args);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "vol_args"
          ],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "inherit"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "arg +\n\t\t\t\toffsetof(struct btrfs_ioctl_vol_args_v2,\n\t\t\t\t\ttransid)",
            "ptr",
            "sizeof(*ptr)"
          ],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_snap_create_transid",
          "args": [
            "file",
            "vol_args->name",
            "vol_args->fd",
            "subvol",
            "ptr",
            "readonly",
            "inherit"
          ],
          "line": 1710
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_snap_create_transid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "1594-1651",
          "snippet": "static noinline int btrfs_ioctl_snap_create_transid(struct file *file,\n\t\t\t\tchar *name, unsigned long fd, int subvol,\n\t\t\t\tu64 *transid, bool readonly,\n\t\t\t\tstruct btrfs_qgroup_inherit *inherit)\n{\n\tint namelen;\n\tint ret = 0;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\tgoto out;\n\n\tnamelen = strlen(name);\n\tif (strchr(name, '/')) {\n\t\tret = -EINVAL;\n\t\tgoto out_drop_write;\n\t}\n\n\tif (name[0] == '.' &&\n\t   (namelen == 1 || (name[1] == '.' && namelen == 2))) {\n\t\tret = -EEXIST;\n\t\tgoto out_drop_write;\n\t}\n\n\tif (subvol) {\n\t\tret = btrfs_mksubvol(&file->f_path, name, namelen,\n\t\t\t\t     NULL, transid, readonly, inherit);\n\t} else {\n\t\tstruct fd src = fdget(fd);\n\t\tstruct inode *src_inode;\n\t\tif (!src.file) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_drop_write;\n\t\t}\n\n\t\tsrc_inode = file_inode(src.file);\n\t\tif (src_inode->i_sb != file_inode(file)->i_sb) {\n\t\t\tbtrfs_info(BTRFS_I(src_inode)->root->fs_info,\n\t\t\t\t   \"Snapshot src from another FS\");\n\t\t\tret = -EXDEV;\n\t\t} else if (!inode_owner_or_capable(src_inode)) {\n\t\t\t/*\n\t\t\t * Subvolume creation is not restricted, but snapshots\n\t\t\t * are limited to own subvolumes only\n\t\t\t */\n\t\t\tret = -EPERM;\n\t\t} else {\n\t\t\tret = btrfs_mksubvol(&file->f_path, name, namelen,\n\t\t\t\t\t     BTRFS_I(src_inode)->root,\n\t\t\t\t\t     transid, readonly, inherit);\n\t\t}\n\t\tfdput(src);\n\t}\nout_drop_write:\n\tmnt_drop_write_file(file);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic noinline int btrfs_ioctl_snap_create_transid(struct file *file,\n\t\t\t\tchar *name, unsigned long fd, int subvol,\n\t\t\t\tu64 *transid, bool readonly,\n\t\t\t\tstruct btrfs_qgroup_inherit *inherit)\n{\n\tint namelen;\n\tint ret = 0;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\tgoto out;\n\n\tnamelen = strlen(name);\n\tif (strchr(name, '/')) {\n\t\tret = -EINVAL;\n\t\tgoto out_drop_write;\n\t}\n\n\tif (name[0] == '.' &&\n\t   (namelen == 1 || (name[1] == '.' && namelen == 2))) {\n\t\tret = -EEXIST;\n\t\tgoto out_drop_write;\n\t}\n\n\tif (subvol) {\n\t\tret = btrfs_mksubvol(&file->f_path, name, namelen,\n\t\t\t\t     NULL, transid, readonly, inherit);\n\t} else {\n\t\tstruct fd src = fdget(fd);\n\t\tstruct inode *src_inode;\n\t\tif (!src.file) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_drop_write;\n\t\t}\n\n\t\tsrc_inode = file_inode(src.file);\n\t\tif (src_inode->i_sb != file_inode(file)->i_sb) {\n\t\t\tbtrfs_info(BTRFS_I(src_inode)->root->fs_info,\n\t\t\t\t   \"Snapshot src from another FS\");\n\t\t\tret = -EXDEV;\n\t\t} else if (!inode_owner_or_capable(src_inode)) {\n\t\t\t/*\n\t\t\t * Subvolume creation is not restricted, but snapshots\n\t\t\t * are limited to own subvolumes only\n\t\t\t */\n\t\t\tret = -EPERM;\n\t\t} else {\n\t\t\tret = btrfs_mksubvol(&file->f_path, name, namelen,\n\t\t\t\t\t     BTRFS_I(src_inode)->root,\n\t\t\t\t\t     transid, readonly, inherit);\n\t\t}\n\t\tfdput(src);\n\t}\nout_drop_write:\n\tmnt_drop_write_file(file);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inherit"
          ],
          "line": 1705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inherit"
          ],
          "line": 1704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user",
          "args": [
            "vol_args->qgroup_inherit",
            "vol_args->size"
          ],
          "line": 1703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "vol_args"
          ],
          "line": 1684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "vol_args"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user",
          "args": [
            "arg",
            "sizeof(*vol_args)"
          ],
          "line": 1682
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic noinline int btrfs_ioctl_snap_create_v2(struct file *file,\n\t\t\t\t\t       void __user *arg, int subvol)\n{\n\tstruct btrfs_ioctl_vol_args_v2 *vol_args;\n\tint ret;\n\tu64 transid = 0;\n\tu64 *ptr = NULL;\n\tbool readonly = false;\n\tstruct btrfs_qgroup_inherit *inherit = NULL;\n\n\tvol_args = memdup_user(arg, sizeof(*vol_args));\n\tif (IS_ERR(vol_args))\n\t\treturn PTR_ERR(vol_args);\n\tvol_args->name[BTRFS_SUBVOL_NAME_MAX] = '\\0';\n\n\tif (vol_args->flags &\n\t    ~(BTRFS_SUBVOL_CREATE_ASYNC | BTRFS_SUBVOL_RDONLY |\n\t      BTRFS_SUBVOL_QGROUP_INHERIT)) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto free_args;\n\t}\n\n\tif (vol_args->flags & BTRFS_SUBVOL_CREATE_ASYNC)\n\t\tptr = &transid;\n\tif (vol_args->flags & BTRFS_SUBVOL_RDONLY)\n\t\treadonly = true;\n\tif (vol_args->flags & BTRFS_SUBVOL_QGROUP_INHERIT) {\n\t\tif (vol_args->size > PAGE_CACHE_SIZE) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto free_args;\n\t\t}\n\t\tinherit = memdup_user(vol_args->qgroup_inherit, vol_args->size);\n\t\tif (IS_ERR(inherit)) {\n\t\t\tret = PTR_ERR(inherit);\n\t\t\tgoto free_args;\n\t\t}\n\t}\n\n\tret = btrfs_ioctl_snap_create_transid(file, vol_args->name,\n\t\t\t\t\t      vol_args->fd, subvol, ptr,\n\t\t\t\t\t      readonly, inherit);\n\tif (ret)\n\t\tgoto free_inherit;\n\n\tif (ptr && copy_to_user(arg +\n\t\t\t\toffsetof(struct btrfs_ioctl_vol_args_v2,\n\t\t\t\t\ttransid),\n\t\t\t\tptr, sizeof(*ptr)))\n\t\tret = -EFAULT;\n\nfree_inherit:\n\tkfree(inherit);\nfree_args:\n\tkfree(vol_args);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_ioctl_snap_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "1653-1670",
    "snippet": "static noinline int btrfs_ioctl_snap_create(struct file *file,\n\t\t\t\t\t    void __user *arg, int subvol)\n{\n\tstruct btrfs_ioctl_vol_args *vol_args;\n\tint ret;\n\n\tvol_args = memdup_user(arg, sizeof(*vol_args));\n\tif (IS_ERR(vol_args))\n\t\treturn PTR_ERR(vol_args);\n\tvol_args->name[BTRFS_PATH_NAME_MAX] = '\\0';\n\n\tret = btrfs_ioctl_snap_create_transid(file, vol_args->name,\n\t\t\t\t\t      vol_args->fd, subvol,\n\t\t\t\t\t      NULL, false, NULL);\n\n\tkfree(vol_args);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "vol_args"
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_ioctl_snap_create_transid",
          "args": [
            "file",
            "vol_args->name",
            "vol_args->fd",
            "subvol",
            "NULL",
            "false",
            "NULL"
          ],
          "line": 1664
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ioctl_snap_create_transid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "1594-1651",
          "snippet": "static noinline int btrfs_ioctl_snap_create_transid(struct file *file,\n\t\t\t\tchar *name, unsigned long fd, int subvol,\n\t\t\t\tu64 *transid, bool readonly,\n\t\t\t\tstruct btrfs_qgroup_inherit *inherit)\n{\n\tint namelen;\n\tint ret = 0;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\tgoto out;\n\n\tnamelen = strlen(name);\n\tif (strchr(name, '/')) {\n\t\tret = -EINVAL;\n\t\tgoto out_drop_write;\n\t}\n\n\tif (name[0] == '.' &&\n\t   (namelen == 1 || (name[1] == '.' && namelen == 2))) {\n\t\tret = -EEXIST;\n\t\tgoto out_drop_write;\n\t}\n\n\tif (subvol) {\n\t\tret = btrfs_mksubvol(&file->f_path, name, namelen,\n\t\t\t\t     NULL, transid, readonly, inherit);\n\t} else {\n\t\tstruct fd src = fdget(fd);\n\t\tstruct inode *src_inode;\n\t\tif (!src.file) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_drop_write;\n\t\t}\n\n\t\tsrc_inode = file_inode(src.file);\n\t\tif (src_inode->i_sb != file_inode(file)->i_sb) {\n\t\t\tbtrfs_info(BTRFS_I(src_inode)->root->fs_info,\n\t\t\t\t   \"Snapshot src from another FS\");\n\t\t\tret = -EXDEV;\n\t\t} else if (!inode_owner_or_capable(src_inode)) {\n\t\t\t/*\n\t\t\t * Subvolume creation is not restricted, but snapshots\n\t\t\t * are limited to own subvolumes only\n\t\t\t */\n\t\t\tret = -EPERM;\n\t\t} else {\n\t\t\tret = btrfs_mksubvol(&file->f_path, name, namelen,\n\t\t\t\t\t     BTRFS_I(src_inode)->root,\n\t\t\t\t\t     transid, readonly, inherit);\n\t\t}\n\t\tfdput(src);\n\t}\nout_drop_write:\n\tmnt_drop_write_file(file);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic noinline int btrfs_ioctl_snap_create_transid(struct file *file,\n\t\t\t\tchar *name, unsigned long fd, int subvol,\n\t\t\t\tu64 *transid, bool readonly,\n\t\t\t\tstruct btrfs_qgroup_inherit *inherit)\n{\n\tint namelen;\n\tint ret = 0;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\tgoto out;\n\n\tnamelen = strlen(name);\n\tif (strchr(name, '/')) {\n\t\tret = -EINVAL;\n\t\tgoto out_drop_write;\n\t}\n\n\tif (name[0] == '.' &&\n\t   (namelen == 1 || (name[1] == '.' && namelen == 2))) {\n\t\tret = -EEXIST;\n\t\tgoto out_drop_write;\n\t}\n\n\tif (subvol) {\n\t\tret = btrfs_mksubvol(&file->f_path, name, namelen,\n\t\t\t\t     NULL, transid, readonly, inherit);\n\t} else {\n\t\tstruct fd src = fdget(fd);\n\t\tstruct inode *src_inode;\n\t\tif (!src.file) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_drop_write;\n\t\t}\n\n\t\tsrc_inode = file_inode(src.file);\n\t\tif (src_inode->i_sb != file_inode(file)->i_sb) {\n\t\t\tbtrfs_info(BTRFS_I(src_inode)->root->fs_info,\n\t\t\t\t   \"Snapshot src from another FS\");\n\t\t\tret = -EXDEV;\n\t\t} else if (!inode_owner_or_capable(src_inode)) {\n\t\t\t/*\n\t\t\t * Subvolume creation is not restricted, but snapshots\n\t\t\t * are limited to own subvolumes only\n\t\t\t */\n\t\t\tret = -EPERM;\n\t\t} else {\n\t\t\tret = btrfs_mksubvol(&file->f_path, name, namelen,\n\t\t\t\t\t     BTRFS_I(src_inode)->root,\n\t\t\t\t\t     transid, readonly, inherit);\n\t\t}\n\t\tfdput(src);\n\t}\nout_drop_write:\n\tmnt_drop_write_file(file);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "vol_args"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "vol_args"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user",
          "args": [
            "arg",
            "sizeof(*vol_args)"
          ],
          "line": 1659
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic noinline int btrfs_ioctl_snap_create(struct file *file,\n\t\t\t\t\t    void __user *arg, int subvol)\n{\n\tstruct btrfs_ioctl_vol_args *vol_args;\n\tint ret;\n\n\tvol_args = memdup_user(arg, sizeof(*vol_args));\n\tif (IS_ERR(vol_args))\n\t\treturn PTR_ERR(vol_args);\n\tvol_args->name[BTRFS_PATH_NAME_MAX] = '\\0';\n\n\tret = btrfs_ioctl_snap_create_transid(file, vol_args->name,\n\t\t\t\t\t      vol_args->fd, subvol,\n\t\t\t\t\t      NULL, false, NULL);\n\n\tkfree(vol_args);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_ioctl_snap_create_transid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "1594-1651",
    "snippet": "static noinline int btrfs_ioctl_snap_create_transid(struct file *file,\n\t\t\t\tchar *name, unsigned long fd, int subvol,\n\t\t\t\tu64 *transid, bool readonly,\n\t\t\t\tstruct btrfs_qgroup_inherit *inherit)\n{\n\tint namelen;\n\tint ret = 0;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\tgoto out;\n\n\tnamelen = strlen(name);\n\tif (strchr(name, '/')) {\n\t\tret = -EINVAL;\n\t\tgoto out_drop_write;\n\t}\n\n\tif (name[0] == '.' &&\n\t   (namelen == 1 || (name[1] == '.' && namelen == 2))) {\n\t\tret = -EEXIST;\n\t\tgoto out_drop_write;\n\t}\n\n\tif (subvol) {\n\t\tret = btrfs_mksubvol(&file->f_path, name, namelen,\n\t\t\t\t     NULL, transid, readonly, inherit);\n\t} else {\n\t\tstruct fd src = fdget(fd);\n\t\tstruct inode *src_inode;\n\t\tif (!src.file) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_drop_write;\n\t\t}\n\n\t\tsrc_inode = file_inode(src.file);\n\t\tif (src_inode->i_sb != file_inode(file)->i_sb) {\n\t\t\tbtrfs_info(BTRFS_I(src_inode)->root->fs_info,\n\t\t\t\t   \"Snapshot src from another FS\");\n\t\t\tret = -EXDEV;\n\t\t} else if (!inode_owner_or_capable(src_inode)) {\n\t\t\t/*\n\t\t\t * Subvolume creation is not restricted, but snapshots\n\t\t\t * are limited to own subvolumes only\n\t\t\t */\n\t\t\tret = -EPERM;\n\t\t} else {\n\t\t\tret = btrfs_mksubvol(&file->f_path, name, namelen,\n\t\t\t\t\t     BTRFS_I(src_inode)->root,\n\t\t\t\t\t     transid, readonly, inherit);\n\t\t}\n\t\tfdput(src);\n\t}\nout_drop_write:\n\tmnt_drop_write_file(file);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "file"
          ],
          "line": 1648
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "src"
          ],
          "line": 1645
        },
        "resolved": true,
        "details": {
          "function_name": "fdput_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "273-278",
          "snippet": "static inline void fdput_pos(struct fd f)\n{\n\tif (f.flags & FDPUT_POS_UNLOCK)\n\t\tmutex_unlock(&f.file->f_pos_lock);\n\tfdput(f);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic inline void fdput_pos(struct fd f)\n{\n\tif (f.flags & FDPUT_POS_UNLOCK)\n\t\tmutex_unlock(&f.file->f_pos_lock);\n\tfdput(f);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_mksubvol",
          "args": [
            "&file->f_path",
            "name",
            "namelen",
            "BTRFS_I(src_inode)->root",
            "transid",
            "readonly",
            "inherit"
          ],
          "line": 1641
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mksubvol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "807-865",
          "snippet": "static noinline int btrfs_mksubvol(struct path *parent,\n\t\t\t\t   char *name, int namelen,\n\t\t\t\t   struct btrfs_root *snap_src,\n\t\t\t\t   u64 *async_transid, bool readonly,\n\t\t\t\t   struct btrfs_qgroup_inherit *inherit)\n{\n\tstruct inode *dir  = parent->dentry->d_inode;\n\tstruct dentry *dentry;\n\tint error;\n\n\terror = mutex_lock_killable_nested(&dir->i_mutex, I_MUTEX_PARENT);\n\tif (error == -EINTR)\n\t\treturn error;\n\n\tdentry = lookup_one_len(name, parent->dentry, namelen);\n\terror = PTR_ERR(dentry);\n\tif (IS_ERR(dentry))\n\t\tgoto out_unlock;\n\n\terror = -EEXIST;\n\tif (dentry->d_inode)\n\t\tgoto out_dput;\n\n\terror = btrfs_may_create(dir, dentry);\n\tif (error)\n\t\tgoto out_dput;\n\n\t/*\n\t * even if this name doesn't exist, we may get hash collisions.\n\t * check for them now when we can safely fail\n\t */\n\terror = btrfs_check_dir_item_collision(BTRFS_I(dir)->root,\n\t\t\t\t\t       dir->i_ino, name,\n\t\t\t\t\t       namelen);\n\tif (error)\n\t\tgoto out_dput;\n\n\tdown_read(&BTRFS_I(dir)->root->fs_info->subvol_sem);\n\n\tif (btrfs_root_refs(&BTRFS_I(dir)->root->root_item) == 0)\n\t\tgoto out_up_read;\n\n\tif (snap_src) {\n\t\terror = create_snapshot(snap_src, dir, dentry, name, namelen,\n\t\t\t\t\tasync_transid, readonly, inherit);\n\t} else {\n\t\terror = create_subvol(dir, dentry, name, namelen,\n\t\t\t\t      async_transid, inherit);\n\t}\n\tif (!error)\n\t\tfsnotify_mkdir(dir, dentry);\nout_up_read:\n\tup_read(&BTRFS_I(dir)->root->fs_info->subvol_sem);\nout_dput:\n\tdput(dentry);\nout_unlock:\n\tmutex_unlock(&dir->i_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic noinline int btrfs_mksubvol(struct path *parent,\n\t\t\t\t   char *name, int namelen,\n\t\t\t\t   struct btrfs_root *snap_src,\n\t\t\t\t   u64 *async_transid, bool readonly,\n\t\t\t\t   struct btrfs_qgroup_inherit *inherit)\n{\n\tstruct inode *dir  = parent->dentry->d_inode;\n\tstruct dentry *dentry;\n\tint error;\n\n\terror = mutex_lock_killable_nested(&dir->i_mutex, I_MUTEX_PARENT);\n\tif (error == -EINTR)\n\t\treturn error;\n\n\tdentry = lookup_one_len(name, parent->dentry, namelen);\n\terror = PTR_ERR(dentry);\n\tif (IS_ERR(dentry))\n\t\tgoto out_unlock;\n\n\terror = -EEXIST;\n\tif (dentry->d_inode)\n\t\tgoto out_dput;\n\n\terror = btrfs_may_create(dir, dentry);\n\tif (error)\n\t\tgoto out_dput;\n\n\t/*\n\t * even if this name doesn't exist, we may get hash collisions.\n\t * check for them now when we can safely fail\n\t */\n\terror = btrfs_check_dir_item_collision(BTRFS_I(dir)->root,\n\t\t\t\t\t       dir->i_ino, name,\n\t\t\t\t\t       namelen);\n\tif (error)\n\t\tgoto out_dput;\n\n\tdown_read(&BTRFS_I(dir)->root->fs_info->subvol_sem);\n\n\tif (btrfs_root_refs(&BTRFS_I(dir)->root->root_item) == 0)\n\t\tgoto out_up_read;\n\n\tif (snap_src) {\n\t\terror = create_snapshot(snap_src, dir, dentry, name, namelen,\n\t\t\t\t\tasync_transid, readonly, inherit);\n\t} else {\n\t\terror = create_subvol(dir, dentry, name, namelen,\n\t\t\t\t      async_transid, inherit);\n\t}\n\tif (!error)\n\t\tfsnotify_mkdir(dir, dentry);\nout_up_read:\n\tup_read(&BTRFS_I(dir)->root->fs_info->subvol_sem);\nout_dput:\n\tdput(dentry);\nout_unlock:\n\tmutex_unlock(&dir->i_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "src_inode"
          ],
          "line": 1642
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_owner_or_capable",
          "args": [
            "src_inode"
          ],
          "line": 1634
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_info",
          "args": [
            "BTRFS_I(src_inode)->root->fs_info",
            "\"Snapshot src from another FS\""
          ],
          "line": 1631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1630
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "fd"
          ],
          "line": 1622
        },
        "resolved": true,
        "details": {
          "function_name": "__fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "706-718",
          "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "name",
            "'/'"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 1606
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "file"
          ],
          "line": 1602
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic noinline int btrfs_ioctl_snap_create_transid(struct file *file,\n\t\t\t\tchar *name, unsigned long fd, int subvol,\n\t\t\t\tu64 *transid, bool readonly,\n\t\t\t\tstruct btrfs_qgroup_inherit *inherit)\n{\n\tint namelen;\n\tint ret = 0;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\tgoto out;\n\n\tnamelen = strlen(name);\n\tif (strchr(name, '/')) {\n\t\tret = -EINVAL;\n\t\tgoto out_drop_write;\n\t}\n\n\tif (name[0] == '.' &&\n\t   (namelen == 1 || (name[1] == '.' && namelen == 2))) {\n\t\tret = -EEXIST;\n\t\tgoto out_drop_write;\n\t}\n\n\tif (subvol) {\n\t\tret = btrfs_mksubvol(&file->f_path, name, namelen,\n\t\t\t\t     NULL, transid, readonly, inherit);\n\t} else {\n\t\tstruct fd src = fdget(fd);\n\t\tstruct inode *src_inode;\n\t\tif (!src.file) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_drop_write;\n\t\t}\n\n\t\tsrc_inode = file_inode(src.file);\n\t\tif (src_inode->i_sb != file_inode(file)->i_sb) {\n\t\t\tbtrfs_info(BTRFS_I(src_inode)->root->fs_info,\n\t\t\t\t   \"Snapshot src from another FS\");\n\t\t\tret = -EXDEV;\n\t\t} else if (!inode_owner_or_capable(src_inode)) {\n\t\t\t/*\n\t\t\t * Subvolume creation is not restricted, but snapshots\n\t\t\t * are limited to own subvolumes only\n\t\t\t */\n\t\t\tret = -EPERM;\n\t\t} else {\n\t\t\tret = btrfs_mksubvol(&file->f_path, name, namelen,\n\t\t\t\t\t     BTRFS_I(src_inode)->root,\n\t\t\t\t\t     transid, readonly, inherit);\n\t\t}\n\t\tfdput(src);\n\t}\nout_drop_write:\n\tmnt_drop_write_file(file);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_ioctl_resize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "1450-1592",
    "snippet": "static noinline int btrfs_ioctl_resize(struct file *file,\n\t\t\t\t\tvoid __user *arg)\n{\n\tu64 new_size;\n\tu64 old_size;\n\tu64 devid = 1;\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tstruct btrfs_ioctl_vol_args *vol_args;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_device *device = NULL;\n\tchar *sizestr;\n\tchar *retptr;\n\tchar *devstr = NULL;\n\tint ret = 0;\n\tint mod = 0;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tif (atomic_xchg(&root->fs_info->mutually_exclusive_operation_running,\n\t\t\t1)) {\n\t\tmnt_drop_write_file(file);\n\t\treturn BTRFS_ERROR_DEV_EXCL_RUN_IN_PROGRESS;\n\t}\n\n\tmutex_lock(&root->fs_info->volume_mutex);\n\tvol_args = memdup_user(arg, sizeof(*vol_args));\n\tif (IS_ERR(vol_args)) {\n\t\tret = PTR_ERR(vol_args);\n\t\tgoto out;\n\t}\n\n\tvol_args->name[BTRFS_PATH_NAME_MAX] = '\\0';\n\n\tsizestr = vol_args->name;\n\tdevstr = strchr(sizestr, ':');\n\tif (devstr) {\n\t\tsizestr = devstr + 1;\n\t\t*devstr = '\\0';\n\t\tdevstr = vol_args->name;\n\t\tret = kstrtoull(devstr, 10, &devid);\n\t\tif (ret)\n\t\t\tgoto out_free;\n\t\tif (!devid) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t\tbtrfs_info(root->fs_info, \"resizing devid %llu\", devid);\n\t}\n\n\tdevice = btrfs_find_device(root->fs_info, devid, NULL, NULL);\n\tif (!device) {\n\t\tbtrfs_info(root->fs_info, \"resizer unable to find device %llu\",\n\t\t       devid);\n\t\tret = -ENODEV;\n\t\tgoto out_free;\n\t}\n\n\tif (!device->writeable) {\n\t\tbtrfs_info(root->fs_info,\n\t\t\t   \"resizer unable to apply on readonly device %llu\",\n\t\t       devid);\n\t\tret = -EPERM;\n\t\tgoto out_free;\n\t}\n\n\tif (!strcmp(sizestr, \"max\"))\n\t\tnew_size = device->bdev->bd_inode->i_size;\n\telse {\n\t\tif (sizestr[0] == '-') {\n\t\t\tmod = -1;\n\t\t\tsizestr++;\n\t\t} else if (sizestr[0] == '+') {\n\t\t\tmod = 1;\n\t\t\tsizestr++;\n\t\t}\n\t\tnew_size = memparse(sizestr, &retptr);\n\t\tif (*retptr != '\\0' || new_size == 0) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\tif (device->is_tgtdev_for_dev_replace) {\n\t\tret = -EPERM;\n\t\tgoto out_free;\n\t}\n\n\told_size = btrfs_device_get_total_bytes(device);\n\n\tif (mod < 0) {\n\t\tif (new_size > old_size) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t\tnew_size = old_size - new_size;\n\t} else if (mod > 0) {\n\t\tif (new_size > ULLONG_MAX - old_size) {\n\t\t\tret = -ERANGE;\n\t\t\tgoto out_free;\n\t\t}\n\t\tnew_size = old_size + new_size;\n\t}\n\n\tif (new_size < 256 * 1024 * 1024) {\n\t\tret = -EINVAL;\n\t\tgoto out_free;\n\t}\n\tif (new_size > device->bdev->bd_inode->i_size) {\n\t\tret = -EFBIG;\n\t\tgoto out_free;\n\t}\n\n\tdo_div(new_size, root->sectorsize);\n\tnew_size *= root->sectorsize;\n\n\tprintk_in_rcu(KERN_INFO \"BTRFS: new size for %s is %llu\\n\",\n\t\t      rcu_str_deref(device->name), new_size);\n\n\tif (new_size > old_size) {\n\t\ttrans = btrfs_start_transaction(root, 0);\n\t\tif (IS_ERR(trans)) {\n\t\t\tret = PTR_ERR(trans);\n\t\t\tgoto out_free;\n\t\t}\n\t\tret = btrfs_grow_device(trans, device, new_size);\n\t\tbtrfs_commit_transaction(trans, root);\n\t} else if (new_size < old_size) {\n\t\tret = btrfs_shrink_device(device, new_size);\n\t} /* equal, nothing need to do */\n\nout_free:\n\tkfree(vol_args);\nout:\n\tmutex_unlock(&root->fs_info->volume_mutex);\n\tatomic_set(&root->fs_info->mutually_exclusive_operation_running, 0);\n\tmnt_drop_write_file(file);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "file"
          ],
          "line": 1590
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&root->fs_info->mutually_exclusive_operation_running",
            "0"
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->fs_info->volume_mutex"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "vol_args"
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_shrink_device",
          "args": [
            "device",
            "new_size"
          ],
          "line": 1582
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_shrink_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "3953-4084",
          "snippet": "int btrfs_shrink_device(struct btrfs_device *device, u64 new_size)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_root *root = device->dev_root;\n\tstruct btrfs_dev_extent *dev_extent = NULL;\n\tstruct btrfs_path *path;\n\tu64 length;\n\tu64 chunk_tree;\n\tu64 chunk_objectid;\n\tu64 chunk_offset;\n\tint ret;\n\tint slot;\n\tint failed = 0;\n\tbool retried = false;\n\tstruct extent_buffer *l;\n\tstruct btrfs_key key;\n\tstruct btrfs_super_block *super_copy = root->fs_info->super_copy;\n\tu64 old_total = btrfs_super_total_bytes(super_copy);\n\tu64 old_size = btrfs_device_get_total_bytes(device);\n\tu64 diff = old_size - new_size;\n\n\tif (device->is_tgtdev_for_dev_replace)\n\t\treturn -EINVAL;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tpath->reada = 2;\n\n\tlock_chunks(root);\n\n\tbtrfs_device_set_total_bytes(device, new_size);\n\tif (device->writeable) {\n\t\tdevice->fs_devices->total_rw_bytes -= diff;\n\t\tspin_lock(&root->fs_info->free_chunk_lock);\n\t\troot->fs_info->free_chunk_space -= diff;\n\t\tspin_unlock(&root->fs_info->free_chunk_lock);\n\t}\n\tunlock_chunks(root);\n\nagain:\n\tkey.objectid = device->devid;\n\tkey.offset = (u64)-1;\n\tkey.type = BTRFS_DEV_EXTENT_KEY;\n\n\tdo {\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\n\t\tret = btrfs_previous_item(root, path, 0, key.type);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tbtrfs_release_path(path);\n\t\t\tbreak;\n\t\t}\n\n\t\tl = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tbtrfs_item_key_to_cpu(l, &key, path->slots[0]);\n\n\t\tif (key.objectid != device->devid) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tbreak;\n\t\t}\n\n\t\tdev_extent = btrfs_item_ptr(l, slot, struct btrfs_dev_extent);\n\t\tlength = btrfs_dev_extent_length(l, dev_extent);\n\n\t\tif (key.offset + length <= new_size) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tbreak;\n\t\t}\n\n\t\tchunk_tree = btrfs_dev_extent_chunk_tree(l, dev_extent);\n\t\tchunk_objectid = btrfs_dev_extent_chunk_objectid(l, dev_extent);\n\t\tchunk_offset = btrfs_dev_extent_chunk_offset(l, dev_extent);\n\t\tbtrfs_release_path(path);\n\n\t\tret = btrfs_relocate_chunk(root, chunk_tree, chunk_objectid,\n\t\t\t\t\t   chunk_offset);\n\t\tif (ret && ret != -ENOSPC)\n\t\t\tgoto done;\n\t\tif (ret == -ENOSPC)\n\t\t\tfailed++;\n\t} while (key.offset-- > 0);\n\n\tif (failed && !retried) {\n\t\tfailed = 0;\n\t\tretried = true;\n\t\tgoto again;\n\t} else if (failed && retried) {\n\t\tret = -ENOSPC;\n\t\tlock_chunks(root);\n\n\t\tbtrfs_device_set_total_bytes(device, old_size);\n\t\tif (device->writeable)\n\t\t\tdevice->fs_devices->total_rw_bytes += diff;\n\t\tspin_lock(&root->fs_info->free_chunk_lock);\n\t\troot->fs_info->free_chunk_space += diff;\n\t\tspin_unlock(&root->fs_info->free_chunk_lock);\n\t\tunlock_chunks(root);\n\t\tgoto done;\n\t}\n\n\t/* Shrinking succeeded, else we would be at \"done\". */\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto done;\n\t}\n\n\tlock_chunks(root);\n\tbtrfs_device_set_disk_total_bytes(device, new_size);\n\tif (list_empty(&device->resized_list))\n\t\tlist_add_tail(&device->resized_list,\n\t\t\t      &root->fs_info->fs_devices->resized_devices);\n\n\tWARN_ON(diff > old_total);\n\tbtrfs_set_super_total_bytes(super_copy, old_total - diff);\n\tunlock_chunks(root);\n\n\t/* Now btrfs_update_device() will change the on-disk size. */\n\tret = btrfs_update_device(trans, device);\n\tbtrfs_end_transaction(trans, root);\ndone:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_shrink_device(struct btrfs_device *device, u64 new_size)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_root *root = device->dev_root;\n\tstruct btrfs_dev_extent *dev_extent = NULL;\n\tstruct btrfs_path *path;\n\tu64 length;\n\tu64 chunk_tree;\n\tu64 chunk_objectid;\n\tu64 chunk_offset;\n\tint ret;\n\tint slot;\n\tint failed = 0;\n\tbool retried = false;\n\tstruct extent_buffer *l;\n\tstruct btrfs_key key;\n\tstruct btrfs_super_block *super_copy = root->fs_info->super_copy;\n\tu64 old_total = btrfs_super_total_bytes(super_copy);\n\tu64 old_size = btrfs_device_get_total_bytes(device);\n\tu64 diff = old_size - new_size;\n\n\tif (device->is_tgtdev_for_dev_replace)\n\t\treturn -EINVAL;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tpath->reada = 2;\n\n\tlock_chunks(root);\n\n\tbtrfs_device_set_total_bytes(device, new_size);\n\tif (device->writeable) {\n\t\tdevice->fs_devices->total_rw_bytes -= diff;\n\t\tspin_lock(&root->fs_info->free_chunk_lock);\n\t\troot->fs_info->free_chunk_space -= diff;\n\t\tspin_unlock(&root->fs_info->free_chunk_lock);\n\t}\n\tunlock_chunks(root);\n\nagain:\n\tkey.objectid = device->devid;\n\tkey.offset = (u64)-1;\n\tkey.type = BTRFS_DEV_EXTENT_KEY;\n\n\tdo {\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\n\t\tret = btrfs_previous_item(root, path, 0, key.type);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tbtrfs_release_path(path);\n\t\t\tbreak;\n\t\t}\n\n\t\tl = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tbtrfs_item_key_to_cpu(l, &key, path->slots[0]);\n\n\t\tif (key.objectid != device->devid) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tbreak;\n\t\t}\n\n\t\tdev_extent = btrfs_item_ptr(l, slot, struct btrfs_dev_extent);\n\t\tlength = btrfs_dev_extent_length(l, dev_extent);\n\n\t\tif (key.offset + length <= new_size) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tbreak;\n\t\t}\n\n\t\tchunk_tree = btrfs_dev_extent_chunk_tree(l, dev_extent);\n\t\tchunk_objectid = btrfs_dev_extent_chunk_objectid(l, dev_extent);\n\t\tchunk_offset = btrfs_dev_extent_chunk_offset(l, dev_extent);\n\t\tbtrfs_release_path(path);\n\n\t\tret = btrfs_relocate_chunk(root, chunk_tree, chunk_objectid,\n\t\t\t\t\t   chunk_offset);\n\t\tif (ret && ret != -ENOSPC)\n\t\t\tgoto done;\n\t\tif (ret == -ENOSPC)\n\t\t\tfailed++;\n\t} while (key.offset-- > 0);\n\n\tif (failed && !retried) {\n\t\tfailed = 0;\n\t\tretried = true;\n\t\tgoto again;\n\t} else if (failed && retried) {\n\t\tret = -ENOSPC;\n\t\tlock_chunks(root);\n\n\t\tbtrfs_device_set_total_bytes(device, old_size);\n\t\tif (device->writeable)\n\t\t\tdevice->fs_devices->total_rw_bytes += diff;\n\t\tspin_lock(&root->fs_info->free_chunk_lock);\n\t\troot->fs_info->free_chunk_space += diff;\n\t\tspin_unlock(&root->fs_info->free_chunk_lock);\n\t\tunlock_chunks(root);\n\t\tgoto done;\n\t}\n\n\t/* Shrinking succeeded, else we would be at \"done\". */\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto done;\n\t}\n\n\tlock_chunks(root);\n\tbtrfs_device_set_disk_total_bytes(device, new_size);\n\tif (list_empty(&device->resized_list))\n\t\tlist_add_tail(&device->resized_list,\n\t\t\t      &root->fs_info->fs_devices->resized_devices);\n\n\tWARN_ON(diff > old_total);\n\tbtrfs_set_super_total_bytes(super_copy, old_total - diff);\n\tunlock_chunks(root);\n\n\t/* Now btrfs_update_device() will change the on-disk size. */\n\tret = btrfs_update_device(trans, device);\n\tbtrfs_end_transaction(trans, root);\ndone:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_commit_transaction",
          "args": [
            "trans",
            "root"
          ],
          "line": 1580
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_commit_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "1764-2099",
          "snippet": "int btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_grow_device",
          "args": [
            "trans",
            "device",
            "new_size"
          ],
          "line": 1579
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_grow_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "2451-2487",
          "snippet": "int btrfs_grow_device(struct btrfs_trans_handle *trans,\n\t\t      struct btrfs_device *device, u64 new_size)\n{\n\tstruct btrfs_super_block *super_copy =\n\t\tdevice->dev_root->fs_info->super_copy;\n\tstruct btrfs_fs_devices *fs_devices;\n\tu64 old_total;\n\tu64 diff;\n\n\tif (!device->writeable)\n\t\treturn -EACCES;\n\n\tlock_chunks(device->dev_root);\n\told_total = btrfs_super_total_bytes(super_copy);\n\tdiff = new_size - device->total_bytes;\n\n\tif (new_size <= device->total_bytes ||\n\t    device->is_tgtdev_for_dev_replace) {\n\t\tunlock_chunks(device->dev_root);\n\t\treturn -EINVAL;\n\t}\n\n\tfs_devices = device->dev_root->fs_info->fs_devices;\n\n\tbtrfs_set_super_total_bytes(super_copy, old_total + diff);\n\tdevice->fs_devices->total_rw_bytes += diff;\n\n\tbtrfs_device_set_total_bytes(device, new_size);\n\tbtrfs_device_set_disk_total_bytes(device, new_size);\n\tbtrfs_clear_space_info_full(device->dev_root->fs_info);\n\tif (list_empty(&device->resized_list))\n\t\tlist_add_tail(&device->resized_list,\n\t\t\t      &fs_devices->resized_devices);\n\tunlock_chunks(device->dev_root);\n\n\treturn btrfs_update_device(trans, device);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_grow_device(struct btrfs_trans_handle *trans,\n\t\t      struct btrfs_device *device, u64 new_size)\n{\n\tstruct btrfs_super_block *super_copy =\n\t\tdevice->dev_root->fs_info->super_copy;\n\tstruct btrfs_fs_devices *fs_devices;\n\tu64 old_total;\n\tu64 diff;\n\n\tif (!device->writeable)\n\t\treturn -EACCES;\n\n\tlock_chunks(device->dev_root);\n\told_total = btrfs_super_total_bytes(super_copy);\n\tdiff = new_size - device->total_bytes;\n\n\tif (new_size <= device->total_bytes ||\n\t    device->is_tgtdev_for_dev_replace) {\n\t\tunlock_chunks(device->dev_root);\n\t\treturn -EINVAL;\n\t}\n\n\tfs_devices = device->dev_root->fs_info->fs_devices;\n\n\tbtrfs_set_super_total_bytes(super_copy, old_total + diff);\n\tdevice->fs_devices->total_rw_bytes += diff;\n\n\tbtrfs_device_set_total_bytes(device, new_size);\n\tbtrfs_device_set_disk_total_bytes(device, new_size);\n\tbtrfs_clear_space_info_full(device->dev_root->fs_info);\n\tif (list_empty(&device->resized_list))\n\t\tlist_add_tail(&device->resized_list,\n\t\t\t      &fs_devices->resized_devices);\n\tunlock_chunks(device->dev_root);\n\n\treturn btrfs_update_device(trans, device);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 1575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_start_transaction",
          "args": [
            "root",
            "0"
          ],
          "line": 1574
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_transaction_lflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "569-574",
          "snippet": "struct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_in_rcu",
          "args": [
            "KERN_INFO \"BTRFS: new size for %s is %llu\\n\"",
            "rcu_str_deref(device->name)",
            "new_size"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_str_deref",
          "args": [
            "device->name"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "new_size",
            "root->sectorsize"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_device_get_total_bytes",
          "args": [
            "device"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memparse",
          "args": [
            "sizestr",
            "&retptr"
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "sizestr",
            "\"max\""
          ],
          "line": 1520
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_info",
          "args": [
            "root->fs_info",
            "\"resizer unable to apply on readonly device %llu\"",
            "devid"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_info",
          "args": [
            "root->fs_info",
            "\"resizer unable to find device %llu\"",
            "devid"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_find_device",
          "args": [
            "root->fs_info",
            "devid",
            "NULL",
            "NULL"
          ],
          "line": 1504
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "5918-5936",
          "snippet": "struct btrfs_device *btrfs_find_device(struct btrfs_fs_info *fs_info, u64 devid,\n\t\t\t\t       u8 *uuid, u8 *fsid)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_fs_devices *cur_devices;\n\n\tcur_devices = fs_info->fs_devices;\n\twhile (cur_devices) {\n\t\tif (!fsid ||\n\t\t    !memcmp(cur_devices->fsid, fsid, BTRFS_UUID_SIZE)) {\n\t\t\tdevice = __find_device(&cur_devices->devices,\n\t\t\t\t\t       devid, uuid);\n\t\t\tif (device)\n\t\t\t\treturn device;\n\t\t}\n\t\tcur_devices = cur_devices->seed;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nstruct btrfs_device *btrfs_find_device(struct btrfs_fs_info *fs_info, u64 devid,\n\t\t\t\t       u8 *uuid, u8 *fsid)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_fs_devices *cur_devices;\n\n\tcur_devices = fs_info->fs_devices;\n\twhile (cur_devices) {\n\t\tif (!fsid ||\n\t\t    !memcmp(cur_devices->fsid, fsid, BTRFS_UUID_SIZE)) {\n\t\t\tdevice = __find_device(&cur_devices->devices,\n\t\t\t\t\t       devid, uuid);\n\t\t\tif (device)\n\t\t\t\treturn device;\n\t\t}\n\t\tcur_devices = cur_devices->seed;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_info",
          "args": [
            "root->fs_info",
            "\"resizing devid %llu\"",
            "devid"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoull",
          "args": [
            "devstr",
            "10",
            "&devid"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "sizestr",
            "':'"
          ],
          "line": 1489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "vol_args"
          ],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "vol_args"
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user",
          "args": [
            "arg",
            "sizeof(*vol_args)"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&root->fs_info->volume_mutex"
          ],
          "line": 1479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_xchg",
          "args": [
            "&root->fs_info->mutually_exclusive_operation_running",
            "1"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "file"
          ],
          "line": 1469
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 1466
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "file_inode(file)"
          ],
          "line": 1456
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1456
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic noinline int btrfs_ioctl_resize(struct file *file,\n\t\t\t\t\tvoid __user *arg)\n{\n\tu64 new_size;\n\tu64 old_size;\n\tu64 devid = 1;\n\tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;\n\tstruct btrfs_ioctl_vol_args *vol_args;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_device *device = NULL;\n\tchar *sizestr;\n\tchar *retptr;\n\tchar *devstr = NULL;\n\tint ret = 0;\n\tint mod = 0;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tif (atomic_xchg(&root->fs_info->mutually_exclusive_operation_running,\n\t\t\t1)) {\n\t\tmnt_drop_write_file(file);\n\t\treturn BTRFS_ERROR_DEV_EXCL_RUN_IN_PROGRESS;\n\t}\n\n\tmutex_lock(&root->fs_info->volume_mutex);\n\tvol_args = memdup_user(arg, sizeof(*vol_args));\n\tif (IS_ERR(vol_args)) {\n\t\tret = PTR_ERR(vol_args);\n\t\tgoto out;\n\t}\n\n\tvol_args->name[BTRFS_PATH_NAME_MAX] = '\\0';\n\n\tsizestr = vol_args->name;\n\tdevstr = strchr(sizestr, ':');\n\tif (devstr) {\n\t\tsizestr = devstr + 1;\n\t\t*devstr = '\\0';\n\t\tdevstr = vol_args->name;\n\t\tret = kstrtoull(devstr, 10, &devid);\n\t\tif (ret)\n\t\t\tgoto out_free;\n\t\tif (!devid) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t\tbtrfs_info(root->fs_info, \"resizing devid %llu\", devid);\n\t}\n\n\tdevice = btrfs_find_device(root->fs_info, devid, NULL, NULL);\n\tif (!device) {\n\t\tbtrfs_info(root->fs_info, \"resizer unable to find device %llu\",\n\t\t       devid);\n\t\tret = -ENODEV;\n\t\tgoto out_free;\n\t}\n\n\tif (!device->writeable) {\n\t\tbtrfs_info(root->fs_info,\n\t\t\t   \"resizer unable to apply on readonly device %llu\",\n\t\t       devid);\n\t\tret = -EPERM;\n\t\tgoto out_free;\n\t}\n\n\tif (!strcmp(sizestr, \"max\"))\n\t\tnew_size = device->bdev->bd_inode->i_size;\n\telse {\n\t\tif (sizestr[0] == '-') {\n\t\t\tmod = -1;\n\t\t\tsizestr++;\n\t\t} else if (sizestr[0] == '+') {\n\t\t\tmod = 1;\n\t\t\tsizestr++;\n\t\t}\n\t\tnew_size = memparse(sizestr, &retptr);\n\t\tif (*retptr != '\\0' || new_size == 0) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\tif (device->is_tgtdev_for_dev_replace) {\n\t\tret = -EPERM;\n\t\tgoto out_free;\n\t}\n\n\told_size = btrfs_device_get_total_bytes(device);\n\n\tif (mod < 0) {\n\t\tif (new_size > old_size) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t\tnew_size = old_size - new_size;\n\t} else if (mod > 0) {\n\t\tif (new_size > ULLONG_MAX - old_size) {\n\t\t\tret = -ERANGE;\n\t\t\tgoto out_free;\n\t\t}\n\t\tnew_size = old_size + new_size;\n\t}\n\n\tif (new_size < 256 * 1024 * 1024) {\n\t\tret = -EINVAL;\n\t\tgoto out_free;\n\t}\n\tif (new_size > device->bdev->bd_inode->i_size) {\n\t\tret = -EFBIG;\n\t\tgoto out_free;\n\t}\n\n\tdo_div(new_size, root->sectorsize);\n\tnew_size *= root->sectorsize;\n\n\tprintk_in_rcu(KERN_INFO \"BTRFS: new size for %s is %llu\\n\",\n\t\t      rcu_str_deref(device->name), new_size);\n\n\tif (new_size > old_size) {\n\t\ttrans = btrfs_start_transaction(root, 0);\n\t\tif (IS_ERR(trans)) {\n\t\t\tret = PTR_ERR(trans);\n\t\t\tgoto out_free;\n\t\t}\n\t\tret = btrfs_grow_device(trans, device, new_size);\n\t\tbtrfs_commit_transaction(trans, root);\n\t} else if (new_size < old_size) {\n\t\tret = btrfs_shrink_device(device, new_size);\n\t} /* equal, nothing need to do */\n\nout_free:\n\tkfree(vol_args);\nout:\n\tmutex_unlock(&root->fs_info->volume_mutex);\n\tatomic_set(&root->fs_info->mutually_exclusive_operation_running, 0);\n\tmnt_drop_write_file(file);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_defrag_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "1231-1448",
    "snippet": "int btrfs_defrag_file(struct inode *inode, struct file *file,\n\t\t      struct btrfs_ioctl_defrag_range_args *range,\n\t\t      u64 newer_than, unsigned long max_to_defrag)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct file_ra_state *ra = NULL;\n\tunsigned long last_index;\n\tu64 isize = i_size_read(inode);\n\tu64 last_len = 0;\n\tu64 skip = 0;\n\tu64 defrag_end = 0;\n\tu64 newer_off = range->start;\n\tunsigned long i;\n\tunsigned long ra_index = 0;\n\tint ret;\n\tint defrag_count = 0;\n\tint compress_type = BTRFS_COMPRESS_ZLIB;\n\tu32 extent_thresh = range->extent_thresh;\n\tunsigned long max_cluster = (256 * 1024) >> PAGE_CACHE_SHIFT;\n\tunsigned long cluster = max_cluster;\n\tu64 new_align = ~((u64)128 * 1024 - 1);\n\tstruct page **pages = NULL;\n\n\tif (isize == 0)\n\t\treturn 0;\n\n\tif (range->start >= isize)\n\t\treturn -EINVAL;\n\n\tif (range->flags & BTRFS_DEFRAG_RANGE_COMPRESS) {\n\t\tif (range->compress_type > BTRFS_COMPRESS_TYPES)\n\t\t\treturn -EINVAL;\n\t\tif (range->compress_type)\n\t\t\tcompress_type = range->compress_type;\n\t}\n\n\tif (extent_thresh == 0)\n\t\textent_thresh = 256 * 1024;\n\n\t/*\n\t * if we were not given a file, allocate a readahead\n\t * context\n\t */\n\tif (!file) {\n\t\tra = kzalloc(sizeof(*ra), GFP_NOFS);\n\t\tif (!ra)\n\t\t\treturn -ENOMEM;\n\t\tfile_ra_state_init(ra, inode->i_mapping);\n\t} else {\n\t\tra = &file->f_ra;\n\t}\n\n\tpages = kmalloc_array(max_cluster, sizeof(struct page *),\n\t\t\tGFP_NOFS);\n\tif (!pages) {\n\t\tret = -ENOMEM;\n\t\tgoto out_ra;\n\t}\n\n\t/* find the last page to defrag */\n\tif (range->start + range->len > range->start) {\n\t\tlast_index = min_t(u64, isize - 1,\n\t\t\t range->start + range->len - 1) >> PAGE_CACHE_SHIFT;\n\t} else {\n\t\tlast_index = (isize - 1) >> PAGE_CACHE_SHIFT;\n\t}\n\n\tif (newer_than) {\n\t\tret = find_new_extents(root, inode, newer_than,\n\t\t\t\t       &newer_off, 64 * 1024);\n\t\tif (!ret) {\n\t\t\trange->start = newer_off;\n\t\t\t/*\n\t\t\t * we always align our defrag to help keep\n\t\t\t * the extents in the file evenly spaced\n\t\t\t */\n\t\t\ti = (newer_off & new_align) >> PAGE_CACHE_SHIFT;\n\t\t} else\n\t\t\tgoto out_ra;\n\t} else {\n\t\ti = range->start >> PAGE_CACHE_SHIFT;\n\t}\n\tif (!max_to_defrag)\n\t\tmax_to_defrag = last_index + 1;\n\n\t/*\n\t * make writeback starts from i, so the defrag range can be\n\t * written sequentially.\n\t */\n\tif (i < inode->i_mapping->writeback_index)\n\t\tinode->i_mapping->writeback_index = i;\n\n\twhile (i <= last_index && defrag_count < max_to_defrag &&\n\t       (i < DIV_ROUND_UP(i_size_read(inode), PAGE_CACHE_SIZE))) {\n\t\t/*\n\t\t * make sure we stop running if someone unmounts\n\t\t * the FS\n\t\t */\n\t\tif (!(inode->i_sb->s_flags & MS_ACTIVE))\n\t\t\tbreak;\n\n\t\tif (btrfs_defrag_cancelled(root->fs_info)) {\n\t\t\tprintk(KERN_DEBUG \"BTRFS: defrag_file cancelled\\n\");\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!should_defrag_range(inode, (u64)i << PAGE_CACHE_SHIFT,\n\t\t\t\t\t extent_thresh, &last_len, &skip,\n\t\t\t\t\t &defrag_end, range->flags &\n\t\t\t\t\t BTRFS_DEFRAG_RANGE_COMPRESS)) {\n\t\t\tunsigned long next;\n\t\t\t/*\n\t\t\t * the should_defrag function tells us how much to skip\n\t\t\t * bump our counter by the suggested amount\n\t\t\t */\n\t\t\tnext = DIV_ROUND_UP(skip, PAGE_CACHE_SIZE);\n\t\t\ti = max(i + 1, next);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!newer_than) {\n\t\t\tcluster = (PAGE_CACHE_ALIGN(defrag_end) >>\n\t\t\t\t   PAGE_CACHE_SHIFT) - i;\n\t\t\tcluster = min(cluster, max_cluster);\n\t\t} else {\n\t\t\tcluster = max_cluster;\n\t\t}\n\n\t\tif (i + cluster > ra_index) {\n\t\t\tra_index = max(i, ra_index);\n\t\t\tbtrfs_force_ra(inode->i_mapping, ra, file, ra_index,\n\t\t\t\t       cluster);\n\t\t\tra_index += max_cluster;\n\t\t}\n\n\t\tmutex_lock(&inode->i_mutex);\n\t\tif (range->flags & BTRFS_DEFRAG_RANGE_COMPRESS)\n\t\t\tBTRFS_I(inode)->force_compress = compress_type;\n\t\tret = cluster_pages_for_defrag(inode, pages, i, cluster);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\tgoto out_ra;\n\t\t}\n\n\t\tdefrag_count += ret;\n\t\tbalance_dirty_pages_ratelimited(inode->i_mapping);\n\t\tmutex_unlock(&inode->i_mutex);\n\n\t\tif (newer_than) {\n\t\t\tif (newer_off == (u64)-1)\n\t\t\t\tbreak;\n\n\t\t\tif (ret > 0)\n\t\t\t\ti += ret;\n\n\t\t\tnewer_off = max(newer_off + 1,\n\t\t\t\t\t(u64)i << PAGE_CACHE_SHIFT);\n\n\t\t\tret = find_new_extents(root, inode,\n\t\t\t\t\t       newer_than, &newer_off,\n\t\t\t\t\t       64 * 1024);\n\t\t\tif (!ret) {\n\t\t\t\trange->start = newer_off;\n\t\t\t\ti = (newer_off & new_align) >> PAGE_CACHE_SHIFT;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (ret > 0) {\n\t\t\t\ti += ret;\n\t\t\t\tlast_len += ret << PAGE_CACHE_SHIFT;\n\t\t\t} else {\n\t\t\t\ti++;\n\t\t\t\tlast_len = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((range->flags & BTRFS_DEFRAG_RANGE_START_IO)) {\n\t\tfilemap_flush(inode->i_mapping);\n\t\tif (test_bit(BTRFS_INODE_HAS_ASYNC_EXTENT,\n\t\t\t     &BTRFS_I(inode)->runtime_flags))\n\t\t\tfilemap_flush(inode->i_mapping);\n\t}\n\n\tif ((range->flags & BTRFS_DEFRAG_RANGE_COMPRESS)) {\n\t\t/* the filemap_flush will queue IO into the worker threads, but\n\t\t * we have to make sure the IO is actually started and that\n\t\t * ordered extents get created before we return\n\t\t */\n\t\tatomic_inc(&root->fs_info->async_submit_draining);\n\t\twhile (atomic_read(&root->fs_info->nr_async_submits) ||\n\t\t      atomic_read(&root->fs_info->async_delalloc_pages)) {\n\t\t\twait_event(root->fs_info->async_submit_wait,\n\t\t\t   (atomic_read(&root->fs_info->nr_async_submits) == 0 &&\n\t\t\t    atomic_read(&root->fs_info->async_delalloc_pages) == 0));\n\t\t}\n\t\tatomic_dec(&root->fs_info->async_submit_draining);\n\t}\n\n\tif (range->compress_type == BTRFS_COMPRESS_LZO) {\n\t\tbtrfs_set_fs_incompat(root->fs_info, COMPRESS_LZO);\n\t}\n\n\tret = defrag_count;\n\nout_ra:\n\tif (range->flags & BTRFS_DEFRAG_RANGE_COMPRESS) {\n\t\tmutex_lock(&inode->i_mutex);\n\t\tBTRFS_I(inode)->force_compress = BTRFS_COMPRESS_NONE;\n\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\tif (!file)\n\t\tkfree(ra);\n\tkfree(pages);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pages"
          ],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ra"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 1441
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_fs_incompat",
          "args": [
            "root->fs_info",
            "COMPRESS_LZO"
          ],
          "line": 1433
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_set_fs_incompat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "4040-4059",
          "snippet": "static inline void __btrfs_set_fs_incompat(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t   u64 flag)\n{\n\tstruct btrfs_super_block *disk_super;\n\tu64 features;\n\n\tdisk_super = fs_info->super_copy;\n\tfeatures = btrfs_super_incompat_flags(disk_super);\n\tif (!(features & flag)) {\n\t\tspin_lock(&fs_info->super_lock);\n\t\tfeatures = btrfs_super_incompat_flags(disk_super);\n\t\tif (!(features & flag)) {\n\t\t\tfeatures |= flag;\n\t\t\tbtrfs_set_super_incompat_flags(disk_super, features);\n\t\t\tbtrfs_info(fs_info, \"setting %llu feature flag\",\n\t\t\t\t\t flag);\n\t\t}\n\t\tspin_unlock(&fs_info->super_lock);\n\t}\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void __btrfs_set_fs_incompat(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t   u64 flag)\n{\n\tstruct btrfs_super_block *disk_super;\n\tu64 features;\n\n\tdisk_super = fs_info->super_copy;\n\tfeatures = btrfs_super_incompat_flags(disk_super);\n\tif (!(features & flag)) {\n\t\tspin_lock(&fs_info->super_lock);\n\t\tfeatures = btrfs_super_incompat_flags(disk_super);\n\t\tif (!(features & flag)) {\n\t\t\tfeatures |= flag;\n\t\t\tbtrfs_set_super_incompat_flags(disk_super, features);\n\t\t\tbtrfs_info(fs_info, \"setting %llu feature flag\",\n\t\t\t\t\t flag);\n\t\t}\n\t\tspin_unlock(&fs_info->super_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&root->fs_info->async_submit_draining"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "root->fs_info->async_submit_wait",
            "(atomic_read(&root->fs_info->nr_async_submits) == 0 &&\n\t\t\t    atomic_read(&root->fs_info->async_delalloc_pages) == 0)"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&root->fs_info->async_delalloc_pages"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&root->fs_info->nr_async_submits"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&root->fs_info->async_delalloc_pages"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&root->fs_info->nr_async_submits"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&root->fs_info->async_submit_draining"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_flush",
          "args": [
            "inode->i_mapping"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_INODE_HAS_ASYNC_EXTENT",
            "&BTRFS_I(inode)->runtime_flags"
          ],
          "line": 1412
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_flush",
          "args": [
            "inode->i_mapping"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_new_extents",
          "args": [
            "root",
            "inode",
            "newer_than",
            "&newer_off",
            "64 * 1024"
          ],
          "line": 1390
        },
        "resolved": true,
        "details": {
          "function_name": "find_new_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "907-965",
          "snippet": "static int find_new_extents(struct btrfs_root *root,\n\t\t\t    struct inode *inode, u64 newer_than,\n\t\t\t    u64 *off, u32 thresh)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key min_key;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_file_extent_item *extent;\n\tint type;\n\tint ret;\n\tu64 ino = btrfs_ino(inode);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tmin_key.objectid = ino;\n\tmin_key.type = BTRFS_EXTENT_DATA_KEY;\n\tmin_key.offset = *off;\n\n\twhile (1) {\n\t\tret = btrfs_search_forward(root, &min_key, path, newer_than);\n\t\tif (ret != 0)\n\t\t\tgoto none;\nprocess_slot:\n\t\tif (min_key.objectid != ino)\n\t\t\tgoto none;\n\t\tif (min_key.type != BTRFS_EXTENT_DATA_KEY)\n\t\t\tgoto none;\n\n\t\tleaf = path->nodes[0];\n\t\textent = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\tstruct btrfs_file_extent_item);\n\n\t\ttype = btrfs_file_extent_type(leaf, extent);\n\t\tif (type == BTRFS_FILE_EXTENT_REG &&\n\t\t    btrfs_file_extent_num_bytes(leaf, extent) < thresh &&\n\t\t    check_defrag_in_cache(inode, min_key.offset, thresh)) {\n\t\t\t*off = min_key.offset;\n\t\t\tbtrfs_free_path(path);\n\t\t\treturn 0;\n\t\t}\n\n\t\tpath->slots[0]++;\n\t\tif (path->slots[0] < btrfs_header_nritems(leaf)) {\n\t\t\tbtrfs_item_key_to_cpu(leaf, &min_key, path->slots[0]);\n\t\t\tgoto process_slot;\n\t\t}\n\n\t\tif (min_key.offset == (u64)-1)\n\t\t\tgoto none;\n\n\t\tmin_key.offset++;\n\t\tbtrfs_release_path(path);\n\t}\nnone:\n\tbtrfs_free_path(path);\n\treturn -ENOENT;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int find_new_extents(struct btrfs_root *root,\n\t\t\t    struct inode *inode, u64 newer_than,\n\t\t\t    u64 *off, u32 thresh)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key min_key;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_file_extent_item *extent;\n\tint type;\n\tint ret;\n\tu64 ino = btrfs_ino(inode);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tmin_key.objectid = ino;\n\tmin_key.type = BTRFS_EXTENT_DATA_KEY;\n\tmin_key.offset = *off;\n\n\twhile (1) {\n\t\tret = btrfs_search_forward(root, &min_key, path, newer_than);\n\t\tif (ret != 0)\n\t\t\tgoto none;\nprocess_slot:\n\t\tif (min_key.objectid != ino)\n\t\t\tgoto none;\n\t\tif (min_key.type != BTRFS_EXTENT_DATA_KEY)\n\t\t\tgoto none;\n\n\t\tleaf = path->nodes[0];\n\t\textent = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\tstruct btrfs_file_extent_item);\n\n\t\ttype = btrfs_file_extent_type(leaf, extent);\n\t\tif (type == BTRFS_FILE_EXTENT_REG &&\n\t\t    btrfs_file_extent_num_bytes(leaf, extent) < thresh &&\n\t\t    check_defrag_in_cache(inode, min_key.offset, thresh)) {\n\t\t\t*off = min_key.offset;\n\t\t\tbtrfs_free_path(path);\n\t\t\treturn 0;\n\t\t}\n\n\t\tpath->slots[0]++;\n\t\tif (path->slots[0] < btrfs_header_nritems(leaf)) {\n\t\t\tbtrfs_item_key_to_cpu(leaf, &min_key, path->slots[0]);\n\t\t\tgoto process_slot;\n\t\t}\n\n\t\tif (min_key.offset == (u64)-1)\n\t\t\tgoto none;\n\n\t\tmin_key.offset++;\n\t\tbtrfs_release_path(path);\n\t}\nnone:\n\tbtrfs_free_path(path);\n\treturn -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "newer_off + 1",
            "(u64)i << PAGE_CACHE_SHIFT"
          ],
          "line": 1387
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_info_handle_maxslots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ioctl.c",
          "lines": "182-199",
          "snippet": "static int ocfs2_info_handle_maxslots(struct inode *inode,\n\t\t\t\t      struct ocfs2_info_request __user *req)\n{\n\tstruct ocfs2_info_maxslots oim;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (o2info_from_user(oim, req))\n\t\treturn -EFAULT;\n\n\toim.im_max_slots = osb->max_slots;\n\n\to2info_set_request_filled(&oim.im_req);\n\n\tif (o2info_to_user(oim, req))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"resize.h\"",
            "#include \"ioctl.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_info_handle_maxslots(struct inode *inode,\n\t\t\t\t      struct ocfs2_info_request __user *req)\n{\n\tstruct ocfs2_info_maxslots oim;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (o2info_from_user(oim, req))\n\t\treturn -EFAULT;\n\n\toim.im_max_slots = osb->max_slots;\n\n\to2info_set_request_filled(&oim.im_req);\n\n\tif (o2info_to_user(oim, req))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "balance_dirty_pages_ratelimited",
          "args": [
            "inode->i_mapping"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cluster_pages_for_defrag",
          "args": [
            "inode",
            "pages",
            "i",
            "cluster"
          ],
          "line": 1370
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_pages_for_defrag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "1086-1229",
          "snippet": "static int cluster_pages_for_defrag(struct inode *inode,\n\t\t\t\t    struct page **pages,\n\t\t\t\t    unsigned long start_index,\n\t\t\t\t    unsigned long num_pages)\n{\n\tunsigned long file_end;\n\tu64 isize = i_size_read(inode);\n\tu64 page_start;\n\tu64 page_end;\n\tu64 page_cnt;\n\tint ret;\n\tint i;\n\tint i_done;\n\tstruct btrfs_ordered_extent *ordered;\n\tstruct extent_state *cached_state = NULL;\n\tstruct extent_io_tree *tree;\n\tgfp_t mask = btrfs_alloc_write_mask(inode->i_mapping);\n\n\tfile_end = (isize - 1) >> PAGE_CACHE_SHIFT;\n\tif (!isize || start_index > file_end)\n\t\treturn 0;\n\n\tpage_cnt = min_t(u64, (u64)num_pages, (u64)file_end - start_index + 1);\n\n\tret = btrfs_delalloc_reserve_space(inode,\n\t\t\t\t\t   page_cnt << PAGE_CACHE_SHIFT);\n\tif (ret)\n\t\treturn ret;\n\ti_done = 0;\n\ttree = &BTRFS_I(inode)->io_tree;\n\n\t/* step one, lock all the pages */\n\tfor (i = 0; i < page_cnt; i++) {\n\t\tstruct page *page;\nagain:\n\t\tpage = find_or_create_page(inode->i_mapping,\n\t\t\t\t\t   start_index + i, mask);\n\t\tif (!page)\n\t\t\tbreak;\n\n\t\tpage_start = page_offset(page);\n\t\tpage_end = page_start + PAGE_CACHE_SIZE - 1;\n\t\twhile (1) {\n\t\t\tlock_extent_bits(tree, page_start, page_end,\n\t\t\t\t\t 0, &cached_state);\n\t\t\tordered = btrfs_lookup_ordered_extent(inode,\n\t\t\t\t\t\t\t      page_start);\n\t\t\tunlock_extent_cached(tree, page_start, page_end,\n\t\t\t\t\t     &cached_state, GFP_NOFS);\n\t\t\tif (!ordered)\n\t\t\t\tbreak;\n\n\t\t\tunlock_page(page);\n\t\t\tbtrfs_start_ordered_extent(inode, ordered, 1);\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tlock_page(page);\n\t\t\t/*\n\t\t\t * we unlocked the page above, so we need check if\n\t\t\t * it was released or not.\n\t\t\t */\n\t\t\tif (page->mapping != inode->i_mapping) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tpage_cache_release(page);\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t}\n\n\t\tif (!PageUptodate(page)) {\n\t\t\tbtrfs_readpage(NULL, page);\n\t\t\tlock_page(page);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tpage_cache_release(page);\n\t\t\t\tret = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (page->mapping != inode->i_mapping) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tgoto again;\n\t\t}\n\n\t\tpages[i] = page;\n\t\ti_done++;\n\t}\n\tif (!i_done || ret)\n\t\tgoto out;\n\n\tif (!(inode->i_sb->s_flags & MS_ACTIVE))\n\t\tgoto out;\n\n\t/*\n\t * so now we have a nice long stream of locked\n\t * and up to date pages, lets wait on them\n\t */\n\tfor (i = 0; i < i_done; i++)\n\t\twait_on_page_writeback(pages[i]);\n\n\tpage_start = page_offset(pages[0]);\n\tpage_end = page_offset(pages[i_done - 1]) + PAGE_CACHE_SIZE;\n\n\tlock_extent_bits(&BTRFS_I(inode)->io_tree,\n\t\t\t page_start, page_end - 1, 0, &cached_state);\n\tclear_extent_bit(&BTRFS_I(inode)->io_tree, page_start,\n\t\t\t  page_end - 1, EXTENT_DIRTY | EXTENT_DELALLOC |\n\t\t\t  EXTENT_DO_ACCOUNTING | EXTENT_DEFRAG, 0, 0,\n\t\t\t  &cached_state, GFP_NOFS);\n\n\tif (i_done != page_cnt) {\n\t\tspin_lock(&BTRFS_I(inode)->lock);\n\t\tBTRFS_I(inode)->outstanding_extents++;\n\t\tspin_unlock(&BTRFS_I(inode)->lock);\n\t\tbtrfs_delalloc_release_space(inode,\n\t\t\t\t     (page_cnt - i_done) << PAGE_CACHE_SHIFT);\n\t}\n\n\n\tset_extent_defrag(&BTRFS_I(inode)->io_tree, page_start, page_end - 1,\n\t\t\t  &cached_state, GFP_NOFS);\n\n\tunlock_extent_cached(&BTRFS_I(inode)->io_tree,\n\t\t\t     page_start, page_end - 1, &cached_state,\n\t\t\t     GFP_NOFS);\n\n\tfor (i = 0; i < i_done; i++) {\n\t\tclear_page_dirty_for_io(pages[i]);\n\t\tClearPageChecked(pages[i]);\n\t\tset_page_extent_mapped(pages[i]);\n\t\tset_page_dirty(pages[i]);\n\t\tunlock_page(pages[i]);\n\t\tpage_cache_release(pages[i]);\n\t}\n\treturn i_done;\nout:\n\tfor (i = 0; i < i_done; i++) {\n\t\tunlock_page(pages[i]);\n\t\tpage_cache_release(pages[i]);\n\t}\n\tbtrfs_delalloc_release_space(inode, page_cnt << PAGE_CACHE_SHIFT);\n\treturn ret;\n\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int cluster_pages_for_defrag(struct inode *inode,\n\t\t\t\t    struct page **pages,\n\t\t\t\t    unsigned long start_index,\n\t\t\t\t    unsigned long num_pages)\n{\n\tunsigned long file_end;\n\tu64 isize = i_size_read(inode);\n\tu64 page_start;\n\tu64 page_end;\n\tu64 page_cnt;\n\tint ret;\n\tint i;\n\tint i_done;\n\tstruct btrfs_ordered_extent *ordered;\n\tstruct extent_state *cached_state = NULL;\n\tstruct extent_io_tree *tree;\n\tgfp_t mask = btrfs_alloc_write_mask(inode->i_mapping);\n\n\tfile_end = (isize - 1) >> PAGE_CACHE_SHIFT;\n\tif (!isize || start_index > file_end)\n\t\treturn 0;\n\n\tpage_cnt = min_t(u64, (u64)num_pages, (u64)file_end - start_index + 1);\n\n\tret = btrfs_delalloc_reserve_space(inode,\n\t\t\t\t\t   page_cnt << PAGE_CACHE_SHIFT);\n\tif (ret)\n\t\treturn ret;\n\ti_done = 0;\n\ttree = &BTRFS_I(inode)->io_tree;\n\n\t/* step one, lock all the pages */\n\tfor (i = 0; i < page_cnt; i++) {\n\t\tstruct page *page;\nagain:\n\t\tpage = find_or_create_page(inode->i_mapping,\n\t\t\t\t\t   start_index + i, mask);\n\t\tif (!page)\n\t\t\tbreak;\n\n\t\tpage_start = page_offset(page);\n\t\tpage_end = page_start + PAGE_CACHE_SIZE - 1;\n\t\twhile (1) {\n\t\t\tlock_extent_bits(tree, page_start, page_end,\n\t\t\t\t\t 0, &cached_state);\n\t\t\tordered = btrfs_lookup_ordered_extent(inode,\n\t\t\t\t\t\t\t      page_start);\n\t\t\tunlock_extent_cached(tree, page_start, page_end,\n\t\t\t\t\t     &cached_state, GFP_NOFS);\n\t\t\tif (!ordered)\n\t\t\t\tbreak;\n\n\t\t\tunlock_page(page);\n\t\t\tbtrfs_start_ordered_extent(inode, ordered, 1);\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tlock_page(page);\n\t\t\t/*\n\t\t\t * we unlocked the page above, so we need check if\n\t\t\t * it was released or not.\n\t\t\t */\n\t\t\tif (page->mapping != inode->i_mapping) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tpage_cache_release(page);\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t}\n\n\t\tif (!PageUptodate(page)) {\n\t\t\tbtrfs_readpage(NULL, page);\n\t\t\tlock_page(page);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tpage_cache_release(page);\n\t\t\t\tret = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (page->mapping != inode->i_mapping) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tgoto again;\n\t\t}\n\n\t\tpages[i] = page;\n\t\ti_done++;\n\t}\n\tif (!i_done || ret)\n\t\tgoto out;\n\n\tif (!(inode->i_sb->s_flags & MS_ACTIVE))\n\t\tgoto out;\n\n\t/*\n\t * so now we have a nice long stream of locked\n\t * and up to date pages, lets wait on them\n\t */\n\tfor (i = 0; i < i_done; i++)\n\t\twait_on_page_writeback(pages[i]);\n\n\tpage_start = page_offset(pages[0]);\n\tpage_end = page_offset(pages[i_done - 1]) + PAGE_CACHE_SIZE;\n\n\tlock_extent_bits(&BTRFS_I(inode)->io_tree,\n\t\t\t page_start, page_end - 1, 0, &cached_state);\n\tclear_extent_bit(&BTRFS_I(inode)->io_tree, page_start,\n\t\t\t  page_end - 1, EXTENT_DIRTY | EXTENT_DELALLOC |\n\t\t\t  EXTENT_DO_ACCOUNTING | EXTENT_DEFRAG, 0, 0,\n\t\t\t  &cached_state, GFP_NOFS);\n\n\tif (i_done != page_cnt) {\n\t\tspin_lock(&BTRFS_I(inode)->lock);\n\t\tBTRFS_I(inode)->outstanding_extents++;\n\t\tspin_unlock(&BTRFS_I(inode)->lock);\n\t\tbtrfs_delalloc_release_space(inode,\n\t\t\t\t     (page_cnt - i_done) << PAGE_CACHE_SHIFT);\n\t}\n\n\n\tset_extent_defrag(&BTRFS_I(inode)->io_tree, page_start, page_end - 1,\n\t\t\t  &cached_state, GFP_NOFS);\n\n\tunlock_extent_cached(&BTRFS_I(inode)->io_tree,\n\t\t\t     page_start, page_end - 1, &cached_state,\n\t\t\t     GFP_NOFS);\n\n\tfor (i = 0; i < i_done; i++) {\n\t\tclear_page_dirty_for_io(pages[i]);\n\t\tClearPageChecked(pages[i]);\n\t\tset_page_extent_mapped(pages[i]);\n\t\tset_page_dirty(pages[i]);\n\t\tunlock_page(pages[i]);\n\t\tpage_cache_release(pages[i]);\n\t}\n\treturn i_done;\nout:\n\tfor (i = 0; i < i_done; i++) {\n\t\tunlock_page(pages[i]);\n\t\tpage_cache_release(pages[i]);\n\t}\n\tbtrfs_delalloc_release_space(inode, page_cnt << PAGE_CACHE_SHIFT);\n\treturn ret;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_force_ra",
          "args": [
            "inode->i_mapping",
            "ra",
            "file",
            "ra_index",
            "cluster"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_force_ra",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3838-3843",
          "snippet": "static inline void btrfs_force_ra(struct address_space *mapping,\n\t\t\t\t  struct file_ra_state *ra, struct file *file,\n\t\t\t\t  pgoff_t offset, unsigned long req_size)\n{\n\tpage_cache_sync_readahead(mapping, ra, file, offset, req_size);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_force_ra(struct address_space *mapping,\n\t\t\t\t  struct file_ra_state *ra, struct file *file,\n\t\t\t\t  pgoff_t offset, unsigned long req_size)\n{\n\tpage_cache_sync_readahead(mapping, ra, file, offset, req_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "cluster",
            "max_cluster"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PAGE_CACHE_ALIGN",
          "args": [
            "defrag_end"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "skip",
            "PAGE_CACHE_SIZE"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "should_defrag_range",
          "args": [
            "inode",
            "(u64)i << PAGE_CACHE_SHIFT",
            "extent_thresh",
            "&last_len",
            "&skip",
            "&defrag_end",
            "range->flags &\n\t\t\t\t\t BTRFS_DEFRAG_RANGE_COMPRESS"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "should_defrag_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "1018-1072",
          "snippet": "static int should_defrag_range(struct inode *inode, u64 start, u32 thresh,\n\t\t\t       u64 *last_len, u64 *skip, u64 *defrag_end,\n\t\t\t       int compress)\n{\n\tstruct extent_map *em;\n\tint ret = 1;\n\tbool next_mergeable = true;\n\n\t/*\n\t * make sure that once we start defragging an extent, we keep on\n\t * defragging it\n\t */\n\tif (start < *defrag_end)\n\t\treturn 1;\n\n\t*skip = 0;\n\n\tem = defrag_lookup_extent(inode, start);\n\tif (!em)\n\t\treturn 0;\n\n\t/* this will cover holes, and inline extents */\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tnext_mergeable = defrag_check_next_extent(inode, em);\n\t/*\n\t * we hit a real extent, if it is big or the next extent is not a\n\t * real extent, don't bother defragging it\n\t */\n\tif (!compress && (*last_len == 0 || *last_len >= thresh) &&\n\t    (em->len >= thresh || !next_mergeable))\n\t\tret = 0;\nout:\n\t/*\n\t * last_len ends up being a counter of how many bytes we've defragged.\n\t * every time we choose not to defrag an extent, we reset *last_len\n\t * so that the next tiny extent will force a defrag.\n\t *\n\t * The end result of this is that tiny extents before a single big\n\t * extent will force at least part of that big extent to be defragged.\n\t */\n\tif (ret) {\n\t\t*defrag_end = extent_map_end(em);\n\t} else {\n\t\t*last_len = 0;\n\t\t*skip = extent_map_end(em);\n\t\t*defrag_end = 0;\n\t}\n\n\tfree_extent_map(em);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int should_defrag_range(struct inode *inode, u64 start, u32 thresh,\n\t\t\t       u64 *last_len, u64 *skip, u64 *defrag_end,\n\t\t\t       int compress)\n{\n\tstruct extent_map *em;\n\tint ret = 1;\n\tbool next_mergeable = true;\n\n\t/*\n\t * make sure that once we start defragging an extent, we keep on\n\t * defragging it\n\t */\n\tif (start < *defrag_end)\n\t\treturn 1;\n\n\t*skip = 0;\n\n\tem = defrag_lookup_extent(inode, start);\n\tif (!em)\n\t\treturn 0;\n\n\t/* this will cover holes, and inline extents */\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tnext_mergeable = defrag_check_next_extent(inode, em);\n\t/*\n\t * we hit a real extent, if it is big or the next extent is not a\n\t * real extent, don't bother defragging it\n\t */\n\tif (!compress && (*last_len == 0 || *last_len >= thresh) &&\n\t    (em->len >= thresh || !next_mergeable))\n\t\tret = 0;\nout:\n\t/*\n\t * last_len ends up being a counter of how many bytes we've defragged.\n\t * every time we choose not to defrag an extent, we reset *last_len\n\t * so that the next tiny extent will force a defrag.\n\t *\n\t * The end result of this is that tiny extents before a single big\n\t * extent will force at least part of that big extent to be defragged.\n\t */\n\tif (ret) {\n\t\t*defrag_end = extent_map_end(em);\n\t} else {\n\t\t*last_len = 0;\n\t\t*skip = extent_map_end(em);\n\t\t*defrag_end = 0;\n\t}\n\n\tfree_extent_map(em);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"BTRFS: defrag_file cancelled\\n\""
          ],
          "line": 1333
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_defrag_cancelled",
          "args": [
            "root->fs_info"
          ],
          "line": 1332
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_defrag_cancelled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "4188-4191",
          "snippet": "static inline int btrfs_defrag_cancelled(struct btrfs_fs_info *fs_info)\n{\n\treturn signal_pending(current);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_defrag_cancelled(struct btrfs_fs_info *fs_info)\n{\n\treturn signal_pending(current);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "i_size_read(inode)",
            "PAGE_CACHE_SIZE"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u64",
            "isize - 1",
            "range->start + range->len - 1"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "max_cluster",
            "sizeof(struct page *)",
            "GFP_NOFS"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_ra_state_init",
          "args": [
            "ra",
            "inode->i_mapping"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*ra)",
            "GFP_NOFS"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nint btrfs_defrag_file(struct inode *inode, struct file *file,\n\t\t      struct btrfs_ioctl_defrag_range_args *range,\n\t\t      u64 newer_than, unsigned long max_to_defrag)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct file_ra_state *ra = NULL;\n\tunsigned long last_index;\n\tu64 isize = i_size_read(inode);\n\tu64 last_len = 0;\n\tu64 skip = 0;\n\tu64 defrag_end = 0;\n\tu64 newer_off = range->start;\n\tunsigned long i;\n\tunsigned long ra_index = 0;\n\tint ret;\n\tint defrag_count = 0;\n\tint compress_type = BTRFS_COMPRESS_ZLIB;\n\tu32 extent_thresh = range->extent_thresh;\n\tunsigned long max_cluster = (256 * 1024) >> PAGE_CACHE_SHIFT;\n\tunsigned long cluster = max_cluster;\n\tu64 new_align = ~((u64)128 * 1024 - 1);\n\tstruct page **pages = NULL;\n\n\tif (isize == 0)\n\t\treturn 0;\n\n\tif (range->start >= isize)\n\t\treturn -EINVAL;\n\n\tif (range->flags & BTRFS_DEFRAG_RANGE_COMPRESS) {\n\t\tif (range->compress_type > BTRFS_COMPRESS_TYPES)\n\t\t\treturn -EINVAL;\n\t\tif (range->compress_type)\n\t\t\tcompress_type = range->compress_type;\n\t}\n\n\tif (extent_thresh == 0)\n\t\textent_thresh = 256 * 1024;\n\n\t/*\n\t * if we were not given a file, allocate a readahead\n\t * context\n\t */\n\tif (!file) {\n\t\tra = kzalloc(sizeof(*ra), GFP_NOFS);\n\t\tif (!ra)\n\t\t\treturn -ENOMEM;\n\t\tfile_ra_state_init(ra, inode->i_mapping);\n\t} else {\n\t\tra = &file->f_ra;\n\t}\n\n\tpages = kmalloc_array(max_cluster, sizeof(struct page *),\n\t\t\tGFP_NOFS);\n\tif (!pages) {\n\t\tret = -ENOMEM;\n\t\tgoto out_ra;\n\t}\n\n\t/* find the last page to defrag */\n\tif (range->start + range->len > range->start) {\n\t\tlast_index = min_t(u64, isize - 1,\n\t\t\t range->start + range->len - 1) >> PAGE_CACHE_SHIFT;\n\t} else {\n\t\tlast_index = (isize - 1) >> PAGE_CACHE_SHIFT;\n\t}\n\n\tif (newer_than) {\n\t\tret = find_new_extents(root, inode, newer_than,\n\t\t\t\t       &newer_off, 64 * 1024);\n\t\tif (!ret) {\n\t\t\trange->start = newer_off;\n\t\t\t/*\n\t\t\t * we always align our defrag to help keep\n\t\t\t * the extents in the file evenly spaced\n\t\t\t */\n\t\t\ti = (newer_off & new_align) >> PAGE_CACHE_SHIFT;\n\t\t} else\n\t\t\tgoto out_ra;\n\t} else {\n\t\ti = range->start >> PAGE_CACHE_SHIFT;\n\t}\n\tif (!max_to_defrag)\n\t\tmax_to_defrag = last_index + 1;\n\n\t/*\n\t * make writeback starts from i, so the defrag range can be\n\t * written sequentially.\n\t */\n\tif (i < inode->i_mapping->writeback_index)\n\t\tinode->i_mapping->writeback_index = i;\n\n\twhile (i <= last_index && defrag_count < max_to_defrag &&\n\t       (i < DIV_ROUND_UP(i_size_read(inode), PAGE_CACHE_SIZE))) {\n\t\t/*\n\t\t * make sure we stop running if someone unmounts\n\t\t * the FS\n\t\t */\n\t\tif (!(inode->i_sb->s_flags & MS_ACTIVE))\n\t\t\tbreak;\n\n\t\tif (btrfs_defrag_cancelled(root->fs_info)) {\n\t\t\tprintk(KERN_DEBUG \"BTRFS: defrag_file cancelled\\n\");\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!should_defrag_range(inode, (u64)i << PAGE_CACHE_SHIFT,\n\t\t\t\t\t extent_thresh, &last_len, &skip,\n\t\t\t\t\t &defrag_end, range->flags &\n\t\t\t\t\t BTRFS_DEFRAG_RANGE_COMPRESS)) {\n\t\t\tunsigned long next;\n\t\t\t/*\n\t\t\t * the should_defrag function tells us how much to skip\n\t\t\t * bump our counter by the suggested amount\n\t\t\t */\n\t\t\tnext = DIV_ROUND_UP(skip, PAGE_CACHE_SIZE);\n\t\t\ti = max(i + 1, next);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!newer_than) {\n\t\t\tcluster = (PAGE_CACHE_ALIGN(defrag_end) >>\n\t\t\t\t   PAGE_CACHE_SHIFT) - i;\n\t\t\tcluster = min(cluster, max_cluster);\n\t\t} else {\n\t\t\tcluster = max_cluster;\n\t\t}\n\n\t\tif (i + cluster > ra_index) {\n\t\t\tra_index = max(i, ra_index);\n\t\t\tbtrfs_force_ra(inode->i_mapping, ra, file, ra_index,\n\t\t\t\t       cluster);\n\t\t\tra_index += max_cluster;\n\t\t}\n\n\t\tmutex_lock(&inode->i_mutex);\n\t\tif (range->flags & BTRFS_DEFRAG_RANGE_COMPRESS)\n\t\t\tBTRFS_I(inode)->force_compress = compress_type;\n\t\tret = cluster_pages_for_defrag(inode, pages, i, cluster);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\tgoto out_ra;\n\t\t}\n\n\t\tdefrag_count += ret;\n\t\tbalance_dirty_pages_ratelimited(inode->i_mapping);\n\t\tmutex_unlock(&inode->i_mutex);\n\n\t\tif (newer_than) {\n\t\t\tif (newer_off == (u64)-1)\n\t\t\t\tbreak;\n\n\t\t\tif (ret > 0)\n\t\t\t\ti += ret;\n\n\t\t\tnewer_off = max(newer_off + 1,\n\t\t\t\t\t(u64)i << PAGE_CACHE_SHIFT);\n\n\t\t\tret = find_new_extents(root, inode,\n\t\t\t\t\t       newer_than, &newer_off,\n\t\t\t\t\t       64 * 1024);\n\t\t\tif (!ret) {\n\t\t\t\trange->start = newer_off;\n\t\t\t\ti = (newer_off & new_align) >> PAGE_CACHE_SHIFT;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (ret > 0) {\n\t\t\t\ti += ret;\n\t\t\t\tlast_len += ret << PAGE_CACHE_SHIFT;\n\t\t\t} else {\n\t\t\t\ti++;\n\t\t\t\tlast_len = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((range->flags & BTRFS_DEFRAG_RANGE_START_IO)) {\n\t\tfilemap_flush(inode->i_mapping);\n\t\tif (test_bit(BTRFS_INODE_HAS_ASYNC_EXTENT,\n\t\t\t     &BTRFS_I(inode)->runtime_flags))\n\t\t\tfilemap_flush(inode->i_mapping);\n\t}\n\n\tif ((range->flags & BTRFS_DEFRAG_RANGE_COMPRESS)) {\n\t\t/* the filemap_flush will queue IO into the worker threads, but\n\t\t * we have to make sure the IO is actually started and that\n\t\t * ordered extents get created before we return\n\t\t */\n\t\tatomic_inc(&root->fs_info->async_submit_draining);\n\t\twhile (atomic_read(&root->fs_info->nr_async_submits) ||\n\t\t      atomic_read(&root->fs_info->async_delalloc_pages)) {\n\t\t\twait_event(root->fs_info->async_submit_wait,\n\t\t\t   (atomic_read(&root->fs_info->nr_async_submits) == 0 &&\n\t\t\t    atomic_read(&root->fs_info->async_delalloc_pages) == 0));\n\t\t}\n\t\tatomic_dec(&root->fs_info->async_submit_draining);\n\t}\n\n\tif (range->compress_type == BTRFS_COMPRESS_LZO) {\n\t\tbtrfs_set_fs_incompat(root->fs_info, COMPRESS_LZO);\n\t}\n\n\tret = defrag_count;\n\nout_ra:\n\tif (range->flags & BTRFS_DEFRAG_RANGE_COMPRESS) {\n\t\tmutex_lock(&inode->i_mutex);\n\t\tBTRFS_I(inode)->force_compress = BTRFS_COMPRESS_NONE;\n\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\tif (!file)\n\t\tkfree(ra);\n\tkfree(pages);\n\treturn ret;\n}"
  },
  {
    "function_name": "cluster_pages_for_defrag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "1086-1229",
    "snippet": "static int cluster_pages_for_defrag(struct inode *inode,\n\t\t\t\t    struct page **pages,\n\t\t\t\t    unsigned long start_index,\n\t\t\t\t    unsigned long num_pages)\n{\n\tunsigned long file_end;\n\tu64 isize = i_size_read(inode);\n\tu64 page_start;\n\tu64 page_end;\n\tu64 page_cnt;\n\tint ret;\n\tint i;\n\tint i_done;\n\tstruct btrfs_ordered_extent *ordered;\n\tstruct extent_state *cached_state = NULL;\n\tstruct extent_io_tree *tree;\n\tgfp_t mask = btrfs_alloc_write_mask(inode->i_mapping);\n\n\tfile_end = (isize - 1) >> PAGE_CACHE_SHIFT;\n\tif (!isize || start_index > file_end)\n\t\treturn 0;\n\n\tpage_cnt = min_t(u64, (u64)num_pages, (u64)file_end - start_index + 1);\n\n\tret = btrfs_delalloc_reserve_space(inode,\n\t\t\t\t\t   page_cnt << PAGE_CACHE_SHIFT);\n\tif (ret)\n\t\treturn ret;\n\ti_done = 0;\n\ttree = &BTRFS_I(inode)->io_tree;\n\n\t/* step one, lock all the pages */\n\tfor (i = 0; i < page_cnt; i++) {\n\t\tstruct page *page;\nagain:\n\t\tpage = find_or_create_page(inode->i_mapping,\n\t\t\t\t\t   start_index + i, mask);\n\t\tif (!page)\n\t\t\tbreak;\n\n\t\tpage_start = page_offset(page);\n\t\tpage_end = page_start + PAGE_CACHE_SIZE - 1;\n\t\twhile (1) {\n\t\t\tlock_extent_bits(tree, page_start, page_end,\n\t\t\t\t\t 0, &cached_state);\n\t\t\tordered = btrfs_lookup_ordered_extent(inode,\n\t\t\t\t\t\t\t      page_start);\n\t\t\tunlock_extent_cached(tree, page_start, page_end,\n\t\t\t\t\t     &cached_state, GFP_NOFS);\n\t\t\tif (!ordered)\n\t\t\t\tbreak;\n\n\t\t\tunlock_page(page);\n\t\t\tbtrfs_start_ordered_extent(inode, ordered, 1);\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tlock_page(page);\n\t\t\t/*\n\t\t\t * we unlocked the page above, so we need check if\n\t\t\t * it was released or not.\n\t\t\t */\n\t\t\tif (page->mapping != inode->i_mapping) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tpage_cache_release(page);\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t}\n\n\t\tif (!PageUptodate(page)) {\n\t\t\tbtrfs_readpage(NULL, page);\n\t\t\tlock_page(page);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tpage_cache_release(page);\n\t\t\t\tret = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (page->mapping != inode->i_mapping) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tgoto again;\n\t\t}\n\n\t\tpages[i] = page;\n\t\ti_done++;\n\t}\n\tif (!i_done || ret)\n\t\tgoto out;\n\n\tif (!(inode->i_sb->s_flags & MS_ACTIVE))\n\t\tgoto out;\n\n\t/*\n\t * so now we have a nice long stream of locked\n\t * and up to date pages, lets wait on them\n\t */\n\tfor (i = 0; i < i_done; i++)\n\t\twait_on_page_writeback(pages[i]);\n\n\tpage_start = page_offset(pages[0]);\n\tpage_end = page_offset(pages[i_done - 1]) + PAGE_CACHE_SIZE;\n\n\tlock_extent_bits(&BTRFS_I(inode)->io_tree,\n\t\t\t page_start, page_end - 1, 0, &cached_state);\n\tclear_extent_bit(&BTRFS_I(inode)->io_tree, page_start,\n\t\t\t  page_end - 1, EXTENT_DIRTY | EXTENT_DELALLOC |\n\t\t\t  EXTENT_DO_ACCOUNTING | EXTENT_DEFRAG, 0, 0,\n\t\t\t  &cached_state, GFP_NOFS);\n\n\tif (i_done != page_cnt) {\n\t\tspin_lock(&BTRFS_I(inode)->lock);\n\t\tBTRFS_I(inode)->outstanding_extents++;\n\t\tspin_unlock(&BTRFS_I(inode)->lock);\n\t\tbtrfs_delalloc_release_space(inode,\n\t\t\t\t     (page_cnt - i_done) << PAGE_CACHE_SHIFT);\n\t}\n\n\n\tset_extent_defrag(&BTRFS_I(inode)->io_tree, page_start, page_end - 1,\n\t\t\t  &cached_state, GFP_NOFS);\n\n\tunlock_extent_cached(&BTRFS_I(inode)->io_tree,\n\t\t\t     page_start, page_end - 1, &cached_state,\n\t\t\t     GFP_NOFS);\n\n\tfor (i = 0; i < i_done; i++) {\n\t\tclear_page_dirty_for_io(pages[i]);\n\t\tClearPageChecked(pages[i]);\n\t\tset_page_extent_mapped(pages[i]);\n\t\tset_page_dirty(pages[i]);\n\t\tunlock_page(pages[i]);\n\t\tpage_cache_release(pages[i]);\n\t}\n\treturn i_done;\nout:\n\tfor (i = 0; i < i_done; i++) {\n\t\tunlock_page(pages[i]);\n\t\tpage_cache_release(pages[i]);\n\t}\n\tbtrfs_delalloc_release_space(inode, page_cnt << PAGE_CACHE_SHIFT);\n\treturn ret;\n\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_delalloc_release_space",
          "args": [
            "inode",
            "page_cnt << PAGE_CACHE_SHIFT"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_delalloc_release_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "5347-5351",
          "snippet": "void btrfs_delalloc_release_space(struct inode *inode, u64 num_bytes)\n{\n\tbtrfs_delalloc_release_metadata(inode, num_bytes);\n\tbtrfs_free_reserved_data_space(inode, num_bytes);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nstatic noinline struct;\n\nvoid btrfs_delalloc_release_space(struct inode *inode, u64 num_bytes)\n{\n\tbtrfs_delalloc_release_metadata(inode, num_bytes);\n\tbtrfs_free_reserved_data_space(inode, num_bytes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "pages[i]"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "pages[i]"
          ],
          "line": 1223
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "pages[i]"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "pages[i]"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "9538-9541",
          "snippet": "static int btrfs_set_page_dirty(struct page *page)\n{\n\treturn __set_page_dirty_nobuffers(page);\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_set_page_dirty(struct page *page)\n{\n\treturn __set_page_dirty_nobuffers(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_extent_mapped",
          "args": [
            "pages[i]"
          ],
          "line": 1215
        },
        "resolved": true,
        "details": {
          "function_name": "set_page_extent_mapped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2862-2869",
          "snippet": "void set_page_extent_mapped(struct page *page)\n{\n\tif (!PagePrivate(page)) {\n\t\tSetPagePrivate(page);\n\t\tpage_cache_get(page);\n\t\tset_page_private(page, EXTENT_PAGE_PRIVATE);\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid set_page_extent_mapped(struct page *page)\n{\n\tif (!PagePrivate(page)) {\n\t\tSetPagePrivate(page);\n\t\tpage_cache_get(page);\n\t\tset_page_private(page, EXTENT_PAGE_PRIVATE);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPageChecked",
          "args": [
            "pages[i]"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_page_dirty_for_io",
          "args": [
            "pages[i]"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_extent_cached",
          "args": [
            "&BTRFS_I(inode)->io_tree",
            "page_start",
            "page_end - 1",
            "&cached_state",
            "GFP_NOFS"
          ],
          "line": 1208
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_extent_cached",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1373-1378",
          "snippet": "int unlock_extent_cached(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t\t struct extent_state **cached, gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, cached,\n\t\t\t\tmask);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint unlock_extent_cached(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t\t struct extent_state **cached, gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, cached,\n\t\t\t\tmask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 1208
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_extent_defrag",
          "args": [
            "&BTRFS_I(inode)->io_tree",
            "page_start",
            "page_end - 1",
            "&cached_state",
            "GFP_NOFS"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "set_extent_defrag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1291-1297",
          "snippet": "int set_extent_defrag(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t      struct extent_state **cached_state, gfp_t mask)\n{\n\treturn set_extent_bit(tree, start, end,\n\t\t\t      EXTENT_DELALLOC | EXTENT_UPTODATE | EXTENT_DEFRAG,\n\t\t\t      NULL, cached_state, mask);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint set_extent_defrag(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t      struct extent_state **cached_state, gfp_t mask)\n{\n\treturn set_extent_bit(tree, start, end,\n\t\t\t      EXTENT_DELALLOC | EXTENT_UPTODATE | EXTENT_DEFRAG,\n\t\t\t      NULL, cached_state, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&BTRFS_I(inode)->lock"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&BTRFS_I(inode)->lock"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_extent_bit",
          "args": [
            "&BTRFS_I(inode)->io_tree",
            "page_start",
            "page_end - 1",
            "EXTENT_DIRTY | EXTENT_DELALLOC |\n\t\t\t  EXTENT_DO_ACCOUNTING | EXTENT_DEFRAG",
            "0",
            "0",
            "&cached_state",
            "GFP_NOFS"
          ],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "clear_extent_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "572-724",
          "snippet": "int clear_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, int wake, int delete,\n\t\t     struct extent_state **cached_state,\n\t\t     gfp_t mask)\n{\n\tstruct extent_state *state;\n\tstruct extent_state *cached;\n\tstruct extent_state *prealloc = NULL;\n\tstruct rb_node *node;\n\tu64 last_end;\n\tint err;\n\tint clear = 0;\n\n\tbtrfs_debug_check_extent_io_range(tree, start, end);\n\n\tif (bits & EXTENT_DELALLOC)\n\t\tbits |= EXTENT_NORESERVE;\n\n\tif (delete)\n\t\tbits |= ~EXTENT_CTLBITS;\n\tbits |= EXTENT_FIRST_DELALLOC;\n\n\tif (bits & (EXTENT_IOBITS | EXTENT_BOUNDARY))\n\t\tclear = 1;\nagain:\n\tif (!prealloc && (mask & __GFP_WAIT)) {\n\t\t/*\n\t\t * Don't care for allocation failure here because we might end\n\t\t * up not needing the pre-allocated extent state at all, which\n\t\t * is the case if we only have in the tree extent states that\n\t\t * cover our input range and don't cover too any other range.\n\t\t * If we end up needing a new extent state we allocate it later.\n\t\t */\n\t\tprealloc = alloc_extent_state(mask);\n\t}\n\n\tspin_lock(&tree->lock);\n\tif (cached_state) {\n\t\tcached = *cached_state;\n\n\t\tif (clear) {\n\t\t\t*cached_state = NULL;\n\t\t\tcached_state = NULL;\n\t\t}\n\n\t\tif (cached && extent_state_in_tree(cached) &&\n\t\t    cached->start <= start && cached->end > start) {\n\t\t\tif (clear)\n\t\t\t\tatomic_dec(&cached->refs);\n\t\t\tstate = cached;\n\t\t\tgoto hit_next;\n\t\t}\n\t\tif (clear)\n\t\t\tfree_extent_state(cached);\n\t}\n\t/*\n\t * this search will find the extents that end after\n\t * our range starts\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node)\n\t\tgoto out;\n\tstate = rb_entry(node, struct extent_state, rb_node);\nhit_next:\n\tif (state->start > end)\n\t\tgoto out;\n\tWARN_ON(state->end < start);\n\tlast_end = state->end;\n\n\t/* the state doesn't have the wanted bits, go ahead */\n\tif (!(state->state & bits)) {\n\t\tstate = next_state(state);\n\t\tgoto next;\n\t}\n\n\t/*\n\t *     | ---- desired range ---- |\n\t *  | state | or\n\t *  | ------------- state -------------- |\n\t *\n\t * We need to split the extent we found, and may flip\n\t * bits on second half.\n\t *\n\t * If the extent we found extends past our range, we\n\t * just split and search again.  It'll get split again\n\t * the next time though.\n\t *\n\t * If the extent we found is inside our range, we clear\n\t * the desired bit on it.\n\t */\n\n\tif (state->start < start) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, start);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tprealloc = NULL;\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (state->end <= end) {\n\t\t\tstate = clear_state_bit(tree, state, &bits, wake);\n\t\t\tgoto next;\n\t\t}\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *                        | state |\n\t * We need to split the extent, and clear the bit\n\t * on the first half\n\t */\n\tif (state->start <= end && state->end > end) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, end + 1);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tif (wake)\n\t\t\twake_up(&state->wq);\n\n\t\tclear_state_bit(tree, prealloc, &bits, wake);\n\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\n\tstate = clear_state_bit(tree, state, &bits, wake);\nnext:\n\tif (last_end == (u64)-1)\n\t\tgoto out;\n\tstart = last_end + 1;\n\tif (start <= end && state && !need_resched())\n\t\tgoto hit_next;\n\tgoto search_again;\n\nout:\n\tspin_unlock(&tree->lock);\n\tif (prealloc)\n\t\tfree_extent_state(prealloc);\n\n\treturn 0;\n\nsearch_again:\n\tif (start > end)\n\t\tgoto out;\n\tspin_unlock(&tree->lock);\n\tif (mask & __GFP_WAIT)\n\t\tcond_resched();\n\tgoto again;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint clear_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, int wake, int delete,\n\t\t     struct extent_state **cached_state,\n\t\t     gfp_t mask)\n{\n\tstruct extent_state *state;\n\tstruct extent_state *cached;\n\tstruct extent_state *prealloc = NULL;\n\tstruct rb_node *node;\n\tu64 last_end;\n\tint err;\n\tint clear = 0;\n\n\tbtrfs_debug_check_extent_io_range(tree, start, end);\n\n\tif (bits & EXTENT_DELALLOC)\n\t\tbits |= EXTENT_NORESERVE;\n\n\tif (delete)\n\t\tbits |= ~EXTENT_CTLBITS;\n\tbits |= EXTENT_FIRST_DELALLOC;\n\n\tif (bits & (EXTENT_IOBITS | EXTENT_BOUNDARY))\n\t\tclear = 1;\nagain:\n\tif (!prealloc && (mask & __GFP_WAIT)) {\n\t\t/*\n\t\t * Don't care for allocation failure here because we might end\n\t\t * up not needing the pre-allocated extent state at all, which\n\t\t * is the case if we only have in the tree extent states that\n\t\t * cover our input range and don't cover too any other range.\n\t\t * If we end up needing a new extent state we allocate it later.\n\t\t */\n\t\tprealloc = alloc_extent_state(mask);\n\t}\n\n\tspin_lock(&tree->lock);\n\tif (cached_state) {\n\t\tcached = *cached_state;\n\n\t\tif (clear) {\n\t\t\t*cached_state = NULL;\n\t\t\tcached_state = NULL;\n\t\t}\n\n\t\tif (cached && extent_state_in_tree(cached) &&\n\t\t    cached->start <= start && cached->end > start) {\n\t\t\tif (clear)\n\t\t\t\tatomic_dec(&cached->refs);\n\t\t\tstate = cached;\n\t\t\tgoto hit_next;\n\t\t}\n\t\tif (clear)\n\t\t\tfree_extent_state(cached);\n\t}\n\t/*\n\t * this search will find the extents that end after\n\t * our range starts\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node)\n\t\tgoto out;\n\tstate = rb_entry(node, struct extent_state, rb_node);\nhit_next:\n\tif (state->start > end)\n\t\tgoto out;\n\tWARN_ON(state->end < start);\n\tlast_end = state->end;\n\n\t/* the state doesn't have the wanted bits, go ahead */\n\tif (!(state->state & bits)) {\n\t\tstate = next_state(state);\n\t\tgoto next;\n\t}\n\n\t/*\n\t *     | ---- desired range ---- |\n\t *  | state | or\n\t *  | ------------- state -------------- |\n\t *\n\t * We need to split the extent we found, and may flip\n\t * bits on second half.\n\t *\n\t * If the extent we found extends past our range, we\n\t * just split and search again.  It'll get split again\n\t * the next time though.\n\t *\n\t * If the extent we found is inside our range, we clear\n\t * the desired bit on it.\n\t */\n\n\tif (state->start < start) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, start);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tprealloc = NULL;\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (state->end <= end) {\n\t\t\tstate = clear_state_bit(tree, state, &bits, wake);\n\t\t\tgoto next;\n\t\t}\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *                        | state |\n\t * We need to split the extent, and clear the bit\n\t * on the first half\n\t */\n\tif (state->start <= end && state->end > end) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, end + 1);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tif (wake)\n\t\t\twake_up(&state->wq);\n\n\t\tclear_state_bit(tree, prealloc, &bits, wake);\n\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\n\tstate = clear_state_bit(tree, state, &bits, wake);\nnext:\n\tif (last_end == (u64)-1)\n\t\tgoto out;\n\tstart = last_end + 1;\n\tif (start <= end && state && !need_resched())\n\t\tgoto hit_next;\n\tgoto search_again;\n\nout:\n\tspin_unlock(&tree->lock);\n\tif (prealloc)\n\t\tfree_extent_state(prealloc);\n\n\treturn 0;\n\nsearch_again:\n\tif (start > end)\n\t\tgoto out;\n\tspin_unlock(&tree->lock);\n\tif (mask & __GFP_WAIT)\n\t\tcond_resched();\n\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_extent_bits",
          "args": [
            "&BTRFS_I(inode)->io_tree",
            "page_start",
            "page_end - 1",
            "0",
            "&cached_state"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "lock_extent_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1332-1350",
          "snippet": "int lock_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, struct extent_state **cached_state)\n{\n\tint err;\n\tu64 failed_start;\n\n\twhile (1) {\n\t\terr = __set_extent_bit(tree, start, end, EXTENT_LOCKED | bits,\n\t\t\t\t       EXTENT_LOCKED, &failed_start,\n\t\t\t\t       cached_state, GFP_NOFS);\n\t\tif (err == -EEXIST) {\n\t\t\twait_extent_bit(tree, failed_start, end, EXTENT_LOCKED);\n\t\t\tstart = failed_start;\n\t\t} else\n\t\t\tbreak;\n\t\tWARN_ON(start > end);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint lock_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, struct extent_state **cached_state)\n{\n\tint err;\n\tu64 failed_start;\n\n\twhile (1) {\n\t\terr = __set_extent_bit(tree, start, end, EXTENT_LOCKED | bits,\n\t\t\t\t       EXTENT_LOCKED, &failed_start,\n\t\t\t\t       cached_state, GFP_NOFS);\n\t\tif (err == -EEXIST) {\n\t\t\twait_extent_bit(tree, failed_start, end, EXTENT_LOCKED);\n\t\t\tstart = failed_start;\n\t\t} else\n\t\t\tbreak;\n\t\tWARN_ON(start > end);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "pages[i_done - 1]"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "pages[0]"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_page_writeback",
          "args": [
            "pages[i]"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_readpage",
          "args": [
            "NULL",
            "page"
          ],
          "line": 1154
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_readpage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "8212-8217",
          "snippet": "int btrfs_readpage(struct file *file, struct page *page)\n{\n\tstruct extent_io_tree *tree;\n\ttree = &BTRFS_I(page->mapping->host)->io_tree;\n\treturn extent_read_full_page(tree, page, btrfs_get_extent, 0);\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nint btrfs_readpage(struct file *file, struct page *page)\n{\n\tstruct extent_io_tree *tree;\n\ttree = &BTRFS_I(page->mapping->host)->io_tree;\n\treturn extent_read_full_page(tree, page, btrfs_get_extent, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_put_ordered_extent",
          "args": [
            "ordered"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_ordered_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "540-558",
          "snippet": "void btrfs_put_ordered_extent(struct btrfs_ordered_extent *entry)\n{\n\tstruct list_head *cur;\n\tstruct btrfs_ordered_sum *sum;\n\n\ttrace_btrfs_ordered_extent_put(entry->inode, entry);\n\n\tif (atomic_dec_and_test(&entry->refs)) {\n\t\tif (entry->inode)\n\t\t\tbtrfs_add_delayed_iput(entry->inode);\n\t\twhile (!list_empty(&entry->list)) {\n\t\t\tcur = entry->list.next;\n\t\t\tsum = list_entry(cur, struct btrfs_ordered_sum, list);\n\t\t\tlist_del(&sum->list);\n\t\t\tkfree(sum);\n\t\t}\n\t\tkmem_cache_free(btrfs_ordered_extent_cache, entry);\n\t}\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *btrfs_ordered_extent_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *btrfs_ordered_extent_cache;\n\nvoid btrfs_put_ordered_extent(struct btrfs_ordered_extent *entry)\n{\n\tstruct list_head *cur;\n\tstruct btrfs_ordered_sum *sum;\n\n\ttrace_btrfs_ordered_extent_put(entry->inode, entry);\n\n\tif (atomic_dec_and_test(&entry->refs)) {\n\t\tif (entry->inode)\n\t\t\tbtrfs_add_delayed_iput(entry->inode);\n\t\twhile (!list_empty(&entry->list)) {\n\t\t\tcur = entry->list.next;\n\t\t\tsum = list_entry(cur, struct btrfs_ordered_sum, list);\n\t\t\tlist_del(&sum->list);\n\t\t\tkfree(sum);\n\t\t}\n\t\tkmem_cache_free(btrfs_ordered_extent_cache, entry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_start_ordered_extent",
          "args": [
            "inode",
            "ordered",
            "1"
          ],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_ordered_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "697-717",
          "snippet": "void btrfs_start_ordered_extent(struct inode *inode,\n\t\t\t\t       struct btrfs_ordered_extent *entry,\n\t\t\t\t       int wait)\n{\n\tu64 start = entry->file_offset;\n\tu64 end = start + entry->len - 1;\n\n\ttrace_btrfs_ordered_extent_start(inode, entry);\n\n\t/*\n\t * pages in the range can be dirty, clean or writeback.  We\n\t * start IO on any dirty ones so the wait doesn't stall waiting\n\t * for the flusher thread to find them\n\t */\n\tif (!test_bit(BTRFS_ORDERED_DIRECT, &entry->flags))\n\t\tfilemap_fdatawrite_range(inode->i_mapping, start, end);\n\tif (wait) {\n\t\twait_event(entry->wait, test_bit(BTRFS_ORDERED_COMPLETE,\n\t\t\t\t\t\t &entry->flags));\n\t}\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nvoid btrfs_start_ordered_extent(struct inode *inode,\n\t\t\t\t       struct btrfs_ordered_extent *entry,\n\t\t\t\t       int wait)\n{\n\tu64 start = entry->file_offset;\n\tu64 end = start + entry->len - 1;\n\n\ttrace_btrfs_ordered_extent_start(inode, entry);\n\n\t/*\n\t * pages in the range can be dirty, clean or writeback.  We\n\t * start IO on any dirty ones so the wait doesn't stall waiting\n\t * for the flusher thread to find them\n\t */\n\tif (!test_bit(BTRFS_ORDERED_DIRECT, &entry->flags))\n\t\tfilemap_fdatawrite_range(inode->i_mapping, start, end);\n\tif (wait) {\n\t\twait_event(entry->wait, test_bit(BTRFS_ORDERED_COMPLETE,\n\t\t\t\t\t\t &entry->flags));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_ordered_extent",
          "args": [
            "inode",
            "page_start"
          ],
          "line": 1131
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_ordered_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "777-798",
          "snippet": "struct btrfs_ordered_extent *btrfs_lookup_ordered_extent(struct inode *inode,\n\t\t\t\t\t\t\t u64 file_offset)\n{\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct rb_node *node;\n\tstruct btrfs_ordered_extent *entry = NULL;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tspin_lock_irq(&tree->lock);\n\tnode = tree_search(tree, file_offset);\n\tif (!node)\n\t\tgoto out;\n\n\tentry = rb_entry(node, struct btrfs_ordered_extent, rb_node);\n\tif (!offset_in_entry(entry, file_offset))\n\t\tentry = NULL;\n\tif (entry)\n\t\tatomic_inc(&entry->refs);\nout:\n\tspin_unlock_irq(&tree->lock);\n\treturn entry;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstruct btrfs_ordered_extent *btrfs_lookup_ordered_extent(struct inode *inode,\n\t\t\t\t\t\t\t u64 file_offset)\n{\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct rb_node *node;\n\tstruct btrfs_ordered_extent *entry = NULL;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tspin_lock_irq(&tree->lock);\n\tnode = tree_search(tree, file_offset);\n\tif (!node)\n\t\tgoto out;\n\n\tentry = rb_entry(node, struct btrfs_ordered_extent, rb_node);\n\tif (!offset_in_entry(entry, file_offset))\n\t\tentry = NULL;\n\tif (entry)\n\t\tatomic_inc(&entry->refs);\nout:\n\tspin_unlock_irq(&tree->lock);\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_or_create_page",
          "args": [
            "inode->i_mapping",
            "start_index + i",
            "mask"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_delalloc_reserve_space",
          "args": [
            "inode",
            "page_cnt << PAGE_CACHE_SHIFT"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_delalloc_reserve_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "5317-5332",
          "snippet": "int btrfs_delalloc_reserve_space(struct inode *inode, u64 num_bytes)\n{\n\tint ret;\n\n\tret = btrfs_check_data_free_space(inode, num_bytes);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_delalloc_reserve_metadata(inode, num_bytes);\n\tif (ret) {\n\t\tbtrfs_free_reserved_data_space(inode, num_bytes);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nstatic noinline struct;\n\nint btrfs_delalloc_reserve_space(struct inode *inode, u64 num_bytes)\n{\n\tint ret;\n\n\tret = btrfs_check_data_free_space(inode, num_bytes);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_delalloc_reserve_metadata(inode, num_bytes);\n\tif (ret) {\n\t\tbtrfs_free_reserved_data_space(inode, num_bytes);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u64",
            "(u64)num_pages",
            "(u64)file_end - start_index + 1"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_write_mask",
          "args": [
            "inode->i_mapping"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_write_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3292-3295",
          "snippet": "static inline gfp_t btrfs_alloc_write_mask(struct address_space *mapping)\n{\n\treturn mapping_gfp_mask(mapping) & ~__GFP_FS;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline gfp_t btrfs_alloc_write_mask(struct address_space *mapping)\n{\n\treturn mapping_gfp_mask(mapping) & ~__GFP_FS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int cluster_pages_for_defrag(struct inode *inode,\n\t\t\t\t    struct page **pages,\n\t\t\t\t    unsigned long start_index,\n\t\t\t\t    unsigned long num_pages)\n{\n\tunsigned long file_end;\n\tu64 isize = i_size_read(inode);\n\tu64 page_start;\n\tu64 page_end;\n\tu64 page_cnt;\n\tint ret;\n\tint i;\n\tint i_done;\n\tstruct btrfs_ordered_extent *ordered;\n\tstruct extent_state *cached_state = NULL;\n\tstruct extent_io_tree *tree;\n\tgfp_t mask = btrfs_alloc_write_mask(inode->i_mapping);\n\n\tfile_end = (isize - 1) >> PAGE_CACHE_SHIFT;\n\tif (!isize || start_index > file_end)\n\t\treturn 0;\n\n\tpage_cnt = min_t(u64, (u64)num_pages, (u64)file_end - start_index + 1);\n\n\tret = btrfs_delalloc_reserve_space(inode,\n\t\t\t\t\t   page_cnt << PAGE_CACHE_SHIFT);\n\tif (ret)\n\t\treturn ret;\n\ti_done = 0;\n\ttree = &BTRFS_I(inode)->io_tree;\n\n\t/* step one, lock all the pages */\n\tfor (i = 0; i < page_cnt; i++) {\n\t\tstruct page *page;\nagain:\n\t\tpage = find_or_create_page(inode->i_mapping,\n\t\t\t\t\t   start_index + i, mask);\n\t\tif (!page)\n\t\t\tbreak;\n\n\t\tpage_start = page_offset(page);\n\t\tpage_end = page_start + PAGE_CACHE_SIZE - 1;\n\t\twhile (1) {\n\t\t\tlock_extent_bits(tree, page_start, page_end,\n\t\t\t\t\t 0, &cached_state);\n\t\t\tordered = btrfs_lookup_ordered_extent(inode,\n\t\t\t\t\t\t\t      page_start);\n\t\t\tunlock_extent_cached(tree, page_start, page_end,\n\t\t\t\t\t     &cached_state, GFP_NOFS);\n\t\t\tif (!ordered)\n\t\t\t\tbreak;\n\n\t\t\tunlock_page(page);\n\t\t\tbtrfs_start_ordered_extent(inode, ordered, 1);\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tlock_page(page);\n\t\t\t/*\n\t\t\t * we unlocked the page above, so we need check if\n\t\t\t * it was released or not.\n\t\t\t */\n\t\t\tif (page->mapping != inode->i_mapping) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tpage_cache_release(page);\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t}\n\n\t\tif (!PageUptodate(page)) {\n\t\t\tbtrfs_readpage(NULL, page);\n\t\t\tlock_page(page);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tpage_cache_release(page);\n\t\t\t\tret = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (page->mapping != inode->i_mapping) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tgoto again;\n\t\t}\n\n\t\tpages[i] = page;\n\t\ti_done++;\n\t}\n\tif (!i_done || ret)\n\t\tgoto out;\n\n\tif (!(inode->i_sb->s_flags & MS_ACTIVE))\n\t\tgoto out;\n\n\t/*\n\t * so now we have a nice long stream of locked\n\t * and up to date pages, lets wait on them\n\t */\n\tfor (i = 0; i < i_done; i++)\n\t\twait_on_page_writeback(pages[i]);\n\n\tpage_start = page_offset(pages[0]);\n\tpage_end = page_offset(pages[i_done - 1]) + PAGE_CACHE_SIZE;\n\n\tlock_extent_bits(&BTRFS_I(inode)->io_tree,\n\t\t\t page_start, page_end - 1, 0, &cached_state);\n\tclear_extent_bit(&BTRFS_I(inode)->io_tree, page_start,\n\t\t\t  page_end - 1, EXTENT_DIRTY | EXTENT_DELALLOC |\n\t\t\t  EXTENT_DO_ACCOUNTING | EXTENT_DEFRAG, 0, 0,\n\t\t\t  &cached_state, GFP_NOFS);\n\n\tif (i_done != page_cnt) {\n\t\tspin_lock(&BTRFS_I(inode)->lock);\n\t\tBTRFS_I(inode)->outstanding_extents++;\n\t\tspin_unlock(&BTRFS_I(inode)->lock);\n\t\tbtrfs_delalloc_release_space(inode,\n\t\t\t\t     (page_cnt - i_done) << PAGE_CACHE_SHIFT);\n\t}\n\n\n\tset_extent_defrag(&BTRFS_I(inode)->io_tree, page_start, page_end - 1,\n\t\t\t  &cached_state, GFP_NOFS);\n\n\tunlock_extent_cached(&BTRFS_I(inode)->io_tree,\n\t\t\t     page_start, page_end - 1, &cached_state,\n\t\t\t     GFP_NOFS);\n\n\tfor (i = 0; i < i_done; i++) {\n\t\tclear_page_dirty_for_io(pages[i]);\n\t\tClearPageChecked(pages[i]);\n\t\tset_page_extent_mapped(pages[i]);\n\t\tset_page_dirty(pages[i]);\n\t\tunlock_page(pages[i]);\n\t\tpage_cache_release(pages[i]);\n\t}\n\treturn i_done;\nout:\n\tfor (i = 0; i < i_done; i++) {\n\t\tunlock_page(pages[i]);\n\t\tpage_cache_release(pages[i]);\n\t}\n\tbtrfs_delalloc_release_space(inode, page_cnt << PAGE_CACHE_SHIFT);\n\treturn ret;\n\n}"
  },
  {
    "function_name": "should_defrag_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "1018-1072",
    "snippet": "static int should_defrag_range(struct inode *inode, u64 start, u32 thresh,\n\t\t\t       u64 *last_len, u64 *skip, u64 *defrag_end,\n\t\t\t       int compress)\n{\n\tstruct extent_map *em;\n\tint ret = 1;\n\tbool next_mergeable = true;\n\n\t/*\n\t * make sure that once we start defragging an extent, we keep on\n\t * defragging it\n\t */\n\tif (start < *defrag_end)\n\t\treturn 1;\n\n\t*skip = 0;\n\n\tem = defrag_lookup_extent(inode, start);\n\tif (!em)\n\t\treturn 0;\n\n\t/* this will cover holes, and inline extents */\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tnext_mergeable = defrag_check_next_extent(inode, em);\n\t/*\n\t * we hit a real extent, if it is big or the next extent is not a\n\t * real extent, don't bother defragging it\n\t */\n\tif (!compress && (*last_len == 0 || *last_len >= thresh) &&\n\t    (em->len >= thresh || !next_mergeable))\n\t\tret = 0;\nout:\n\t/*\n\t * last_len ends up being a counter of how many bytes we've defragged.\n\t * every time we choose not to defrag an extent, we reset *last_len\n\t * so that the next tiny extent will force a defrag.\n\t *\n\t * The end result of this is that tiny extents before a single big\n\t * extent will force at least part of that big extent to be defragged.\n\t */\n\tif (ret) {\n\t\t*defrag_end = extent_map_end(em);\n\t} else {\n\t\t*last_len = 0;\n\t\t*skip = extent_map_end(em);\n\t\t*defrag_end = 0;\n\t}\n\n\tfree_extent_map(em);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_map",
          "args": [
            "em"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "70-82",
          "snippet": "void free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nvoid free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_map_end",
          "args": [
            "em"
          ],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "extent_map_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.h",
          "lines": "52-57",
          "snippet": "static inline u64 extent_map_end(struct extent_map *em)\n{\n\tif (em->start + em->len < em->start)\n\t\treturn (u64)-1;\n\treturn em->start + em->len;\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline u64 extent_map_end(struct extent_map *em)\n{\n\tif (em->start + em->len < em->start)\n\t\treturn (u64)-1;\n\treturn em->start + em->len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "defrag_check_next_extent",
          "args": [
            "inode",
            "em"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "defrag_check_next_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "998-1016",
          "snippet": "static bool defrag_check_next_extent(struct inode *inode, struct extent_map *em)\n{\n\tstruct extent_map *next;\n\tbool ret = true;\n\n\t/* this is the last extent */\n\tif (em->start + em->len >= i_size_read(inode))\n\t\treturn false;\n\n\tnext = defrag_lookup_extent(inode, em->start + em->len);\n\tif (!next || next->block_start >= EXTENT_MAP_LAST_BYTE)\n\t\tret = false;\n\telse if ((em->block_start + em->block_len == next->block_start) &&\n\t\t (em->block_len > 128 * 1024 && next->block_len > 128 * 1024))\n\t\tret = false;\n\n\tfree_extent_map(next);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic bool defrag_check_next_extent(struct inode *inode, struct extent_map *em)\n{\n\tstruct extent_map *next;\n\tbool ret = true;\n\n\t/* this is the last extent */\n\tif (em->start + em->len >= i_size_read(inode))\n\t\treturn false;\n\n\tnext = defrag_lookup_extent(inode, em->start + em->len);\n\tif (!next || next->block_start >= EXTENT_MAP_LAST_BYTE)\n\t\tret = false;\n\telse if ((em->block_start + em->block_len == next->block_start) &&\n\t\t (em->block_len > 128 * 1024 && next->block_len > 128 * 1024))\n\t\tret = false;\n\n\tfree_extent_map(next);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "defrag_lookup_extent",
          "args": [
            "inode",
            "start"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "defrag_lookup_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "967-996",
          "snippet": "static struct extent_map *defrag_lookup_extent(struct inode *inode, u64 start)\n{\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tstruct extent_io_tree *io_tree = &BTRFS_I(inode)->io_tree;\n\tstruct extent_map *em;\n\tu64 len = PAGE_CACHE_SIZE;\n\n\t/*\n\t * hopefully we have this extent in the tree already, try without\n\t * the full extent lock\n\t */\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, start, len);\n\tread_unlock(&em_tree->lock);\n\n\tif (!em) {\n\t\tstruct extent_state *cached = NULL;\n\t\tu64 end = start + len - 1;\n\n\t\t/* get the big lock and read metadata off disk */\n\t\tlock_extent_bits(io_tree, start, end, 0, &cached);\n\t\tem = btrfs_get_extent(inode, NULL, 0, start, len, 0);\n\t\tunlock_extent_cached(io_tree, start, end, &cached, GFP_NOFS);\n\n\t\tif (IS_ERR(em))\n\t\t\treturn NULL;\n\t}\n\n\treturn em;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic struct extent_map *defrag_lookup_extent(struct inode *inode, u64 start)\n{\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tstruct extent_io_tree *io_tree = &BTRFS_I(inode)->io_tree;\n\tstruct extent_map *em;\n\tu64 len = PAGE_CACHE_SIZE;\n\n\t/*\n\t * hopefully we have this extent in the tree already, try without\n\t * the full extent lock\n\t */\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, start, len);\n\tread_unlock(&em_tree->lock);\n\n\tif (!em) {\n\t\tstruct extent_state *cached = NULL;\n\t\tu64 end = start + len - 1;\n\n\t\t/* get the big lock and read metadata off disk */\n\t\tlock_extent_bits(io_tree, start, end, 0, &cached);\n\t\tem = btrfs_get_extent(inode, NULL, 0, start, len, 0);\n\t\tunlock_extent_cached(io_tree, start, end, &cached, GFP_NOFS);\n\n\t\tif (IS_ERR(em))\n\t\t\treturn NULL;\n\t}\n\n\treturn em;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int should_defrag_range(struct inode *inode, u64 start, u32 thresh,\n\t\t\t       u64 *last_len, u64 *skip, u64 *defrag_end,\n\t\t\t       int compress)\n{\n\tstruct extent_map *em;\n\tint ret = 1;\n\tbool next_mergeable = true;\n\n\t/*\n\t * make sure that once we start defragging an extent, we keep on\n\t * defragging it\n\t */\n\tif (start < *defrag_end)\n\t\treturn 1;\n\n\t*skip = 0;\n\n\tem = defrag_lookup_extent(inode, start);\n\tif (!em)\n\t\treturn 0;\n\n\t/* this will cover holes, and inline extents */\n\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tnext_mergeable = defrag_check_next_extent(inode, em);\n\t/*\n\t * we hit a real extent, if it is big or the next extent is not a\n\t * real extent, don't bother defragging it\n\t */\n\tif (!compress && (*last_len == 0 || *last_len >= thresh) &&\n\t    (em->len >= thresh || !next_mergeable))\n\t\tret = 0;\nout:\n\t/*\n\t * last_len ends up being a counter of how many bytes we've defragged.\n\t * every time we choose not to defrag an extent, we reset *last_len\n\t * so that the next tiny extent will force a defrag.\n\t *\n\t * The end result of this is that tiny extents before a single big\n\t * extent will force at least part of that big extent to be defragged.\n\t */\n\tif (ret) {\n\t\t*defrag_end = extent_map_end(em);\n\t} else {\n\t\t*last_len = 0;\n\t\t*skip = extent_map_end(em);\n\t\t*defrag_end = 0;\n\t}\n\n\tfree_extent_map(em);\n\treturn ret;\n}"
  },
  {
    "function_name": "defrag_check_next_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "998-1016",
    "snippet": "static bool defrag_check_next_extent(struct inode *inode, struct extent_map *em)\n{\n\tstruct extent_map *next;\n\tbool ret = true;\n\n\t/* this is the last extent */\n\tif (em->start + em->len >= i_size_read(inode))\n\t\treturn false;\n\n\tnext = defrag_lookup_extent(inode, em->start + em->len);\n\tif (!next || next->block_start >= EXTENT_MAP_LAST_BYTE)\n\t\tret = false;\n\telse if ((em->block_start + em->block_len == next->block_start) &&\n\t\t (em->block_len > 128 * 1024 && next->block_len > 128 * 1024))\n\t\tret = false;\n\n\tfree_extent_map(next);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_map",
          "args": [
            "next"
          ],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "70-82",
          "snippet": "void free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nvoid free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "defrag_lookup_extent",
          "args": [
            "inode",
            "em->start + em->len"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "defrag_lookup_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "967-996",
          "snippet": "static struct extent_map *defrag_lookup_extent(struct inode *inode, u64 start)\n{\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tstruct extent_io_tree *io_tree = &BTRFS_I(inode)->io_tree;\n\tstruct extent_map *em;\n\tu64 len = PAGE_CACHE_SIZE;\n\n\t/*\n\t * hopefully we have this extent in the tree already, try without\n\t * the full extent lock\n\t */\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, start, len);\n\tread_unlock(&em_tree->lock);\n\n\tif (!em) {\n\t\tstruct extent_state *cached = NULL;\n\t\tu64 end = start + len - 1;\n\n\t\t/* get the big lock and read metadata off disk */\n\t\tlock_extent_bits(io_tree, start, end, 0, &cached);\n\t\tem = btrfs_get_extent(inode, NULL, 0, start, len, 0);\n\t\tunlock_extent_cached(io_tree, start, end, &cached, GFP_NOFS);\n\n\t\tif (IS_ERR(em))\n\t\t\treturn NULL;\n\t}\n\n\treturn em;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic struct extent_map *defrag_lookup_extent(struct inode *inode, u64 start)\n{\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tstruct extent_io_tree *io_tree = &BTRFS_I(inode)->io_tree;\n\tstruct extent_map *em;\n\tu64 len = PAGE_CACHE_SIZE;\n\n\t/*\n\t * hopefully we have this extent in the tree already, try without\n\t * the full extent lock\n\t */\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, start, len);\n\tread_unlock(&em_tree->lock);\n\n\tif (!em) {\n\t\tstruct extent_state *cached = NULL;\n\t\tu64 end = start + len - 1;\n\n\t\t/* get the big lock and read metadata off disk */\n\t\tlock_extent_bits(io_tree, start, end, 0, &cached);\n\t\tem = btrfs_get_extent(inode, NULL, 0, start, len, 0);\n\t\tunlock_extent_cached(io_tree, start, end, &cached, GFP_NOFS);\n\n\t\tif (IS_ERR(em))\n\t\t\treturn NULL;\n\t}\n\n\treturn em;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic bool defrag_check_next_extent(struct inode *inode, struct extent_map *em)\n{\n\tstruct extent_map *next;\n\tbool ret = true;\n\n\t/* this is the last extent */\n\tif (em->start + em->len >= i_size_read(inode))\n\t\treturn false;\n\n\tnext = defrag_lookup_extent(inode, em->start + em->len);\n\tif (!next || next->block_start >= EXTENT_MAP_LAST_BYTE)\n\t\tret = false;\n\telse if ((em->block_start + em->block_len == next->block_start) &&\n\t\t (em->block_len > 128 * 1024 && next->block_len > 128 * 1024))\n\t\tret = false;\n\n\tfree_extent_map(next);\n\treturn ret;\n}"
  },
  {
    "function_name": "defrag_lookup_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "967-996",
    "snippet": "static struct extent_map *defrag_lookup_extent(struct inode *inode, u64 start)\n{\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tstruct extent_io_tree *io_tree = &BTRFS_I(inode)->io_tree;\n\tstruct extent_map *em;\n\tu64 len = PAGE_CACHE_SIZE;\n\n\t/*\n\t * hopefully we have this extent in the tree already, try without\n\t * the full extent lock\n\t */\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, start, len);\n\tread_unlock(&em_tree->lock);\n\n\tif (!em) {\n\t\tstruct extent_state *cached = NULL;\n\t\tu64 end = start + len - 1;\n\n\t\t/* get the big lock and read metadata off disk */\n\t\tlock_extent_bits(io_tree, start, end, 0, &cached);\n\t\tem = btrfs_get_extent(inode, NULL, 0, start, len, 0);\n\t\tunlock_extent_cached(io_tree, start, end, &cached, GFP_NOFS);\n\n\t\tif (IS_ERR(em))\n\t\t\treturn NULL;\n\t}\n\n\treturn em;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "em"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_extent_cached",
          "args": [
            "io_tree",
            "start",
            "end",
            "&cached",
            "GFP_NOFS"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_extent_cached",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1373-1378",
          "snippet": "int unlock_extent_cached(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t\t struct extent_state **cached, gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, cached,\n\t\t\t\tmask);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint unlock_extent_cached(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t\t struct extent_state **cached, gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, cached,\n\t\t\t\tmask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_get_extent",
          "args": [
            "inode",
            "NULL",
            "0",
            "start",
            "len",
            "0"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_extent_fiemap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "6744-6869",
          "snippet": "struct extent_map *btrfs_get_extent_fiemap(struct inode *inode, struct page *page,\n\t\t\t\t\t   size_t pg_offset, u64 start, u64 len,\n\t\t\t\t\t   int create)\n{\n\tstruct extent_map *em;\n\tstruct extent_map *hole_em = NULL;\n\tu64 range_start = start;\n\tu64 end;\n\tu64 found;\n\tu64 found_end;\n\tint err = 0;\n\n\tem = btrfs_get_extent(inode, page, pg_offset, start, len, create);\n\tif (IS_ERR(em))\n\t\treturn em;\n\tif (em) {\n\t\t/*\n\t\t * if our em maps to\n\t\t * -  a hole or\n\t\t * -  a pre-alloc extent,\n\t\t * there might actually be delalloc bytes behind it.\n\t\t */\n\t\tif (em->block_start != EXTENT_MAP_HOLE &&\n\t\t    !test_bit(EXTENT_FLAG_PREALLOC, &em->flags))\n\t\t\treturn em;\n\t\telse\n\t\t\thole_em = em;\n\t}\n\n\t/* check to see if we've wrapped (len == -1 or similar) */\n\tend = start + len;\n\tif (end < start)\n\t\tend = (u64)-1;\n\telse\n\t\tend -= 1;\n\n\tem = NULL;\n\n\t/* ok, we didn't find anything, lets look for delalloc */\n\tfound = count_range_bits(&BTRFS_I(inode)->io_tree, &range_start,\n\t\t\t\t end, len, EXTENT_DELALLOC, 1);\n\tfound_end = range_start + found;\n\tif (found_end < range_start)\n\t\tfound_end = (u64)-1;\n\n\t/*\n\t * we didn't find anything useful, return\n\t * the original results from get_extent()\n\t */\n\tif (range_start > end || found_end <= start) {\n\t\tem = hole_em;\n\t\thole_em = NULL;\n\t\tgoto out;\n\t}\n\n\t/* adjust the range_start to make sure it doesn't\n\t * go backwards from the start they passed in\n\t */\n\trange_start = max(start, range_start);\n\tfound = found_end - range_start;\n\n\tif (found > 0) {\n\t\tu64 hole_start = start;\n\t\tu64 hole_len = len;\n\n\t\tem = alloc_extent_map();\n\t\tif (!em) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * when btrfs_get_extent can't find anything it\n\t\t * returns one huge hole\n\t\t *\n\t\t * make sure what it found really fits our range, and\n\t\t * adjust to make sure it is based on the start from\n\t\t * the caller\n\t\t */\n\t\tif (hole_em) {\n\t\t\tu64 calc_end = extent_map_end(hole_em);\n\n\t\t\tif (calc_end <= start || (hole_em->start > end)) {\n\t\t\t\tfree_extent_map(hole_em);\n\t\t\t\thole_em = NULL;\n\t\t\t} else {\n\t\t\t\thole_start = max(hole_em->start, start);\n\t\t\t\thole_len = calc_end - hole_start;\n\t\t\t}\n\t\t}\n\t\tem->bdev = NULL;\n\t\tif (hole_em && range_start > hole_start) {\n\t\t\t/* our hole starts before our delalloc, so we\n\t\t\t * have to return just the parts of the hole\n\t\t\t * that go until  the delalloc starts\n\t\t\t */\n\t\t\tem->len = min(hole_len,\n\t\t\t\t      range_start - hole_start);\n\t\t\tem->start = hole_start;\n\t\t\tem->orig_start = hole_start;\n\t\t\t/*\n\t\t\t * don't adjust block start at all,\n\t\t\t * it is fixed at EXTENT_MAP_HOLE\n\t\t\t */\n\t\t\tem->block_start = hole_em->block_start;\n\t\t\tem->block_len = hole_len;\n\t\t\tif (test_bit(EXTENT_FLAG_PREALLOC, &hole_em->flags))\n\t\t\t\tset_bit(EXTENT_FLAG_PREALLOC, &em->flags);\n\t\t} else {\n\t\t\tem->start = range_start;\n\t\t\tem->len = found;\n\t\t\tem->orig_start = range_start;\n\t\t\tem->block_start = EXTENT_MAP_DELALLOC;\n\t\t\tem->block_len = found;\n\t\t}\n\t} else if (hole_em) {\n\t\treturn hole_em;\n\t}\nout:\n\n\tfree_extent_map(hole_em);\n\tif (err) {\n\t\tfree_extent_map(em);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn em;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nstruct extent_map *btrfs_get_extent_fiemap(struct inode *inode, struct page *page,\n\t\t\t\t\t   size_t pg_offset, u64 start, u64 len,\n\t\t\t\t\t   int create)\n{\n\tstruct extent_map *em;\n\tstruct extent_map *hole_em = NULL;\n\tu64 range_start = start;\n\tu64 end;\n\tu64 found;\n\tu64 found_end;\n\tint err = 0;\n\n\tem = btrfs_get_extent(inode, page, pg_offset, start, len, create);\n\tif (IS_ERR(em))\n\t\treturn em;\n\tif (em) {\n\t\t/*\n\t\t * if our em maps to\n\t\t * -  a hole or\n\t\t * -  a pre-alloc extent,\n\t\t * there might actually be delalloc bytes behind it.\n\t\t */\n\t\tif (em->block_start != EXTENT_MAP_HOLE &&\n\t\t    !test_bit(EXTENT_FLAG_PREALLOC, &em->flags))\n\t\t\treturn em;\n\t\telse\n\t\t\thole_em = em;\n\t}\n\n\t/* check to see if we've wrapped (len == -1 or similar) */\n\tend = start + len;\n\tif (end < start)\n\t\tend = (u64)-1;\n\telse\n\t\tend -= 1;\n\n\tem = NULL;\n\n\t/* ok, we didn't find anything, lets look for delalloc */\n\tfound = count_range_bits(&BTRFS_I(inode)->io_tree, &range_start,\n\t\t\t\t end, len, EXTENT_DELALLOC, 1);\n\tfound_end = range_start + found;\n\tif (found_end < range_start)\n\t\tfound_end = (u64)-1;\n\n\t/*\n\t * we didn't find anything useful, return\n\t * the original results from get_extent()\n\t */\n\tif (range_start > end || found_end <= start) {\n\t\tem = hole_em;\n\t\thole_em = NULL;\n\t\tgoto out;\n\t}\n\n\t/* adjust the range_start to make sure it doesn't\n\t * go backwards from the start they passed in\n\t */\n\trange_start = max(start, range_start);\n\tfound = found_end - range_start;\n\n\tif (found > 0) {\n\t\tu64 hole_start = start;\n\t\tu64 hole_len = len;\n\n\t\tem = alloc_extent_map();\n\t\tif (!em) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * when btrfs_get_extent can't find anything it\n\t\t * returns one huge hole\n\t\t *\n\t\t * make sure what it found really fits our range, and\n\t\t * adjust to make sure it is based on the start from\n\t\t * the caller\n\t\t */\n\t\tif (hole_em) {\n\t\t\tu64 calc_end = extent_map_end(hole_em);\n\n\t\t\tif (calc_end <= start || (hole_em->start > end)) {\n\t\t\t\tfree_extent_map(hole_em);\n\t\t\t\thole_em = NULL;\n\t\t\t} else {\n\t\t\t\thole_start = max(hole_em->start, start);\n\t\t\t\thole_len = calc_end - hole_start;\n\t\t\t}\n\t\t}\n\t\tem->bdev = NULL;\n\t\tif (hole_em && range_start > hole_start) {\n\t\t\t/* our hole starts before our delalloc, so we\n\t\t\t * have to return just the parts of the hole\n\t\t\t * that go until  the delalloc starts\n\t\t\t */\n\t\t\tem->len = min(hole_len,\n\t\t\t\t      range_start - hole_start);\n\t\t\tem->start = hole_start;\n\t\t\tem->orig_start = hole_start;\n\t\t\t/*\n\t\t\t * don't adjust block start at all,\n\t\t\t * it is fixed at EXTENT_MAP_HOLE\n\t\t\t */\n\t\t\tem->block_start = hole_em->block_start;\n\t\t\tem->block_len = hole_len;\n\t\t\tif (test_bit(EXTENT_FLAG_PREALLOC, &hole_em->flags))\n\t\t\t\tset_bit(EXTENT_FLAG_PREALLOC, &em->flags);\n\t\t} else {\n\t\t\tem->start = range_start;\n\t\t\tem->len = found;\n\t\t\tem->orig_start = range_start;\n\t\t\tem->block_start = EXTENT_MAP_DELALLOC;\n\t\t\tem->block_len = found;\n\t\t}\n\t} else if (hole_em) {\n\t\treturn hole_em;\n\t}\nout:\n\n\tfree_extent_map(hole_em);\n\tif (err) {\n\t\tfree_extent_map(em);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn em;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_extent_bits",
          "args": [
            "io_tree",
            "start",
            "end",
            "0",
            "&cached"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "lock_extent_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1332-1350",
          "snippet": "int lock_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, struct extent_state **cached_state)\n{\n\tint err;\n\tu64 failed_start;\n\n\twhile (1) {\n\t\terr = __set_extent_bit(tree, start, end, EXTENT_LOCKED | bits,\n\t\t\t\t       EXTENT_LOCKED, &failed_start,\n\t\t\t\t       cached_state, GFP_NOFS);\n\t\tif (err == -EEXIST) {\n\t\t\twait_extent_bit(tree, failed_start, end, EXTENT_LOCKED);\n\t\t\tstart = failed_start;\n\t\t} else\n\t\t\tbreak;\n\t\tWARN_ON(start > end);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint lock_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, struct extent_state **cached_state)\n{\n\tint err;\n\tu64 failed_start;\n\n\twhile (1) {\n\t\terr = __set_extent_bit(tree, start, end, EXTENT_LOCKED | bits,\n\t\t\t\t       EXTENT_LOCKED, &failed_start,\n\t\t\t\t       cached_state, GFP_NOFS);\n\t\tif (err == -EEXIST) {\n\t\t\twait_extent_bit(tree, failed_start, end, EXTENT_LOCKED);\n\t\t\tstart = failed_start;\n\t\t} else\n\t\t\tbreak;\n\t\tWARN_ON(start > end);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&em_tree->lock"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_extent_mapping",
          "args": [
            "em_tree",
            "start",
            "len"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_extent_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "399-403",
          "snippet": "struct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\t u64 start, u64 len)\n{\n\treturn __lookup_extent_mapping(tree, start, len, 1);\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstruct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\t u64 start, u64 len)\n{\n\treturn __lookup_extent_mapping(tree, start, len, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&em_tree->lock"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "335-338",
          "snippet": "static inline void tree_mod_log_read_lock(struct btrfs_fs_info *fs_info)\n{\n\tread_lock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_lock(struct btrfs_fs_info *fs_info)\n{\n\tread_lock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic struct extent_map *defrag_lookup_extent(struct inode *inode, u64 start)\n{\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tstruct extent_io_tree *io_tree = &BTRFS_I(inode)->io_tree;\n\tstruct extent_map *em;\n\tu64 len = PAGE_CACHE_SIZE;\n\n\t/*\n\t * hopefully we have this extent in the tree already, try without\n\t * the full extent lock\n\t */\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, start, len);\n\tread_unlock(&em_tree->lock);\n\n\tif (!em) {\n\t\tstruct extent_state *cached = NULL;\n\t\tu64 end = start + len - 1;\n\n\t\t/* get the big lock and read metadata off disk */\n\t\tlock_extent_bits(io_tree, start, end, 0, &cached);\n\t\tem = btrfs_get_extent(inode, NULL, 0, start, len, 0);\n\t\tunlock_extent_cached(io_tree, start, end, &cached, GFP_NOFS);\n\n\t\tif (IS_ERR(em))\n\t\t\treturn NULL;\n\t}\n\n\treturn em;\n}"
  },
  {
    "function_name": "find_new_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "907-965",
    "snippet": "static int find_new_extents(struct btrfs_root *root,\n\t\t\t    struct inode *inode, u64 newer_than,\n\t\t\t    u64 *off, u32 thresh)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key min_key;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_file_extent_item *extent;\n\tint type;\n\tint ret;\n\tu64 ino = btrfs_ino(inode);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tmin_key.objectid = ino;\n\tmin_key.type = BTRFS_EXTENT_DATA_KEY;\n\tmin_key.offset = *off;\n\n\twhile (1) {\n\t\tret = btrfs_search_forward(root, &min_key, path, newer_than);\n\t\tif (ret != 0)\n\t\t\tgoto none;\nprocess_slot:\n\t\tif (min_key.objectid != ino)\n\t\t\tgoto none;\n\t\tif (min_key.type != BTRFS_EXTENT_DATA_KEY)\n\t\t\tgoto none;\n\n\t\tleaf = path->nodes[0];\n\t\textent = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\tstruct btrfs_file_extent_item);\n\n\t\ttype = btrfs_file_extent_type(leaf, extent);\n\t\tif (type == BTRFS_FILE_EXTENT_REG &&\n\t\t    btrfs_file_extent_num_bytes(leaf, extent) < thresh &&\n\t\t    check_defrag_in_cache(inode, min_key.offset, thresh)) {\n\t\t\t*off = min_key.offset;\n\t\t\tbtrfs_free_path(path);\n\t\t\treturn 0;\n\t\t}\n\n\t\tpath->slots[0]++;\n\t\tif (path->slots[0] < btrfs_header_nritems(leaf)) {\n\t\t\tbtrfs_item_key_to_cpu(leaf, &min_key, path->slots[0]);\n\t\t\tgoto process_slot;\n\t\t}\n\n\t\tif (min_key.offset == (u64)-1)\n\t\t\tgoto none;\n\n\t\tmin_key.offset++;\n\t\tbtrfs_release_path(path);\n\t}\nnone:\n\tbtrfs_free_path(path);\n\treturn -ENOENT;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "leaf",
            "&min_key",
            "path->slots[0]"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "leaf"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_defrag_in_cache",
          "args": [
            "inode",
            "min_key.offset",
            "thresh"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "check_defrag_in_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "874-898",
          "snippet": "static int check_defrag_in_cache(struct inode *inode, u64 offset, u32 thresh)\n{\n\tstruct extent_io_tree *io_tree = &BTRFS_I(inode)->io_tree;\n\tstruct extent_map *em = NULL;\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tu64 end;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, offset, PAGE_CACHE_SIZE);\n\tread_unlock(&em_tree->lock);\n\n\tif (em) {\n\t\tend = extent_map_end(em);\n\t\tfree_extent_map(em);\n\t\tif (end - offset > thresh)\n\t\t\treturn 0;\n\t}\n\t/* if we already have a nice delalloc here, just stop */\n\tthresh /= 2;\n\tend = count_range_bits(io_tree, &offset, offset + thresh,\n\t\t\t       thresh, EXTENT_DELALLOC, 1);\n\tif (end >= thresh)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int check_defrag_in_cache(struct inode *inode, u64 offset, u32 thresh)\n{\n\tstruct extent_io_tree *io_tree = &BTRFS_I(inode)->io_tree;\n\tstruct extent_map *em = NULL;\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tu64 end;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, offset, PAGE_CACHE_SIZE);\n\tread_unlock(&em_tree->lock);\n\n\tif (em) {\n\t\tend = extent_map_end(em);\n\t\tfree_extent_map(em);\n\t\tif (end - offset > thresh)\n\t\t\treturn 0;\n\t}\n\t/* if we already have a nice delalloc here, just stop */\n\tthresh /= 2;\n\tend = count_range_bits(io_tree, &offset, offset + thresh,\n\t\t\t       thresh, EXTENT_DELALLOC, 1);\n\tif (end >= thresh)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_num_bytes",
          "args": [
            "leaf",
            "extent"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_type",
          "args": [
            "leaf",
            "extent"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "path->slots[0]",
            "structbtrfs_file_extent_item"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_forward",
          "args": [
            "root",
            "&min_key",
            "path",
            "newer_than"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_forward",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5113-5211",
          "snippet": "int btrfs_search_forward(struct btrfs_root *root, struct btrfs_key *min_key,\n\t\t\t struct btrfs_path *path,\n\t\t\t u64 min_trans)\n{\n\tstruct extent_buffer *cur;\n\tstruct btrfs_key found_key;\n\tint slot;\n\tint sret;\n\tu32 nritems;\n\tint level;\n\tint ret = 1;\n\tint keep_locks = path->keep_locks;\n\n\tpath->keep_locks = 1;\nagain:\n\tcur = btrfs_read_lock_root_node(root);\n\tlevel = btrfs_header_level(cur);\n\tWARN_ON(path->nodes[level]);\n\tpath->nodes[level] = cur;\n\tpath->locks[level] = BTRFS_READ_LOCK;\n\n\tif (btrfs_header_generation(cur) < min_trans) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\twhile (1) {\n\t\tnritems = btrfs_header_nritems(cur);\n\t\tlevel = btrfs_header_level(cur);\n\t\tsret = bin_search(cur, min_key, level, &slot);\n\n\t\t/* at the lowest level, we're done, setup the path and exit */\n\t\tif (level == path->lowest_level) {\n\t\t\tif (slot >= nritems)\n\t\t\t\tgoto find_next_key;\n\t\t\tret = 0;\n\t\t\tpath->slots[level] = slot;\n\t\t\tbtrfs_item_key_to_cpu(cur, &found_key, slot);\n\t\t\tgoto out;\n\t\t}\n\t\tif (sret && slot > 0)\n\t\t\tslot--;\n\t\t/*\n\t\t * check this node pointer against the min_trans parameters.\n\t\t * If it is too old, old, skip to the next one.\n\t\t */\n\t\twhile (slot < nritems) {\n\t\t\tu64 gen;\n\n\t\t\tgen = btrfs_node_ptr_generation(cur, slot);\n\t\t\tif (gen < min_trans) {\n\t\t\t\tslot++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\nfind_next_key:\n\t\t/*\n\t\t * we didn't find a candidate key in this node, walk forward\n\t\t * and find another one\n\t\t */\n\t\tif (slot >= nritems) {\n\t\t\tpath->slots[level] = slot;\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tsret = btrfs_find_next_key(root, path, min_key, level,\n\t\t\t\t\t\t  min_trans);\n\t\t\tif (sret == 0) {\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tgoto again;\n\t\t\t} else {\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\t/* save our key for returning back */\n\t\tbtrfs_node_key_to_cpu(cur, &found_key, slot);\n\t\tpath->slots[level] = slot;\n\t\tif (level == path->lowest_level) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tbtrfs_set_path_blocking(path);\n\t\tcur = read_node_slot(root, cur, slot);\n\t\tBUG_ON(!cur); /* -ENOMEM */\n\n\t\tbtrfs_tree_read_lock(cur);\n\n\t\tpath->locks[level - 1] = BTRFS_READ_LOCK;\n\t\tpath->nodes[level - 1] = cur;\n\t\tunlock_up(path, level, 1, 0, NULL);\n\t\tbtrfs_clear_path_blocking(path, NULL, 0);\n\t}\nout:\n\tpath->keep_locks = keep_locks;\n\tif (ret == 0) {\n\t\tbtrfs_unlock_up_safe(path, path->lowest_level + 1);\n\t\tbtrfs_set_path_blocking(path);\n\t\tmemcpy(min_key, &found_key, sizeof(found_key));\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_forward(struct btrfs_root *root, struct btrfs_key *min_key,\n\t\t\t struct btrfs_path *path,\n\t\t\t u64 min_trans)\n{\n\tstruct extent_buffer *cur;\n\tstruct btrfs_key found_key;\n\tint slot;\n\tint sret;\n\tu32 nritems;\n\tint level;\n\tint ret = 1;\n\tint keep_locks = path->keep_locks;\n\n\tpath->keep_locks = 1;\nagain:\n\tcur = btrfs_read_lock_root_node(root);\n\tlevel = btrfs_header_level(cur);\n\tWARN_ON(path->nodes[level]);\n\tpath->nodes[level] = cur;\n\tpath->locks[level] = BTRFS_READ_LOCK;\n\n\tif (btrfs_header_generation(cur) < min_trans) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\twhile (1) {\n\t\tnritems = btrfs_header_nritems(cur);\n\t\tlevel = btrfs_header_level(cur);\n\t\tsret = bin_search(cur, min_key, level, &slot);\n\n\t\t/* at the lowest level, we're done, setup the path and exit */\n\t\tif (level == path->lowest_level) {\n\t\t\tif (slot >= nritems)\n\t\t\t\tgoto find_next_key;\n\t\t\tret = 0;\n\t\t\tpath->slots[level] = slot;\n\t\t\tbtrfs_item_key_to_cpu(cur, &found_key, slot);\n\t\t\tgoto out;\n\t\t}\n\t\tif (sret && slot > 0)\n\t\t\tslot--;\n\t\t/*\n\t\t * check this node pointer against the min_trans parameters.\n\t\t * If it is too old, old, skip to the next one.\n\t\t */\n\t\twhile (slot < nritems) {\n\t\t\tu64 gen;\n\n\t\t\tgen = btrfs_node_ptr_generation(cur, slot);\n\t\t\tif (gen < min_trans) {\n\t\t\t\tslot++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\nfind_next_key:\n\t\t/*\n\t\t * we didn't find a candidate key in this node, walk forward\n\t\t * and find another one\n\t\t */\n\t\tif (slot >= nritems) {\n\t\t\tpath->slots[level] = slot;\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tsret = btrfs_find_next_key(root, path, min_key, level,\n\t\t\t\t\t\t  min_trans);\n\t\t\tif (sret == 0) {\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tgoto again;\n\t\t\t} else {\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\t/* save our key for returning back */\n\t\tbtrfs_node_key_to_cpu(cur, &found_key, slot);\n\t\tpath->slots[level] = slot;\n\t\tif (level == path->lowest_level) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tbtrfs_set_path_blocking(path);\n\t\tcur = read_node_slot(root, cur, slot);\n\t\tBUG_ON(!cur); /* -ENOMEM */\n\n\t\tbtrfs_tree_read_lock(cur);\n\n\t\tpath->locks[level - 1] = BTRFS_READ_LOCK;\n\t\tpath->nodes[level - 1] = cur;\n\t\tunlock_up(path, level, 1, 0, NULL);\n\t\tbtrfs_clear_path_blocking(path, NULL, 0);\n\t}\nout:\n\tpath->keep_locks = keep_locks;\n\tif (ret == 0) {\n\t\tbtrfs_unlock_up_safe(path, path->lowest_level + 1);\n\t\tbtrfs_set_path_blocking(path);\n\t\tmemcpy(min_key, &found_key, sizeof(found_key));\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ino",
          "args": [
            "inode"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_resume_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "311-316",
          "snippet": "static inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [
            "#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\n#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10\n\nstatic inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int find_new_extents(struct btrfs_root *root,\n\t\t\t    struct inode *inode, u64 newer_than,\n\t\t\t    u64 *off, u32 thresh)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key min_key;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_file_extent_item *extent;\n\tint type;\n\tint ret;\n\tu64 ino = btrfs_ino(inode);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tmin_key.objectid = ino;\n\tmin_key.type = BTRFS_EXTENT_DATA_KEY;\n\tmin_key.offset = *off;\n\n\twhile (1) {\n\t\tret = btrfs_search_forward(root, &min_key, path, newer_than);\n\t\tif (ret != 0)\n\t\t\tgoto none;\nprocess_slot:\n\t\tif (min_key.objectid != ino)\n\t\t\tgoto none;\n\t\tif (min_key.type != BTRFS_EXTENT_DATA_KEY)\n\t\t\tgoto none;\n\n\t\tleaf = path->nodes[0];\n\t\textent = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\tstruct btrfs_file_extent_item);\n\n\t\ttype = btrfs_file_extent_type(leaf, extent);\n\t\tif (type == BTRFS_FILE_EXTENT_REG &&\n\t\t    btrfs_file_extent_num_bytes(leaf, extent) < thresh &&\n\t\t    check_defrag_in_cache(inode, min_key.offset, thresh)) {\n\t\t\t*off = min_key.offset;\n\t\t\tbtrfs_free_path(path);\n\t\t\treturn 0;\n\t\t}\n\n\t\tpath->slots[0]++;\n\t\tif (path->slots[0] < btrfs_header_nritems(leaf)) {\n\t\t\tbtrfs_item_key_to_cpu(leaf, &min_key, path->slots[0]);\n\t\t\tgoto process_slot;\n\t\t}\n\n\t\tif (min_key.offset == (u64)-1)\n\t\t\tgoto none;\n\n\t\tmin_key.offset++;\n\t\tbtrfs_release_path(path);\n\t}\nnone:\n\tbtrfs_free_path(path);\n\treturn -ENOENT;\n}"
  },
  {
    "function_name": "check_defrag_in_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "874-898",
    "snippet": "static int check_defrag_in_cache(struct inode *inode, u64 offset, u32 thresh)\n{\n\tstruct extent_io_tree *io_tree = &BTRFS_I(inode)->io_tree;\n\tstruct extent_map *em = NULL;\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tu64 end;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, offset, PAGE_CACHE_SIZE);\n\tread_unlock(&em_tree->lock);\n\n\tif (em) {\n\t\tend = extent_map_end(em);\n\t\tfree_extent_map(em);\n\t\tif (end - offset > thresh)\n\t\t\treturn 0;\n\t}\n\t/* if we already have a nice delalloc here, just stop */\n\tthresh /= 2;\n\tend = count_range_bits(io_tree, &offset, offset + thresh,\n\t\t\t       thresh, EXTENT_DELALLOC, 1);\n\tif (end >= thresh)\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "count_range_bits",
          "args": [
            "io_tree",
            "&offset",
            "offset + thresh",
            "thresh",
            "EXTENT_DELALLOC",
            "1"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "count_range_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1812-1865",
          "snippet": "u64 count_range_bits(struct extent_io_tree *tree,\n\t\t     u64 *start, u64 search_end, u64 max_bytes,\n\t\t     unsigned bits, int contig)\n{\n\tstruct rb_node *node;\n\tstruct extent_state *state;\n\tu64 cur_start = *start;\n\tu64 total_bytes = 0;\n\tu64 last = 0;\n\tint found = 0;\n\n\tif (WARN_ON(search_end <= cur_start))\n\t\treturn 0;\n\n\tspin_lock(&tree->lock);\n\tif (cur_start == 0 && bits == EXTENT_DIRTY) {\n\t\ttotal_bytes = tree->dirty_bytes;\n\t\tgoto out;\n\t}\n\t/*\n\t * this search will find all the extents that end after\n\t * our range starts.\n\t */\n\tnode = tree_search(tree, cur_start);\n\tif (!node)\n\t\tgoto out;\n\n\twhile (1) {\n\t\tstate = rb_entry(node, struct extent_state, rb_node);\n\t\tif (state->start > search_end)\n\t\t\tbreak;\n\t\tif (contig && found && state->start > last + 1)\n\t\t\tbreak;\n\t\tif (state->end >= cur_start && (state->state & bits) == bits) {\n\t\t\ttotal_bytes += min(search_end, state->end) + 1 -\n\t\t\t\t       max(cur_start, state->start);\n\t\t\tif (total_bytes >= max_bytes)\n\t\t\t\tbreak;\n\t\t\tif (!found) {\n\t\t\t\t*start = max(cur_start, state->start);\n\t\t\t\tfound = 1;\n\t\t\t}\n\t\t\tlast = state->end;\n\t\t} else if (contig && found) {\n\t\t\tbreak;\n\t\t}\n\t\tnode = rb_next(node);\n\t\tif (!node)\n\t\t\tbreak;\n\t}\nout:\n\tspin_unlock(&tree->lock);\n\treturn total_bytes;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nu64 count_range_bits(struct extent_io_tree *tree,\n\t\t     u64 *start, u64 search_end, u64 max_bytes,\n\t\t     unsigned bits, int contig)\n{\n\tstruct rb_node *node;\n\tstruct extent_state *state;\n\tu64 cur_start = *start;\n\tu64 total_bytes = 0;\n\tu64 last = 0;\n\tint found = 0;\n\n\tif (WARN_ON(search_end <= cur_start))\n\t\treturn 0;\n\n\tspin_lock(&tree->lock);\n\tif (cur_start == 0 && bits == EXTENT_DIRTY) {\n\t\ttotal_bytes = tree->dirty_bytes;\n\t\tgoto out;\n\t}\n\t/*\n\t * this search will find all the extents that end after\n\t * our range starts.\n\t */\n\tnode = tree_search(tree, cur_start);\n\tif (!node)\n\t\tgoto out;\n\n\twhile (1) {\n\t\tstate = rb_entry(node, struct extent_state, rb_node);\n\t\tif (state->start > search_end)\n\t\t\tbreak;\n\t\tif (contig && found && state->start > last + 1)\n\t\t\tbreak;\n\t\tif (state->end >= cur_start && (state->state & bits) == bits) {\n\t\t\ttotal_bytes += min(search_end, state->end) + 1 -\n\t\t\t\t       max(cur_start, state->start);\n\t\t\tif (total_bytes >= max_bytes)\n\t\t\t\tbreak;\n\t\t\tif (!found) {\n\t\t\t\t*start = max(cur_start, state->start);\n\t\t\t\tfound = 1;\n\t\t\t}\n\t\t\tlast = state->end;\n\t\t} else if (contig && found) {\n\t\t\tbreak;\n\t\t}\n\t\tnode = rb_next(node);\n\t\tif (!node)\n\t\t\tbreak;\n\t}\nout:\n\tspin_unlock(&tree->lock);\n\treturn total_bytes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_extent_map",
          "args": [
            "em"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "70-82",
          "snippet": "void free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nvoid free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_map_end",
          "args": [
            "em"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "extent_map_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.h",
          "lines": "52-57",
          "snippet": "static inline u64 extent_map_end(struct extent_map *em)\n{\n\tif (em->start + em->len < em->start)\n\t\treturn (u64)-1;\n\treturn em->start + em->len;\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline u64 extent_map_end(struct extent_map *em)\n{\n\tif (em->start + em->len < em->start)\n\t\treturn (u64)-1;\n\treturn em->start + em->len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&em_tree->lock"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_extent_mapping",
          "args": [
            "em_tree",
            "offset",
            "PAGE_CACHE_SIZE"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_extent_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "399-403",
          "snippet": "struct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\t u64 start, u64 len)\n{\n\treturn __lookup_extent_mapping(tree, start, len, 1);\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstruct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\t u64 start, u64 len)\n{\n\treturn __lookup_extent_mapping(tree, start, len, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&em_tree->lock"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "335-338",
          "snippet": "static inline void tree_mod_log_read_lock(struct btrfs_fs_info *fs_info)\n{\n\tread_lock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_lock(struct btrfs_fs_info *fs_info)\n{\n\tread_lock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int check_defrag_in_cache(struct inode *inode, u64 offset, u32 thresh)\n{\n\tstruct extent_io_tree *io_tree = &BTRFS_I(inode)->io_tree;\n\tstruct extent_map *em = NULL;\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tu64 end;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, offset, PAGE_CACHE_SIZE);\n\tread_unlock(&em_tree->lock);\n\n\tif (em) {\n\t\tend = extent_map_end(em);\n\t\tfree_extent_map(em);\n\t\tif (end - offset > thresh)\n\t\t\treturn 0;\n\t}\n\t/* if we already have a nice delalloc here, just stop */\n\tthresh /= 2;\n\tend = count_range_bits(io_tree, &offset, offset + thresh,\n\t\t\t       thresh, EXTENT_DELALLOC, 1);\n\tif (end >= thresh)\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "btrfs_mksubvol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "807-865",
    "snippet": "static noinline int btrfs_mksubvol(struct path *parent,\n\t\t\t\t   char *name, int namelen,\n\t\t\t\t   struct btrfs_root *snap_src,\n\t\t\t\t   u64 *async_transid, bool readonly,\n\t\t\t\t   struct btrfs_qgroup_inherit *inherit)\n{\n\tstruct inode *dir  = parent->dentry->d_inode;\n\tstruct dentry *dentry;\n\tint error;\n\n\terror = mutex_lock_killable_nested(&dir->i_mutex, I_MUTEX_PARENT);\n\tif (error == -EINTR)\n\t\treturn error;\n\n\tdentry = lookup_one_len(name, parent->dentry, namelen);\n\terror = PTR_ERR(dentry);\n\tif (IS_ERR(dentry))\n\t\tgoto out_unlock;\n\n\terror = -EEXIST;\n\tif (dentry->d_inode)\n\t\tgoto out_dput;\n\n\terror = btrfs_may_create(dir, dentry);\n\tif (error)\n\t\tgoto out_dput;\n\n\t/*\n\t * even if this name doesn't exist, we may get hash collisions.\n\t * check for them now when we can safely fail\n\t */\n\terror = btrfs_check_dir_item_collision(BTRFS_I(dir)->root,\n\t\t\t\t\t       dir->i_ino, name,\n\t\t\t\t\t       namelen);\n\tif (error)\n\t\tgoto out_dput;\n\n\tdown_read(&BTRFS_I(dir)->root->fs_info->subvol_sem);\n\n\tif (btrfs_root_refs(&BTRFS_I(dir)->root->root_item) == 0)\n\t\tgoto out_up_read;\n\n\tif (snap_src) {\n\t\terror = create_snapshot(snap_src, dir, dentry, name, namelen,\n\t\t\t\t\tasync_transid, readonly, inherit);\n\t} else {\n\t\terror = create_subvol(dir, dentry, name, namelen,\n\t\t\t\t      async_transid, inherit);\n\t}\n\tif (!error)\n\t\tfsnotify_mkdir(dir, dentry);\nout_up_read:\n\tup_read(&BTRFS_I(dir)->root->fs_info->subvol_sem);\nout_dput:\n\tdput(dentry);\nout_unlock:\n\tmutex_unlock(&dir->i_mutex);\n\treturn error;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dir->i_mutex"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&BTRFS_I(dir)->root->fs_info->subvol_sem"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "dir"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_mkdir",
          "args": [
            "dir",
            "dentry"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_subvol",
          "args": [
            "dir",
            "dentry",
            "name",
            "namelen",
            "async_transid",
            "inherit"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "create_subvol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "431-618",
          "snippet": "static noinline int create_subvol(struct inode *dir,\n\t\t\t\t  struct dentry *dentry,\n\t\t\t\t  char *name, int namelen,\n\t\t\t\t  u64 *async_transid,\n\t\t\t\t  struct btrfs_qgroup_inherit *inherit)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_key key;\n\tstruct btrfs_root_item root_item;\n\tstruct btrfs_inode_item *inode_item;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_root *root = BTRFS_I(dir)->root;\n\tstruct btrfs_root *new_root;\n\tstruct btrfs_block_rsv block_rsv;\n\tstruct timespec cur_time = CURRENT_TIME;\n\tstruct inode *inode;\n\tint ret;\n\tint err;\n\tu64 objectid;\n\tu64 new_dirid = BTRFS_FIRST_FREE_OBJECTID;\n\tu64 index = 0;\n\tu64 qgroup_reserved;\n\tuuid_le new_uuid;\n\n\tret = btrfs_find_free_objectid(root->fs_info->tree_root, &objectid);\n\tif (ret)\n\t\treturn ret;\n\n\tbtrfs_init_block_rsv(&block_rsv, BTRFS_BLOCK_RSV_TEMP);\n\t/*\n\t * The same as the snapshot creation, please see the comment\n\t * of create_snapshot().\n\t */\n\tret = btrfs_subvolume_reserve_metadata(root, &block_rsv,\n\t\t\t\t\t       8, &qgroup_reserved, false);\n\tif (ret)\n\t\treturn ret;\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tbtrfs_subvolume_release_metadata(root, &block_rsv,\n\t\t\t\t\t\t qgroup_reserved);\n\t\treturn ret;\n\t}\n\ttrans->block_rsv = &block_rsv;\n\ttrans->bytes_reserved = block_rsv.size;\n\n\tret = btrfs_qgroup_inherit(trans, root->fs_info, 0, objectid, inherit);\n\tif (ret)\n\t\tgoto fail;\n\n\tleaf = btrfs_alloc_tree_block(trans, root, 0, objectid, NULL, 0, 0, 0);\n\tif (IS_ERR(leaf)) {\n\t\tret = PTR_ERR(leaf);\n\t\tgoto fail;\n\t}\n\n\tmemset_extent_buffer(leaf, 0, 0, sizeof(struct btrfs_header));\n\tbtrfs_set_header_bytenr(leaf, leaf->start);\n\tbtrfs_set_header_generation(leaf, trans->transid);\n\tbtrfs_set_header_backref_rev(leaf, BTRFS_MIXED_BACKREF_REV);\n\tbtrfs_set_header_owner(leaf, objectid);\n\n\twrite_extent_buffer(leaf, root->fs_info->fsid, btrfs_header_fsid(),\n\t\t\t    BTRFS_FSID_SIZE);\n\twrite_extent_buffer(leaf, root->fs_info->chunk_tree_uuid,\n\t\t\t    btrfs_header_chunk_tree_uuid(leaf),\n\t\t\t    BTRFS_UUID_SIZE);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tmemset(&root_item, 0, sizeof(root_item));\n\n\tinode_item = &root_item.inode;\n\tbtrfs_set_stack_inode_generation(inode_item, 1);\n\tbtrfs_set_stack_inode_size(inode_item, 3);\n\tbtrfs_set_stack_inode_nlink(inode_item, 1);\n\tbtrfs_set_stack_inode_nbytes(inode_item, root->nodesize);\n\tbtrfs_set_stack_inode_mode(inode_item, S_IFDIR | 0755);\n\n\tbtrfs_set_root_flags(&root_item, 0);\n\tbtrfs_set_root_limit(&root_item, 0);\n\tbtrfs_set_stack_inode_flags(inode_item, BTRFS_INODE_ROOT_ITEM_INIT);\n\n\tbtrfs_set_root_bytenr(&root_item, leaf->start);\n\tbtrfs_set_root_generation(&root_item, trans->transid);\n\tbtrfs_set_root_level(&root_item, 0);\n\tbtrfs_set_root_refs(&root_item, 1);\n\tbtrfs_set_root_used(&root_item, leaf->len);\n\tbtrfs_set_root_last_snapshot(&root_item, 0);\n\n\tbtrfs_set_root_generation_v2(&root_item,\n\t\t\tbtrfs_root_generation(&root_item));\n\tuuid_le_gen(&new_uuid);\n\tmemcpy(root_item.uuid, new_uuid.b, BTRFS_UUID_SIZE);\n\tbtrfs_set_stack_timespec_sec(&root_item.otime, cur_time.tv_sec);\n\tbtrfs_set_stack_timespec_nsec(&root_item.otime, cur_time.tv_nsec);\n\troot_item.ctime = root_item.otime;\n\tbtrfs_set_root_ctransid(&root_item, trans->transid);\n\tbtrfs_set_root_otransid(&root_item, trans->transid);\n\n\tbtrfs_tree_unlock(leaf);\n\tfree_extent_buffer(leaf);\n\tleaf = NULL;\n\n\tbtrfs_set_root_dirid(&root_item, new_dirid);\n\n\tkey.objectid = objectid;\n\tkey.offset = 0;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tret = btrfs_insert_root(trans, root->fs_info->tree_root, &key,\n\t\t\t\t&root_item);\n\tif (ret)\n\t\tgoto fail;\n\n\tkey.offset = (u64)-1;\n\tnew_root = btrfs_read_fs_root_no_name(root->fs_info, &key);\n\tif (IS_ERR(new_root)) {\n\t\tbtrfs_abort_transaction(trans, root, PTR_ERR(new_root));\n\t\tret = PTR_ERR(new_root);\n\t\tgoto fail;\n\t}\n\n\tbtrfs_record_root_in_trans(trans, new_root);\n\n\tret = btrfs_create_subvol_root(trans, new_root, root, new_dirid);\n\tif (ret) {\n\t\t/* We potentially lose an unused inode item here */\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * insert the directory item\n\t */\n\tret = btrfs_set_inode_index(dir, &index);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tret = btrfs_insert_dir_item(trans, root,\n\t\t\t\t    name, namelen, dir, &key,\n\t\t\t\t    BTRFS_FT_DIR, index);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tbtrfs_i_size_write(dir, dir->i_size + namelen * 2);\n\tret = btrfs_update_inode(trans, root, dir);\n\tBUG_ON(ret);\n\n\tret = btrfs_add_root_ref(trans, root->fs_info->tree_root,\n\t\t\t\t objectid, root->root_key.objectid,\n\t\t\t\t btrfs_ino(dir), index, name, namelen);\n\tBUG_ON(ret);\n\n\tret = btrfs_uuid_tree_add(trans, root->fs_info->uuid_root,\n\t\t\t\t  root_item.uuid, BTRFS_UUID_KEY_SUBVOL,\n\t\t\t\t  objectid);\n\tif (ret)\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\nfail:\n\ttrans->block_rsv = NULL;\n\ttrans->bytes_reserved = 0;\n\tbtrfs_subvolume_release_metadata(root, &block_rsv, qgroup_reserved);\n\n\tif (async_transid) {\n\t\t*async_transid = trans->transid;\n\t\terr = btrfs_commit_transaction_async(trans, root, 1);\n\t\tif (err)\n\t\t\terr = btrfs_commit_transaction(trans, root);\n\t} else {\n\t\terr = btrfs_commit_transaction(trans, root);\n\t}\n\tif (err && !ret)\n\t\tret = err;\n\n\tif (!ret) {\n\t\tinode = btrfs_lookup_dentry(dir, dentry);\n\t\tif (IS_ERR(inode))\n\t\t\treturn PTR_ERR(inode);\n\t\td_instantiate(dentry, inode);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic noinline int create_subvol(struct inode *dir,\n\t\t\t\t  struct dentry *dentry,\n\t\t\t\t  char *name, int namelen,\n\t\t\t\t  u64 *async_transid,\n\t\t\t\t  struct btrfs_qgroup_inherit *inherit)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_key key;\n\tstruct btrfs_root_item root_item;\n\tstruct btrfs_inode_item *inode_item;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_root *root = BTRFS_I(dir)->root;\n\tstruct btrfs_root *new_root;\n\tstruct btrfs_block_rsv block_rsv;\n\tstruct timespec cur_time = CURRENT_TIME;\n\tstruct inode *inode;\n\tint ret;\n\tint err;\n\tu64 objectid;\n\tu64 new_dirid = BTRFS_FIRST_FREE_OBJECTID;\n\tu64 index = 0;\n\tu64 qgroup_reserved;\n\tuuid_le new_uuid;\n\n\tret = btrfs_find_free_objectid(root->fs_info->tree_root, &objectid);\n\tif (ret)\n\t\treturn ret;\n\n\tbtrfs_init_block_rsv(&block_rsv, BTRFS_BLOCK_RSV_TEMP);\n\t/*\n\t * The same as the snapshot creation, please see the comment\n\t * of create_snapshot().\n\t */\n\tret = btrfs_subvolume_reserve_metadata(root, &block_rsv,\n\t\t\t\t\t       8, &qgroup_reserved, false);\n\tif (ret)\n\t\treturn ret;\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tbtrfs_subvolume_release_metadata(root, &block_rsv,\n\t\t\t\t\t\t qgroup_reserved);\n\t\treturn ret;\n\t}\n\ttrans->block_rsv = &block_rsv;\n\ttrans->bytes_reserved = block_rsv.size;\n\n\tret = btrfs_qgroup_inherit(trans, root->fs_info, 0, objectid, inherit);\n\tif (ret)\n\t\tgoto fail;\n\n\tleaf = btrfs_alloc_tree_block(trans, root, 0, objectid, NULL, 0, 0, 0);\n\tif (IS_ERR(leaf)) {\n\t\tret = PTR_ERR(leaf);\n\t\tgoto fail;\n\t}\n\n\tmemset_extent_buffer(leaf, 0, 0, sizeof(struct btrfs_header));\n\tbtrfs_set_header_bytenr(leaf, leaf->start);\n\tbtrfs_set_header_generation(leaf, trans->transid);\n\tbtrfs_set_header_backref_rev(leaf, BTRFS_MIXED_BACKREF_REV);\n\tbtrfs_set_header_owner(leaf, objectid);\n\n\twrite_extent_buffer(leaf, root->fs_info->fsid, btrfs_header_fsid(),\n\t\t\t    BTRFS_FSID_SIZE);\n\twrite_extent_buffer(leaf, root->fs_info->chunk_tree_uuid,\n\t\t\t    btrfs_header_chunk_tree_uuid(leaf),\n\t\t\t    BTRFS_UUID_SIZE);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tmemset(&root_item, 0, sizeof(root_item));\n\n\tinode_item = &root_item.inode;\n\tbtrfs_set_stack_inode_generation(inode_item, 1);\n\tbtrfs_set_stack_inode_size(inode_item, 3);\n\tbtrfs_set_stack_inode_nlink(inode_item, 1);\n\tbtrfs_set_stack_inode_nbytes(inode_item, root->nodesize);\n\tbtrfs_set_stack_inode_mode(inode_item, S_IFDIR | 0755);\n\n\tbtrfs_set_root_flags(&root_item, 0);\n\tbtrfs_set_root_limit(&root_item, 0);\n\tbtrfs_set_stack_inode_flags(inode_item, BTRFS_INODE_ROOT_ITEM_INIT);\n\n\tbtrfs_set_root_bytenr(&root_item, leaf->start);\n\tbtrfs_set_root_generation(&root_item, trans->transid);\n\tbtrfs_set_root_level(&root_item, 0);\n\tbtrfs_set_root_refs(&root_item, 1);\n\tbtrfs_set_root_used(&root_item, leaf->len);\n\tbtrfs_set_root_last_snapshot(&root_item, 0);\n\n\tbtrfs_set_root_generation_v2(&root_item,\n\t\t\tbtrfs_root_generation(&root_item));\n\tuuid_le_gen(&new_uuid);\n\tmemcpy(root_item.uuid, new_uuid.b, BTRFS_UUID_SIZE);\n\tbtrfs_set_stack_timespec_sec(&root_item.otime, cur_time.tv_sec);\n\tbtrfs_set_stack_timespec_nsec(&root_item.otime, cur_time.tv_nsec);\n\troot_item.ctime = root_item.otime;\n\tbtrfs_set_root_ctransid(&root_item, trans->transid);\n\tbtrfs_set_root_otransid(&root_item, trans->transid);\n\n\tbtrfs_tree_unlock(leaf);\n\tfree_extent_buffer(leaf);\n\tleaf = NULL;\n\n\tbtrfs_set_root_dirid(&root_item, new_dirid);\n\n\tkey.objectid = objectid;\n\tkey.offset = 0;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tret = btrfs_insert_root(trans, root->fs_info->tree_root, &key,\n\t\t\t\t&root_item);\n\tif (ret)\n\t\tgoto fail;\n\n\tkey.offset = (u64)-1;\n\tnew_root = btrfs_read_fs_root_no_name(root->fs_info, &key);\n\tif (IS_ERR(new_root)) {\n\t\tbtrfs_abort_transaction(trans, root, PTR_ERR(new_root));\n\t\tret = PTR_ERR(new_root);\n\t\tgoto fail;\n\t}\n\n\tbtrfs_record_root_in_trans(trans, new_root);\n\n\tret = btrfs_create_subvol_root(trans, new_root, root, new_dirid);\n\tif (ret) {\n\t\t/* We potentially lose an unused inode item here */\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * insert the directory item\n\t */\n\tret = btrfs_set_inode_index(dir, &index);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tret = btrfs_insert_dir_item(trans, root,\n\t\t\t\t    name, namelen, dir, &key,\n\t\t\t\t    BTRFS_FT_DIR, index);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tbtrfs_i_size_write(dir, dir->i_size + namelen * 2);\n\tret = btrfs_update_inode(trans, root, dir);\n\tBUG_ON(ret);\n\n\tret = btrfs_add_root_ref(trans, root->fs_info->tree_root,\n\t\t\t\t objectid, root->root_key.objectid,\n\t\t\t\t btrfs_ino(dir), index, name, namelen);\n\tBUG_ON(ret);\n\n\tret = btrfs_uuid_tree_add(trans, root->fs_info->uuid_root,\n\t\t\t\t  root_item.uuid, BTRFS_UUID_KEY_SUBVOL,\n\t\t\t\t  objectid);\n\tif (ret)\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\nfail:\n\ttrans->block_rsv = NULL;\n\ttrans->bytes_reserved = 0;\n\tbtrfs_subvolume_release_metadata(root, &block_rsv, qgroup_reserved);\n\n\tif (async_transid) {\n\t\t*async_transid = trans->transid;\n\t\terr = btrfs_commit_transaction_async(trans, root, 1);\n\t\tif (err)\n\t\t\terr = btrfs_commit_transaction(trans, root);\n\t} else {\n\t\terr = btrfs_commit_transaction(trans, root);\n\t}\n\tif (err && !ret)\n\t\tret = err;\n\n\tif (!ret) {\n\t\tinode = btrfs_lookup_dentry(dir, dentry);\n\t\tif (IS_ERR(inode))\n\t\t\treturn PTR_ERR(inode);\n\t\td_instantiate(dentry, inode);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_snapshot",
          "args": [
            "snap_src",
            "dir",
            "dentry",
            "name",
            "namelen",
            "async_transid",
            "readonly",
            "inherit"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "create_snapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "637-738",
          "snippet": "static int create_snapshot(struct btrfs_root *root, struct inode *dir,\n\t\t\t   struct dentry *dentry, char *name, int namelen,\n\t\t\t   u64 *async_transid, bool readonly,\n\t\t\t   struct btrfs_qgroup_inherit *inherit)\n{\n\tstruct inode *inode;\n\tstruct btrfs_pending_snapshot *pending_snapshot;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\n\tif (!test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\treturn -EINVAL;\n\n\tatomic_inc(&root->will_be_snapshoted);\n\tsmp_mb__after_atomic();\n\tbtrfs_wait_for_no_snapshoting_writes(root);\n\n\tret = btrfs_start_delalloc_inodes(root, 0);\n\tif (ret)\n\t\tgoto out;\n\n\tbtrfs_wait_ordered_extents(root, -1);\n\n\tpending_snapshot = kzalloc(sizeof(*pending_snapshot), GFP_NOFS);\n\tif (!pending_snapshot) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tbtrfs_init_block_rsv(&pending_snapshot->block_rsv,\n\t\t\t     BTRFS_BLOCK_RSV_TEMP);\n\t/*\n\t * 1 - parent dir inode\n\t * 2 - dir entries\n\t * 1 - root item\n\t * 2 - root ref/backref\n\t * 1 - root of snapshot\n\t * 1 - UUID item\n\t */\n\tret = btrfs_subvolume_reserve_metadata(BTRFS_I(dir)->root,\n\t\t\t\t\t&pending_snapshot->block_rsv, 8,\n\t\t\t\t\t&pending_snapshot->qgroup_reserved,\n\t\t\t\t\tfalse);\n\tif (ret)\n\t\tgoto free;\n\n\tpending_snapshot->dentry = dentry;\n\tpending_snapshot->root = root;\n\tpending_snapshot->readonly = readonly;\n\tpending_snapshot->dir = dir;\n\tpending_snapshot->inherit = inherit;\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto fail;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_add(&pending_snapshot->list,\n\t\t &trans->transaction->pending_snapshots);\n\tspin_unlock(&root->fs_info->trans_lock);\n\tif (async_transid) {\n\t\t*async_transid = trans->transid;\n\t\tret = btrfs_commit_transaction_async(trans,\n\t\t\t\t     root->fs_info->extent_root, 1);\n\t\tif (ret)\n\t\t\tret = btrfs_commit_transaction(trans, root);\n\t} else {\n\t\tret = btrfs_commit_transaction(trans,\n\t\t\t\t\t       root->fs_info->extent_root);\n\t}\n\tif (ret)\n\t\tgoto fail;\n\n\tret = pending_snapshot->error;\n\tif (ret)\n\t\tgoto fail;\n\n\tret = btrfs_orphan_cleanup(pending_snapshot->snap);\n\tif (ret)\n\t\tgoto fail;\n\n\tinode = btrfs_lookup_dentry(dentry->d_parent->d_inode, dentry);\n\tif (IS_ERR(inode)) {\n\t\tret = PTR_ERR(inode);\n\t\tgoto fail;\n\t}\n\n\td_instantiate(dentry, inode);\n\tret = 0;\nfail:\n\tbtrfs_subvolume_release_metadata(BTRFS_I(dir)->root,\n\t\t\t\t\t &pending_snapshot->block_rsv,\n\t\t\t\t\t pending_snapshot->qgroup_reserved);\nfree:\n\tkfree(pending_snapshot);\nout:\n\tif (atomic_dec_and_test(&root->will_be_snapshoted))\n\t\twake_up_atomic_t(&root->will_be_snapshoted);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int create_snapshot(struct btrfs_root *root, struct inode *dir,\n\t\t\t   struct dentry *dentry, char *name, int namelen,\n\t\t\t   u64 *async_transid, bool readonly,\n\t\t\t   struct btrfs_qgroup_inherit *inherit)\n{\n\tstruct inode *inode;\n\tstruct btrfs_pending_snapshot *pending_snapshot;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\n\tif (!test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\treturn -EINVAL;\n\n\tatomic_inc(&root->will_be_snapshoted);\n\tsmp_mb__after_atomic();\n\tbtrfs_wait_for_no_snapshoting_writes(root);\n\n\tret = btrfs_start_delalloc_inodes(root, 0);\n\tif (ret)\n\t\tgoto out;\n\n\tbtrfs_wait_ordered_extents(root, -1);\n\n\tpending_snapshot = kzalloc(sizeof(*pending_snapshot), GFP_NOFS);\n\tif (!pending_snapshot) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tbtrfs_init_block_rsv(&pending_snapshot->block_rsv,\n\t\t\t     BTRFS_BLOCK_RSV_TEMP);\n\t/*\n\t * 1 - parent dir inode\n\t * 2 - dir entries\n\t * 1 - root item\n\t * 2 - root ref/backref\n\t * 1 - root of snapshot\n\t * 1 - UUID item\n\t */\n\tret = btrfs_subvolume_reserve_metadata(BTRFS_I(dir)->root,\n\t\t\t\t\t&pending_snapshot->block_rsv, 8,\n\t\t\t\t\t&pending_snapshot->qgroup_reserved,\n\t\t\t\t\tfalse);\n\tif (ret)\n\t\tgoto free;\n\n\tpending_snapshot->dentry = dentry;\n\tpending_snapshot->root = root;\n\tpending_snapshot->readonly = readonly;\n\tpending_snapshot->dir = dir;\n\tpending_snapshot->inherit = inherit;\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto fail;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_add(&pending_snapshot->list,\n\t\t &trans->transaction->pending_snapshots);\n\tspin_unlock(&root->fs_info->trans_lock);\n\tif (async_transid) {\n\t\t*async_transid = trans->transid;\n\t\tret = btrfs_commit_transaction_async(trans,\n\t\t\t\t     root->fs_info->extent_root, 1);\n\t\tif (ret)\n\t\t\tret = btrfs_commit_transaction(trans, root);\n\t} else {\n\t\tret = btrfs_commit_transaction(trans,\n\t\t\t\t\t       root->fs_info->extent_root);\n\t}\n\tif (ret)\n\t\tgoto fail;\n\n\tret = pending_snapshot->error;\n\tif (ret)\n\t\tgoto fail;\n\n\tret = btrfs_orphan_cleanup(pending_snapshot->snap);\n\tif (ret)\n\t\tgoto fail;\n\n\tinode = btrfs_lookup_dentry(dentry->d_parent->d_inode, dentry);\n\tif (IS_ERR(inode)) {\n\t\tret = PTR_ERR(inode);\n\t\tgoto fail;\n\t}\n\n\td_instantiate(dentry, inode);\n\tret = 0;\nfail:\n\tbtrfs_subvolume_release_metadata(BTRFS_I(dir)->root,\n\t\t\t\t\t &pending_snapshot->block_rsv,\n\t\t\t\t\t pending_snapshot->qgroup_reserved);\nfree:\n\tkfree(pending_snapshot);\nout:\n\tif (atomic_dec_and_test(&root->will_be_snapshoted))\n\t\twake_up_atomic_t(&root->will_be_snapshoted);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_root_refs",
          "args": [
            "&BTRFS_I(dir)->root->root_item"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&BTRFS_I(dir)->root->fs_info->subvol_sem"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_check_dir_item_collision",
          "args": [
            "BTRFS_I(dir)->root",
            "dir->i_ino",
            "name",
            "namelen"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_check_dir_item_collision",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dir-item.c",
          "lines": "216-273",
          "snippet": "int btrfs_check_dir_item_collision(struct btrfs_root *root, u64 dir,\n\t\t\t\t   const char *name, int name_len)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct btrfs_dir_item *di;\n\tint data_size;\n\tstruct extent_buffer *leaf;\n\tint slot;\n\tstruct btrfs_path *path;\n\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_ITEM_KEY;\n\tkey.offset = btrfs_name_hash(name, name_len);\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\n\t/* return back any errors */\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* nothing found, we're safe */\n\tif (ret > 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* we found an item, look for our name in the item */\n\tdi = btrfs_match_dir_item_name(root, path, name, name_len);\n\tif (di) {\n\t\t/* our exact name was found */\n\t\tret = -EEXIST;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * see if there is room in the item to insert this\n\t * name\n\t */\n\tdata_size = sizeof(*di) + name_len;\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\tif (data_size + btrfs_item_size_nr(leaf, slot) +\n\t    sizeof(struct btrfs_item) > BTRFS_LEAF_DATA_SIZE(root)) {\n\t\tret = -EOVERFLOW;\n\t} else {\n\t\t/* plenty of insertion room */\n\t\tret = 0;\n\t}\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n\nint btrfs_check_dir_item_collision(struct btrfs_root *root, u64 dir,\n\t\t\t\t   const char *name, int name_len)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct btrfs_dir_item *di;\n\tint data_size;\n\tstruct extent_buffer *leaf;\n\tint slot;\n\tstruct btrfs_path *path;\n\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_ITEM_KEY;\n\tkey.offset = btrfs_name_hash(name, name_len);\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\n\t/* return back any errors */\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* nothing found, we're safe */\n\tif (ret > 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* we found an item, look for our name in the item */\n\tdi = btrfs_match_dir_item_name(root, path, name, name_len);\n\tif (di) {\n\t\t/* our exact name was found */\n\t\tret = -EEXIST;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * see if there is room in the item to insert this\n\t * name\n\t */\n\tdata_size = sizeof(*di) + name_len;\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\tif (data_size + btrfs_item_size_nr(leaf, slot) +\n\t    sizeof(struct btrfs_item) > BTRFS_LEAF_DATA_SIZE(root)) {\n\t\tret = -EOVERFLOW;\n\t} else {\n\t\t/* plenty of insertion room */\n\t\tret = 0;\n\t}\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_may_create",
          "args": [
            "dir",
            "dentry"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_may_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "793-800",
          "snippet": "static inline int btrfs_may_create(struct inode *dir, struct dentry *child)\n{\n\tif (child->d_inode)\n\t\treturn -EEXIST;\n\tif (IS_DEADDIR(dir))\n\t\treturn -ENOENT;\n\treturn inode_permission(dir, MAY_WRITE | MAY_EXEC);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic inline int btrfs_may_create(struct inode *dir, struct dentry *child)\n{\n\tif (child->d_inode)\n\t\treturn -EEXIST;\n\tif (IS_DEADDIR(dir))\n\t\treturn -ENOENT;\n\treturn inode_permission(dir, MAY_WRITE | MAY_EXEC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_one_len",
          "args": [
            "name",
            "parent->dentry",
            "namelen"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_one_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2145-2184",
          "snippet": "struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstruct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_killable_nested",
          "args": [
            "&dir->i_mutex",
            "I_MUTEX_PARENT"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic noinline int btrfs_mksubvol(struct path *parent,\n\t\t\t\t   char *name, int namelen,\n\t\t\t\t   struct btrfs_root *snap_src,\n\t\t\t\t   u64 *async_transid, bool readonly,\n\t\t\t\t   struct btrfs_qgroup_inherit *inherit)\n{\n\tstruct inode *dir  = parent->dentry->d_inode;\n\tstruct dentry *dentry;\n\tint error;\n\n\terror = mutex_lock_killable_nested(&dir->i_mutex, I_MUTEX_PARENT);\n\tif (error == -EINTR)\n\t\treturn error;\n\n\tdentry = lookup_one_len(name, parent->dentry, namelen);\n\terror = PTR_ERR(dentry);\n\tif (IS_ERR(dentry))\n\t\tgoto out_unlock;\n\n\terror = -EEXIST;\n\tif (dentry->d_inode)\n\t\tgoto out_dput;\n\n\terror = btrfs_may_create(dir, dentry);\n\tif (error)\n\t\tgoto out_dput;\n\n\t/*\n\t * even if this name doesn't exist, we may get hash collisions.\n\t * check for them now when we can safely fail\n\t */\n\terror = btrfs_check_dir_item_collision(BTRFS_I(dir)->root,\n\t\t\t\t\t       dir->i_ino, name,\n\t\t\t\t\t       namelen);\n\tif (error)\n\t\tgoto out_dput;\n\n\tdown_read(&BTRFS_I(dir)->root->fs_info->subvol_sem);\n\n\tif (btrfs_root_refs(&BTRFS_I(dir)->root->root_item) == 0)\n\t\tgoto out_up_read;\n\n\tif (snap_src) {\n\t\terror = create_snapshot(snap_src, dir, dentry, name, namelen,\n\t\t\t\t\tasync_transid, readonly, inherit);\n\t} else {\n\t\terror = create_subvol(dir, dentry, name, namelen,\n\t\t\t\t      async_transid, inherit);\n\t}\n\tif (!error)\n\t\tfsnotify_mkdir(dir, dentry);\nout_up_read:\n\tup_read(&BTRFS_I(dir)->root->fs_info->subvol_sem);\nout_dput:\n\tdput(dentry);\nout_unlock:\n\tmutex_unlock(&dir->i_mutex);\n\treturn error;\n}"
  },
  {
    "function_name": "btrfs_may_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "793-800",
    "snippet": "static inline int btrfs_may_create(struct inode *dir, struct dentry *child)\n{\n\tif (child->d_inode)\n\t\treturn -EEXIST;\n\tif (IS_DEADDIR(dir))\n\t\treturn -ENOENT;\n\treturn inode_permission(dir, MAY_WRITE | MAY_EXEC);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_permission",
          "args": [
            "dir",
            "MAY_WRITE | MAY_EXEC"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "inode_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "459-467",
          "snippet": "int inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\treturn __inode_permission(inode, mask);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\treturn __inode_permission(inode, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DEADDIR",
          "args": [
            "dir"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic inline int btrfs_may_create(struct inode *dir, struct dentry *child)\n{\n\tif (child->d_inode)\n\t\treturn -EEXIST;\n\tif (IS_DEADDIR(dir))\n\t\treturn -ENOENT;\n\treturn inode_permission(dir, MAY_WRITE | MAY_EXEC);\n}"
  },
  {
    "function_name": "btrfs_may_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "760-790",
    "snippet": "static int btrfs_may_delete(struct inode *dir, struct dentry *victim, int isdir)\n{\n\tint error;\n\n\tif (!victim->d_inode)\n\t\treturn -ENOENT;\n\n\tBUG_ON(victim->d_parent->d_inode != dir);\n\taudit_inode_child(dir, victim, AUDIT_TYPE_CHILD_DELETE);\n\n\terror = inode_permission(dir, MAY_WRITE | MAY_EXEC);\n\tif (error)\n\t\treturn error;\n\tif (IS_APPEND(dir))\n\t\treturn -EPERM;\n\tif (check_sticky(dir, victim->d_inode) || IS_APPEND(victim->d_inode) ||\n\t    IS_IMMUTABLE(victim->d_inode) || IS_SWAPFILE(victim->d_inode))\n\t\treturn -EPERM;\n\tif (isdir) {\n\t\tif (!d_is_dir(victim))\n\t\t\treturn -ENOTDIR;\n\t\tif (IS_ROOT(victim))\n\t\t\treturn -EBUSY;\n\t} else if (d_is_dir(victim))\n\t\treturn -EISDIR;\n\tif (IS_DEADDIR(dir))\n\t\treturn -ENOENT;\n\tif (victim->d_flags & DCACHE_NFSFS_RENAMED)\n\t\treturn -EBUSY;\n\treturn 0;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_DEADDIR",
          "args": [
            "dir"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_is_dir",
          "args": [
            "victim"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "victim"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_is_dir",
          "args": [
            "victim"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SWAPFILE",
          "args": [
            "victim->d_inode"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_IMMUTABLE",
          "args": [
            "victim->d_inode"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_APPEND",
          "args": [
            "victim->d_inode"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_sticky",
          "args": [
            "dir",
            "victim->d_inode"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "__check_sticky",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2419-2428",
          "snippet": "int __check_sticky(struct inode *dir, struct inode *inode)\n{\n\tkuid_t fsuid = current_fsuid();\n\n\tif (uid_eq(inode->i_uid, fsuid))\n\t\treturn 0;\n\tif (uid_eq(dir->i_uid, fsuid))\n\t\treturn 0;\n\treturn !capable_wrt_inode_uidgid(inode, CAP_FOWNER);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint __check_sticky(struct inode *dir, struct inode *inode)\n{\n\tkuid_t fsuid = current_fsuid();\n\n\tif (uid_eq(inode->i_uid, fsuid))\n\t\treturn 0;\n\tif (uid_eq(dir->i_uid, fsuid))\n\t\treturn 0;\n\treturn !capable_wrt_inode_uidgid(inode, CAP_FOWNER);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_APPEND",
          "args": [
            "dir"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_permission",
          "args": [
            "dir",
            "MAY_WRITE | MAY_EXEC"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "inode_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "459-467",
          "snippet": "int inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\treturn __inode_permission(inode, mask);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\treturn __inode_permission(inode, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_inode_child",
          "args": [
            "dir",
            "victim",
            "AUDIT_TYPE_CHILD_DELETE"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "victim->d_parent->d_inode != dir"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_may_delete(struct inode *dir, struct dentry *victim, int isdir)\n{\n\tint error;\n\n\tif (!victim->d_inode)\n\t\treturn -ENOENT;\n\n\tBUG_ON(victim->d_parent->d_inode != dir);\n\taudit_inode_child(dir, victim, AUDIT_TYPE_CHILD_DELETE);\n\n\terror = inode_permission(dir, MAY_WRITE | MAY_EXEC);\n\tif (error)\n\t\treturn error;\n\tif (IS_APPEND(dir))\n\t\treturn -EPERM;\n\tif (check_sticky(dir, victim->d_inode) || IS_APPEND(victim->d_inode) ||\n\t    IS_IMMUTABLE(victim->d_inode) || IS_SWAPFILE(victim->d_inode))\n\t\treturn -EPERM;\n\tif (isdir) {\n\t\tif (!d_is_dir(victim))\n\t\t\treturn -ENOTDIR;\n\t\tif (IS_ROOT(victim))\n\t\t\treturn -EBUSY;\n\t} else if (d_is_dir(victim))\n\t\treturn -EISDIR;\n\tif (IS_DEADDIR(dir))\n\t\treturn -ENOENT;\n\tif (victim->d_flags & DCACHE_NFSFS_RENAMED)\n\t\treturn -EBUSY;\n\treturn 0;\n}"
  },
  {
    "function_name": "create_snapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "637-738",
    "snippet": "static int create_snapshot(struct btrfs_root *root, struct inode *dir,\n\t\t\t   struct dentry *dentry, char *name, int namelen,\n\t\t\t   u64 *async_transid, bool readonly,\n\t\t\t   struct btrfs_qgroup_inherit *inherit)\n{\n\tstruct inode *inode;\n\tstruct btrfs_pending_snapshot *pending_snapshot;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\n\tif (!test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\treturn -EINVAL;\n\n\tatomic_inc(&root->will_be_snapshoted);\n\tsmp_mb__after_atomic();\n\tbtrfs_wait_for_no_snapshoting_writes(root);\n\n\tret = btrfs_start_delalloc_inodes(root, 0);\n\tif (ret)\n\t\tgoto out;\n\n\tbtrfs_wait_ordered_extents(root, -1);\n\n\tpending_snapshot = kzalloc(sizeof(*pending_snapshot), GFP_NOFS);\n\tif (!pending_snapshot) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tbtrfs_init_block_rsv(&pending_snapshot->block_rsv,\n\t\t\t     BTRFS_BLOCK_RSV_TEMP);\n\t/*\n\t * 1 - parent dir inode\n\t * 2 - dir entries\n\t * 1 - root item\n\t * 2 - root ref/backref\n\t * 1 - root of snapshot\n\t * 1 - UUID item\n\t */\n\tret = btrfs_subvolume_reserve_metadata(BTRFS_I(dir)->root,\n\t\t\t\t\t&pending_snapshot->block_rsv, 8,\n\t\t\t\t\t&pending_snapshot->qgroup_reserved,\n\t\t\t\t\tfalse);\n\tif (ret)\n\t\tgoto free;\n\n\tpending_snapshot->dentry = dentry;\n\tpending_snapshot->root = root;\n\tpending_snapshot->readonly = readonly;\n\tpending_snapshot->dir = dir;\n\tpending_snapshot->inherit = inherit;\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto fail;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_add(&pending_snapshot->list,\n\t\t &trans->transaction->pending_snapshots);\n\tspin_unlock(&root->fs_info->trans_lock);\n\tif (async_transid) {\n\t\t*async_transid = trans->transid;\n\t\tret = btrfs_commit_transaction_async(trans,\n\t\t\t\t     root->fs_info->extent_root, 1);\n\t\tif (ret)\n\t\t\tret = btrfs_commit_transaction(trans, root);\n\t} else {\n\t\tret = btrfs_commit_transaction(trans,\n\t\t\t\t\t       root->fs_info->extent_root);\n\t}\n\tif (ret)\n\t\tgoto fail;\n\n\tret = pending_snapshot->error;\n\tif (ret)\n\t\tgoto fail;\n\n\tret = btrfs_orphan_cleanup(pending_snapshot->snap);\n\tif (ret)\n\t\tgoto fail;\n\n\tinode = btrfs_lookup_dentry(dentry->d_parent->d_inode, dentry);\n\tif (IS_ERR(inode)) {\n\t\tret = PTR_ERR(inode);\n\t\tgoto fail;\n\t}\n\n\td_instantiate(dentry, inode);\n\tret = 0;\nfail:\n\tbtrfs_subvolume_release_metadata(BTRFS_I(dir)->root,\n\t\t\t\t\t &pending_snapshot->block_rsv,\n\t\t\t\t\t pending_snapshot->qgroup_reserved);\nfree:\n\tkfree(pending_snapshot);\nout:\n\tif (atomic_dec_and_test(&root->will_be_snapshoted))\n\t\twake_up_atomic_t(&root->will_be_snapshoted);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_atomic_t",
          "args": [
            "&root->will_be_snapshoted"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&root->will_be_snapshoted"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pending_snapshot"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_subvolume_release_metadata",
          "args": [
            "BTRFS_I(dir)->root",
            "&pending_snapshot->block_rsv",
            "pending_snapshot->qgroup_reserved"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_subvolume_release_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "4996-5003",
          "snippet": "void btrfs_subvolume_release_metadata(struct btrfs_root *root,\n\t\t\t\t      struct btrfs_block_rsv *rsv,\n\t\t\t\t      u64 qgroup_reserved)\n{\n\tbtrfs_block_rsv_release(root, rsv, (u64)-1);\n\tif (qgroup_reserved)\n\t\tbtrfs_qgroup_free(root, qgroup_reserved);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_subvolume_release_metadata(struct btrfs_root *root,\n\t\t\t\t      struct btrfs_block_rsv *rsv,\n\t\t\t\t      u64 qgroup_reserved)\n{\n\tbtrfs_block_rsv_release(root, rsv, (u64)-1);\n\tif (qgroup_reserved)\n\t\tbtrfs_qgroup_free(root, qgroup_reserved);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "dir"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_dentry",
          "args": [
            "dentry->d_parent->d_inode",
            "dentry"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "5363-5414",
          "snippet": "struct inode *btrfs_lookup_dentry(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode;\n\tstruct btrfs_root *root = BTRFS_I(dir)->root;\n\tstruct btrfs_root *sub_root = root;\n\tstruct btrfs_key location;\n\tint index;\n\tint ret = 0;\n\n\tif (dentry->d_name.len > BTRFS_NAME_LEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tret = btrfs_inode_by_name(dir, dentry, &location);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tif (location.objectid == 0)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tif (location.type == BTRFS_INODE_ITEM_KEY) {\n\t\tinode = btrfs_iget(dir->i_sb, &location, root, NULL);\n\t\treturn inode;\n\t}\n\n\tBUG_ON(location.type != BTRFS_ROOT_ITEM_KEY);\n\n\tindex = srcu_read_lock(&root->fs_info->subvol_srcu);\n\tret = fixup_tree_root_location(root, dir, dentry,\n\t\t\t\t       &location, &sub_root);\n\tif (ret < 0) {\n\t\tif (ret != -ENOENT)\n\t\t\tinode = ERR_PTR(ret);\n\t\telse\n\t\t\tinode = new_simple_dir(dir->i_sb, &location, sub_root);\n\t} else {\n\t\tinode = btrfs_iget(dir->i_sb, &location, sub_root, NULL);\n\t}\n\tsrcu_read_unlock(&root->fs_info->subvol_srcu, index);\n\n\tif (!IS_ERR(inode) && root != sub_root) {\n\t\tdown_read(&root->fs_info->cleanup_work_sem);\n\t\tif (!(inode->i_sb->s_flags & MS_RDONLY))\n\t\t\tret = btrfs_orphan_cleanup(sub_root);\n\t\tup_read(&root->fs_info->cleanup_work_sem);\n\t\tif (ret) {\n\t\t\tiput(inode);\n\t\t\tinode = ERR_PTR(ret);\n\t\t}\n\t}\n\n\treturn inode;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static struct extent_map *create_pinned_em(struct inode *inode, u64 start,\n\t\t\t\t\t   u64 len, u64 orig_start,\n\t\t\t\t\t   u64 block_start, u64 block_len,\n\t\t\t\t\t   u64 orig_block_len, u64 ram_bytes,\n\t\t\t\t\t   int type);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic struct extent_map *create_pinned_em(struct inode *inode, u64 start,\n\t\t\t\t\t   u64 len, u64 orig_start,\n\t\t\t\t\t   u64 block_start, u64 block_len,\n\t\t\t\t\t   u64 orig_block_len, u64 ram_bytes,\n\t\t\t\t\t   int type);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nstruct inode *btrfs_lookup_dentry(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode;\n\tstruct btrfs_root *root = BTRFS_I(dir)->root;\n\tstruct btrfs_root *sub_root = root;\n\tstruct btrfs_key location;\n\tint index;\n\tint ret = 0;\n\n\tif (dentry->d_name.len > BTRFS_NAME_LEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tret = btrfs_inode_by_name(dir, dentry, &location);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tif (location.objectid == 0)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tif (location.type == BTRFS_INODE_ITEM_KEY) {\n\t\tinode = btrfs_iget(dir->i_sb, &location, root, NULL);\n\t\treturn inode;\n\t}\n\n\tBUG_ON(location.type != BTRFS_ROOT_ITEM_KEY);\n\n\tindex = srcu_read_lock(&root->fs_info->subvol_srcu);\n\tret = fixup_tree_root_location(root, dir, dentry,\n\t\t\t\t       &location, &sub_root);\n\tif (ret < 0) {\n\t\tif (ret != -ENOENT)\n\t\t\tinode = ERR_PTR(ret);\n\t\telse\n\t\t\tinode = new_simple_dir(dir->i_sb, &location, sub_root);\n\t} else {\n\t\tinode = btrfs_iget(dir->i_sb, &location, sub_root, NULL);\n\t}\n\tsrcu_read_unlock(&root->fs_info->subvol_srcu, index);\n\n\tif (!IS_ERR(inode) && root != sub_root) {\n\t\tdown_read(&root->fs_info->cleanup_work_sem);\n\t\tif (!(inode->i_sb->s_flags & MS_RDONLY))\n\t\t\tret = btrfs_orphan_cleanup(sub_root);\n\t\tup_read(&root->fs_info->cleanup_work_sem);\n\t\tif (ret) {\n\t\t\tiput(inode);\n\t\t\tinode = ERR_PTR(ret);\n\t\t}\n\t}\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_orphan_cleanup",
          "args": [
            "pending_snapshot->snap"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_orphan_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3300-3498",
          "snippet": "int btrfs_orphan_cleanup(struct btrfs_root *root)\n{\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key, found_key;\n\tstruct btrfs_trans_handle *trans;\n\tstruct inode *inode;\n\tu64 last_objectid = 0;\n\tint ret = 0, nr_unlink = 0, nr_truncate = 0;\n\n\tif (cmpxchg(&root->orphan_cleanup_state, 0, ORPHAN_CLEANUP_STARTED))\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tpath->reada = -1;\n\n\tkey.objectid = BTRFS_ORPHAN_OBJECTID;\n\tkey.type = BTRFS_ORPHAN_ITEM_KEY;\n\tkey.offset = (u64)-1;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * if ret == 0 means we found what we were searching for, which\n\t\t * is weird, but possible, so only screw with path if we didn't\n\t\t * find the key and see if we have stuff that matches\n\t\t */\n\t\tif (ret > 0) {\n\t\t\tret = 0;\n\t\t\tif (path->slots[0] == 0)\n\t\t\t\tbreak;\n\t\t\tpath->slots[0]--;\n\t\t}\n\n\t\t/* pull out the item */\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\n\t\t/* make sure the item matches what we want */\n\t\tif (found_key.objectid != BTRFS_ORPHAN_OBJECTID)\n\t\t\tbreak;\n\t\tif (found_key.type != BTRFS_ORPHAN_ITEM_KEY)\n\t\t\tbreak;\n\n\t\t/* release the path since we're done with it */\n\t\tbtrfs_release_path(path);\n\n\t\t/*\n\t\t * this is where we are basically btrfs_lookup, without the\n\t\t * crossing root thing.  we store the inode number in the\n\t\t * offset of the orphan item.\n\t\t */\n\n\t\tif (found_key.offset == last_objectid) {\n\t\t\tbtrfs_err(root->fs_info,\n\t\t\t\t\"Error removing orphan entry, stopping orphan cleanup\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlast_objectid = found_key.offset;\n\n\t\tfound_key.objectid = found_key.offset;\n\t\tfound_key.type = BTRFS_INODE_ITEM_KEY;\n\t\tfound_key.offset = 0;\n\t\tinode = btrfs_iget(root->fs_info->sb, &found_key, root, NULL);\n\t\tret = PTR_ERR_OR_ZERO(inode);\n\t\tif (ret && ret != -ESTALE)\n\t\t\tgoto out;\n\n\t\tif (ret == -ESTALE && root == root->fs_info->tree_root) {\n\t\t\tstruct btrfs_root *dead_root;\n\t\t\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\t\t\tint is_dead_root = 0;\n\n\t\t\t/*\n\t\t\t * this is an orphan in the tree root. Currently these\n\t\t\t * could come from 2 sources:\n\t\t\t *  a) a snapshot deletion in progress\n\t\t\t *  b) a free space cache inode\n\t\t\t * We need to distinguish those two, as the snapshot\n\t\t\t * orphan must not get deleted.\n\t\t\t * find_dead_roots already ran before us, so if this\n\t\t\t * is a snapshot deletion, we should find the root\n\t\t\t * in the dead_roots list\n\t\t\t */\n\t\t\tspin_lock(&fs_info->trans_lock);\n\t\t\tlist_for_each_entry(dead_root, &fs_info->dead_roots,\n\t\t\t\t\t    root_list) {\n\t\t\t\tif (dead_root->root_key.objectid ==\n\t\t\t\t    found_key.objectid) {\n\t\t\t\t\tis_dead_root = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock(&fs_info->trans_lock);\n\t\t\tif (is_dead_root) {\n\t\t\t\t/* prevent this orphan from being found again */\n\t\t\t\tkey.offset = found_key.objectid - 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Inode is already gone but the orphan item is still there,\n\t\t * kill the orphan item.\n\t\t */\n\t\tif (ret == -ESTALE) {\n\t\t\ttrans = btrfs_start_transaction(root, 1);\n\t\t\tif (IS_ERR(trans)) {\n\t\t\t\tret = PTR_ERR(trans);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbtrfs_debug(root->fs_info, \"auto deleting %Lu\",\n\t\t\t\tfound_key.objectid);\n\t\t\tret = btrfs_del_orphan_item(trans, root,\n\t\t\t\t\t\t    found_key.objectid);\n\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * add this inode to the orphan list so btrfs_orphan_del does\n\t\t * the proper thing when we hit it\n\t\t */\n\t\tset_bit(BTRFS_INODE_HAS_ORPHAN_ITEM,\n\t\t\t&BTRFS_I(inode)->runtime_flags);\n\t\tatomic_inc(&root->orphan_inodes);\n\n\t\t/* if we have links, this was a truncate, lets do that */\n\t\tif (inode->i_nlink) {\n\t\t\tif (WARN_ON(!S_ISREG(inode->i_mode))) {\n\t\t\t\tiput(inode);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnr_truncate++;\n\n\t\t\t/* 1 for the orphan item deletion. */\n\t\t\ttrans = btrfs_start_transaction(root, 1);\n\t\t\tif (IS_ERR(trans)) {\n\t\t\t\tiput(inode);\n\t\t\t\tret = PTR_ERR(trans);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = btrfs_orphan_add(trans, inode);\n\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\tif (ret) {\n\t\t\t\tiput(inode);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = btrfs_truncate(inode);\n\t\t\tif (ret)\n\t\t\t\tbtrfs_orphan_del(NULL, inode);\n\t\t} else {\n\t\t\tnr_unlink++;\n\t\t}\n\n\t\t/* this will do delete_inode and everything for us */\n\t\tiput(inode);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\t/* release the path since we're done with it */\n\tbtrfs_release_path(path);\n\n\troot->orphan_cleanup_state = ORPHAN_CLEANUP_DONE;\n\n\tif (root->orphan_block_rsv)\n\t\tbtrfs_block_rsv_release(root, root->orphan_block_rsv,\n\t\t\t\t\t(u64)-1);\n\n\tif (root->orphan_block_rsv ||\n\t    test_bit(BTRFS_ROOT_ORPHAN_ITEM_INSERTED, &root->state)) {\n\t\ttrans = btrfs_join_transaction(root);\n\t\tif (!IS_ERR(trans))\n\t\t\tbtrfs_end_transaction(trans, root);\n\t}\n\n\tif (nr_unlink)\n\t\tbtrfs_debug(root->fs_info, \"unlinked %d orphans\", nr_unlink);\n\tif (nr_truncate)\n\t\tbtrfs_debug(root->fs_info, \"truncated %d orphans\", nr_truncate);\n\nout:\n\tif (ret)\n\t\tbtrfs_err(root->fs_info,\n\t\t\t\"could not do orphan cleanup %d\", ret);\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static struct extent_map *create_pinned_em(struct inode *inode, u64 start,\n\t\t\t\t\t   u64 len, u64 orig_start,\n\t\t\t\t\t   u64 block_start, u64 block_len,\n\t\t\t\t\t   u64 orig_block_len, u64 ram_bytes,\n\t\t\t\t\t   int type);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic struct extent_map *create_pinned_em(struct inode *inode, u64 start,\n\t\t\t\t\t   u64 len, u64 orig_start,\n\t\t\t\t\t   u64 block_start, u64 block_len,\n\t\t\t\t\t   u64 orig_block_len, u64 ram_bytes,\n\t\t\t\t\t   int type);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nint btrfs_orphan_cleanup(struct btrfs_root *root)\n{\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key, found_key;\n\tstruct btrfs_trans_handle *trans;\n\tstruct inode *inode;\n\tu64 last_objectid = 0;\n\tint ret = 0, nr_unlink = 0, nr_truncate = 0;\n\n\tif (cmpxchg(&root->orphan_cleanup_state, 0, ORPHAN_CLEANUP_STARTED))\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tpath->reada = -1;\n\n\tkey.objectid = BTRFS_ORPHAN_OBJECTID;\n\tkey.type = BTRFS_ORPHAN_ITEM_KEY;\n\tkey.offset = (u64)-1;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * if ret == 0 means we found what we were searching for, which\n\t\t * is weird, but possible, so only screw with path if we didn't\n\t\t * find the key and see if we have stuff that matches\n\t\t */\n\t\tif (ret > 0) {\n\t\t\tret = 0;\n\t\t\tif (path->slots[0] == 0)\n\t\t\t\tbreak;\n\t\t\tpath->slots[0]--;\n\t\t}\n\n\t\t/* pull out the item */\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\n\t\t/* make sure the item matches what we want */\n\t\tif (found_key.objectid != BTRFS_ORPHAN_OBJECTID)\n\t\t\tbreak;\n\t\tif (found_key.type != BTRFS_ORPHAN_ITEM_KEY)\n\t\t\tbreak;\n\n\t\t/* release the path since we're done with it */\n\t\tbtrfs_release_path(path);\n\n\t\t/*\n\t\t * this is where we are basically btrfs_lookup, without the\n\t\t * crossing root thing.  we store the inode number in the\n\t\t * offset of the orphan item.\n\t\t */\n\n\t\tif (found_key.offset == last_objectid) {\n\t\t\tbtrfs_err(root->fs_info,\n\t\t\t\t\"Error removing orphan entry, stopping orphan cleanup\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlast_objectid = found_key.offset;\n\n\t\tfound_key.objectid = found_key.offset;\n\t\tfound_key.type = BTRFS_INODE_ITEM_KEY;\n\t\tfound_key.offset = 0;\n\t\tinode = btrfs_iget(root->fs_info->sb, &found_key, root, NULL);\n\t\tret = PTR_ERR_OR_ZERO(inode);\n\t\tif (ret && ret != -ESTALE)\n\t\t\tgoto out;\n\n\t\tif (ret == -ESTALE && root == root->fs_info->tree_root) {\n\t\t\tstruct btrfs_root *dead_root;\n\t\t\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\t\t\tint is_dead_root = 0;\n\n\t\t\t/*\n\t\t\t * this is an orphan in the tree root. Currently these\n\t\t\t * could come from 2 sources:\n\t\t\t *  a) a snapshot deletion in progress\n\t\t\t *  b) a free space cache inode\n\t\t\t * We need to distinguish those two, as the snapshot\n\t\t\t * orphan must not get deleted.\n\t\t\t * find_dead_roots already ran before us, so if this\n\t\t\t * is a snapshot deletion, we should find the root\n\t\t\t * in the dead_roots list\n\t\t\t */\n\t\t\tspin_lock(&fs_info->trans_lock);\n\t\t\tlist_for_each_entry(dead_root, &fs_info->dead_roots,\n\t\t\t\t\t    root_list) {\n\t\t\t\tif (dead_root->root_key.objectid ==\n\t\t\t\t    found_key.objectid) {\n\t\t\t\t\tis_dead_root = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock(&fs_info->trans_lock);\n\t\t\tif (is_dead_root) {\n\t\t\t\t/* prevent this orphan from being found again */\n\t\t\t\tkey.offset = found_key.objectid - 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Inode is already gone but the orphan item is still there,\n\t\t * kill the orphan item.\n\t\t */\n\t\tif (ret == -ESTALE) {\n\t\t\ttrans = btrfs_start_transaction(root, 1);\n\t\t\tif (IS_ERR(trans)) {\n\t\t\t\tret = PTR_ERR(trans);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbtrfs_debug(root->fs_info, \"auto deleting %Lu\",\n\t\t\t\tfound_key.objectid);\n\t\t\tret = btrfs_del_orphan_item(trans, root,\n\t\t\t\t\t\t    found_key.objectid);\n\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * add this inode to the orphan list so btrfs_orphan_del does\n\t\t * the proper thing when we hit it\n\t\t */\n\t\tset_bit(BTRFS_INODE_HAS_ORPHAN_ITEM,\n\t\t\t&BTRFS_I(inode)->runtime_flags);\n\t\tatomic_inc(&root->orphan_inodes);\n\n\t\t/* if we have links, this was a truncate, lets do that */\n\t\tif (inode->i_nlink) {\n\t\t\tif (WARN_ON(!S_ISREG(inode->i_mode))) {\n\t\t\t\tiput(inode);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnr_truncate++;\n\n\t\t\t/* 1 for the orphan item deletion. */\n\t\t\ttrans = btrfs_start_transaction(root, 1);\n\t\t\tif (IS_ERR(trans)) {\n\t\t\t\tiput(inode);\n\t\t\t\tret = PTR_ERR(trans);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = btrfs_orphan_add(trans, inode);\n\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\tif (ret) {\n\t\t\t\tiput(inode);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = btrfs_truncate(inode);\n\t\t\tif (ret)\n\t\t\t\tbtrfs_orphan_del(NULL, inode);\n\t\t} else {\n\t\t\tnr_unlink++;\n\t\t}\n\n\t\t/* this will do delete_inode and everything for us */\n\t\tiput(inode);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\t/* release the path since we're done with it */\n\tbtrfs_release_path(path);\n\n\troot->orphan_cleanup_state = ORPHAN_CLEANUP_DONE;\n\n\tif (root->orphan_block_rsv)\n\t\tbtrfs_block_rsv_release(root, root->orphan_block_rsv,\n\t\t\t\t\t(u64)-1);\n\n\tif (root->orphan_block_rsv ||\n\t    test_bit(BTRFS_ROOT_ORPHAN_ITEM_INSERTED, &root->state)) {\n\t\ttrans = btrfs_join_transaction(root);\n\t\tif (!IS_ERR(trans))\n\t\t\tbtrfs_end_transaction(trans, root);\n\t}\n\n\tif (nr_unlink)\n\t\tbtrfs_debug(root->fs_info, \"unlinked %d orphans\", nr_unlink);\n\tif (nr_truncate)\n\t\tbtrfs_debug(root->fs_info, \"truncated %d orphans\", nr_truncate);\n\nout:\n\tif (ret)\n\t\tbtrfs_err(root->fs_info,\n\t\t\t\"could not do orphan cleanup %d\", ret);\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_commit_transaction",
          "args": [
            "trans",
            "root->fs_info->extent_root"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_commit_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "1764-2099",
          "snippet": "int btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_commit_transaction_async",
          "args": [
            "trans",
            "root->fs_info->extent_root",
            "1"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_commit_transaction_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "1627-1675",
          "snippet": "int btrfs_commit_transaction_async(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root,\n\t\t\t\t   int wait_for_unblock)\n{\n\tstruct btrfs_async_commit *ac;\n\tstruct btrfs_transaction *cur_trans;\n\n\tac = kmalloc(sizeof(*ac), GFP_NOFS);\n\tif (!ac)\n\t\treturn -ENOMEM;\n\n\tINIT_WORK(&ac->work, do_async_commit);\n\tac->root = root;\n\tac->newtrans = btrfs_join_transaction(root);\n\tif (IS_ERR(ac->newtrans)) {\n\t\tint err = PTR_ERR(ac->newtrans);\n\t\tkfree(ac);\n\t\treturn err;\n\t}\n\n\t/* take transaction reference */\n\tcur_trans = trans->transaction;\n\tatomic_inc(&cur_trans->use_count);\n\n\tbtrfs_end_transaction(trans, root);\n\n\t/*\n\t * Tell lockdep we've released the freeze rwsem, since the\n\t * async commit thread will be the one to unlock it.\n\t */\n\tif (ac->newtrans->type & __TRANS_FREEZABLE)\n\t\trwsem_release(\n\t\t\t&root->fs_info->sb->s_writers.lock_map[SB_FREEZE_FS-1],\n\t\t\t1, _THIS_IP_);\n\n\tschedule_work(&ac->work);\n\n\t/* wait for transaction to start and unblock */\n\tif (wait_for_unblock)\n\t\twait_current_trans_commit_start_and_unblock(root, cur_trans);\n\telse\n\t\twait_current_trans_commit_start(root, cur_trans);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tbtrfs_put_transaction(cur_trans);\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_commit_transaction_async(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root,\n\t\t\t\t   int wait_for_unblock)\n{\n\tstruct btrfs_async_commit *ac;\n\tstruct btrfs_transaction *cur_trans;\n\n\tac = kmalloc(sizeof(*ac), GFP_NOFS);\n\tif (!ac)\n\t\treturn -ENOMEM;\n\n\tINIT_WORK(&ac->work, do_async_commit);\n\tac->root = root;\n\tac->newtrans = btrfs_join_transaction(root);\n\tif (IS_ERR(ac->newtrans)) {\n\t\tint err = PTR_ERR(ac->newtrans);\n\t\tkfree(ac);\n\t\treturn err;\n\t}\n\n\t/* take transaction reference */\n\tcur_trans = trans->transaction;\n\tatomic_inc(&cur_trans->use_count);\n\n\tbtrfs_end_transaction(trans, root);\n\n\t/*\n\t * Tell lockdep we've released the freeze rwsem, since the\n\t * async commit thread will be the one to unlock it.\n\t */\n\tif (ac->newtrans->type & __TRANS_FREEZABLE)\n\t\trwsem_release(\n\t\t\t&root->fs_info->sb->s_writers.lock_map[SB_FREEZE_FS-1],\n\t\t\t1, _THIS_IP_);\n\n\tschedule_work(&ac->work);\n\n\t/* wait for transaction to start and unblock */\n\tif (wait_for_unblock)\n\t\twait_current_trans_commit_start_and_unblock(root, cur_trans);\n\telse\n\t\twait_current_trans_commit_start(root, cur_trans);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tbtrfs_put_transaction(cur_trans);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&root->fs_info->trans_lock"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&pending_snapshot->list",
            "&trans->transaction->pending_snapshots"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&root->fs_info->trans_lock"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_start_transaction",
          "args": [
            "root",
            "0"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_transaction_lflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "569-574",
          "snippet": "struct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_subvolume_reserve_metadata",
          "args": [
            "BTRFS_I(dir)->root",
            "&pending_snapshot->block_rsv",
            "8",
            "&pending_snapshot->qgroup_reserved",
            "false"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_subvolume_reserve_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "4957-4994",
          "snippet": "int btrfs_subvolume_reserve_metadata(struct btrfs_root *root,\n\t\t\t\t     struct btrfs_block_rsv *rsv,\n\t\t\t\t     int items,\n\t\t\t\t     u64 *qgroup_reserved,\n\t\t\t\t     bool use_global_rsv)\n{\n\tu64 num_bytes;\n\tint ret;\n\tstruct btrfs_block_rsv *global_rsv = &root->fs_info->global_block_rsv;\n\n\tif (root->fs_info->quota_enabled) {\n\t\t/* One for parent inode, two for dir entries */\n\t\tnum_bytes = 3 * root->nodesize;\n\t\tret = btrfs_qgroup_reserve(root, num_bytes);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tnum_bytes = 0;\n\t}\n\n\t*qgroup_reserved = num_bytes;\n\n\tnum_bytes = btrfs_calc_trans_metadata_size(root, items);\n\trsv->space_info = __find_space_info(root->fs_info,\n\t\t\t\t\t    BTRFS_BLOCK_GROUP_METADATA);\n\tret = btrfs_block_rsv_add(root, rsv, num_bytes,\n\t\t\t\t  BTRFS_RESERVE_FLUSH_ALL);\n\n\tif (ret == -ENOSPC && use_global_rsv)\n\t\tret = btrfs_block_rsv_migrate(global_rsv, rsv, num_bytes);\n\n\tif (ret) {\n\t\tif (*qgroup_reserved)\n\t\t\tbtrfs_qgroup_free(root, *qgroup_reserved);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nstatic noinline struct;\n\nint btrfs_subvolume_reserve_metadata(struct btrfs_root *root,\n\t\t\t\t     struct btrfs_block_rsv *rsv,\n\t\t\t\t     int items,\n\t\t\t\t     u64 *qgroup_reserved,\n\t\t\t\t     bool use_global_rsv)\n{\n\tu64 num_bytes;\n\tint ret;\n\tstruct btrfs_block_rsv *global_rsv = &root->fs_info->global_block_rsv;\n\n\tif (root->fs_info->quota_enabled) {\n\t\t/* One for parent inode, two for dir entries */\n\t\tnum_bytes = 3 * root->nodesize;\n\t\tret = btrfs_qgroup_reserve(root, num_bytes);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tnum_bytes = 0;\n\t}\n\n\t*qgroup_reserved = num_bytes;\n\n\tnum_bytes = btrfs_calc_trans_metadata_size(root, items);\n\trsv->space_info = __find_space_info(root->fs_info,\n\t\t\t\t\t    BTRFS_BLOCK_GROUP_METADATA);\n\tret = btrfs_block_rsv_add(root, rsv, num_bytes,\n\t\t\t\t  BTRFS_RESERVE_FLUSH_ALL);\n\n\tif (ret == -ENOSPC && use_global_rsv)\n\t\tret = btrfs_block_rsv_migrate(global_rsv, rsv, num_bytes);\n\n\tif (ret) {\n\t\tif (*qgroup_reserved)\n\t\t\tbtrfs_qgroup_free(root, *qgroup_reserved);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_init_block_rsv",
          "args": [
            "&pending_snapshot->block_rsv",
            "BTRFS_BLOCK_RSV_TEMP"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_block_rsv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "4671-4676",
          "snippet": "void btrfs_init_block_rsv(struct btrfs_block_rsv *rsv, unsigned short type)\n{\n\tmemset(rsv, 0, sizeof(*rsv));\n\tspin_lock_init(&rsv->lock);\n\trsv->type = type;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_init_block_rsv(struct btrfs_block_rsv *rsv, unsigned short type)\n{\n\tmemset(rsv, 0, sizeof(*rsv));\n\tspin_lock_init(&rsv->lock);\n\trsv->type = type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*pending_snapshot)",
            "GFP_NOFS"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_wait_ordered_extents",
          "args": [
            "root",
            "-1"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_wait_ordered_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "609-654",
          "snippet": "int btrfs_wait_ordered_extents(struct btrfs_root *root, int nr)\n{\n\tstruct list_head splice, works;\n\tstruct btrfs_ordered_extent *ordered, *next;\n\tint count = 0;\n\n\tINIT_LIST_HEAD(&splice);\n\tINIT_LIST_HEAD(&works);\n\n\tmutex_lock(&root->ordered_extent_mutex);\n\tspin_lock(&root->ordered_extent_lock);\n\tlist_splice_init(&root->ordered_extents, &splice);\n\twhile (!list_empty(&splice) && nr) {\n\t\tordered = list_first_entry(&splice, struct btrfs_ordered_extent,\n\t\t\t\t\t   root_extent_list);\n\t\tlist_move_tail(&ordered->root_extent_list,\n\t\t\t       &root->ordered_extents);\n\t\tatomic_inc(&ordered->refs);\n\t\tspin_unlock(&root->ordered_extent_lock);\n\n\t\tbtrfs_init_work(&ordered->flush_work,\n\t\t\t\tbtrfs_flush_delalloc_helper,\n\t\t\t\tbtrfs_run_ordered_extent_work, NULL, NULL);\n\t\tlist_add_tail(&ordered->work_list, &works);\n\t\tbtrfs_queue_work(root->fs_info->flush_workers,\n\t\t\t\t &ordered->flush_work);\n\n\t\tcond_resched();\n\t\tspin_lock(&root->ordered_extent_lock);\n\t\tif (nr != -1)\n\t\t\tnr--;\n\t\tcount++;\n\t}\n\tlist_splice_tail(&splice, &root->ordered_extents);\n\tspin_unlock(&root->ordered_extent_lock);\n\n\tlist_for_each_entry_safe(ordered, next, &works, work_list) {\n\t\tlist_del_init(&ordered->work_list);\n\t\twait_for_completion(&ordered->completion);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tcond_resched();\n\t}\n\tmutex_unlock(&root->ordered_extent_mutex);\n\n\treturn count;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nint btrfs_wait_ordered_extents(struct btrfs_root *root, int nr)\n{\n\tstruct list_head splice, works;\n\tstruct btrfs_ordered_extent *ordered, *next;\n\tint count = 0;\n\n\tINIT_LIST_HEAD(&splice);\n\tINIT_LIST_HEAD(&works);\n\n\tmutex_lock(&root->ordered_extent_mutex);\n\tspin_lock(&root->ordered_extent_lock);\n\tlist_splice_init(&root->ordered_extents, &splice);\n\twhile (!list_empty(&splice) && nr) {\n\t\tordered = list_first_entry(&splice, struct btrfs_ordered_extent,\n\t\t\t\t\t   root_extent_list);\n\t\tlist_move_tail(&ordered->root_extent_list,\n\t\t\t       &root->ordered_extents);\n\t\tatomic_inc(&ordered->refs);\n\t\tspin_unlock(&root->ordered_extent_lock);\n\n\t\tbtrfs_init_work(&ordered->flush_work,\n\t\t\t\tbtrfs_flush_delalloc_helper,\n\t\t\t\tbtrfs_run_ordered_extent_work, NULL, NULL);\n\t\tlist_add_tail(&ordered->work_list, &works);\n\t\tbtrfs_queue_work(root->fs_info->flush_workers,\n\t\t\t\t &ordered->flush_work);\n\n\t\tcond_resched();\n\t\tspin_lock(&root->ordered_extent_lock);\n\t\tif (nr != -1)\n\t\t\tnr--;\n\t\tcount++;\n\t}\n\tlist_splice_tail(&splice, &root->ordered_extents);\n\tspin_unlock(&root->ordered_extent_lock);\n\n\tlist_for_each_entry_safe(ordered, next, &works, work_list) {\n\t\tlist_del_init(&ordered->work_list);\n\t\twait_for_completion(&ordered->completion);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tcond_resched();\n\t}\n\tmutex_unlock(&root->ordered_extent_mutex);\n\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_start_delalloc_inodes",
          "args": [
            "root",
            "0"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_delalloc_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "9202-9226",
          "snippet": "int btrfs_start_delalloc_inodes(struct btrfs_root *root, int delay_iput)\n{\n\tint ret;\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &root->fs_info->fs_state))\n\t\treturn -EROFS;\n\n\tret = __start_delalloc_inodes(root, delay_iput, -1);\n\tif (ret > 0)\n\t\tret = 0;\n\t/*\n\t * the filemap_flush will queue IO into the worker threads, but\n\t * we have to make sure the IO is actually started and that\n\t * ordered extents get created before we return\n\t */\n\tatomic_inc(&root->fs_info->async_submit_draining);\n\twhile (atomic_read(&root->fs_info->nr_async_submits) ||\n\t      atomic_read(&root->fs_info->async_delalloc_pages)) {\n\t\twait_event(root->fs_info->async_submit_wait,\n\t\t   (atomic_read(&root->fs_info->nr_async_submits) == 0 &&\n\t\t    atomic_read(&root->fs_info->async_delalloc_pages) == 0));\n\t}\n\tatomic_dec(&root->fs_info->async_submit_draining);\n\treturn ret;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nint btrfs_start_delalloc_inodes(struct btrfs_root *root, int delay_iput)\n{\n\tint ret;\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &root->fs_info->fs_state))\n\t\treturn -EROFS;\n\n\tret = __start_delalloc_inodes(root, delay_iput, -1);\n\tif (ret > 0)\n\t\tret = 0;\n\t/*\n\t * the filemap_flush will queue IO into the worker threads, but\n\t * we have to make sure the IO is actually started and that\n\t * ordered extents get created before we return\n\t */\n\tatomic_inc(&root->fs_info->async_submit_draining);\n\twhile (atomic_read(&root->fs_info->nr_async_submits) ||\n\t      atomic_read(&root->fs_info->async_delalloc_pages)) {\n\t\twait_event(root->fs_info->async_submit_wait,\n\t\t   (atomic_read(&root->fs_info->nr_async_submits) == 0 &&\n\t\t    atomic_read(&root->fs_info->async_delalloc_pages) == 0));\n\t}\n\tatomic_dec(&root->fs_info->async_submit_draining);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_wait_for_no_snapshoting_writes",
          "args": [
            "root"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_wait_for_no_snapshoting_writes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "620-635",
          "snippet": "static void btrfs_wait_for_no_snapshoting_writes(struct btrfs_root *root)\n{\n\ts64 writers;\n\tDEFINE_WAIT(wait);\n\n\tdo {\n\t\tprepare_to_wait(&root->subv_writers->wait, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\n\t\twriters = percpu_counter_sum(&root->subv_writers->counter);\n\t\tif (writers)\n\t\t\tschedule();\n\n\t\tfinish_wait(&root->subv_writers->wait, &wait);\n\t} while (writers);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic void btrfs_wait_for_no_snapshoting_writes(struct btrfs_root *root)\n{\n\ts64 writers;\n\tDEFINE_WAIT(wait);\n\n\tdo {\n\t\tprepare_to_wait(&root->subv_writers->wait, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\n\t\twriters = percpu_counter_sum(&root->subv_writers->counter);\n\t\tif (writers)\n\t\t\tschedule();\n\n\t\tfinish_wait(&root->subv_writers->wait, &wait);\n\t} while (writers);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&root->will_be_snapshoted"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_ROOT_REF_COWS",
            "&root->state"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int create_snapshot(struct btrfs_root *root, struct inode *dir,\n\t\t\t   struct dentry *dentry, char *name, int namelen,\n\t\t\t   u64 *async_transid, bool readonly,\n\t\t\t   struct btrfs_qgroup_inherit *inherit)\n{\n\tstruct inode *inode;\n\tstruct btrfs_pending_snapshot *pending_snapshot;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\n\tif (!test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\treturn -EINVAL;\n\n\tatomic_inc(&root->will_be_snapshoted);\n\tsmp_mb__after_atomic();\n\tbtrfs_wait_for_no_snapshoting_writes(root);\n\n\tret = btrfs_start_delalloc_inodes(root, 0);\n\tif (ret)\n\t\tgoto out;\n\n\tbtrfs_wait_ordered_extents(root, -1);\n\n\tpending_snapshot = kzalloc(sizeof(*pending_snapshot), GFP_NOFS);\n\tif (!pending_snapshot) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tbtrfs_init_block_rsv(&pending_snapshot->block_rsv,\n\t\t\t     BTRFS_BLOCK_RSV_TEMP);\n\t/*\n\t * 1 - parent dir inode\n\t * 2 - dir entries\n\t * 1 - root item\n\t * 2 - root ref/backref\n\t * 1 - root of snapshot\n\t * 1 - UUID item\n\t */\n\tret = btrfs_subvolume_reserve_metadata(BTRFS_I(dir)->root,\n\t\t\t\t\t&pending_snapshot->block_rsv, 8,\n\t\t\t\t\t&pending_snapshot->qgroup_reserved,\n\t\t\t\t\tfalse);\n\tif (ret)\n\t\tgoto free;\n\n\tpending_snapshot->dentry = dentry;\n\tpending_snapshot->root = root;\n\tpending_snapshot->readonly = readonly;\n\tpending_snapshot->dir = dir;\n\tpending_snapshot->inherit = inherit;\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto fail;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_add(&pending_snapshot->list,\n\t\t &trans->transaction->pending_snapshots);\n\tspin_unlock(&root->fs_info->trans_lock);\n\tif (async_transid) {\n\t\t*async_transid = trans->transid;\n\t\tret = btrfs_commit_transaction_async(trans,\n\t\t\t\t     root->fs_info->extent_root, 1);\n\t\tif (ret)\n\t\t\tret = btrfs_commit_transaction(trans, root);\n\t} else {\n\t\tret = btrfs_commit_transaction(trans,\n\t\t\t\t\t       root->fs_info->extent_root);\n\t}\n\tif (ret)\n\t\tgoto fail;\n\n\tret = pending_snapshot->error;\n\tif (ret)\n\t\tgoto fail;\n\n\tret = btrfs_orphan_cleanup(pending_snapshot->snap);\n\tif (ret)\n\t\tgoto fail;\n\n\tinode = btrfs_lookup_dentry(dentry->d_parent->d_inode, dentry);\n\tif (IS_ERR(inode)) {\n\t\tret = PTR_ERR(inode);\n\t\tgoto fail;\n\t}\n\n\td_instantiate(dentry, inode);\n\tret = 0;\nfail:\n\tbtrfs_subvolume_release_metadata(BTRFS_I(dir)->root,\n\t\t\t\t\t &pending_snapshot->block_rsv,\n\t\t\t\t\t pending_snapshot->qgroup_reserved);\nfree:\n\tkfree(pending_snapshot);\nout:\n\tif (atomic_dec_and_test(&root->will_be_snapshoted))\n\t\twake_up_atomic_t(&root->will_be_snapshoted);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_wait_for_no_snapshoting_writes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "620-635",
    "snippet": "static void btrfs_wait_for_no_snapshoting_writes(struct btrfs_root *root)\n{\n\ts64 writers;\n\tDEFINE_WAIT(wait);\n\n\tdo {\n\t\tprepare_to_wait(&root->subv_writers->wait, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\n\t\twriters = percpu_counter_sum(&root->subv_writers->counter);\n\t\tif (writers)\n\t\t\tschedule();\n\n\t\tfinish_wait(&root->subv_writers->wait, &wait);\n\t} while (writers);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "&root->subv_writers->wait",
            "&wait"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_sum",
          "args": [
            "&root->subv_writers->counter"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_to_wait",
          "args": [
            "&root->subv_writers->wait",
            "&wait",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT",
          "args": [
            "wait"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic void btrfs_wait_for_no_snapshoting_writes(struct btrfs_root *root)\n{\n\ts64 writers;\n\tDEFINE_WAIT(wait);\n\n\tdo {\n\t\tprepare_to_wait(&root->subv_writers->wait, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\n\t\twriters = percpu_counter_sum(&root->subv_writers->counter);\n\t\tif (writers)\n\t\t\tschedule();\n\n\t\tfinish_wait(&root->subv_writers->wait, &wait);\n\t} while (writers);\n}"
  },
  {
    "function_name": "create_subvol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "431-618",
    "snippet": "static noinline int create_subvol(struct inode *dir,\n\t\t\t\t  struct dentry *dentry,\n\t\t\t\t  char *name, int namelen,\n\t\t\t\t  u64 *async_transid,\n\t\t\t\t  struct btrfs_qgroup_inherit *inherit)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_key key;\n\tstruct btrfs_root_item root_item;\n\tstruct btrfs_inode_item *inode_item;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_root *root = BTRFS_I(dir)->root;\n\tstruct btrfs_root *new_root;\n\tstruct btrfs_block_rsv block_rsv;\n\tstruct timespec cur_time = CURRENT_TIME;\n\tstruct inode *inode;\n\tint ret;\n\tint err;\n\tu64 objectid;\n\tu64 new_dirid = BTRFS_FIRST_FREE_OBJECTID;\n\tu64 index = 0;\n\tu64 qgroup_reserved;\n\tuuid_le new_uuid;\n\n\tret = btrfs_find_free_objectid(root->fs_info->tree_root, &objectid);\n\tif (ret)\n\t\treturn ret;\n\n\tbtrfs_init_block_rsv(&block_rsv, BTRFS_BLOCK_RSV_TEMP);\n\t/*\n\t * The same as the snapshot creation, please see the comment\n\t * of create_snapshot().\n\t */\n\tret = btrfs_subvolume_reserve_metadata(root, &block_rsv,\n\t\t\t\t\t       8, &qgroup_reserved, false);\n\tif (ret)\n\t\treturn ret;\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tbtrfs_subvolume_release_metadata(root, &block_rsv,\n\t\t\t\t\t\t qgroup_reserved);\n\t\treturn ret;\n\t}\n\ttrans->block_rsv = &block_rsv;\n\ttrans->bytes_reserved = block_rsv.size;\n\n\tret = btrfs_qgroup_inherit(trans, root->fs_info, 0, objectid, inherit);\n\tif (ret)\n\t\tgoto fail;\n\n\tleaf = btrfs_alloc_tree_block(trans, root, 0, objectid, NULL, 0, 0, 0);\n\tif (IS_ERR(leaf)) {\n\t\tret = PTR_ERR(leaf);\n\t\tgoto fail;\n\t}\n\n\tmemset_extent_buffer(leaf, 0, 0, sizeof(struct btrfs_header));\n\tbtrfs_set_header_bytenr(leaf, leaf->start);\n\tbtrfs_set_header_generation(leaf, trans->transid);\n\tbtrfs_set_header_backref_rev(leaf, BTRFS_MIXED_BACKREF_REV);\n\tbtrfs_set_header_owner(leaf, objectid);\n\n\twrite_extent_buffer(leaf, root->fs_info->fsid, btrfs_header_fsid(),\n\t\t\t    BTRFS_FSID_SIZE);\n\twrite_extent_buffer(leaf, root->fs_info->chunk_tree_uuid,\n\t\t\t    btrfs_header_chunk_tree_uuid(leaf),\n\t\t\t    BTRFS_UUID_SIZE);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tmemset(&root_item, 0, sizeof(root_item));\n\n\tinode_item = &root_item.inode;\n\tbtrfs_set_stack_inode_generation(inode_item, 1);\n\tbtrfs_set_stack_inode_size(inode_item, 3);\n\tbtrfs_set_stack_inode_nlink(inode_item, 1);\n\tbtrfs_set_stack_inode_nbytes(inode_item, root->nodesize);\n\tbtrfs_set_stack_inode_mode(inode_item, S_IFDIR | 0755);\n\n\tbtrfs_set_root_flags(&root_item, 0);\n\tbtrfs_set_root_limit(&root_item, 0);\n\tbtrfs_set_stack_inode_flags(inode_item, BTRFS_INODE_ROOT_ITEM_INIT);\n\n\tbtrfs_set_root_bytenr(&root_item, leaf->start);\n\tbtrfs_set_root_generation(&root_item, trans->transid);\n\tbtrfs_set_root_level(&root_item, 0);\n\tbtrfs_set_root_refs(&root_item, 1);\n\tbtrfs_set_root_used(&root_item, leaf->len);\n\tbtrfs_set_root_last_snapshot(&root_item, 0);\n\n\tbtrfs_set_root_generation_v2(&root_item,\n\t\t\tbtrfs_root_generation(&root_item));\n\tuuid_le_gen(&new_uuid);\n\tmemcpy(root_item.uuid, new_uuid.b, BTRFS_UUID_SIZE);\n\tbtrfs_set_stack_timespec_sec(&root_item.otime, cur_time.tv_sec);\n\tbtrfs_set_stack_timespec_nsec(&root_item.otime, cur_time.tv_nsec);\n\troot_item.ctime = root_item.otime;\n\tbtrfs_set_root_ctransid(&root_item, trans->transid);\n\tbtrfs_set_root_otransid(&root_item, trans->transid);\n\n\tbtrfs_tree_unlock(leaf);\n\tfree_extent_buffer(leaf);\n\tleaf = NULL;\n\n\tbtrfs_set_root_dirid(&root_item, new_dirid);\n\n\tkey.objectid = objectid;\n\tkey.offset = 0;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tret = btrfs_insert_root(trans, root->fs_info->tree_root, &key,\n\t\t\t\t&root_item);\n\tif (ret)\n\t\tgoto fail;\n\n\tkey.offset = (u64)-1;\n\tnew_root = btrfs_read_fs_root_no_name(root->fs_info, &key);\n\tif (IS_ERR(new_root)) {\n\t\tbtrfs_abort_transaction(trans, root, PTR_ERR(new_root));\n\t\tret = PTR_ERR(new_root);\n\t\tgoto fail;\n\t}\n\n\tbtrfs_record_root_in_trans(trans, new_root);\n\n\tret = btrfs_create_subvol_root(trans, new_root, root, new_dirid);\n\tif (ret) {\n\t\t/* We potentially lose an unused inode item here */\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * insert the directory item\n\t */\n\tret = btrfs_set_inode_index(dir, &index);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tret = btrfs_insert_dir_item(trans, root,\n\t\t\t\t    name, namelen, dir, &key,\n\t\t\t\t    BTRFS_FT_DIR, index);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tbtrfs_i_size_write(dir, dir->i_size + namelen * 2);\n\tret = btrfs_update_inode(trans, root, dir);\n\tBUG_ON(ret);\n\n\tret = btrfs_add_root_ref(trans, root->fs_info->tree_root,\n\t\t\t\t objectid, root->root_key.objectid,\n\t\t\t\t btrfs_ino(dir), index, name, namelen);\n\tBUG_ON(ret);\n\n\tret = btrfs_uuid_tree_add(trans, root->fs_info->uuid_root,\n\t\t\t\t  root_item.uuid, BTRFS_UUID_KEY_SUBVOL,\n\t\t\t\t  objectid);\n\tif (ret)\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\nfail:\n\ttrans->block_rsv = NULL;\n\ttrans->bytes_reserved = 0;\n\tbtrfs_subvolume_release_metadata(root, &block_rsv, qgroup_reserved);\n\n\tif (async_transid) {\n\t\t*async_transid = trans->transid;\n\t\terr = btrfs_commit_transaction_async(trans, root, 1);\n\t\tif (err)\n\t\t\terr = btrfs_commit_transaction(trans, root);\n\t} else {\n\t\terr = btrfs_commit_transaction(trans, root);\n\t}\n\tif (err && !ret)\n\t\tret = err;\n\n\tif (!ret) {\n\t\tinode = btrfs_lookup_dentry(dir, dentry);\n\t\tif (IS_ERR(inode))\n\t\t\treturn PTR_ERR(inode);\n\t\td_instantiate(dentry, inode);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_dentry",
          "args": [
            "dir",
            "dentry"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "5363-5414",
          "snippet": "struct inode *btrfs_lookup_dentry(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode;\n\tstruct btrfs_root *root = BTRFS_I(dir)->root;\n\tstruct btrfs_root *sub_root = root;\n\tstruct btrfs_key location;\n\tint index;\n\tint ret = 0;\n\n\tif (dentry->d_name.len > BTRFS_NAME_LEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tret = btrfs_inode_by_name(dir, dentry, &location);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tif (location.objectid == 0)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tif (location.type == BTRFS_INODE_ITEM_KEY) {\n\t\tinode = btrfs_iget(dir->i_sb, &location, root, NULL);\n\t\treturn inode;\n\t}\n\n\tBUG_ON(location.type != BTRFS_ROOT_ITEM_KEY);\n\n\tindex = srcu_read_lock(&root->fs_info->subvol_srcu);\n\tret = fixup_tree_root_location(root, dir, dentry,\n\t\t\t\t       &location, &sub_root);\n\tif (ret < 0) {\n\t\tif (ret != -ENOENT)\n\t\t\tinode = ERR_PTR(ret);\n\t\telse\n\t\t\tinode = new_simple_dir(dir->i_sb, &location, sub_root);\n\t} else {\n\t\tinode = btrfs_iget(dir->i_sb, &location, sub_root, NULL);\n\t}\n\tsrcu_read_unlock(&root->fs_info->subvol_srcu, index);\n\n\tif (!IS_ERR(inode) && root != sub_root) {\n\t\tdown_read(&root->fs_info->cleanup_work_sem);\n\t\tif (!(inode->i_sb->s_flags & MS_RDONLY))\n\t\t\tret = btrfs_orphan_cleanup(sub_root);\n\t\tup_read(&root->fs_info->cleanup_work_sem);\n\t\tif (ret) {\n\t\t\tiput(inode);\n\t\t\tinode = ERR_PTR(ret);\n\t\t}\n\t}\n\n\treturn inode;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static struct extent_map *create_pinned_em(struct inode *inode, u64 start,\n\t\t\t\t\t   u64 len, u64 orig_start,\n\t\t\t\t\t   u64 block_start, u64 block_len,\n\t\t\t\t\t   u64 orig_block_len, u64 ram_bytes,\n\t\t\t\t\t   int type);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic struct extent_map *create_pinned_em(struct inode *inode, u64 start,\n\t\t\t\t\t   u64 len, u64 orig_start,\n\t\t\t\t\t   u64 block_start, u64 block_len,\n\t\t\t\t\t   u64 orig_block_len, u64 ram_bytes,\n\t\t\t\t\t   int type);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nstruct inode *btrfs_lookup_dentry(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode;\n\tstruct btrfs_root *root = BTRFS_I(dir)->root;\n\tstruct btrfs_root *sub_root = root;\n\tstruct btrfs_key location;\n\tint index;\n\tint ret = 0;\n\n\tif (dentry->d_name.len > BTRFS_NAME_LEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tret = btrfs_inode_by_name(dir, dentry, &location);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tif (location.objectid == 0)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tif (location.type == BTRFS_INODE_ITEM_KEY) {\n\t\tinode = btrfs_iget(dir->i_sb, &location, root, NULL);\n\t\treturn inode;\n\t}\n\n\tBUG_ON(location.type != BTRFS_ROOT_ITEM_KEY);\n\n\tindex = srcu_read_lock(&root->fs_info->subvol_srcu);\n\tret = fixup_tree_root_location(root, dir, dentry,\n\t\t\t\t       &location, &sub_root);\n\tif (ret < 0) {\n\t\tif (ret != -ENOENT)\n\t\t\tinode = ERR_PTR(ret);\n\t\telse\n\t\t\tinode = new_simple_dir(dir->i_sb, &location, sub_root);\n\t} else {\n\t\tinode = btrfs_iget(dir->i_sb, &location, sub_root, NULL);\n\t}\n\tsrcu_read_unlock(&root->fs_info->subvol_srcu, index);\n\n\tif (!IS_ERR(inode) && root != sub_root) {\n\t\tdown_read(&root->fs_info->cleanup_work_sem);\n\t\tif (!(inode->i_sb->s_flags & MS_RDONLY))\n\t\t\tret = btrfs_orphan_cleanup(sub_root);\n\t\tup_read(&root->fs_info->cleanup_work_sem);\n\t\tif (ret) {\n\t\t\tiput(inode);\n\t\t\tinode = ERR_PTR(ret);\n\t\t}\n\t}\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_commit_transaction",
          "args": [
            "trans",
            "root"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_commit_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "1764-2099",
          "snippet": "int btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_commit_transaction_async",
          "args": [
            "trans",
            "root",
            "1"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_commit_transaction_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "1627-1675",
          "snippet": "int btrfs_commit_transaction_async(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root,\n\t\t\t\t   int wait_for_unblock)\n{\n\tstruct btrfs_async_commit *ac;\n\tstruct btrfs_transaction *cur_trans;\n\n\tac = kmalloc(sizeof(*ac), GFP_NOFS);\n\tif (!ac)\n\t\treturn -ENOMEM;\n\n\tINIT_WORK(&ac->work, do_async_commit);\n\tac->root = root;\n\tac->newtrans = btrfs_join_transaction(root);\n\tif (IS_ERR(ac->newtrans)) {\n\t\tint err = PTR_ERR(ac->newtrans);\n\t\tkfree(ac);\n\t\treturn err;\n\t}\n\n\t/* take transaction reference */\n\tcur_trans = trans->transaction;\n\tatomic_inc(&cur_trans->use_count);\n\n\tbtrfs_end_transaction(trans, root);\n\n\t/*\n\t * Tell lockdep we've released the freeze rwsem, since the\n\t * async commit thread will be the one to unlock it.\n\t */\n\tif (ac->newtrans->type & __TRANS_FREEZABLE)\n\t\trwsem_release(\n\t\t\t&root->fs_info->sb->s_writers.lock_map[SB_FREEZE_FS-1],\n\t\t\t1, _THIS_IP_);\n\n\tschedule_work(&ac->work);\n\n\t/* wait for transaction to start and unblock */\n\tif (wait_for_unblock)\n\t\twait_current_trans_commit_start_and_unblock(root, cur_trans);\n\telse\n\t\twait_current_trans_commit_start(root, cur_trans);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tbtrfs_put_transaction(cur_trans);\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_commit_transaction_async(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root,\n\t\t\t\t   int wait_for_unblock)\n{\n\tstruct btrfs_async_commit *ac;\n\tstruct btrfs_transaction *cur_trans;\n\n\tac = kmalloc(sizeof(*ac), GFP_NOFS);\n\tif (!ac)\n\t\treturn -ENOMEM;\n\n\tINIT_WORK(&ac->work, do_async_commit);\n\tac->root = root;\n\tac->newtrans = btrfs_join_transaction(root);\n\tif (IS_ERR(ac->newtrans)) {\n\t\tint err = PTR_ERR(ac->newtrans);\n\t\tkfree(ac);\n\t\treturn err;\n\t}\n\n\t/* take transaction reference */\n\tcur_trans = trans->transaction;\n\tatomic_inc(&cur_trans->use_count);\n\n\tbtrfs_end_transaction(trans, root);\n\n\t/*\n\t * Tell lockdep we've released the freeze rwsem, since the\n\t * async commit thread will be the one to unlock it.\n\t */\n\tif (ac->newtrans->type & __TRANS_FREEZABLE)\n\t\trwsem_release(\n\t\t\t&root->fs_info->sb->s_writers.lock_map[SB_FREEZE_FS-1],\n\t\t\t1, _THIS_IP_);\n\n\tschedule_work(&ac->work);\n\n\t/* wait for transaction to start and unblock */\n\tif (wait_for_unblock)\n\t\twait_current_trans_commit_start_and_unblock(root, cur_trans);\n\telse\n\t\twait_current_trans_commit_start(root, cur_trans);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tbtrfs_put_transaction(cur_trans);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_subvolume_release_metadata",
          "args": [
            "root",
            "&block_rsv",
            "qgroup_reserved"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_subvolume_release_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "4996-5003",
          "snippet": "void btrfs_subvolume_release_metadata(struct btrfs_root *root,\n\t\t\t\t      struct btrfs_block_rsv *rsv,\n\t\t\t\t      u64 qgroup_reserved)\n{\n\tbtrfs_block_rsv_release(root, rsv, (u64)-1);\n\tif (qgroup_reserved)\n\t\tbtrfs_qgroup_free(root, qgroup_reserved);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_subvolume_release_metadata(struct btrfs_root *root,\n\t\t\t\t      struct btrfs_block_rsv *rsv,\n\t\t\t\t      u64 qgroup_reserved)\n{\n\tbtrfs_block_rsv_release(root, rsv, (u64)-1);\n\tif (qgroup_reserved)\n\t\tbtrfs_qgroup_free(root, qgroup_reserved);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_uuid_tree_add",
          "args": [
            "trans",
            "root->fs_info->uuid_root",
            "root_item.uuid",
            "BTRFS_UUID_KEY_SUBVOL",
            "objectid"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_uuid_tree_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/uuid-tree.c",
          "lines": "93-155",
          "snippet": "int btrfs_uuid_tree_add(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_root *uuid_root, u8 *uuid, u8 type,\n\t\t\tu64 subid_cpu)\n{\n\tint ret;\n\tstruct btrfs_path *path = NULL;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tunsigned long offset;\n\t__le64 subid_le;\n\n\tret = btrfs_uuid_tree_lookup(uuid_root, uuid, type, subid_cpu);\n\tif (ret != -ENOENT)\n\t\treturn ret;\n\n\tif (WARN_ON_ONCE(!uuid_root)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tbtrfs_uuid_to_key(uuid, type, &key);\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_insert_empty_item(trans, uuid_root, path, &key,\n\t\t\t\t      sizeof(subid_le));\n\tif (ret >= 0) {\n\t\t/* Add an item for the type for the first time */\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\toffset = btrfs_item_ptr_offset(eb, slot);\n\t} else if (ret == -EEXIST) {\n\t\t/*\n\t\t * An item with that type already exists.\n\t\t * Extend the item and store the new subid at the end.\n\t\t */\n\t\tbtrfs_extend_item(uuid_root, path, sizeof(subid_le));\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\toffset = btrfs_item_ptr_offset(eb, slot);\n\t\toffset += btrfs_item_size_nr(eb, slot) - sizeof(subid_le);\n\t} else if (ret < 0) {\n\t\tbtrfs_warn(uuid_root->fs_info, \"insert uuid item failed %d \"\n\t\t\t\"(0x%016llx, 0x%016llx) type %u!\",\n\t\t\tret, (unsigned long long)key.objectid,\n\t\t\t(unsigned long long)key.offset, type);\n\t\tgoto out;\n\t}\n\n\tret = 0;\n\tsubid_le = cpu_to_le64(subid_cpu);\n\twrite_extent_buffer(eb, &subid_le, offset, sizeof(subid_le));\n\tbtrfs_mark_buffer_dirty(eb);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/uuid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/uuid.h>\n\nint btrfs_uuid_tree_add(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_root *uuid_root, u8 *uuid, u8 type,\n\t\t\tu64 subid_cpu)\n{\n\tint ret;\n\tstruct btrfs_path *path = NULL;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tunsigned long offset;\n\t__le64 subid_le;\n\n\tret = btrfs_uuid_tree_lookup(uuid_root, uuid, type, subid_cpu);\n\tif (ret != -ENOENT)\n\t\treturn ret;\n\n\tif (WARN_ON_ONCE(!uuid_root)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tbtrfs_uuid_to_key(uuid, type, &key);\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_insert_empty_item(trans, uuid_root, path, &key,\n\t\t\t\t      sizeof(subid_le));\n\tif (ret >= 0) {\n\t\t/* Add an item for the type for the first time */\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\toffset = btrfs_item_ptr_offset(eb, slot);\n\t} else if (ret == -EEXIST) {\n\t\t/*\n\t\t * An item with that type already exists.\n\t\t * Extend the item and store the new subid at the end.\n\t\t */\n\t\tbtrfs_extend_item(uuid_root, path, sizeof(subid_le));\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\toffset = btrfs_item_ptr_offset(eb, slot);\n\t\toffset += btrfs_item_size_nr(eb, slot) - sizeof(subid_le);\n\t} else if (ret < 0) {\n\t\tbtrfs_warn(uuid_root->fs_info, \"insert uuid item failed %d \"\n\t\t\t\"(0x%016llx, 0x%016llx) type %u!\",\n\t\t\tret, (unsigned long long)key.objectid,\n\t\t\t(unsigned long long)key.offset, type);\n\t\tgoto out;\n\t}\n\n\tret = 0;\n\tsubid_le = cpu_to_le64(subid_cpu);\n\twrite_extent_buffer(eb, &subid_le, offset, sizeof(subid_le));\n\tbtrfs_mark_buffer_dirty(eb);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_add_root_ref",
          "args": [
            "trans",
            "root->fs_info->tree_root",
            "objectid",
            "root->root_key.objectid",
            "btrfs_ino(dir)",
            "index",
            "name",
            "namelen"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_add_root_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/root-tree.c",
          "lines": "419-466",
          "snippet": "int btrfs_add_root_ref(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *tree_root,\n\t\t       u64 root_id, u64 ref_id, u64 dirid, u64 sequence,\n\t\t       const char *name, int name_len)\n{\n\tstruct btrfs_key key;\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_root_ref *ref;\n\tstruct extent_buffer *leaf;\n\tunsigned long ptr;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = root_id;\n\tkey.type = BTRFS_ROOT_BACKREF_KEY;\n\tkey.offset = ref_id;\nagain:\n\tret = btrfs_insert_empty_item(trans, tree_root, path, &key,\n\t\t\t\t      sizeof(*ref) + name_len);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, tree_root, ret);\n\t\tbtrfs_free_path(path);\n\t\treturn ret;\n\t}\n\n\tleaf = path->nodes[0];\n\tref = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_root_ref);\n\tbtrfs_set_root_ref_dirid(leaf, ref, dirid);\n\tbtrfs_set_root_ref_sequence(leaf, ref, sequence);\n\tbtrfs_set_root_ref_name_len(leaf, ref, name_len);\n\tptr = (unsigned long)(ref + 1);\n\twrite_extent_buffer(leaf, name, ptr, name_len);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tif (key.type == BTRFS_ROOT_BACKREF_KEY) {\n\t\tbtrfs_release_path(path);\n\t\tkey.objectid = ref_id;\n\t\tkey.type = BTRFS_ROOT_REF_KEY;\n\t\tkey.offset = root_id;\n\t\tgoto again;\n\t}\n\n\tbtrfs_free_path(path);\n\treturn 0;\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/err.h>\n\nint btrfs_add_root_ref(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *tree_root,\n\t\t       u64 root_id, u64 ref_id, u64 dirid, u64 sequence,\n\t\t       const char *name, int name_len)\n{\n\tstruct btrfs_key key;\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_root_ref *ref;\n\tstruct extent_buffer *leaf;\n\tunsigned long ptr;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = root_id;\n\tkey.type = BTRFS_ROOT_BACKREF_KEY;\n\tkey.offset = ref_id;\nagain:\n\tret = btrfs_insert_empty_item(trans, tree_root, path, &key,\n\t\t\t\t      sizeof(*ref) + name_len);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, tree_root, ret);\n\t\tbtrfs_free_path(path);\n\t\treturn ret;\n\t}\n\n\tleaf = path->nodes[0];\n\tref = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_root_ref);\n\tbtrfs_set_root_ref_dirid(leaf, ref, dirid);\n\tbtrfs_set_root_ref_sequence(leaf, ref, sequence);\n\tbtrfs_set_root_ref_name_len(leaf, ref, name_len);\n\tptr = (unsigned long)(ref + 1);\n\twrite_extent_buffer(leaf, name, ptr, name_len);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tif (key.type == BTRFS_ROOT_BACKREF_KEY) {\n\t\tbtrfs_release_path(path);\n\t\tkey.objectid = ref_id;\n\t\tkey.type = BTRFS_ROOT_REF_KEY;\n\t\tkey.offset = root_id;\n\t\tgoto again;\n\t}\n\n\tbtrfs_free_path(path);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ino",
          "args": [
            "dir"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_resume_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "311-316",
          "snippet": "static inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [
            "#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\n#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10\n\nstatic inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_update_inode",
          "args": [
            "trans",
            "root",
            "dir"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_update_inode_fallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3841-3851",
          "snippet": "noinline int btrfs_update_inode_fallback(struct btrfs_trans_handle *trans,\n\t\t\t\t\t struct btrfs_root *root,\n\t\t\t\t\t struct inode *inode)\n{\n\tint ret;\n\n\tret = btrfs_update_inode(trans, root, inode);\n\tif (ret == -ENOSPC)\n\t\treturn btrfs_update_inode_item(trans, root, inode);\n\treturn ret;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nnoinline int btrfs_update_inode_fallback(struct btrfs_trans_handle *trans,\n\t\t\t\t\t struct btrfs_root *root,\n\t\t\t\t\t struct inode *inode)\n{\n\tint ret;\n\n\tret = btrfs_update_inode(trans, root, inode);\n\tif (ret == -ENOSPC)\n\t\treturn btrfs_update_inode_item(trans, root, inode);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_i_size_write",
          "args": [
            "dir",
            "dir->i_size + namelen * 2"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_insert_dir_item",
          "args": [
            "trans",
            "root",
            "name",
            "namelen",
            "dir",
            "&key",
            "BTRFS_FT_DIR",
            "index"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_dir_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dir-item.c",
          "lines": "120-184",
          "snippet": "int btrfs_insert_dir_item(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t\t  *root, const char *name, int name_len,\n\t\t\t  struct inode *dir, struct btrfs_key *location,\n\t\t\t  u8 type, u64 index)\n{\n\tint ret = 0;\n\tint ret2 = 0;\n\tstruct btrfs_path *path;\n\tstruct btrfs_dir_item *dir_item;\n\tstruct extent_buffer *leaf;\n\tunsigned long name_ptr;\n\tstruct btrfs_key key;\n\tstruct btrfs_disk_key disk_key;\n\tu32 data_size;\n\n\tkey.objectid = btrfs_ino(dir);\n\tkey.type = BTRFS_DIR_ITEM_KEY;\n\tkey.offset = btrfs_name_hash(name, name_len);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->leave_spinning = 1;\n\n\tbtrfs_cpu_key_to_disk(&disk_key, location);\n\n\tdata_size = sizeof(*dir_item) + name_len;\n\tdir_item = insert_with_overflow(trans, root, path, &key, data_size,\n\t\t\t\t\tname, name_len);\n\tif (IS_ERR(dir_item)) {\n\t\tret = PTR_ERR(dir_item);\n\t\tif (ret == -EEXIST)\n\t\t\tgoto second_insert;\n\t\tgoto out_free;\n\t}\n\n\tleaf = path->nodes[0];\n\tbtrfs_set_dir_item_key(leaf, dir_item, &disk_key);\n\tbtrfs_set_dir_type(leaf, dir_item, type);\n\tbtrfs_set_dir_data_len(leaf, dir_item, 0);\n\tbtrfs_set_dir_name_len(leaf, dir_item, name_len);\n\tbtrfs_set_dir_transid(leaf, dir_item, trans->transid);\n\tname_ptr = (unsigned long)(dir_item + 1);\n\n\twrite_extent_buffer(leaf, name, name_ptr, name_len);\n\tbtrfs_mark_buffer_dirty(leaf);\n\nsecond_insert:\n\t/* FIXME, use some real flag for selecting the extra index */\n\tif (root == root->fs_info->tree_root) {\n\t\tret = 0;\n\t\tgoto out_free;\n\t}\n\tbtrfs_release_path(path);\n\n\tret2 = btrfs_insert_delayed_dir_index(trans, root, name, name_len, dir,\n\t\t\t\t\t      &disk_key, type, index);\nout_free:\n\tbtrfs_free_path(path);\n\tif (ret)\n\t\treturn ret;\n\tif (ret2)\n\t\treturn ret2;\n\treturn 0;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n\nint btrfs_insert_dir_item(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t\t  *root, const char *name, int name_len,\n\t\t\t  struct inode *dir, struct btrfs_key *location,\n\t\t\t  u8 type, u64 index)\n{\n\tint ret = 0;\n\tint ret2 = 0;\n\tstruct btrfs_path *path;\n\tstruct btrfs_dir_item *dir_item;\n\tstruct extent_buffer *leaf;\n\tunsigned long name_ptr;\n\tstruct btrfs_key key;\n\tstruct btrfs_disk_key disk_key;\n\tu32 data_size;\n\n\tkey.objectid = btrfs_ino(dir);\n\tkey.type = BTRFS_DIR_ITEM_KEY;\n\tkey.offset = btrfs_name_hash(name, name_len);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->leave_spinning = 1;\n\n\tbtrfs_cpu_key_to_disk(&disk_key, location);\n\n\tdata_size = sizeof(*dir_item) + name_len;\n\tdir_item = insert_with_overflow(trans, root, path, &key, data_size,\n\t\t\t\t\tname, name_len);\n\tif (IS_ERR(dir_item)) {\n\t\tret = PTR_ERR(dir_item);\n\t\tif (ret == -EEXIST)\n\t\t\tgoto second_insert;\n\t\tgoto out_free;\n\t}\n\n\tleaf = path->nodes[0];\n\tbtrfs_set_dir_item_key(leaf, dir_item, &disk_key);\n\tbtrfs_set_dir_type(leaf, dir_item, type);\n\tbtrfs_set_dir_data_len(leaf, dir_item, 0);\n\tbtrfs_set_dir_name_len(leaf, dir_item, name_len);\n\tbtrfs_set_dir_transid(leaf, dir_item, trans->transid);\n\tname_ptr = (unsigned long)(dir_item + 1);\n\n\twrite_extent_buffer(leaf, name, name_ptr, name_len);\n\tbtrfs_mark_buffer_dirty(leaf);\n\nsecond_insert:\n\t/* FIXME, use some real flag for selecting the extra index */\n\tif (root == root->fs_info->tree_root) {\n\t\tret = 0;\n\t\tgoto out_free;\n\t}\n\tbtrfs_release_path(path);\n\n\tret2 = btrfs_insert_delayed_dir_index(trans, root, name, name_len, dir,\n\t\t\t\t\t      &disk_key, type, index);\nout_free:\n\tbtrfs_free_path(path);\n\tif (ret)\n\t\treturn ret;\n\tif (ret2)\n\t\treturn ret2;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_inode_index",
          "args": [
            "dir",
            "&index"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_inode_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "5788-5805",
          "snippet": "int btrfs_set_inode_index(struct inode *dir, u64 *index)\n{\n\tint ret = 0;\n\n\tif (BTRFS_I(dir)->index_cnt == (u64)-1) {\n\t\tret = btrfs_inode_delayed_dir_index_count(dir);\n\t\tif (ret) {\n\t\t\tret = btrfs_set_inode_index_count(dir);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\t*index = BTRFS_I(dir)->index_cnt;\n\tBTRFS_I(dir)->index_cnt++;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nint btrfs_set_inode_index(struct inode *dir, u64 *index)\n{\n\tint ret = 0;\n\n\tif (BTRFS_I(dir)->index_cnt == (u64)-1) {\n\t\tret = btrfs_inode_delayed_dir_index_count(dir);\n\t\tif (ret) {\n\t\t\tret = btrfs_set_inode_index_count(dir);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\t*index = BTRFS_I(dir)->index_cnt;\n\tBTRFS_I(dir)->index_cnt++;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_create_subvol_root",
          "args": [
            "trans",
            "new_root",
            "root",
            "new_dirid"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_create_subvol_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "8641-8673",
          "snippet": "int btrfs_create_subvol_root(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *new_root,\n\t\t\t     struct btrfs_root *parent_root,\n\t\t\t     u64 new_dirid)\n{\n\tstruct inode *inode;\n\tint err;\n\tu64 index = 0;\n\n\tinode = btrfs_new_inode(trans, new_root, NULL, \"..\", 2,\n\t\t\t\tnew_dirid, new_dirid,\n\t\t\t\tS_IFDIR | (~current_umask() & S_IRWXUGO),\n\t\t\t\t&index);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\tinode->i_op = &btrfs_dir_inode_operations;\n\tinode->i_fop = &btrfs_dir_file_operations;\n\n\tset_nlink(inode, 1);\n\tbtrfs_i_size_write(inode, 0);\n\tunlock_new_inode(inode);\n\n\terr = btrfs_subvol_inherit_props(trans, new_root, parent_root);\n\tif (err)\n\t\tbtrfs_err(new_root->fs_info,\n\t\t\t  \"error inheriting subvolume %llu properties: %d\",\n\t\t\t  new_root->root_key.objectid, err);\n\n\terr = btrfs_update_inode(trans, new_root, inode);\n\n\tiput(inode);\n\treturn err;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations btrfs_dir_inode_operations;",
            "static const struct file_operations btrfs_dir_file_operations;",
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);",
            "static const struct inode_operations btrfs_dir_inode_operations = {\n\t.getattr\t= btrfs_getattr,\n\t.lookup\t\t= btrfs_lookup,\n\t.create\t\t= btrfs_create,\n\t.unlink\t\t= btrfs_unlink,\n\t.link\t\t= btrfs_link,\n\t.mkdir\t\t= btrfs_mkdir,\n\t.rmdir\t\t= btrfs_rmdir,\n\t.rename2\t= btrfs_rename2,\n\t.symlink\t= btrfs_symlink,\n\t.setattr\t= btrfs_setattr,\n\t.mknod\t\t= btrfs_mknod,\n\t.setxattr\t= btrfs_setxattr,\n\t.getxattr\t= btrfs_getxattr,\n\t.listxattr\t= btrfs_listxattr,\n\t.removexattr\t= btrfs_removexattr,\n\t.permission\t= btrfs_permission,\n\t.get_acl\t= btrfs_get_acl,\n\t.set_acl\t= btrfs_set_acl,\n\t.update_time\t= btrfs_update_time,\n\t.tmpfile        = btrfs_tmpfile,\n};",
            "static const struct file_operations btrfs_dir_file_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= btrfs_real_readdir,\n\t.unlocked_ioctl\t= btrfs_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= btrfs_ioctl,\n#endif\n\t.release        = btrfs_release_file,\n\t.fsync\t\t= btrfs_sync_file,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic const struct inode_operations btrfs_dir_inode_operations;\nstatic const struct file_operations btrfs_dir_file_operations;\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\nstatic const struct inode_operations btrfs_dir_inode_operations = {\n\t.getattr\t= btrfs_getattr,\n\t.lookup\t\t= btrfs_lookup,\n\t.create\t\t= btrfs_create,\n\t.unlink\t\t= btrfs_unlink,\n\t.link\t\t= btrfs_link,\n\t.mkdir\t\t= btrfs_mkdir,\n\t.rmdir\t\t= btrfs_rmdir,\n\t.rename2\t= btrfs_rename2,\n\t.symlink\t= btrfs_symlink,\n\t.setattr\t= btrfs_setattr,\n\t.mknod\t\t= btrfs_mknod,\n\t.setxattr\t= btrfs_setxattr,\n\t.getxattr\t= btrfs_getxattr,\n\t.listxattr\t= btrfs_listxattr,\n\t.removexattr\t= btrfs_removexattr,\n\t.permission\t= btrfs_permission,\n\t.get_acl\t= btrfs_get_acl,\n\t.set_acl\t= btrfs_set_acl,\n\t.update_time\t= btrfs_update_time,\n\t.tmpfile        = btrfs_tmpfile,\n};\nstatic const struct file_operations btrfs_dir_file_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= btrfs_real_readdir,\n\t.unlocked_ioctl\t= btrfs_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= btrfs_ioctl,\n#endif\n\t.release        = btrfs_release_file,\n\t.fsync\t\t= btrfs_sync_file,\n};\n\nint btrfs_create_subvol_root(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *new_root,\n\t\t\t     struct btrfs_root *parent_root,\n\t\t\t     u64 new_dirid)\n{\n\tstruct inode *inode;\n\tint err;\n\tu64 index = 0;\n\n\tinode = btrfs_new_inode(trans, new_root, NULL, \"..\", 2,\n\t\t\t\tnew_dirid, new_dirid,\n\t\t\t\tS_IFDIR | (~current_umask() & S_IRWXUGO),\n\t\t\t\t&index);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\tinode->i_op = &btrfs_dir_inode_operations;\n\tinode->i_fop = &btrfs_dir_file_operations;\n\n\tset_nlink(inode, 1);\n\tbtrfs_i_size_write(inode, 0);\n\tunlock_new_inode(inode);\n\n\terr = btrfs_subvol_inherit_props(trans, new_root, parent_root);\n\tif (err)\n\t\tbtrfs_err(new_root->fs_info,\n\t\t\t  \"error inheriting subvolume %llu properties: %d\",\n\t\t\t  new_root->root_key.objectid, err);\n\n\terr = btrfs_update_inode(trans, new_root, inode);\n\n\tiput(inode);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_record_root_in_trans",
          "args": [
            "trans",
            "new_root"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_record_root_in_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "330-350",
          "snippet": "int btrfs_record_root_in_trans(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root)\n{\n\tif (!test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\treturn 0;\n\n\t/*\n\t * see record_root_in_trans for comments about IN_TRANS_SETUP usage\n\t * and barriers\n\t */\n\tsmp_rmb();\n\tif (root->last_trans == trans->transid &&\n\t    !test_bit(BTRFS_ROOT_IN_TRANS_SETUP, &root->state))\n\t\treturn 0;\n\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\trecord_root_in_trans(trans, root);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_record_root_in_trans(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root)\n{\n\tif (!test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\treturn 0;\n\n\t/*\n\t * see record_root_in_trans for comments about IN_TRANS_SETUP usage\n\t * and barriers\n\t */\n\tsmp_rmb();\n\tif (root->last_trans == trans->transid &&\n\t    !test_bit(BTRFS_ROOT_IN_TRANS_SETUP, &root->state))\n\t\treturn 0;\n\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\trecord_root_in_trans(trans, root);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "new_root"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "PTR_ERR(new_root)"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "new_root"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new_root"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_read_fs_root_no_name",
          "args": [
            "root->fs_info",
            "&key"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_read_fs_root_no_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.h",
          "lines": "76-81",
          "snippet": "static inline struct btrfs_root *\nbtrfs_read_fs_root_no_name(struct btrfs_fs_info *fs_info,\n\t\t\t   struct btrfs_key *location)\n{\n\treturn btrfs_get_fs_root(fs_info, location, true);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct btrfs_root *\nbtrfs_read_fs_root_no_name(struct btrfs_fs_info *fs_info,\n\t\t\t   struct btrfs_key *location)\n{\n\treturn btrfs_get_fs_root(fs_info, location, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_insert_root",
          "args": [
            "trans",
            "root->fs_info->tree_root",
            "&key",
            "&root_item"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/root-tree.c",
          "lines": "212-220",
          "snippet": "int btrfs_insert_root(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t      struct btrfs_key *key, struct btrfs_root_item *item)\n{\n\t/*\n\t * Make sure generation v1 and v2 match. See update_root for details.\n\t */\n\tbtrfs_set_root_generation_v2(item, btrfs_root_generation(item));\n\treturn btrfs_insert_item(trans, root, key, item, sizeof(*item));\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/err.h>\n\nint btrfs_insert_root(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t      struct btrfs_key *key, struct btrfs_root_item *item)\n{\n\t/*\n\t * Make sure generation v1 and v2 match. See update_root for details.\n\t */\n\tbtrfs_set_root_generation_v2(item, btrfs_root_generation(item));\n\treturn btrfs_insert_item(trans, root, key, item, sizeof(*item));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_dirid",
          "args": [
            "&root_item",
            "new_dirid"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "leaf"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_unlock",
          "args": [
            "leaf"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "269-290",
          "snippet": "void btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_otransid",
          "args": [
            "&root_item",
            "trans->transid"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_ctransid",
          "args": [
            "&root_item",
            "trans->transid"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_timespec_nsec",
          "args": [
            "&root_item.otime",
            "cur_time.tv_nsec"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_timespec_sec",
          "args": [
            "&root_item.otime",
            "cur_time.tv_sec"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "root_item.uuid",
            "new_uuid.b",
            "BTRFS_UUID_SIZE"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uuid_le_gen",
          "args": [
            "&new_uuid"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_generation_v2",
          "args": [
            "&root_item",
            "btrfs_root_generation(&root_item)"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_root_generation",
          "args": [
            "&root_item"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_last_snapshot",
          "args": [
            "&root_item",
            "0"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_used",
          "args": [
            "&root_item",
            "leaf->len"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_refs",
          "args": [
            "&root_item",
            "1"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_level",
          "args": [
            "&root_item",
            "0"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_generation",
          "args": [
            "&root_item",
            "trans->transid"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_bytenr",
          "args": [
            "&root_item",
            "leaf->start"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_inode_flags",
          "args": [
            "inode_item",
            "BTRFS_INODE_ROOT_ITEM_INIT"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_limit",
          "args": [
            "&root_item",
            "0"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_flags",
          "args": [
            "&root_item",
            "0"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_inode_mode",
          "args": [
            "inode_item",
            "S_IFDIR | 0755"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_inode_nbytes",
          "args": [
            "inode_item",
            "root->nodesize"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_inode_nlink",
          "args": [
            "inode_item",
            "1"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_inode_size",
          "args": [
            "inode_item",
            "3"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_stack_inode_generation",
          "args": [
            "inode_item",
            "1"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&root_item",
            "0",
            "sizeof(root_item)"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "leaf"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_extent_buffer",
          "args": [
            "leaf",
            "root->fs_info->chunk_tree_uuid",
            "btrfs_header_chunk_tree_uuid(leaf)",
            "BTRFS_UUID_SIZE"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "write_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5356-5385",
          "snippet": "void write_extent_buffer(struct extent_buffer *eb, const void *srcv,\n\t\t\t unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *src = (char *)srcv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemcpy(kaddr + offset, src, cur);\n\n\t\tsrc += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid write_extent_buffer(struct extent_buffer *eb, const void *srcv,\n\t\t\t unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *src = (char *)srcv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemcpy(kaddr + offset, src, cur);\n\n\t\tsrc += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_chunk_tree_uuid",
          "args": [
            "leaf"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_header_chunk_tree_uuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2837-2840",
          "snippet": "static inline unsigned long btrfs_header_chunk_tree_uuid(struct extent_buffer *eb)\n{\n\treturn offsetof(struct btrfs_header, chunk_tree_uuid);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long btrfs_header_chunk_tree_uuid(struct extent_buffer *eb)\n{\n\treturn offsetof(struct btrfs_header, chunk_tree_uuid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_fsid",
          "args": [],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_header_fsid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2832-2835",
          "snippet": "static inline unsigned long btrfs_header_fsid(void)\n{\n\treturn offsetof(struct btrfs_header, fsid);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long btrfs_header_fsid(void)\n{\n\treturn offsetof(struct btrfs_header, fsid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_owner",
          "args": [
            "leaf",
            "objectid"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_backref_rev",
          "args": [
            "leaf",
            "BTRFS_MIXED_BACKREF_REV"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_header_backref_rev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2823-2830",
          "snippet": "static inline void btrfs_set_header_backref_rev(struct extent_buffer *eb,\n\t\t\t\t\t\tint rev)\n{\n\tu64 flags = btrfs_header_flags(eb);\n\tflags &= ~BTRFS_BACKREF_REV_MASK;\n\tflags |= (u64)rev << BTRFS_BACKREF_REV_SHIFT;\n\tbtrfs_set_header_flags(eb, flags);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_BACKREF_REV_MASK\t\t(((u64)BTRFS_BACKREF_REV_MAX - 1) << \\\n\t\t\t\t\t BTRFS_BACKREF_REV_SHIFT)",
            "#define BTRFS_BACKREF_REV_SHIFT\t\t56"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_BACKREF_REV_MASK\t\t(((u64)BTRFS_BACKREF_REV_MAX - 1) << \\\n\t\t\t\t\t BTRFS_BACKREF_REV_SHIFT)\n#define BTRFS_BACKREF_REV_SHIFT\t\t56\n\nstatic inline void btrfs_set_header_backref_rev(struct extent_buffer *eb,\n\t\t\t\t\t\tint rev)\n{\n\tu64 flags = btrfs_header_flags(eb);\n\tflags &= ~BTRFS_BACKREF_REV_MASK;\n\tflags |= (u64)rev << BTRFS_BACKREF_REV_SHIFT;\n\tbtrfs_set_header_flags(eb, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_generation",
          "args": [
            "leaf",
            "trans->transid"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_bytenr",
          "args": [
            "leaf",
            "leaf->start"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset_extent_buffer",
          "args": [
            "leaf",
            "0",
            "0",
            "sizeof(struct btrfs_header)"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "memset_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5387-5414",
          "snippet": "void memset_extent_buffer(struct extent_buffer *eb, char c,\n\t\t\t  unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemset(kaddr + offset, c, cur);\n\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid memset_extent_buffer(struct extent_buffer *eb, char c,\n\t\t\t  unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemset(kaddr + offset, c, cur);\n\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "leaf"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "leaf"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_tree_block",
          "args": [
            "trans",
            "root",
            "0",
            "objectid",
            "NULL",
            "0",
            "0",
            "0"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "7316-7385",
          "snippet": "struct extent_buffer *btrfs_alloc_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_root *root,\n\t\t\t\t\tu64 parent, u64 root_objectid,\n\t\t\t\t\tstruct btrfs_disk_key *key, int level,\n\t\t\t\t\tu64 hint, u64 empty_size)\n{\n\tstruct btrfs_key ins;\n\tstruct btrfs_block_rsv *block_rsv;\n\tstruct extent_buffer *buf;\n\tu64 flags = 0;\n\tint ret;\n\tu32 blocksize = root->nodesize;\n\tbool skinny_metadata = btrfs_fs_incompat(root->fs_info,\n\t\t\t\t\t\t SKINNY_METADATA);\n\n\tif (btrfs_test_is_dummy_root(root)) {\n\t\tbuf = btrfs_init_new_buffer(trans, root, root->alloc_bytenr,\n\t\t\t\t\t    level);\n\t\tif (!IS_ERR(buf))\n\t\t\troot->alloc_bytenr += blocksize;\n\t\treturn buf;\n\t}\n\n\tblock_rsv = use_block_rsv(trans, root, blocksize);\n\tif (IS_ERR(block_rsv))\n\t\treturn ERR_CAST(block_rsv);\n\n\tret = btrfs_reserve_extent(root, blocksize, blocksize,\n\t\t\t\t   empty_size, hint, &ins, 0, 0);\n\tif (ret) {\n\t\tunuse_block_rsv(root->fs_info, block_rsv, blocksize);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tbuf = btrfs_init_new_buffer(trans, root, ins.objectid, level);\n\tBUG_ON(IS_ERR(buf)); /* -ENOMEM */\n\n\tif (root_objectid == BTRFS_TREE_RELOC_OBJECTID) {\n\t\tif (parent == 0)\n\t\t\tparent = ins.objectid;\n\t\tflags |= BTRFS_BLOCK_FLAG_FULL_BACKREF;\n\t} else\n\t\tBUG_ON(parent > 0);\n\n\tif (root_objectid != BTRFS_TREE_LOG_OBJECTID) {\n\t\tstruct btrfs_delayed_extent_op *extent_op;\n\t\textent_op = btrfs_alloc_delayed_extent_op();\n\t\tBUG_ON(!extent_op); /* -ENOMEM */\n\t\tif (key)\n\t\t\tmemcpy(&extent_op->key, key, sizeof(extent_op->key));\n\t\telse\n\t\t\tmemset(&extent_op->key, 0, sizeof(extent_op->key));\n\t\textent_op->flags_to_set = flags;\n\t\tif (skinny_metadata)\n\t\t\textent_op->update_key = 0;\n\t\telse\n\t\t\textent_op->update_key = 1;\n\t\textent_op->update_flags = 1;\n\t\textent_op->is_data = 0;\n\t\textent_op->level = level;\n\n\t\tret = btrfs_add_delayed_tree_ref(root->fs_info, trans,\n\t\t\t\t\tins.objectid,\n\t\t\t\t\tins.offset, parent, root_objectid,\n\t\t\t\t\tlevel, BTRFS_ADD_DELAYED_EXTENT,\n\t\t\t\t\textent_op, 0);\n\t\tBUG_ON(ret); /* -ENOMEM */\n\t}\n\treturn buf;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);\nstatic noinline struct;\n\nstruct extent_buffer *btrfs_alloc_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_root *root,\n\t\t\t\t\tu64 parent, u64 root_objectid,\n\t\t\t\t\tstruct btrfs_disk_key *key, int level,\n\t\t\t\t\tu64 hint, u64 empty_size)\n{\n\tstruct btrfs_key ins;\n\tstruct btrfs_block_rsv *block_rsv;\n\tstruct extent_buffer *buf;\n\tu64 flags = 0;\n\tint ret;\n\tu32 blocksize = root->nodesize;\n\tbool skinny_metadata = btrfs_fs_incompat(root->fs_info,\n\t\t\t\t\t\t SKINNY_METADATA);\n\n\tif (btrfs_test_is_dummy_root(root)) {\n\t\tbuf = btrfs_init_new_buffer(trans, root, root->alloc_bytenr,\n\t\t\t\t\t    level);\n\t\tif (!IS_ERR(buf))\n\t\t\troot->alloc_bytenr += blocksize;\n\t\treturn buf;\n\t}\n\n\tblock_rsv = use_block_rsv(trans, root, blocksize);\n\tif (IS_ERR(block_rsv))\n\t\treturn ERR_CAST(block_rsv);\n\n\tret = btrfs_reserve_extent(root, blocksize, blocksize,\n\t\t\t\t   empty_size, hint, &ins, 0, 0);\n\tif (ret) {\n\t\tunuse_block_rsv(root->fs_info, block_rsv, blocksize);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tbuf = btrfs_init_new_buffer(trans, root, ins.objectid, level);\n\tBUG_ON(IS_ERR(buf)); /* -ENOMEM */\n\n\tif (root_objectid == BTRFS_TREE_RELOC_OBJECTID) {\n\t\tif (parent == 0)\n\t\t\tparent = ins.objectid;\n\t\tflags |= BTRFS_BLOCK_FLAG_FULL_BACKREF;\n\t} else\n\t\tBUG_ON(parent > 0);\n\n\tif (root_objectid != BTRFS_TREE_LOG_OBJECTID) {\n\t\tstruct btrfs_delayed_extent_op *extent_op;\n\t\textent_op = btrfs_alloc_delayed_extent_op();\n\t\tBUG_ON(!extent_op); /* -ENOMEM */\n\t\tif (key)\n\t\t\tmemcpy(&extent_op->key, key, sizeof(extent_op->key));\n\t\telse\n\t\t\tmemset(&extent_op->key, 0, sizeof(extent_op->key));\n\t\textent_op->flags_to_set = flags;\n\t\tif (skinny_metadata)\n\t\t\textent_op->update_key = 0;\n\t\telse\n\t\t\textent_op->update_key = 1;\n\t\textent_op->update_flags = 1;\n\t\textent_op->is_data = 0;\n\t\textent_op->level = level;\n\n\t\tret = btrfs_add_delayed_tree_ref(root->fs_info, trans,\n\t\t\t\t\tins.objectid,\n\t\t\t\t\tins.offset, parent, root_objectid,\n\t\t\t\t\tlevel, BTRFS_ADD_DELAYED_EXTENT,\n\t\t\t\t\textent_op, 0);\n\t\tBUG_ON(ret); /* -ENOMEM */\n\t}\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_qgroup_inherit",
          "args": [
            "trans",
            "root->fs_info",
            "0",
            "objectid",
            "inherit"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_qgroup_inherit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "2190-2359",
          "snippet": "int btrfs_qgroup_inherit(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_fs_info *fs_info, u64 srcid, u64 objectid,\n\t\t\t struct btrfs_qgroup_inherit *inherit)\n{\n\tint ret = 0;\n\tint i;\n\tu64 *i_qgroups;\n\tstruct btrfs_root *quota_root = fs_info->quota_root;\n\tstruct btrfs_qgroup *srcgroup;\n\tstruct btrfs_qgroup *dstgroup;\n\tu32 level_size = 0;\n\tu64 nums;\n\n\tmutex_lock(&fs_info->qgroup_ioctl_lock);\n\tif (!fs_info->quota_enabled)\n\t\tgoto out;\n\n\tif (!quota_root) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (inherit) {\n\t\ti_qgroups = (u64 *)(inherit + 1);\n\t\tnums = inherit->num_qgroups + 2 * inherit->num_ref_copies +\n\t\t       2 * inherit->num_excl_copies;\n\t\tfor (i = 0; i < nums; ++i) {\n\t\t\tsrcgroup = find_qgroup_rb(fs_info, *i_qgroups);\n\t\t\tif (!srcgroup) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t++i_qgroups;\n\t\t}\n\t}\n\n\t/*\n\t * create a tracking group for the subvol itself\n\t */\n\tret = add_qgroup_item(trans, quota_root, objectid);\n\tif (ret)\n\t\tgoto out;\n\n\tif (inherit && inherit->flags & BTRFS_QGROUP_INHERIT_SET_LIMITS) {\n\t\tret = update_qgroup_limit_item(trans, quota_root, objectid,\n\t\t\t\t\t       inherit->lim.flags,\n\t\t\t\t\t       inherit->lim.max_rfer,\n\t\t\t\t\t       inherit->lim.max_excl,\n\t\t\t\t\t       inherit->lim.rsv_rfer,\n\t\t\t\t\t       inherit->lim.rsv_excl);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (srcid) {\n\t\tstruct btrfs_root *srcroot;\n\t\tstruct btrfs_key srckey;\n\n\t\tsrckey.objectid = srcid;\n\t\tsrckey.type = BTRFS_ROOT_ITEM_KEY;\n\t\tsrckey.offset = (u64)-1;\n\t\tsrcroot = btrfs_read_fs_root_no_name(fs_info, &srckey);\n\t\tif (IS_ERR(srcroot)) {\n\t\t\tret = PTR_ERR(srcroot);\n\t\t\tgoto out;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tlevel_size = srcroot->nodesize;\n\t\trcu_read_unlock();\n\t}\n\n\t/*\n\t * add qgroup to all inherited groups\n\t */\n\tif (inherit) {\n\t\ti_qgroups = (u64 *)(inherit + 1);\n\t\tfor (i = 0; i < inherit->num_qgroups; ++i) {\n\t\t\tret = add_qgroup_relation_item(trans, quota_root,\n\t\t\t\t\t\t       objectid, *i_qgroups);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tret = add_qgroup_relation_item(trans, quota_root,\n\t\t\t\t\t\t       *i_qgroups, objectid);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\t++i_qgroups;\n\t\t}\n\t}\n\n\n\tspin_lock(&fs_info->qgroup_lock);\n\n\tdstgroup = add_qgroup_rb(fs_info, objectid);\n\tif (IS_ERR(dstgroup)) {\n\t\tret = PTR_ERR(dstgroup);\n\t\tgoto unlock;\n\t}\n\n\tif (srcid) {\n\t\tsrcgroup = find_qgroup_rb(fs_info, srcid);\n\t\tif (!srcgroup)\n\t\t\tgoto unlock;\n\n\t\t/*\n\t\t * We call inherit after we clone the root in order to make sure\n\t\t * our counts don't go crazy, so at this point the only\n\t\t * difference between the two roots should be the root node.\n\t\t */\n\t\tdstgroup->rfer = srcgroup->rfer;\n\t\tdstgroup->rfer_cmpr = srcgroup->rfer_cmpr;\n\t\tdstgroup->excl = level_size;\n\t\tdstgroup->excl_cmpr = level_size;\n\t\tsrcgroup->excl = level_size;\n\t\tsrcgroup->excl_cmpr = level_size;\n\t\tqgroup_dirty(fs_info, dstgroup);\n\t\tqgroup_dirty(fs_info, srcgroup);\n\t}\n\n\tif (!inherit)\n\t\tgoto unlock;\n\n\ti_qgroups = (u64 *)(inherit + 1);\n\tfor (i = 0; i < inherit->num_qgroups; ++i) {\n\t\tret = add_relation_rb(quota_root->fs_info, objectid,\n\t\t\t\t      *i_qgroups);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t\t++i_qgroups;\n\t}\n\n\tfor (i = 0; i <  inherit->num_ref_copies; ++i) {\n\t\tstruct btrfs_qgroup *src;\n\t\tstruct btrfs_qgroup *dst;\n\n\t\tsrc = find_qgroup_rb(fs_info, i_qgroups[0]);\n\t\tdst = find_qgroup_rb(fs_info, i_qgroups[1]);\n\n\t\tif (!src || !dst) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tdst->rfer = src->rfer - level_size;\n\t\tdst->rfer_cmpr = src->rfer_cmpr - level_size;\n\t\ti_qgroups += 2;\n\t}\n\tfor (i = 0; i <  inherit->num_excl_copies; ++i) {\n\t\tstruct btrfs_qgroup *src;\n\t\tstruct btrfs_qgroup *dst;\n\n\t\tsrc = find_qgroup_rb(fs_info, i_qgroups[0]);\n\t\tdst = find_qgroup_rb(fs_info, i_qgroups[1]);\n\n\t\tif (!src || !dst) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tdst->excl = src->excl + level_size;\n\t\tdst->excl_cmpr = src->excl_cmpr + level_size;\n\t\ti_qgroups += 2;\n\t}\n\nunlock:\n\tspin_unlock(&fs_info->qgroup_lock);\nout:\n\tmutex_unlock(&fs_info->qgroup_ioctl_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nint btrfs_qgroup_inherit(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_fs_info *fs_info, u64 srcid, u64 objectid,\n\t\t\t struct btrfs_qgroup_inherit *inherit)\n{\n\tint ret = 0;\n\tint i;\n\tu64 *i_qgroups;\n\tstruct btrfs_root *quota_root = fs_info->quota_root;\n\tstruct btrfs_qgroup *srcgroup;\n\tstruct btrfs_qgroup *dstgroup;\n\tu32 level_size = 0;\n\tu64 nums;\n\n\tmutex_lock(&fs_info->qgroup_ioctl_lock);\n\tif (!fs_info->quota_enabled)\n\t\tgoto out;\n\n\tif (!quota_root) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (inherit) {\n\t\ti_qgroups = (u64 *)(inherit + 1);\n\t\tnums = inherit->num_qgroups + 2 * inherit->num_ref_copies +\n\t\t       2 * inherit->num_excl_copies;\n\t\tfor (i = 0; i < nums; ++i) {\n\t\t\tsrcgroup = find_qgroup_rb(fs_info, *i_qgroups);\n\t\t\tif (!srcgroup) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t++i_qgroups;\n\t\t}\n\t}\n\n\t/*\n\t * create a tracking group for the subvol itself\n\t */\n\tret = add_qgroup_item(trans, quota_root, objectid);\n\tif (ret)\n\t\tgoto out;\n\n\tif (inherit && inherit->flags & BTRFS_QGROUP_INHERIT_SET_LIMITS) {\n\t\tret = update_qgroup_limit_item(trans, quota_root, objectid,\n\t\t\t\t\t       inherit->lim.flags,\n\t\t\t\t\t       inherit->lim.max_rfer,\n\t\t\t\t\t       inherit->lim.max_excl,\n\t\t\t\t\t       inherit->lim.rsv_rfer,\n\t\t\t\t\t       inherit->lim.rsv_excl);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (srcid) {\n\t\tstruct btrfs_root *srcroot;\n\t\tstruct btrfs_key srckey;\n\n\t\tsrckey.objectid = srcid;\n\t\tsrckey.type = BTRFS_ROOT_ITEM_KEY;\n\t\tsrckey.offset = (u64)-1;\n\t\tsrcroot = btrfs_read_fs_root_no_name(fs_info, &srckey);\n\t\tif (IS_ERR(srcroot)) {\n\t\t\tret = PTR_ERR(srcroot);\n\t\t\tgoto out;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tlevel_size = srcroot->nodesize;\n\t\trcu_read_unlock();\n\t}\n\n\t/*\n\t * add qgroup to all inherited groups\n\t */\n\tif (inherit) {\n\t\ti_qgroups = (u64 *)(inherit + 1);\n\t\tfor (i = 0; i < inherit->num_qgroups; ++i) {\n\t\t\tret = add_qgroup_relation_item(trans, quota_root,\n\t\t\t\t\t\t       objectid, *i_qgroups);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tret = add_qgroup_relation_item(trans, quota_root,\n\t\t\t\t\t\t       *i_qgroups, objectid);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\t++i_qgroups;\n\t\t}\n\t}\n\n\n\tspin_lock(&fs_info->qgroup_lock);\n\n\tdstgroup = add_qgroup_rb(fs_info, objectid);\n\tif (IS_ERR(dstgroup)) {\n\t\tret = PTR_ERR(dstgroup);\n\t\tgoto unlock;\n\t}\n\n\tif (srcid) {\n\t\tsrcgroup = find_qgroup_rb(fs_info, srcid);\n\t\tif (!srcgroup)\n\t\t\tgoto unlock;\n\n\t\t/*\n\t\t * We call inherit after we clone the root in order to make sure\n\t\t * our counts don't go crazy, so at this point the only\n\t\t * difference between the two roots should be the root node.\n\t\t */\n\t\tdstgroup->rfer = srcgroup->rfer;\n\t\tdstgroup->rfer_cmpr = srcgroup->rfer_cmpr;\n\t\tdstgroup->excl = level_size;\n\t\tdstgroup->excl_cmpr = level_size;\n\t\tsrcgroup->excl = level_size;\n\t\tsrcgroup->excl_cmpr = level_size;\n\t\tqgroup_dirty(fs_info, dstgroup);\n\t\tqgroup_dirty(fs_info, srcgroup);\n\t}\n\n\tif (!inherit)\n\t\tgoto unlock;\n\n\ti_qgroups = (u64 *)(inherit + 1);\n\tfor (i = 0; i < inherit->num_qgroups; ++i) {\n\t\tret = add_relation_rb(quota_root->fs_info, objectid,\n\t\t\t\t      *i_qgroups);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t\t++i_qgroups;\n\t}\n\n\tfor (i = 0; i <  inherit->num_ref_copies; ++i) {\n\t\tstruct btrfs_qgroup *src;\n\t\tstruct btrfs_qgroup *dst;\n\n\t\tsrc = find_qgroup_rb(fs_info, i_qgroups[0]);\n\t\tdst = find_qgroup_rb(fs_info, i_qgroups[1]);\n\n\t\tif (!src || !dst) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tdst->rfer = src->rfer - level_size;\n\t\tdst->rfer_cmpr = src->rfer_cmpr - level_size;\n\t\ti_qgroups += 2;\n\t}\n\tfor (i = 0; i <  inherit->num_excl_copies; ++i) {\n\t\tstruct btrfs_qgroup *src;\n\t\tstruct btrfs_qgroup *dst;\n\n\t\tsrc = find_qgroup_rb(fs_info, i_qgroups[0]);\n\t\tdst = find_qgroup_rb(fs_info, i_qgroups[1]);\n\n\t\tif (!src || !dst) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tdst->excl = src->excl + level_size;\n\t\tdst->excl_cmpr = src->excl_cmpr + level_size;\n\t\ti_qgroups += 2;\n\t}\n\nunlock:\n\tspin_unlock(&fs_info->qgroup_lock);\nout:\n\tmutex_unlock(&fs_info->qgroup_ioctl_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_start_transaction",
          "args": [
            "root",
            "0"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_transaction_lflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "569-574",
          "snippet": "struct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_subvolume_reserve_metadata",
          "args": [
            "root",
            "&block_rsv",
            "8",
            "&qgroup_reserved",
            "false"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_subvolume_reserve_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "4957-4994",
          "snippet": "int btrfs_subvolume_reserve_metadata(struct btrfs_root *root,\n\t\t\t\t     struct btrfs_block_rsv *rsv,\n\t\t\t\t     int items,\n\t\t\t\t     u64 *qgroup_reserved,\n\t\t\t\t     bool use_global_rsv)\n{\n\tu64 num_bytes;\n\tint ret;\n\tstruct btrfs_block_rsv *global_rsv = &root->fs_info->global_block_rsv;\n\n\tif (root->fs_info->quota_enabled) {\n\t\t/* One for parent inode, two for dir entries */\n\t\tnum_bytes = 3 * root->nodesize;\n\t\tret = btrfs_qgroup_reserve(root, num_bytes);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tnum_bytes = 0;\n\t}\n\n\t*qgroup_reserved = num_bytes;\n\n\tnum_bytes = btrfs_calc_trans_metadata_size(root, items);\n\trsv->space_info = __find_space_info(root->fs_info,\n\t\t\t\t\t    BTRFS_BLOCK_GROUP_METADATA);\n\tret = btrfs_block_rsv_add(root, rsv, num_bytes,\n\t\t\t\t  BTRFS_RESERVE_FLUSH_ALL);\n\n\tif (ret == -ENOSPC && use_global_rsv)\n\t\tret = btrfs_block_rsv_migrate(global_rsv, rsv, num_bytes);\n\n\tif (ret) {\n\t\tif (*qgroup_reserved)\n\t\t\tbtrfs_qgroup_free(root, *qgroup_reserved);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nstatic noinline struct;\n\nint btrfs_subvolume_reserve_metadata(struct btrfs_root *root,\n\t\t\t\t     struct btrfs_block_rsv *rsv,\n\t\t\t\t     int items,\n\t\t\t\t     u64 *qgroup_reserved,\n\t\t\t\t     bool use_global_rsv)\n{\n\tu64 num_bytes;\n\tint ret;\n\tstruct btrfs_block_rsv *global_rsv = &root->fs_info->global_block_rsv;\n\n\tif (root->fs_info->quota_enabled) {\n\t\t/* One for parent inode, two for dir entries */\n\t\tnum_bytes = 3 * root->nodesize;\n\t\tret = btrfs_qgroup_reserve(root, num_bytes);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tnum_bytes = 0;\n\t}\n\n\t*qgroup_reserved = num_bytes;\n\n\tnum_bytes = btrfs_calc_trans_metadata_size(root, items);\n\trsv->space_info = __find_space_info(root->fs_info,\n\t\t\t\t\t    BTRFS_BLOCK_GROUP_METADATA);\n\tret = btrfs_block_rsv_add(root, rsv, num_bytes,\n\t\t\t\t  BTRFS_RESERVE_FLUSH_ALL);\n\n\tif (ret == -ENOSPC && use_global_rsv)\n\t\tret = btrfs_block_rsv_migrate(global_rsv, rsv, num_bytes);\n\n\tif (ret) {\n\t\tif (*qgroup_reserved)\n\t\t\tbtrfs_qgroup_free(root, *qgroup_reserved);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_init_block_rsv",
          "args": [
            "&block_rsv",
            "BTRFS_BLOCK_RSV_TEMP"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_block_rsv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "4671-4676",
          "snippet": "void btrfs_init_block_rsv(struct btrfs_block_rsv *rsv, unsigned short type)\n{\n\tmemset(rsv, 0, sizeof(*rsv));\n\tspin_lock_init(&rsv->lock);\n\trsv->type = type;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_init_block_rsv(struct btrfs_block_rsv *rsv, unsigned short type)\n{\n\tmemset(rsv, 0, sizeof(*rsv));\n\tspin_lock_init(&rsv->lock);\n\trsv->type = type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_find_free_objectid",
          "args": [
            "root->fs_info->tree_root",
            "&objectid"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_free_objectid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode-map.c",
          "lines": "546-568",
          "snippet": "int btrfs_find_free_objectid(struct btrfs_root *root, u64 *objectid)\n{\n\tint ret;\n\tmutex_lock(&root->objectid_mutex);\n\n\tif (unlikely(root->highest_objectid < BTRFS_FIRST_FREE_OBJECTID)) {\n\t\tret = btrfs_find_highest_objectid(root,\n\t\t\t\t\t\t  &root->highest_objectid);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (unlikely(root->highest_objectid >= BTRFS_LAST_FREE_OBJECTID)) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t*objectid = ++root->highest_objectid;\n\tret = 0;\nout:\n\tmutex_unlock(&root->objectid_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n\nint btrfs_find_free_objectid(struct btrfs_root *root, u64 *objectid)\n{\n\tint ret;\n\tmutex_lock(&root->objectid_mutex);\n\n\tif (unlikely(root->highest_objectid < BTRFS_FIRST_FREE_OBJECTID)) {\n\t\tret = btrfs_find_highest_objectid(root,\n\t\t\t\t\t\t  &root->highest_objectid);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (unlikely(root->highest_objectid >= BTRFS_LAST_FREE_OBJECTID)) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t*objectid = ++root->highest_objectid;\n\tret = 0;\nout:\n\tmutex_unlock(&root->objectid_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "dir"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic noinline int create_subvol(struct inode *dir,\n\t\t\t\t  struct dentry *dentry,\n\t\t\t\t  char *name, int namelen,\n\t\t\t\t  u64 *async_transid,\n\t\t\t\t  struct btrfs_qgroup_inherit *inherit)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_key key;\n\tstruct btrfs_root_item root_item;\n\tstruct btrfs_inode_item *inode_item;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_root *root = BTRFS_I(dir)->root;\n\tstruct btrfs_root *new_root;\n\tstruct btrfs_block_rsv block_rsv;\n\tstruct timespec cur_time = CURRENT_TIME;\n\tstruct inode *inode;\n\tint ret;\n\tint err;\n\tu64 objectid;\n\tu64 new_dirid = BTRFS_FIRST_FREE_OBJECTID;\n\tu64 index = 0;\n\tu64 qgroup_reserved;\n\tuuid_le new_uuid;\n\n\tret = btrfs_find_free_objectid(root->fs_info->tree_root, &objectid);\n\tif (ret)\n\t\treturn ret;\n\n\tbtrfs_init_block_rsv(&block_rsv, BTRFS_BLOCK_RSV_TEMP);\n\t/*\n\t * The same as the snapshot creation, please see the comment\n\t * of create_snapshot().\n\t */\n\tret = btrfs_subvolume_reserve_metadata(root, &block_rsv,\n\t\t\t\t\t       8, &qgroup_reserved, false);\n\tif (ret)\n\t\treturn ret;\n\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tbtrfs_subvolume_release_metadata(root, &block_rsv,\n\t\t\t\t\t\t qgroup_reserved);\n\t\treturn ret;\n\t}\n\ttrans->block_rsv = &block_rsv;\n\ttrans->bytes_reserved = block_rsv.size;\n\n\tret = btrfs_qgroup_inherit(trans, root->fs_info, 0, objectid, inherit);\n\tif (ret)\n\t\tgoto fail;\n\n\tleaf = btrfs_alloc_tree_block(trans, root, 0, objectid, NULL, 0, 0, 0);\n\tif (IS_ERR(leaf)) {\n\t\tret = PTR_ERR(leaf);\n\t\tgoto fail;\n\t}\n\n\tmemset_extent_buffer(leaf, 0, 0, sizeof(struct btrfs_header));\n\tbtrfs_set_header_bytenr(leaf, leaf->start);\n\tbtrfs_set_header_generation(leaf, trans->transid);\n\tbtrfs_set_header_backref_rev(leaf, BTRFS_MIXED_BACKREF_REV);\n\tbtrfs_set_header_owner(leaf, objectid);\n\n\twrite_extent_buffer(leaf, root->fs_info->fsid, btrfs_header_fsid(),\n\t\t\t    BTRFS_FSID_SIZE);\n\twrite_extent_buffer(leaf, root->fs_info->chunk_tree_uuid,\n\t\t\t    btrfs_header_chunk_tree_uuid(leaf),\n\t\t\t    BTRFS_UUID_SIZE);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tmemset(&root_item, 0, sizeof(root_item));\n\n\tinode_item = &root_item.inode;\n\tbtrfs_set_stack_inode_generation(inode_item, 1);\n\tbtrfs_set_stack_inode_size(inode_item, 3);\n\tbtrfs_set_stack_inode_nlink(inode_item, 1);\n\tbtrfs_set_stack_inode_nbytes(inode_item, root->nodesize);\n\tbtrfs_set_stack_inode_mode(inode_item, S_IFDIR | 0755);\n\n\tbtrfs_set_root_flags(&root_item, 0);\n\tbtrfs_set_root_limit(&root_item, 0);\n\tbtrfs_set_stack_inode_flags(inode_item, BTRFS_INODE_ROOT_ITEM_INIT);\n\n\tbtrfs_set_root_bytenr(&root_item, leaf->start);\n\tbtrfs_set_root_generation(&root_item, trans->transid);\n\tbtrfs_set_root_level(&root_item, 0);\n\tbtrfs_set_root_refs(&root_item, 1);\n\tbtrfs_set_root_used(&root_item, leaf->len);\n\tbtrfs_set_root_last_snapshot(&root_item, 0);\n\n\tbtrfs_set_root_generation_v2(&root_item,\n\t\t\tbtrfs_root_generation(&root_item));\n\tuuid_le_gen(&new_uuid);\n\tmemcpy(root_item.uuid, new_uuid.b, BTRFS_UUID_SIZE);\n\tbtrfs_set_stack_timespec_sec(&root_item.otime, cur_time.tv_sec);\n\tbtrfs_set_stack_timespec_nsec(&root_item.otime, cur_time.tv_nsec);\n\troot_item.ctime = root_item.otime;\n\tbtrfs_set_root_ctransid(&root_item, trans->transid);\n\tbtrfs_set_root_otransid(&root_item, trans->transid);\n\n\tbtrfs_tree_unlock(leaf);\n\tfree_extent_buffer(leaf);\n\tleaf = NULL;\n\n\tbtrfs_set_root_dirid(&root_item, new_dirid);\n\n\tkey.objectid = objectid;\n\tkey.offset = 0;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tret = btrfs_insert_root(trans, root->fs_info->tree_root, &key,\n\t\t\t\t&root_item);\n\tif (ret)\n\t\tgoto fail;\n\n\tkey.offset = (u64)-1;\n\tnew_root = btrfs_read_fs_root_no_name(root->fs_info, &key);\n\tif (IS_ERR(new_root)) {\n\t\tbtrfs_abort_transaction(trans, root, PTR_ERR(new_root));\n\t\tret = PTR_ERR(new_root);\n\t\tgoto fail;\n\t}\n\n\tbtrfs_record_root_in_trans(trans, new_root);\n\n\tret = btrfs_create_subvol_root(trans, new_root, root, new_dirid);\n\tif (ret) {\n\t\t/* We potentially lose an unused inode item here */\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * insert the directory item\n\t */\n\tret = btrfs_set_inode_index(dir, &index);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tret = btrfs_insert_dir_item(trans, root,\n\t\t\t\t    name, namelen, dir, &key,\n\t\t\t\t    BTRFS_FT_DIR, index);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto fail;\n\t}\n\n\tbtrfs_i_size_write(dir, dir->i_size + namelen * 2);\n\tret = btrfs_update_inode(trans, root, dir);\n\tBUG_ON(ret);\n\n\tret = btrfs_add_root_ref(trans, root->fs_info->tree_root,\n\t\t\t\t objectid, root->root_key.objectid,\n\t\t\t\t btrfs_ino(dir), index, name, namelen);\n\tBUG_ON(ret);\n\n\tret = btrfs_uuid_tree_add(trans, root->fs_info->uuid_root,\n\t\t\t\t  root_item.uuid, BTRFS_UUID_KEY_SUBVOL,\n\t\t\t\t  objectid);\n\tif (ret)\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\nfail:\n\ttrans->block_rsv = NULL;\n\ttrans->bytes_reserved = 0;\n\tbtrfs_subvolume_release_metadata(root, &block_rsv, qgroup_reserved);\n\n\tif (async_transid) {\n\t\t*async_transid = trans->transid;\n\t\terr = btrfs_commit_transaction_async(trans, root, 1);\n\t\tif (err)\n\t\t\terr = btrfs_commit_transaction(trans, root);\n\t} else {\n\t\terr = btrfs_commit_transaction(trans, root);\n\t}\n\tif (err && !ret)\n\t\tret = err;\n\n\tif (!ret) {\n\t\tinode = btrfs_lookup_dentry(dir, dentry);\n\t\tif (IS_ERR(inode))\n\t\t\treturn PTR_ERR(inode);\n\t\td_instantiate(dentry, inode);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_is_empty_uuid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "420-429",
    "snippet": "int btrfs_is_empty_uuid(u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_UUID_SIZE; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nint btrfs_is_empty_uuid(u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_UUID_SIZE; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "btrfs_ioctl_fitrim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "372-418",
    "snippet": "static noinline int btrfs_ioctl_fitrim(struct file *file, void __user *arg)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(file_inode(file)->i_sb);\n\tstruct btrfs_device *device;\n\tstruct request_queue *q;\n\tstruct fstrim_range range;\n\tu64 minlen = ULLONG_MAX;\n\tu64 num_devices = 0;\n\tu64 total_bytes = btrfs_super_total_bytes(fs_info->super_copy);\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(device, &fs_info->fs_devices->devices,\n\t\t\t\tdev_list) {\n\t\tif (!device->bdev)\n\t\t\tcontinue;\n\t\tq = bdev_get_queue(device->bdev);\n\t\tif (blk_queue_discard(q)) {\n\t\t\tnum_devices++;\n\t\t\tminlen = min((u64)q->limits.discard_granularity,\n\t\t\t\t     minlen);\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (!num_devices)\n\t\treturn -EOPNOTSUPP;\n\tif (copy_from_user(&range, arg, sizeof(range)))\n\t\treturn -EFAULT;\n\tif (range.start > total_bytes ||\n\t    range.len < fs_info->sb->s_blocksize)\n\t\treturn -EINVAL;\n\n\trange.len = min(range.len, total_bytes - range.start);\n\trange.minlen = max(range.minlen, minlen);\n\tret = btrfs_trim_fs(fs_info->tree_root, &range);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (copy_to_user(arg, &range, sizeof(range)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "arg",
            "&range",
            "sizeof(range)"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_trim_fs",
          "args": [
            "fs_info->tree_root",
            "&range"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_trim_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "9710-9770",
          "snippet": "int btrfs_trim_fs(struct btrfs_root *root, struct fstrim_range *range)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_block_group_cache *cache = NULL;\n\tu64 group_trimmed;\n\tu64 start;\n\tu64 end;\n\tu64 trimmed = 0;\n\tu64 total_bytes = btrfs_super_total_bytes(fs_info->super_copy);\n\tint ret = 0;\n\n\t/*\n\t * try to trim all FS space, our block group may start from non-zero.\n\t */\n\tif (range->len == total_bytes)\n\t\tcache = btrfs_lookup_first_block_group(fs_info, range->start);\n\telse\n\t\tcache = btrfs_lookup_block_group(fs_info, range->start);\n\n\twhile (cache) {\n\t\tif (cache->key.objectid >= (range->start + range->len)) {\n\t\t\tbtrfs_put_block_group(cache);\n\t\t\tbreak;\n\t\t}\n\n\t\tstart = max(range->start, cache->key.objectid);\n\t\tend = min(range->start + range->len,\n\t\t\t\tcache->key.objectid + cache->key.offset);\n\n\t\tif (end - start >= range->minlen) {\n\t\t\tif (!block_group_cache_done(cache)) {\n\t\t\t\tret = cache_block_group(cache, 0);\n\t\t\t\tif (ret) {\n\t\t\t\t\tbtrfs_put_block_group(cache);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tret = wait_block_group_cache_done(cache);\n\t\t\t\tif (ret) {\n\t\t\t\t\tbtrfs_put_block_group(cache);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tret = btrfs_trim_block_group(cache,\n\t\t\t\t\t\t     &group_trimmed,\n\t\t\t\t\t\t     start,\n\t\t\t\t\t\t     end,\n\t\t\t\t\t\t     range->minlen);\n\n\t\t\ttrimmed += group_trimmed;\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_put_block_group(cache);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tcache = next_block_group(fs_info->tree_root, cache);\n\t}\n\n\trange->len = trimmed;\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);\nstatic noinline struct;\n\nint btrfs_trim_fs(struct btrfs_root *root, struct fstrim_range *range)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_block_group_cache *cache = NULL;\n\tu64 group_trimmed;\n\tu64 start;\n\tu64 end;\n\tu64 trimmed = 0;\n\tu64 total_bytes = btrfs_super_total_bytes(fs_info->super_copy);\n\tint ret = 0;\n\n\t/*\n\t * try to trim all FS space, our block group may start from non-zero.\n\t */\n\tif (range->len == total_bytes)\n\t\tcache = btrfs_lookup_first_block_group(fs_info, range->start);\n\telse\n\t\tcache = btrfs_lookup_block_group(fs_info, range->start);\n\n\twhile (cache) {\n\t\tif (cache->key.objectid >= (range->start + range->len)) {\n\t\t\tbtrfs_put_block_group(cache);\n\t\t\tbreak;\n\t\t}\n\n\t\tstart = max(range->start, cache->key.objectid);\n\t\tend = min(range->start + range->len,\n\t\t\t\tcache->key.objectid + cache->key.offset);\n\n\t\tif (end - start >= range->minlen) {\n\t\t\tif (!block_group_cache_done(cache)) {\n\t\t\t\tret = cache_block_group(cache, 0);\n\t\t\t\tif (ret) {\n\t\t\t\t\tbtrfs_put_block_group(cache);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tret = wait_block_group_cache_done(cache);\n\t\t\t\tif (ret) {\n\t\t\t\t\tbtrfs_put_block_group(cache);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tret = btrfs_trim_block_group(cache,\n\t\t\t\t\t\t     &group_trimmed,\n\t\t\t\t\t\t     start,\n\t\t\t\t\t\t     end,\n\t\t\t\t\t\t     range->minlen);\n\n\t\t\ttrimmed += group_trimmed;\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_put_block_group(cache);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tcache = next_block_group(fs_info->tree_root, cache);\n\t}\n\n\trange->len = trimmed;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "range.minlen",
            "minlen"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_info_handle_maxslots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ioctl.c",
          "lines": "182-199",
          "snippet": "static int ocfs2_info_handle_maxslots(struct inode *inode,\n\t\t\t\t      struct ocfs2_info_request __user *req)\n{\n\tstruct ocfs2_info_maxslots oim;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (o2info_from_user(oim, req))\n\t\treturn -EFAULT;\n\n\toim.im_max_slots = osb->max_slots;\n\n\to2info_set_request_filled(&oim.im_req);\n\n\tif (o2info_to_user(oim, req))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"move_extents.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"dir.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"resize.h\"",
            "#include \"ioctl.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"move_extents.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"dir.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"resize.h\"\n#include \"ioctl.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_info_handle_maxslots(struct inode *inode,\n\t\t\t\t      struct ocfs2_info_request __user *req)\n{\n\tstruct ocfs2_info_maxslots oim;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (o2info_from_user(oim, req))\n\t\treturn -EFAULT;\n\n\toim.im_max_slots = osb->max_slots;\n\n\to2info_set_request_filled(&oim.im_req);\n\n\tif (o2info_to_user(oim, req))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "range.len",
            "total_bytes - range.start"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&range",
            "arg",
            "sizeof(range)"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_queue_discard",
          "args": [
            "q"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_get_queue",
          "args": [
            "device->bdev"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "device",
            "&fs_info->fs_devices->devices",
            "dev_list"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_super_total_bytes",
          "args": [
            "fs_info->super_copy"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_sb",
          "args": [
            "file_inode(file)->i_sb"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3272-3275",
          "snippet": "static inline struct btrfs_fs_info *btrfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct btrfs_fs_info *btrfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic noinline int btrfs_ioctl_fitrim(struct file *file, void __user *arg)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(file_inode(file)->i_sb);\n\tstruct btrfs_device *device;\n\tstruct request_queue *q;\n\tstruct fstrim_range range;\n\tu64 minlen = ULLONG_MAX;\n\tu64 num_devices = 0;\n\tu64 total_bytes = btrfs_super_total_bytes(fs_info->super_copy);\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(device, &fs_info->fs_devices->devices,\n\t\t\t\tdev_list) {\n\t\tif (!device->bdev)\n\t\t\tcontinue;\n\t\tq = bdev_get_queue(device->bdev);\n\t\tif (blk_queue_discard(q)) {\n\t\t\tnum_devices++;\n\t\t\tminlen = min((u64)q->limits.discard_granularity,\n\t\t\t\t     minlen);\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (!num_devices)\n\t\treturn -EOPNOTSUPP;\n\tif (copy_from_user(&range, arg, sizeof(range)))\n\t\treturn -EFAULT;\n\tif (range.start > total_bytes ||\n\t    range.len < fs_info->sb->s_blocksize)\n\t\treturn -EINVAL;\n\n\trange.len = min(range.len, total_bytes - range.start);\n\trange.minlen = max(range.minlen, minlen);\n\tret = btrfs_trim_fs(fs_info->tree_root, &range);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (copy_to_user(arg, &range, sizeof(range)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_ioctl_getversion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "365-370",
    "snippet": "static int btrfs_ioctl_getversion(struct file *file, int __user *arg)\n{\n\tstruct inode *inode = file_inode(file);\n\n\treturn put_user(inode->i_generation, arg);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "inode->i_generation",
            "arg"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_ioctl_getversion(struct file *file, int __user *arg)\n{\n\tstruct inode *inode = file_inode(file);\n\n\treturn put_user(inode->i_generation, arg);\n}"
  },
  {
    "function_name": "btrfs_ioctl_setflags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "213-363",
    "snippet": "static int btrfs_ioctl_setflags(struct file *file, void __user *arg)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_inode *ip = BTRFS_I(inode);\n\tstruct btrfs_root *root = ip->root;\n\tstruct btrfs_trans_handle *trans;\n\tunsigned int flags, oldflags;\n\tint ret;\n\tu64 ip_oldflags;\n\tunsigned int i_oldflags;\n\tumode_t mode;\n\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EPERM;\n\n\tif (btrfs_root_readonly(root))\n\t\treturn -EROFS;\n\n\tif (copy_from_user(&flags, arg, sizeof(flags)))\n\t\treturn -EFAULT;\n\n\tret = check_flags(flags);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&inode->i_mutex);\n\n\tip_oldflags = ip->flags;\n\ti_oldflags = inode->i_flags;\n\tmode = inode->i_mode;\n\n\tflags = btrfs_mask_flags(inode->i_mode, flags);\n\toldflags = btrfs_flags_to_ioctl(ip->flags);\n\tif ((flags ^ oldflags) & (FS_APPEND_FL | FS_IMMUTABLE_FL)) {\n\t\tif (!capable(CAP_LINUX_IMMUTABLE)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tif (flags & FS_SYNC_FL)\n\t\tip->flags |= BTRFS_INODE_SYNC;\n\telse\n\t\tip->flags &= ~BTRFS_INODE_SYNC;\n\tif (flags & FS_IMMUTABLE_FL)\n\t\tip->flags |= BTRFS_INODE_IMMUTABLE;\n\telse\n\t\tip->flags &= ~BTRFS_INODE_IMMUTABLE;\n\tif (flags & FS_APPEND_FL)\n\t\tip->flags |= BTRFS_INODE_APPEND;\n\telse\n\t\tip->flags &= ~BTRFS_INODE_APPEND;\n\tif (flags & FS_NODUMP_FL)\n\t\tip->flags |= BTRFS_INODE_NODUMP;\n\telse\n\t\tip->flags &= ~BTRFS_INODE_NODUMP;\n\tif (flags & FS_NOATIME_FL)\n\t\tip->flags |= BTRFS_INODE_NOATIME;\n\telse\n\t\tip->flags &= ~BTRFS_INODE_NOATIME;\n\tif (flags & FS_DIRSYNC_FL)\n\t\tip->flags |= BTRFS_INODE_DIRSYNC;\n\telse\n\t\tip->flags &= ~BTRFS_INODE_DIRSYNC;\n\tif (flags & FS_NOCOW_FL) {\n\t\tif (S_ISREG(mode)) {\n\t\t\t/*\n\t\t\t * It's safe to turn csums off here, no extents exist.\n\t\t\t * Otherwise we want the flag to reflect the real COW\n\t\t\t * status of the file and will not set it.\n\t\t\t */\n\t\t\tif (inode->i_size == 0)\n\t\t\t\tip->flags |= BTRFS_INODE_NODATACOW\n\t\t\t\t\t   | BTRFS_INODE_NODATASUM;\n\t\t} else {\n\t\t\tip->flags |= BTRFS_INODE_NODATACOW;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Revert back under same assuptions as above\n\t\t */\n\t\tif (S_ISREG(mode)) {\n\t\t\tif (inode->i_size == 0)\n\t\t\t\tip->flags &= ~(BTRFS_INODE_NODATACOW\n\t\t\t\t             | BTRFS_INODE_NODATASUM);\n\t\t} else {\n\t\t\tip->flags &= ~BTRFS_INODE_NODATACOW;\n\t\t}\n\t}\n\n\t/*\n\t * The COMPRESS flag can only be changed by users, while the NOCOMPRESS\n\t * flag may be changed automatically if compression code won't make\n\t * things smaller.\n\t */\n\tif (flags & FS_NOCOMP_FL) {\n\t\tip->flags &= ~BTRFS_INODE_COMPRESS;\n\t\tip->flags |= BTRFS_INODE_NOCOMPRESS;\n\n\t\tret = btrfs_set_prop(inode, \"btrfs.compression\", NULL, 0, 0);\n\t\tif (ret && ret != -ENODATA)\n\t\t\tgoto out_drop;\n\t} else if (flags & FS_COMPR_FL) {\n\t\tconst char *comp;\n\n\t\tip->flags |= BTRFS_INODE_COMPRESS;\n\t\tip->flags &= ~BTRFS_INODE_NOCOMPRESS;\n\n\t\tif (root->fs_info->compress_type == BTRFS_COMPRESS_LZO)\n\t\t\tcomp = \"lzo\";\n\t\telse\n\t\t\tcomp = \"zlib\";\n\t\tret = btrfs_set_prop(inode, \"btrfs.compression\",\n\t\t\t\t     comp, strlen(comp), 0);\n\t\tif (ret)\n\t\t\tgoto out_drop;\n\n\t} else {\n\t\tret = btrfs_set_prop(inode, \"btrfs.compression\", NULL, 0, 0);\n\t\tif (ret && ret != -ENODATA)\n\t\t\tgoto out_drop;\n\t\tip->flags &= ~(BTRFS_INODE_COMPRESS | BTRFS_INODE_NOCOMPRESS);\n\t}\n\n\ttrans = btrfs_start_transaction(root, 1);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out_drop;\n\t}\n\n\tbtrfs_update_iflags(inode);\n\tinode_inc_iversion(inode);\n\tinode->i_ctime = CURRENT_TIME;\n\tret = btrfs_update_inode(trans, root, inode);\n\n\tbtrfs_end_transaction(trans, root);\n out_drop:\n\tif (ret) {\n\t\tip->flags = ip_oldflags;\n\t\tinode->i_flags = i_oldflags;\n\t}\n\n out_unlock:\n\tmutex_unlock(&inode->i_mutex);\n\tmnt_drop_write_file(file);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "file"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_end_transaction",
          "args": [
            "trans",
            "root"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_end_transaction_throttle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "846-850",
          "snippet": "int btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_update_inode",
          "args": [
            "trans",
            "root",
            "inode"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_update_inode_fallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3841-3851",
          "snippet": "noinline int btrfs_update_inode_fallback(struct btrfs_trans_handle *trans,\n\t\t\t\t\t struct btrfs_root *root,\n\t\t\t\t\t struct inode *inode)\n{\n\tint ret;\n\n\tret = btrfs_update_inode(trans, root, inode);\n\tif (ret == -ENOSPC)\n\t\treturn btrfs_update_inode_item(trans, root, inode);\n\treturn ret;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nnoinline int btrfs_update_inode_fallback(struct btrfs_trans_handle *trans,\n\t\t\t\t\t struct btrfs_root *root,\n\t\t\t\t\t struct inode *inode)\n{\n\tint ret;\n\n\tret = btrfs_update_inode(trans, root, inode);\n\tif (ret == -ENOSPC)\n\t\treturn btrfs_update_inode_item(trans, root, inode);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_inc_iversion",
          "args": [
            "inode"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_update_iflags",
          "args": [
            "inode"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_update_iflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "136-155",
          "snippet": "void btrfs_update_iflags(struct inode *inode)\n{\n\tstruct btrfs_inode *ip = BTRFS_I(inode);\n\tunsigned int new_fl = 0;\n\n\tif (ip->flags & BTRFS_INODE_SYNC)\n\t\tnew_fl |= S_SYNC;\n\tif (ip->flags & BTRFS_INODE_IMMUTABLE)\n\t\tnew_fl |= S_IMMUTABLE;\n\tif (ip->flags & BTRFS_INODE_APPEND)\n\t\tnew_fl |= S_APPEND;\n\tif (ip->flags & BTRFS_INODE_NOATIME)\n\t\tnew_fl |= S_NOATIME;\n\tif (ip->flags & BTRFS_INODE_DIRSYNC)\n\t\tnew_fl |= S_DIRSYNC;\n\n\tset_mask_bits(&inode->i_flags,\n\t\t      S_SYNC | S_APPEND | S_IMMUTABLE | S_NOATIME | S_DIRSYNC,\n\t\t      new_fl);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nvoid btrfs_update_iflags(struct inode *inode)\n{\n\tstruct btrfs_inode *ip = BTRFS_I(inode);\n\tunsigned int new_fl = 0;\n\n\tif (ip->flags & BTRFS_INODE_SYNC)\n\t\tnew_fl |= S_SYNC;\n\tif (ip->flags & BTRFS_INODE_IMMUTABLE)\n\t\tnew_fl |= S_IMMUTABLE;\n\tif (ip->flags & BTRFS_INODE_APPEND)\n\t\tnew_fl |= S_APPEND;\n\tif (ip->flags & BTRFS_INODE_NOATIME)\n\t\tnew_fl |= S_NOATIME;\n\tif (ip->flags & BTRFS_INODE_DIRSYNC)\n\t\tnew_fl |= S_DIRSYNC;\n\n\tset_mask_bits(&inode->i_flags,\n\t\t      S_SYNC | S_APPEND | S_IMMUTABLE | S_NOATIME | S_DIRSYNC,\n\t\t      new_fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_start_transaction",
          "args": [
            "root",
            "1"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_transaction_lflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "569-574",
          "snippet": "struct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_prop",
          "args": [
            "inode",
            "\"btrfs.compression\"",
            "NULL",
            "0",
            "0"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_prop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/props.c",
          "lines": "150-157",
          "snippet": "int btrfs_set_prop(struct inode *inode,\n\t\t   const char *name,\n\t\t   const char *value,\n\t\t   size_t value_len,\n\t\t   int flags)\n{\n\treturn __btrfs_set_prop(NULL, inode, name, value, value_len, flags);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"props.h\"",
            "#include <linux/hashtable.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *prop_compression_extract(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"btrfs_inode.h\"\n#include \"props.h\"\n#include <linux/hashtable.h>\n\nstatic const char *prop_compression_extract(struct inode *inode);\n\nint btrfs_set_prop(struct inode *inode,\n\t\t   const char *name,\n\t\t   const char *value,\n\t\t   size_t value_len,\n\t\t   int flags)\n{\n\treturn __btrfs_set_prop(NULL, inode, name, value, value_len, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "comp"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "mode"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "mode"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_LINUX_IMMUTABLE"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_flags_to_ioctl",
          "args": [
            "ip->flags"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_flags_to_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "106-131",
          "snippet": "static unsigned int btrfs_flags_to_ioctl(unsigned int flags)\n{\n\tunsigned int iflags = 0;\n\n\tif (flags & BTRFS_INODE_SYNC)\n\t\tiflags |= FS_SYNC_FL;\n\tif (flags & BTRFS_INODE_IMMUTABLE)\n\t\tiflags |= FS_IMMUTABLE_FL;\n\tif (flags & BTRFS_INODE_APPEND)\n\t\tiflags |= FS_APPEND_FL;\n\tif (flags & BTRFS_INODE_NODUMP)\n\t\tiflags |= FS_NODUMP_FL;\n\tif (flags & BTRFS_INODE_NOATIME)\n\t\tiflags |= FS_NOATIME_FL;\n\tif (flags & BTRFS_INODE_DIRSYNC)\n\t\tiflags |= FS_DIRSYNC_FL;\n\tif (flags & BTRFS_INODE_NODATACOW)\n\t\tiflags |= FS_NOCOW_FL;\n\n\tif ((flags & BTRFS_INODE_COMPRESS) && !(flags & BTRFS_INODE_NOCOMPRESS))\n\t\tiflags |= FS_COMPR_FL;\n\telse if (flags & BTRFS_INODE_NOCOMPRESS)\n\t\tiflags |= FS_NOCOMP_FL;\n\n\treturn iflags;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic unsigned int btrfs_flags_to_ioctl(unsigned int flags)\n{\n\tunsigned int iflags = 0;\n\n\tif (flags & BTRFS_INODE_SYNC)\n\t\tiflags |= FS_SYNC_FL;\n\tif (flags & BTRFS_INODE_IMMUTABLE)\n\t\tiflags |= FS_IMMUTABLE_FL;\n\tif (flags & BTRFS_INODE_APPEND)\n\t\tiflags |= FS_APPEND_FL;\n\tif (flags & BTRFS_INODE_NODUMP)\n\t\tiflags |= FS_NODUMP_FL;\n\tif (flags & BTRFS_INODE_NOATIME)\n\t\tiflags |= FS_NOATIME_FL;\n\tif (flags & BTRFS_INODE_DIRSYNC)\n\t\tiflags |= FS_DIRSYNC_FL;\n\tif (flags & BTRFS_INODE_NODATACOW)\n\t\tiflags |= FS_NOCOW_FL;\n\n\tif ((flags & BTRFS_INODE_COMPRESS) && !(flags & BTRFS_INODE_NOCOMPRESS))\n\t\tiflags |= FS_COMPR_FL;\n\telse if (flags & BTRFS_INODE_NOCOMPRESS)\n\t\tiflags |= FS_NOCOMP_FL;\n\n\treturn iflags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_mask_flags",
          "args": [
            "inode->i_mode",
            "flags"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mask_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "93-101",
          "snippet": "static inline __u32 btrfs_mask_flags(umode_t mode, __u32 flags)\n{\n\tif (S_ISDIR(mode))\n\t\treturn flags;\n\telse if (S_ISREG(mode))\n\t\treturn flags & ~FS_DIRSYNC_FL;\n\telse\n\t\treturn flags & (FS_NODUMP_FL | FS_NOATIME_FL);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic inline __u32 btrfs_mask_flags(umode_t mode, __u32 flags)\n{\n\tif (S_ISDIR(mode))\n\t\treturn flags;\n\telse if (S_ISREG(mode))\n\t\treturn flags & ~FS_DIRSYNC_FL;\n\telse\n\t\treturn flags & (FS_NODUMP_FL | FS_NOATIME_FL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "file"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_flags",
          "args": [
            "flags"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "check_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "198-211",
          "snippet": "static int check_flags(unsigned int flags)\n{\n\tif (flags & ~(FS_IMMUTABLE_FL | FS_APPEND_FL | \\\n\t\t      FS_NOATIME_FL | FS_NODUMP_FL | \\\n\t\t      FS_SYNC_FL | FS_DIRSYNC_FL | \\\n\t\t      FS_NOCOMP_FL | FS_COMPR_FL |\n\t\t      FS_NOCOW_FL))\n\t\treturn -EOPNOTSUPP;\n\n\tif ((flags & FS_NOCOMP_FL) && (flags & FS_COMPR_FL))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int check_flags(unsigned int flags)\n{\n\tif (flags & ~(FS_IMMUTABLE_FL | FS_APPEND_FL | \\\n\t\t      FS_NOATIME_FL | FS_NODUMP_FL | \\\n\t\t      FS_SYNC_FL | FS_DIRSYNC_FL | \\\n\t\t      FS_NOCOMP_FL | FS_COMPR_FL |\n\t\t      FS_NOCOW_FL))\n\t\treturn -EOPNOTSUPP;\n\n\tif ((flags & FS_NOCOMP_FL) && (flags & FS_COMPR_FL))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&flags",
            "arg",
            "sizeof(flags)"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_root_readonly",
          "args": [
            "root"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_root_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2876-2879",
          "snippet": "static inline bool btrfs_root_readonly(struct btrfs_root *root)\n{\n\treturn (root->root_item.flags & cpu_to_le64(BTRFS_ROOT_SUBVOL_RDONLY)) != 0;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_ROOT_SUBVOL_RDONLY\t(1ULL << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_ROOT_SUBVOL_RDONLY\t(1ULL << 0)\n\nstatic inline bool btrfs_root_readonly(struct btrfs_root *root)\n{\n\treturn (root->root_item.flags & cpu_to_le64(BTRFS_ROOT_SUBVOL_RDONLY)) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_ioctl_setflags(struct file *file, void __user *arg)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_inode *ip = BTRFS_I(inode);\n\tstruct btrfs_root *root = ip->root;\n\tstruct btrfs_trans_handle *trans;\n\tunsigned int flags, oldflags;\n\tint ret;\n\tu64 ip_oldflags;\n\tunsigned int i_oldflags;\n\tumode_t mode;\n\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EPERM;\n\n\tif (btrfs_root_readonly(root))\n\t\treturn -EROFS;\n\n\tif (copy_from_user(&flags, arg, sizeof(flags)))\n\t\treturn -EFAULT;\n\n\tret = check_flags(flags);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&inode->i_mutex);\n\n\tip_oldflags = ip->flags;\n\ti_oldflags = inode->i_flags;\n\tmode = inode->i_mode;\n\n\tflags = btrfs_mask_flags(inode->i_mode, flags);\n\toldflags = btrfs_flags_to_ioctl(ip->flags);\n\tif ((flags ^ oldflags) & (FS_APPEND_FL | FS_IMMUTABLE_FL)) {\n\t\tif (!capable(CAP_LINUX_IMMUTABLE)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tif (flags & FS_SYNC_FL)\n\t\tip->flags |= BTRFS_INODE_SYNC;\n\telse\n\t\tip->flags &= ~BTRFS_INODE_SYNC;\n\tif (flags & FS_IMMUTABLE_FL)\n\t\tip->flags |= BTRFS_INODE_IMMUTABLE;\n\telse\n\t\tip->flags &= ~BTRFS_INODE_IMMUTABLE;\n\tif (flags & FS_APPEND_FL)\n\t\tip->flags |= BTRFS_INODE_APPEND;\n\telse\n\t\tip->flags &= ~BTRFS_INODE_APPEND;\n\tif (flags & FS_NODUMP_FL)\n\t\tip->flags |= BTRFS_INODE_NODUMP;\n\telse\n\t\tip->flags &= ~BTRFS_INODE_NODUMP;\n\tif (flags & FS_NOATIME_FL)\n\t\tip->flags |= BTRFS_INODE_NOATIME;\n\telse\n\t\tip->flags &= ~BTRFS_INODE_NOATIME;\n\tif (flags & FS_DIRSYNC_FL)\n\t\tip->flags |= BTRFS_INODE_DIRSYNC;\n\telse\n\t\tip->flags &= ~BTRFS_INODE_DIRSYNC;\n\tif (flags & FS_NOCOW_FL) {\n\t\tif (S_ISREG(mode)) {\n\t\t\t/*\n\t\t\t * It's safe to turn csums off here, no extents exist.\n\t\t\t * Otherwise we want the flag to reflect the real COW\n\t\t\t * status of the file and will not set it.\n\t\t\t */\n\t\t\tif (inode->i_size == 0)\n\t\t\t\tip->flags |= BTRFS_INODE_NODATACOW\n\t\t\t\t\t   | BTRFS_INODE_NODATASUM;\n\t\t} else {\n\t\t\tip->flags |= BTRFS_INODE_NODATACOW;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Revert back under same assuptions as above\n\t\t */\n\t\tif (S_ISREG(mode)) {\n\t\t\tif (inode->i_size == 0)\n\t\t\t\tip->flags &= ~(BTRFS_INODE_NODATACOW\n\t\t\t\t             | BTRFS_INODE_NODATASUM);\n\t\t} else {\n\t\t\tip->flags &= ~BTRFS_INODE_NODATACOW;\n\t\t}\n\t}\n\n\t/*\n\t * The COMPRESS flag can only be changed by users, while the NOCOMPRESS\n\t * flag may be changed automatically if compression code won't make\n\t * things smaller.\n\t */\n\tif (flags & FS_NOCOMP_FL) {\n\t\tip->flags &= ~BTRFS_INODE_COMPRESS;\n\t\tip->flags |= BTRFS_INODE_NOCOMPRESS;\n\n\t\tret = btrfs_set_prop(inode, \"btrfs.compression\", NULL, 0, 0);\n\t\tif (ret && ret != -ENODATA)\n\t\t\tgoto out_drop;\n\t} else if (flags & FS_COMPR_FL) {\n\t\tconst char *comp;\n\n\t\tip->flags |= BTRFS_INODE_COMPRESS;\n\t\tip->flags &= ~BTRFS_INODE_NOCOMPRESS;\n\n\t\tif (root->fs_info->compress_type == BTRFS_COMPRESS_LZO)\n\t\t\tcomp = \"lzo\";\n\t\telse\n\t\t\tcomp = \"zlib\";\n\t\tret = btrfs_set_prop(inode, \"btrfs.compression\",\n\t\t\t\t     comp, strlen(comp), 0);\n\t\tif (ret)\n\t\t\tgoto out_drop;\n\n\t} else {\n\t\tret = btrfs_set_prop(inode, \"btrfs.compression\", NULL, 0, 0);\n\t\tif (ret && ret != -ENODATA)\n\t\t\tgoto out_drop;\n\t\tip->flags &= ~(BTRFS_INODE_COMPRESS | BTRFS_INODE_NOCOMPRESS);\n\t}\n\n\ttrans = btrfs_start_transaction(root, 1);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out_drop;\n\t}\n\n\tbtrfs_update_iflags(inode);\n\tinode_inc_iversion(inode);\n\tinode->i_ctime = CURRENT_TIME;\n\tret = btrfs_update_inode(trans, root, inode);\n\n\tbtrfs_end_transaction(trans, root);\n out_drop:\n\tif (ret) {\n\t\tip->flags = ip_oldflags;\n\t\tinode->i_flags = i_oldflags;\n\t}\n\n out_unlock:\n\tmutex_unlock(&inode->i_mutex);\n\tmnt_drop_write_file(file);\n\treturn ret;\n}"
  },
  {
    "function_name": "check_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "198-211",
    "snippet": "static int check_flags(unsigned int flags)\n{\n\tif (flags & ~(FS_IMMUTABLE_FL | FS_APPEND_FL | \\\n\t\t      FS_NOATIME_FL | FS_NODUMP_FL | \\\n\t\t      FS_SYNC_FL | FS_DIRSYNC_FL | \\\n\t\t      FS_NOCOMP_FL | FS_COMPR_FL |\n\t\t      FS_NOCOW_FL))\n\t\treturn -EOPNOTSUPP;\n\n\tif ((flags & FS_NOCOMP_FL) && (flags & FS_COMPR_FL))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int check_flags(unsigned int flags)\n{\n\tif (flags & ~(FS_IMMUTABLE_FL | FS_APPEND_FL | \\\n\t\t      FS_NOATIME_FL | FS_NODUMP_FL | \\\n\t\t      FS_SYNC_FL | FS_DIRSYNC_FL | \\\n\t\t      FS_NOCOMP_FL | FS_COMPR_FL |\n\t\t      FS_NOCOW_FL))\n\t\treturn -EOPNOTSUPP;\n\n\tif ((flags & FS_NOCOMP_FL) && (flags & FS_COMPR_FL))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_ioctl_getflags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "188-196",
    "snippet": "static int btrfs_ioctl_getflags(struct file *file, void __user *arg)\n{\n\tstruct btrfs_inode *ip = BTRFS_I(file_inode(file));\n\tunsigned int flags = btrfs_flags_to_ioctl(ip->flags);\n\n\tif (copy_to_user(arg, &flags, sizeof(flags)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "arg",
            "&flags",
            "sizeof(flags)"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_flags_to_ioctl",
          "args": [
            "ip->flags"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_flags_to_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "106-131",
          "snippet": "static unsigned int btrfs_flags_to_ioctl(unsigned int flags)\n{\n\tunsigned int iflags = 0;\n\n\tif (flags & BTRFS_INODE_SYNC)\n\t\tiflags |= FS_SYNC_FL;\n\tif (flags & BTRFS_INODE_IMMUTABLE)\n\t\tiflags |= FS_IMMUTABLE_FL;\n\tif (flags & BTRFS_INODE_APPEND)\n\t\tiflags |= FS_APPEND_FL;\n\tif (flags & BTRFS_INODE_NODUMP)\n\t\tiflags |= FS_NODUMP_FL;\n\tif (flags & BTRFS_INODE_NOATIME)\n\t\tiflags |= FS_NOATIME_FL;\n\tif (flags & BTRFS_INODE_DIRSYNC)\n\t\tiflags |= FS_DIRSYNC_FL;\n\tif (flags & BTRFS_INODE_NODATACOW)\n\t\tiflags |= FS_NOCOW_FL;\n\n\tif ((flags & BTRFS_INODE_COMPRESS) && !(flags & BTRFS_INODE_NOCOMPRESS))\n\t\tiflags |= FS_COMPR_FL;\n\telse if (flags & BTRFS_INODE_NOCOMPRESS)\n\t\tiflags |= FS_NOCOMP_FL;\n\n\treturn iflags;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic unsigned int btrfs_flags_to_ioctl(unsigned int flags)\n{\n\tunsigned int iflags = 0;\n\n\tif (flags & BTRFS_INODE_SYNC)\n\t\tiflags |= FS_SYNC_FL;\n\tif (flags & BTRFS_INODE_IMMUTABLE)\n\t\tiflags |= FS_IMMUTABLE_FL;\n\tif (flags & BTRFS_INODE_APPEND)\n\t\tiflags |= FS_APPEND_FL;\n\tif (flags & BTRFS_INODE_NODUMP)\n\t\tiflags |= FS_NODUMP_FL;\n\tif (flags & BTRFS_INODE_NOATIME)\n\t\tiflags |= FS_NOATIME_FL;\n\tif (flags & BTRFS_INODE_DIRSYNC)\n\t\tiflags |= FS_DIRSYNC_FL;\n\tif (flags & BTRFS_INODE_NODATACOW)\n\t\tiflags |= FS_NOCOW_FL;\n\n\tif ((flags & BTRFS_INODE_COMPRESS) && !(flags & BTRFS_INODE_NOCOMPRESS))\n\t\tiflags |= FS_COMPR_FL;\n\telse if (flags & BTRFS_INODE_NOCOMPRESS)\n\t\tiflags |= FS_NOCOMP_FL;\n\n\treturn iflags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "file_inode(file)"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_ioctl_getflags(struct file *file, void __user *arg)\n{\n\tstruct btrfs_inode *ip = BTRFS_I(file_inode(file));\n\tunsigned int flags = btrfs_flags_to_ioctl(ip->flags);\n\n\tif (copy_to_user(arg, &flags, sizeof(flags)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_inherit_iflags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "162-186",
    "snippet": "void btrfs_inherit_iflags(struct inode *inode, struct inode *dir)\n{\n\tunsigned int flags;\n\n\tif (!dir)\n\t\treturn;\n\n\tflags = BTRFS_I(dir)->flags;\n\n\tif (flags & BTRFS_INODE_NOCOMPRESS) {\n\t\tBTRFS_I(inode)->flags &= ~BTRFS_INODE_COMPRESS;\n\t\tBTRFS_I(inode)->flags |= BTRFS_INODE_NOCOMPRESS;\n\t} else if (flags & BTRFS_INODE_COMPRESS) {\n\t\tBTRFS_I(inode)->flags &= ~BTRFS_INODE_NOCOMPRESS;\n\t\tBTRFS_I(inode)->flags |= BTRFS_INODE_COMPRESS;\n\t}\n\n\tif (flags & BTRFS_INODE_NODATACOW) {\n\t\tBTRFS_I(inode)->flags |= BTRFS_INODE_NODATACOW;\n\t\tif (S_ISREG(inode->i_mode))\n\t\t\tBTRFS_I(inode)->flags |= BTRFS_INODE_NODATASUM;\n\t}\n\n\tbtrfs_update_iflags(inode);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_update_iflags",
          "args": [
            "inode"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_update_iflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "136-155",
          "snippet": "void btrfs_update_iflags(struct inode *inode)\n{\n\tstruct btrfs_inode *ip = BTRFS_I(inode);\n\tunsigned int new_fl = 0;\n\n\tif (ip->flags & BTRFS_INODE_SYNC)\n\t\tnew_fl |= S_SYNC;\n\tif (ip->flags & BTRFS_INODE_IMMUTABLE)\n\t\tnew_fl |= S_IMMUTABLE;\n\tif (ip->flags & BTRFS_INODE_APPEND)\n\t\tnew_fl |= S_APPEND;\n\tif (ip->flags & BTRFS_INODE_NOATIME)\n\t\tnew_fl |= S_NOATIME;\n\tif (ip->flags & BTRFS_INODE_DIRSYNC)\n\t\tnew_fl |= S_DIRSYNC;\n\n\tset_mask_bits(&inode->i_flags,\n\t\t      S_SYNC | S_APPEND | S_IMMUTABLE | S_NOATIME | S_DIRSYNC,\n\t\t      new_fl);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nvoid btrfs_update_iflags(struct inode *inode)\n{\n\tstruct btrfs_inode *ip = BTRFS_I(inode);\n\tunsigned int new_fl = 0;\n\n\tif (ip->flags & BTRFS_INODE_SYNC)\n\t\tnew_fl |= S_SYNC;\n\tif (ip->flags & BTRFS_INODE_IMMUTABLE)\n\t\tnew_fl |= S_IMMUTABLE;\n\tif (ip->flags & BTRFS_INODE_APPEND)\n\t\tnew_fl |= S_APPEND;\n\tif (ip->flags & BTRFS_INODE_NOATIME)\n\t\tnew_fl |= S_NOATIME;\n\tif (ip->flags & BTRFS_INODE_DIRSYNC)\n\t\tnew_fl |= S_DIRSYNC;\n\n\tset_mask_bits(&inode->i_flags,\n\t\t      S_SYNC | S_APPEND | S_IMMUTABLE | S_NOATIME | S_DIRSYNC,\n\t\t      new_fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nvoid btrfs_inherit_iflags(struct inode *inode, struct inode *dir)\n{\n\tunsigned int flags;\n\n\tif (!dir)\n\t\treturn;\n\n\tflags = BTRFS_I(dir)->flags;\n\n\tif (flags & BTRFS_INODE_NOCOMPRESS) {\n\t\tBTRFS_I(inode)->flags &= ~BTRFS_INODE_COMPRESS;\n\t\tBTRFS_I(inode)->flags |= BTRFS_INODE_NOCOMPRESS;\n\t} else if (flags & BTRFS_INODE_COMPRESS) {\n\t\tBTRFS_I(inode)->flags &= ~BTRFS_INODE_NOCOMPRESS;\n\t\tBTRFS_I(inode)->flags |= BTRFS_INODE_COMPRESS;\n\t}\n\n\tif (flags & BTRFS_INODE_NODATACOW) {\n\t\tBTRFS_I(inode)->flags |= BTRFS_INODE_NODATACOW;\n\t\tif (S_ISREG(inode->i_mode))\n\t\t\tBTRFS_I(inode)->flags |= BTRFS_INODE_NODATASUM;\n\t}\n\n\tbtrfs_update_iflags(inode);\n}"
  },
  {
    "function_name": "btrfs_update_iflags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "136-155",
    "snippet": "void btrfs_update_iflags(struct inode *inode)\n{\n\tstruct btrfs_inode *ip = BTRFS_I(inode);\n\tunsigned int new_fl = 0;\n\n\tif (ip->flags & BTRFS_INODE_SYNC)\n\t\tnew_fl |= S_SYNC;\n\tif (ip->flags & BTRFS_INODE_IMMUTABLE)\n\t\tnew_fl |= S_IMMUTABLE;\n\tif (ip->flags & BTRFS_INODE_APPEND)\n\t\tnew_fl |= S_APPEND;\n\tif (ip->flags & BTRFS_INODE_NOATIME)\n\t\tnew_fl |= S_NOATIME;\n\tif (ip->flags & BTRFS_INODE_DIRSYNC)\n\t\tnew_fl |= S_DIRSYNC;\n\n\tset_mask_bits(&inode->i_flags,\n\t\t      S_SYNC | S_APPEND | S_IMMUTABLE | S_NOATIME | S_DIRSYNC,\n\t\t      new_fl);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_mask_bits",
          "args": [
            "&inode->i_flags",
            "S_SYNC | S_APPEND | S_IMMUTABLE | S_NOATIME | S_DIRSYNC",
            "new_fl"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nvoid btrfs_update_iflags(struct inode *inode)\n{\n\tstruct btrfs_inode *ip = BTRFS_I(inode);\n\tunsigned int new_fl = 0;\n\n\tif (ip->flags & BTRFS_INODE_SYNC)\n\t\tnew_fl |= S_SYNC;\n\tif (ip->flags & BTRFS_INODE_IMMUTABLE)\n\t\tnew_fl |= S_IMMUTABLE;\n\tif (ip->flags & BTRFS_INODE_APPEND)\n\t\tnew_fl |= S_APPEND;\n\tif (ip->flags & BTRFS_INODE_NOATIME)\n\t\tnew_fl |= S_NOATIME;\n\tif (ip->flags & BTRFS_INODE_DIRSYNC)\n\t\tnew_fl |= S_DIRSYNC;\n\n\tset_mask_bits(&inode->i_flags,\n\t\t      S_SYNC | S_APPEND | S_IMMUTABLE | S_NOATIME | S_DIRSYNC,\n\t\t      new_fl);\n}"
  },
  {
    "function_name": "btrfs_flags_to_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "106-131",
    "snippet": "static unsigned int btrfs_flags_to_ioctl(unsigned int flags)\n{\n\tunsigned int iflags = 0;\n\n\tif (flags & BTRFS_INODE_SYNC)\n\t\tiflags |= FS_SYNC_FL;\n\tif (flags & BTRFS_INODE_IMMUTABLE)\n\t\tiflags |= FS_IMMUTABLE_FL;\n\tif (flags & BTRFS_INODE_APPEND)\n\t\tiflags |= FS_APPEND_FL;\n\tif (flags & BTRFS_INODE_NODUMP)\n\t\tiflags |= FS_NODUMP_FL;\n\tif (flags & BTRFS_INODE_NOATIME)\n\t\tiflags |= FS_NOATIME_FL;\n\tif (flags & BTRFS_INODE_DIRSYNC)\n\t\tiflags |= FS_DIRSYNC_FL;\n\tif (flags & BTRFS_INODE_NODATACOW)\n\t\tiflags |= FS_NOCOW_FL;\n\n\tif ((flags & BTRFS_INODE_COMPRESS) && !(flags & BTRFS_INODE_NOCOMPRESS))\n\t\tiflags |= FS_COMPR_FL;\n\telse if (flags & BTRFS_INODE_NOCOMPRESS)\n\t\tiflags |= FS_NOCOMP_FL;\n\n\treturn iflags;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic unsigned int btrfs_flags_to_ioctl(unsigned int flags)\n{\n\tunsigned int iflags = 0;\n\n\tif (flags & BTRFS_INODE_SYNC)\n\t\tiflags |= FS_SYNC_FL;\n\tif (flags & BTRFS_INODE_IMMUTABLE)\n\t\tiflags |= FS_IMMUTABLE_FL;\n\tif (flags & BTRFS_INODE_APPEND)\n\t\tiflags |= FS_APPEND_FL;\n\tif (flags & BTRFS_INODE_NODUMP)\n\t\tiflags |= FS_NODUMP_FL;\n\tif (flags & BTRFS_INODE_NOATIME)\n\t\tiflags |= FS_NOATIME_FL;\n\tif (flags & BTRFS_INODE_DIRSYNC)\n\t\tiflags |= FS_DIRSYNC_FL;\n\tif (flags & BTRFS_INODE_NODATACOW)\n\t\tiflags |= FS_NOCOW_FL;\n\n\tif ((flags & BTRFS_INODE_COMPRESS) && !(flags & BTRFS_INODE_NOCOMPRESS))\n\t\tiflags |= FS_COMPR_FL;\n\telse if (flags & BTRFS_INODE_NOCOMPRESS)\n\t\tiflags |= FS_NOCOMP_FL;\n\n\treturn iflags;\n}"
  },
  {
    "function_name": "btrfs_mask_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
    "lines": "93-101",
    "snippet": "static inline __u32 btrfs_mask_flags(umode_t mode, __u32 flags)\n{\n\tif (S_ISDIR(mode))\n\t\treturn flags;\n\telse if (S_ISREG(mode))\n\t\treturn flags & ~FS_DIRSYNC_FL;\n\telse\n\t\treturn flags & (FS_NODUMP_FL | FS_NOATIME_FL);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"sysfs.h\"",
      "#include \"props.h\"",
      "#include \"dev-replace.h\"",
      "#include \"send.h\"",
      "#include \"rcu-string.h\"",
      "#include \"backref.h\"",
      "#include \"inode-map.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/btrfs.h>",
      "#include <linux/uuid.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "mode"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic inline __u32 btrfs_mask_flags(umode_t mode, __u32 flags)\n{\n\tif (S_ISDIR(mode))\n\t\treturn flags;\n\telse if (S_ISREG(mode))\n\t\treturn flags & ~FS_DIRSYNC_FL;\n\telse\n\t\treturn flags & (FS_NODUMP_FL | FS_NOATIME_FL);\n}"
  }
]