[
  {
    "function_name": "hfsplus_user_listxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr_user.c",
    "lines": "56-64",
    "snippet": "static size_t hfsplus_user_listxattr(struct dentry *dentry, char *list,\n\t\tsize_t list_size, const char *name, size_t name_len, int type)\n{\n\t/*\n\t * This method is not used.\n\t * It is used hfsplus_listxattr() instead of generic_listxattr().\n\t */\n\treturn -EOPNOTSUPP;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/nls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n\nstatic size_t hfsplus_user_listxattr(struct dentry *dentry, char *list,\n\t\tsize_t list_size, const char *name, size_t name_len, int type)\n{\n\t/*\n\t * This method is not used.\n\t * It is used hfsplus_listxattr() instead of generic_listxattr().\n\t */\n\treturn -EOPNOTSUPP;\n}"
  },
  {
    "function_name": "hfsplus_user_setxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr_user.c",
    "lines": "35-54",
    "snippet": "static int hfsplus_user_setxattr(struct dentry *dentry, const char *name,\n\t\tconst void *buffer, size_t size, int flags, int type)\n{\n\tchar *xattr_name;\n\tint res;\n\n\tif (!strcmp(name, \"\"))\n\t\treturn -EINVAL;\n\n\txattr_name = kmalloc(NLS_MAX_CHARSET_SIZE * HFSPLUS_ATTR_MAX_STRLEN + 1,\n\t\tGFP_KERNEL);\n\tif (!xattr_name)\n\t\treturn -ENOMEM;\n\tstrcpy(xattr_name, XATTR_USER_PREFIX);\n\tstrcpy(xattr_name + XATTR_USER_PREFIX_LEN, name);\n\n\tres = hfsplus_setxattr(dentry, xattr_name, buffer, size, flags);\n\tkfree(xattr_name);\n\treturn res;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/nls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "xattr_name"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_setxattr",
          "args": [
            "dentry",
            "xattr_name",
            "buffer",
            "size",
            "flags"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_setxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.h",
          "lines": "24-28",
          "snippet": "static inline int hfsplus_setxattr(struct dentry *dentry, const char *name,\n\t\t\tconst void *value, size_t size, int flags)\n{\n\treturn __hfsplus_setxattr(dentry->d_inode, name, value, size, flags);\n}",
          "includes": [
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/xattr.h>\n\nstatic inline int hfsplus_setxattr(struct dentry *dentry, const char *name,\n\t\t\tconst void *value, size_t size, int flags)\n{\n\treturn __hfsplus_setxattr(dentry->d_inode, name, value, size, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "xattr_name + XATTR_USER_PREFIX_LEN",
            "name"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "xattr_name",
            "XATTR_USER_PREFIX"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "NLS_MAX_CHARSET_SIZE * HFSPLUS_ATTR_MAX_STRLEN + 1",
            "GFP_KERNEL"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"\""
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_strcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/unicode.c",
          "lines": "64-87",
          "snippet": "int hfsplus_strcmp(const struct hfsplus_unistr *s1,\n\t\t   const struct hfsplus_unistr *s2)\n{\n\tu16 len1, len2, c1, c2;\n\tconst hfsplus_unichr *p1, *p2;\n\tint len;\n\n\tlen1 = be16_to_cpu(s1->length);\n\tlen2 = be16_to_cpu(s2->length);\n\tp1 = s1->unicode;\n\tp2 = s2->unicode;\n\n\tfor (len = min(len1, len2); len > 0; len--) {\n\t\tc1 = be16_to_cpu(*p1);\n\t\tc2 = be16_to_cpu(*p2);\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tp1++;\n\t\tp2++;\n\t}\n\n\treturn len1 < len2 ? -1 :\n\t       len1 > len2 ? 1 : 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/types.h>\n\nint hfsplus_strcmp(const struct hfsplus_unistr *s1,\n\t\t   const struct hfsplus_unistr *s2)\n{\n\tu16 len1, len2, c1, c2;\n\tconst hfsplus_unichr *p1, *p2;\n\tint len;\n\n\tlen1 = be16_to_cpu(s1->length);\n\tlen2 = be16_to_cpu(s2->length);\n\tp1 = s1->unicode;\n\tp2 = s2->unicode;\n\n\tfor (len = min(len1, len2); len > 0; len--) {\n\t\tc1 = be16_to_cpu(*p1);\n\t\tc2 = be16_to_cpu(*p2);\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tp1++;\n\t\tp2++;\n\t}\n\n\treturn len1 < len2 ? -1 :\n\t       len1 > len2 ? 1 : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n\nstatic int hfsplus_user_setxattr(struct dentry *dentry, const char *name,\n\t\tconst void *buffer, size_t size, int flags, int type)\n{\n\tchar *xattr_name;\n\tint res;\n\n\tif (!strcmp(name, \"\"))\n\t\treturn -EINVAL;\n\n\txattr_name = kmalloc(NLS_MAX_CHARSET_SIZE * HFSPLUS_ATTR_MAX_STRLEN + 1,\n\t\tGFP_KERNEL);\n\tif (!xattr_name)\n\t\treturn -ENOMEM;\n\tstrcpy(xattr_name, XATTR_USER_PREFIX);\n\tstrcpy(xattr_name + XATTR_USER_PREFIX_LEN, name);\n\n\tres = hfsplus_setxattr(dentry, xattr_name, buffer, size, flags);\n\tkfree(xattr_name);\n\treturn res;\n}"
  },
  {
    "function_name": "hfsplus_user_getxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr_user.c",
    "lines": "14-33",
    "snippet": "static int hfsplus_user_getxattr(struct dentry *dentry, const char *name,\n\t\t\t\t\tvoid *buffer, size_t size, int type)\n{\n\tchar *xattr_name;\n\tint res;\n\n\tif (!strcmp(name, \"\"))\n\t\treturn -EINVAL;\n\n\txattr_name = kmalloc(NLS_MAX_CHARSET_SIZE * HFSPLUS_ATTR_MAX_STRLEN + 1,\n\t\tGFP_KERNEL);\n\tif (!xattr_name)\n\t\treturn -ENOMEM;\n\tstrcpy(xattr_name, XATTR_USER_PREFIX);\n\tstrcpy(xattr_name + XATTR_USER_PREFIX_LEN, name);\n\n\tres = hfsplus_getxattr(dentry, xattr_name, buffer, size);\n\tkfree(xattr_name);\n\treturn res;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/nls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "xattr_name"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_getxattr",
          "args": [
            "dentry",
            "xattr_name",
            "buffer",
            "size"
          ],
          "line": 30
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_getxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.h",
          "lines": "33-39",
          "snippet": "static inline ssize_t hfsplus_getxattr(struct dentry *dentry,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tvoid *value,\n\t\t\t\t\tsize_t size)\n{\n\treturn __hfsplus_getxattr(dentry->d_inode, name, value, size);\n}",
          "includes": [
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/xattr.h>\n\nstatic inline ssize_t hfsplus_getxattr(struct dentry *dentry,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tvoid *value,\n\t\t\t\t\tsize_t size)\n{\n\treturn __hfsplus_getxattr(dentry->d_inode, name, value, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "xattr_name + XATTR_USER_PREFIX_LEN",
            "name"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "xattr_name",
            "XATTR_USER_PREFIX"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "NLS_MAX_CHARSET_SIZE * HFSPLUS_ATTR_MAX_STRLEN + 1",
            "GFP_KERNEL"
          ],
          "line": 23
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"\""
          ],
          "line": 20
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_strcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/unicode.c",
          "lines": "64-87",
          "snippet": "int hfsplus_strcmp(const struct hfsplus_unistr *s1,\n\t\t   const struct hfsplus_unistr *s2)\n{\n\tu16 len1, len2, c1, c2;\n\tconst hfsplus_unichr *p1, *p2;\n\tint len;\n\n\tlen1 = be16_to_cpu(s1->length);\n\tlen2 = be16_to_cpu(s2->length);\n\tp1 = s1->unicode;\n\tp2 = s2->unicode;\n\n\tfor (len = min(len1, len2); len > 0; len--) {\n\t\tc1 = be16_to_cpu(*p1);\n\t\tc2 = be16_to_cpu(*p2);\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tp1++;\n\t\tp2++;\n\t}\n\n\treturn len1 < len2 ? -1 :\n\t       len1 > len2 ? 1 : 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/types.h>\n\nint hfsplus_strcmp(const struct hfsplus_unistr *s1,\n\t\t   const struct hfsplus_unistr *s2)\n{\n\tu16 len1, len2, c1, c2;\n\tconst hfsplus_unichr *p1, *p2;\n\tint len;\n\n\tlen1 = be16_to_cpu(s1->length);\n\tlen2 = be16_to_cpu(s2->length);\n\tp1 = s1->unicode;\n\tp2 = s2->unicode;\n\n\tfor (len = min(len1, len2); len > 0; len--) {\n\t\tc1 = be16_to_cpu(*p1);\n\t\tc2 = be16_to_cpu(*p2);\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tp1++;\n\t\tp2++;\n\t}\n\n\treturn len1 < len2 ? -1 :\n\t       len1 > len2 ? 1 : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n\nstatic int hfsplus_user_getxattr(struct dentry *dentry, const char *name,\n\t\t\t\t\tvoid *buffer, size_t size, int type)\n{\n\tchar *xattr_name;\n\tint res;\n\n\tif (!strcmp(name, \"\"))\n\t\treturn -EINVAL;\n\n\txattr_name = kmalloc(NLS_MAX_CHARSET_SIZE * HFSPLUS_ATTR_MAX_STRLEN + 1,\n\t\tGFP_KERNEL);\n\tif (!xattr_name)\n\t\treturn -ENOMEM;\n\tstrcpy(xattr_name, XATTR_USER_PREFIX);\n\tstrcpy(xattr_name + XATTR_USER_PREFIX_LEN, name);\n\n\tres = hfsplus_getxattr(dentry, xattr_name, buffer, size);\n\tkfree(xattr_name);\n\treturn res;\n}"
  }
]