[
  {
    "function_name": "init_flat_binfmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_flat.c",
    "lines": "943-947",
    "snippet": "static int __init init_flat_binfmt(void)\n{\n\tregister_binfmt(&flat_format);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/zlib.h>",
      "#include <asm/page.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/unaligned.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/flat.h>",
      "#include <linux/init.h>",
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/slab.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct linux_binfmt flat_format = {\n\t.module\t\t= THIS_MODULE,\n\t.load_binary\t= load_flat_binary,\n\t.core_dump\t= flat_core_dump,\n\t.min_coredump\t= PAGE_SIZE\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_binfmt",
          "args": [
            "&flat_format"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_binfmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "87-92",
          "snippet": "void unregister_binfmt(struct linux_binfmt * fmt)\n{\n\twrite_lock(&binfmt_lock);\n\tlist_del(&fmt->lh);\n\twrite_unlock(&binfmt_lock);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(binfmt_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic DEFINE_RWLOCK(binfmt_lock);\n\nvoid unregister_binfmt(struct linux_binfmt * fmt)\n{\n\twrite_lock(&binfmt_lock);\n\tlist_del(&fmt->lh);\n\twrite_unlock(&binfmt_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/zlib.h>\n#include <asm/page.h>\n#include <asm/cacheflush.h>\n#include <asm/unaligned.h>\n#include <asm/uaccess.h>\n#include <asm/byteorder.h>\n#include <linux/syscalls.h>\n#include <linux/flat.h>\n#include <linux/init.h>\n#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/slab.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic struct linux_binfmt flat_format = {\n\t.module\t\t= THIS_MODULE,\n\t.load_binary\t= load_flat_binary,\n\t.core_dump\t= flat_core_dump,\n\t.min_coredump\t= PAGE_SIZE\n};\n\nstatic int __init init_flat_binfmt(void)\n{\n\tregister_binfmt(&flat_format);\n\treturn 0;\n}"
  },
  {
    "function_name": "load_flat_binary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_flat.c",
    "lines": "860-939",
    "snippet": "static int load_flat_binary(struct linux_binprm * bprm)\n{\n\tstruct lib_info libinfo;\n\tstruct pt_regs *regs = current_pt_regs();\n\tunsigned long p = bprm->p;\n\tunsigned long stack_len;\n\tunsigned long start_addr;\n\tunsigned long *sp;\n\tint res;\n\tint i, j;\n\n\tmemset(&libinfo, 0, sizeof(libinfo));\n\t/*\n\t * We have to add the size of our arguments to our stack size\n\t * otherwise it's too easy for users to create stack overflows\n\t * by passing in a huge argument list.  And yes,  we have to be\n\t * pedantic and include space for the argv/envp array as it may have\n\t * a lot of entries.\n\t */\n#define TOP_OF_ARGS (PAGE_SIZE * MAX_ARG_PAGES - sizeof(void *))\n\tstack_len = TOP_OF_ARGS - bprm->p;             /* the strings */\n\tstack_len += (bprm->argc + 1) * sizeof(char *); /* the argv array */\n\tstack_len += (bprm->envc + 1) * sizeof(char *); /* the envp array */\n\tstack_len += FLAT_STACK_ALIGN - 1;  /* reserve for upcoming alignment */\n\t\n\tres = load_flat_file(bprm, &libinfo, 0, &stack_len);\n\tif (IS_ERR_VALUE(res))\n\t\treturn res;\n\t\n\t/* Update data segment pointers for all libraries */\n\tfor (i=0; i<MAX_SHARED_LIBS; i++)\n\t\tif (libinfo.lib_list[i].loaded)\n\t\t\tfor (j=0; j<MAX_SHARED_LIBS; j++)\n\t\t\t\t(-(j+1))[(unsigned long *)(libinfo.lib_list[i].start_data)] =\n\t\t\t\t\t(libinfo.lib_list[j].loaded)?\n\t\t\t\t\t\tlibinfo.lib_list[j].start_data:UNLOADED_LIB;\n\n\tinstall_exec_creds(bprm);\n\n\tset_binfmt(&flat_format);\n\n\tp = ((current->mm->context.end_brk + stack_len + 3) & ~3) - 4;\n\tDBG_FLT(\"p=%x\\n\", (int)p);\n\n\t/* copy the arg pages onto the stack, this could be more efficient :-) */\n\tfor (i = TOP_OF_ARGS - 1; i >= bprm->p; i--)\n\t\t* (char *) --p =\n\t\t\t((char *) page_address(bprm->page[i/PAGE_SIZE]))[i % PAGE_SIZE];\n\n\tsp = (unsigned long *) create_flat_tables(p, bprm);\n\t\n\t/* Fake some return addresses to ensure the call chain will\n\t * initialise library in order for us.  We are required to call\n\t * lib 1 first, then 2, ... and finally the main program (id 0).\n\t */\n\tstart_addr = libinfo.lib_list[0].entry;\n\n#ifdef CONFIG_BINFMT_SHARED_FLAT\n\tfor (i = MAX_SHARED_LIBS-1; i>0; i--) {\n\t\tif (libinfo.lib_list[i].loaded) {\n\t\t\t/* Push previos first to call address */\n\t\t\t--sp;\tput_user(start_addr, sp);\n\t\t\tstart_addr = libinfo.lib_list[i].entry;\n\t\t}\n\t}\n#endif\n\t\n\t/* Stash our initial stack pointer into the mm structure */\n\tcurrent->mm->start_stack = (unsigned long )sp;\n\n#ifdef FLAT_PLAT_INIT\n\tFLAT_PLAT_INIT(regs);\n#endif\n\tDBG_FLT(\"start_thread(regs=0x%x, entry=0x%x, start_stack=0x%x)\\n\",\n\t\t(int)regs, (int)start_addr, (int)current->mm->start_stack);\n\t\n\tstart_thread(regs, start_addr, current->mm->start_stack);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/zlib.h>",
      "#include <asm/page.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/unaligned.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/flat.h>",
      "#include <linux/init.h>",
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/slab.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [
      "#define TOP_OF_ARGS (PAGE_SIZE * MAX_ARG_PAGES - sizeof(void *))",
      "#define UNLOADED_LIB 0x7ff000ff\t\t/* Placeholder for unused library */",
      "#define FLAT_STACK_ALIGN\tmax_t(unsigned long, sizeof(void *), ARCH_SLAB_MINALIGN)"
    ],
    "globals_used": [
      "static int load_flat_binary(struct linux_binprm *);",
      "static struct linux_binfmt flat_format = {\n\t.module\t\t= THIS_MODULE,\n\t.load_binary\t= load_flat_binary,\n\t.core_dump\t= flat_core_dump,\n\t.min_coredump\t= PAGE_SIZE\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "start_thread",
          "args": [
            "regs",
            "start_addr",
            "current->mm->start_stack"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG_FLT",
          "args": [
            "\"start_thread(regs=0x%x, entry=0x%x, start_stack=0x%x)\\n\"",
            "(int)regs",
            "(int)start_addr",
            "(int)current->mm->start_stack"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FLAT_PLAT_INIT",
          "args": [
            "regs"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "start_addr",
            "sp"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_flat_tables",
          "args": [
            "p",
            "bprm"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "create_flat_tables",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_flat.c",
          "lines": "121-162",
          "snippet": "static unsigned long create_flat_tables(\n\tunsigned long pp,\n\tstruct linux_binprm * bprm)\n{\n\tunsigned long *argv,*envp;\n\tunsigned long * sp;\n\tchar * p = (char*)pp;\n\tint argc = bprm->argc;\n\tint envc = bprm->envc;\n\tchar uninitialized_var(dummy);\n\n\tsp = (unsigned long *)p;\n\tsp -= (envc + argc + 2) + 1 + (flat_argvp_envp_on_stack() ? 2 : 0);\n\tsp = (unsigned long *) ((unsigned long)sp & -FLAT_STACK_ALIGN);\n\targv = sp + 1 + (flat_argvp_envp_on_stack() ? 2 : 0);\n\tenvp = argv + (argc + 1);\n\n\tif (flat_argvp_envp_on_stack()) {\n\t\tput_user((unsigned long) envp, sp + 2);\n\t\tput_user((unsigned long) argv, sp + 1);\n\t}\n\n\tput_user(argc, sp);\n\tcurrent->mm->arg_start = (unsigned long) p;\n\twhile (argc-->0) {\n\t\tput_user((unsigned long) p, argv++);\n\t\tdo {\n\t\t\tget_user(dummy, p); p++;\n\t\t} while (dummy);\n\t}\n\tput_user((unsigned long) NULL, argv);\n\tcurrent->mm->arg_end = current->mm->env_start = (unsigned long) p;\n\twhile (envc-->0) {\n\t\tput_user((unsigned long)p, envp); envp++;\n\t\tdo {\n\t\t\tget_user(dummy, p); p++;\n\t\t} while (dummy);\n\t}\n\tput_user((unsigned long) NULL, envp);\n\tcurrent->mm->env_end = (unsigned long) p;\n\treturn (unsigned long)sp;\n}",
          "includes": [
            "#include <linux/zlib.h>",
            "#include <asm/page.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/flat.h>",
            "#include <linux/init.h>",
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/slab.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define FLAT_STACK_ALIGN\tmax_t(unsigned long, sizeof(void *), ARCH_SLAB_MINALIGN)"
          ],
          "globals_used": [
            "static int load_flat_binary(struct linux_binprm *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zlib.h>\n#include <asm/page.h>\n#include <asm/cacheflush.h>\n#include <asm/unaligned.h>\n#include <asm/uaccess.h>\n#include <asm/byteorder.h>\n#include <linux/syscalls.h>\n#include <linux/flat.h>\n#include <linux/init.h>\n#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/slab.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\n#define FLAT_STACK_ALIGN\tmax_t(unsigned long, sizeof(void *), ARCH_SLAB_MINALIGN)\n\nstatic int load_flat_binary(struct linux_binprm *);\n\nstatic unsigned long create_flat_tables(\n\tunsigned long pp,\n\tstruct linux_binprm * bprm)\n{\n\tunsigned long *argv,*envp;\n\tunsigned long * sp;\n\tchar * p = (char*)pp;\n\tint argc = bprm->argc;\n\tint envc = bprm->envc;\n\tchar uninitialized_var(dummy);\n\n\tsp = (unsigned long *)p;\n\tsp -= (envc + argc + 2) + 1 + (flat_argvp_envp_on_stack() ? 2 : 0);\n\tsp = (unsigned long *) ((unsigned long)sp & -FLAT_STACK_ALIGN);\n\targv = sp + 1 + (flat_argvp_envp_on_stack() ? 2 : 0);\n\tenvp = argv + (argc + 1);\n\n\tif (flat_argvp_envp_on_stack()) {\n\t\tput_user((unsigned long) envp, sp + 2);\n\t\tput_user((unsigned long) argv, sp + 1);\n\t}\n\n\tput_user(argc, sp);\n\tcurrent->mm->arg_start = (unsigned long) p;\n\twhile (argc-->0) {\n\t\tput_user((unsigned long) p, argv++);\n\t\tdo {\n\t\t\tget_user(dummy, p); p++;\n\t\t} while (dummy);\n\t}\n\tput_user((unsigned long) NULL, argv);\n\tcurrent->mm->arg_end = current->mm->env_start = (unsigned long) p;\n\twhile (envc-->0) {\n\t\tput_user((unsigned long)p, envp); envp++;\n\t\tdo {\n\t\t\tget_user(dummy, p); p++;\n\t\t} while (dummy);\n\t}\n\tput_user((unsigned long) NULL, envp);\n\tcurrent->mm->env_end = (unsigned long) p;\n\treturn (unsigned long)sp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "bprm->page[i/PAGE_SIZE]"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG_FLT",
          "args": [
            "\"p=%x\\n\"",
            "(int)p"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_binfmt",
          "args": [
            "&flat_format"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "set_binfmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "1642-1652",
          "snippet": "void set_binfmt(struct linux_binfmt *new)\n{\n\tstruct mm_struct *mm = current->mm;\n\n\tif (mm->binfmt)\n\t\tmodule_put(mm->binfmt->module);\n\n\tmm->binfmt = new;\n\tif (new)\n\t\t__module_get(new->module);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid set_binfmt(struct linux_binfmt *new)\n{\n\tstruct mm_struct *mm = current->mm;\n\n\tif (mm->binfmt)\n\t\tmodule_put(mm->binfmt->module);\n\n\tmm->binfmt = new;\n\tif (new)\n\t\t__module_get(new->module);\n}"
        }
      },
      {
        "call_info": {
          "callee": "install_exec_creds",
          "args": [
            "bprm"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "install_exec_creds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "1202-1224",
          "snippet": "void install_exec_creds(struct linux_binprm *bprm)\n{\n\tsecurity_bprm_committing_creds(bprm);\n\n\tcommit_creds(bprm->cred);\n\tbprm->cred = NULL;\n\n\t/*\n\t * Disable monitoring for regular users\n\t * when executing setuid binaries. Must\n\t * wait until new credentials are committed\n\t * by commit_creds() above\n\t */\n\tif (get_dumpable(current->mm) != SUID_DUMP_USER)\n\t\tperf_event_exit_task(current);\n\t/*\n\t * cred_guard_mutex must be held at least to this point to prevent\n\t * ptrace_attach() from altering our determination of the task's\n\t * credentials; any time after this it may be unlocked.\n\t */\n\tsecurity_bprm_committed_creds(bprm);\n\tmutex_unlock(&current->signal->cred_guard_mutex);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid install_exec_creds(struct linux_binprm *bprm)\n{\n\tsecurity_bprm_committing_creds(bprm);\n\n\tcommit_creds(bprm->cred);\n\tbprm->cred = NULL;\n\n\t/*\n\t * Disable monitoring for regular users\n\t * when executing setuid binaries. Must\n\t * wait until new credentials are committed\n\t * by commit_creds() above\n\t */\n\tif (get_dumpable(current->mm) != SUID_DUMP_USER)\n\t\tperf_event_exit_task(current);\n\t/*\n\t * cred_guard_mutex must be held at least to this point to prevent\n\t * ptrace_attach() from altering our determination of the task's\n\t * credentials; any time after this it may be unlocked.\n\t */\n\tsecurity_bprm_committed_creds(bprm);\n\tmutex_unlock(&current->signal->cred_guard_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR_VALUE",
          "args": [
            "res"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_flat_file",
          "args": [
            "bprm",
            "&libinfo",
            "0",
            "&stack_len"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "load_flat_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_flat.c",
          "lines": "426-798",
          "snippet": "static int load_flat_file(struct linux_binprm * bprm,\n\t\tstruct lib_info *libinfo, int id, unsigned long *extra_stack)\n{\n\tstruct flat_hdr * hdr;\n\tunsigned long textpos = 0, datapos = 0, result;\n\tunsigned long realdatastart = 0;\n\tunsigned long text_len, data_len, bss_len, stack_len, flags;\n\tunsigned long full_data;\n\tunsigned long len, memp = 0;\n\tunsigned long memp_size, extra, rlim;\n\tunsigned long *reloc = 0, *rp;\n\tstruct inode *inode;\n\tint i, rev, relocs = 0;\n\tloff_t fpos;\n\tunsigned long start_code, end_code;\n\tint ret;\n\n\thdr = ((struct flat_hdr *) bprm->buf);\t\t/* exec-header */\n\tinode = file_inode(bprm->file);\n\n\ttext_len  = ntohl(hdr->data_start);\n\tdata_len  = ntohl(hdr->data_end) - ntohl(hdr->data_start);\n\tbss_len   = ntohl(hdr->bss_end) - ntohl(hdr->data_end);\n\tstack_len = ntohl(hdr->stack_size);\n\tif (extra_stack) {\n\t\tstack_len += *extra_stack;\n\t\t*extra_stack = stack_len;\n\t}\n\trelocs    = ntohl(hdr->reloc_count);\n\tflags     = ntohl(hdr->flags);\n\trev       = ntohl(hdr->rev);\n\tfull_data = data_len + relocs * sizeof(unsigned long);\n\n\tif (strncmp(hdr->magic, \"bFLT\", 4)) {\n\t\t/*\n\t\t * Previously, here was a printk to tell people\n\t\t *   \"BINFMT_FLAT: bad header magic\".\n\t\t * But for the kernel which also use ELF FD-PIC format, this\n\t\t * error message is confusing.\n\t\t * because a lot of people do not manage to produce good\n\t\t */\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n\n\tif (flags & FLAT_FLAG_KTRACE)\n\t\tprintk(\"BINFMT_FLAT: Loading file: %s\\n\", bprm->filename);\n\n\tif (rev != FLAT_VERSION && rev != OLD_FLAT_VERSION) {\n\t\tprintk(\"BINFMT_FLAT: bad flat file version 0x%x (supported \"\n\t\t\t\"0x%lx and 0x%lx)\\n\",\n\t\t\trev, FLAT_VERSION, OLD_FLAT_VERSION);\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n\t\n\t/* Don't allow old format executables to use shared libraries */\n\tif (rev == OLD_FLAT_VERSION && id != 0) {\n\t\tprintk(\"BINFMT_FLAT: shared libraries are not available before rev 0x%x\\n\",\n\t\t\t\t(int) FLAT_VERSION);\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n\n\t/*\n\t * fix up the flags for the older format,  there were all kinds\n\t * of endian hacks,  this only works for the simple cases\n\t */\n\tif (rev == OLD_FLAT_VERSION && flat_old_ram_flag(flags))\n\t\tflags = FLAT_FLAG_RAM;\n\n#ifndef CONFIG_BINFMT_ZFLAT\n\tif (flags & (FLAT_FLAG_GZIP|FLAT_FLAG_GZDATA)) {\n\t\tprintk(\"Support for ZFLAT executables is not enabled.\\n\");\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n#endif\n\n\t/*\n\t * Check initial limits. This avoids letting people circumvent\n\t * size limits imposed on them by creating programs with large\n\t * arrays in the data or bss.\n\t */\n\trlim = rlimit(RLIMIT_DATA);\n\tif (rlim >= RLIM_INFINITY)\n\t\trlim = ~0;\n\tif (data_len + bss_len > rlim) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t/* Flush all traces of the currently running executable */\n\tif (id == 0) {\n\t\tresult = flush_old_exec(bprm);\n\t\tif (result) {\n\t\t\tret = result;\n\t\t\tgoto err;\n\t\t}\n\n\t\t/* OK, This is the point of no return */\n\t\tset_personality(PER_LINUX_32BIT);\n\t\tsetup_new_exec(bprm);\n\t}\n\n\t/*\n\t * calculate the extra space we need to map in\n\t */\n\textra = max_t(unsigned long, bss_len + stack_len,\n\t\t\trelocs * sizeof(unsigned long));\n\n\t/*\n\t * there are a couple of cases here,  the separate code/data\n\t * case,  and then the fully copied to RAM case which lumps\n\t * it all together.\n\t */\n\tif ((flags & (FLAT_FLAG_RAM|FLAT_FLAG_GZIP)) == 0) {\n\t\t/*\n\t\t * this should give us a ROM ptr,  but if it doesn't we don't\n\t\t * really care\n\t\t */\n\t\tDBG_FLT(\"BINFMT_FLAT: ROM mapping of file (we hope)\\n\");\n\n\t\ttextpos = vm_mmap(bprm->file, 0, text_len, PROT_READ|PROT_EXEC,\n\t\t\t\t  MAP_PRIVATE|MAP_EXECUTABLE, 0);\n\t\tif (!textpos || IS_ERR_VALUE(textpos)) {\n\t\t\tif (!textpos)\n\t\t\t\ttextpos = (unsigned long) -ENOMEM;\n\t\t\tprintk(\"Unable to mmap process text, errno %d\\n\", (int)-textpos);\n\t\t\tret = textpos;\n\t\t\tgoto err;\n\t\t}\n\n\t\tlen = data_len + extra + MAX_SHARED_LIBS * sizeof(unsigned long);\n\t\tlen = PAGE_ALIGN(len);\n\t\trealdatastart = vm_mmap(0, 0, len,\n\t\t\tPROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE, 0);\n\n\t\tif (realdatastart == 0 || IS_ERR_VALUE(realdatastart)) {\n\t\t\tif (!realdatastart)\n\t\t\t\trealdatastart = (unsigned long) -ENOMEM;\n\t\t\tprintk(\"Unable to allocate RAM for process data, errno %d\\n\",\n\t\t\t\t\t(int)-realdatastart);\n\t\t\tvm_munmap(textpos, text_len);\n\t\t\tret = realdatastart;\n\t\t\tgoto err;\n\t\t}\n\t\tdatapos = ALIGN(realdatastart +\n\t\t\t\tMAX_SHARED_LIBS * sizeof(unsigned long),\n\t\t\t\tFLAT_DATA_ALIGN);\n\n\t\tDBG_FLT(\"BINFMT_FLAT: Allocated data+bss+stack (%d bytes): %x\\n\",\n\t\t\t\t(int)(data_len + bss_len + stack_len), (int)datapos);\n\n\t\tfpos = ntohl(hdr->data_start);\n#ifdef CONFIG_BINFMT_ZFLAT\n\t\tif (flags & FLAT_FLAG_GZDATA) {\n\t\t\tresult = decompress_exec(bprm, fpos, (char *) datapos, \n\t\t\t\t\t\t full_data, 0);\n\t\t} else\n#endif\n\t\t{\n\t\t\tresult = read_code(bprm->file, datapos, fpos,\n\t\t\t\t\tfull_data);\n\t\t}\n\t\tif (IS_ERR_VALUE(result)) {\n\t\t\tprintk(\"Unable to read data+bss, errno %d\\n\", (int)-result);\n\t\t\tvm_munmap(textpos, text_len);\n\t\t\tvm_munmap(realdatastart, len);\n\t\t\tret = result;\n\t\t\tgoto err;\n\t\t}\n\n\t\treloc = (unsigned long *) (datapos+(ntohl(hdr->reloc_start)-text_len));\n\t\tmemp = realdatastart;\n\t\tmemp_size = len;\n\t} else {\n\n\t\tlen = text_len + data_len + extra + MAX_SHARED_LIBS * sizeof(unsigned long);\n\t\tlen = PAGE_ALIGN(len);\n\t\ttextpos = vm_mmap(0, 0, len,\n\t\t\tPROT_READ | PROT_EXEC | PROT_WRITE, MAP_PRIVATE, 0);\n\n\t\tif (!textpos || IS_ERR_VALUE(textpos)) {\n\t\t\tif (!textpos)\n\t\t\t\ttextpos = (unsigned long) -ENOMEM;\n\t\t\tprintk(\"Unable to allocate RAM for process text/data, errno %d\\n\",\n\t\t\t\t\t(int)-textpos);\n\t\t\tret = textpos;\n\t\t\tgoto err;\n\t\t}\n\n\t\trealdatastart = textpos + ntohl(hdr->data_start);\n\t\tdatapos = ALIGN(realdatastart +\n\t\t\t\tMAX_SHARED_LIBS * sizeof(unsigned long),\n\t\t\t\tFLAT_DATA_ALIGN);\n\n\t\treloc = (unsigned long *)\n\t\t\t(datapos + (ntohl(hdr->reloc_start) - text_len));\n\t\tmemp = textpos;\n\t\tmemp_size = len;\n#ifdef CONFIG_BINFMT_ZFLAT\n\t\t/*\n\t\t * load it all in and treat it like a RAM load from now on\n\t\t */\n\t\tif (flags & FLAT_FLAG_GZIP) {\n\t\t\tresult = decompress_exec(bprm, sizeof (struct flat_hdr),\n\t\t\t\t\t (((char *) textpos) + sizeof (struct flat_hdr)),\n\t\t\t\t\t (text_len + full_data\n\t\t\t\t\t\t  - sizeof (struct flat_hdr)),\n\t\t\t\t\t 0);\n\t\t\tmemmove((void *) datapos, (void *) realdatastart,\n\t\t\t\t\tfull_data);\n\t\t} else if (flags & FLAT_FLAG_GZDATA) {\n\t\t\tresult = read_code(bprm->file, textpos, 0, text_len);\n\t\t\tif (!IS_ERR_VALUE(result))\n\t\t\t\tresult = decompress_exec(bprm, text_len, (char *) datapos,\n\t\t\t\t\t\t full_data, 0);\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t\tresult = read_code(bprm->file, textpos, 0, text_len);\n\t\t\tif (!IS_ERR_VALUE(result))\n\t\t\t\tresult = read_code(bprm->file, datapos,\n\t\t\t\t\t\t   ntohl(hdr->data_start),\n\t\t\t\t\t\t   full_data);\n\t\t}\n\t\tif (IS_ERR_VALUE(result)) {\n\t\t\tprintk(\"Unable to read code+data+bss, errno %d\\n\",(int)-result);\n\t\t\tvm_munmap(textpos, text_len + data_len + extra +\n\t\t\t\tMAX_SHARED_LIBS * sizeof(unsigned long));\n\t\t\tret = result;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (flags & FLAT_FLAG_KTRACE)\n\t\tprintk(\"Mapping is %x, Entry point is %x, data_start is %x\\n\",\n\t\t\t(int)textpos, 0x00ffffff&ntohl(hdr->entry), ntohl(hdr->data_start));\n\n\t/* The main program needs a little extra setup in the task structure */\n\tstart_code = textpos + sizeof (struct flat_hdr);\n\tend_code = textpos + text_len;\n\tif (id == 0) {\n\t\tcurrent->mm->start_code = start_code;\n\t\tcurrent->mm->end_code = end_code;\n\t\tcurrent->mm->start_data = datapos;\n\t\tcurrent->mm->end_data = datapos + data_len;\n\t\t/*\n\t\t * set up the brk stuff, uses any slack left in data/bss/stack\n\t\t * allocation.  We put the brk after the bss (between the bss\n\t\t * and stack) like other platforms.\n\t\t * Userspace code relies on the stack pointer starting out at\n\t\t * an address right at the end of a page.\n\t\t */\n\t\tcurrent->mm->start_brk = datapos + data_len + bss_len;\n\t\tcurrent->mm->brk = (current->mm->start_brk + 3) & ~3;\n\t\tcurrent->mm->context.end_brk = memp + memp_size - stack_len;\n\t}\n\n\tif (flags & FLAT_FLAG_KTRACE)\n\t\tprintk(\"%s %s: TEXT=%x-%x DATA=%x-%x BSS=%x-%x\\n\",\n\t\t\tid ? \"Lib\" : \"Load\", bprm->filename,\n\t\t\t(int) start_code, (int) end_code,\n\t\t\t(int) datapos,\n\t\t\t(int) (datapos + data_len),\n\t\t\t(int) (datapos + data_len),\n\t\t\t(int) (((datapos + data_len + bss_len) + 3) & ~3));\n\n\ttext_len -= sizeof(struct flat_hdr); /* the real code len */\n\n\t/* Store the current module values into the global library structure */\n\tlibinfo->lib_list[id].start_code = start_code;\n\tlibinfo->lib_list[id].start_data = datapos;\n\tlibinfo->lib_list[id].start_brk = datapos + data_len + bss_len;\n\tlibinfo->lib_list[id].text_len = text_len;\n\tlibinfo->lib_list[id].loaded = 1;\n\tlibinfo->lib_list[id].entry = (0x00ffffff & ntohl(hdr->entry)) + textpos;\n\tlibinfo->lib_list[id].build_date = ntohl(hdr->build_date);\n\t\n\t/*\n\t * We just load the allocations into some temporary memory to\n\t * help simplify all this mumbo jumbo\n\t *\n\t * We've got two different sections of relocation entries.\n\t * The first is the GOT which resides at the beginning of the data segment\n\t * and is terminated with a -1.  This one can be relocated in place.\n\t * The second is the extra relocation entries tacked after the image's\n\t * data segment. These require a little more processing as the entry is\n\t * really an offset into the image which contains an offset into the\n\t * image.\n\t */\n\tif (flags & FLAT_FLAG_GOTPIC) {\n\t\tfor (rp = (unsigned long *)datapos; *rp != 0xffffffff; rp++) {\n\t\t\tunsigned long addr;\n\t\t\tif (*rp) {\n\t\t\t\taddr = calc_reloc(*rp, libinfo, id, 0);\n\t\t\t\tif (addr == RELOC_FAILED) {\n\t\t\t\t\tret = -ENOEXEC;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\t*rp = addr;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Now run through the relocation entries.\n\t * We've got to be careful here as C++ produces relocatable zero\n\t * entries in the constructor and destructor tables which are then\n\t * tested for being not zero (which will always occur unless we're\n\t * based from address zero).  This causes an endless loop as __start\n\t * is at zero.  The solution used is to not relocate zero addresses.\n\t * This has the negative side effect of not allowing a global data\n\t * reference to be statically initialised to _stext (I've moved\n\t * __start to address 4 so that is okay).\n\t */\n\tif (rev > OLD_FLAT_VERSION) {\n\t\tunsigned long persistent = 0;\n\t\tfor (i=0; i < relocs; i++) {\n\t\t\tunsigned long addr, relval;\n\n\t\t\t/* Get the address of the pointer to be\n\t\t\t   relocated (of course, the address has to be\n\t\t\t   relocated first).  */\n\t\t\trelval = ntohl(reloc[i]);\n\t\t\tif (flat_set_persistent (relval, &persistent))\n\t\t\t\tcontinue;\n\t\t\taddr = flat_get_relocate_addr(relval);\n\t\t\trp = (unsigned long *) calc_reloc(addr, libinfo, id, 1);\n\t\t\tif (rp == (unsigned long *)RELOC_FAILED) {\n\t\t\t\tret = -ENOEXEC;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\t/* Get the pointer's value.  */\n\t\t\taddr = flat_get_addr_from_rp(rp, relval, flags,\n\t\t\t\t\t\t\t&persistent);\n\t\t\tif (addr != 0) {\n\t\t\t\t/*\n\t\t\t\t * Do the relocation.  PIC relocs in the data section are\n\t\t\t\t * already in target order\n\t\t\t\t */\n\t\t\t\tif ((flags & FLAT_FLAG_GOTPIC) == 0)\n\t\t\t\t\taddr = ntohl(addr);\n\t\t\t\taddr = calc_reloc(addr, libinfo, id, 0);\n\t\t\t\tif (addr == RELOC_FAILED) {\n\t\t\t\t\tret = -ENOEXEC;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\n\t\t\t\t/* Write back the relocated pointer.  */\n\t\t\t\tflat_put_addr_at_rp(rp, addr, relval);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i=0; i < relocs; i++)\n\t\t\told_reloc(ntohl(reloc[i]));\n\t}\n\t\n\tflush_icache_range(start_code, end_code);\n\n\t/* zero the BSS,  BRK and stack areas */\n\tmemset((void*)(datapos + data_len), 0, bss_len + \n\t\t\t(memp + memp_size - stack_len -\t\t/* end brk */\n\t\t\tlibinfo->lib_list[id].start_brk) +\t/* start brk */\n\t\t\tstack_len);\n\n\treturn 0;\nerr:\n\treturn ret;\n}",
          "includes": [
            "#include <linux/zlib.h>",
            "#include <asm/page.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/flat.h>",
            "#include <linux/init.h>",
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/slab.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define RELOC_FAILED 0xff00ff01\t\t/* Relocation incorrect somewhere */",
            "#define FLAT_DATA_ALIGN\t(0x20)"
          ],
          "globals_used": [
            "static int load_flat_binary(struct linux_binprm *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zlib.h>\n#include <asm/page.h>\n#include <asm/cacheflush.h>\n#include <asm/unaligned.h>\n#include <asm/uaccess.h>\n#include <asm/byteorder.h>\n#include <linux/syscalls.h>\n#include <linux/flat.h>\n#include <linux/init.h>\n#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/slab.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\n#define RELOC_FAILED 0xff00ff01\t\t/* Relocation incorrect somewhere */\n#define FLAT_DATA_ALIGN\t(0x20)\n\nstatic int load_flat_binary(struct linux_binprm *);\n\nstatic int load_flat_file(struct linux_binprm * bprm,\n\t\tstruct lib_info *libinfo, int id, unsigned long *extra_stack)\n{\n\tstruct flat_hdr * hdr;\n\tunsigned long textpos = 0, datapos = 0, result;\n\tunsigned long realdatastart = 0;\n\tunsigned long text_len, data_len, bss_len, stack_len, flags;\n\tunsigned long full_data;\n\tunsigned long len, memp = 0;\n\tunsigned long memp_size, extra, rlim;\n\tunsigned long *reloc = 0, *rp;\n\tstruct inode *inode;\n\tint i, rev, relocs = 0;\n\tloff_t fpos;\n\tunsigned long start_code, end_code;\n\tint ret;\n\n\thdr = ((struct flat_hdr *) bprm->buf);\t\t/* exec-header */\n\tinode = file_inode(bprm->file);\n\n\ttext_len  = ntohl(hdr->data_start);\n\tdata_len  = ntohl(hdr->data_end) - ntohl(hdr->data_start);\n\tbss_len   = ntohl(hdr->bss_end) - ntohl(hdr->data_end);\n\tstack_len = ntohl(hdr->stack_size);\n\tif (extra_stack) {\n\t\tstack_len += *extra_stack;\n\t\t*extra_stack = stack_len;\n\t}\n\trelocs    = ntohl(hdr->reloc_count);\n\tflags     = ntohl(hdr->flags);\n\trev       = ntohl(hdr->rev);\n\tfull_data = data_len + relocs * sizeof(unsigned long);\n\n\tif (strncmp(hdr->magic, \"bFLT\", 4)) {\n\t\t/*\n\t\t * Previously, here was a printk to tell people\n\t\t *   \"BINFMT_FLAT: bad header magic\".\n\t\t * But for the kernel which also use ELF FD-PIC format, this\n\t\t * error message is confusing.\n\t\t * because a lot of people do not manage to produce good\n\t\t */\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n\n\tif (flags & FLAT_FLAG_KTRACE)\n\t\tprintk(\"BINFMT_FLAT: Loading file: %s\\n\", bprm->filename);\n\n\tif (rev != FLAT_VERSION && rev != OLD_FLAT_VERSION) {\n\t\tprintk(\"BINFMT_FLAT: bad flat file version 0x%x (supported \"\n\t\t\t\"0x%lx and 0x%lx)\\n\",\n\t\t\trev, FLAT_VERSION, OLD_FLAT_VERSION);\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n\t\n\t/* Don't allow old format executables to use shared libraries */\n\tif (rev == OLD_FLAT_VERSION && id != 0) {\n\t\tprintk(\"BINFMT_FLAT: shared libraries are not available before rev 0x%x\\n\",\n\t\t\t\t(int) FLAT_VERSION);\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n\n\t/*\n\t * fix up the flags for the older format,  there were all kinds\n\t * of endian hacks,  this only works for the simple cases\n\t */\n\tif (rev == OLD_FLAT_VERSION && flat_old_ram_flag(flags))\n\t\tflags = FLAT_FLAG_RAM;\n\n#ifndef CONFIG_BINFMT_ZFLAT\n\tif (flags & (FLAT_FLAG_GZIP|FLAT_FLAG_GZDATA)) {\n\t\tprintk(\"Support for ZFLAT executables is not enabled.\\n\");\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n#endif\n\n\t/*\n\t * Check initial limits. This avoids letting people circumvent\n\t * size limits imposed on them by creating programs with large\n\t * arrays in the data or bss.\n\t */\n\trlim = rlimit(RLIMIT_DATA);\n\tif (rlim >= RLIM_INFINITY)\n\t\trlim = ~0;\n\tif (data_len + bss_len > rlim) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t/* Flush all traces of the currently running executable */\n\tif (id == 0) {\n\t\tresult = flush_old_exec(bprm);\n\t\tif (result) {\n\t\t\tret = result;\n\t\t\tgoto err;\n\t\t}\n\n\t\t/* OK, This is the point of no return */\n\t\tset_personality(PER_LINUX_32BIT);\n\t\tsetup_new_exec(bprm);\n\t}\n\n\t/*\n\t * calculate the extra space we need to map in\n\t */\n\textra = max_t(unsigned long, bss_len + stack_len,\n\t\t\trelocs * sizeof(unsigned long));\n\n\t/*\n\t * there are a couple of cases here,  the separate code/data\n\t * case,  and then the fully copied to RAM case which lumps\n\t * it all together.\n\t */\n\tif ((flags & (FLAT_FLAG_RAM|FLAT_FLAG_GZIP)) == 0) {\n\t\t/*\n\t\t * this should give us a ROM ptr,  but if it doesn't we don't\n\t\t * really care\n\t\t */\n\t\tDBG_FLT(\"BINFMT_FLAT: ROM mapping of file (we hope)\\n\");\n\n\t\ttextpos = vm_mmap(bprm->file, 0, text_len, PROT_READ|PROT_EXEC,\n\t\t\t\t  MAP_PRIVATE|MAP_EXECUTABLE, 0);\n\t\tif (!textpos || IS_ERR_VALUE(textpos)) {\n\t\t\tif (!textpos)\n\t\t\t\ttextpos = (unsigned long) -ENOMEM;\n\t\t\tprintk(\"Unable to mmap process text, errno %d\\n\", (int)-textpos);\n\t\t\tret = textpos;\n\t\t\tgoto err;\n\t\t}\n\n\t\tlen = data_len + extra + MAX_SHARED_LIBS * sizeof(unsigned long);\n\t\tlen = PAGE_ALIGN(len);\n\t\trealdatastart = vm_mmap(0, 0, len,\n\t\t\tPROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE, 0);\n\n\t\tif (realdatastart == 0 || IS_ERR_VALUE(realdatastart)) {\n\t\t\tif (!realdatastart)\n\t\t\t\trealdatastart = (unsigned long) -ENOMEM;\n\t\t\tprintk(\"Unable to allocate RAM for process data, errno %d\\n\",\n\t\t\t\t\t(int)-realdatastart);\n\t\t\tvm_munmap(textpos, text_len);\n\t\t\tret = realdatastart;\n\t\t\tgoto err;\n\t\t}\n\t\tdatapos = ALIGN(realdatastart +\n\t\t\t\tMAX_SHARED_LIBS * sizeof(unsigned long),\n\t\t\t\tFLAT_DATA_ALIGN);\n\n\t\tDBG_FLT(\"BINFMT_FLAT: Allocated data+bss+stack (%d bytes): %x\\n\",\n\t\t\t\t(int)(data_len + bss_len + stack_len), (int)datapos);\n\n\t\tfpos = ntohl(hdr->data_start);\n#ifdef CONFIG_BINFMT_ZFLAT\n\t\tif (flags & FLAT_FLAG_GZDATA) {\n\t\t\tresult = decompress_exec(bprm, fpos, (char *) datapos, \n\t\t\t\t\t\t full_data, 0);\n\t\t} else\n#endif\n\t\t{\n\t\t\tresult = read_code(bprm->file, datapos, fpos,\n\t\t\t\t\tfull_data);\n\t\t}\n\t\tif (IS_ERR_VALUE(result)) {\n\t\t\tprintk(\"Unable to read data+bss, errno %d\\n\", (int)-result);\n\t\t\tvm_munmap(textpos, text_len);\n\t\t\tvm_munmap(realdatastart, len);\n\t\t\tret = result;\n\t\t\tgoto err;\n\t\t}\n\n\t\treloc = (unsigned long *) (datapos+(ntohl(hdr->reloc_start)-text_len));\n\t\tmemp = realdatastart;\n\t\tmemp_size = len;\n\t} else {\n\n\t\tlen = text_len + data_len + extra + MAX_SHARED_LIBS * sizeof(unsigned long);\n\t\tlen = PAGE_ALIGN(len);\n\t\ttextpos = vm_mmap(0, 0, len,\n\t\t\tPROT_READ | PROT_EXEC | PROT_WRITE, MAP_PRIVATE, 0);\n\n\t\tif (!textpos || IS_ERR_VALUE(textpos)) {\n\t\t\tif (!textpos)\n\t\t\t\ttextpos = (unsigned long) -ENOMEM;\n\t\t\tprintk(\"Unable to allocate RAM for process text/data, errno %d\\n\",\n\t\t\t\t\t(int)-textpos);\n\t\t\tret = textpos;\n\t\t\tgoto err;\n\t\t}\n\n\t\trealdatastart = textpos + ntohl(hdr->data_start);\n\t\tdatapos = ALIGN(realdatastart +\n\t\t\t\tMAX_SHARED_LIBS * sizeof(unsigned long),\n\t\t\t\tFLAT_DATA_ALIGN);\n\n\t\treloc = (unsigned long *)\n\t\t\t(datapos + (ntohl(hdr->reloc_start) - text_len));\n\t\tmemp = textpos;\n\t\tmemp_size = len;\n#ifdef CONFIG_BINFMT_ZFLAT\n\t\t/*\n\t\t * load it all in and treat it like a RAM load from now on\n\t\t */\n\t\tif (flags & FLAT_FLAG_GZIP) {\n\t\t\tresult = decompress_exec(bprm, sizeof (struct flat_hdr),\n\t\t\t\t\t (((char *) textpos) + sizeof (struct flat_hdr)),\n\t\t\t\t\t (text_len + full_data\n\t\t\t\t\t\t  - sizeof (struct flat_hdr)),\n\t\t\t\t\t 0);\n\t\t\tmemmove((void *) datapos, (void *) realdatastart,\n\t\t\t\t\tfull_data);\n\t\t} else if (flags & FLAT_FLAG_GZDATA) {\n\t\t\tresult = read_code(bprm->file, textpos, 0, text_len);\n\t\t\tif (!IS_ERR_VALUE(result))\n\t\t\t\tresult = decompress_exec(bprm, text_len, (char *) datapos,\n\t\t\t\t\t\t full_data, 0);\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t\tresult = read_code(bprm->file, textpos, 0, text_len);\n\t\t\tif (!IS_ERR_VALUE(result))\n\t\t\t\tresult = read_code(bprm->file, datapos,\n\t\t\t\t\t\t   ntohl(hdr->data_start),\n\t\t\t\t\t\t   full_data);\n\t\t}\n\t\tif (IS_ERR_VALUE(result)) {\n\t\t\tprintk(\"Unable to read code+data+bss, errno %d\\n\",(int)-result);\n\t\t\tvm_munmap(textpos, text_len + data_len + extra +\n\t\t\t\tMAX_SHARED_LIBS * sizeof(unsigned long));\n\t\t\tret = result;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (flags & FLAT_FLAG_KTRACE)\n\t\tprintk(\"Mapping is %x, Entry point is %x, data_start is %x\\n\",\n\t\t\t(int)textpos, 0x00ffffff&ntohl(hdr->entry), ntohl(hdr->data_start));\n\n\t/* The main program needs a little extra setup in the task structure */\n\tstart_code = textpos + sizeof (struct flat_hdr);\n\tend_code = textpos + text_len;\n\tif (id == 0) {\n\t\tcurrent->mm->start_code = start_code;\n\t\tcurrent->mm->end_code = end_code;\n\t\tcurrent->mm->start_data = datapos;\n\t\tcurrent->mm->end_data = datapos + data_len;\n\t\t/*\n\t\t * set up the brk stuff, uses any slack left in data/bss/stack\n\t\t * allocation.  We put the brk after the bss (between the bss\n\t\t * and stack) like other platforms.\n\t\t * Userspace code relies on the stack pointer starting out at\n\t\t * an address right at the end of a page.\n\t\t */\n\t\tcurrent->mm->start_brk = datapos + data_len + bss_len;\n\t\tcurrent->mm->brk = (current->mm->start_brk + 3) & ~3;\n\t\tcurrent->mm->context.end_brk = memp + memp_size - stack_len;\n\t}\n\n\tif (flags & FLAT_FLAG_KTRACE)\n\t\tprintk(\"%s %s: TEXT=%x-%x DATA=%x-%x BSS=%x-%x\\n\",\n\t\t\tid ? \"Lib\" : \"Load\", bprm->filename,\n\t\t\t(int) start_code, (int) end_code,\n\t\t\t(int) datapos,\n\t\t\t(int) (datapos + data_len),\n\t\t\t(int) (datapos + data_len),\n\t\t\t(int) (((datapos + data_len + bss_len) + 3) & ~3));\n\n\ttext_len -= sizeof(struct flat_hdr); /* the real code len */\n\n\t/* Store the current module values into the global library structure */\n\tlibinfo->lib_list[id].start_code = start_code;\n\tlibinfo->lib_list[id].start_data = datapos;\n\tlibinfo->lib_list[id].start_brk = datapos + data_len + bss_len;\n\tlibinfo->lib_list[id].text_len = text_len;\n\tlibinfo->lib_list[id].loaded = 1;\n\tlibinfo->lib_list[id].entry = (0x00ffffff & ntohl(hdr->entry)) + textpos;\n\tlibinfo->lib_list[id].build_date = ntohl(hdr->build_date);\n\t\n\t/*\n\t * We just load the allocations into some temporary memory to\n\t * help simplify all this mumbo jumbo\n\t *\n\t * We've got two different sections of relocation entries.\n\t * The first is the GOT which resides at the beginning of the data segment\n\t * and is terminated with a -1.  This one can be relocated in place.\n\t * The second is the extra relocation entries tacked after the image's\n\t * data segment. These require a little more processing as the entry is\n\t * really an offset into the image which contains an offset into the\n\t * image.\n\t */\n\tif (flags & FLAT_FLAG_GOTPIC) {\n\t\tfor (rp = (unsigned long *)datapos; *rp != 0xffffffff; rp++) {\n\t\t\tunsigned long addr;\n\t\t\tif (*rp) {\n\t\t\t\taddr = calc_reloc(*rp, libinfo, id, 0);\n\t\t\t\tif (addr == RELOC_FAILED) {\n\t\t\t\t\tret = -ENOEXEC;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\t*rp = addr;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Now run through the relocation entries.\n\t * We've got to be careful here as C++ produces relocatable zero\n\t * entries in the constructor and destructor tables which are then\n\t * tested for being not zero (which will always occur unless we're\n\t * based from address zero).  This causes an endless loop as __start\n\t * is at zero.  The solution used is to not relocate zero addresses.\n\t * This has the negative side effect of not allowing a global data\n\t * reference to be statically initialised to _stext (I've moved\n\t * __start to address 4 so that is okay).\n\t */\n\tif (rev > OLD_FLAT_VERSION) {\n\t\tunsigned long persistent = 0;\n\t\tfor (i=0; i < relocs; i++) {\n\t\t\tunsigned long addr, relval;\n\n\t\t\t/* Get the address of the pointer to be\n\t\t\t   relocated (of course, the address has to be\n\t\t\t   relocated first).  */\n\t\t\trelval = ntohl(reloc[i]);\n\t\t\tif (flat_set_persistent (relval, &persistent))\n\t\t\t\tcontinue;\n\t\t\taddr = flat_get_relocate_addr(relval);\n\t\t\trp = (unsigned long *) calc_reloc(addr, libinfo, id, 1);\n\t\t\tif (rp == (unsigned long *)RELOC_FAILED) {\n\t\t\t\tret = -ENOEXEC;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\t/* Get the pointer's value.  */\n\t\t\taddr = flat_get_addr_from_rp(rp, relval, flags,\n\t\t\t\t\t\t\t&persistent);\n\t\t\tif (addr != 0) {\n\t\t\t\t/*\n\t\t\t\t * Do the relocation.  PIC relocs in the data section are\n\t\t\t\t * already in target order\n\t\t\t\t */\n\t\t\t\tif ((flags & FLAT_FLAG_GOTPIC) == 0)\n\t\t\t\t\taddr = ntohl(addr);\n\t\t\t\taddr = calc_reloc(addr, libinfo, id, 0);\n\t\t\t\tif (addr == RELOC_FAILED) {\n\t\t\t\t\tret = -ENOEXEC;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\n\t\t\t\t/* Write back the relocated pointer.  */\n\t\t\t\tflat_put_addr_at_rp(rp, addr, relval);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i=0; i < relocs; i++)\n\t\t\told_reloc(ntohl(reloc[i]));\n\t}\n\t\n\tflush_icache_range(start_code, end_code);\n\n\t/* zero the BSS,  BRK and stack areas */\n\tmemset((void*)(datapos + data_len), 0, bss_len + \n\t\t\t(memp + memp_size - stack_len -\t\t/* end brk */\n\t\t\tlibinfo->lib_list[id].start_brk) +\t/* start brk */\n\t\t\tstack_len);\n\n\treturn 0;\nerr:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&libinfo",
            "0",
            "sizeof(libinfo)"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_pt_regs",
          "args": [],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/zlib.h>\n#include <asm/page.h>\n#include <asm/cacheflush.h>\n#include <asm/unaligned.h>\n#include <asm/uaccess.h>\n#include <asm/byteorder.h>\n#include <linux/syscalls.h>\n#include <linux/flat.h>\n#include <linux/init.h>\n#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/slab.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\n#define TOP_OF_ARGS (PAGE_SIZE * MAX_ARG_PAGES - sizeof(void *))\n#define UNLOADED_LIB 0x7ff000ff\t\t/* Placeholder for unused library */\n#define FLAT_STACK_ALIGN\tmax_t(unsigned long, sizeof(void *), ARCH_SLAB_MINALIGN)\n\nstatic int load_flat_binary(struct linux_binprm *);\nstatic struct linux_binfmt flat_format = {\n\t.module\t\t= THIS_MODULE,\n\t.load_binary\t= load_flat_binary,\n\t.core_dump\t= flat_core_dump,\n\t.min_coredump\t= PAGE_SIZE\n};\n\nstatic int load_flat_binary(struct linux_binprm * bprm)\n{\n\tstruct lib_info libinfo;\n\tstruct pt_regs *regs = current_pt_regs();\n\tunsigned long p = bprm->p;\n\tunsigned long stack_len;\n\tunsigned long start_addr;\n\tunsigned long *sp;\n\tint res;\n\tint i, j;\n\n\tmemset(&libinfo, 0, sizeof(libinfo));\n\t/*\n\t * We have to add the size of our arguments to our stack size\n\t * otherwise it's too easy for users to create stack overflows\n\t * by passing in a huge argument list.  And yes,  we have to be\n\t * pedantic and include space for the argv/envp array as it may have\n\t * a lot of entries.\n\t */\n#define TOP_OF_ARGS (PAGE_SIZE * MAX_ARG_PAGES - sizeof(void *))\n\tstack_len = TOP_OF_ARGS - bprm->p;             /* the strings */\n\tstack_len += (bprm->argc + 1) * sizeof(char *); /* the argv array */\n\tstack_len += (bprm->envc + 1) * sizeof(char *); /* the envp array */\n\tstack_len += FLAT_STACK_ALIGN - 1;  /* reserve for upcoming alignment */\n\t\n\tres = load_flat_file(bprm, &libinfo, 0, &stack_len);\n\tif (IS_ERR_VALUE(res))\n\t\treturn res;\n\t\n\t/* Update data segment pointers for all libraries */\n\tfor (i=0; i<MAX_SHARED_LIBS; i++)\n\t\tif (libinfo.lib_list[i].loaded)\n\t\t\tfor (j=0; j<MAX_SHARED_LIBS; j++)\n\t\t\t\t(-(j+1))[(unsigned long *)(libinfo.lib_list[i].start_data)] =\n\t\t\t\t\t(libinfo.lib_list[j].loaded)?\n\t\t\t\t\t\tlibinfo.lib_list[j].start_data:UNLOADED_LIB;\n\n\tinstall_exec_creds(bprm);\n\n\tset_binfmt(&flat_format);\n\n\tp = ((current->mm->context.end_brk + stack_len + 3) & ~3) - 4;\n\tDBG_FLT(\"p=%x\\n\", (int)p);\n\n\t/* copy the arg pages onto the stack, this could be more efficient :-) */\n\tfor (i = TOP_OF_ARGS - 1; i >= bprm->p; i--)\n\t\t* (char *) --p =\n\t\t\t((char *) page_address(bprm->page[i/PAGE_SIZE]))[i % PAGE_SIZE];\n\n\tsp = (unsigned long *) create_flat_tables(p, bprm);\n\t\n\t/* Fake some return addresses to ensure the call chain will\n\t * initialise library in order for us.  We are required to call\n\t * lib 1 first, then 2, ... and finally the main program (id 0).\n\t */\n\tstart_addr = libinfo.lib_list[0].entry;\n\n#ifdef CONFIG_BINFMT_SHARED_FLAT\n\tfor (i = MAX_SHARED_LIBS-1; i>0; i--) {\n\t\tif (libinfo.lib_list[i].loaded) {\n\t\t\t/* Push previos first to call address */\n\t\t\t--sp;\tput_user(start_addr, sp);\n\t\t\tstart_addr = libinfo.lib_list[i].entry;\n\t\t}\n\t}\n#endif\n\t\n\t/* Stash our initial stack pointer into the mm structure */\n\tcurrent->mm->start_stack = (unsigned long )sp;\n\n#ifdef FLAT_PLAT_INIT\n\tFLAT_PLAT_INIT(regs);\n#endif\n\tDBG_FLT(\"start_thread(regs=0x%x, entry=0x%x, start_stack=0x%x)\\n\",\n\t\t(int)regs, (int)start_addr, (int)current->mm->start_stack);\n\t\n\tstart_thread(regs, start_addr, current->mm->start_stack);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "load_flat_shared_library",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_flat.c",
    "lines": "809-850",
    "snippet": "static int load_flat_shared_library(int id, struct lib_info *libs)\n{\n\tstruct linux_binprm bprm;\n\tint res;\n\tchar buf[16];\n\n\tmemset(&bprm, 0, sizeof(bprm));\n\n\t/* Create the file name */\n\tsprintf(buf, \"/lib/lib%d.so\", id);\n\n\t/* Open the file up */\n\tbprm.filename = buf;\n\tbprm.file = open_exec(bprm.filename);\n\tres = PTR_ERR(bprm.file);\n\tif (IS_ERR(bprm.file))\n\t\treturn res;\n\n\tbprm.cred = prepare_exec_creds();\n\tres = -ENOMEM;\n\tif (!bprm.cred)\n\t\tgoto out;\n\n\t/* We don't really care about recalculating credentials at this point\n\t * as we're past the point of no return and are dealing with shared\n\t * libraries.\n\t */\n\tbprm.cred_prepared = 1;\n\n\tres = prepare_binprm(&bprm);\n\n\tif (!IS_ERR_VALUE(res))\n\t\tres = load_flat_file(&bprm, libs, id, NULL);\n\n\tabort_creds(bprm.cred);\n\nout:\n\tallow_write_access(bprm.file);\n\tfput(bprm.file);\n\n\treturn(res);\n}",
    "includes": [
      "#include <linux/zlib.h>",
      "#include <asm/page.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/unaligned.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/flat.h>",
      "#include <linux/init.h>",
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/slab.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int load_flat_binary(struct linux_binprm *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "bprm.file"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "293-300",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "allow_write_access",
          "args": [
            "bprm.file"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abort_creds",
          "args": [
            "bprm.cred"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_flat_file",
          "args": [
            "&bprm",
            "libs",
            "id",
            "NULL"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "load_flat_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_flat.c",
          "lines": "426-798",
          "snippet": "static int load_flat_file(struct linux_binprm * bprm,\n\t\tstruct lib_info *libinfo, int id, unsigned long *extra_stack)\n{\n\tstruct flat_hdr * hdr;\n\tunsigned long textpos = 0, datapos = 0, result;\n\tunsigned long realdatastart = 0;\n\tunsigned long text_len, data_len, bss_len, stack_len, flags;\n\tunsigned long full_data;\n\tunsigned long len, memp = 0;\n\tunsigned long memp_size, extra, rlim;\n\tunsigned long *reloc = 0, *rp;\n\tstruct inode *inode;\n\tint i, rev, relocs = 0;\n\tloff_t fpos;\n\tunsigned long start_code, end_code;\n\tint ret;\n\n\thdr = ((struct flat_hdr *) bprm->buf);\t\t/* exec-header */\n\tinode = file_inode(bprm->file);\n\n\ttext_len  = ntohl(hdr->data_start);\n\tdata_len  = ntohl(hdr->data_end) - ntohl(hdr->data_start);\n\tbss_len   = ntohl(hdr->bss_end) - ntohl(hdr->data_end);\n\tstack_len = ntohl(hdr->stack_size);\n\tif (extra_stack) {\n\t\tstack_len += *extra_stack;\n\t\t*extra_stack = stack_len;\n\t}\n\trelocs    = ntohl(hdr->reloc_count);\n\tflags     = ntohl(hdr->flags);\n\trev       = ntohl(hdr->rev);\n\tfull_data = data_len + relocs * sizeof(unsigned long);\n\n\tif (strncmp(hdr->magic, \"bFLT\", 4)) {\n\t\t/*\n\t\t * Previously, here was a printk to tell people\n\t\t *   \"BINFMT_FLAT: bad header magic\".\n\t\t * But for the kernel which also use ELF FD-PIC format, this\n\t\t * error message is confusing.\n\t\t * because a lot of people do not manage to produce good\n\t\t */\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n\n\tif (flags & FLAT_FLAG_KTRACE)\n\t\tprintk(\"BINFMT_FLAT: Loading file: %s\\n\", bprm->filename);\n\n\tif (rev != FLAT_VERSION && rev != OLD_FLAT_VERSION) {\n\t\tprintk(\"BINFMT_FLAT: bad flat file version 0x%x (supported \"\n\t\t\t\"0x%lx and 0x%lx)\\n\",\n\t\t\trev, FLAT_VERSION, OLD_FLAT_VERSION);\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n\t\n\t/* Don't allow old format executables to use shared libraries */\n\tif (rev == OLD_FLAT_VERSION && id != 0) {\n\t\tprintk(\"BINFMT_FLAT: shared libraries are not available before rev 0x%x\\n\",\n\t\t\t\t(int) FLAT_VERSION);\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n\n\t/*\n\t * fix up the flags for the older format,  there were all kinds\n\t * of endian hacks,  this only works for the simple cases\n\t */\n\tif (rev == OLD_FLAT_VERSION && flat_old_ram_flag(flags))\n\t\tflags = FLAT_FLAG_RAM;\n\n#ifndef CONFIG_BINFMT_ZFLAT\n\tif (flags & (FLAT_FLAG_GZIP|FLAT_FLAG_GZDATA)) {\n\t\tprintk(\"Support for ZFLAT executables is not enabled.\\n\");\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n#endif\n\n\t/*\n\t * Check initial limits. This avoids letting people circumvent\n\t * size limits imposed on them by creating programs with large\n\t * arrays in the data or bss.\n\t */\n\trlim = rlimit(RLIMIT_DATA);\n\tif (rlim >= RLIM_INFINITY)\n\t\trlim = ~0;\n\tif (data_len + bss_len > rlim) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t/* Flush all traces of the currently running executable */\n\tif (id == 0) {\n\t\tresult = flush_old_exec(bprm);\n\t\tif (result) {\n\t\t\tret = result;\n\t\t\tgoto err;\n\t\t}\n\n\t\t/* OK, This is the point of no return */\n\t\tset_personality(PER_LINUX_32BIT);\n\t\tsetup_new_exec(bprm);\n\t}\n\n\t/*\n\t * calculate the extra space we need to map in\n\t */\n\textra = max_t(unsigned long, bss_len + stack_len,\n\t\t\trelocs * sizeof(unsigned long));\n\n\t/*\n\t * there are a couple of cases here,  the separate code/data\n\t * case,  and then the fully copied to RAM case which lumps\n\t * it all together.\n\t */\n\tif ((flags & (FLAT_FLAG_RAM|FLAT_FLAG_GZIP)) == 0) {\n\t\t/*\n\t\t * this should give us a ROM ptr,  but if it doesn't we don't\n\t\t * really care\n\t\t */\n\t\tDBG_FLT(\"BINFMT_FLAT: ROM mapping of file (we hope)\\n\");\n\n\t\ttextpos = vm_mmap(bprm->file, 0, text_len, PROT_READ|PROT_EXEC,\n\t\t\t\t  MAP_PRIVATE|MAP_EXECUTABLE, 0);\n\t\tif (!textpos || IS_ERR_VALUE(textpos)) {\n\t\t\tif (!textpos)\n\t\t\t\ttextpos = (unsigned long) -ENOMEM;\n\t\t\tprintk(\"Unable to mmap process text, errno %d\\n\", (int)-textpos);\n\t\t\tret = textpos;\n\t\t\tgoto err;\n\t\t}\n\n\t\tlen = data_len + extra + MAX_SHARED_LIBS * sizeof(unsigned long);\n\t\tlen = PAGE_ALIGN(len);\n\t\trealdatastart = vm_mmap(0, 0, len,\n\t\t\tPROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE, 0);\n\n\t\tif (realdatastart == 0 || IS_ERR_VALUE(realdatastart)) {\n\t\t\tif (!realdatastart)\n\t\t\t\trealdatastart = (unsigned long) -ENOMEM;\n\t\t\tprintk(\"Unable to allocate RAM for process data, errno %d\\n\",\n\t\t\t\t\t(int)-realdatastart);\n\t\t\tvm_munmap(textpos, text_len);\n\t\t\tret = realdatastart;\n\t\t\tgoto err;\n\t\t}\n\t\tdatapos = ALIGN(realdatastart +\n\t\t\t\tMAX_SHARED_LIBS * sizeof(unsigned long),\n\t\t\t\tFLAT_DATA_ALIGN);\n\n\t\tDBG_FLT(\"BINFMT_FLAT: Allocated data+bss+stack (%d bytes): %x\\n\",\n\t\t\t\t(int)(data_len + bss_len + stack_len), (int)datapos);\n\n\t\tfpos = ntohl(hdr->data_start);\n#ifdef CONFIG_BINFMT_ZFLAT\n\t\tif (flags & FLAT_FLAG_GZDATA) {\n\t\t\tresult = decompress_exec(bprm, fpos, (char *) datapos, \n\t\t\t\t\t\t full_data, 0);\n\t\t} else\n#endif\n\t\t{\n\t\t\tresult = read_code(bprm->file, datapos, fpos,\n\t\t\t\t\tfull_data);\n\t\t}\n\t\tif (IS_ERR_VALUE(result)) {\n\t\t\tprintk(\"Unable to read data+bss, errno %d\\n\", (int)-result);\n\t\t\tvm_munmap(textpos, text_len);\n\t\t\tvm_munmap(realdatastart, len);\n\t\t\tret = result;\n\t\t\tgoto err;\n\t\t}\n\n\t\treloc = (unsigned long *) (datapos+(ntohl(hdr->reloc_start)-text_len));\n\t\tmemp = realdatastart;\n\t\tmemp_size = len;\n\t} else {\n\n\t\tlen = text_len + data_len + extra + MAX_SHARED_LIBS * sizeof(unsigned long);\n\t\tlen = PAGE_ALIGN(len);\n\t\ttextpos = vm_mmap(0, 0, len,\n\t\t\tPROT_READ | PROT_EXEC | PROT_WRITE, MAP_PRIVATE, 0);\n\n\t\tif (!textpos || IS_ERR_VALUE(textpos)) {\n\t\t\tif (!textpos)\n\t\t\t\ttextpos = (unsigned long) -ENOMEM;\n\t\t\tprintk(\"Unable to allocate RAM for process text/data, errno %d\\n\",\n\t\t\t\t\t(int)-textpos);\n\t\t\tret = textpos;\n\t\t\tgoto err;\n\t\t}\n\n\t\trealdatastart = textpos + ntohl(hdr->data_start);\n\t\tdatapos = ALIGN(realdatastart +\n\t\t\t\tMAX_SHARED_LIBS * sizeof(unsigned long),\n\t\t\t\tFLAT_DATA_ALIGN);\n\n\t\treloc = (unsigned long *)\n\t\t\t(datapos + (ntohl(hdr->reloc_start) - text_len));\n\t\tmemp = textpos;\n\t\tmemp_size = len;\n#ifdef CONFIG_BINFMT_ZFLAT\n\t\t/*\n\t\t * load it all in and treat it like a RAM load from now on\n\t\t */\n\t\tif (flags & FLAT_FLAG_GZIP) {\n\t\t\tresult = decompress_exec(bprm, sizeof (struct flat_hdr),\n\t\t\t\t\t (((char *) textpos) + sizeof (struct flat_hdr)),\n\t\t\t\t\t (text_len + full_data\n\t\t\t\t\t\t  - sizeof (struct flat_hdr)),\n\t\t\t\t\t 0);\n\t\t\tmemmove((void *) datapos, (void *) realdatastart,\n\t\t\t\t\tfull_data);\n\t\t} else if (flags & FLAT_FLAG_GZDATA) {\n\t\t\tresult = read_code(bprm->file, textpos, 0, text_len);\n\t\t\tif (!IS_ERR_VALUE(result))\n\t\t\t\tresult = decompress_exec(bprm, text_len, (char *) datapos,\n\t\t\t\t\t\t full_data, 0);\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t\tresult = read_code(bprm->file, textpos, 0, text_len);\n\t\t\tif (!IS_ERR_VALUE(result))\n\t\t\t\tresult = read_code(bprm->file, datapos,\n\t\t\t\t\t\t   ntohl(hdr->data_start),\n\t\t\t\t\t\t   full_data);\n\t\t}\n\t\tif (IS_ERR_VALUE(result)) {\n\t\t\tprintk(\"Unable to read code+data+bss, errno %d\\n\",(int)-result);\n\t\t\tvm_munmap(textpos, text_len + data_len + extra +\n\t\t\t\tMAX_SHARED_LIBS * sizeof(unsigned long));\n\t\t\tret = result;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (flags & FLAT_FLAG_KTRACE)\n\t\tprintk(\"Mapping is %x, Entry point is %x, data_start is %x\\n\",\n\t\t\t(int)textpos, 0x00ffffff&ntohl(hdr->entry), ntohl(hdr->data_start));\n\n\t/* The main program needs a little extra setup in the task structure */\n\tstart_code = textpos + sizeof (struct flat_hdr);\n\tend_code = textpos + text_len;\n\tif (id == 0) {\n\t\tcurrent->mm->start_code = start_code;\n\t\tcurrent->mm->end_code = end_code;\n\t\tcurrent->mm->start_data = datapos;\n\t\tcurrent->mm->end_data = datapos + data_len;\n\t\t/*\n\t\t * set up the brk stuff, uses any slack left in data/bss/stack\n\t\t * allocation.  We put the brk after the bss (between the bss\n\t\t * and stack) like other platforms.\n\t\t * Userspace code relies on the stack pointer starting out at\n\t\t * an address right at the end of a page.\n\t\t */\n\t\tcurrent->mm->start_brk = datapos + data_len + bss_len;\n\t\tcurrent->mm->brk = (current->mm->start_brk + 3) & ~3;\n\t\tcurrent->mm->context.end_brk = memp + memp_size - stack_len;\n\t}\n\n\tif (flags & FLAT_FLAG_KTRACE)\n\t\tprintk(\"%s %s: TEXT=%x-%x DATA=%x-%x BSS=%x-%x\\n\",\n\t\t\tid ? \"Lib\" : \"Load\", bprm->filename,\n\t\t\t(int) start_code, (int) end_code,\n\t\t\t(int) datapos,\n\t\t\t(int) (datapos + data_len),\n\t\t\t(int) (datapos + data_len),\n\t\t\t(int) (((datapos + data_len + bss_len) + 3) & ~3));\n\n\ttext_len -= sizeof(struct flat_hdr); /* the real code len */\n\n\t/* Store the current module values into the global library structure */\n\tlibinfo->lib_list[id].start_code = start_code;\n\tlibinfo->lib_list[id].start_data = datapos;\n\tlibinfo->lib_list[id].start_brk = datapos + data_len + bss_len;\n\tlibinfo->lib_list[id].text_len = text_len;\n\tlibinfo->lib_list[id].loaded = 1;\n\tlibinfo->lib_list[id].entry = (0x00ffffff & ntohl(hdr->entry)) + textpos;\n\tlibinfo->lib_list[id].build_date = ntohl(hdr->build_date);\n\t\n\t/*\n\t * We just load the allocations into some temporary memory to\n\t * help simplify all this mumbo jumbo\n\t *\n\t * We've got two different sections of relocation entries.\n\t * The first is the GOT which resides at the beginning of the data segment\n\t * and is terminated with a -1.  This one can be relocated in place.\n\t * The second is the extra relocation entries tacked after the image's\n\t * data segment. These require a little more processing as the entry is\n\t * really an offset into the image which contains an offset into the\n\t * image.\n\t */\n\tif (flags & FLAT_FLAG_GOTPIC) {\n\t\tfor (rp = (unsigned long *)datapos; *rp != 0xffffffff; rp++) {\n\t\t\tunsigned long addr;\n\t\t\tif (*rp) {\n\t\t\t\taddr = calc_reloc(*rp, libinfo, id, 0);\n\t\t\t\tif (addr == RELOC_FAILED) {\n\t\t\t\t\tret = -ENOEXEC;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\t*rp = addr;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Now run through the relocation entries.\n\t * We've got to be careful here as C++ produces relocatable zero\n\t * entries in the constructor and destructor tables which are then\n\t * tested for being not zero (which will always occur unless we're\n\t * based from address zero).  This causes an endless loop as __start\n\t * is at zero.  The solution used is to not relocate zero addresses.\n\t * This has the negative side effect of not allowing a global data\n\t * reference to be statically initialised to _stext (I've moved\n\t * __start to address 4 so that is okay).\n\t */\n\tif (rev > OLD_FLAT_VERSION) {\n\t\tunsigned long persistent = 0;\n\t\tfor (i=0; i < relocs; i++) {\n\t\t\tunsigned long addr, relval;\n\n\t\t\t/* Get the address of the pointer to be\n\t\t\t   relocated (of course, the address has to be\n\t\t\t   relocated first).  */\n\t\t\trelval = ntohl(reloc[i]);\n\t\t\tif (flat_set_persistent (relval, &persistent))\n\t\t\t\tcontinue;\n\t\t\taddr = flat_get_relocate_addr(relval);\n\t\t\trp = (unsigned long *) calc_reloc(addr, libinfo, id, 1);\n\t\t\tif (rp == (unsigned long *)RELOC_FAILED) {\n\t\t\t\tret = -ENOEXEC;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\t/* Get the pointer's value.  */\n\t\t\taddr = flat_get_addr_from_rp(rp, relval, flags,\n\t\t\t\t\t\t\t&persistent);\n\t\t\tif (addr != 0) {\n\t\t\t\t/*\n\t\t\t\t * Do the relocation.  PIC relocs in the data section are\n\t\t\t\t * already in target order\n\t\t\t\t */\n\t\t\t\tif ((flags & FLAT_FLAG_GOTPIC) == 0)\n\t\t\t\t\taddr = ntohl(addr);\n\t\t\t\taddr = calc_reloc(addr, libinfo, id, 0);\n\t\t\t\tif (addr == RELOC_FAILED) {\n\t\t\t\t\tret = -ENOEXEC;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\n\t\t\t\t/* Write back the relocated pointer.  */\n\t\t\t\tflat_put_addr_at_rp(rp, addr, relval);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i=0; i < relocs; i++)\n\t\t\told_reloc(ntohl(reloc[i]));\n\t}\n\t\n\tflush_icache_range(start_code, end_code);\n\n\t/* zero the BSS,  BRK and stack areas */\n\tmemset((void*)(datapos + data_len), 0, bss_len + \n\t\t\t(memp + memp_size - stack_len -\t\t/* end brk */\n\t\t\tlibinfo->lib_list[id].start_brk) +\t/* start brk */\n\t\t\tstack_len);\n\n\treturn 0;\nerr:\n\treturn ret;\n}",
          "includes": [
            "#include <linux/zlib.h>",
            "#include <asm/page.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/flat.h>",
            "#include <linux/init.h>",
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/slab.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define RELOC_FAILED 0xff00ff01\t\t/* Relocation incorrect somewhere */",
            "#define FLAT_DATA_ALIGN\t(0x20)"
          ],
          "globals_used": [
            "static int load_flat_binary(struct linux_binprm *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zlib.h>\n#include <asm/page.h>\n#include <asm/cacheflush.h>\n#include <asm/unaligned.h>\n#include <asm/uaccess.h>\n#include <asm/byteorder.h>\n#include <linux/syscalls.h>\n#include <linux/flat.h>\n#include <linux/init.h>\n#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/slab.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\n#define RELOC_FAILED 0xff00ff01\t\t/* Relocation incorrect somewhere */\n#define FLAT_DATA_ALIGN\t(0x20)\n\nstatic int load_flat_binary(struct linux_binprm *);\n\nstatic int load_flat_file(struct linux_binprm * bprm,\n\t\tstruct lib_info *libinfo, int id, unsigned long *extra_stack)\n{\n\tstruct flat_hdr * hdr;\n\tunsigned long textpos = 0, datapos = 0, result;\n\tunsigned long realdatastart = 0;\n\tunsigned long text_len, data_len, bss_len, stack_len, flags;\n\tunsigned long full_data;\n\tunsigned long len, memp = 0;\n\tunsigned long memp_size, extra, rlim;\n\tunsigned long *reloc = 0, *rp;\n\tstruct inode *inode;\n\tint i, rev, relocs = 0;\n\tloff_t fpos;\n\tunsigned long start_code, end_code;\n\tint ret;\n\n\thdr = ((struct flat_hdr *) bprm->buf);\t\t/* exec-header */\n\tinode = file_inode(bprm->file);\n\n\ttext_len  = ntohl(hdr->data_start);\n\tdata_len  = ntohl(hdr->data_end) - ntohl(hdr->data_start);\n\tbss_len   = ntohl(hdr->bss_end) - ntohl(hdr->data_end);\n\tstack_len = ntohl(hdr->stack_size);\n\tif (extra_stack) {\n\t\tstack_len += *extra_stack;\n\t\t*extra_stack = stack_len;\n\t}\n\trelocs    = ntohl(hdr->reloc_count);\n\tflags     = ntohl(hdr->flags);\n\trev       = ntohl(hdr->rev);\n\tfull_data = data_len + relocs * sizeof(unsigned long);\n\n\tif (strncmp(hdr->magic, \"bFLT\", 4)) {\n\t\t/*\n\t\t * Previously, here was a printk to tell people\n\t\t *   \"BINFMT_FLAT: bad header magic\".\n\t\t * But for the kernel which also use ELF FD-PIC format, this\n\t\t * error message is confusing.\n\t\t * because a lot of people do not manage to produce good\n\t\t */\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n\n\tif (flags & FLAT_FLAG_KTRACE)\n\t\tprintk(\"BINFMT_FLAT: Loading file: %s\\n\", bprm->filename);\n\n\tif (rev != FLAT_VERSION && rev != OLD_FLAT_VERSION) {\n\t\tprintk(\"BINFMT_FLAT: bad flat file version 0x%x (supported \"\n\t\t\t\"0x%lx and 0x%lx)\\n\",\n\t\t\trev, FLAT_VERSION, OLD_FLAT_VERSION);\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n\t\n\t/* Don't allow old format executables to use shared libraries */\n\tif (rev == OLD_FLAT_VERSION && id != 0) {\n\t\tprintk(\"BINFMT_FLAT: shared libraries are not available before rev 0x%x\\n\",\n\t\t\t\t(int) FLAT_VERSION);\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n\n\t/*\n\t * fix up the flags for the older format,  there were all kinds\n\t * of endian hacks,  this only works for the simple cases\n\t */\n\tif (rev == OLD_FLAT_VERSION && flat_old_ram_flag(flags))\n\t\tflags = FLAT_FLAG_RAM;\n\n#ifndef CONFIG_BINFMT_ZFLAT\n\tif (flags & (FLAT_FLAG_GZIP|FLAT_FLAG_GZDATA)) {\n\t\tprintk(\"Support for ZFLAT executables is not enabled.\\n\");\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n#endif\n\n\t/*\n\t * Check initial limits. This avoids letting people circumvent\n\t * size limits imposed on them by creating programs with large\n\t * arrays in the data or bss.\n\t */\n\trlim = rlimit(RLIMIT_DATA);\n\tif (rlim >= RLIM_INFINITY)\n\t\trlim = ~0;\n\tif (data_len + bss_len > rlim) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t/* Flush all traces of the currently running executable */\n\tif (id == 0) {\n\t\tresult = flush_old_exec(bprm);\n\t\tif (result) {\n\t\t\tret = result;\n\t\t\tgoto err;\n\t\t}\n\n\t\t/* OK, This is the point of no return */\n\t\tset_personality(PER_LINUX_32BIT);\n\t\tsetup_new_exec(bprm);\n\t}\n\n\t/*\n\t * calculate the extra space we need to map in\n\t */\n\textra = max_t(unsigned long, bss_len + stack_len,\n\t\t\trelocs * sizeof(unsigned long));\n\n\t/*\n\t * there are a couple of cases here,  the separate code/data\n\t * case,  and then the fully copied to RAM case which lumps\n\t * it all together.\n\t */\n\tif ((flags & (FLAT_FLAG_RAM|FLAT_FLAG_GZIP)) == 0) {\n\t\t/*\n\t\t * this should give us a ROM ptr,  but if it doesn't we don't\n\t\t * really care\n\t\t */\n\t\tDBG_FLT(\"BINFMT_FLAT: ROM mapping of file (we hope)\\n\");\n\n\t\ttextpos = vm_mmap(bprm->file, 0, text_len, PROT_READ|PROT_EXEC,\n\t\t\t\t  MAP_PRIVATE|MAP_EXECUTABLE, 0);\n\t\tif (!textpos || IS_ERR_VALUE(textpos)) {\n\t\t\tif (!textpos)\n\t\t\t\ttextpos = (unsigned long) -ENOMEM;\n\t\t\tprintk(\"Unable to mmap process text, errno %d\\n\", (int)-textpos);\n\t\t\tret = textpos;\n\t\t\tgoto err;\n\t\t}\n\n\t\tlen = data_len + extra + MAX_SHARED_LIBS * sizeof(unsigned long);\n\t\tlen = PAGE_ALIGN(len);\n\t\trealdatastart = vm_mmap(0, 0, len,\n\t\t\tPROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE, 0);\n\n\t\tif (realdatastart == 0 || IS_ERR_VALUE(realdatastart)) {\n\t\t\tif (!realdatastart)\n\t\t\t\trealdatastart = (unsigned long) -ENOMEM;\n\t\t\tprintk(\"Unable to allocate RAM for process data, errno %d\\n\",\n\t\t\t\t\t(int)-realdatastart);\n\t\t\tvm_munmap(textpos, text_len);\n\t\t\tret = realdatastart;\n\t\t\tgoto err;\n\t\t}\n\t\tdatapos = ALIGN(realdatastart +\n\t\t\t\tMAX_SHARED_LIBS * sizeof(unsigned long),\n\t\t\t\tFLAT_DATA_ALIGN);\n\n\t\tDBG_FLT(\"BINFMT_FLAT: Allocated data+bss+stack (%d bytes): %x\\n\",\n\t\t\t\t(int)(data_len + bss_len + stack_len), (int)datapos);\n\n\t\tfpos = ntohl(hdr->data_start);\n#ifdef CONFIG_BINFMT_ZFLAT\n\t\tif (flags & FLAT_FLAG_GZDATA) {\n\t\t\tresult = decompress_exec(bprm, fpos, (char *) datapos, \n\t\t\t\t\t\t full_data, 0);\n\t\t} else\n#endif\n\t\t{\n\t\t\tresult = read_code(bprm->file, datapos, fpos,\n\t\t\t\t\tfull_data);\n\t\t}\n\t\tif (IS_ERR_VALUE(result)) {\n\t\t\tprintk(\"Unable to read data+bss, errno %d\\n\", (int)-result);\n\t\t\tvm_munmap(textpos, text_len);\n\t\t\tvm_munmap(realdatastart, len);\n\t\t\tret = result;\n\t\t\tgoto err;\n\t\t}\n\n\t\treloc = (unsigned long *) (datapos+(ntohl(hdr->reloc_start)-text_len));\n\t\tmemp = realdatastart;\n\t\tmemp_size = len;\n\t} else {\n\n\t\tlen = text_len + data_len + extra + MAX_SHARED_LIBS * sizeof(unsigned long);\n\t\tlen = PAGE_ALIGN(len);\n\t\ttextpos = vm_mmap(0, 0, len,\n\t\t\tPROT_READ | PROT_EXEC | PROT_WRITE, MAP_PRIVATE, 0);\n\n\t\tif (!textpos || IS_ERR_VALUE(textpos)) {\n\t\t\tif (!textpos)\n\t\t\t\ttextpos = (unsigned long) -ENOMEM;\n\t\t\tprintk(\"Unable to allocate RAM for process text/data, errno %d\\n\",\n\t\t\t\t\t(int)-textpos);\n\t\t\tret = textpos;\n\t\t\tgoto err;\n\t\t}\n\n\t\trealdatastart = textpos + ntohl(hdr->data_start);\n\t\tdatapos = ALIGN(realdatastart +\n\t\t\t\tMAX_SHARED_LIBS * sizeof(unsigned long),\n\t\t\t\tFLAT_DATA_ALIGN);\n\n\t\treloc = (unsigned long *)\n\t\t\t(datapos + (ntohl(hdr->reloc_start) - text_len));\n\t\tmemp = textpos;\n\t\tmemp_size = len;\n#ifdef CONFIG_BINFMT_ZFLAT\n\t\t/*\n\t\t * load it all in and treat it like a RAM load from now on\n\t\t */\n\t\tif (flags & FLAT_FLAG_GZIP) {\n\t\t\tresult = decompress_exec(bprm, sizeof (struct flat_hdr),\n\t\t\t\t\t (((char *) textpos) + sizeof (struct flat_hdr)),\n\t\t\t\t\t (text_len + full_data\n\t\t\t\t\t\t  - sizeof (struct flat_hdr)),\n\t\t\t\t\t 0);\n\t\t\tmemmove((void *) datapos, (void *) realdatastart,\n\t\t\t\t\tfull_data);\n\t\t} else if (flags & FLAT_FLAG_GZDATA) {\n\t\t\tresult = read_code(bprm->file, textpos, 0, text_len);\n\t\t\tif (!IS_ERR_VALUE(result))\n\t\t\t\tresult = decompress_exec(bprm, text_len, (char *) datapos,\n\t\t\t\t\t\t full_data, 0);\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t\tresult = read_code(bprm->file, textpos, 0, text_len);\n\t\t\tif (!IS_ERR_VALUE(result))\n\t\t\t\tresult = read_code(bprm->file, datapos,\n\t\t\t\t\t\t   ntohl(hdr->data_start),\n\t\t\t\t\t\t   full_data);\n\t\t}\n\t\tif (IS_ERR_VALUE(result)) {\n\t\t\tprintk(\"Unable to read code+data+bss, errno %d\\n\",(int)-result);\n\t\t\tvm_munmap(textpos, text_len + data_len + extra +\n\t\t\t\tMAX_SHARED_LIBS * sizeof(unsigned long));\n\t\t\tret = result;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (flags & FLAT_FLAG_KTRACE)\n\t\tprintk(\"Mapping is %x, Entry point is %x, data_start is %x\\n\",\n\t\t\t(int)textpos, 0x00ffffff&ntohl(hdr->entry), ntohl(hdr->data_start));\n\n\t/* The main program needs a little extra setup in the task structure */\n\tstart_code = textpos + sizeof (struct flat_hdr);\n\tend_code = textpos + text_len;\n\tif (id == 0) {\n\t\tcurrent->mm->start_code = start_code;\n\t\tcurrent->mm->end_code = end_code;\n\t\tcurrent->mm->start_data = datapos;\n\t\tcurrent->mm->end_data = datapos + data_len;\n\t\t/*\n\t\t * set up the brk stuff, uses any slack left in data/bss/stack\n\t\t * allocation.  We put the brk after the bss (between the bss\n\t\t * and stack) like other platforms.\n\t\t * Userspace code relies on the stack pointer starting out at\n\t\t * an address right at the end of a page.\n\t\t */\n\t\tcurrent->mm->start_brk = datapos + data_len + bss_len;\n\t\tcurrent->mm->brk = (current->mm->start_brk + 3) & ~3;\n\t\tcurrent->mm->context.end_brk = memp + memp_size - stack_len;\n\t}\n\n\tif (flags & FLAT_FLAG_KTRACE)\n\t\tprintk(\"%s %s: TEXT=%x-%x DATA=%x-%x BSS=%x-%x\\n\",\n\t\t\tid ? \"Lib\" : \"Load\", bprm->filename,\n\t\t\t(int) start_code, (int) end_code,\n\t\t\t(int) datapos,\n\t\t\t(int) (datapos + data_len),\n\t\t\t(int) (datapos + data_len),\n\t\t\t(int) (((datapos + data_len + bss_len) + 3) & ~3));\n\n\ttext_len -= sizeof(struct flat_hdr); /* the real code len */\n\n\t/* Store the current module values into the global library structure */\n\tlibinfo->lib_list[id].start_code = start_code;\n\tlibinfo->lib_list[id].start_data = datapos;\n\tlibinfo->lib_list[id].start_brk = datapos + data_len + bss_len;\n\tlibinfo->lib_list[id].text_len = text_len;\n\tlibinfo->lib_list[id].loaded = 1;\n\tlibinfo->lib_list[id].entry = (0x00ffffff & ntohl(hdr->entry)) + textpos;\n\tlibinfo->lib_list[id].build_date = ntohl(hdr->build_date);\n\t\n\t/*\n\t * We just load the allocations into some temporary memory to\n\t * help simplify all this mumbo jumbo\n\t *\n\t * We've got two different sections of relocation entries.\n\t * The first is the GOT which resides at the beginning of the data segment\n\t * and is terminated with a -1.  This one can be relocated in place.\n\t * The second is the extra relocation entries tacked after the image's\n\t * data segment. These require a little more processing as the entry is\n\t * really an offset into the image which contains an offset into the\n\t * image.\n\t */\n\tif (flags & FLAT_FLAG_GOTPIC) {\n\t\tfor (rp = (unsigned long *)datapos; *rp != 0xffffffff; rp++) {\n\t\t\tunsigned long addr;\n\t\t\tif (*rp) {\n\t\t\t\taddr = calc_reloc(*rp, libinfo, id, 0);\n\t\t\t\tif (addr == RELOC_FAILED) {\n\t\t\t\t\tret = -ENOEXEC;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\t*rp = addr;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Now run through the relocation entries.\n\t * We've got to be careful here as C++ produces relocatable zero\n\t * entries in the constructor and destructor tables which are then\n\t * tested for being not zero (which will always occur unless we're\n\t * based from address zero).  This causes an endless loop as __start\n\t * is at zero.  The solution used is to not relocate zero addresses.\n\t * This has the negative side effect of not allowing a global data\n\t * reference to be statically initialised to _stext (I've moved\n\t * __start to address 4 so that is okay).\n\t */\n\tif (rev > OLD_FLAT_VERSION) {\n\t\tunsigned long persistent = 0;\n\t\tfor (i=0; i < relocs; i++) {\n\t\t\tunsigned long addr, relval;\n\n\t\t\t/* Get the address of the pointer to be\n\t\t\t   relocated (of course, the address has to be\n\t\t\t   relocated first).  */\n\t\t\trelval = ntohl(reloc[i]);\n\t\t\tif (flat_set_persistent (relval, &persistent))\n\t\t\t\tcontinue;\n\t\t\taddr = flat_get_relocate_addr(relval);\n\t\t\trp = (unsigned long *) calc_reloc(addr, libinfo, id, 1);\n\t\t\tif (rp == (unsigned long *)RELOC_FAILED) {\n\t\t\t\tret = -ENOEXEC;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\t/* Get the pointer's value.  */\n\t\t\taddr = flat_get_addr_from_rp(rp, relval, flags,\n\t\t\t\t\t\t\t&persistent);\n\t\t\tif (addr != 0) {\n\t\t\t\t/*\n\t\t\t\t * Do the relocation.  PIC relocs in the data section are\n\t\t\t\t * already in target order\n\t\t\t\t */\n\t\t\t\tif ((flags & FLAT_FLAG_GOTPIC) == 0)\n\t\t\t\t\taddr = ntohl(addr);\n\t\t\t\taddr = calc_reloc(addr, libinfo, id, 0);\n\t\t\t\tif (addr == RELOC_FAILED) {\n\t\t\t\t\tret = -ENOEXEC;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\n\t\t\t\t/* Write back the relocated pointer.  */\n\t\t\t\tflat_put_addr_at_rp(rp, addr, relval);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i=0; i < relocs; i++)\n\t\t\told_reloc(ntohl(reloc[i]));\n\t}\n\t\n\tflush_icache_range(start_code, end_code);\n\n\t/* zero the BSS,  BRK and stack areas */\n\tmemset((void*)(datapos + data_len), 0, bss_len + \n\t\t\t(memp + memp_size - stack_len -\t\t/* end brk */\n\t\t\tlibinfo->lib_list[id].start_brk) +\t/* start brk */\n\t\t\tstack_len);\n\n\treturn 0;\nerr:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR_VALUE",
          "args": [
            "res"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_binprm",
          "args": [
            "&bprm"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_binprm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "1274-1315",
          "snippet": "int prepare_binprm(struct linux_binprm *bprm)\n{\n\tstruct inode *inode = file_inode(bprm->file);\n\tumode_t mode = inode->i_mode;\n\tint retval;\n\n\n\t/* clear any previous set[ug]id data from a previous binary */\n\tbprm->cred->euid = current_euid();\n\tbprm->cred->egid = current_egid();\n\n\tif (!(bprm->file->f_path.mnt->mnt_flags & MNT_NOSUID) &&\n\t    !task_no_new_privs(current) &&\n\t    kuid_has_mapping(bprm->cred->user_ns, inode->i_uid) &&\n\t    kgid_has_mapping(bprm->cred->user_ns, inode->i_gid)) {\n\t\t/* Set-uid? */\n\t\tif (mode & S_ISUID) {\n\t\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\t\tbprm->cred->euid = inode->i_uid;\n\t\t}\n\n\t\t/* Set-gid? */\n\t\t/*\n\t\t * If setgid is set but no group execute bit then this\n\t\t * is a candidate for mandatory locking, not a setgid\n\t\t * executable.\n\t\t */\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\t\tbprm->cred->egid = inode->i_gid;\n\t\t}\n\t}\n\n\t/* fill in binprm security blob */\n\tretval = security_bprm_set_creds(bprm);\n\tif (retval)\n\t\treturn retval;\n\tbprm->cred_prepared = 1;\n\n\tmemset(bprm->buf, 0, BINPRM_BUF_SIZE);\n\treturn kernel_read(bprm->file, 0, bprm->buf, BINPRM_BUF_SIZE);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint prepare_binprm(struct linux_binprm *bprm)\n{\n\tstruct inode *inode = file_inode(bprm->file);\n\tumode_t mode = inode->i_mode;\n\tint retval;\n\n\n\t/* clear any previous set[ug]id data from a previous binary */\n\tbprm->cred->euid = current_euid();\n\tbprm->cred->egid = current_egid();\n\n\tif (!(bprm->file->f_path.mnt->mnt_flags & MNT_NOSUID) &&\n\t    !task_no_new_privs(current) &&\n\t    kuid_has_mapping(bprm->cred->user_ns, inode->i_uid) &&\n\t    kgid_has_mapping(bprm->cred->user_ns, inode->i_gid)) {\n\t\t/* Set-uid? */\n\t\tif (mode & S_ISUID) {\n\t\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\t\tbprm->cred->euid = inode->i_uid;\n\t\t}\n\n\t\t/* Set-gid? */\n\t\t/*\n\t\t * If setgid is set but no group execute bit then this\n\t\t * is a candidate for mandatory locking, not a setgid\n\t\t * executable.\n\t\t */\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\t\tbprm->cred->egid = inode->i_gid;\n\t\t}\n\t}\n\n\t/* fill in binprm security blob */\n\tretval = security_bprm_set_creds(bprm);\n\tif (retval)\n\t\treturn retval;\n\tbprm->cred_prepared = 1;\n\n\tmemset(bprm->buf, 0, BINPRM_BUF_SIZE);\n\treturn kernel_read(bprm->file, 0, bprm->buf, BINPRM_BUF_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_exec_creds",
          "args": [],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bprm.file"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bprm.file"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open_exec",
          "args": [
            "bprm.filename"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "open_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "795-805",
          "snippet": "struct file *open_exec(const char *name)\n{\n\tstruct filename *filename = getname_kernel(name);\n\tstruct file *f = ERR_CAST(filename);\n\n\tif (!IS_ERR(filename)) {\n\t\tf = do_open_execat(AT_FDCWD, filename, 0);\n\t\tputname(filename);\n\t}\n\treturn f;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstruct file *open_exec(const char *name)\n{\n\tstruct filename *filename = getname_kernel(name);\n\tstruct file *f = ERR_CAST(filename);\n\n\tif (!IS_ERR(filename)) {\n\t\tf = do_open_execat(AT_FDCWD, filename, 0);\n\t\tputname(filename);\n\t}\n\treturn f;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"/lib/lib%d.so\"",
            "id"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&bprm",
            "0",
            "sizeof(bprm)"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/zlib.h>\n#include <asm/page.h>\n#include <asm/cacheflush.h>\n#include <asm/unaligned.h>\n#include <asm/uaccess.h>\n#include <asm/byteorder.h>\n#include <linux/syscalls.h>\n#include <linux/flat.h>\n#include <linux/init.h>\n#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/slab.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int load_flat_binary(struct linux_binprm *);\n\nstatic int load_flat_shared_library(int id, struct lib_info *libs)\n{\n\tstruct linux_binprm bprm;\n\tint res;\n\tchar buf[16];\n\n\tmemset(&bprm, 0, sizeof(bprm));\n\n\t/* Create the file name */\n\tsprintf(buf, \"/lib/lib%d.so\", id);\n\n\t/* Open the file up */\n\tbprm.filename = buf;\n\tbprm.file = open_exec(bprm.filename);\n\tres = PTR_ERR(bprm.file);\n\tif (IS_ERR(bprm.file))\n\t\treturn res;\n\n\tbprm.cred = prepare_exec_creds();\n\tres = -ENOMEM;\n\tif (!bprm.cred)\n\t\tgoto out;\n\n\t/* We don't really care about recalculating credentials at this point\n\t * as we're past the point of no return and are dealing with shared\n\t * libraries.\n\t */\n\tbprm.cred_prepared = 1;\n\n\tres = prepare_binprm(&bprm);\n\n\tif (!IS_ERR_VALUE(res))\n\t\tres = load_flat_file(&bprm, libs, id, NULL);\n\n\tabort_creds(bprm.cred);\n\nout:\n\tallow_write_access(bprm.file);\n\tfput(bprm.file);\n\n\treturn(res);\n}"
  },
  {
    "function_name": "load_flat_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_flat.c",
    "lines": "426-798",
    "snippet": "static int load_flat_file(struct linux_binprm * bprm,\n\t\tstruct lib_info *libinfo, int id, unsigned long *extra_stack)\n{\n\tstruct flat_hdr * hdr;\n\tunsigned long textpos = 0, datapos = 0, result;\n\tunsigned long realdatastart = 0;\n\tunsigned long text_len, data_len, bss_len, stack_len, flags;\n\tunsigned long full_data;\n\tunsigned long len, memp = 0;\n\tunsigned long memp_size, extra, rlim;\n\tunsigned long *reloc = 0, *rp;\n\tstruct inode *inode;\n\tint i, rev, relocs = 0;\n\tloff_t fpos;\n\tunsigned long start_code, end_code;\n\tint ret;\n\n\thdr = ((struct flat_hdr *) bprm->buf);\t\t/* exec-header */\n\tinode = file_inode(bprm->file);\n\n\ttext_len  = ntohl(hdr->data_start);\n\tdata_len  = ntohl(hdr->data_end) - ntohl(hdr->data_start);\n\tbss_len   = ntohl(hdr->bss_end) - ntohl(hdr->data_end);\n\tstack_len = ntohl(hdr->stack_size);\n\tif (extra_stack) {\n\t\tstack_len += *extra_stack;\n\t\t*extra_stack = stack_len;\n\t}\n\trelocs    = ntohl(hdr->reloc_count);\n\tflags     = ntohl(hdr->flags);\n\trev       = ntohl(hdr->rev);\n\tfull_data = data_len + relocs * sizeof(unsigned long);\n\n\tif (strncmp(hdr->magic, \"bFLT\", 4)) {\n\t\t/*\n\t\t * Previously, here was a printk to tell people\n\t\t *   \"BINFMT_FLAT: bad header magic\".\n\t\t * But for the kernel which also use ELF FD-PIC format, this\n\t\t * error message is confusing.\n\t\t * because a lot of people do not manage to produce good\n\t\t */\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n\n\tif (flags & FLAT_FLAG_KTRACE)\n\t\tprintk(\"BINFMT_FLAT: Loading file: %s\\n\", bprm->filename);\n\n\tif (rev != FLAT_VERSION && rev != OLD_FLAT_VERSION) {\n\t\tprintk(\"BINFMT_FLAT: bad flat file version 0x%x (supported \"\n\t\t\t\"0x%lx and 0x%lx)\\n\",\n\t\t\trev, FLAT_VERSION, OLD_FLAT_VERSION);\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n\t\n\t/* Don't allow old format executables to use shared libraries */\n\tif (rev == OLD_FLAT_VERSION && id != 0) {\n\t\tprintk(\"BINFMT_FLAT: shared libraries are not available before rev 0x%x\\n\",\n\t\t\t\t(int) FLAT_VERSION);\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n\n\t/*\n\t * fix up the flags for the older format,  there were all kinds\n\t * of endian hacks,  this only works for the simple cases\n\t */\n\tif (rev == OLD_FLAT_VERSION && flat_old_ram_flag(flags))\n\t\tflags = FLAT_FLAG_RAM;\n\n#ifndef CONFIG_BINFMT_ZFLAT\n\tif (flags & (FLAT_FLAG_GZIP|FLAT_FLAG_GZDATA)) {\n\t\tprintk(\"Support for ZFLAT executables is not enabled.\\n\");\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n#endif\n\n\t/*\n\t * Check initial limits. This avoids letting people circumvent\n\t * size limits imposed on them by creating programs with large\n\t * arrays in the data or bss.\n\t */\n\trlim = rlimit(RLIMIT_DATA);\n\tif (rlim >= RLIM_INFINITY)\n\t\trlim = ~0;\n\tif (data_len + bss_len > rlim) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t/* Flush all traces of the currently running executable */\n\tif (id == 0) {\n\t\tresult = flush_old_exec(bprm);\n\t\tif (result) {\n\t\t\tret = result;\n\t\t\tgoto err;\n\t\t}\n\n\t\t/* OK, This is the point of no return */\n\t\tset_personality(PER_LINUX_32BIT);\n\t\tsetup_new_exec(bprm);\n\t}\n\n\t/*\n\t * calculate the extra space we need to map in\n\t */\n\textra = max_t(unsigned long, bss_len + stack_len,\n\t\t\trelocs * sizeof(unsigned long));\n\n\t/*\n\t * there are a couple of cases here,  the separate code/data\n\t * case,  and then the fully copied to RAM case which lumps\n\t * it all together.\n\t */\n\tif ((flags & (FLAT_FLAG_RAM|FLAT_FLAG_GZIP)) == 0) {\n\t\t/*\n\t\t * this should give us a ROM ptr,  but if it doesn't we don't\n\t\t * really care\n\t\t */\n\t\tDBG_FLT(\"BINFMT_FLAT: ROM mapping of file (we hope)\\n\");\n\n\t\ttextpos = vm_mmap(bprm->file, 0, text_len, PROT_READ|PROT_EXEC,\n\t\t\t\t  MAP_PRIVATE|MAP_EXECUTABLE, 0);\n\t\tif (!textpos || IS_ERR_VALUE(textpos)) {\n\t\t\tif (!textpos)\n\t\t\t\ttextpos = (unsigned long) -ENOMEM;\n\t\t\tprintk(\"Unable to mmap process text, errno %d\\n\", (int)-textpos);\n\t\t\tret = textpos;\n\t\t\tgoto err;\n\t\t}\n\n\t\tlen = data_len + extra + MAX_SHARED_LIBS * sizeof(unsigned long);\n\t\tlen = PAGE_ALIGN(len);\n\t\trealdatastart = vm_mmap(0, 0, len,\n\t\t\tPROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE, 0);\n\n\t\tif (realdatastart == 0 || IS_ERR_VALUE(realdatastart)) {\n\t\t\tif (!realdatastart)\n\t\t\t\trealdatastart = (unsigned long) -ENOMEM;\n\t\t\tprintk(\"Unable to allocate RAM for process data, errno %d\\n\",\n\t\t\t\t\t(int)-realdatastart);\n\t\t\tvm_munmap(textpos, text_len);\n\t\t\tret = realdatastart;\n\t\t\tgoto err;\n\t\t}\n\t\tdatapos = ALIGN(realdatastart +\n\t\t\t\tMAX_SHARED_LIBS * sizeof(unsigned long),\n\t\t\t\tFLAT_DATA_ALIGN);\n\n\t\tDBG_FLT(\"BINFMT_FLAT: Allocated data+bss+stack (%d bytes): %x\\n\",\n\t\t\t\t(int)(data_len + bss_len + stack_len), (int)datapos);\n\n\t\tfpos = ntohl(hdr->data_start);\n#ifdef CONFIG_BINFMT_ZFLAT\n\t\tif (flags & FLAT_FLAG_GZDATA) {\n\t\t\tresult = decompress_exec(bprm, fpos, (char *) datapos, \n\t\t\t\t\t\t full_data, 0);\n\t\t} else\n#endif\n\t\t{\n\t\t\tresult = read_code(bprm->file, datapos, fpos,\n\t\t\t\t\tfull_data);\n\t\t}\n\t\tif (IS_ERR_VALUE(result)) {\n\t\t\tprintk(\"Unable to read data+bss, errno %d\\n\", (int)-result);\n\t\t\tvm_munmap(textpos, text_len);\n\t\t\tvm_munmap(realdatastart, len);\n\t\t\tret = result;\n\t\t\tgoto err;\n\t\t}\n\n\t\treloc = (unsigned long *) (datapos+(ntohl(hdr->reloc_start)-text_len));\n\t\tmemp = realdatastart;\n\t\tmemp_size = len;\n\t} else {\n\n\t\tlen = text_len + data_len + extra + MAX_SHARED_LIBS * sizeof(unsigned long);\n\t\tlen = PAGE_ALIGN(len);\n\t\ttextpos = vm_mmap(0, 0, len,\n\t\t\tPROT_READ | PROT_EXEC | PROT_WRITE, MAP_PRIVATE, 0);\n\n\t\tif (!textpos || IS_ERR_VALUE(textpos)) {\n\t\t\tif (!textpos)\n\t\t\t\ttextpos = (unsigned long) -ENOMEM;\n\t\t\tprintk(\"Unable to allocate RAM for process text/data, errno %d\\n\",\n\t\t\t\t\t(int)-textpos);\n\t\t\tret = textpos;\n\t\t\tgoto err;\n\t\t}\n\n\t\trealdatastart = textpos + ntohl(hdr->data_start);\n\t\tdatapos = ALIGN(realdatastart +\n\t\t\t\tMAX_SHARED_LIBS * sizeof(unsigned long),\n\t\t\t\tFLAT_DATA_ALIGN);\n\n\t\treloc = (unsigned long *)\n\t\t\t(datapos + (ntohl(hdr->reloc_start) - text_len));\n\t\tmemp = textpos;\n\t\tmemp_size = len;\n#ifdef CONFIG_BINFMT_ZFLAT\n\t\t/*\n\t\t * load it all in and treat it like a RAM load from now on\n\t\t */\n\t\tif (flags & FLAT_FLAG_GZIP) {\n\t\t\tresult = decompress_exec(bprm, sizeof (struct flat_hdr),\n\t\t\t\t\t (((char *) textpos) + sizeof (struct flat_hdr)),\n\t\t\t\t\t (text_len + full_data\n\t\t\t\t\t\t  - sizeof (struct flat_hdr)),\n\t\t\t\t\t 0);\n\t\t\tmemmove((void *) datapos, (void *) realdatastart,\n\t\t\t\t\tfull_data);\n\t\t} else if (flags & FLAT_FLAG_GZDATA) {\n\t\t\tresult = read_code(bprm->file, textpos, 0, text_len);\n\t\t\tif (!IS_ERR_VALUE(result))\n\t\t\t\tresult = decompress_exec(bprm, text_len, (char *) datapos,\n\t\t\t\t\t\t full_data, 0);\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t\tresult = read_code(bprm->file, textpos, 0, text_len);\n\t\t\tif (!IS_ERR_VALUE(result))\n\t\t\t\tresult = read_code(bprm->file, datapos,\n\t\t\t\t\t\t   ntohl(hdr->data_start),\n\t\t\t\t\t\t   full_data);\n\t\t}\n\t\tif (IS_ERR_VALUE(result)) {\n\t\t\tprintk(\"Unable to read code+data+bss, errno %d\\n\",(int)-result);\n\t\t\tvm_munmap(textpos, text_len + data_len + extra +\n\t\t\t\tMAX_SHARED_LIBS * sizeof(unsigned long));\n\t\t\tret = result;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (flags & FLAT_FLAG_KTRACE)\n\t\tprintk(\"Mapping is %x, Entry point is %x, data_start is %x\\n\",\n\t\t\t(int)textpos, 0x00ffffff&ntohl(hdr->entry), ntohl(hdr->data_start));\n\n\t/* The main program needs a little extra setup in the task structure */\n\tstart_code = textpos + sizeof (struct flat_hdr);\n\tend_code = textpos + text_len;\n\tif (id == 0) {\n\t\tcurrent->mm->start_code = start_code;\n\t\tcurrent->mm->end_code = end_code;\n\t\tcurrent->mm->start_data = datapos;\n\t\tcurrent->mm->end_data = datapos + data_len;\n\t\t/*\n\t\t * set up the brk stuff, uses any slack left in data/bss/stack\n\t\t * allocation.  We put the brk after the bss (between the bss\n\t\t * and stack) like other platforms.\n\t\t * Userspace code relies on the stack pointer starting out at\n\t\t * an address right at the end of a page.\n\t\t */\n\t\tcurrent->mm->start_brk = datapos + data_len + bss_len;\n\t\tcurrent->mm->brk = (current->mm->start_brk + 3) & ~3;\n\t\tcurrent->mm->context.end_brk = memp + memp_size - stack_len;\n\t}\n\n\tif (flags & FLAT_FLAG_KTRACE)\n\t\tprintk(\"%s %s: TEXT=%x-%x DATA=%x-%x BSS=%x-%x\\n\",\n\t\t\tid ? \"Lib\" : \"Load\", bprm->filename,\n\t\t\t(int) start_code, (int) end_code,\n\t\t\t(int) datapos,\n\t\t\t(int) (datapos + data_len),\n\t\t\t(int) (datapos + data_len),\n\t\t\t(int) (((datapos + data_len + bss_len) + 3) & ~3));\n\n\ttext_len -= sizeof(struct flat_hdr); /* the real code len */\n\n\t/* Store the current module values into the global library structure */\n\tlibinfo->lib_list[id].start_code = start_code;\n\tlibinfo->lib_list[id].start_data = datapos;\n\tlibinfo->lib_list[id].start_brk = datapos + data_len + bss_len;\n\tlibinfo->lib_list[id].text_len = text_len;\n\tlibinfo->lib_list[id].loaded = 1;\n\tlibinfo->lib_list[id].entry = (0x00ffffff & ntohl(hdr->entry)) + textpos;\n\tlibinfo->lib_list[id].build_date = ntohl(hdr->build_date);\n\t\n\t/*\n\t * We just load the allocations into some temporary memory to\n\t * help simplify all this mumbo jumbo\n\t *\n\t * We've got two different sections of relocation entries.\n\t * The first is the GOT which resides at the beginning of the data segment\n\t * and is terminated with a -1.  This one can be relocated in place.\n\t * The second is the extra relocation entries tacked after the image's\n\t * data segment. These require a little more processing as the entry is\n\t * really an offset into the image which contains an offset into the\n\t * image.\n\t */\n\tif (flags & FLAT_FLAG_GOTPIC) {\n\t\tfor (rp = (unsigned long *)datapos; *rp != 0xffffffff; rp++) {\n\t\t\tunsigned long addr;\n\t\t\tif (*rp) {\n\t\t\t\taddr = calc_reloc(*rp, libinfo, id, 0);\n\t\t\t\tif (addr == RELOC_FAILED) {\n\t\t\t\t\tret = -ENOEXEC;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\t*rp = addr;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Now run through the relocation entries.\n\t * We've got to be careful here as C++ produces relocatable zero\n\t * entries in the constructor and destructor tables which are then\n\t * tested for being not zero (which will always occur unless we're\n\t * based from address zero).  This causes an endless loop as __start\n\t * is at zero.  The solution used is to not relocate zero addresses.\n\t * This has the negative side effect of not allowing a global data\n\t * reference to be statically initialised to _stext (I've moved\n\t * __start to address 4 so that is okay).\n\t */\n\tif (rev > OLD_FLAT_VERSION) {\n\t\tunsigned long persistent = 0;\n\t\tfor (i=0; i < relocs; i++) {\n\t\t\tunsigned long addr, relval;\n\n\t\t\t/* Get the address of the pointer to be\n\t\t\t   relocated (of course, the address has to be\n\t\t\t   relocated first).  */\n\t\t\trelval = ntohl(reloc[i]);\n\t\t\tif (flat_set_persistent (relval, &persistent))\n\t\t\t\tcontinue;\n\t\t\taddr = flat_get_relocate_addr(relval);\n\t\t\trp = (unsigned long *) calc_reloc(addr, libinfo, id, 1);\n\t\t\tif (rp == (unsigned long *)RELOC_FAILED) {\n\t\t\t\tret = -ENOEXEC;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\t/* Get the pointer's value.  */\n\t\t\taddr = flat_get_addr_from_rp(rp, relval, flags,\n\t\t\t\t\t\t\t&persistent);\n\t\t\tif (addr != 0) {\n\t\t\t\t/*\n\t\t\t\t * Do the relocation.  PIC relocs in the data section are\n\t\t\t\t * already in target order\n\t\t\t\t */\n\t\t\t\tif ((flags & FLAT_FLAG_GOTPIC) == 0)\n\t\t\t\t\taddr = ntohl(addr);\n\t\t\t\taddr = calc_reloc(addr, libinfo, id, 0);\n\t\t\t\tif (addr == RELOC_FAILED) {\n\t\t\t\t\tret = -ENOEXEC;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\n\t\t\t\t/* Write back the relocated pointer.  */\n\t\t\t\tflat_put_addr_at_rp(rp, addr, relval);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i=0; i < relocs; i++)\n\t\t\told_reloc(ntohl(reloc[i]));\n\t}\n\t\n\tflush_icache_range(start_code, end_code);\n\n\t/* zero the BSS,  BRK and stack areas */\n\tmemset((void*)(datapos + data_len), 0, bss_len + \n\t\t\t(memp + memp_size - stack_len -\t\t/* end brk */\n\t\t\tlibinfo->lib_list[id].start_brk) +\t/* start brk */\n\t\t\tstack_len);\n\n\treturn 0;\nerr:\n\treturn ret;\n}",
    "includes": [
      "#include <linux/zlib.h>",
      "#include <asm/page.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/unaligned.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/flat.h>",
      "#include <linux/init.h>",
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/slab.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [
      "#define RELOC_FAILED 0xff00ff01\t\t/* Relocation incorrect somewhere */",
      "#define FLAT_DATA_ALIGN\t(0x20)"
    ],
    "globals_used": [
      "static int load_flat_binary(struct linux_binprm *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(void*)(datapos + data_len)",
            "0",
            "bss_len + \n\t\t\t(memp + memp_size - stack_len -\t\t/* end brk */\n\t\t\tlibinfo->lib_list[id].start_brk) +\t/* start brk */\n\t\t\tstack_len"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_icache_range",
          "args": [
            "start_code",
            "end_code"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "old_reloc",
          "args": [
            "ntohl(reloc[i])"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "old_reloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_flat.c",
          "lines": "383-422",
          "snippet": "static void old_reloc(unsigned long rl)\n{\n#ifdef DEBUG\n\tchar *segment[] = { \"TEXT\", \"DATA\", \"BSS\", \"*UNKNOWN*\" };\n#endif\n\tflat_v2_reloc_t\tr;\n\tunsigned long *ptr;\n\t\n\tr.value = rl;\n#if defined(CONFIG_COLDFIRE)\n\tptr = (unsigned long *) (current->mm->start_code + r.reloc.offset);\n#else\n\tptr = (unsigned long *) (current->mm->start_data + r.reloc.offset);\n#endif\n\n#ifdef DEBUG\n\tprintk(\"Relocation of variable at DATASEG+%x \"\n\t\t\"(address %p, currently %x) into segment %s\\n\",\n\t\tr.reloc.offset, ptr, (int)*ptr, segment[r.reloc.type]);\n#endif\n\t\n\tswitch (r.reloc.type) {\n\tcase OLD_FLAT_RELOC_TYPE_TEXT:\n\t\t*ptr += current->mm->start_code;\n\t\tbreak;\n\tcase OLD_FLAT_RELOC_TYPE_DATA:\n\t\t*ptr += current->mm->start_data;\n\t\tbreak;\n\tcase OLD_FLAT_RELOC_TYPE_BSS:\n\t\t*ptr += current->mm->end_data;\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"BINFMT_FLAT: Unknown relocation type=%x\\n\", r.reloc.type);\n\t\tbreak;\n\t}\n\n#ifdef DEBUG\n\tprintk(\"Relocation became %x\\n\", (int)*ptr);\n#endif\n}",
          "includes": [
            "#include <linux/zlib.h>",
            "#include <asm/page.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/flat.h>",
            "#include <linux/init.h>",
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/slab.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define DEBUG 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zlib.h>\n#include <asm/page.h>\n#include <asm/cacheflush.h>\n#include <asm/unaligned.h>\n#include <asm/uaccess.h>\n#include <asm/byteorder.h>\n#include <linux/syscalls.h>\n#include <linux/flat.h>\n#include <linux/init.h>\n#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/slab.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\n#define DEBUG 1\n\nstatic void old_reloc(unsigned long rl)\n{\n#ifdef DEBUG\n\tchar *segment[] = { \"TEXT\", \"DATA\", \"BSS\", \"*UNKNOWN*\" };\n#endif\n\tflat_v2_reloc_t\tr;\n\tunsigned long *ptr;\n\t\n\tr.value = rl;\n#if defined(CONFIG_COLDFIRE)\n\tptr = (unsigned long *) (current->mm->start_code + r.reloc.offset);\n#else\n\tptr = (unsigned long *) (current->mm->start_data + r.reloc.offset);\n#endif\n\n#ifdef DEBUG\n\tprintk(\"Relocation of variable at DATASEG+%x \"\n\t\t\"(address %p, currently %x) into segment %s\\n\",\n\t\tr.reloc.offset, ptr, (int)*ptr, segment[r.reloc.type]);\n#endif\n\t\n\tswitch (r.reloc.type) {\n\tcase OLD_FLAT_RELOC_TYPE_TEXT:\n\t\t*ptr += current->mm->start_code;\n\t\tbreak;\n\tcase OLD_FLAT_RELOC_TYPE_DATA:\n\t\t*ptr += current->mm->start_data;\n\t\tbreak;\n\tcase OLD_FLAT_RELOC_TYPE_BSS:\n\t\t*ptr += current->mm->end_data;\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"BINFMT_FLAT: Unknown relocation type=%x\\n\", r.reloc.type);\n\t\tbreak;\n\t}\n\n#ifdef DEBUG\n\tprintk(\"Relocation became %x\\n\", (int)*ptr);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "reloc[i]"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flat_put_addr_at_rp",
          "args": [
            "rp",
            "addr",
            "relval"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calc_reloc",
          "args": [
            "addr",
            "libinfo",
            "id",
            "0"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "calc_reloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_flat.c",
          "lines": "312-379",
          "snippet": "static unsigned long\ncalc_reloc(unsigned long r, struct lib_info *p, int curid, int internalp)\n{\n\tunsigned long addr;\n\tint id;\n\tunsigned long start_brk;\n\tunsigned long start_data;\n\tunsigned long text_len;\n\tunsigned long start_code;\n\n#ifdef CONFIG_BINFMT_SHARED_FLAT\n\tif (r == 0)\n\t\tid = curid;\t/* Relocs of 0 are always self referring */\n\telse {\n\t\tid = (r >> 24) & 0xff;\t/* Find ID for this reloc */\n\t\tr &= 0x00ffffff;\t/* Trim ID off here */\n\t}\n\tif (id >= MAX_SHARED_LIBS) {\n\t\tprintk(\"BINFMT_FLAT: reference 0x%x to shared library %d\",\n\t\t\t\t(unsigned) r, id);\n\t\tgoto failed;\n\t}\n\tif (curid != id) {\n\t\tif (internalp) {\n\t\t\tprintk(\"BINFMT_FLAT: reloc address 0x%x not in same module \"\n\t\t\t\t\t\"(%d != %d)\", (unsigned) r, curid, id);\n\t\t\tgoto failed;\n\t\t} else if ( ! p->lib_list[id].loaded &&\n\t\t\t\tIS_ERR_VALUE(load_flat_shared_library(id, p))) {\n\t\t\tprintk(\"BINFMT_FLAT: failed to load library %d\", id);\n\t\t\tgoto failed;\n\t\t}\n\t\t/* Check versioning information (i.e. time stamps) */\n\t\tif (p->lib_list[id].build_date && p->lib_list[curid].build_date &&\n\t\t\t\tp->lib_list[curid].build_date < p->lib_list[id].build_date) {\n\t\t\tprintk(\"BINFMT_FLAT: library %d is younger than %d\", id, curid);\n\t\t\tgoto failed;\n\t\t}\n\t}\n#else\n\tid = 0;\n#endif\n\n\tstart_brk = p->lib_list[id].start_brk;\n\tstart_data = p->lib_list[id].start_data;\n\tstart_code = p->lib_list[id].start_code;\n\ttext_len = p->lib_list[id].text_len;\n\n\tif (!flat_reloc_valid(r, start_brk - start_data + text_len)) {\n\t\tprintk(\"BINFMT_FLAT: reloc outside program 0x%x (0 - 0x%x/0x%x)\",\n\t\t       (int) r,(int)(start_brk-start_data+text_len),(int)text_len);\n\t\tgoto failed;\n\t}\n\n\tif (r < text_len)\t\t\t/* In text segment */\n\t\taddr = r + start_code;\n\telse\t\t\t\t\t/* In data segment */\n\t\taddr = r - text_len + start_data;\n\n\t/* Range checked already above so doing the range tests is redundant...*/\n\treturn(addr);\n\nfailed:\n\tprintk(\", killing %s!\\n\", current->comm);\n\tsend_sig(SIGSEGV, current, 0);\n\n\treturn RELOC_FAILED;\n}",
          "includes": [
            "#include <linux/zlib.h>",
            "#include <asm/page.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/flat.h>",
            "#include <linux/init.h>",
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/slab.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define RELOC_FAILED 0xff00ff01\t\t/* Relocation incorrect somewhere */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zlib.h>\n#include <asm/page.h>\n#include <asm/cacheflush.h>\n#include <asm/unaligned.h>\n#include <asm/uaccess.h>\n#include <asm/byteorder.h>\n#include <linux/syscalls.h>\n#include <linux/flat.h>\n#include <linux/init.h>\n#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/slab.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\n#define RELOC_FAILED 0xff00ff01\t\t/* Relocation incorrect somewhere */\n\nstatic unsigned long\ncalc_reloc(unsigned long r, struct lib_info *p, int curid, int internalp)\n{\n\tunsigned long addr;\n\tint id;\n\tunsigned long start_brk;\n\tunsigned long start_data;\n\tunsigned long text_len;\n\tunsigned long start_code;\n\n#ifdef CONFIG_BINFMT_SHARED_FLAT\n\tif (r == 0)\n\t\tid = curid;\t/* Relocs of 0 are always self referring */\n\telse {\n\t\tid = (r >> 24) & 0xff;\t/* Find ID for this reloc */\n\t\tr &= 0x00ffffff;\t/* Trim ID off here */\n\t}\n\tif (id >= MAX_SHARED_LIBS) {\n\t\tprintk(\"BINFMT_FLAT: reference 0x%x to shared library %d\",\n\t\t\t\t(unsigned) r, id);\n\t\tgoto failed;\n\t}\n\tif (curid != id) {\n\t\tif (internalp) {\n\t\t\tprintk(\"BINFMT_FLAT: reloc address 0x%x not in same module \"\n\t\t\t\t\t\"(%d != %d)\", (unsigned) r, curid, id);\n\t\t\tgoto failed;\n\t\t} else if ( ! p->lib_list[id].loaded &&\n\t\t\t\tIS_ERR_VALUE(load_flat_shared_library(id, p))) {\n\t\t\tprintk(\"BINFMT_FLAT: failed to load library %d\", id);\n\t\t\tgoto failed;\n\t\t}\n\t\t/* Check versioning information (i.e. time stamps) */\n\t\tif (p->lib_list[id].build_date && p->lib_list[curid].build_date &&\n\t\t\t\tp->lib_list[curid].build_date < p->lib_list[id].build_date) {\n\t\t\tprintk(\"BINFMT_FLAT: library %d is younger than %d\", id, curid);\n\t\t\tgoto failed;\n\t\t}\n\t}\n#else\n\tid = 0;\n#endif\n\n\tstart_brk = p->lib_list[id].start_brk;\n\tstart_data = p->lib_list[id].start_data;\n\tstart_code = p->lib_list[id].start_code;\n\ttext_len = p->lib_list[id].text_len;\n\n\tif (!flat_reloc_valid(r, start_brk - start_data + text_len)) {\n\t\tprintk(\"BINFMT_FLAT: reloc outside program 0x%x (0 - 0x%x/0x%x)\",\n\t\t       (int) r,(int)(start_brk-start_data+text_len),(int)text_len);\n\t\tgoto failed;\n\t}\n\n\tif (r < text_len)\t\t\t/* In text segment */\n\t\taddr = r + start_code;\n\telse\t\t\t\t\t/* In data segment */\n\t\taddr = r - text_len + start_data;\n\n\t/* Range checked already above so doing the range tests is redundant...*/\n\treturn(addr);\n\nfailed:\n\tprintk(\", killing %s!\\n\", current->comm);\n\tsend_sig(SIGSEGV, current, 0);\n\n\treturn RELOC_FAILED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "addr"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flat_get_addr_from_rp",
          "args": [
            "rp",
            "relval",
            "flags",
            "&persistent"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flat_get_relocate_addr",
          "args": [
            "relval"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flat_set_persistent",
          "args": [
            "relval",
            "&persistent"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "reloc[i]"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "hdr->build_date"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "hdr->entry"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%s %s: TEXT=%x-%x DATA=%x-%x BSS=%x-%x\\n\"",
            "id ? \"Lib\" : \"Load\"",
            "bprm->filename",
            "(int) start_code",
            "(int) end_code",
            "(int) datapos",
            "(int) (datapos + data_len)",
            "(int) (datapos + data_len)",
            "(int) (((datapos + data_len + bss_len) + 3) & ~3)"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "hdr->data_start"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "hdr->entry"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_munmap",
          "args": [
            "textpos",
            "text_len + data_len + extra +\n\t\t\t\tMAX_SHARED_LIBS * sizeof(unsigned long)"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR_VALUE",
          "args": [
            "result"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_code",
          "args": [
            "bprm->file",
            "datapos",
            "ntohl(hdr->data_start)",
            "full_data"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "read_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "825-831",
          "snippet": "ssize_t read_code(struct file *file, unsigned long addr, loff_t pos, size_t len)\n{\n\tssize_t res = vfs_read(file, (void __user *)addr, len, &pos);\n\tif (res > 0)\n\t\tflush_icache_range(addr, addr + len);\n\treturn res;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nssize_t read_code(struct file *file, unsigned long addr, loff_t pos, size_t len)\n{\n\tssize_t res = vfs_read(file, (void __user *)addr, len, &pos);\n\tif (res > 0)\n\t\tflush_icache_range(addr, addr + len);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "hdr->data_start"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR_VALUE",
          "args": [
            "result"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decompress_exec",
          "args": [
            "bprm",
            "text_len",
            "(char *) datapos",
            "full_data",
            "0"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "decompress_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_flat.c",
          "lines": "181-306",
          "snippet": "static int decompress_exec(\n\tstruct linux_binprm *bprm,\n\tunsigned long offset,\n\tchar *dst,\n\tlong len,\n\tint fd)\n{\n\tunsigned char *buf;\n\tz_stream strm;\n\tloff_t fpos;\n\tint ret, retval;\n\n\tDBG_FLT(\"decompress_exec(offset=%x,buf=%x,len=%x)\\n\",(int)offset, (int)dst, (int)len);\n\n\tmemset(&strm, 0, sizeof(strm));\n\tstrm.workspace = kmalloc(zlib_inflate_workspacesize(), GFP_KERNEL);\n\tif (strm.workspace == NULL) {\n\t\tDBG_FLT(\"binfmt_flat: no memory for decompress workspace\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tbuf = kmalloc(LBUFSIZE, GFP_KERNEL);\n\tif (buf == NULL) {\n\t\tDBG_FLT(\"binfmt_flat: no memory for read buffer\\n\");\n\t\tretval = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\t/* Read in first chunk of data and parse gzip header. */\n\tfpos = offset;\n\tret = kernel_read(bprm->file, offset, buf, LBUFSIZE);\n\n\tstrm.next_in = buf;\n\tstrm.avail_in = ret;\n\tstrm.total_in = 0;\n\tfpos += ret;\n\n\tretval = -ENOEXEC;\n\n\t/* Check minimum size -- gzip header */\n\tif (ret < 10) {\n\t\tDBG_FLT(\"binfmt_flat: file too small?\\n\");\n\t\tgoto out_free_buf;\n\t}\n\n\t/* Check gzip magic number */\n\tif ((buf[0] != 037) || ((buf[1] != 0213) && (buf[1] != 0236))) {\n\t\tDBG_FLT(\"binfmt_flat: unknown compression magic?\\n\");\n\t\tgoto out_free_buf;\n\t}\n\n\t/* Check gzip method */\n\tif (buf[2] != 8) {\n\t\tDBG_FLT(\"binfmt_flat: unknown compression method?\\n\");\n\t\tgoto out_free_buf;\n\t}\n\t/* Check gzip flags */\n\tif ((buf[3] & ENCRYPTED) || (buf[3] & CONTINUATION) ||\n\t    (buf[3] & RESERVED)) {\n\t\tDBG_FLT(\"binfmt_flat: unknown flags?\\n\");\n\t\tgoto out_free_buf;\n\t}\n\n\tret = 10;\n\tif (buf[3] & EXTRA_FIELD) {\n\t\tret += 2 + buf[10] + (buf[11] << 8);\n\t\tif (unlikely(LBUFSIZE <= ret)) {\n\t\t\tDBG_FLT(\"binfmt_flat: buffer overflow (EXTRA)?\\n\");\n\t\t\tgoto out_free_buf;\n\t\t}\n\t}\n\tif (buf[3] & ORIG_NAME) {\n\t\twhile (ret < LBUFSIZE && buf[ret++] != 0)\n\t\t\t;\n\t\tif (unlikely(LBUFSIZE == ret)) {\n\t\t\tDBG_FLT(\"binfmt_flat: buffer overflow (ORIG_NAME)?\\n\");\n\t\t\tgoto out_free_buf;\n\t\t}\n\t}\n\tif (buf[3] & COMMENT) {\n\t\twhile (ret < LBUFSIZE && buf[ret++] != 0)\n\t\t\t;\n\t\tif (unlikely(LBUFSIZE == ret)) {\n\t\t\tDBG_FLT(\"binfmt_flat: buffer overflow (COMMENT)?\\n\");\n\t\t\tgoto out_free_buf;\n\t\t}\n\t}\n\n\tstrm.next_in += ret;\n\tstrm.avail_in -= ret;\n\n\tstrm.next_out = dst;\n\tstrm.avail_out = len;\n\tstrm.total_out = 0;\n\n\tif (zlib_inflateInit2(&strm, -MAX_WBITS) != Z_OK) {\n\t\tDBG_FLT(\"binfmt_flat: zlib init failed?\\n\");\n\t\tgoto out_free_buf;\n\t}\n\n\twhile ((ret = zlib_inflate(&strm, Z_NO_FLUSH)) == Z_OK) {\n\t\tret = kernel_read(bprm->file, fpos, buf, LBUFSIZE);\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\t\tlen -= ret;\n\n\t\tstrm.next_in = buf;\n\t\tstrm.avail_in = ret;\n\t\tstrm.total_in = 0;\n\t\tfpos += ret;\n\t}\n\n\tif (ret < 0) {\n\t\tDBG_FLT(\"binfmt_flat: decompression failed (%d), %s\\n\",\n\t\t\tret, strm.msg);\n\t\tgoto out_zlib;\n\t}\n\n\tretval = 0;\nout_zlib:\n\tzlib_inflateEnd(&strm);\nout_free_buf:\n\tkfree(buf);\nout_free:\n\tkfree(strm.workspace);\n\treturn retval;\n}",
          "includes": [
            "#include <linux/zlib.h>",
            "#include <asm/page.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/flat.h>",
            "#include <linux/init.h>",
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/slab.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define RESERVED     0xC0 /* bit 6,7:   reserved */",
            "#define ENCRYPTED    0x20 /* bit 5 set: file is encrypted */",
            "#define COMMENT      0x10 /* bit 4 set: file comment present */",
            "#define ORIG_NAME    0x08 /* bit 3 set: original file name present */",
            "#define EXTRA_FIELD  0x04 /* bit 2 set: extra field present */",
            "#define CONTINUATION 0x02 /* bit 1 set: continuation of multi-part gzip file */",
            "#define LBUFSIZE\t4000"
          ],
          "globals_used": [
            "static int load_flat_binary(struct linux_binprm *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zlib.h>\n#include <asm/page.h>\n#include <asm/cacheflush.h>\n#include <asm/unaligned.h>\n#include <asm/uaccess.h>\n#include <asm/byteorder.h>\n#include <linux/syscalls.h>\n#include <linux/flat.h>\n#include <linux/init.h>\n#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/slab.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\n#define RESERVED     0xC0 /* bit 6,7:   reserved */\n#define ENCRYPTED    0x20 /* bit 5 set: file is encrypted */\n#define COMMENT      0x10 /* bit 4 set: file comment present */\n#define ORIG_NAME    0x08 /* bit 3 set: original file name present */\n#define EXTRA_FIELD  0x04 /* bit 2 set: extra field present */\n#define CONTINUATION 0x02 /* bit 1 set: continuation of multi-part gzip file */\n#define LBUFSIZE\t4000\n\nstatic int load_flat_binary(struct linux_binprm *);\n\nstatic int decompress_exec(\n\tstruct linux_binprm *bprm,\n\tunsigned long offset,\n\tchar *dst,\n\tlong len,\n\tint fd)\n{\n\tunsigned char *buf;\n\tz_stream strm;\n\tloff_t fpos;\n\tint ret, retval;\n\n\tDBG_FLT(\"decompress_exec(offset=%x,buf=%x,len=%x)\\n\",(int)offset, (int)dst, (int)len);\n\n\tmemset(&strm, 0, sizeof(strm));\n\tstrm.workspace = kmalloc(zlib_inflate_workspacesize(), GFP_KERNEL);\n\tif (strm.workspace == NULL) {\n\t\tDBG_FLT(\"binfmt_flat: no memory for decompress workspace\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tbuf = kmalloc(LBUFSIZE, GFP_KERNEL);\n\tif (buf == NULL) {\n\t\tDBG_FLT(\"binfmt_flat: no memory for read buffer\\n\");\n\t\tretval = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\t/* Read in first chunk of data and parse gzip header. */\n\tfpos = offset;\n\tret = kernel_read(bprm->file, offset, buf, LBUFSIZE);\n\n\tstrm.next_in = buf;\n\tstrm.avail_in = ret;\n\tstrm.total_in = 0;\n\tfpos += ret;\n\n\tretval = -ENOEXEC;\n\n\t/* Check minimum size -- gzip header */\n\tif (ret < 10) {\n\t\tDBG_FLT(\"binfmt_flat: file too small?\\n\");\n\t\tgoto out_free_buf;\n\t}\n\n\t/* Check gzip magic number */\n\tif ((buf[0] != 037) || ((buf[1] != 0213) && (buf[1] != 0236))) {\n\t\tDBG_FLT(\"binfmt_flat: unknown compression magic?\\n\");\n\t\tgoto out_free_buf;\n\t}\n\n\t/* Check gzip method */\n\tif (buf[2] != 8) {\n\t\tDBG_FLT(\"binfmt_flat: unknown compression method?\\n\");\n\t\tgoto out_free_buf;\n\t}\n\t/* Check gzip flags */\n\tif ((buf[3] & ENCRYPTED) || (buf[3] & CONTINUATION) ||\n\t    (buf[3] & RESERVED)) {\n\t\tDBG_FLT(\"binfmt_flat: unknown flags?\\n\");\n\t\tgoto out_free_buf;\n\t}\n\n\tret = 10;\n\tif (buf[3] & EXTRA_FIELD) {\n\t\tret += 2 + buf[10] + (buf[11] << 8);\n\t\tif (unlikely(LBUFSIZE <= ret)) {\n\t\t\tDBG_FLT(\"binfmt_flat: buffer overflow (EXTRA)?\\n\");\n\t\t\tgoto out_free_buf;\n\t\t}\n\t}\n\tif (buf[3] & ORIG_NAME) {\n\t\twhile (ret < LBUFSIZE && buf[ret++] != 0)\n\t\t\t;\n\t\tif (unlikely(LBUFSIZE == ret)) {\n\t\t\tDBG_FLT(\"binfmt_flat: buffer overflow (ORIG_NAME)?\\n\");\n\t\t\tgoto out_free_buf;\n\t\t}\n\t}\n\tif (buf[3] & COMMENT) {\n\t\twhile (ret < LBUFSIZE && buf[ret++] != 0)\n\t\t\t;\n\t\tif (unlikely(LBUFSIZE == ret)) {\n\t\t\tDBG_FLT(\"binfmt_flat: buffer overflow (COMMENT)?\\n\");\n\t\t\tgoto out_free_buf;\n\t\t}\n\t}\n\n\tstrm.next_in += ret;\n\tstrm.avail_in -= ret;\n\n\tstrm.next_out = dst;\n\tstrm.avail_out = len;\n\tstrm.total_out = 0;\n\n\tif (zlib_inflateInit2(&strm, -MAX_WBITS) != Z_OK) {\n\t\tDBG_FLT(\"binfmt_flat: zlib init failed?\\n\");\n\t\tgoto out_free_buf;\n\t}\n\n\twhile ((ret = zlib_inflate(&strm, Z_NO_FLUSH)) == Z_OK) {\n\t\tret = kernel_read(bprm->file, fpos, buf, LBUFSIZE);\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\t\tlen -= ret;\n\n\t\tstrm.next_in = buf;\n\t\tstrm.avail_in = ret;\n\t\tstrm.total_in = 0;\n\t\tfpos += ret;\n\t}\n\n\tif (ret < 0) {\n\t\tDBG_FLT(\"binfmt_flat: decompression failed (%d), %s\\n\",\n\t\t\tret, strm.msg);\n\t\tgoto out_zlib;\n\t}\n\n\tretval = 0;\nout_zlib:\n\tzlib_inflateEnd(&strm);\nout_free_buf:\n\tkfree(buf);\nout_free:\n\tkfree(strm.workspace);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR_VALUE",
          "args": [
            "result"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "(void *) datapos",
            "(void *) realdatastart",
            "full_data"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "hdr->reloc_start"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "realdatastart +\n\t\t\t\tMAX_SHARED_LIBS * sizeof(unsigned long)",
            "FLAT_DATA_ALIGN"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "hdr->data_start"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR_VALUE",
          "args": [
            "textpos"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_mmap",
          "args": [
            "0",
            "0",
            "len",
            "PROT_READ | PROT_EXEC | PROT_WRITE",
            "MAP_PRIVATE",
            "0"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "len"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "hdr->reloc_start"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_munmap",
          "args": [
            "realdatastart",
            "len"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_munmap",
          "args": [
            "textpos",
            "text_len"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR_VALUE",
          "args": [
            "result"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "hdr->data_start"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG_FLT",
          "args": [
            "\"BINFMT_FLAT: Allocated data+bss+stack (%d bytes): %x\\n\"",
            "(int)(data_len + bss_len + stack_len)",
            "(int)datapos"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "realdatastart +\n\t\t\t\tMAX_SHARED_LIBS * sizeof(unsigned long)",
            "FLAT_DATA_ALIGN"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_munmap",
          "args": [
            "textpos",
            "text_len"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR_VALUE",
          "args": [
            "realdatastart"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_mmap",
          "args": [
            "0",
            "0",
            "len",
            "PROT_READ|PROT_WRITE|PROT_EXEC",
            "MAP_PRIVATE",
            "0"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "len"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR_VALUE",
          "args": [
            "textpos"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_mmap",
          "args": [
            "bprm->file",
            "0",
            "text_len",
            "PROT_READ|PROT_EXEC",
            "MAP_PRIVATE|MAP_EXECUTABLE",
            "0"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG_FLT",
          "args": [
            "\"BINFMT_FLAT: ROM mapping of file (we hope)\\n\""
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "unsignedlong",
            "bss_len + stack_len",
            "relocs * sizeof(unsigned long)"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_new_exec",
          "args": [
            "bprm"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "setup_new_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "1112-1148",
          "snippet": "void setup_new_exec(struct linux_binprm * bprm)\n{\n\tarch_pick_mmap_layout(current->mm);\n\n\t/* This is the point of no return */\n\tcurrent->sas_ss_sp = current->sas_ss_size = 0;\n\n\tif (uid_eq(current_euid(), current_uid()) && gid_eq(current_egid(), current_gid()))\n\t\tset_dumpable(current->mm, SUID_DUMP_USER);\n\telse\n\t\tset_dumpable(current->mm, suid_dumpable);\n\n\tperf_event_exec();\n\t__set_task_comm(current, kbasename(bprm->filename), true);\n\n\t/* Set the new mm task size. We have to do that late because it may\n\t * depend on TIF_32BIT which is only updated in flush_thread() on\n\t * some architectures like powerpc\n\t */\n\tcurrent->mm->task_size = TASK_SIZE;\n\n\t/* install the new credentials */\n\tif (!uid_eq(bprm->cred->uid, current_euid()) ||\n\t    !gid_eq(bprm->cred->gid, current_egid())) {\n\t\tcurrent->pdeath_signal = 0;\n\t} else {\n\t\twould_dump(bprm, bprm->file);\n\t\tif (bprm->interp_flags & BINPRM_FLAGS_ENFORCE_NONDUMP)\n\t\t\tset_dumpable(current->mm, suid_dumpable);\n\t}\n\n\t/* An exec changes our domain. We are no longer part of the thread\n\t   group */\n\tcurrent->self_exec_id++;\n\tflush_signal_handlers(current, 0);\n\tdo_close_on_exec(current->files);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int suid_dumpable = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint suid_dumpable = 0;\n\nvoid setup_new_exec(struct linux_binprm * bprm)\n{\n\tarch_pick_mmap_layout(current->mm);\n\n\t/* This is the point of no return */\n\tcurrent->sas_ss_sp = current->sas_ss_size = 0;\n\n\tif (uid_eq(current_euid(), current_uid()) && gid_eq(current_egid(), current_gid()))\n\t\tset_dumpable(current->mm, SUID_DUMP_USER);\n\telse\n\t\tset_dumpable(current->mm, suid_dumpable);\n\n\tperf_event_exec();\n\t__set_task_comm(current, kbasename(bprm->filename), true);\n\n\t/* Set the new mm task size. We have to do that late because it may\n\t * depend on TIF_32BIT which is only updated in flush_thread() on\n\t * some architectures like powerpc\n\t */\n\tcurrent->mm->task_size = TASK_SIZE;\n\n\t/* install the new credentials */\n\tif (!uid_eq(bprm->cred->uid, current_euid()) ||\n\t    !gid_eq(bprm->cred->gid, current_egid())) {\n\t\tcurrent->pdeath_signal = 0;\n\t} else {\n\t\twould_dump(bprm, bprm->file);\n\t\tif (bprm->interp_flags & BINPRM_FLAGS_ENFORCE_NONDUMP)\n\t\t\tset_dumpable(current->mm, suid_dumpable);\n\t}\n\n\t/* An exec changes our domain. We are no longer part of the thread\n\t   group */\n\tcurrent->self_exec_id++;\n\tflush_signal_handlers(current, 0);\n\tdo_close_on_exec(current->files);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_personality",
          "args": [
            "PER_LINUX_32BIT"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_old_exec",
          "args": [
            "bprm"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "flush_old_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "1069-1102",
          "snippet": "int flush_old_exec(struct linux_binprm * bprm)\n{\n\tint retval;\n\n\t/*\n\t * Make sure we have a private signal table and that\n\t * we are unassociated from the previous thread group.\n\t */\n\tretval = de_thread(current);\n\tif (retval)\n\t\tgoto out;\n\n\tset_mm_exe_file(bprm->mm, bprm->file);\n\t/*\n\t * Release all of the old mmap stuff\n\t */\n\tacct_arg_size(bprm, 0);\n\tretval = exec_mmap(bprm->mm);\n\tif (retval)\n\t\tgoto out;\n\n\tbprm->mm = NULL;\t\t/* We're using it now */\n\n\tset_fs(USER_DS);\n\tcurrent->flags &= ~(PF_RANDOMIZE | PF_FORKNOEXEC | PF_KTHREAD |\n\t\t\t\t\tPF_NOFREEZE | PF_NO_SETAFFINITY);\n\tflush_thread();\n\tcurrent->personality &= ~bprm->per_clear;\n\n\treturn 0;\n\nout:\n\treturn retval;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint flush_old_exec(struct linux_binprm * bprm)\n{\n\tint retval;\n\n\t/*\n\t * Make sure we have a private signal table and that\n\t * we are unassociated from the previous thread group.\n\t */\n\tretval = de_thread(current);\n\tif (retval)\n\t\tgoto out;\n\n\tset_mm_exe_file(bprm->mm, bprm->file);\n\t/*\n\t * Release all of the old mmap stuff\n\t */\n\tacct_arg_size(bprm, 0);\n\tretval = exec_mmap(bprm->mm);\n\tif (retval)\n\t\tgoto out;\n\n\tbprm->mm = NULL;\t\t/* We're using it now */\n\n\tset_fs(USER_DS);\n\tcurrent->flags &= ~(PF_RANDOMIZE | PF_FORKNOEXEC | PF_KTHREAD |\n\t\t\t\t\tPF_NOFREEZE | PF_NO_SETAFFINITY);\n\tflush_thread();\n\tcurrent->personality &= ~bprm->per_clear;\n\n\treturn 0;\n\nout:\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rlimit",
          "args": [
            "RLIMIT_DATA"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flat_old_ram_flag",
          "args": [
            "flags"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "hdr->magic",
            "\"bFLT\"",
            "4"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "hdr->rev"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "hdr->flags"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "hdr->reloc_count"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "hdr->stack_size"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "hdr->data_end"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "hdr->bss_end"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "hdr->data_start"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "hdr->data_end"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "hdr->data_start"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "bprm->file"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/zlib.h>\n#include <asm/page.h>\n#include <asm/cacheflush.h>\n#include <asm/unaligned.h>\n#include <asm/uaccess.h>\n#include <asm/byteorder.h>\n#include <linux/syscalls.h>\n#include <linux/flat.h>\n#include <linux/init.h>\n#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/slab.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\n#define RELOC_FAILED 0xff00ff01\t\t/* Relocation incorrect somewhere */\n#define FLAT_DATA_ALIGN\t(0x20)\n\nstatic int load_flat_binary(struct linux_binprm *);\n\nstatic int load_flat_file(struct linux_binprm * bprm,\n\t\tstruct lib_info *libinfo, int id, unsigned long *extra_stack)\n{\n\tstruct flat_hdr * hdr;\n\tunsigned long textpos = 0, datapos = 0, result;\n\tunsigned long realdatastart = 0;\n\tunsigned long text_len, data_len, bss_len, stack_len, flags;\n\tunsigned long full_data;\n\tunsigned long len, memp = 0;\n\tunsigned long memp_size, extra, rlim;\n\tunsigned long *reloc = 0, *rp;\n\tstruct inode *inode;\n\tint i, rev, relocs = 0;\n\tloff_t fpos;\n\tunsigned long start_code, end_code;\n\tint ret;\n\n\thdr = ((struct flat_hdr *) bprm->buf);\t\t/* exec-header */\n\tinode = file_inode(bprm->file);\n\n\ttext_len  = ntohl(hdr->data_start);\n\tdata_len  = ntohl(hdr->data_end) - ntohl(hdr->data_start);\n\tbss_len   = ntohl(hdr->bss_end) - ntohl(hdr->data_end);\n\tstack_len = ntohl(hdr->stack_size);\n\tif (extra_stack) {\n\t\tstack_len += *extra_stack;\n\t\t*extra_stack = stack_len;\n\t}\n\trelocs    = ntohl(hdr->reloc_count);\n\tflags     = ntohl(hdr->flags);\n\trev       = ntohl(hdr->rev);\n\tfull_data = data_len + relocs * sizeof(unsigned long);\n\n\tif (strncmp(hdr->magic, \"bFLT\", 4)) {\n\t\t/*\n\t\t * Previously, here was a printk to tell people\n\t\t *   \"BINFMT_FLAT: bad header magic\".\n\t\t * But for the kernel which also use ELF FD-PIC format, this\n\t\t * error message is confusing.\n\t\t * because a lot of people do not manage to produce good\n\t\t */\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n\n\tif (flags & FLAT_FLAG_KTRACE)\n\t\tprintk(\"BINFMT_FLAT: Loading file: %s\\n\", bprm->filename);\n\n\tif (rev != FLAT_VERSION && rev != OLD_FLAT_VERSION) {\n\t\tprintk(\"BINFMT_FLAT: bad flat file version 0x%x (supported \"\n\t\t\t\"0x%lx and 0x%lx)\\n\",\n\t\t\trev, FLAT_VERSION, OLD_FLAT_VERSION);\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n\t\n\t/* Don't allow old format executables to use shared libraries */\n\tif (rev == OLD_FLAT_VERSION && id != 0) {\n\t\tprintk(\"BINFMT_FLAT: shared libraries are not available before rev 0x%x\\n\",\n\t\t\t\t(int) FLAT_VERSION);\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n\n\t/*\n\t * fix up the flags for the older format,  there were all kinds\n\t * of endian hacks,  this only works for the simple cases\n\t */\n\tif (rev == OLD_FLAT_VERSION && flat_old_ram_flag(flags))\n\t\tflags = FLAT_FLAG_RAM;\n\n#ifndef CONFIG_BINFMT_ZFLAT\n\tif (flags & (FLAT_FLAG_GZIP|FLAT_FLAG_GZDATA)) {\n\t\tprintk(\"Support for ZFLAT executables is not enabled.\\n\");\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n#endif\n\n\t/*\n\t * Check initial limits. This avoids letting people circumvent\n\t * size limits imposed on them by creating programs with large\n\t * arrays in the data or bss.\n\t */\n\trlim = rlimit(RLIMIT_DATA);\n\tif (rlim >= RLIM_INFINITY)\n\t\trlim = ~0;\n\tif (data_len + bss_len > rlim) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t/* Flush all traces of the currently running executable */\n\tif (id == 0) {\n\t\tresult = flush_old_exec(bprm);\n\t\tif (result) {\n\t\t\tret = result;\n\t\t\tgoto err;\n\t\t}\n\n\t\t/* OK, This is the point of no return */\n\t\tset_personality(PER_LINUX_32BIT);\n\t\tsetup_new_exec(bprm);\n\t}\n\n\t/*\n\t * calculate the extra space we need to map in\n\t */\n\textra = max_t(unsigned long, bss_len + stack_len,\n\t\t\trelocs * sizeof(unsigned long));\n\n\t/*\n\t * there are a couple of cases here,  the separate code/data\n\t * case,  and then the fully copied to RAM case which lumps\n\t * it all together.\n\t */\n\tif ((flags & (FLAT_FLAG_RAM|FLAT_FLAG_GZIP)) == 0) {\n\t\t/*\n\t\t * this should give us a ROM ptr,  but if it doesn't we don't\n\t\t * really care\n\t\t */\n\t\tDBG_FLT(\"BINFMT_FLAT: ROM mapping of file (we hope)\\n\");\n\n\t\ttextpos = vm_mmap(bprm->file, 0, text_len, PROT_READ|PROT_EXEC,\n\t\t\t\t  MAP_PRIVATE|MAP_EXECUTABLE, 0);\n\t\tif (!textpos || IS_ERR_VALUE(textpos)) {\n\t\t\tif (!textpos)\n\t\t\t\ttextpos = (unsigned long) -ENOMEM;\n\t\t\tprintk(\"Unable to mmap process text, errno %d\\n\", (int)-textpos);\n\t\t\tret = textpos;\n\t\t\tgoto err;\n\t\t}\n\n\t\tlen = data_len + extra + MAX_SHARED_LIBS * sizeof(unsigned long);\n\t\tlen = PAGE_ALIGN(len);\n\t\trealdatastart = vm_mmap(0, 0, len,\n\t\t\tPROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE, 0);\n\n\t\tif (realdatastart == 0 || IS_ERR_VALUE(realdatastart)) {\n\t\t\tif (!realdatastart)\n\t\t\t\trealdatastart = (unsigned long) -ENOMEM;\n\t\t\tprintk(\"Unable to allocate RAM for process data, errno %d\\n\",\n\t\t\t\t\t(int)-realdatastart);\n\t\t\tvm_munmap(textpos, text_len);\n\t\t\tret = realdatastart;\n\t\t\tgoto err;\n\t\t}\n\t\tdatapos = ALIGN(realdatastart +\n\t\t\t\tMAX_SHARED_LIBS * sizeof(unsigned long),\n\t\t\t\tFLAT_DATA_ALIGN);\n\n\t\tDBG_FLT(\"BINFMT_FLAT: Allocated data+bss+stack (%d bytes): %x\\n\",\n\t\t\t\t(int)(data_len + bss_len + stack_len), (int)datapos);\n\n\t\tfpos = ntohl(hdr->data_start);\n#ifdef CONFIG_BINFMT_ZFLAT\n\t\tif (flags & FLAT_FLAG_GZDATA) {\n\t\t\tresult = decompress_exec(bprm, fpos, (char *) datapos, \n\t\t\t\t\t\t full_data, 0);\n\t\t} else\n#endif\n\t\t{\n\t\t\tresult = read_code(bprm->file, datapos, fpos,\n\t\t\t\t\tfull_data);\n\t\t}\n\t\tif (IS_ERR_VALUE(result)) {\n\t\t\tprintk(\"Unable to read data+bss, errno %d\\n\", (int)-result);\n\t\t\tvm_munmap(textpos, text_len);\n\t\t\tvm_munmap(realdatastart, len);\n\t\t\tret = result;\n\t\t\tgoto err;\n\t\t}\n\n\t\treloc = (unsigned long *) (datapos+(ntohl(hdr->reloc_start)-text_len));\n\t\tmemp = realdatastart;\n\t\tmemp_size = len;\n\t} else {\n\n\t\tlen = text_len + data_len + extra + MAX_SHARED_LIBS * sizeof(unsigned long);\n\t\tlen = PAGE_ALIGN(len);\n\t\ttextpos = vm_mmap(0, 0, len,\n\t\t\tPROT_READ | PROT_EXEC | PROT_WRITE, MAP_PRIVATE, 0);\n\n\t\tif (!textpos || IS_ERR_VALUE(textpos)) {\n\t\t\tif (!textpos)\n\t\t\t\ttextpos = (unsigned long) -ENOMEM;\n\t\t\tprintk(\"Unable to allocate RAM for process text/data, errno %d\\n\",\n\t\t\t\t\t(int)-textpos);\n\t\t\tret = textpos;\n\t\t\tgoto err;\n\t\t}\n\n\t\trealdatastart = textpos + ntohl(hdr->data_start);\n\t\tdatapos = ALIGN(realdatastart +\n\t\t\t\tMAX_SHARED_LIBS * sizeof(unsigned long),\n\t\t\t\tFLAT_DATA_ALIGN);\n\n\t\treloc = (unsigned long *)\n\t\t\t(datapos + (ntohl(hdr->reloc_start) - text_len));\n\t\tmemp = textpos;\n\t\tmemp_size = len;\n#ifdef CONFIG_BINFMT_ZFLAT\n\t\t/*\n\t\t * load it all in and treat it like a RAM load from now on\n\t\t */\n\t\tif (flags & FLAT_FLAG_GZIP) {\n\t\t\tresult = decompress_exec(bprm, sizeof (struct flat_hdr),\n\t\t\t\t\t (((char *) textpos) + sizeof (struct flat_hdr)),\n\t\t\t\t\t (text_len + full_data\n\t\t\t\t\t\t  - sizeof (struct flat_hdr)),\n\t\t\t\t\t 0);\n\t\t\tmemmove((void *) datapos, (void *) realdatastart,\n\t\t\t\t\tfull_data);\n\t\t} else if (flags & FLAT_FLAG_GZDATA) {\n\t\t\tresult = read_code(bprm->file, textpos, 0, text_len);\n\t\t\tif (!IS_ERR_VALUE(result))\n\t\t\t\tresult = decompress_exec(bprm, text_len, (char *) datapos,\n\t\t\t\t\t\t full_data, 0);\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t\tresult = read_code(bprm->file, textpos, 0, text_len);\n\t\t\tif (!IS_ERR_VALUE(result))\n\t\t\t\tresult = read_code(bprm->file, datapos,\n\t\t\t\t\t\t   ntohl(hdr->data_start),\n\t\t\t\t\t\t   full_data);\n\t\t}\n\t\tif (IS_ERR_VALUE(result)) {\n\t\t\tprintk(\"Unable to read code+data+bss, errno %d\\n\",(int)-result);\n\t\t\tvm_munmap(textpos, text_len + data_len + extra +\n\t\t\t\tMAX_SHARED_LIBS * sizeof(unsigned long));\n\t\t\tret = result;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (flags & FLAT_FLAG_KTRACE)\n\t\tprintk(\"Mapping is %x, Entry point is %x, data_start is %x\\n\",\n\t\t\t(int)textpos, 0x00ffffff&ntohl(hdr->entry), ntohl(hdr->data_start));\n\n\t/* The main program needs a little extra setup in the task structure */\n\tstart_code = textpos + sizeof (struct flat_hdr);\n\tend_code = textpos + text_len;\n\tif (id == 0) {\n\t\tcurrent->mm->start_code = start_code;\n\t\tcurrent->mm->end_code = end_code;\n\t\tcurrent->mm->start_data = datapos;\n\t\tcurrent->mm->end_data = datapos + data_len;\n\t\t/*\n\t\t * set up the brk stuff, uses any slack left in data/bss/stack\n\t\t * allocation.  We put the brk after the bss (between the bss\n\t\t * and stack) like other platforms.\n\t\t * Userspace code relies on the stack pointer starting out at\n\t\t * an address right at the end of a page.\n\t\t */\n\t\tcurrent->mm->start_brk = datapos + data_len + bss_len;\n\t\tcurrent->mm->brk = (current->mm->start_brk + 3) & ~3;\n\t\tcurrent->mm->context.end_brk = memp + memp_size - stack_len;\n\t}\n\n\tif (flags & FLAT_FLAG_KTRACE)\n\t\tprintk(\"%s %s: TEXT=%x-%x DATA=%x-%x BSS=%x-%x\\n\",\n\t\t\tid ? \"Lib\" : \"Load\", bprm->filename,\n\t\t\t(int) start_code, (int) end_code,\n\t\t\t(int) datapos,\n\t\t\t(int) (datapos + data_len),\n\t\t\t(int) (datapos + data_len),\n\t\t\t(int) (((datapos + data_len + bss_len) + 3) & ~3));\n\n\ttext_len -= sizeof(struct flat_hdr); /* the real code len */\n\n\t/* Store the current module values into the global library structure */\n\tlibinfo->lib_list[id].start_code = start_code;\n\tlibinfo->lib_list[id].start_data = datapos;\n\tlibinfo->lib_list[id].start_brk = datapos + data_len + bss_len;\n\tlibinfo->lib_list[id].text_len = text_len;\n\tlibinfo->lib_list[id].loaded = 1;\n\tlibinfo->lib_list[id].entry = (0x00ffffff & ntohl(hdr->entry)) + textpos;\n\tlibinfo->lib_list[id].build_date = ntohl(hdr->build_date);\n\t\n\t/*\n\t * We just load the allocations into some temporary memory to\n\t * help simplify all this mumbo jumbo\n\t *\n\t * We've got two different sections of relocation entries.\n\t * The first is the GOT which resides at the beginning of the data segment\n\t * and is terminated with a -1.  This one can be relocated in place.\n\t * The second is the extra relocation entries tacked after the image's\n\t * data segment. These require a little more processing as the entry is\n\t * really an offset into the image which contains an offset into the\n\t * image.\n\t */\n\tif (flags & FLAT_FLAG_GOTPIC) {\n\t\tfor (rp = (unsigned long *)datapos; *rp != 0xffffffff; rp++) {\n\t\t\tunsigned long addr;\n\t\t\tif (*rp) {\n\t\t\t\taddr = calc_reloc(*rp, libinfo, id, 0);\n\t\t\t\tif (addr == RELOC_FAILED) {\n\t\t\t\t\tret = -ENOEXEC;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\t*rp = addr;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Now run through the relocation entries.\n\t * We've got to be careful here as C++ produces relocatable zero\n\t * entries in the constructor and destructor tables which are then\n\t * tested for being not zero (which will always occur unless we're\n\t * based from address zero).  This causes an endless loop as __start\n\t * is at zero.  The solution used is to not relocate zero addresses.\n\t * This has the negative side effect of not allowing a global data\n\t * reference to be statically initialised to _stext (I've moved\n\t * __start to address 4 so that is okay).\n\t */\n\tif (rev > OLD_FLAT_VERSION) {\n\t\tunsigned long persistent = 0;\n\t\tfor (i=0; i < relocs; i++) {\n\t\t\tunsigned long addr, relval;\n\n\t\t\t/* Get the address of the pointer to be\n\t\t\t   relocated (of course, the address has to be\n\t\t\t   relocated first).  */\n\t\t\trelval = ntohl(reloc[i]);\n\t\t\tif (flat_set_persistent (relval, &persistent))\n\t\t\t\tcontinue;\n\t\t\taddr = flat_get_relocate_addr(relval);\n\t\t\trp = (unsigned long *) calc_reloc(addr, libinfo, id, 1);\n\t\t\tif (rp == (unsigned long *)RELOC_FAILED) {\n\t\t\t\tret = -ENOEXEC;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\t/* Get the pointer's value.  */\n\t\t\taddr = flat_get_addr_from_rp(rp, relval, flags,\n\t\t\t\t\t\t\t&persistent);\n\t\t\tif (addr != 0) {\n\t\t\t\t/*\n\t\t\t\t * Do the relocation.  PIC relocs in the data section are\n\t\t\t\t * already in target order\n\t\t\t\t */\n\t\t\t\tif ((flags & FLAT_FLAG_GOTPIC) == 0)\n\t\t\t\t\taddr = ntohl(addr);\n\t\t\t\taddr = calc_reloc(addr, libinfo, id, 0);\n\t\t\t\tif (addr == RELOC_FAILED) {\n\t\t\t\t\tret = -ENOEXEC;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\n\t\t\t\t/* Write back the relocated pointer.  */\n\t\t\t\tflat_put_addr_at_rp(rp, addr, relval);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i=0; i < relocs; i++)\n\t\t\told_reloc(ntohl(reloc[i]));\n\t}\n\t\n\tflush_icache_range(start_code, end_code);\n\n\t/* zero the BSS,  BRK and stack areas */\n\tmemset((void*)(datapos + data_len), 0, bss_len + \n\t\t\t(memp + memp_size - stack_len -\t\t/* end brk */\n\t\t\tlibinfo->lib_list[id].start_brk) +\t/* start brk */\n\t\t\tstack_len);\n\n\treturn 0;\nerr:\n\treturn ret;\n}"
  },
  {
    "function_name": "old_reloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_flat.c",
    "lines": "383-422",
    "snippet": "static void old_reloc(unsigned long rl)\n{\n#ifdef DEBUG\n\tchar *segment[] = { \"TEXT\", \"DATA\", \"BSS\", \"*UNKNOWN*\" };\n#endif\n\tflat_v2_reloc_t\tr;\n\tunsigned long *ptr;\n\t\n\tr.value = rl;\n#if defined(CONFIG_COLDFIRE)\n\tptr = (unsigned long *) (current->mm->start_code + r.reloc.offset);\n#else\n\tptr = (unsigned long *) (current->mm->start_data + r.reloc.offset);\n#endif\n\n#ifdef DEBUG\n\tprintk(\"Relocation of variable at DATASEG+%x \"\n\t\t\"(address %p, currently %x) into segment %s\\n\",\n\t\tr.reloc.offset, ptr, (int)*ptr, segment[r.reloc.type]);\n#endif\n\t\n\tswitch (r.reloc.type) {\n\tcase OLD_FLAT_RELOC_TYPE_TEXT:\n\t\t*ptr += current->mm->start_code;\n\t\tbreak;\n\tcase OLD_FLAT_RELOC_TYPE_DATA:\n\t\t*ptr += current->mm->start_data;\n\t\tbreak;\n\tcase OLD_FLAT_RELOC_TYPE_BSS:\n\t\t*ptr += current->mm->end_data;\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"BINFMT_FLAT: Unknown relocation type=%x\\n\", r.reloc.type);\n\t\tbreak;\n\t}\n\n#ifdef DEBUG\n\tprintk(\"Relocation became %x\\n\", (int)*ptr);\n#endif\n}",
    "includes": [
      "#include <linux/zlib.h>",
      "#include <asm/page.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/unaligned.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/flat.h>",
      "#include <linux/init.h>",
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/slab.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [
      "#define DEBUG 1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Relocation became %x\\n\"",
            "(int)*ptr"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/zlib.h>\n#include <asm/page.h>\n#include <asm/cacheflush.h>\n#include <asm/unaligned.h>\n#include <asm/uaccess.h>\n#include <asm/byteorder.h>\n#include <linux/syscalls.h>\n#include <linux/flat.h>\n#include <linux/init.h>\n#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/slab.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\n#define DEBUG 1\n\nstatic void old_reloc(unsigned long rl)\n{\n#ifdef DEBUG\n\tchar *segment[] = { \"TEXT\", \"DATA\", \"BSS\", \"*UNKNOWN*\" };\n#endif\n\tflat_v2_reloc_t\tr;\n\tunsigned long *ptr;\n\t\n\tr.value = rl;\n#if defined(CONFIG_COLDFIRE)\n\tptr = (unsigned long *) (current->mm->start_code + r.reloc.offset);\n#else\n\tptr = (unsigned long *) (current->mm->start_data + r.reloc.offset);\n#endif\n\n#ifdef DEBUG\n\tprintk(\"Relocation of variable at DATASEG+%x \"\n\t\t\"(address %p, currently %x) into segment %s\\n\",\n\t\tr.reloc.offset, ptr, (int)*ptr, segment[r.reloc.type]);\n#endif\n\t\n\tswitch (r.reloc.type) {\n\tcase OLD_FLAT_RELOC_TYPE_TEXT:\n\t\t*ptr += current->mm->start_code;\n\t\tbreak;\n\tcase OLD_FLAT_RELOC_TYPE_DATA:\n\t\t*ptr += current->mm->start_data;\n\t\tbreak;\n\tcase OLD_FLAT_RELOC_TYPE_BSS:\n\t\t*ptr += current->mm->end_data;\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"BINFMT_FLAT: Unknown relocation type=%x\\n\", r.reloc.type);\n\t\tbreak;\n\t}\n\n#ifdef DEBUG\n\tprintk(\"Relocation became %x\\n\", (int)*ptr);\n#endif\n}"
  },
  {
    "function_name": "calc_reloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_flat.c",
    "lines": "312-379",
    "snippet": "static unsigned long\ncalc_reloc(unsigned long r, struct lib_info *p, int curid, int internalp)\n{\n\tunsigned long addr;\n\tint id;\n\tunsigned long start_brk;\n\tunsigned long start_data;\n\tunsigned long text_len;\n\tunsigned long start_code;\n\n#ifdef CONFIG_BINFMT_SHARED_FLAT\n\tif (r == 0)\n\t\tid = curid;\t/* Relocs of 0 are always self referring */\n\telse {\n\t\tid = (r >> 24) & 0xff;\t/* Find ID for this reloc */\n\t\tr &= 0x00ffffff;\t/* Trim ID off here */\n\t}\n\tif (id >= MAX_SHARED_LIBS) {\n\t\tprintk(\"BINFMT_FLAT: reference 0x%x to shared library %d\",\n\t\t\t\t(unsigned) r, id);\n\t\tgoto failed;\n\t}\n\tif (curid != id) {\n\t\tif (internalp) {\n\t\t\tprintk(\"BINFMT_FLAT: reloc address 0x%x not in same module \"\n\t\t\t\t\t\"(%d != %d)\", (unsigned) r, curid, id);\n\t\t\tgoto failed;\n\t\t} else if ( ! p->lib_list[id].loaded &&\n\t\t\t\tIS_ERR_VALUE(load_flat_shared_library(id, p))) {\n\t\t\tprintk(\"BINFMT_FLAT: failed to load library %d\", id);\n\t\t\tgoto failed;\n\t\t}\n\t\t/* Check versioning information (i.e. time stamps) */\n\t\tif (p->lib_list[id].build_date && p->lib_list[curid].build_date &&\n\t\t\t\tp->lib_list[curid].build_date < p->lib_list[id].build_date) {\n\t\t\tprintk(\"BINFMT_FLAT: library %d is younger than %d\", id, curid);\n\t\t\tgoto failed;\n\t\t}\n\t}\n#else\n\tid = 0;\n#endif\n\n\tstart_brk = p->lib_list[id].start_brk;\n\tstart_data = p->lib_list[id].start_data;\n\tstart_code = p->lib_list[id].start_code;\n\ttext_len = p->lib_list[id].text_len;\n\n\tif (!flat_reloc_valid(r, start_brk - start_data + text_len)) {\n\t\tprintk(\"BINFMT_FLAT: reloc outside program 0x%x (0 - 0x%x/0x%x)\",\n\t\t       (int) r,(int)(start_brk-start_data+text_len),(int)text_len);\n\t\tgoto failed;\n\t}\n\n\tif (r < text_len)\t\t\t/* In text segment */\n\t\taddr = r + start_code;\n\telse\t\t\t\t\t/* In data segment */\n\t\taddr = r - text_len + start_data;\n\n\t/* Range checked already above so doing the range tests is redundant...*/\n\treturn(addr);\n\nfailed:\n\tprintk(\", killing %s!\\n\", current->comm);\n\tsend_sig(SIGSEGV, current, 0);\n\n\treturn RELOC_FAILED;\n}",
    "includes": [
      "#include <linux/zlib.h>",
      "#include <asm/page.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/unaligned.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/flat.h>",
      "#include <linux/init.h>",
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/slab.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [
      "#define RELOC_FAILED 0xff00ff01\t\t/* Relocation incorrect somewhere */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_sig",
          "args": [
            "SIGSEGV",
            "current",
            "0"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "send_sigurg_to_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fcntl.c",
          "lines": "518-523",
          "snippet": "static void send_sigurg_to_task(struct task_struct *p,\n\t\t\t\tstruct fown_struct *fown, int group)\n{\n\tif (sigio_perm(p, fown, SIGURG))\n\t\tdo_send_sig_info(SIGURG, SEND_SIG_PRIV, p, group);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/poll.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/siginfo.h>\n#include <asm/poll.h>\n#include <linux/shmem_fs.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nstatic void send_sigurg_to_task(struct task_struct *p,\n\t\t\t\tstruct fown_struct *fown, int group)\n{\n\tif (sigio_perm(p, fown, SIGURG))\n\t\tdo_send_sig_info(SIGURG, SEND_SIG_PRIV, p, group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\", killing %s!\\n\"",
            "current->comm"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flat_reloc_valid",
          "args": [
            "r",
            "start_brk - start_data + text_len"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR_VALUE",
          "args": [
            "load_flat_shared_library(id, p)"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_flat_shared_library",
          "args": [
            "id",
            "p"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "load_flat_shared_library",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_flat.c",
          "lines": "809-850",
          "snippet": "static int load_flat_shared_library(int id, struct lib_info *libs)\n{\n\tstruct linux_binprm bprm;\n\tint res;\n\tchar buf[16];\n\n\tmemset(&bprm, 0, sizeof(bprm));\n\n\t/* Create the file name */\n\tsprintf(buf, \"/lib/lib%d.so\", id);\n\n\t/* Open the file up */\n\tbprm.filename = buf;\n\tbprm.file = open_exec(bprm.filename);\n\tres = PTR_ERR(bprm.file);\n\tif (IS_ERR(bprm.file))\n\t\treturn res;\n\n\tbprm.cred = prepare_exec_creds();\n\tres = -ENOMEM;\n\tif (!bprm.cred)\n\t\tgoto out;\n\n\t/* We don't really care about recalculating credentials at this point\n\t * as we're past the point of no return and are dealing with shared\n\t * libraries.\n\t */\n\tbprm.cred_prepared = 1;\n\n\tres = prepare_binprm(&bprm);\n\n\tif (!IS_ERR_VALUE(res))\n\t\tres = load_flat_file(&bprm, libs, id, NULL);\n\n\tabort_creds(bprm.cred);\n\nout:\n\tallow_write_access(bprm.file);\n\tfput(bprm.file);\n\n\treturn(res);\n}",
          "includes": [
            "#include <linux/zlib.h>",
            "#include <asm/page.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/flat.h>",
            "#include <linux/init.h>",
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/slab.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int load_flat_binary(struct linux_binprm *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zlib.h>\n#include <asm/page.h>\n#include <asm/cacheflush.h>\n#include <asm/unaligned.h>\n#include <asm/uaccess.h>\n#include <asm/byteorder.h>\n#include <linux/syscalls.h>\n#include <linux/flat.h>\n#include <linux/init.h>\n#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/slab.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int load_flat_binary(struct linux_binprm *);\n\nstatic int load_flat_shared_library(int id, struct lib_info *libs)\n{\n\tstruct linux_binprm bprm;\n\tint res;\n\tchar buf[16];\n\n\tmemset(&bprm, 0, sizeof(bprm));\n\n\t/* Create the file name */\n\tsprintf(buf, \"/lib/lib%d.so\", id);\n\n\t/* Open the file up */\n\tbprm.filename = buf;\n\tbprm.file = open_exec(bprm.filename);\n\tres = PTR_ERR(bprm.file);\n\tif (IS_ERR(bprm.file))\n\t\treturn res;\n\n\tbprm.cred = prepare_exec_creds();\n\tres = -ENOMEM;\n\tif (!bprm.cred)\n\t\tgoto out;\n\n\t/* We don't really care about recalculating credentials at this point\n\t * as we're past the point of no return and are dealing with shared\n\t * libraries.\n\t */\n\tbprm.cred_prepared = 1;\n\n\tres = prepare_binprm(&bprm);\n\n\tif (!IS_ERR_VALUE(res))\n\t\tres = load_flat_file(&bprm, libs, id, NULL);\n\n\tabort_creds(bprm.cred);\n\nout:\n\tallow_write_access(bprm.file);\n\tfput(bprm.file);\n\n\treturn(res);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/zlib.h>\n#include <asm/page.h>\n#include <asm/cacheflush.h>\n#include <asm/unaligned.h>\n#include <asm/uaccess.h>\n#include <asm/byteorder.h>\n#include <linux/syscalls.h>\n#include <linux/flat.h>\n#include <linux/init.h>\n#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/slab.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\n#define RELOC_FAILED 0xff00ff01\t\t/* Relocation incorrect somewhere */\n\nstatic unsigned long\ncalc_reloc(unsigned long r, struct lib_info *p, int curid, int internalp)\n{\n\tunsigned long addr;\n\tint id;\n\tunsigned long start_brk;\n\tunsigned long start_data;\n\tunsigned long text_len;\n\tunsigned long start_code;\n\n#ifdef CONFIG_BINFMT_SHARED_FLAT\n\tif (r == 0)\n\t\tid = curid;\t/* Relocs of 0 are always self referring */\n\telse {\n\t\tid = (r >> 24) & 0xff;\t/* Find ID for this reloc */\n\t\tr &= 0x00ffffff;\t/* Trim ID off here */\n\t}\n\tif (id >= MAX_SHARED_LIBS) {\n\t\tprintk(\"BINFMT_FLAT: reference 0x%x to shared library %d\",\n\t\t\t\t(unsigned) r, id);\n\t\tgoto failed;\n\t}\n\tif (curid != id) {\n\t\tif (internalp) {\n\t\t\tprintk(\"BINFMT_FLAT: reloc address 0x%x not in same module \"\n\t\t\t\t\t\"(%d != %d)\", (unsigned) r, curid, id);\n\t\t\tgoto failed;\n\t\t} else if ( ! p->lib_list[id].loaded &&\n\t\t\t\tIS_ERR_VALUE(load_flat_shared_library(id, p))) {\n\t\t\tprintk(\"BINFMT_FLAT: failed to load library %d\", id);\n\t\t\tgoto failed;\n\t\t}\n\t\t/* Check versioning information (i.e. time stamps) */\n\t\tif (p->lib_list[id].build_date && p->lib_list[curid].build_date &&\n\t\t\t\tp->lib_list[curid].build_date < p->lib_list[id].build_date) {\n\t\t\tprintk(\"BINFMT_FLAT: library %d is younger than %d\", id, curid);\n\t\t\tgoto failed;\n\t\t}\n\t}\n#else\n\tid = 0;\n#endif\n\n\tstart_brk = p->lib_list[id].start_brk;\n\tstart_data = p->lib_list[id].start_data;\n\tstart_code = p->lib_list[id].start_code;\n\ttext_len = p->lib_list[id].text_len;\n\n\tif (!flat_reloc_valid(r, start_brk - start_data + text_len)) {\n\t\tprintk(\"BINFMT_FLAT: reloc outside program 0x%x (0 - 0x%x/0x%x)\",\n\t\t       (int) r,(int)(start_brk-start_data+text_len),(int)text_len);\n\t\tgoto failed;\n\t}\n\n\tif (r < text_len)\t\t\t/* In text segment */\n\t\taddr = r + start_code;\n\telse\t\t\t\t\t/* In data segment */\n\t\taddr = r - text_len + start_data;\n\n\t/* Range checked already above so doing the range tests is redundant...*/\n\treturn(addr);\n\nfailed:\n\tprintk(\", killing %s!\\n\", current->comm);\n\tsend_sig(SIGSEGV, current, 0);\n\n\treturn RELOC_FAILED;\n}"
  },
  {
    "function_name": "decompress_exec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_flat.c",
    "lines": "181-306",
    "snippet": "static int decompress_exec(\n\tstruct linux_binprm *bprm,\n\tunsigned long offset,\n\tchar *dst,\n\tlong len,\n\tint fd)\n{\n\tunsigned char *buf;\n\tz_stream strm;\n\tloff_t fpos;\n\tint ret, retval;\n\n\tDBG_FLT(\"decompress_exec(offset=%x,buf=%x,len=%x)\\n\",(int)offset, (int)dst, (int)len);\n\n\tmemset(&strm, 0, sizeof(strm));\n\tstrm.workspace = kmalloc(zlib_inflate_workspacesize(), GFP_KERNEL);\n\tif (strm.workspace == NULL) {\n\t\tDBG_FLT(\"binfmt_flat: no memory for decompress workspace\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tbuf = kmalloc(LBUFSIZE, GFP_KERNEL);\n\tif (buf == NULL) {\n\t\tDBG_FLT(\"binfmt_flat: no memory for read buffer\\n\");\n\t\tretval = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\t/* Read in first chunk of data and parse gzip header. */\n\tfpos = offset;\n\tret = kernel_read(bprm->file, offset, buf, LBUFSIZE);\n\n\tstrm.next_in = buf;\n\tstrm.avail_in = ret;\n\tstrm.total_in = 0;\n\tfpos += ret;\n\n\tretval = -ENOEXEC;\n\n\t/* Check minimum size -- gzip header */\n\tif (ret < 10) {\n\t\tDBG_FLT(\"binfmt_flat: file too small?\\n\");\n\t\tgoto out_free_buf;\n\t}\n\n\t/* Check gzip magic number */\n\tif ((buf[0] != 037) || ((buf[1] != 0213) && (buf[1] != 0236))) {\n\t\tDBG_FLT(\"binfmt_flat: unknown compression magic?\\n\");\n\t\tgoto out_free_buf;\n\t}\n\n\t/* Check gzip method */\n\tif (buf[2] != 8) {\n\t\tDBG_FLT(\"binfmt_flat: unknown compression method?\\n\");\n\t\tgoto out_free_buf;\n\t}\n\t/* Check gzip flags */\n\tif ((buf[3] & ENCRYPTED) || (buf[3] & CONTINUATION) ||\n\t    (buf[3] & RESERVED)) {\n\t\tDBG_FLT(\"binfmt_flat: unknown flags?\\n\");\n\t\tgoto out_free_buf;\n\t}\n\n\tret = 10;\n\tif (buf[3] & EXTRA_FIELD) {\n\t\tret += 2 + buf[10] + (buf[11] << 8);\n\t\tif (unlikely(LBUFSIZE <= ret)) {\n\t\t\tDBG_FLT(\"binfmt_flat: buffer overflow (EXTRA)?\\n\");\n\t\t\tgoto out_free_buf;\n\t\t}\n\t}\n\tif (buf[3] & ORIG_NAME) {\n\t\twhile (ret < LBUFSIZE && buf[ret++] != 0)\n\t\t\t;\n\t\tif (unlikely(LBUFSIZE == ret)) {\n\t\t\tDBG_FLT(\"binfmt_flat: buffer overflow (ORIG_NAME)?\\n\");\n\t\t\tgoto out_free_buf;\n\t\t}\n\t}\n\tif (buf[3] & COMMENT) {\n\t\twhile (ret < LBUFSIZE && buf[ret++] != 0)\n\t\t\t;\n\t\tif (unlikely(LBUFSIZE == ret)) {\n\t\t\tDBG_FLT(\"binfmt_flat: buffer overflow (COMMENT)?\\n\");\n\t\t\tgoto out_free_buf;\n\t\t}\n\t}\n\n\tstrm.next_in += ret;\n\tstrm.avail_in -= ret;\n\n\tstrm.next_out = dst;\n\tstrm.avail_out = len;\n\tstrm.total_out = 0;\n\n\tif (zlib_inflateInit2(&strm, -MAX_WBITS) != Z_OK) {\n\t\tDBG_FLT(\"binfmt_flat: zlib init failed?\\n\");\n\t\tgoto out_free_buf;\n\t}\n\n\twhile ((ret = zlib_inflate(&strm, Z_NO_FLUSH)) == Z_OK) {\n\t\tret = kernel_read(bprm->file, fpos, buf, LBUFSIZE);\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\t\tlen -= ret;\n\n\t\tstrm.next_in = buf;\n\t\tstrm.avail_in = ret;\n\t\tstrm.total_in = 0;\n\t\tfpos += ret;\n\t}\n\n\tif (ret < 0) {\n\t\tDBG_FLT(\"binfmt_flat: decompression failed (%d), %s\\n\",\n\t\t\tret, strm.msg);\n\t\tgoto out_zlib;\n\t}\n\n\tretval = 0;\nout_zlib:\n\tzlib_inflateEnd(&strm);\nout_free_buf:\n\tkfree(buf);\nout_free:\n\tkfree(strm.workspace);\n\treturn retval;\n}",
    "includes": [
      "#include <linux/zlib.h>",
      "#include <asm/page.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/unaligned.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/flat.h>",
      "#include <linux/init.h>",
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/slab.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [
      "#define RESERVED     0xC0 /* bit 6,7:   reserved */",
      "#define ENCRYPTED    0x20 /* bit 5 set: file is encrypted */",
      "#define COMMENT      0x10 /* bit 4 set: file comment present */",
      "#define ORIG_NAME    0x08 /* bit 3 set: original file name present */",
      "#define EXTRA_FIELD  0x04 /* bit 2 set: extra field present */",
      "#define CONTINUATION 0x02 /* bit 1 set: continuation of multi-part gzip file */",
      "#define LBUFSIZE\t4000"
    ],
    "globals_used": [
      "static int load_flat_binary(struct linux_binprm *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "strm.workspace"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zlib_inflateEnd",
          "args": [
            "&strm"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG_FLT",
          "args": [
            "\"binfmt_flat: decompression failed (%d), %s\\n\"",
            "ret",
            "strm.msg"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_read",
          "args": [
            "bprm->file",
            "fpos",
            "buf",
            "LBUFSIZE"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_readv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "569-583",
          "snippet": "static ssize_t kernel_readv(struct file *file, const struct iovec *vec,\n\t\t\t    unsigned long vlen, loff_t offset)\n{\n\tmm_segment_t old_fs;\n\tloff_t pos = offset;\n\tssize_t res;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = vfs_readv(file, (const struct iovec __user *)vec, vlen, &pos);\n\tset_fs(old_fs);\n\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic ssize_t kernel_readv(struct file *file, const struct iovec *vec,\n\t\t\t    unsigned long vlen, loff_t offset)\n{\n\tmm_segment_t old_fs;\n\tloff_t pos = offset;\n\tssize_t res;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = vfs_readv(file, (const struct iovec __user *)vec, vlen, &pos);\n\tset_fs(old_fs);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zlib_inflate",
          "args": [
            "&strm",
            "Z_NO_FLUSH"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG_FLT",
          "args": [
            "\"binfmt_flat: zlib init failed?\\n\""
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zlib_inflateInit2",
          "args": [
            "&strm",
            "-MAX_WBITS"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG_FLT",
          "args": [
            "\"binfmt_flat: buffer overflow (COMMENT)?\\n\""
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "LBUFSIZE == ret"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG_FLT",
          "args": [
            "\"binfmt_flat: buffer overflow (ORIG_NAME)?\\n\""
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "LBUFSIZE == ret"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG_FLT",
          "args": [
            "\"binfmt_flat: buffer overflow (EXTRA)?\\n\""
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "LBUFSIZE <= ret"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG_FLT",
          "args": [
            "\"binfmt_flat: unknown flags?\\n\""
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG_FLT",
          "args": [
            "\"binfmt_flat: unknown compression method?\\n\""
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG_FLT",
          "args": [
            "\"binfmt_flat: unknown compression magic?\\n\""
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG_FLT",
          "args": [
            "\"binfmt_flat: file too small?\\n\""
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG_FLT",
          "args": [
            "\"binfmt_flat: no memory for read buffer\\n\""
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "LBUFSIZE",
            "GFP_KERNEL"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DBG_FLT",
          "args": [
            "\"binfmt_flat: no memory for decompress workspace\\n\""
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zlib_inflate_workspacesize",
          "args": [],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&strm",
            "0",
            "sizeof(strm)"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG_FLT",
          "args": [
            "\"decompress_exec(offset=%x,buf=%x,len=%x)\\n\"",
            "(int)offset",
            "(int)dst",
            "(int)len"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/zlib.h>\n#include <asm/page.h>\n#include <asm/cacheflush.h>\n#include <asm/unaligned.h>\n#include <asm/uaccess.h>\n#include <asm/byteorder.h>\n#include <linux/syscalls.h>\n#include <linux/flat.h>\n#include <linux/init.h>\n#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/slab.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\n#define RESERVED     0xC0 /* bit 6,7:   reserved */\n#define ENCRYPTED    0x20 /* bit 5 set: file is encrypted */\n#define COMMENT      0x10 /* bit 4 set: file comment present */\n#define ORIG_NAME    0x08 /* bit 3 set: original file name present */\n#define EXTRA_FIELD  0x04 /* bit 2 set: extra field present */\n#define CONTINUATION 0x02 /* bit 1 set: continuation of multi-part gzip file */\n#define LBUFSIZE\t4000\n\nstatic int load_flat_binary(struct linux_binprm *);\n\nstatic int decompress_exec(\n\tstruct linux_binprm *bprm,\n\tunsigned long offset,\n\tchar *dst,\n\tlong len,\n\tint fd)\n{\n\tunsigned char *buf;\n\tz_stream strm;\n\tloff_t fpos;\n\tint ret, retval;\n\n\tDBG_FLT(\"decompress_exec(offset=%x,buf=%x,len=%x)\\n\",(int)offset, (int)dst, (int)len);\n\n\tmemset(&strm, 0, sizeof(strm));\n\tstrm.workspace = kmalloc(zlib_inflate_workspacesize(), GFP_KERNEL);\n\tif (strm.workspace == NULL) {\n\t\tDBG_FLT(\"binfmt_flat: no memory for decompress workspace\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tbuf = kmalloc(LBUFSIZE, GFP_KERNEL);\n\tif (buf == NULL) {\n\t\tDBG_FLT(\"binfmt_flat: no memory for read buffer\\n\");\n\t\tretval = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\t/* Read in first chunk of data and parse gzip header. */\n\tfpos = offset;\n\tret = kernel_read(bprm->file, offset, buf, LBUFSIZE);\n\n\tstrm.next_in = buf;\n\tstrm.avail_in = ret;\n\tstrm.total_in = 0;\n\tfpos += ret;\n\n\tretval = -ENOEXEC;\n\n\t/* Check minimum size -- gzip header */\n\tif (ret < 10) {\n\t\tDBG_FLT(\"binfmt_flat: file too small?\\n\");\n\t\tgoto out_free_buf;\n\t}\n\n\t/* Check gzip magic number */\n\tif ((buf[0] != 037) || ((buf[1] != 0213) && (buf[1] != 0236))) {\n\t\tDBG_FLT(\"binfmt_flat: unknown compression magic?\\n\");\n\t\tgoto out_free_buf;\n\t}\n\n\t/* Check gzip method */\n\tif (buf[2] != 8) {\n\t\tDBG_FLT(\"binfmt_flat: unknown compression method?\\n\");\n\t\tgoto out_free_buf;\n\t}\n\t/* Check gzip flags */\n\tif ((buf[3] & ENCRYPTED) || (buf[3] & CONTINUATION) ||\n\t    (buf[3] & RESERVED)) {\n\t\tDBG_FLT(\"binfmt_flat: unknown flags?\\n\");\n\t\tgoto out_free_buf;\n\t}\n\n\tret = 10;\n\tif (buf[3] & EXTRA_FIELD) {\n\t\tret += 2 + buf[10] + (buf[11] << 8);\n\t\tif (unlikely(LBUFSIZE <= ret)) {\n\t\t\tDBG_FLT(\"binfmt_flat: buffer overflow (EXTRA)?\\n\");\n\t\t\tgoto out_free_buf;\n\t\t}\n\t}\n\tif (buf[3] & ORIG_NAME) {\n\t\twhile (ret < LBUFSIZE && buf[ret++] != 0)\n\t\t\t;\n\t\tif (unlikely(LBUFSIZE == ret)) {\n\t\t\tDBG_FLT(\"binfmt_flat: buffer overflow (ORIG_NAME)?\\n\");\n\t\t\tgoto out_free_buf;\n\t\t}\n\t}\n\tif (buf[3] & COMMENT) {\n\t\twhile (ret < LBUFSIZE && buf[ret++] != 0)\n\t\t\t;\n\t\tif (unlikely(LBUFSIZE == ret)) {\n\t\t\tDBG_FLT(\"binfmt_flat: buffer overflow (COMMENT)?\\n\");\n\t\t\tgoto out_free_buf;\n\t\t}\n\t}\n\n\tstrm.next_in += ret;\n\tstrm.avail_in -= ret;\n\n\tstrm.next_out = dst;\n\tstrm.avail_out = len;\n\tstrm.total_out = 0;\n\n\tif (zlib_inflateInit2(&strm, -MAX_WBITS) != Z_OK) {\n\t\tDBG_FLT(\"binfmt_flat: zlib init failed?\\n\");\n\t\tgoto out_free_buf;\n\t}\n\n\twhile ((ret = zlib_inflate(&strm, Z_NO_FLUSH)) == Z_OK) {\n\t\tret = kernel_read(bprm->file, fpos, buf, LBUFSIZE);\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\t\tlen -= ret;\n\n\t\tstrm.next_in = buf;\n\t\tstrm.avail_in = ret;\n\t\tstrm.total_in = 0;\n\t\tfpos += ret;\n\t}\n\n\tif (ret < 0) {\n\t\tDBG_FLT(\"binfmt_flat: decompression failed (%d), %s\\n\",\n\t\t\tret, strm.msg);\n\t\tgoto out_zlib;\n\t}\n\n\tretval = 0;\nout_zlib:\n\tzlib_inflateEnd(&strm);\nout_free_buf:\n\tkfree(buf);\nout_free:\n\tkfree(strm.workspace);\n\treturn retval;\n}"
  },
  {
    "function_name": "create_flat_tables",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_flat.c",
    "lines": "121-162",
    "snippet": "static unsigned long create_flat_tables(\n\tunsigned long pp,\n\tstruct linux_binprm * bprm)\n{\n\tunsigned long *argv,*envp;\n\tunsigned long * sp;\n\tchar * p = (char*)pp;\n\tint argc = bprm->argc;\n\tint envc = bprm->envc;\n\tchar uninitialized_var(dummy);\n\n\tsp = (unsigned long *)p;\n\tsp -= (envc + argc + 2) + 1 + (flat_argvp_envp_on_stack() ? 2 : 0);\n\tsp = (unsigned long *) ((unsigned long)sp & -FLAT_STACK_ALIGN);\n\targv = sp + 1 + (flat_argvp_envp_on_stack() ? 2 : 0);\n\tenvp = argv + (argc + 1);\n\n\tif (flat_argvp_envp_on_stack()) {\n\t\tput_user((unsigned long) envp, sp + 2);\n\t\tput_user((unsigned long) argv, sp + 1);\n\t}\n\n\tput_user(argc, sp);\n\tcurrent->mm->arg_start = (unsigned long) p;\n\twhile (argc-->0) {\n\t\tput_user((unsigned long) p, argv++);\n\t\tdo {\n\t\t\tget_user(dummy, p); p++;\n\t\t} while (dummy);\n\t}\n\tput_user((unsigned long) NULL, argv);\n\tcurrent->mm->arg_end = current->mm->env_start = (unsigned long) p;\n\twhile (envc-->0) {\n\t\tput_user((unsigned long)p, envp); envp++;\n\t\tdo {\n\t\t\tget_user(dummy, p); p++;\n\t\t} while (dummy);\n\t}\n\tput_user((unsigned long) NULL, envp);\n\tcurrent->mm->env_end = (unsigned long) p;\n\treturn (unsigned long)sp;\n}",
    "includes": [
      "#include <linux/zlib.h>",
      "#include <asm/page.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/unaligned.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/flat.h>",
      "#include <linux/init.h>",
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/slab.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [
      "#define FLAT_STACK_ALIGN\tmax_t(unsigned long, sizeof(void *), ARCH_SLAB_MINALIGN)"
    ],
    "globals_used": [
      "static int load_flat_binary(struct linux_binprm *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "(unsigned long) NULL",
            "envp"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "dummy",
            "p"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_arg_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "399-418",
          "snippet": "static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "(unsigned long)p",
            "envp"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "(unsigned long) NULL",
            "argv"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "(unsigned long) p",
            "argv++"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "argc",
            "sp"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "(unsigned long) argv",
            "sp + 1"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "(unsigned long) envp",
            "sp + 2"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flat_argvp_envp_on_stack",
          "args": [],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flat_argvp_envp_on_stack",
          "args": [],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flat_argvp_envp_on_stack",
          "args": [],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/zlib.h>\n#include <asm/page.h>\n#include <asm/cacheflush.h>\n#include <asm/unaligned.h>\n#include <asm/uaccess.h>\n#include <asm/byteorder.h>\n#include <linux/syscalls.h>\n#include <linux/flat.h>\n#include <linux/init.h>\n#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/slab.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\n#define FLAT_STACK_ALIGN\tmax_t(unsigned long, sizeof(void *), ARCH_SLAB_MINALIGN)\n\nstatic int load_flat_binary(struct linux_binprm *);\n\nstatic unsigned long create_flat_tables(\n\tunsigned long pp,\n\tstruct linux_binprm * bprm)\n{\n\tunsigned long *argv,*envp;\n\tunsigned long * sp;\n\tchar * p = (char*)pp;\n\tint argc = bprm->argc;\n\tint envc = bprm->envc;\n\tchar uninitialized_var(dummy);\n\n\tsp = (unsigned long *)p;\n\tsp -= (envc + argc + 2) + 1 + (flat_argvp_envp_on_stack() ? 2 : 0);\n\tsp = (unsigned long *) ((unsigned long)sp & -FLAT_STACK_ALIGN);\n\targv = sp + 1 + (flat_argvp_envp_on_stack() ? 2 : 0);\n\tenvp = argv + (argc + 1);\n\n\tif (flat_argvp_envp_on_stack()) {\n\t\tput_user((unsigned long) envp, sp + 2);\n\t\tput_user((unsigned long) argv, sp + 1);\n\t}\n\n\tput_user(argc, sp);\n\tcurrent->mm->arg_start = (unsigned long) p;\n\twhile (argc-->0) {\n\t\tput_user((unsigned long) p, argv++);\n\t\tdo {\n\t\t\tget_user(dummy, p); p++;\n\t\t} while (dummy);\n\t}\n\tput_user((unsigned long) NULL, argv);\n\tcurrent->mm->arg_end = current->mm->env_start = (unsigned long) p;\n\twhile (envc-->0) {\n\t\tput_user((unsigned long)p, envp); envp++;\n\t\tdo {\n\t\t\tget_user(dummy, p); p++;\n\t\t} while (dummy);\n\t}\n\tput_user((unsigned long) NULL, envp);\n\tcurrent->mm->env_end = (unsigned long) p;\n\treturn (unsigned long)sp;\n}"
  },
  {
    "function_name": "flat_core_dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_flat.c",
    "lines": "107-112",
    "snippet": "static int flat_core_dump(struct coredump_params *cprm)\n{\n\tprintk(\"Process %s:%d received signr %d and should have core dumped\\n\",\n\t\t\tcurrent->comm, current->pid, (int) cprm->siginfo->si_signo);\n\treturn(1);\n}",
    "includes": [
      "#include <linux/zlib.h>",
      "#include <asm/page.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/unaligned.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/flat.h>",
      "#include <linux/init.h>",
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/slab.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int flat_core_dump(struct coredump_params *cprm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Process %s:%d received signr %d and should have core dumped\\n\"",
            "current->comm",
            "current->pid",
            "(int) cprm->siginfo->si_signo"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/zlib.h>\n#include <asm/page.h>\n#include <asm/cacheflush.h>\n#include <asm/unaligned.h>\n#include <asm/uaccess.h>\n#include <asm/byteorder.h>\n#include <linux/syscalls.h>\n#include <linux/flat.h>\n#include <linux/init.h>\n#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/slab.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int flat_core_dump(struct coredump_params *cprm);\n\nstatic int flat_core_dump(struct coredump_params *cprm)\n{\n\tprintk(\"Process %s:%d received signr %d and should have core dumped\\n\",\n\t\t\tcurrent->comm, current->pid, (int) cprm->siginfo->si_signo);\n\treturn(1);\n}"
  }
]