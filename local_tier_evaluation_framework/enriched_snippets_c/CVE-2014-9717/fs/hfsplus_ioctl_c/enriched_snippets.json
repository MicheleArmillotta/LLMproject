[
  {
    "function_name": "hfsplus_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/ioctl.c",
    "lines": "138-152",
    "snippet": "long hfsplus_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\n\tswitch (cmd) {\n\tcase HFSPLUS_IOC_EXT2_GETFLAGS:\n\t\treturn hfsplus_ioctl_getflags(file, argp);\n\tcase HFSPLUS_IOC_EXT2_SETFLAGS:\n\t\treturn hfsplus_ioctl_setflags(file, argp);\n\tcase HFSPLUS_IOC_BLESS:\n\t\treturn hfsplus_ioctl_bless(file, argp);\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}",
    "includes": [
      "#include \"hfsplus_fs.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfsplus_ioctl_bless",
          "args": [
            "file",
            "argp"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_ioctl_bless",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/ioctl.c",
          "lines": "26-57",
          "snippet": "static int hfsplus_ioctl_bless(struct file *file, int __user *user_flags)\n{\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(inode->i_sb);\n\tstruct hfsplus_vh *vh = sbi->s_vhdr;\n\tstruct hfsplus_vh *bvh = sbi->s_backup_vhdr;\n\tu32 cnid = (unsigned long)dentry->d_fsdata;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tmutex_lock(&sbi->vh_mutex);\n\n\t/* Directory containing the bootable system */\n\tvh->finder_info[0] = bvh->finder_info[0] =\n\t\tcpu_to_be32(parent_ino(dentry));\n\n\t/*\n\t * Bootloader. Just using the inode here breaks in the case of\n\t * hard links - the firmware wants the ID of the hard link file,\n\t * but the inode points at the indirect inode\n\t */\n\tvh->finder_info[1] = bvh->finder_info[1] = cpu_to_be32(cnid);\n\n\t/* Per spec, the OS X system folder - same as finder_info[0] here */\n\tvh->finder_info[5] = bvh->finder_info[5] =\n\t\tcpu_to_be32(parent_ino(dentry));\n\n\tmutex_unlock(&sbi->vh_mutex);\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int hfsplus_ioctl_bless(struct file *file, int __user *user_flags)\n{\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(inode->i_sb);\n\tstruct hfsplus_vh *vh = sbi->s_vhdr;\n\tstruct hfsplus_vh *bvh = sbi->s_backup_vhdr;\n\tu32 cnid = (unsigned long)dentry->d_fsdata;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tmutex_lock(&sbi->vh_mutex);\n\n\t/* Directory containing the bootable system */\n\tvh->finder_info[0] = bvh->finder_info[0] =\n\t\tcpu_to_be32(parent_ino(dentry));\n\n\t/*\n\t * Bootloader. Just using the inode here breaks in the case of\n\t * hard links - the firmware wants the ID of the hard link file,\n\t * but the inode points at the indirect inode\n\t */\n\tvh->finder_info[1] = bvh->finder_info[1] = cpu_to_be32(cnid);\n\n\t/* Per spec, the OS X system folder - same as finder_info[0] here */\n\tvh->finder_info[5] = bvh->finder_info[5] =\n\t\tcpu_to_be32(parent_ino(dentry));\n\n\tmutex_unlock(&sbi->vh_mutex);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_ioctl_setflags",
          "args": [
            "file",
            "argp"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_ioctl_setflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/ioctl.c",
          "lines": "75-136",
          "snippet": "static int hfsplus_ioctl_setflags(struct file *file, int __user *user_flags)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tunsigned int flags;\n\tint err = 0;\n\n\terr = mnt_want_write_file(file);\n\tif (err)\n\t\tgoto out;\n\n\tif (!inode_owner_or_capable(inode)) {\n\t\terr = -EACCES;\n\t\tgoto out_drop_write;\n\t}\n\n\tif (get_user(flags, user_flags)) {\n\t\terr = -EFAULT;\n\t\tgoto out_drop_write;\n\t}\n\n\tmutex_lock(&inode->i_mutex);\n\n\tif ((flags & (FS_IMMUTABLE_FL|FS_APPEND_FL)) ||\n\t    inode->i_flags & (S_IMMUTABLE|S_APPEND)) {\n\t\tif (!capable(CAP_LINUX_IMMUTABLE)) {\n\t\t\terr = -EPERM;\n\t\t\tgoto out_unlock_inode;\n\t\t}\n\t}\n\n\t/* don't silently ignore unsupported ext2 flags */\n\tif (flags & ~(FS_IMMUTABLE_FL|FS_APPEND_FL|FS_NODUMP_FL)) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_unlock_inode;\n\t}\n\n\tif (flags & FS_IMMUTABLE_FL)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\telse\n\t\tinode->i_flags &= ~S_IMMUTABLE;\n\n\tif (flags & FS_APPEND_FL)\n\t\tinode->i_flags |= S_APPEND;\n\telse\n\t\tinode->i_flags &= ~S_APPEND;\n\n\tif (flags & FS_NODUMP_FL)\n\t\thip->userflags |= HFSPLUS_FLG_NODUMP;\n\telse\n\t\thip->userflags &= ~HFSPLUS_FLG_NODUMP;\n\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\n\nout_unlock_inode:\n\tmutex_unlock(&inode->i_mutex);\nout_drop_write:\n\tmnt_drop_write_file(file);\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int hfsplus_ioctl_setflags(struct file *file, int __user *user_flags)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tunsigned int flags;\n\tint err = 0;\n\n\terr = mnt_want_write_file(file);\n\tif (err)\n\t\tgoto out;\n\n\tif (!inode_owner_or_capable(inode)) {\n\t\terr = -EACCES;\n\t\tgoto out_drop_write;\n\t}\n\n\tif (get_user(flags, user_flags)) {\n\t\terr = -EFAULT;\n\t\tgoto out_drop_write;\n\t}\n\n\tmutex_lock(&inode->i_mutex);\n\n\tif ((flags & (FS_IMMUTABLE_FL|FS_APPEND_FL)) ||\n\t    inode->i_flags & (S_IMMUTABLE|S_APPEND)) {\n\t\tif (!capable(CAP_LINUX_IMMUTABLE)) {\n\t\t\terr = -EPERM;\n\t\t\tgoto out_unlock_inode;\n\t\t}\n\t}\n\n\t/* don't silently ignore unsupported ext2 flags */\n\tif (flags & ~(FS_IMMUTABLE_FL|FS_APPEND_FL|FS_NODUMP_FL)) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_unlock_inode;\n\t}\n\n\tif (flags & FS_IMMUTABLE_FL)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\telse\n\t\tinode->i_flags &= ~S_IMMUTABLE;\n\n\tif (flags & FS_APPEND_FL)\n\t\tinode->i_flags |= S_APPEND;\n\telse\n\t\tinode->i_flags &= ~S_APPEND;\n\n\tif (flags & FS_NODUMP_FL)\n\t\thip->userflags |= HFSPLUS_FLG_NODUMP;\n\telse\n\t\thip->userflags &= ~HFSPLUS_FLG_NODUMP;\n\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\n\nout_unlock_inode:\n\tmutex_unlock(&inode->i_mutex);\nout_drop_write:\n\tmnt_drop_write_file(file);\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_ioctl_getflags",
          "args": [
            "file",
            "argp"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_ioctl_getflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/ioctl.c",
          "lines": "59-73",
          "snippet": "static int hfsplus_ioctl_getflags(struct file *file, int __user *user_flags)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tunsigned int flags = 0;\n\n\tif (inode->i_flags & S_IMMUTABLE)\n\t\tflags |= FS_IMMUTABLE_FL;\n\tif (inode->i_flags & S_APPEND)\n\t\tflags |= FS_APPEND_FL;\n\tif (hip->userflags & HFSPLUS_FLG_NODUMP)\n\t\tflags |= FS_NODUMP_FL;\n\n\treturn put_user(flags, user_flags);\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int hfsplus_ioctl_getflags(struct file *file, int __user *user_flags)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tunsigned int flags = 0;\n\n\tif (inode->i_flags & S_IMMUTABLE)\n\t\tflags |= FS_IMMUTABLE_FL;\n\tif (inode->i_flags & S_APPEND)\n\t\tflags |= FS_APPEND_FL;\n\tif (hip->userflags & HFSPLUS_FLG_NODUMP)\n\t\tflags |= FS_NODUMP_FL;\n\n\treturn put_user(flags, user_flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nlong hfsplus_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\n\tswitch (cmd) {\n\tcase HFSPLUS_IOC_EXT2_GETFLAGS:\n\t\treturn hfsplus_ioctl_getflags(file, argp);\n\tcase HFSPLUS_IOC_EXT2_SETFLAGS:\n\t\treturn hfsplus_ioctl_setflags(file, argp);\n\tcase HFSPLUS_IOC_BLESS:\n\t\treturn hfsplus_ioctl_bless(file, argp);\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}"
  },
  {
    "function_name": "hfsplus_ioctl_setflags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/ioctl.c",
    "lines": "75-136",
    "snippet": "static int hfsplus_ioctl_setflags(struct file *file, int __user *user_flags)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tunsigned int flags;\n\tint err = 0;\n\n\terr = mnt_want_write_file(file);\n\tif (err)\n\t\tgoto out;\n\n\tif (!inode_owner_or_capable(inode)) {\n\t\terr = -EACCES;\n\t\tgoto out_drop_write;\n\t}\n\n\tif (get_user(flags, user_flags)) {\n\t\terr = -EFAULT;\n\t\tgoto out_drop_write;\n\t}\n\n\tmutex_lock(&inode->i_mutex);\n\n\tif ((flags & (FS_IMMUTABLE_FL|FS_APPEND_FL)) ||\n\t    inode->i_flags & (S_IMMUTABLE|S_APPEND)) {\n\t\tif (!capable(CAP_LINUX_IMMUTABLE)) {\n\t\t\terr = -EPERM;\n\t\t\tgoto out_unlock_inode;\n\t\t}\n\t}\n\n\t/* don't silently ignore unsupported ext2 flags */\n\tif (flags & ~(FS_IMMUTABLE_FL|FS_APPEND_FL|FS_NODUMP_FL)) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_unlock_inode;\n\t}\n\n\tif (flags & FS_IMMUTABLE_FL)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\telse\n\t\tinode->i_flags &= ~S_IMMUTABLE;\n\n\tif (flags & FS_APPEND_FL)\n\t\tinode->i_flags |= S_APPEND;\n\telse\n\t\tinode->i_flags &= ~S_APPEND;\n\n\tif (flags & FS_NODUMP_FL)\n\t\thip->userflags |= HFSPLUS_FLG_NODUMP;\n\telse\n\t\thip->userflags &= ~HFSPLUS_FLG_NODUMP;\n\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\n\nout_unlock_inode:\n\tmutex_unlock(&inode->i_mutex);\nout_drop_write:\n\tmnt_drop_write_file(file);\nout:\n\treturn err;\n}",
    "includes": [
      "#include \"hfsplus_fs.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "file"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_LINUX_IMMUTABLE"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "flags",
            "user_flags"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_arg_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "399-418",
          "snippet": "static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "file"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_I",
          "args": [
            "inode"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "264-267",
          "snippet": "static inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int hfsplus_ioctl_setflags(struct file *file, int __user *user_flags)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tunsigned int flags;\n\tint err = 0;\n\n\terr = mnt_want_write_file(file);\n\tif (err)\n\t\tgoto out;\n\n\tif (!inode_owner_or_capable(inode)) {\n\t\terr = -EACCES;\n\t\tgoto out_drop_write;\n\t}\n\n\tif (get_user(flags, user_flags)) {\n\t\terr = -EFAULT;\n\t\tgoto out_drop_write;\n\t}\n\n\tmutex_lock(&inode->i_mutex);\n\n\tif ((flags & (FS_IMMUTABLE_FL|FS_APPEND_FL)) ||\n\t    inode->i_flags & (S_IMMUTABLE|S_APPEND)) {\n\t\tif (!capable(CAP_LINUX_IMMUTABLE)) {\n\t\t\terr = -EPERM;\n\t\t\tgoto out_unlock_inode;\n\t\t}\n\t}\n\n\t/* don't silently ignore unsupported ext2 flags */\n\tif (flags & ~(FS_IMMUTABLE_FL|FS_APPEND_FL|FS_NODUMP_FL)) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_unlock_inode;\n\t}\n\n\tif (flags & FS_IMMUTABLE_FL)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\telse\n\t\tinode->i_flags &= ~S_IMMUTABLE;\n\n\tif (flags & FS_APPEND_FL)\n\t\tinode->i_flags |= S_APPEND;\n\telse\n\t\tinode->i_flags &= ~S_APPEND;\n\n\tif (flags & FS_NODUMP_FL)\n\t\thip->userflags |= HFSPLUS_FLG_NODUMP;\n\telse\n\t\thip->userflags &= ~HFSPLUS_FLG_NODUMP;\n\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\n\nout_unlock_inode:\n\tmutex_unlock(&inode->i_mutex);\nout_drop_write:\n\tmnt_drop_write_file(file);\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "hfsplus_ioctl_getflags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/ioctl.c",
    "lines": "59-73",
    "snippet": "static int hfsplus_ioctl_getflags(struct file *file, int __user *user_flags)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tunsigned int flags = 0;\n\n\tif (inode->i_flags & S_IMMUTABLE)\n\t\tflags |= FS_IMMUTABLE_FL;\n\tif (inode->i_flags & S_APPEND)\n\t\tflags |= FS_APPEND_FL;\n\tif (hip->userflags & HFSPLUS_FLG_NODUMP)\n\t\tflags |= FS_NODUMP_FL;\n\n\treturn put_user(flags, user_flags);\n}",
    "includes": [
      "#include \"hfsplus_fs.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "flags",
            "user_flags"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFSPLUS_I",
          "args": [
            "inode"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "264-267",
          "snippet": "static inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int hfsplus_ioctl_getflags(struct file *file, int __user *user_flags)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tunsigned int flags = 0;\n\n\tif (inode->i_flags & S_IMMUTABLE)\n\t\tflags |= FS_IMMUTABLE_FL;\n\tif (inode->i_flags & S_APPEND)\n\t\tflags |= FS_APPEND_FL;\n\tif (hip->userflags & HFSPLUS_FLG_NODUMP)\n\t\tflags |= FS_NODUMP_FL;\n\n\treturn put_user(flags, user_flags);\n}"
  },
  {
    "function_name": "hfsplus_ioctl_bless",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/ioctl.c",
    "lines": "26-57",
    "snippet": "static int hfsplus_ioctl_bless(struct file *file, int __user *user_flags)\n{\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(inode->i_sb);\n\tstruct hfsplus_vh *vh = sbi->s_vhdr;\n\tstruct hfsplus_vh *bvh = sbi->s_backup_vhdr;\n\tu32 cnid = (unsigned long)dentry->d_fsdata;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tmutex_lock(&sbi->vh_mutex);\n\n\t/* Directory containing the bootable system */\n\tvh->finder_info[0] = bvh->finder_info[0] =\n\t\tcpu_to_be32(parent_ino(dentry));\n\n\t/*\n\t * Bootloader. Just using the inode here breaks in the case of\n\t * hard links - the firmware wants the ID of the hard link file,\n\t * but the inode points at the indirect inode\n\t */\n\tvh->finder_info[1] = bvh->finder_info[1] = cpu_to_be32(cnid);\n\n\t/* Per spec, the OS X system folder - same as finder_info[0] here */\n\tvh->finder_info[5] = bvh->finder_info[5] =\n\t\tcpu_to_be32(parent_ino(dentry));\n\n\tmutex_unlock(&sbi->vh_mutex);\n\treturn 0;\n}",
    "includes": [
      "#include \"hfsplus_fs.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->vh_mutex"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "parent_ino(dentry)"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parent_ino",
          "args": [
            "dentry"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_parent_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "376-389",
          "snippet": "ino_t exofs_parent_ino(struct dentry *child)\n{\n\tstruct page *page;\n\tstruct exofs_dir_entry *de;\n\tino_t ino;\n\n\tde = exofs_dotdot(child->d_inode, &page);\n\tif (!de)\n\t\treturn 0;\n\n\tino = le64_to_cpu(de->inode_no);\n\texofs_put_page(page);\n\treturn ino;\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\nino_t exofs_parent_ino(struct dentry *child)\n{\n\tstruct page *page;\n\tstruct exofs_dir_entry *de;\n\tino_t ino;\n\n\tde = exofs_dotdot(child->d_inode, &page);\n\tif (!de)\n\t\treturn 0;\n\n\tino = le64_to_cpu(de->inode_no);\n\texofs_put_page(page);\n\treturn ino;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "cnid"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "parent_ino(dentry)"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sbi->vh_mutex"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 30
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int hfsplus_ioctl_bless(struct file *file, int __user *user_flags)\n{\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(inode->i_sb);\n\tstruct hfsplus_vh *vh = sbi->s_vhdr;\n\tstruct hfsplus_vh *bvh = sbi->s_backup_vhdr;\n\tu32 cnid = (unsigned long)dentry->d_fsdata;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tmutex_lock(&sbi->vh_mutex);\n\n\t/* Directory containing the bootable system */\n\tvh->finder_info[0] = bvh->finder_info[0] =\n\t\tcpu_to_be32(parent_ino(dentry));\n\n\t/*\n\t * Bootloader. Just using the inode here breaks in the case of\n\t * hard links - the firmware wants the ID of the hard link file,\n\t * but the inode points at the indirect inode\n\t */\n\tvh->finder_info[1] = bvh->finder_info[1] = cpu_to_be32(cnid);\n\n\t/* Per spec, the OS X system folder - same as finder_info[0] here */\n\tvh->finder_info[5] = bvh->finder_info[5] =\n\t\tcpu_to_be32(parent_ino(dentry));\n\n\tmutex_unlock(&sbi->vh_mutex);\n\treturn 0;\n}"
  }
]