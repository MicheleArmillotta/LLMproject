[
  {
    "function_name": "nfs4_deviceid_mark_client_invalid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_dev.c",
    "lines": "347-360",
    "snippet": "void\nnfs4_deviceid_mark_client_invalid(struct nfs_client *clp)\n{\n\tstruct nfs4_deviceid_node *d;\n\tint i;\n\n\trcu_read_lock();\n\tfor (i = 0; i < NFS4_DEVICE_ID_HASH_SIZE; i ++){\n\t\thlist_for_each_entry_rcu(d, &nfs4_deviceid_cache[i], node)\n\t\t\tif (d->nfs_client == clp)\n\t\t\t\tset_bit(NFS_DEVICEID_INVALID, &d->flags);\n\t}\n\trcu_read_unlock();\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4session.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [
      "#define NFS4_DEVICE_ID_HASH_SIZE\t(1 << NFS4_DEVICE_ID_HASH_BITS)"
    ],
    "globals_used": [
      "static struct hlist_head nfs4_deviceid_cache[NFS4_DEVICE_ID_HASH_SIZE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFS_DEVICEID_INVALID",
            "&d->flags"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu",
          "args": [
            "d",
            "&nfs4_deviceid_cache[i]",
            "node"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/nfs_fs.h>\n#include <linux/export.h>\n\n#define NFS4_DEVICE_ID_HASH_SIZE\t(1 << NFS4_DEVICE_ID_HASH_BITS)\n\nstatic struct hlist_head nfs4_deviceid_cache[NFS4_DEVICE_ID_HASH_SIZE];\n\nvoid\nnfs4_deviceid_mark_client_invalid(struct nfs_client *clp)\n{\n\tstruct nfs4_deviceid_node *d;\n\tint i;\n\n\trcu_read_lock();\n\tfor (i = 0; i < NFS4_DEVICE_ID_HASH_SIZE; i ++){\n\t\thlist_for_each_entry_rcu(d, &nfs4_deviceid_cache[i], node)\n\t\t\tif (d->nfs_client == clp)\n\t\t\t\tset_bit(NFS_DEVICEID_INVALID, &d->flags);\n\t}\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "nfs4_deviceid_purge_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_dev.c",
    "lines": "333-342",
    "snippet": "void\nnfs4_deviceid_purge_client(const struct nfs_client *clp)\n{\n\tlong h;\n\n\tif (!(clp->cl_exchange_flags & EXCHGID4_FLAG_USE_PNFS_MDS))\n\t\treturn;\n\tfor (h = 0; h < NFS4_DEVICE_ID_HASH_SIZE; h++)\n\t\t_deviceid_purge_client(clp, h);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4session.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [
      "#define NFS4_DEVICE_ID_HASH_SIZE\t(1 << NFS4_DEVICE_ID_HASH_BITS)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_deviceid_purge_client",
          "args": [
            "clp",
            "h"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "_deviceid_purge_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_dev.c",
          "lines": "305-331",
          "snippet": "static void\n_deviceid_purge_client(const struct nfs_client *clp, long hash)\n{\n\tstruct nfs4_deviceid_node *d;\n\tHLIST_HEAD(tmp);\n\n\tspin_lock(&nfs4_deviceid_lock);\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(d, &nfs4_deviceid_cache[hash], node)\n\t\tif (d->nfs_client == clp && atomic_read(&d->ref)) {\n\t\t\thlist_del_init_rcu(&d->node);\n\t\t\thlist_add_head(&d->tmpnode, &tmp);\n\t\t}\n\trcu_read_unlock();\n\tspin_unlock(&nfs4_deviceid_lock);\n\n\tif (hlist_empty(&tmp))\n\t\treturn;\n\n\tsynchronize_rcu();\n\twhile (!hlist_empty(&tmp)) {\n\t\td = hlist_entry(tmp.first, struct nfs4_deviceid_node, tmpnode);\n\t\thlist_del(&d->tmpnode);\n\t\tif (atomic_dec_and_test(&d->ref))\n\t\t\td->ld->free_deviceid_node(d);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head nfs4_deviceid_cache[NFS4_DEVICE_ID_HASH_SIZE];",
            "static DEFINE_SPINLOCK(nfs4_deviceid_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/nfs_fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head nfs4_deviceid_cache[NFS4_DEVICE_ID_HASH_SIZE];\nstatic DEFINE_SPINLOCK(nfs4_deviceid_lock);\n\nstatic void\n_deviceid_purge_client(const struct nfs_client *clp, long hash)\n{\n\tstruct nfs4_deviceid_node *d;\n\tHLIST_HEAD(tmp);\n\n\tspin_lock(&nfs4_deviceid_lock);\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(d, &nfs4_deviceid_cache[hash], node)\n\t\tif (d->nfs_client == clp && atomic_read(&d->ref)) {\n\t\t\thlist_del_init_rcu(&d->node);\n\t\t\thlist_add_head(&d->tmpnode, &tmp);\n\t\t}\n\trcu_read_unlock();\n\tspin_unlock(&nfs4_deviceid_lock);\n\n\tif (hlist_empty(&tmp))\n\t\treturn;\n\n\tsynchronize_rcu();\n\twhile (!hlist_empty(&tmp)) {\n\t\td = hlist_entry(tmp.first, struct nfs4_deviceid_node, tmpnode);\n\t\thlist_del(&d->tmpnode);\n\t\tif (atomic_dec_and_test(&d->ref))\n\t\t\td->ld->free_deviceid_node(d);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/nfs_fs.h>\n#include <linux/export.h>\n\n#define NFS4_DEVICE_ID_HASH_SIZE\t(1 << NFS4_DEVICE_ID_HASH_BITS)\n\nvoid\nnfs4_deviceid_purge_client(const struct nfs_client *clp)\n{\n\tlong h;\n\n\tif (!(clp->cl_exchange_flags & EXCHGID4_FLAG_USE_PNFS_MDS))\n\t\treturn;\n\tfor (h = 0; h < NFS4_DEVICE_ID_HASH_SIZE; h++)\n\t\t_deviceid_purge_client(clp, h);\n}"
  },
  {
    "function_name": "_deviceid_purge_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_dev.c",
    "lines": "305-331",
    "snippet": "static void\n_deviceid_purge_client(const struct nfs_client *clp, long hash)\n{\n\tstruct nfs4_deviceid_node *d;\n\tHLIST_HEAD(tmp);\n\n\tspin_lock(&nfs4_deviceid_lock);\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(d, &nfs4_deviceid_cache[hash], node)\n\t\tif (d->nfs_client == clp && atomic_read(&d->ref)) {\n\t\t\thlist_del_init_rcu(&d->node);\n\t\t\thlist_add_head(&d->tmpnode, &tmp);\n\t\t}\n\trcu_read_unlock();\n\tspin_unlock(&nfs4_deviceid_lock);\n\n\tif (hlist_empty(&tmp))\n\t\treturn;\n\n\tsynchronize_rcu();\n\twhile (!hlist_empty(&tmp)) {\n\t\td = hlist_entry(tmp.first, struct nfs4_deviceid_node, tmpnode);\n\t\thlist_del(&d->tmpnode);\n\t\tif (atomic_dec_and_test(&d->ref))\n\t\t\td->ld->free_deviceid_node(d);\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4session.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hlist_head nfs4_deviceid_cache[NFS4_DEVICE_ID_HASH_SIZE];",
      "static DEFINE_SPINLOCK(nfs4_deviceid_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "d->ld->free_deviceid_node",
          "args": [
            "d"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&d->ref"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_del",
          "args": [
            "&d->tmpnode"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_entry",
          "args": [
            "tmp.first",
            "structnfs4_deviceid_node",
            "tmpnode"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "&tmp"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "&tmp"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nfs4_deviceid_lock"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&d->tmpnode",
            "&tmp"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_del_init_rcu",
          "args": [
            "&d->node"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&d->ref"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu",
          "args": [
            "d",
            "&nfs4_deviceid_cache[hash]",
            "node"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nfs4_deviceid_lock"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "HLIST_HEAD",
          "args": [
            "tmp"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/nfs_fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head nfs4_deviceid_cache[NFS4_DEVICE_ID_HASH_SIZE];\nstatic DEFINE_SPINLOCK(nfs4_deviceid_lock);\n\nstatic void\n_deviceid_purge_client(const struct nfs_client *clp, long hash)\n{\n\tstruct nfs4_deviceid_node *d;\n\tHLIST_HEAD(tmp);\n\n\tspin_lock(&nfs4_deviceid_lock);\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(d, &nfs4_deviceid_cache[hash], node)\n\t\tif (d->nfs_client == clp && atomic_read(&d->ref)) {\n\t\t\thlist_del_init_rcu(&d->node);\n\t\t\thlist_add_head(&d->tmpnode, &tmp);\n\t\t}\n\trcu_read_unlock();\n\tspin_unlock(&nfs4_deviceid_lock);\n\n\tif (hlist_empty(&tmp))\n\t\treturn;\n\n\tsynchronize_rcu();\n\twhile (!hlist_empty(&tmp)) {\n\t\td = hlist_entry(tmp.first, struct nfs4_deviceid_node, tmpnode);\n\t\thlist_del(&d->tmpnode);\n\t\tif (atomic_dec_and_test(&d->ref))\n\t\t\td->ld->free_deviceid_node(d);\n\t}\n}"
  },
  {
    "function_name": "nfs4_test_deviceid_unavailable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_dev.c",
    "lines": "289-302",
    "snippet": "bool\nnfs4_test_deviceid_unavailable(struct nfs4_deviceid_node *node)\n{\n\tif (test_bit(NFS_DEVICEID_UNAVAILABLE, &node->flags)) {\n\t\tunsigned long start, end;\n\n\t\tend = jiffies;\n\t\tstart = end - PNFS_DEVICE_RETRY_TIMEOUT;\n\t\tif (time_in_range(node->timestamp_unavailable, start, end))\n\t\t\treturn true;\n\t\tclear_bit(NFS_DEVICEID_UNAVAILABLE, &node->flags);\n\t}\n\treturn false;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4session.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [
      "#define PNFS_DEVICE_RETRY_TIMEOUT (120*HZ)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "NFS_DEVICEID_UNAVAILABLE",
            "&node->flags"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_in_range",
          "args": [
            "node->timestamp_unavailable",
            "start",
            "end"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS_DEVICEID_UNAVAILABLE",
            "&node->flags"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/nfs_fs.h>\n#include <linux/export.h>\n\n#define PNFS_DEVICE_RETRY_TIMEOUT (120*HZ)\n\nbool\nnfs4_test_deviceid_unavailable(struct nfs4_deviceid_node *node)\n{\n\tif (test_bit(NFS_DEVICEID_UNAVAILABLE, &node->flags)) {\n\t\tunsigned long start, end;\n\n\t\tend = jiffies;\n\t\tstart = end - PNFS_DEVICE_RETRY_TIMEOUT;\n\t\tif (time_in_range(node->timestamp_unavailable, start, end))\n\t\t\treturn true;\n\t\tclear_bit(NFS_DEVICEID_UNAVAILABLE, &node->flags);\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "nfs4_mark_deviceid_unavailable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_dev.c",
    "lines": "281-286",
    "snippet": "void\nnfs4_mark_deviceid_unavailable(struct nfs4_deviceid_node *node)\n{\n\tnode->timestamp_unavailable = jiffies;\n\tset_bit(NFS_DEVICEID_UNAVAILABLE, &node->flags);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4session.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFS_DEVICEID_UNAVAILABLE",
            "&node->flags"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/nfs_fs.h>\n#include <linux/export.h>\n\nvoid\nnfs4_mark_deviceid_unavailable(struct nfs4_deviceid_node *node)\n{\n\tnode->timestamp_unavailable = jiffies;\n\tset_bit(NFS_DEVICEID_UNAVAILABLE, &node->flags);\n}"
  },
  {
    "function_name": "nfs4_put_deviceid_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_dev.c",
    "lines": "271-278",
    "snippet": "bool\nnfs4_put_deviceid_node(struct nfs4_deviceid_node *d)\n{\n\tif (!atomic_dec_and_test(&d->ref))\n\t\treturn false;\n\td->ld->free_deviceid_node(d);\n\treturn true;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4session.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d->ld->free_deviceid_node",
          "args": [
            "d"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&d->ref"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/nfs_fs.h>\n#include <linux/export.h>\n\nbool\nnfs4_put_deviceid_node(struct nfs4_deviceid_node *d)\n{\n\tif (!atomic_dec_and_test(&d->ref))\n\t\treturn false;\n\td->ld->free_deviceid_node(d);\n\treturn true;\n}"
  },
  {
    "function_name": "nfs4_init_deviceid_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_dev.c",
    "lines": "247-258",
    "snippet": "void\nnfs4_init_deviceid_node(struct nfs4_deviceid_node *d, struct nfs_server *server,\n\t\t\tconst struct nfs4_deviceid *id)\n{\n\tINIT_HLIST_NODE(&d->node);\n\tINIT_HLIST_NODE(&d->tmpnode);\n\td->ld = server->pnfs_curr_ld;\n\td->nfs_client = server->nfs_client;\n\td->flags = 0;\n\td->deviceid = *id;\n\tatomic_set(&d->ref, 1);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4session.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&d->ref",
            "1"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_NODE",
          "args": [
            "&d->tmpnode"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_NODE",
          "args": [
            "&d->node"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/nfs_fs.h>\n#include <linux/export.h>\n\nvoid\nnfs4_init_deviceid_node(struct nfs4_deviceid_node *d, struct nfs_server *server,\n\t\t\tconst struct nfs4_deviceid *id)\n{\n\tINIT_HLIST_NODE(&d->node);\n\tINIT_HLIST_NODE(&d->tmpnode);\n\td->ld = server->pnfs_curr_ld;\n\td->nfs_client = server->nfs_client;\n\td->flags = 0;\n\td->deviceid = *id;\n\tatomic_set(&d->ref, 1);\n}"
  },
  {
    "function_name": "nfs4_delete_deviceid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_dev.c",
    "lines": "223-244",
    "snippet": "void\nnfs4_delete_deviceid(const struct pnfs_layoutdriver_type *ld,\n\t\t\t const struct nfs_client *clp, const struct nfs4_deviceid *id)\n{\n\tstruct nfs4_deviceid_node *d;\n\n\tspin_lock(&nfs4_deviceid_lock);\n\trcu_read_lock();\n\td = _lookup_deviceid(ld, clp, id, nfs4_deviceid_hash(id));\n\trcu_read_unlock();\n\tif (!d) {\n\t\tspin_unlock(&nfs4_deviceid_lock);\n\t\treturn;\n\t}\n\thlist_del_init_rcu(&d->node);\n\tspin_unlock(&nfs4_deviceid_lock);\n\tsynchronize_rcu();\n\n\t/* balance the initial ref set in pnfs_insert_deviceid */\n\tif (atomic_dec_and_test(&d->ref))\n\t\td->ld->free_deviceid_node(d);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4session.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(nfs4_deviceid_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "d->ld->free_deviceid_node",
          "args": [
            "d"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&d->ref"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nfs4_deviceid_lock"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_del_init_rcu",
          "args": [
            "&d->node"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_lookup_deviceid",
          "args": [
            "ld",
            "clp",
            "id",
            "nfs4_deviceid_hash(id)"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "_lookup_deviceid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_dev.c",
          "lines": "77-93",
          "snippet": "static struct nfs4_deviceid_node *\n_lookup_deviceid(const struct pnfs_layoutdriver_type *ld,\n\t\t const struct nfs_client *clp, const struct nfs4_deviceid *id,\n\t\t long hash)\n{\n\tstruct nfs4_deviceid_node *d;\n\n\thlist_for_each_entry_rcu(d, &nfs4_deviceid_cache[hash], node)\n\t\tif (d->ld == ld && d->nfs_client == clp &&\n\t\t    !memcmp(&d->deviceid, id, sizeof(*id))) {\n\t\t\tif (atomic_read(&d->ref))\n\t\t\t\treturn d;\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head nfs4_deviceid_cache[NFS4_DEVICE_ID_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/nfs_fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head nfs4_deviceid_cache[NFS4_DEVICE_ID_HASH_SIZE];\n\nstatic struct nfs4_deviceid_node *\n_lookup_deviceid(const struct pnfs_layoutdriver_type *ld,\n\t\t const struct nfs_client *clp, const struct nfs4_deviceid *id,\n\t\t long hash)\n{\n\tstruct nfs4_deviceid_node *d;\n\n\thlist_for_each_entry_rcu(d, &nfs4_deviceid_cache[hash], node)\n\t\tif (d->ld == ld && d->nfs_client == clp &&\n\t\t    !memcmp(&d->deviceid, id, sizeof(*id))) {\n\t\t\tif (atomic_read(&d->ref))\n\t\t\t\treturn d;\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_deviceid_hash",
          "args": [
            "id"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_deviceid_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_dev.c",
          "lines": "63-75",
          "snippet": "static inline u32\nnfs4_deviceid_hash(const struct nfs4_deviceid *id)\n{\n\tunsigned char *cptr = (unsigned char *)id->data;\n\tunsigned int nbytes = NFS4_DEVICEID4_SIZE;\n\tu32 x = 0;\n\n\twhile (nbytes--) {\n\t\tx *= 37;\n\t\tx += *cptr++;\n\t}\n\treturn x & NFS4_DEVICE_ID_HASH_MASK;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define NFS4_DEVICE_ID_HASH_MASK\t(NFS4_DEVICE_ID_HASH_SIZE - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/nfs_fs.h>\n#include <linux/export.h>\n\n#define NFS4_DEVICE_ID_HASH_MASK\t(NFS4_DEVICE_ID_HASH_SIZE - 1)\n\nstatic inline u32\nnfs4_deviceid_hash(const struct nfs4_deviceid *id)\n{\n\tunsigned char *cptr = (unsigned char *)id->data;\n\tunsigned int nbytes = NFS4_DEVICEID4_SIZE;\n\tu32 x = 0;\n\n\twhile (nbytes--) {\n\t\tx *= 37;\n\t\tx += *cptr++;\n\t}\n\treturn x & NFS4_DEVICE_ID_HASH_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nfs4_deviceid_lock"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/nfs_fs.h>\n#include <linux/export.h>\n\nstatic DEFINE_SPINLOCK(nfs4_deviceid_lock);\n\nvoid\nnfs4_delete_deviceid(const struct pnfs_layoutdriver_type *ld,\n\t\t\t const struct nfs_client *clp, const struct nfs4_deviceid *id)\n{\n\tstruct nfs4_deviceid_node *d;\n\n\tspin_lock(&nfs4_deviceid_lock);\n\trcu_read_lock();\n\td = _lookup_deviceid(ld, clp, id, nfs4_deviceid_hash(id));\n\trcu_read_unlock();\n\tif (!d) {\n\t\tspin_unlock(&nfs4_deviceid_lock);\n\t\treturn;\n\t}\n\thlist_del_init_rcu(&d->node);\n\tspin_unlock(&nfs4_deviceid_lock);\n\tsynchronize_rcu();\n\n\t/* balance the initial ref set in pnfs_insert_deviceid */\n\tif (atomic_dec_and_test(&d->ref))\n\t\td->ld->free_deviceid_node(d);\n}"
  },
  {
    "function_name": "nfs4_find_get_deviceid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_dev.c",
    "lines": "184-212",
    "snippet": "struct nfs4_deviceid_node *\nnfs4_find_get_deviceid(struct nfs_server *server,\n\t\tconst struct nfs4_deviceid *id, struct rpc_cred *cred,\n\t\tgfp_t gfp_mask)\n{\n\tlong hash = nfs4_deviceid_hash(id);\n\tstruct nfs4_deviceid_node *d, *new;\n\n\td = __nfs4_find_get_deviceid(server, id, hash);\n\tif (d)\n\t\treturn d;\n\n\tnew = nfs4_get_device_info(server, id, cred, gfp_mask);\n\tif (!new)\n\t\treturn new;\n\n\tspin_lock(&nfs4_deviceid_lock);\n\td = __nfs4_find_get_deviceid(server, id, hash);\n\tif (d) {\n\t\tspin_unlock(&nfs4_deviceid_lock);\n\t\tserver->pnfs_curr_ld->free_deviceid_node(new);\n\t\treturn d;\n\t}\n\thlist_add_head_rcu(&new->node, &nfs4_deviceid_cache[hash]);\n\tatomic_inc(&new->ref);\n\tspin_unlock(&nfs4_deviceid_lock);\n\n\treturn new;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4session.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hlist_head nfs4_deviceid_cache[NFS4_DEVICE_ID_HASH_SIZE];",
      "static DEFINE_SPINLOCK(nfs4_deviceid_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nfs4_deviceid_lock"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&new->ref"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_add_head_rcu",
          "args": [
            "&new->node",
            "&nfs4_deviceid_cache[hash]"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->pnfs_curr_ld->free_deviceid_node",
          "args": [
            "new"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__nfs4_find_get_deviceid",
          "args": [
            "server",
            "id",
            "hash"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "__nfs4_find_get_deviceid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_dev.c",
          "lines": "169-182",
          "snippet": "static struct nfs4_deviceid_node *\n__nfs4_find_get_deviceid(struct nfs_server *server,\n\t\tconst struct nfs4_deviceid *id, long hash)\n{\n\tstruct nfs4_deviceid_node *d;\n\n\trcu_read_lock();\n\td = _lookup_deviceid(server->pnfs_curr_ld, server->nfs_client, id,\n\t\t\thash);\n\tif (d != NULL)\n\t\tatomic_inc(&d->ref);\n\trcu_read_unlock();\n\treturn d;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/nfs_fs.h>\n#include <linux/export.h>\n\nstatic struct nfs4_deviceid_node *\n__nfs4_find_get_deviceid(struct nfs_server *server,\n\t\tconst struct nfs4_deviceid *id, long hash)\n{\n\tstruct nfs4_deviceid_node *d;\n\n\trcu_read_lock();\n\td = _lookup_deviceid(server->pnfs_curr_ld, server->nfs_client, id,\n\t\t\thash);\n\tif (d != NULL)\n\t\tatomic_inc(&d->ref);\n\trcu_read_unlock();\n\treturn d;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nfs4_deviceid_lock"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_get_device_info",
          "args": [
            "server",
            "id",
            "cred",
            "gfp_mask"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_get_device_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_dev.c",
          "lines": "95-161",
          "snippet": "static struct nfs4_deviceid_node *\nnfs4_get_device_info(struct nfs_server *server,\n\t\tconst struct nfs4_deviceid *dev_id,\n\t\tstruct rpc_cred *cred, gfp_t gfp_flags)\n{\n\tstruct nfs4_deviceid_node *d = NULL;\n\tstruct pnfs_device *pdev = NULL;\n\tstruct page **pages = NULL;\n\tu32 max_resp_sz;\n\tint max_pages;\n\tint rc, i;\n\n\t/*\n\t * Use the session max response size as the basis for setting\n\t * GETDEVICEINFO's maxcount\n\t */\n\tmax_resp_sz = server->nfs_client->cl_session->fc_attrs.max_resp_sz;\n\tif (server->pnfs_curr_ld->max_deviceinfo_size &&\n\t    server->pnfs_curr_ld->max_deviceinfo_size < max_resp_sz)\n\t\tmax_resp_sz = server->pnfs_curr_ld->max_deviceinfo_size;\n\tmax_pages = nfs_page_array_len(0, max_resp_sz);\n\tdprintk(\"%s: server %p max_resp_sz %u max_pages %d\\n\",\n\t\t__func__, server, max_resp_sz, max_pages);\n\n\tpdev = kzalloc(sizeof(*pdev), gfp_flags);\n\tif (!pdev)\n\t\treturn NULL;\n\n\tpages = kcalloc(max_pages, sizeof(struct page *), gfp_flags);\n\tif (!pages)\n\t\tgoto out_free_pdev;\n\n\tfor (i = 0; i < max_pages; i++) {\n\t\tpages[i] = alloc_page(gfp_flags);\n\t\tif (!pages[i])\n\t\t\tgoto out_free_pages;\n\t}\n\n\tmemcpy(&pdev->dev_id, dev_id, sizeof(*dev_id));\n\tpdev->layout_type = server->pnfs_curr_ld->id;\n\tpdev->pages = pages;\n\tpdev->pgbase = 0;\n\tpdev->pglen = max_resp_sz;\n\tpdev->mincount = 0;\n\tpdev->maxcount = max_resp_sz - nfs41_maxgetdevinfo_overhead;\n\n\trc = nfs4_proc_getdeviceinfo(server, pdev, cred);\n\tdprintk(\"%s getdevice info returns %d\\n\", __func__, rc);\n\tif (rc)\n\t\tgoto out_free_pages;\n\n\t/*\n\t * Found new device, need to decode it and then add it to the\n\t * list of known devices for this mountpoint.\n\t */\n\td = server->pnfs_curr_ld->alloc_deviceid_node(server, pdev,\n\t\t\tgfp_flags);\n\nout_free_pages:\n\tfor (i = 0; i < max_pages; i++)\n\t\t__free_page(pages[i]);\n\tkfree(pages);\nout_free_pdev:\n\tkfree(pdev);\n\tdprintk(\"<-- %s d %p\\n\", __func__, d);\n\treturn d;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/nfs_fs.h>\n#include <linux/export.h>\n\nstatic struct nfs4_deviceid_node *\nnfs4_get_device_info(struct nfs_server *server,\n\t\tconst struct nfs4_deviceid *dev_id,\n\t\tstruct rpc_cred *cred, gfp_t gfp_flags)\n{\n\tstruct nfs4_deviceid_node *d = NULL;\n\tstruct pnfs_device *pdev = NULL;\n\tstruct page **pages = NULL;\n\tu32 max_resp_sz;\n\tint max_pages;\n\tint rc, i;\n\n\t/*\n\t * Use the session max response size as the basis for setting\n\t * GETDEVICEINFO's maxcount\n\t */\n\tmax_resp_sz = server->nfs_client->cl_session->fc_attrs.max_resp_sz;\n\tif (server->pnfs_curr_ld->max_deviceinfo_size &&\n\t    server->pnfs_curr_ld->max_deviceinfo_size < max_resp_sz)\n\t\tmax_resp_sz = server->pnfs_curr_ld->max_deviceinfo_size;\n\tmax_pages = nfs_page_array_len(0, max_resp_sz);\n\tdprintk(\"%s: server %p max_resp_sz %u max_pages %d\\n\",\n\t\t__func__, server, max_resp_sz, max_pages);\n\n\tpdev = kzalloc(sizeof(*pdev), gfp_flags);\n\tif (!pdev)\n\t\treturn NULL;\n\n\tpages = kcalloc(max_pages, sizeof(struct page *), gfp_flags);\n\tif (!pages)\n\t\tgoto out_free_pdev;\n\n\tfor (i = 0; i < max_pages; i++) {\n\t\tpages[i] = alloc_page(gfp_flags);\n\t\tif (!pages[i])\n\t\t\tgoto out_free_pages;\n\t}\n\n\tmemcpy(&pdev->dev_id, dev_id, sizeof(*dev_id));\n\tpdev->layout_type = server->pnfs_curr_ld->id;\n\tpdev->pages = pages;\n\tpdev->pgbase = 0;\n\tpdev->pglen = max_resp_sz;\n\tpdev->mincount = 0;\n\tpdev->maxcount = max_resp_sz - nfs41_maxgetdevinfo_overhead;\n\n\trc = nfs4_proc_getdeviceinfo(server, pdev, cred);\n\tdprintk(\"%s getdevice info returns %d\\n\", __func__, rc);\n\tif (rc)\n\t\tgoto out_free_pages;\n\n\t/*\n\t * Found new device, need to decode it and then add it to the\n\t * list of known devices for this mountpoint.\n\t */\n\td = server->pnfs_curr_ld->alloc_deviceid_node(server, pdev,\n\t\t\tgfp_flags);\n\nout_free_pages:\n\tfor (i = 0; i < max_pages; i++)\n\t\t__free_page(pages[i]);\n\tkfree(pages);\nout_free_pdev:\n\tkfree(pdev);\n\tdprintk(\"<-- %s d %p\\n\", __func__, d);\n\treturn d;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_deviceid_hash",
          "args": [
            "id"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_deviceid_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_dev.c",
          "lines": "63-75",
          "snippet": "static inline u32\nnfs4_deviceid_hash(const struct nfs4_deviceid *id)\n{\n\tunsigned char *cptr = (unsigned char *)id->data;\n\tunsigned int nbytes = NFS4_DEVICEID4_SIZE;\n\tu32 x = 0;\n\n\twhile (nbytes--) {\n\t\tx *= 37;\n\t\tx += *cptr++;\n\t}\n\treturn x & NFS4_DEVICE_ID_HASH_MASK;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define NFS4_DEVICE_ID_HASH_MASK\t(NFS4_DEVICE_ID_HASH_SIZE - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/nfs_fs.h>\n#include <linux/export.h>\n\n#define NFS4_DEVICE_ID_HASH_MASK\t(NFS4_DEVICE_ID_HASH_SIZE - 1)\n\nstatic inline u32\nnfs4_deviceid_hash(const struct nfs4_deviceid *id)\n{\n\tunsigned char *cptr = (unsigned char *)id->data;\n\tunsigned int nbytes = NFS4_DEVICEID4_SIZE;\n\tu32 x = 0;\n\n\twhile (nbytes--) {\n\t\tx *= 37;\n\t\tx += *cptr++;\n\t}\n\treturn x & NFS4_DEVICE_ID_HASH_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/nfs_fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head nfs4_deviceid_cache[NFS4_DEVICE_ID_HASH_SIZE];\nstatic DEFINE_SPINLOCK(nfs4_deviceid_lock);\n\nstruct nfs4_deviceid_node *\nnfs4_find_get_deviceid(struct nfs_server *server,\n\t\tconst struct nfs4_deviceid *id, struct rpc_cred *cred,\n\t\tgfp_t gfp_mask)\n{\n\tlong hash = nfs4_deviceid_hash(id);\n\tstruct nfs4_deviceid_node *d, *new;\n\n\td = __nfs4_find_get_deviceid(server, id, hash);\n\tif (d)\n\t\treturn d;\n\n\tnew = nfs4_get_device_info(server, id, cred, gfp_mask);\n\tif (!new)\n\t\treturn new;\n\n\tspin_lock(&nfs4_deviceid_lock);\n\td = __nfs4_find_get_deviceid(server, id, hash);\n\tif (d) {\n\t\tspin_unlock(&nfs4_deviceid_lock);\n\t\tserver->pnfs_curr_ld->free_deviceid_node(new);\n\t\treturn d;\n\t}\n\thlist_add_head_rcu(&new->node, &nfs4_deviceid_cache[hash]);\n\tatomic_inc(&new->ref);\n\tspin_unlock(&nfs4_deviceid_lock);\n\n\treturn new;\n}"
  },
  {
    "function_name": "__nfs4_find_get_deviceid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_dev.c",
    "lines": "169-182",
    "snippet": "static struct nfs4_deviceid_node *\n__nfs4_find_get_deviceid(struct nfs_server *server,\n\t\tconst struct nfs4_deviceid *id, long hash)\n{\n\tstruct nfs4_deviceid_node *d;\n\n\trcu_read_lock();\n\td = _lookup_deviceid(server->pnfs_curr_ld, server->nfs_client, id,\n\t\t\thash);\n\tif (d != NULL)\n\t\tatomic_inc(&d->ref);\n\trcu_read_unlock();\n\treturn d;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4session.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&d->ref"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_lookup_deviceid",
          "args": [
            "server->pnfs_curr_ld",
            "server->nfs_client",
            "id",
            "hash"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "_lookup_deviceid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_dev.c",
          "lines": "77-93",
          "snippet": "static struct nfs4_deviceid_node *\n_lookup_deviceid(const struct pnfs_layoutdriver_type *ld,\n\t\t const struct nfs_client *clp, const struct nfs4_deviceid *id,\n\t\t long hash)\n{\n\tstruct nfs4_deviceid_node *d;\n\n\thlist_for_each_entry_rcu(d, &nfs4_deviceid_cache[hash], node)\n\t\tif (d->ld == ld && d->nfs_client == clp &&\n\t\t    !memcmp(&d->deviceid, id, sizeof(*id))) {\n\t\t\tif (atomic_read(&d->ref))\n\t\t\t\treturn d;\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head nfs4_deviceid_cache[NFS4_DEVICE_ID_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/nfs_fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head nfs4_deviceid_cache[NFS4_DEVICE_ID_HASH_SIZE];\n\nstatic struct nfs4_deviceid_node *\n_lookup_deviceid(const struct pnfs_layoutdriver_type *ld,\n\t\t const struct nfs_client *clp, const struct nfs4_deviceid *id,\n\t\t long hash)\n{\n\tstruct nfs4_deviceid_node *d;\n\n\thlist_for_each_entry_rcu(d, &nfs4_deviceid_cache[hash], node)\n\t\tif (d->ld == ld && d->nfs_client == clp &&\n\t\t    !memcmp(&d->deviceid, id, sizeof(*id))) {\n\t\t\tif (atomic_read(&d->ref))\n\t\t\t\treturn d;\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/nfs_fs.h>\n#include <linux/export.h>\n\nstatic struct nfs4_deviceid_node *\n__nfs4_find_get_deviceid(struct nfs_server *server,\n\t\tconst struct nfs4_deviceid *id, long hash)\n{\n\tstruct nfs4_deviceid_node *d;\n\n\trcu_read_lock();\n\td = _lookup_deviceid(server->pnfs_curr_ld, server->nfs_client, id,\n\t\t\thash);\n\tif (d != NULL)\n\t\tatomic_inc(&d->ref);\n\trcu_read_unlock();\n\treturn d;\n}"
  },
  {
    "function_name": "nfs4_get_device_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_dev.c",
    "lines": "95-161",
    "snippet": "static struct nfs4_deviceid_node *\nnfs4_get_device_info(struct nfs_server *server,\n\t\tconst struct nfs4_deviceid *dev_id,\n\t\tstruct rpc_cred *cred, gfp_t gfp_flags)\n{\n\tstruct nfs4_deviceid_node *d = NULL;\n\tstruct pnfs_device *pdev = NULL;\n\tstruct page **pages = NULL;\n\tu32 max_resp_sz;\n\tint max_pages;\n\tint rc, i;\n\n\t/*\n\t * Use the session max response size as the basis for setting\n\t * GETDEVICEINFO's maxcount\n\t */\n\tmax_resp_sz = server->nfs_client->cl_session->fc_attrs.max_resp_sz;\n\tif (server->pnfs_curr_ld->max_deviceinfo_size &&\n\t    server->pnfs_curr_ld->max_deviceinfo_size < max_resp_sz)\n\t\tmax_resp_sz = server->pnfs_curr_ld->max_deviceinfo_size;\n\tmax_pages = nfs_page_array_len(0, max_resp_sz);\n\tdprintk(\"%s: server %p max_resp_sz %u max_pages %d\\n\",\n\t\t__func__, server, max_resp_sz, max_pages);\n\n\tpdev = kzalloc(sizeof(*pdev), gfp_flags);\n\tif (!pdev)\n\t\treturn NULL;\n\n\tpages = kcalloc(max_pages, sizeof(struct page *), gfp_flags);\n\tif (!pages)\n\t\tgoto out_free_pdev;\n\n\tfor (i = 0; i < max_pages; i++) {\n\t\tpages[i] = alloc_page(gfp_flags);\n\t\tif (!pages[i])\n\t\t\tgoto out_free_pages;\n\t}\n\n\tmemcpy(&pdev->dev_id, dev_id, sizeof(*dev_id));\n\tpdev->layout_type = server->pnfs_curr_ld->id;\n\tpdev->pages = pages;\n\tpdev->pgbase = 0;\n\tpdev->pglen = max_resp_sz;\n\tpdev->mincount = 0;\n\tpdev->maxcount = max_resp_sz - nfs41_maxgetdevinfo_overhead;\n\n\trc = nfs4_proc_getdeviceinfo(server, pdev, cred);\n\tdprintk(\"%s getdevice info returns %d\\n\", __func__, rc);\n\tif (rc)\n\t\tgoto out_free_pages;\n\n\t/*\n\t * Found new device, need to decode it and then add it to the\n\t * list of known devices for this mountpoint.\n\t */\n\td = server->pnfs_curr_ld->alloc_deviceid_node(server, pdev,\n\t\t\tgfp_flags);\n\nout_free_pages:\n\tfor (i = 0; i < max_pages; i++)\n\t\t__free_page(pages[i]);\n\tkfree(pages);\nout_free_pdev:\n\tkfree(pdev);\n\tdprintk(\"<-- %s d %p\\n\", __func__, d);\n\treturn d;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4session.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"<-- %s d %p\\n\"",
            "__func__",
            "d"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pdev"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pages"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "pages[i]"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->pnfs_curr_ld->alloc_deviceid_node",
          "args": [
            "server",
            "pdev",
            "gfp_flags"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s getdevice info returns %d\\n\"",
            "__func__",
            "rc"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_proc_getdeviceinfo",
          "args": [
            "server",
            "pdev",
            "cred"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_proc_getdeviceinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "7966-7979",
          "snippet": "int nfs4_proc_getdeviceinfo(struct nfs_server *server,\n\t\tstruct pnfs_device *pdev,\n\t\tstruct rpc_cred *cred)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\tdo {\n\t\terr = nfs4_handle_exception(server,\n\t\t\t\t\t_nfs4_proc_getdeviceinfo(server, pdev, cred),\n\t\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nint nfs4_proc_getdeviceinfo(struct nfs_server *server,\n\t\tstruct pnfs_device *pdev,\n\t\tstruct rpc_cred *cred)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\tdo {\n\t\terr = nfs4_handle_exception(server,\n\t\t\t\t\t_nfs4_proc_getdeviceinfo(server, pdev, cred),\n\t\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&pdev->dev_id",
            "dev_id",
            "sizeof(*dev_id)"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "gfp_flags"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "max_pages",
            "sizeof(struct page *)",
            "gfp_flags"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*pdev)",
            "gfp_flags"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: server %p max_resp_sz %u max_pages %d\\n\"",
            "__func__",
            "server",
            "max_resp_sz",
            "max_pages"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_page_array_len",
          "args": [
            "0",
            "max_resp_sz"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_page_array_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
          "lines": "646-651",
          "snippet": "static inline\nunsigned int nfs_page_array_len(unsigned int base, size_t len)\n{\n\treturn ((unsigned long)len + (unsigned long)base +\n\t\tPAGE_SIZE - 1) >> PAGE_SHIFT;\n}",
          "includes": [
            "#include <linux/nfs_page.h>",
            "#include <linux/crc32.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include \"nfs4_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ssize_t nfs_file_splice_read(struct file *, loff_t *, struct pipe_inode_info *,\n\t\t\t     size_t, unsigned int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nssize_t nfs_file_splice_read(struct file *, loff_t *, struct pipe_inode_info *,\n\t\t\t     size_t, unsigned int);\n\nstatic inline\nunsigned int nfs_page_array_len(unsigned int base, size_t len)\n{\n\treturn ((unsigned long)len + (unsigned long)base +\n\t\tPAGE_SIZE - 1) >> PAGE_SHIFT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/nfs_fs.h>\n#include <linux/export.h>\n\nstatic struct nfs4_deviceid_node *\nnfs4_get_device_info(struct nfs_server *server,\n\t\tconst struct nfs4_deviceid *dev_id,\n\t\tstruct rpc_cred *cred, gfp_t gfp_flags)\n{\n\tstruct nfs4_deviceid_node *d = NULL;\n\tstruct pnfs_device *pdev = NULL;\n\tstruct page **pages = NULL;\n\tu32 max_resp_sz;\n\tint max_pages;\n\tint rc, i;\n\n\t/*\n\t * Use the session max response size as the basis for setting\n\t * GETDEVICEINFO's maxcount\n\t */\n\tmax_resp_sz = server->nfs_client->cl_session->fc_attrs.max_resp_sz;\n\tif (server->pnfs_curr_ld->max_deviceinfo_size &&\n\t    server->pnfs_curr_ld->max_deviceinfo_size < max_resp_sz)\n\t\tmax_resp_sz = server->pnfs_curr_ld->max_deviceinfo_size;\n\tmax_pages = nfs_page_array_len(0, max_resp_sz);\n\tdprintk(\"%s: server %p max_resp_sz %u max_pages %d\\n\",\n\t\t__func__, server, max_resp_sz, max_pages);\n\n\tpdev = kzalloc(sizeof(*pdev), gfp_flags);\n\tif (!pdev)\n\t\treturn NULL;\n\n\tpages = kcalloc(max_pages, sizeof(struct page *), gfp_flags);\n\tif (!pages)\n\t\tgoto out_free_pdev;\n\n\tfor (i = 0; i < max_pages; i++) {\n\t\tpages[i] = alloc_page(gfp_flags);\n\t\tif (!pages[i])\n\t\t\tgoto out_free_pages;\n\t}\n\n\tmemcpy(&pdev->dev_id, dev_id, sizeof(*dev_id));\n\tpdev->layout_type = server->pnfs_curr_ld->id;\n\tpdev->pages = pages;\n\tpdev->pgbase = 0;\n\tpdev->pglen = max_resp_sz;\n\tpdev->mincount = 0;\n\tpdev->maxcount = max_resp_sz - nfs41_maxgetdevinfo_overhead;\n\n\trc = nfs4_proc_getdeviceinfo(server, pdev, cred);\n\tdprintk(\"%s getdevice info returns %d\\n\", __func__, rc);\n\tif (rc)\n\t\tgoto out_free_pages;\n\n\t/*\n\t * Found new device, need to decode it and then add it to the\n\t * list of known devices for this mountpoint.\n\t */\n\td = server->pnfs_curr_ld->alloc_deviceid_node(server, pdev,\n\t\t\tgfp_flags);\n\nout_free_pages:\n\tfor (i = 0; i < max_pages; i++)\n\t\t__free_page(pages[i]);\n\tkfree(pages);\nout_free_pdev:\n\tkfree(pdev);\n\tdprintk(\"<-- %s d %p\\n\", __func__, d);\n\treturn d;\n}"
  },
  {
    "function_name": "_lookup_deviceid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_dev.c",
    "lines": "77-93",
    "snippet": "static struct nfs4_deviceid_node *\n_lookup_deviceid(const struct pnfs_layoutdriver_type *ld,\n\t\t const struct nfs_client *clp, const struct nfs4_deviceid *id,\n\t\t long hash)\n{\n\tstruct nfs4_deviceid_node *d;\n\n\thlist_for_each_entry_rcu(d, &nfs4_deviceid_cache[hash], node)\n\t\tif (d->ld == ld && d->nfs_client == clp &&\n\t\t    !memcmp(&d->deviceid, id, sizeof(*id))) {\n\t\t\tif (atomic_read(&d->ref))\n\t\t\t\treturn d;\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4session.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hlist_head nfs4_deviceid_cache[NFS4_DEVICE_ID_HASH_SIZE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&d->ref"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "&d->deviceid",
            "id",
            "sizeof(*id)"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu",
          "args": [
            "d",
            "&nfs4_deviceid_cache[hash]",
            "node"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/nfs_fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head nfs4_deviceid_cache[NFS4_DEVICE_ID_HASH_SIZE];\n\nstatic struct nfs4_deviceid_node *\n_lookup_deviceid(const struct pnfs_layoutdriver_type *ld,\n\t\t const struct nfs_client *clp, const struct nfs4_deviceid *id,\n\t\t long hash)\n{\n\tstruct nfs4_deviceid_node *d;\n\n\thlist_for_each_entry_rcu(d, &nfs4_deviceid_cache[hash], node)\n\t\tif (d->ld == ld && d->nfs_client == clp &&\n\t\t    !memcmp(&d->deviceid, id, sizeof(*id))) {\n\t\t\tif (atomic_read(&d->ref))\n\t\t\t\treturn d;\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "nfs4_deviceid_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_dev.c",
    "lines": "63-75",
    "snippet": "static inline u32\nnfs4_deviceid_hash(const struct nfs4_deviceid *id)\n{\n\tunsigned char *cptr = (unsigned char *)id->data;\n\tunsigned int nbytes = NFS4_DEVICEID4_SIZE;\n\tu32 x = 0;\n\n\twhile (nbytes--) {\n\t\tx *= 37;\n\t\tx += *cptr++;\n\t}\n\treturn x & NFS4_DEVICE_ID_HASH_MASK;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4session.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [
      "#define NFS4_DEVICE_ID_HASH_MASK\t(NFS4_DEVICE_ID_HASH_SIZE - 1)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/nfs_fs.h>\n#include <linux/export.h>\n\n#define NFS4_DEVICE_ID_HASH_MASK\t(NFS4_DEVICE_ID_HASH_SIZE - 1)\n\nstatic inline u32\nnfs4_deviceid_hash(const struct nfs4_deviceid *id)\n{\n\tunsigned char *cptr = (unsigned char *)id->data;\n\tunsigned int nbytes = NFS4_DEVICEID4_SIZE;\n\tu32 x = 0;\n\n\twhile (nbytes--) {\n\t\tx *= 37;\n\t\tx += *cptr++;\n\t}\n\treturn x & NFS4_DEVICE_ID_HASH_MASK;\n}"
  },
  {
    "function_name": "nfs4_print_deviceid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_dev.c",
    "lines": "52-59",
    "snippet": "void\nnfs4_print_deviceid(const struct nfs4_deviceid *id)\n{\n\tu32 *p = (u32 *)id;\n\n\tdprintk(\"%s: device id= [%x%x%x%x]\\n\", __func__,\n\t\tp[0], p[1], p[2], p[3]);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4session.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: device id= [%x%x%x%x]\\n\"",
            "__func__",
            "p[0]",
            "p[1]",
            "p[2]",
            "p[3]"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/nfs_fs.h>\n#include <linux/export.h>\n\nvoid\nnfs4_print_deviceid(const struct nfs4_deviceid *id)\n{\n\tu32 *p = (u32 *)id;\n\n\tdprintk(\"%s: device id= [%x%x%x%x]\\n\", __func__,\n\t\tp[0], p[1], p[2], p[3]);\n}"
  }
]