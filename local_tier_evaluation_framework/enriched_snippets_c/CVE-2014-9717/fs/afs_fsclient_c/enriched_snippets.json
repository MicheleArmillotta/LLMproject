[
  {
    "function_name": "afs_fs_release_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
    "lines": "1884-1911",
    "snippet": "int afs_fs_release_lock(struct afs_server *server,\n\t\t\tstruct key *key,\n\t\t\tstruct afs_vnode *vnode,\n\t\t\tconst struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tcall = afs_alloc_flat_call(&afs_RXFSReleaseLock, 4 * 4, 6 * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(FSRELEASELOCK);\n\t*bp++ = htonl(vnode->fid.vid);\n\t*bp++ = htonl(vnode->fid.vnode);\n\t*bp++ = htonl(vnode->fid.unique);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}",
    "includes": [
      "#include \"afs_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/circ_buf.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct afs_call_type afs_RXFSReleaseLock = {\n\t.name\t\t= \"FS.ReleaseLock\",\n\t.deliver\t= afs_deliver_fs_xxxx_lock,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "afs_make_call",
          "args": [
            "&server->addr",
            "call",
            "GFP_NOFS",
            "wait_mode"
          ],
          "line": 1910
        },
        "resolved": true,
        "details": {
          "function_name": "afs_make_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "338-420",
          "snippet": "int afs_make_call(struct in_addr *addr, struct afs_call *call, gfp_t gfp,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct sockaddr_rxrpc srx;\n\tstruct rxrpc_call *rxcall;\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tint ret;\n\tstruct sk_buff *skb;\n\n\t_enter(\"%x,{%d},\", addr->s_addr, ntohs(call->port));\n\n\tASSERT(call->type != NULL);\n\tASSERT(call->type->name != NULL);\n\n\t_debug(\"____MAKE %p{%s,%x} [%d]____\",\n\t       call, call->type->name, key_serial(call->key),\n\t       atomic_read(&afs_outstanding_calls));\n\n\tcall->wait_mode = wait_mode;\n\tcall->async_workfn = afs_process_async_call;\n\tINIT_WORK(&call->async_work, afs_async_workfn);\n\n\tmemset(&srx, 0, sizeof(srx));\n\tsrx.srx_family = AF_RXRPC;\n\tsrx.srx_service = call->service_id;\n\tsrx.transport_type = SOCK_DGRAM;\n\tsrx.transport_len = sizeof(srx.transport.sin);\n\tsrx.transport.sin.sin_family = AF_INET;\n\tsrx.transport.sin.sin_port = call->port;\n\tmemcpy(&srx.transport.sin.sin_addr, addr, 4);\n\n\t/* create a call */\n\trxcall = rxrpc_kernel_begin_call(afs_socket, &srx, call->key,\n\t\t\t\t\t (unsigned long) call, gfp);\n\tcall->key = NULL;\n\tif (IS_ERR(rxcall)) {\n\t\tret = PTR_ERR(rxcall);\n\t\tgoto error_kill_call;\n\t}\n\n\tcall->rxcall = rxcall;\n\n\t/* send the request */\n\tiov[0].iov_base\t= call->request;\n\tiov[0].iov_len\t= call->request_size;\n\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1,\n\t\t      call->request_size);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= (call->send_pages ? MSG_MORE : 0);\n\n\t/* have to change the state *before* sending the last packet as RxRPC\n\t * might give us the reply before it returns from sending the\n\t * request */\n\tif (!call->send_pages)\n\t\tcall->state = AFS_CALL_AWAIT_REPLY;\n\tret = rxrpc_kernel_send_data(rxcall, &msg, call->request_size);\n\tif (ret < 0)\n\t\tgoto error_do_abort;\n\n\tif (call->send_pages) {\n\t\tret = afs_send_pages(call, &msg, iov);\n\t\tif (ret < 0)\n\t\t\tgoto error_do_abort;\n\t}\n\n\t/* at this point, an async call may no longer exist as it may have\n\t * already completed */\n\treturn wait_mode->wait(call);\n\nerror_do_abort:\n\trxrpc_kernel_abort_call(rxcall, RX_USER_ABORT);\n\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\tafs_free_skb(skb);\nerror_kill_call:\n\tafs_end_call(call);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct socket *afs_socket;",
            "static atomic_t afs_outstanding_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);",
            "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
            "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic struct socket *afs_socket;\nstatic atomic_t afs_outstanding_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\n\nint afs_make_call(struct in_addr *addr, struct afs_call *call, gfp_t gfp,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct sockaddr_rxrpc srx;\n\tstruct rxrpc_call *rxcall;\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tint ret;\n\tstruct sk_buff *skb;\n\n\t_enter(\"%x,{%d},\", addr->s_addr, ntohs(call->port));\n\n\tASSERT(call->type != NULL);\n\tASSERT(call->type->name != NULL);\n\n\t_debug(\"____MAKE %p{%s,%x} [%d]____\",\n\t       call, call->type->name, key_serial(call->key),\n\t       atomic_read(&afs_outstanding_calls));\n\n\tcall->wait_mode = wait_mode;\n\tcall->async_workfn = afs_process_async_call;\n\tINIT_WORK(&call->async_work, afs_async_workfn);\n\n\tmemset(&srx, 0, sizeof(srx));\n\tsrx.srx_family = AF_RXRPC;\n\tsrx.srx_service = call->service_id;\n\tsrx.transport_type = SOCK_DGRAM;\n\tsrx.transport_len = sizeof(srx.transport.sin);\n\tsrx.transport.sin.sin_family = AF_INET;\n\tsrx.transport.sin.sin_port = call->port;\n\tmemcpy(&srx.transport.sin.sin_addr, addr, 4);\n\n\t/* create a call */\n\trxcall = rxrpc_kernel_begin_call(afs_socket, &srx, call->key,\n\t\t\t\t\t (unsigned long) call, gfp);\n\tcall->key = NULL;\n\tif (IS_ERR(rxcall)) {\n\t\tret = PTR_ERR(rxcall);\n\t\tgoto error_kill_call;\n\t}\n\n\tcall->rxcall = rxcall;\n\n\t/* send the request */\n\tiov[0].iov_base\t= call->request;\n\tiov[0].iov_len\t= call->request_size;\n\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1,\n\t\t      call->request_size);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= (call->send_pages ? MSG_MORE : 0);\n\n\t/* have to change the state *before* sending the last packet as RxRPC\n\t * might give us the reply before it returns from sending the\n\t * request */\n\tif (!call->send_pages)\n\t\tcall->state = AFS_CALL_AWAIT_REPLY;\n\tret = rxrpc_kernel_send_data(rxcall, &msg, call->request_size);\n\tif (ret < 0)\n\t\tgoto error_do_abort;\n\n\tif (call->send_pages) {\n\t\tret = afs_send_pages(call, &msg, iov);\n\t\tif (ret < 0)\n\t\t\tgoto error_do_abort;\n\t}\n\n\t/* at this point, an async call may no longer exist as it may have\n\t * already completed */\n\treturn wait_mode->wait(call);\n\nerror_do_abort:\n\trxrpc_kernel_abort_call(rxcall, RX_USER_ABORT);\n\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\tafs_free_skb(skb);\nerror_kill_call:\n\tafs_end_call(call);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "vnode->fid.unique"
          ],
          "line": 1908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "vnode->fid.vnode"
          ],
          "line": 1907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "vnode->fid.vid"
          ],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "FSRELEASELOCK"
          ],
          "line": 1905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "AFS_FS_PORT"
          ],
          "line": 1901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_alloc_flat_call",
          "args": [
            "&afs_RXFSReleaseLock",
            "4 * 4",
            "6 * 4"
          ],
          "line": 1894
        },
        "resolved": true,
        "details": {
          "function_name": "afs_alloc_flat_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "218-255",
          "snippet": "struct afs_call *afs_alloc_flat_call(const struct afs_call_type *type,\n\t\t\t\t     size_t request_size, size_t reply_size)\n{\n\tstruct afs_call *call;\n\n\tcall = kzalloc(sizeof(*call), GFP_NOFS);\n\tif (!call)\n\t\tgoto nomem_call;\n\n\t_debug(\"CALL %p{%s} [%d]\",\n\t       call, type->name, atomic_read(&afs_outstanding_calls));\n\tatomic_inc(&afs_outstanding_calls);\n\n\tcall->type = type;\n\tcall->request_size = request_size;\n\tcall->reply_max = reply_size;\n\n\tif (request_size) {\n\t\tcall->request = kmalloc(request_size, GFP_NOFS);\n\t\tif (!call->request)\n\t\t\tgoto nomem_free;\n\t}\n\n\tif (reply_size) {\n\t\tcall->buffer = kmalloc(reply_size, GFP_NOFS);\n\t\tif (!call->buffer)\n\t\t\tgoto nomem_free;\n\t}\n\n\tinit_waitqueue_head(&call->waitq);\n\tskb_queue_head_init(&call->rx_queue);\n\treturn call;\n\nnomem_free:\n\tafs_free_call(call);\nnomem_call:\n\treturn NULL;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t afs_outstanding_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic atomic_t afs_outstanding_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nstruct afs_call *afs_alloc_flat_call(const struct afs_call_type *type,\n\t\t\t\t     size_t request_size, size_t reply_size)\n{\n\tstruct afs_call *call;\n\n\tcall = kzalloc(sizeof(*call), GFP_NOFS);\n\tif (!call)\n\t\tgoto nomem_call;\n\n\t_debug(\"CALL %p{%s} [%d]\",\n\t       call, type->name, atomic_read(&afs_outstanding_calls));\n\tatomic_inc(&afs_outstanding_calls);\n\n\tcall->type = type;\n\tcall->request_size = request_size;\n\tcall->reply_max = reply_size;\n\n\tif (request_size) {\n\t\tcall->request = kmalloc(request_size, GFP_NOFS);\n\t\tif (!call->request)\n\t\t\tgoto nomem_free;\n\t}\n\n\tif (reply_size) {\n\t\tcall->buffer = kmalloc(reply_size, GFP_NOFS);\n\t\tif (!call->buffer)\n\t\t\tgoto nomem_free;\n\t}\n\n\tinit_waitqueue_head(&call->waitq);\n\tskb_queue_head_init(&call->rx_queue);\n\treturn call;\n\nnomem_free:\n\tafs_free_call(call);\nnomem_call:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 1892
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic const struct afs_call_type afs_RXFSReleaseLock = {\n\t.name\t\t= \"FS.ReleaseLock\",\n\t.deliver\t= afs_deliver_fs_xxxx_lock,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\nint afs_fs_release_lock(struct afs_server *server,\n\t\t\tstruct key *key,\n\t\t\tstruct afs_vnode *vnode,\n\t\t\tconst struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tcall = afs_alloc_flat_call(&afs_RXFSReleaseLock, 4 * 4, 6 * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(FSRELEASELOCK);\n\t*bp++ = htonl(vnode->fid.vid);\n\t*bp++ = htonl(vnode->fid.vnode);\n\t*bp++ = htonl(vnode->fid.unique);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}"
  },
  {
    "function_name": "afs_fs_extend_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
    "lines": "1852-1879",
    "snippet": "int afs_fs_extend_lock(struct afs_server *server,\n\t\t       struct key *key,\n\t\t       struct afs_vnode *vnode,\n\t\t       const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tcall = afs_alloc_flat_call(&afs_RXFSExtendLock, 4 * 4, 6 * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(FSEXTENDLOCK);\n\t*bp++ = htonl(vnode->fid.vid);\n\t*bp++ = htonl(vnode->fid.vnode);\n\t*bp++ = htonl(vnode->fid.unique);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}",
    "includes": [
      "#include \"afs_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/circ_buf.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct afs_call_type afs_RXFSExtendLock = {\n\t.name\t\t= \"FS.ExtendLock\",\n\t.deliver\t= afs_deliver_fs_xxxx_lock,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "afs_make_call",
          "args": [
            "&server->addr",
            "call",
            "GFP_NOFS",
            "wait_mode"
          ],
          "line": 1878
        },
        "resolved": true,
        "details": {
          "function_name": "afs_make_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "338-420",
          "snippet": "int afs_make_call(struct in_addr *addr, struct afs_call *call, gfp_t gfp,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct sockaddr_rxrpc srx;\n\tstruct rxrpc_call *rxcall;\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tint ret;\n\tstruct sk_buff *skb;\n\n\t_enter(\"%x,{%d},\", addr->s_addr, ntohs(call->port));\n\n\tASSERT(call->type != NULL);\n\tASSERT(call->type->name != NULL);\n\n\t_debug(\"____MAKE %p{%s,%x} [%d]____\",\n\t       call, call->type->name, key_serial(call->key),\n\t       atomic_read(&afs_outstanding_calls));\n\n\tcall->wait_mode = wait_mode;\n\tcall->async_workfn = afs_process_async_call;\n\tINIT_WORK(&call->async_work, afs_async_workfn);\n\n\tmemset(&srx, 0, sizeof(srx));\n\tsrx.srx_family = AF_RXRPC;\n\tsrx.srx_service = call->service_id;\n\tsrx.transport_type = SOCK_DGRAM;\n\tsrx.transport_len = sizeof(srx.transport.sin);\n\tsrx.transport.sin.sin_family = AF_INET;\n\tsrx.transport.sin.sin_port = call->port;\n\tmemcpy(&srx.transport.sin.sin_addr, addr, 4);\n\n\t/* create a call */\n\trxcall = rxrpc_kernel_begin_call(afs_socket, &srx, call->key,\n\t\t\t\t\t (unsigned long) call, gfp);\n\tcall->key = NULL;\n\tif (IS_ERR(rxcall)) {\n\t\tret = PTR_ERR(rxcall);\n\t\tgoto error_kill_call;\n\t}\n\n\tcall->rxcall = rxcall;\n\n\t/* send the request */\n\tiov[0].iov_base\t= call->request;\n\tiov[0].iov_len\t= call->request_size;\n\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1,\n\t\t      call->request_size);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= (call->send_pages ? MSG_MORE : 0);\n\n\t/* have to change the state *before* sending the last packet as RxRPC\n\t * might give us the reply before it returns from sending the\n\t * request */\n\tif (!call->send_pages)\n\t\tcall->state = AFS_CALL_AWAIT_REPLY;\n\tret = rxrpc_kernel_send_data(rxcall, &msg, call->request_size);\n\tif (ret < 0)\n\t\tgoto error_do_abort;\n\n\tif (call->send_pages) {\n\t\tret = afs_send_pages(call, &msg, iov);\n\t\tif (ret < 0)\n\t\t\tgoto error_do_abort;\n\t}\n\n\t/* at this point, an async call may no longer exist as it may have\n\t * already completed */\n\treturn wait_mode->wait(call);\n\nerror_do_abort:\n\trxrpc_kernel_abort_call(rxcall, RX_USER_ABORT);\n\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\tafs_free_skb(skb);\nerror_kill_call:\n\tafs_end_call(call);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct socket *afs_socket;",
            "static atomic_t afs_outstanding_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);",
            "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
            "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic struct socket *afs_socket;\nstatic atomic_t afs_outstanding_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\n\nint afs_make_call(struct in_addr *addr, struct afs_call *call, gfp_t gfp,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct sockaddr_rxrpc srx;\n\tstruct rxrpc_call *rxcall;\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tint ret;\n\tstruct sk_buff *skb;\n\n\t_enter(\"%x,{%d},\", addr->s_addr, ntohs(call->port));\n\n\tASSERT(call->type != NULL);\n\tASSERT(call->type->name != NULL);\n\n\t_debug(\"____MAKE %p{%s,%x} [%d]____\",\n\t       call, call->type->name, key_serial(call->key),\n\t       atomic_read(&afs_outstanding_calls));\n\n\tcall->wait_mode = wait_mode;\n\tcall->async_workfn = afs_process_async_call;\n\tINIT_WORK(&call->async_work, afs_async_workfn);\n\n\tmemset(&srx, 0, sizeof(srx));\n\tsrx.srx_family = AF_RXRPC;\n\tsrx.srx_service = call->service_id;\n\tsrx.transport_type = SOCK_DGRAM;\n\tsrx.transport_len = sizeof(srx.transport.sin);\n\tsrx.transport.sin.sin_family = AF_INET;\n\tsrx.transport.sin.sin_port = call->port;\n\tmemcpy(&srx.transport.sin.sin_addr, addr, 4);\n\n\t/* create a call */\n\trxcall = rxrpc_kernel_begin_call(afs_socket, &srx, call->key,\n\t\t\t\t\t (unsigned long) call, gfp);\n\tcall->key = NULL;\n\tif (IS_ERR(rxcall)) {\n\t\tret = PTR_ERR(rxcall);\n\t\tgoto error_kill_call;\n\t}\n\n\tcall->rxcall = rxcall;\n\n\t/* send the request */\n\tiov[0].iov_base\t= call->request;\n\tiov[0].iov_len\t= call->request_size;\n\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1,\n\t\t      call->request_size);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= (call->send_pages ? MSG_MORE : 0);\n\n\t/* have to change the state *before* sending the last packet as RxRPC\n\t * might give us the reply before it returns from sending the\n\t * request */\n\tif (!call->send_pages)\n\t\tcall->state = AFS_CALL_AWAIT_REPLY;\n\tret = rxrpc_kernel_send_data(rxcall, &msg, call->request_size);\n\tif (ret < 0)\n\t\tgoto error_do_abort;\n\n\tif (call->send_pages) {\n\t\tret = afs_send_pages(call, &msg, iov);\n\t\tif (ret < 0)\n\t\t\tgoto error_do_abort;\n\t}\n\n\t/* at this point, an async call may no longer exist as it may have\n\t * already completed */\n\treturn wait_mode->wait(call);\n\nerror_do_abort:\n\trxrpc_kernel_abort_call(rxcall, RX_USER_ABORT);\n\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\tafs_free_skb(skb);\nerror_kill_call:\n\tafs_end_call(call);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "vnode->fid.unique"
          ],
          "line": 1876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "vnode->fid.vnode"
          ],
          "line": 1875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "vnode->fid.vid"
          ],
          "line": 1874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "FSEXTENDLOCK"
          ],
          "line": 1873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "AFS_FS_PORT"
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_alloc_flat_call",
          "args": [
            "&afs_RXFSExtendLock",
            "4 * 4",
            "6 * 4"
          ],
          "line": 1862
        },
        "resolved": true,
        "details": {
          "function_name": "afs_alloc_flat_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "218-255",
          "snippet": "struct afs_call *afs_alloc_flat_call(const struct afs_call_type *type,\n\t\t\t\t     size_t request_size, size_t reply_size)\n{\n\tstruct afs_call *call;\n\n\tcall = kzalloc(sizeof(*call), GFP_NOFS);\n\tif (!call)\n\t\tgoto nomem_call;\n\n\t_debug(\"CALL %p{%s} [%d]\",\n\t       call, type->name, atomic_read(&afs_outstanding_calls));\n\tatomic_inc(&afs_outstanding_calls);\n\n\tcall->type = type;\n\tcall->request_size = request_size;\n\tcall->reply_max = reply_size;\n\n\tif (request_size) {\n\t\tcall->request = kmalloc(request_size, GFP_NOFS);\n\t\tif (!call->request)\n\t\t\tgoto nomem_free;\n\t}\n\n\tif (reply_size) {\n\t\tcall->buffer = kmalloc(reply_size, GFP_NOFS);\n\t\tif (!call->buffer)\n\t\t\tgoto nomem_free;\n\t}\n\n\tinit_waitqueue_head(&call->waitq);\n\tskb_queue_head_init(&call->rx_queue);\n\treturn call;\n\nnomem_free:\n\tafs_free_call(call);\nnomem_call:\n\treturn NULL;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t afs_outstanding_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic atomic_t afs_outstanding_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nstruct afs_call *afs_alloc_flat_call(const struct afs_call_type *type,\n\t\t\t\t     size_t request_size, size_t reply_size)\n{\n\tstruct afs_call *call;\n\n\tcall = kzalloc(sizeof(*call), GFP_NOFS);\n\tif (!call)\n\t\tgoto nomem_call;\n\n\t_debug(\"CALL %p{%s} [%d]\",\n\t       call, type->name, atomic_read(&afs_outstanding_calls));\n\tatomic_inc(&afs_outstanding_calls);\n\n\tcall->type = type;\n\tcall->request_size = request_size;\n\tcall->reply_max = reply_size;\n\n\tif (request_size) {\n\t\tcall->request = kmalloc(request_size, GFP_NOFS);\n\t\tif (!call->request)\n\t\t\tgoto nomem_free;\n\t}\n\n\tif (reply_size) {\n\t\tcall->buffer = kmalloc(reply_size, GFP_NOFS);\n\t\tif (!call->buffer)\n\t\t\tgoto nomem_free;\n\t}\n\n\tinit_waitqueue_head(&call->waitq);\n\tskb_queue_head_init(&call->rx_queue);\n\treturn call;\n\nnomem_free:\n\tafs_free_call(call);\nnomem_call:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 1860
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic const struct afs_call_type afs_RXFSExtendLock = {\n\t.name\t\t= \"FS.ExtendLock\",\n\t.deliver\t= afs_deliver_fs_xxxx_lock,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\nint afs_fs_extend_lock(struct afs_server *server,\n\t\t       struct key *key,\n\t\t       struct afs_vnode *vnode,\n\t\t       const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tcall = afs_alloc_flat_call(&afs_RXFSExtendLock, 4 * 4, 6 * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(FSEXTENDLOCK);\n\t*bp++ = htonl(vnode->fid.vid);\n\t*bp++ = htonl(vnode->fid.vnode);\n\t*bp++ = htonl(vnode->fid.unique);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}"
  },
  {
    "function_name": "afs_fs_set_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
    "lines": "1818-1847",
    "snippet": "int afs_fs_set_lock(struct afs_server *server,\n\t\t    struct key *key,\n\t\t    struct afs_vnode *vnode,\n\t\t    afs_lock_type_t type,\n\t\t    const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tcall = afs_alloc_flat_call(&afs_RXFSSetLock, 5 * 4, 6 * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(FSSETLOCK);\n\t*bp++ = htonl(vnode->fid.vid);\n\t*bp++ = htonl(vnode->fid.vnode);\n\t*bp++ = htonl(vnode->fid.unique);\n\t*bp++ = htonl(type);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}",
    "includes": [
      "#include \"afs_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/circ_buf.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct afs_call_type afs_RXFSSetLock = {\n\t.name\t\t= \"FS.SetLock\",\n\t.deliver\t= afs_deliver_fs_xxxx_lock,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "afs_make_call",
          "args": [
            "&server->addr",
            "call",
            "GFP_NOFS",
            "wait_mode"
          ],
          "line": 1846
        },
        "resolved": true,
        "details": {
          "function_name": "afs_make_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "338-420",
          "snippet": "int afs_make_call(struct in_addr *addr, struct afs_call *call, gfp_t gfp,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct sockaddr_rxrpc srx;\n\tstruct rxrpc_call *rxcall;\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tint ret;\n\tstruct sk_buff *skb;\n\n\t_enter(\"%x,{%d},\", addr->s_addr, ntohs(call->port));\n\n\tASSERT(call->type != NULL);\n\tASSERT(call->type->name != NULL);\n\n\t_debug(\"____MAKE %p{%s,%x} [%d]____\",\n\t       call, call->type->name, key_serial(call->key),\n\t       atomic_read(&afs_outstanding_calls));\n\n\tcall->wait_mode = wait_mode;\n\tcall->async_workfn = afs_process_async_call;\n\tINIT_WORK(&call->async_work, afs_async_workfn);\n\n\tmemset(&srx, 0, sizeof(srx));\n\tsrx.srx_family = AF_RXRPC;\n\tsrx.srx_service = call->service_id;\n\tsrx.transport_type = SOCK_DGRAM;\n\tsrx.transport_len = sizeof(srx.transport.sin);\n\tsrx.transport.sin.sin_family = AF_INET;\n\tsrx.transport.sin.sin_port = call->port;\n\tmemcpy(&srx.transport.sin.sin_addr, addr, 4);\n\n\t/* create a call */\n\trxcall = rxrpc_kernel_begin_call(afs_socket, &srx, call->key,\n\t\t\t\t\t (unsigned long) call, gfp);\n\tcall->key = NULL;\n\tif (IS_ERR(rxcall)) {\n\t\tret = PTR_ERR(rxcall);\n\t\tgoto error_kill_call;\n\t}\n\n\tcall->rxcall = rxcall;\n\n\t/* send the request */\n\tiov[0].iov_base\t= call->request;\n\tiov[0].iov_len\t= call->request_size;\n\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1,\n\t\t      call->request_size);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= (call->send_pages ? MSG_MORE : 0);\n\n\t/* have to change the state *before* sending the last packet as RxRPC\n\t * might give us the reply before it returns from sending the\n\t * request */\n\tif (!call->send_pages)\n\t\tcall->state = AFS_CALL_AWAIT_REPLY;\n\tret = rxrpc_kernel_send_data(rxcall, &msg, call->request_size);\n\tif (ret < 0)\n\t\tgoto error_do_abort;\n\n\tif (call->send_pages) {\n\t\tret = afs_send_pages(call, &msg, iov);\n\t\tif (ret < 0)\n\t\t\tgoto error_do_abort;\n\t}\n\n\t/* at this point, an async call may no longer exist as it may have\n\t * already completed */\n\treturn wait_mode->wait(call);\n\nerror_do_abort:\n\trxrpc_kernel_abort_call(rxcall, RX_USER_ABORT);\n\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\tafs_free_skb(skb);\nerror_kill_call:\n\tafs_end_call(call);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct socket *afs_socket;",
            "static atomic_t afs_outstanding_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);",
            "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
            "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic struct socket *afs_socket;\nstatic atomic_t afs_outstanding_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\n\nint afs_make_call(struct in_addr *addr, struct afs_call *call, gfp_t gfp,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct sockaddr_rxrpc srx;\n\tstruct rxrpc_call *rxcall;\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tint ret;\n\tstruct sk_buff *skb;\n\n\t_enter(\"%x,{%d},\", addr->s_addr, ntohs(call->port));\n\n\tASSERT(call->type != NULL);\n\tASSERT(call->type->name != NULL);\n\n\t_debug(\"____MAKE %p{%s,%x} [%d]____\",\n\t       call, call->type->name, key_serial(call->key),\n\t       atomic_read(&afs_outstanding_calls));\n\n\tcall->wait_mode = wait_mode;\n\tcall->async_workfn = afs_process_async_call;\n\tINIT_WORK(&call->async_work, afs_async_workfn);\n\n\tmemset(&srx, 0, sizeof(srx));\n\tsrx.srx_family = AF_RXRPC;\n\tsrx.srx_service = call->service_id;\n\tsrx.transport_type = SOCK_DGRAM;\n\tsrx.transport_len = sizeof(srx.transport.sin);\n\tsrx.transport.sin.sin_family = AF_INET;\n\tsrx.transport.sin.sin_port = call->port;\n\tmemcpy(&srx.transport.sin.sin_addr, addr, 4);\n\n\t/* create a call */\n\trxcall = rxrpc_kernel_begin_call(afs_socket, &srx, call->key,\n\t\t\t\t\t (unsigned long) call, gfp);\n\tcall->key = NULL;\n\tif (IS_ERR(rxcall)) {\n\t\tret = PTR_ERR(rxcall);\n\t\tgoto error_kill_call;\n\t}\n\n\tcall->rxcall = rxcall;\n\n\t/* send the request */\n\tiov[0].iov_base\t= call->request;\n\tiov[0].iov_len\t= call->request_size;\n\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1,\n\t\t      call->request_size);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= (call->send_pages ? MSG_MORE : 0);\n\n\t/* have to change the state *before* sending the last packet as RxRPC\n\t * might give us the reply before it returns from sending the\n\t * request */\n\tif (!call->send_pages)\n\t\tcall->state = AFS_CALL_AWAIT_REPLY;\n\tret = rxrpc_kernel_send_data(rxcall, &msg, call->request_size);\n\tif (ret < 0)\n\t\tgoto error_do_abort;\n\n\tif (call->send_pages) {\n\t\tret = afs_send_pages(call, &msg, iov);\n\t\tif (ret < 0)\n\t\t\tgoto error_do_abort;\n\t}\n\n\t/* at this point, an async call may no longer exist as it may have\n\t * already completed */\n\treturn wait_mode->wait(call);\n\nerror_do_abort:\n\trxrpc_kernel_abort_call(rxcall, RX_USER_ABORT);\n\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\tafs_free_skb(skb);\nerror_kill_call:\n\tafs_end_call(call);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "type"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "vnode->fid.unique"
          ],
          "line": 1843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "vnode->fid.vnode"
          ],
          "line": 1842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "vnode->fid.vid"
          ],
          "line": 1841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "FSSETLOCK"
          ],
          "line": 1840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "AFS_FS_PORT"
          ],
          "line": 1836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_alloc_flat_call",
          "args": [
            "&afs_RXFSSetLock",
            "5 * 4",
            "6 * 4"
          ],
          "line": 1829
        },
        "resolved": true,
        "details": {
          "function_name": "afs_alloc_flat_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "218-255",
          "snippet": "struct afs_call *afs_alloc_flat_call(const struct afs_call_type *type,\n\t\t\t\t     size_t request_size, size_t reply_size)\n{\n\tstruct afs_call *call;\n\n\tcall = kzalloc(sizeof(*call), GFP_NOFS);\n\tif (!call)\n\t\tgoto nomem_call;\n\n\t_debug(\"CALL %p{%s} [%d]\",\n\t       call, type->name, atomic_read(&afs_outstanding_calls));\n\tatomic_inc(&afs_outstanding_calls);\n\n\tcall->type = type;\n\tcall->request_size = request_size;\n\tcall->reply_max = reply_size;\n\n\tif (request_size) {\n\t\tcall->request = kmalloc(request_size, GFP_NOFS);\n\t\tif (!call->request)\n\t\t\tgoto nomem_free;\n\t}\n\n\tif (reply_size) {\n\t\tcall->buffer = kmalloc(reply_size, GFP_NOFS);\n\t\tif (!call->buffer)\n\t\t\tgoto nomem_free;\n\t}\n\n\tinit_waitqueue_head(&call->waitq);\n\tskb_queue_head_init(&call->rx_queue);\n\treturn call;\n\nnomem_free:\n\tafs_free_call(call);\nnomem_call:\n\treturn NULL;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t afs_outstanding_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic atomic_t afs_outstanding_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nstruct afs_call *afs_alloc_flat_call(const struct afs_call_type *type,\n\t\t\t\t     size_t request_size, size_t reply_size)\n{\n\tstruct afs_call *call;\n\n\tcall = kzalloc(sizeof(*call), GFP_NOFS);\n\tif (!call)\n\t\tgoto nomem_call;\n\n\t_debug(\"CALL %p{%s} [%d]\",\n\t       call, type->name, atomic_read(&afs_outstanding_calls));\n\tatomic_inc(&afs_outstanding_calls);\n\n\tcall->type = type;\n\tcall->request_size = request_size;\n\tcall->reply_max = reply_size;\n\n\tif (request_size) {\n\t\tcall->request = kmalloc(request_size, GFP_NOFS);\n\t\tif (!call->request)\n\t\t\tgoto nomem_free;\n\t}\n\n\tif (reply_size) {\n\t\tcall->buffer = kmalloc(reply_size, GFP_NOFS);\n\t\tif (!call->buffer)\n\t\t\tgoto nomem_free;\n\t}\n\n\tinit_waitqueue_head(&call->waitq);\n\tskb_queue_head_init(&call->rx_queue);\n\treturn call;\n\nnomem_free:\n\tafs_free_call(call);\nnomem_call:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 1827
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic const struct afs_call_type afs_RXFSSetLock = {\n\t.name\t\t= \"FS.SetLock\",\n\t.deliver\t= afs_deliver_fs_xxxx_lock,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\nint afs_fs_set_lock(struct afs_server *server,\n\t\t    struct key *key,\n\t\t    struct afs_vnode *vnode,\n\t\t    afs_lock_type_t type,\n\t\t    const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tcall = afs_alloc_flat_call(&afs_RXFSSetLock, 5 * 4, 6 * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(FSSETLOCK);\n\t*bp++ = htonl(vnode->fid.vid);\n\t*bp++ = htonl(vnode->fid.vnode);\n\t*bp++ = htonl(vnode->fid.unique);\n\t*bp++ = htonl(type);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}"
  },
  {
    "function_name": "afs_deliver_fs_xxxx_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
    "lines": "1763-1783",
    "snippet": "static int afs_deliver_fs_xxxx_lock(struct afs_call *call,\n\t\t\t\t    struct sk_buff *skb, bool last)\n{\n\tconst __be32 *bp;\n\n\t_enter(\"{%u},{%u},%d\", call->unmarshall, skb->len, last);\n\n\tafs_transfer_reply(call, skb);\n\tif (!last)\n\t\treturn 0;\n\n\tif (call->reply_size != call->reply_max)\n\t\treturn -EBADMSG;\n\n\t/* unmarshall the reply once we've received all of it */\n\tbp = call->buffer;\n\t/* xdr_decode_AFSVolSync(&bp, call->replyX); */\n\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}",
    "includes": [
      "#include \"afs_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/circ_buf.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = 0 [done]\""
          ],
          "line": 1781
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_transfer_reply",
          "args": [
            "call",
            "skb"
          ],
          "line": 1770
        },
        "resolved": true,
        "details": {
          "function_name": "afs_transfer_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "668-675",
          "snippet": "void afs_transfer_reply(struct afs_call *call, struct sk_buff *skb)\n{\n\tsize_t len = skb->len;\n\n\tif (skb_copy_bits(skb, 0, call->buffer + call->reply_size, len) < 0)\n\t\tBUG();\n\tcall->reply_size += len;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);",
            "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
            "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\n\nvoid afs_transfer_reply(struct afs_call *call, struct sk_buff *skb)\n{\n\tsize_t len = skb->len;\n\n\tif (skb_copy_bits(skb, 0, call->buffer + call->reply_size, len) < 0)\n\t\tBUG();\n\tcall->reply_size += len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%u},{%u},%d\"",
            "call->unmarshall",
            "skb->len",
            "last"
          ],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic int afs_deliver_fs_xxxx_lock(struct afs_call *call,\n\t\t\t\t    struct sk_buff *skb, bool last)\n{\n\tconst __be32 *bp;\n\n\t_enter(\"{%u},{%u},%d\", call->unmarshall, skb->len, last);\n\n\tafs_transfer_reply(call, skb);\n\tif (!last)\n\t\treturn 0;\n\n\tif (call->reply_size != call->reply_max)\n\t\treturn -EBADMSG;\n\n\t/* unmarshall the reply once we've received all of it */\n\tbp = call->buffer;\n\t/* xdr_decode_AFSVolSync(&bp, call->replyX); */\n\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}"
  },
  {
    "function_name": "afs_fs_get_volume_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
    "lines": "1723-1758",
    "snippet": "int afs_fs_get_volume_status(struct afs_server *server,\n\t\t\t     struct key *key,\n\t\t\t     struct afs_vnode *vnode,\n\t\t\t     struct afs_volume_status *vs,\n\t\t\t     const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\t__be32 *bp;\n\tvoid *tmpbuf;\n\n\t_enter(\"\");\n\n\ttmpbuf = kmalloc(AFSOPAQUEMAX, GFP_KERNEL);\n\tif (!tmpbuf)\n\t\treturn -ENOMEM;\n\n\tcall = afs_alloc_flat_call(&afs_RXFSGetVolumeStatus, 2 * 4, 12 * 4);\n\tif (!call) {\n\t\tkfree(tmpbuf);\n\t\treturn -ENOMEM;\n\t}\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->reply2 = vs;\n\tcall->reply3 = tmpbuf;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\tbp[0] = htonl(FSGETVOLUMESTATUS);\n\tbp[1] = htonl(vnode->fid.vid);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}",
    "includes": [
      "#include \"afs_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/circ_buf.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct afs_call_type afs_RXFSGetVolumeStatus = {\n\t.name\t\t= \"FS.GetVolumeStatus\",\n\t.deliver\t= afs_deliver_fs_get_volume_status,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_get_volume_status_call_destructor,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "afs_make_call",
          "args": [
            "&server->addr",
            "call",
            "GFP_NOFS",
            "wait_mode"
          ],
          "line": 1757
        },
        "resolved": true,
        "details": {
          "function_name": "afs_make_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "338-420",
          "snippet": "int afs_make_call(struct in_addr *addr, struct afs_call *call, gfp_t gfp,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct sockaddr_rxrpc srx;\n\tstruct rxrpc_call *rxcall;\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tint ret;\n\tstruct sk_buff *skb;\n\n\t_enter(\"%x,{%d},\", addr->s_addr, ntohs(call->port));\n\n\tASSERT(call->type != NULL);\n\tASSERT(call->type->name != NULL);\n\n\t_debug(\"____MAKE %p{%s,%x} [%d]____\",\n\t       call, call->type->name, key_serial(call->key),\n\t       atomic_read(&afs_outstanding_calls));\n\n\tcall->wait_mode = wait_mode;\n\tcall->async_workfn = afs_process_async_call;\n\tINIT_WORK(&call->async_work, afs_async_workfn);\n\n\tmemset(&srx, 0, sizeof(srx));\n\tsrx.srx_family = AF_RXRPC;\n\tsrx.srx_service = call->service_id;\n\tsrx.transport_type = SOCK_DGRAM;\n\tsrx.transport_len = sizeof(srx.transport.sin);\n\tsrx.transport.sin.sin_family = AF_INET;\n\tsrx.transport.sin.sin_port = call->port;\n\tmemcpy(&srx.transport.sin.sin_addr, addr, 4);\n\n\t/* create a call */\n\trxcall = rxrpc_kernel_begin_call(afs_socket, &srx, call->key,\n\t\t\t\t\t (unsigned long) call, gfp);\n\tcall->key = NULL;\n\tif (IS_ERR(rxcall)) {\n\t\tret = PTR_ERR(rxcall);\n\t\tgoto error_kill_call;\n\t}\n\n\tcall->rxcall = rxcall;\n\n\t/* send the request */\n\tiov[0].iov_base\t= call->request;\n\tiov[0].iov_len\t= call->request_size;\n\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1,\n\t\t      call->request_size);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= (call->send_pages ? MSG_MORE : 0);\n\n\t/* have to change the state *before* sending the last packet as RxRPC\n\t * might give us the reply before it returns from sending the\n\t * request */\n\tif (!call->send_pages)\n\t\tcall->state = AFS_CALL_AWAIT_REPLY;\n\tret = rxrpc_kernel_send_data(rxcall, &msg, call->request_size);\n\tif (ret < 0)\n\t\tgoto error_do_abort;\n\n\tif (call->send_pages) {\n\t\tret = afs_send_pages(call, &msg, iov);\n\t\tif (ret < 0)\n\t\t\tgoto error_do_abort;\n\t}\n\n\t/* at this point, an async call may no longer exist as it may have\n\t * already completed */\n\treturn wait_mode->wait(call);\n\nerror_do_abort:\n\trxrpc_kernel_abort_call(rxcall, RX_USER_ABORT);\n\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\tafs_free_skb(skb);\nerror_kill_call:\n\tafs_end_call(call);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct socket *afs_socket;",
            "static atomic_t afs_outstanding_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);",
            "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
            "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic struct socket *afs_socket;\nstatic atomic_t afs_outstanding_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\n\nint afs_make_call(struct in_addr *addr, struct afs_call *call, gfp_t gfp,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct sockaddr_rxrpc srx;\n\tstruct rxrpc_call *rxcall;\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tint ret;\n\tstruct sk_buff *skb;\n\n\t_enter(\"%x,{%d},\", addr->s_addr, ntohs(call->port));\n\n\tASSERT(call->type != NULL);\n\tASSERT(call->type->name != NULL);\n\n\t_debug(\"____MAKE %p{%s,%x} [%d]____\",\n\t       call, call->type->name, key_serial(call->key),\n\t       atomic_read(&afs_outstanding_calls));\n\n\tcall->wait_mode = wait_mode;\n\tcall->async_workfn = afs_process_async_call;\n\tINIT_WORK(&call->async_work, afs_async_workfn);\n\n\tmemset(&srx, 0, sizeof(srx));\n\tsrx.srx_family = AF_RXRPC;\n\tsrx.srx_service = call->service_id;\n\tsrx.transport_type = SOCK_DGRAM;\n\tsrx.transport_len = sizeof(srx.transport.sin);\n\tsrx.transport.sin.sin_family = AF_INET;\n\tsrx.transport.sin.sin_port = call->port;\n\tmemcpy(&srx.transport.sin.sin_addr, addr, 4);\n\n\t/* create a call */\n\trxcall = rxrpc_kernel_begin_call(afs_socket, &srx, call->key,\n\t\t\t\t\t (unsigned long) call, gfp);\n\tcall->key = NULL;\n\tif (IS_ERR(rxcall)) {\n\t\tret = PTR_ERR(rxcall);\n\t\tgoto error_kill_call;\n\t}\n\n\tcall->rxcall = rxcall;\n\n\t/* send the request */\n\tiov[0].iov_base\t= call->request;\n\tiov[0].iov_len\t= call->request_size;\n\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1,\n\t\t      call->request_size);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= (call->send_pages ? MSG_MORE : 0);\n\n\t/* have to change the state *before* sending the last packet as RxRPC\n\t * might give us the reply before it returns from sending the\n\t * request */\n\tif (!call->send_pages)\n\t\tcall->state = AFS_CALL_AWAIT_REPLY;\n\tret = rxrpc_kernel_send_data(rxcall, &msg, call->request_size);\n\tif (ret < 0)\n\t\tgoto error_do_abort;\n\n\tif (call->send_pages) {\n\t\tret = afs_send_pages(call, &msg, iov);\n\t\tif (ret < 0)\n\t\t\tgoto error_do_abort;\n\t}\n\n\t/* at this point, an async call may no longer exist as it may have\n\t * already completed */\n\treturn wait_mode->wait(call);\n\nerror_do_abort:\n\trxrpc_kernel_abort_call(rxcall, RX_USER_ABORT);\n\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\tafs_free_skb(skb);\nerror_kill_call:\n\tafs_end_call(call);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "vnode->fid.vid"
          ],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "FSGETVOLUMESTATUS"
          ],
          "line": 1754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "AFS_FS_PORT"
          ],
          "line": 1750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tmpbuf"
          ],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_alloc_flat_call",
          "args": [
            "&afs_RXFSGetVolumeStatus",
            "2 * 4",
            "12 * 4"
          ],
          "line": 1739
        },
        "resolved": true,
        "details": {
          "function_name": "afs_alloc_flat_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "218-255",
          "snippet": "struct afs_call *afs_alloc_flat_call(const struct afs_call_type *type,\n\t\t\t\t     size_t request_size, size_t reply_size)\n{\n\tstruct afs_call *call;\n\n\tcall = kzalloc(sizeof(*call), GFP_NOFS);\n\tif (!call)\n\t\tgoto nomem_call;\n\n\t_debug(\"CALL %p{%s} [%d]\",\n\t       call, type->name, atomic_read(&afs_outstanding_calls));\n\tatomic_inc(&afs_outstanding_calls);\n\n\tcall->type = type;\n\tcall->request_size = request_size;\n\tcall->reply_max = reply_size;\n\n\tif (request_size) {\n\t\tcall->request = kmalloc(request_size, GFP_NOFS);\n\t\tif (!call->request)\n\t\t\tgoto nomem_free;\n\t}\n\n\tif (reply_size) {\n\t\tcall->buffer = kmalloc(reply_size, GFP_NOFS);\n\t\tif (!call->buffer)\n\t\t\tgoto nomem_free;\n\t}\n\n\tinit_waitqueue_head(&call->waitq);\n\tskb_queue_head_init(&call->rx_queue);\n\treturn call;\n\nnomem_free:\n\tafs_free_call(call);\nnomem_call:\n\treturn NULL;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t afs_outstanding_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic atomic_t afs_outstanding_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nstruct afs_call *afs_alloc_flat_call(const struct afs_call_type *type,\n\t\t\t\t     size_t request_size, size_t reply_size)\n{\n\tstruct afs_call *call;\n\n\tcall = kzalloc(sizeof(*call), GFP_NOFS);\n\tif (!call)\n\t\tgoto nomem_call;\n\n\t_debug(\"CALL %p{%s} [%d]\",\n\t       call, type->name, atomic_read(&afs_outstanding_calls));\n\tatomic_inc(&afs_outstanding_calls);\n\n\tcall->type = type;\n\tcall->request_size = request_size;\n\tcall->reply_max = reply_size;\n\n\tif (request_size) {\n\t\tcall->request = kmalloc(request_size, GFP_NOFS);\n\t\tif (!call->request)\n\t\t\tgoto nomem_free;\n\t}\n\n\tif (reply_size) {\n\t\tcall->buffer = kmalloc(reply_size, GFP_NOFS);\n\t\tif (!call->buffer)\n\t\t\tgoto nomem_free;\n\t}\n\n\tinit_waitqueue_head(&call->waitq);\n\tskb_queue_head_init(&call->rx_queue);\n\treturn call;\n\nnomem_free:\n\tafs_free_call(call);\nnomem_call:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "AFSOPAQUEMAX",
            "GFP_KERNEL"
          ],
          "line": 1735
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 1733
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic const struct afs_call_type afs_RXFSGetVolumeStatus = {\n\t.name\t\t= \"FS.GetVolumeStatus\",\n\t.deliver\t= afs_deliver_fs_get_volume_status,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_get_volume_status_call_destructor,\n};\n\nint afs_fs_get_volume_status(struct afs_server *server,\n\t\t\t     struct key *key,\n\t\t\t     struct afs_vnode *vnode,\n\t\t\t     struct afs_volume_status *vs,\n\t\t\t     const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\t__be32 *bp;\n\tvoid *tmpbuf;\n\n\t_enter(\"\");\n\n\ttmpbuf = kmalloc(AFSOPAQUEMAX, GFP_KERNEL);\n\tif (!tmpbuf)\n\t\treturn -ENOMEM;\n\n\tcall = afs_alloc_flat_call(&afs_RXFSGetVolumeStatus, 2 * 4, 12 * 4);\n\tif (!call) {\n\t\tkfree(tmpbuf);\n\t\treturn -ENOMEM;\n\t}\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->reply2 = vs;\n\tcall->reply3 = tmpbuf;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\tbp[0] = htonl(FSGETVOLUMESTATUS);\n\tbp[1] = htonl(vnode->fid.vid);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}"
  },
  {
    "function_name": "afs_get_volume_status_call_destructor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
    "lines": "1703-1708",
    "snippet": "static void afs_get_volume_status_call_destructor(struct afs_call *call)\n{\n\tkfree(call->reply3);\n\tcall->reply3 = NULL;\n\tafs_flat_call_destructor(call);\n}",
    "includes": [
      "#include \"afs_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/circ_buf.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "afs_flat_call_destructor",
          "args": [
            "call"
          ],
          "line": 1707
        },
        "resolved": true,
        "details": {
          "function_name": "afs_flat_call_destructor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "260-268",
          "snippet": "void afs_flat_call_destructor(struct afs_call *call)\n{\n\t_enter(\"\");\n\n\tkfree(call->request);\n\tcall->request = NULL;\n\tkfree(call->buffer);\n\tcall->buffer = NULL;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nvoid afs_flat_call_destructor(struct afs_call *call)\n{\n\t_enter(\"\");\n\n\tkfree(call->request);\n\tcall->request = NULL;\n\tkfree(call->buffer);\n\tcall->buffer = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "call->reply3"
          ],
          "line": 1705
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic void afs_get_volume_status_call_destructor(struct afs_call *call)\n{\n\tkfree(call->reply3);\n\tcall->reply3 = NULL;\n\tafs_flat_call_destructor(call);\n}"
  },
  {
    "function_name": "afs_deliver_fs_get_volume_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
    "lines": "1488-1698",
    "snippet": "static int afs_deliver_fs_get_volume_status(struct afs_call *call,\n\t\t\t\t\t    struct sk_buff *skb, bool last)\n{\n\tconst __be32 *bp;\n\tchar *p;\n\tint ret;\n\n\t_enter(\"{%u},{%u},%d\", call->unmarshall, skb->len, last);\n\n\tswitch (call->unmarshall) {\n\tcase 0:\n\t\tcall->offset = 0;\n\t\tcall->unmarshall++;\n\n\t\t/* extract the returned status record */\n\tcase 1:\n\t\t_debug(\"extract status\");\n\t\tret = afs_extract_data(call, skb, last, call->buffer,\n\t\t\t\t       12 * 4);\n\t\tswitch (ret) {\n\t\tcase 0:\t\tbreak;\n\t\tcase -EAGAIN:\treturn 0;\n\t\tdefault:\treturn ret;\n\t\t}\n\n\t\tbp = call->buffer;\n\t\txdr_decode_AFSFetchVolumeStatus(&bp, call->reply2);\n\t\tcall->offset = 0;\n\t\tcall->unmarshall++;\n\n\t\t/* extract the volume name length */\n\tcase 2:\n\t\tret = afs_extract_data(call, skb, last, &call->tmp, 4);\n\t\tswitch (ret) {\n\t\tcase 0:\t\tbreak;\n\t\tcase -EAGAIN:\treturn 0;\n\t\tdefault:\treturn ret;\n\t\t}\n\n\t\tcall->count = ntohl(call->tmp);\n\t\t_debug(\"volname length: %u\", call->count);\n\t\tif (call->count >= AFSNAMEMAX)\n\t\t\treturn -EBADMSG;\n\t\tcall->offset = 0;\n\t\tcall->unmarshall++;\n\n\t\t/* extract the volume name */\n\tcase 3:\n\t\t_debug(\"extract volname\");\n\t\tif (call->count > 0) {\n\t\t\tret = afs_extract_data(call, skb, last, call->reply3,\n\t\t\t\t\t       call->count);\n\t\t\tswitch (ret) {\n\t\t\tcase 0:\t\tbreak;\n\t\t\tcase -EAGAIN:\treturn 0;\n\t\t\tdefault:\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tp = call->reply3;\n\t\tp[call->count] = 0;\n\t\t_debug(\"volname '%s'\", p);\n\n\t\tcall->offset = 0;\n\t\tcall->unmarshall++;\n\n\t\t/* extract the volume name padding */\n\t\tif ((call->count & 3) == 0) {\n\t\t\tcall->unmarshall++;\n\t\t\tgoto no_volname_padding;\n\t\t}\n\t\tcall->count = 4 - (call->count & 3);\n\n\tcase 4:\n\t\tret = afs_extract_data(call, skb, last, call->buffer,\n\t\t\t\t       call->count);\n\t\tswitch (ret) {\n\t\tcase 0:\t\tbreak;\n\t\tcase -EAGAIN:\treturn 0;\n\t\tdefault:\treturn ret;\n\t\t}\n\n\t\tcall->offset = 0;\n\t\tcall->unmarshall++;\n\tno_volname_padding:\n\n\t\t/* extract the offline message length */\n\tcase 5:\n\t\tret = afs_extract_data(call, skb, last, &call->tmp, 4);\n\t\tswitch (ret) {\n\t\tcase 0:\t\tbreak;\n\t\tcase -EAGAIN:\treturn 0;\n\t\tdefault:\treturn ret;\n\t\t}\n\n\t\tcall->count = ntohl(call->tmp);\n\t\t_debug(\"offline msg length: %u\", call->count);\n\t\tif (call->count >= AFSNAMEMAX)\n\t\t\treturn -EBADMSG;\n\t\tcall->offset = 0;\n\t\tcall->unmarshall++;\n\n\t\t/* extract the offline message */\n\tcase 6:\n\t\t_debug(\"extract offline\");\n\t\tif (call->count > 0) {\n\t\t\tret = afs_extract_data(call, skb, last, call->reply3,\n\t\t\t\t\t       call->count);\n\t\t\tswitch (ret) {\n\t\t\tcase 0:\t\tbreak;\n\t\t\tcase -EAGAIN:\treturn 0;\n\t\t\tdefault:\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tp = call->reply3;\n\t\tp[call->count] = 0;\n\t\t_debug(\"offline '%s'\", p);\n\n\t\tcall->offset = 0;\n\t\tcall->unmarshall++;\n\n\t\t/* extract the offline message padding */\n\t\tif ((call->count & 3) == 0) {\n\t\t\tcall->unmarshall++;\n\t\t\tgoto no_offline_padding;\n\t\t}\n\t\tcall->count = 4 - (call->count & 3);\n\n\tcase 7:\n\t\tret = afs_extract_data(call, skb, last, call->buffer,\n\t\t\t\t       call->count);\n\t\tswitch (ret) {\n\t\tcase 0:\t\tbreak;\n\t\tcase -EAGAIN:\treturn 0;\n\t\tdefault:\treturn ret;\n\t\t}\n\n\t\tcall->offset = 0;\n\t\tcall->unmarshall++;\n\tno_offline_padding:\n\n\t\t/* extract the message of the day length */\n\tcase 8:\n\t\tret = afs_extract_data(call, skb, last, &call->tmp, 4);\n\t\tswitch (ret) {\n\t\tcase 0:\t\tbreak;\n\t\tcase -EAGAIN:\treturn 0;\n\t\tdefault:\treturn ret;\n\t\t}\n\n\t\tcall->count = ntohl(call->tmp);\n\t\t_debug(\"motd length: %u\", call->count);\n\t\tif (call->count >= AFSNAMEMAX)\n\t\t\treturn -EBADMSG;\n\t\tcall->offset = 0;\n\t\tcall->unmarshall++;\n\n\t\t/* extract the message of the day */\n\tcase 9:\n\t\t_debug(\"extract motd\");\n\t\tif (call->count > 0) {\n\t\t\tret = afs_extract_data(call, skb, last, call->reply3,\n\t\t\t\t\t       call->count);\n\t\t\tswitch (ret) {\n\t\t\tcase 0:\t\tbreak;\n\t\t\tcase -EAGAIN:\treturn 0;\n\t\t\tdefault:\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tp = call->reply3;\n\t\tp[call->count] = 0;\n\t\t_debug(\"motd '%s'\", p);\n\n\t\tcall->offset = 0;\n\t\tcall->unmarshall++;\n\n\t\t/* extract the message of the day padding */\n\t\tif ((call->count & 3) == 0) {\n\t\t\tcall->unmarshall++;\n\t\t\tgoto no_motd_padding;\n\t\t}\n\t\tcall->count = 4 - (call->count & 3);\n\n\tcase 10:\n\t\tret = afs_extract_data(call, skb, last, call->buffer,\n\t\t\t\t       call->count);\n\t\tswitch (ret) {\n\t\tcase 0:\t\tbreak;\n\t\tcase -EAGAIN:\treturn 0;\n\t\tdefault:\treturn ret;\n\t\t}\n\n\t\tcall->offset = 0;\n\t\tcall->unmarshall++;\n\tno_motd_padding:\n\n\tcase 11:\n\t\t_debug(\"trailer %d\", skb->len);\n\t\tif (skb->len != 0)\n\t\t\treturn -EBADMSG;\n\t\tbreak;\n\t}\n\n\tif (!last)\n\t\treturn 0;\n\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}",
    "includes": [
      "#include \"afs_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/circ_buf.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = 0 [done]\""
          ],
          "line": 1696
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"trailer %d\"",
            "skb->len"
          ],
          "line": 1687
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "392-395",
          "snippet": "static int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_destroy_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_destroy_inode(struct inode *inode);\n\nstatic int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_extract_data",
          "args": [
            "call",
            "skb",
            "last",
            "call->buffer",
            "call->count"
          ],
          "line": 1674
        },
        "resolved": true,
        "details": {
          "function_name": "afs_extract_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "841-865",
          "snippet": "int afs_extract_data(struct afs_call *call, struct sk_buff *skb,\n\t\t     bool last, void *buf, size_t count)\n{\n\tsize_t len = skb->len;\n\n\t_enter(\"{%u},{%zu},%d,,%zu\", call->offset, len, last, count);\n\n\tASSERTCMP(call->offset, <, count);\n\n\tlen = min_t(size_t, len, count - call->offset);\n\tif (skb_copy_bits(skb, 0, buf + call->offset, len) < 0 ||\n\t    !pskb_pull(skb, len))\n\t\tBUG();\n\tcall->offset += len;\n\n\tif (call->offset < count) {\n\t\tif (last) {\n\t\t\t_leave(\" = -EBADMSG [%d < %zu]\", call->offset, count);\n\t\t\treturn -EBADMSG;\n\t\t}\n\t\t_leave(\" = -EAGAIN\");\n\t\treturn -EAGAIN;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);",
            "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
            "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\n\nint afs_extract_data(struct afs_call *call, struct sk_buff *skb,\n\t\t     bool last, void *buf, size_t count)\n{\n\tsize_t len = skb->len;\n\n\t_enter(\"{%u},{%zu},%d,,%zu\", call->offset, len, last, count);\n\n\tASSERTCMP(call->offset, <, count);\n\n\tlen = min_t(size_t, len, count - call->offset);\n\tif (skb_copy_bits(skb, 0, buf + call->offset, len) < 0 ||\n\t    !pskb_pull(skb, len))\n\t\tBUG();\n\tcall->offset += len;\n\n\tif (call->offset < count) {\n\t\tif (last) {\n\t\t\t_leave(\" = -EBADMSG [%d < %zu]\", call->offset, count);\n\t\t\treturn -EBADMSG;\n\t\t}\n\t\t_leave(\" = -EAGAIN\");\n\t\treturn -EAGAIN;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"extract motd\""
          ],
          "line": 1648
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "call->tmp"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "call->tmp"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "call->tmp"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_AFSFetchVolumeStatus",
          "args": [
            "&bp",
            "call->reply2"
          ],
          "line": 1514
        },
        "resolved": true,
        "details": {
          "function_name": "xdr_decode_AFSFetchVolumeStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
          "lines": "215-233",
          "snippet": "static void xdr_decode_AFSFetchVolumeStatus(const __be32 **_bp,\n\t\t\t\t\t    struct afs_volume_status *vs)\n{\n\tconst __be32 *bp = *_bp;\n\n\tvs->vid\t\t\t= ntohl(*bp++);\n\tvs->parent_id\t\t= ntohl(*bp++);\n\tvs->online\t\t= ntohl(*bp++);\n\tvs->in_service\t\t= ntohl(*bp++);\n\tvs->blessed\t\t= ntohl(*bp++);\n\tvs->needs_salvage\t= ntohl(*bp++);\n\tvs->type\t\t= ntohl(*bp++);\n\tvs->min_quota\t\t= ntohl(*bp++);\n\tvs->max_quota\t\t= ntohl(*bp++);\n\tvs->blocks_in_use\t= ntohl(*bp++);\n\tvs->part_blocks_avail\t= ntohl(*bp++);\n\tvs->part_max_blocks\t= ntohl(*bp++);\n\t*_bp = bp;\n}",
          "includes": [
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic void xdr_decode_AFSFetchVolumeStatus(const __be32 **_bp,\n\t\t\t\t\t    struct afs_volume_status *vs)\n{\n\tconst __be32 *bp = *_bp;\n\n\tvs->vid\t\t\t= ntohl(*bp++);\n\tvs->parent_id\t\t= ntohl(*bp++);\n\tvs->online\t\t= ntohl(*bp++);\n\tvs->in_service\t\t= ntohl(*bp++);\n\tvs->blessed\t\t= ntohl(*bp++);\n\tvs->needs_salvage\t= ntohl(*bp++);\n\tvs->type\t\t= ntohl(*bp++);\n\tvs->min_quota\t\t= ntohl(*bp++);\n\tvs->max_quota\t\t= ntohl(*bp++);\n\tvs->blocks_in_use\t= ntohl(*bp++);\n\tvs->part_blocks_avail\t= ntohl(*bp++);\n\tvs->part_max_blocks\t= ntohl(*bp++);\n\t*_bp = bp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%u},{%u},%d\"",
            "call->unmarshall",
            "skb->len",
            "last"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic int afs_deliver_fs_get_volume_status(struct afs_call *call,\n\t\t\t\t\t    struct sk_buff *skb, bool last)\n{\n\tconst __be32 *bp;\n\tchar *p;\n\tint ret;\n\n\t_enter(\"{%u},{%u},%d\", call->unmarshall, skb->len, last);\n\n\tswitch (call->unmarshall) {\n\tcase 0:\n\t\tcall->offset = 0;\n\t\tcall->unmarshall++;\n\n\t\t/* extract the returned status record */\n\tcase 1:\n\t\t_debug(\"extract status\");\n\t\tret = afs_extract_data(call, skb, last, call->buffer,\n\t\t\t\t       12 * 4);\n\t\tswitch (ret) {\n\t\tcase 0:\t\tbreak;\n\t\tcase -EAGAIN:\treturn 0;\n\t\tdefault:\treturn ret;\n\t\t}\n\n\t\tbp = call->buffer;\n\t\txdr_decode_AFSFetchVolumeStatus(&bp, call->reply2);\n\t\tcall->offset = 0;\n\t\tcall->unmarshall++;\n\n\t\t/* extract the volume name length */\n\tcase 2:\n\t\tret = afs_extract_data(call, skb, last, &call->tmp, 4);\n\t\tswitch (ret) {\n\t\tcase 0:\t\tbreak;\n\t\tcase -EAGAIN:\treturn 0;\n\t\tdefault:\treturn ret;\n\t\t}\n\n\t\tcall->count = ntohl(call->tmp);\n\t\t_debug(\"volname length: %u\", call->count);\n\t\tif (call->count >= AFSNAMEMAX)\n\t\t\treturn -EBADMSG;\n\t\tcall->offset = 0;\n\t\tcall->unmarshall++;\n\n\t\t/* extract the volume name */\n\tcase 3:\n\t\t_debug(\"extract volname\");\n\t\tif (call->count > 0) {\n\t\t\tret = afs_extract_data(call, skb, last, call->reply3,\n\t\t\t\t\t       call->count);\n\t\t\tswitch (ret) {\n\t\t\tcase 0:\t\tbreak;\n\t\t\tcase -EAGAIN:\treturn 0;\n\t\t\tdefault:\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tp = call->reply3;\n\t\tp[call->count] = 0;\n\t\t_debug(\"volname '%s'\", p);\n\n\t\tcall->offset = 0;\n\t\tcall->unmarshall++;\n\n\t\t/* extract the volume name padding */\n\t\tif ((call->count & 3) == 0) {\n\t\t\tcall->unmarshall++;\n\t\t\tgoto no_volname_padding;\n\t\t}\n\t\tcall->count = 4 - (call->count & 3);\n\n\tcase 4:\n\t\tret = afs_extract_data(call, skb, last, call->buffer,\n\t\t\t\t       call->count);\n\t\tswitch (ret) {\n\t\tcase 0:\t\tbreak;\n\t\tcase -EAGAIN:\treturn 0;\n\t\tdefault:\treturn ret;\n\t\t}\n\n\t\tcall->offset = 0;\n\t\tcall->unmarshall++;\n\tno_volname_padding:\n\n\t\t/* extract the offline message length */\n\tcase 5:\n\t\tret = afs_extract_data(call, skb, last, &call->tmp, 4);\n\t\tswitch (ret) {\n\t\tcase 0:\t\tbreak;\n\t\tcase -EAGAIN:\treturn 0;\n\t\tdefault:\treturn ret;\n\t\t}\n\n\t\tcall->count = ntohl(call->tmp);\n\t\t_debug(\"offline msg length: %u\", call->count);\n\t\tif (call->count >= AFSNAMEMAX)\n\t\t\treturn -EBADMSG;\n\t\tcall->offset = 0;\n\t\tcall->unmarshall++;\n\n\t\t/* extract the offline message */\n\tcase 6:\n\t\t_debug(\"extract offline\");\n\t\tif (call->count > 0) {\n\t\t\tret = afs_extract_data(call, skb, last, call->reply3,\n\t\t\t\t\t       call->count);\n\t\t\tswitch (ret) {\n\t\t\tcase 0:\t\tbreak;\n\t\t\tcase -EAGAIN:\treturn 0;\n\t\t\tdefault:\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tp = call->reply3;\n\t\tp[call->count] = 0;\n\t\t_debug(\"offline '%s'\", p);\n\n\t\tcall->offset = 0;\n\t\tcall->unmarshall++;\n\n\t\t/* extract the offline message padding */\n\t\tif ((call->count & 3) == 0) {\n\t\t\tcall->unmarshall++;\n\t\t\tgoto no_offline_padding;\n\t\t}\n\t\tcall->count = 4 - (call->count & 3);\n\n\tcase 7:\n\t\tret = afs_extract_data(call, skb, last, call->buffer,\n\t\t\t\t       call->count);\n\t\tswitch (ret) {\n\t\tcase 0:\t\tbreak;\n\t\tcase -EAGAIN:\treturn 0;\n\t\tdefault:\treturn ret;\n\t\t}\n\n\t\tcall->offset = 0;\n\t\tcall->unmarshall++;\n\tno_offline_padding:\n\n\t\t/* extract the message of the day length */\n\tcase 8:\n\t\tret = afs_extract_data(call, skb, last, &call->tmp, 4);\n\t\tswitch (ret) {\n\t\tcase 0:\t\tbreak;\n\t\tcase -EAGAIN:\treturn 0;\n\t\tdefault:\treturn ret;\n\t\t}\n\n\t\tcall->count = ntohl(call->tmp);\n\t\t_debug(\"motd length: %u\", call->count);\n\t\tif (call->count >= AFSNAMEMAX)\n\t\t\treturn -EBADMSG;\n\t\tcall->offset = 0;\n\t\tcall->unmarshall++;\n\n\t\t/* extract the message of the day */\n\tcase 9:\n\t\t_debug(\"extract motd\");\n\t\tif (call->count > 0) {\n\t\t\tret = afs_extract_data(call, skb, last, call->reply3,\n\t\t\t\t\t       call->count);\n\t\t\tswitch (ret) {\n\t\t\tcase 0:\t\tbreak;\n\t\t\tcase -EAGAIN:\treturn 0;\n\t\t\tdefault:\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tp = call->reply3;\n\t\tp[call->count] = 0;\n\t\t_debug(\"motd '%s'\", p);\n\n\t\tcall->offset = 0;\n\t\tcall->unmarshall++;\n\n\t\t/* extract the message of the day padding */\n\t\tif ((call->count & 3) == 0) {\n\t\t\tcall->unmarshall++;\n\t\t\tgoto no_motd_padding;\n\t\t}\n\t\tcall->count = 4 - (call->count & 3);\n\n\tcase 10:\n\t\tret = afs_extract_data(call, skb, last, call->buffer,\n\t\t\t\t       call->count);\n\t\tswitch (ret) {\n\t\tcase 0:\t\tbreak;\n\t\tcase -EAGAIN:\treturn 0;\n\t\tdefault:\treturn ret;\n\t\t}\n\n\t\tcall->offset = 0;\n\t\tcall->unmarshall++;\n\tno_motd_padding:\n\n\tcase 11:\n\t\t_debug(\"trailer %d\", skb->len);\n\t\tif (skb->len != 0)\n\t\t\treturn -EBADMSG;\n\t\tbreak;\n\t}\n\n\tif (!last)\n\t\treturn 0;\n\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}"
  },
  {
    "function_name": "afs_fs_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
    "lines": "1447-1483",
    "snippet": "int afs_fs_setattr(struct afs_server *server, struct key *key,\n\t\t   struct afs_vnode *vnode, struct iattr *attr,\n\t\t   const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\tif (attr->ia_valid & ATTR_SIZE)\n\t\treturn afs_fs_setattr_size(server, key, vnode, attr,\n\t\t\t\t\t   wait_mode);\n\n\t_enter(\",%x,{%x:%u},,\",\n\t       key_serial(key), vnode->fid.vid, vnode->fid.vnode);\n\n\tcall = afs_alloc_flat_call(&afs_RXFSStoreStatus,\n\t\t\t\t   (4 + 6) * 4,\n\t\t\t\t   (21 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\tcall->operation_ID = FSSTORESTATUS;\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(FSSTORESTATUS);\n\t*bp++ = htonl(vnode->fid.vid);\n\t*bp++ = htonl(vnode->fid.vnode);\n\t*bp++ = htonl(vnode->fid.unique);\n\n\txdr_encode_AFS_StoreStatus(&bp, attr);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}",
    "includes": [
      "#include \"afs_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/circ_buf.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct afs_call_type afs_RXFSStoreStatus = {\n\t.name\t\t= \"FS.StoreStatus\",\n\t.deliver\t= afs_deliver_fs_store_status,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "afs_make_call",
          "args": [
            "&server->addr",
            "call",
            "GFP_NOFS",
            "wait_mode"
          ],
          "line": 1482
        },
        "resolved": true,
        "details": {
          "function_name": "afs_make_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "338-420",
          "snippet": "int afs_make_call(struct in_addr *addr, struct afs_call *call, gfp_t gfp,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct sockaddr_rxrpc srx;\n\tstruct rxrpc_call *rxcall;\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tint ret;\n\tstruct sk_buff *skb;\n\n\t_enter(\"%x,{%d},\", addr->s_addr, ntohs(call->port));\n\n\tASSERT(call->type != NULL);\n\tASSERT(call->type->name != NULL);\n\n\t_debug(\"____MAKE %p{%s,%x} [%d]____\",\n\t       call, call->type->name, key_serial(call->key),\n\t       atomic_read(&afs_outstanding_calls));\n\n\tcall->wait_mode = wait_mode;\n\tcall->async_workfn = afs_process_async_call;\n\tINIT_WORK(&call->async_work, afs_async_workfn);\n\n\tmemset(&srx, 0, sizeof(srx));\n\tsrx.srx_family = AF_RXRPC;\n\tsrx.srx_service = call->service_id;\n\tsrx.transport_type = SOCK_DGRAM;\n\tsrx.transport_len = sizeof(srx.transport.sin);\n\tsrx.transport.sin.sin_family = AF_INET;\n\tsrx.transport.sin.sin_port = call->port;\n\tmemcpy(&srx.transport.sin.sin_addr, addr, 4);\n\n\t/* create a call */\n\trxcall = rxrpc_kernel_begin_call(afs_socket, &srx, call->key,\n\t\t\t\t\t (unsigned long) call, gfp);\n\tcall->key = NULL;\n\tif (IS_ERR(rxcall)) {\n\t\tret = PTR_ERR(rxcall);\n\t\tgoto error_kill_call;\n\t}\n\n\tcall->rxcall = rxcall;\n\n\t/* send the request */\n\tiov[0].iov_base\t= call->request;\n\tiov[0].iov_len\t= call->request_size;\n\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1,\n\t\t      call->request_size);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= (call->send_pages ? MSG_MORE : 0);\n\n\t/* have to change the state *before* sending the last packet as RxRPC\n\t * might give us the reply before it returns from sending the\n\t * request */\n\tif (!call->send_pages)\n\t\tcall->state = AFS_CALL_AWAIT_REPLY;\n\tret = rxrpc_kernel_send_data(rxcall, &msg, call->request_size);\n\tif (ret < 0)\n\t\tgoto error_do_abort;\n\n\tif (call->send_pages) {\n\t\tret = afs_send_pages(call, &msg, iov);\n\t\tif (ret < 0)\n\t\t\tgoto error_do_abort;\n\t}\n\n\t/* at this point, an async call may no longer exist as it may have\n\t * already completed */\n\treturn wait_mode->wait(call);\n\nerror_do_abort:\n\trxrpc_kernel_abort_call(rxcall, RX_USER_ABORT);\n\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\tafs_free_skb(skb);\nerror_kill_call:\n\tafs_end_call(call);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct socket *afs_socket;",
            "static atomic_t afs_outstanding_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);",
            "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
            "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic struct socket *afs_socket;\nstatic atomic_t afs_outstanding_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\n\nint afs_make_call(struct in_addr *addr, struct afs_call *call, gfp_t gfp,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct sockaddr_rxrpc srx;\n\tstruct rxrpc_call *rxcall;\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tint ret;\n\tstruct sk_buff *skb;\n\n\t_enter(\"%x,{%d},\", addr->s_addr, ntohs(call->port));\n\n\tASSERT(call->type != NULL);\n\tASSERT(call->type->name != NULL);\n\n\t_debug(\"____MAKE %p{%s,%x} [%d]____\",\n\t       call, call->type->name, key_serial(call->key),\n\t       atomic_read(&afs_outstanding_calls));\n\n\tcall->wait_mode = wait_mode;\n\tcall->async_workfn = afs_process_async_call;\n\tINIT_WORK(&call->async_work, afs_async_workfn);\n\n\tmemset(&srx, 0, sizeof(srx));\n\tsrx.srx_family = AF_RXRPC;\n\tsrx.srx_service = call->service_id;\n\tsrx.transport_type = SOCK_DGRAM;\n\tsrx.transport_len = sizeof(srx.transport.sin);\n\tsrx.transport.sin.sin_family = AF_INET;\n\tsrx.transport.sin.sin_port = call->port;\n\tmemcpy(&srx.transport.sin.sin_addr, addr, 4);\n\n\t/* create a call */\n\trxcall = rxrpc_kernel_begin_call(afs_socket, &srx, call->key,\n\t\t\t\t\t (unsigned long) call, gfp);\n\tcall->key = NULL;\n\tif (IS_ERR(rxcall)) {\n\t\tret = PTR_ERR(rxcall);\n\t\tgoto error_kill_call;\n\t}\n\n\tcall->rxcall = rxcall;\n\n\t/* send the request */\n\tiov[0].iov_base\t= call->request;\n\tiov[0].iov_len\t= call->request_size;\n\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1,\n\t\t      call->request_size);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= (call->send_pages ? MSG_MORE : 0);\n\n\t/* have to change the state *before* sending the last packet as RxRPC\n\t * might give us the reply before it returns from sending the\n\t * request */\n\tif (!call->send_pages)\n\t\tcall->state = AFS_CALL_AWAIT_REPLY;\n\tret = rxrpc_kernel_send_data(rxcall, &msg, call->request_size);\n\tif (ret < 0)\n\t\tgoto error_do_abort;\n\n\tif (call->send_pages) {\n\t\tret = afs_send_pages(call, &msg, iov);\n\t\tif (ret < 0)\n\t\t\tgoto error_do_abort;\n\t}\n\n\t/* at this point, an async call may no longer exist as it may have\n\t * already completed */\n\treturn wait_mode->wait(call);\n\nerror_do_abort:\n\trxrpc_kernel_abort_call(rxcall, RX_USER_ABORT);\n\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\tafs_free_skb(skb);\nerror_kill_call:\n\tafs_end_call(call);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_encode_AFS_StoreStatus",
          "args": [
            "&bp",
            "attr"
          ],
          "line": 1480
        },
        "resolved": true,
        "details": {
          "function_name": "xdr_encode_AFS_StoreStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
          "lines": "177-210",
          "snippet": "static void xdr_encode_AFS_StoreStatus(__be32 **_bp, struct iattr *attr)\n{\n\t__be32 *bp = *_bp;\n\tu32 mask = 0, mtime = 0, owner = 0, group = 0, mode = 0;\n\n\tmask = 0;\n\tif (attr->ia_valid & ATTR_MTIME) {\n\t\tmask |= AFS_SET_MTIME;\n\t\tmtime = attr->ia_mtime.tv_sec;\n\t}\n\n\tif (attr->ia_valid & ATTR_UID) {\n\t\tmask |= AFS_SET_OWNER;\n\t\towner = from_kuid(&init_user_ns, attr->ia_uid);\n\t}\n\n\tif (attr->ia_valid & ATTR_GID) {\n\t\tmask |= AFS_SET_GROUP;\n\t\tgroup = from_kgid(&init_user_ns, attr->ia_gid);\n\t}\n\n\tif (attr->ia_valid & ATTR_MODE) {\n\t\tmask |= AFS_SET_MODE;\n\t\tmode = attr->ia_mode & S_IALLUGO;\n\t}\n\n\t*bp++ = htonl(mask);\n\t*bp++ = htonl(mtime);\n\t*bp++ = htonl(owner);\n\t*bp++ = htonl(group);\n\t*bp++ = htonl(mode);\n\t*bp++ = 0;\t\t/* segment size */\n\t*_bp = bp;\n}",
          "includes": [
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic void xdr_encode_AFS_StoreStatus(__be32 **_bp, struct iattr *attr)\n{\n\t__be32 *bp = *_bp;\n\tu32 mask = 0, mtime = 0, owner = 0, group = 0, mode = 0;\n\n\tmask = 0;\n\tif (attr->ia_valid & ATTR_MTIME) {\n\t\tmask |= AFS_SET_MTIME;\n\t\tmtime = attr->ia_mtime.tv_sec;\n\t}\n\n\tif (attr->ia_valid & ATTR_UID) {\n\t\tmask |= AFS_SET_OWNER;\n\t\towner = from_kuid(&init_user_ns, attr->ia_uid);\n\t}\n\n\tif (attr->ia_valid & ATTR_GID) {\n\t\tmask |= AFS_SET_GROUP;\n\t\tgroup = from_kgid(&init_user_ns, attr->ia_gid);\n\t}\n\n\tif (attr->ia_valid & ATTR_MODE) {\n\t\tmask |= AFS_SET_MODE;\n\t\tmode = attr->ia_mode & S_IALLUGO;\n\t}\n\n\t*bp++ = htonl(mask);\n\t*bp++ = htonl(mtime);\n\t*bp++ = htonl(owner);\n\t*bp++ = htonl(group);\n\t*bp++ = htonl(mode);\n\t*bp++ = 0;\t\t/* segment size */\n\t*_bp = bp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "vnode->fid.unique"
          ],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "vnode->fid.vnode"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "vnode->fid.vid"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "FSSTORESTATUS"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "AFS_FS_PORT"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_alloc_flat_call",
          "args": [
            "&afs_RXFSStoreStatus",
            "(4 + 6) * 4",
            "(21 + 6) * 4"
          ],
          "line": 1461
        },
        "resolved": true,
        "details": {
          "function_name": "afs_alloc_flat_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "218-255",
          "snippet": "struct afs_call *afs_alloc_flat_call(const struct afs_call_type *type,\n\t\t\t\t     size_t request_size, size_t reply_size)\n{\n\tstruct afs_call *call;\n\n\tcall = kzalloc(sizeof(*call), GFP_NOFS);\n\tif (!call)\n\t\tgoto nomem_call;\n\n\t_debug(\"CALL %p{%s} [%d]\",\n\t       call, type->name, atomic_read(&afs_outstanding_calls));\n\tatomic_inc(&afs_outstanding_calls);\n\n\tcall->type = type;\n\tcall->request_size = request_size;\n\tcall->reply_max = reply_size;\n\n\tif (request_size) {\n\t\tcall->request = kmalloc(request_size, GFP_NOFS);\n\t\tif (!call->request)\n\t\t\tgoto nomem_free;\n\t}\n\n\tif (reply_size) {\n\t\tcall->buffer = kmalloc(reply_size, GFP_NOFS);\n\t\tif (!call->buffer)\n\t\t\tgoto nomem_free;\n\t}\n\n\tinit_waitqueue_head(&call->waitq);\n\tskb_queue_head_init(&call->rx_queue);\n\treturn call;\n\nnomem_free:\n\tafs_free_call(call);\nnomem_call:\n\treturn NULL;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t afs_outstanding_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic atomic_t afs_outstanding_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nstruct afs_call *afs_alloc_flat_call(const struct afs_call_type *type,\n\t\t\t\t     size_t request_size, size_t reply_size)\n{\n\tstruct afs_call *call;\n\n\tcall = kzalloc(sizeof(*call), GFP_NOFS);\n\tif (!call)\n\t\tgoto nomem_call;\n\n\t_debug(\"CALL %p{%s} [%d]\",\n\t       call, type->name, atomic_read(&afs_outstanding_calls));\n\tatomic_inc(&afs_outstanding_calls);\n\n\tcall->type = type;\n\tcall->request_size = request_size;\n\tcall->reply_max = reply_size;\n\n\tif (request_size) {\n\t\tcall->request = kmalloc(request_size, GFP_NOFS);\n\t\tif (!call->request)\n\t\t\tgoto nomem_free;\n\t}\n\n\tif (reply_size) {\n\t\tcall->buffer = kmalloc(reply_size, GFP_NOFS);\n\t\tif (!call->buffer)\n\t\t\tgoto nomem_free;\n\t}\n\n\tinit_waitqueue_head(&call->waitq);\n\tskb_queue_head_init(&call->rx_queue);\n\treturn call;\n\nnomem_free:\n\tafs_free_call(call);\nnomem_call:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\",%x,{%x:%u},,\"",
            "key_serial(key)",
            "vnode->fid.vid",
            "vnode->fid.vnode"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_serial",
          "args": [
            "key"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_fs_setattr_size",
          "args": [
            "server",
            "key",
            "vnode",
            "attr",
            "wait_mode"
          ],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "afs_fs_setattr_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
          "lines": "1399-1441",
          "snippet": "static int afs_fs_setattr_size(struct afs_server *server, struct key *key,\n\t\t\t       struct afs_vnode *vnode, struct iattr *attr,\n\t\t\t       const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\",%x,{%x:%u},,\",\n\t       key_serial(key), vnode->fid.vid, vnode->fid.vnode);\n\n\tASSERT(attr->ia_valid & ATTR_SIZE);\n\tif (attr->ia_size >> 32)\n\t\treturn afs_fs_setattr_size64(server, key, vnode, attr,\n\t\t\t\t\t     wait_mode);\n\n\tcall = afs_alloc_flat_call(&afs_RXFSStoreData_as_Status,\n\t\t\t\t   (4 + 6 + 3) * 4,\n\t\t\t\t   (21 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\tcall->store_version = vnode->status.data_version + 1;\n\tcall->operation_ID = FSSTOREDATA;\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(FSSTOREDATA);\n\t*bp++ = htonl(vnode->fid.vid);\n\t*bp++ = htonl(vnode->fid.vnode);\n\t*bp++ = htonl(vnode->fid.unique);\n\n\txdr_encode_AFS_StoreStatus(&bp, attr);\n\n\t*bp++ = 0;\t\t\t\t/* position of start of write */\n\t*bp++ = 0;\t\t\t\t/* size of write */\n\t*bp++ = htonl(attr->ia_size);\t\t/* new file length */\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}",
          "includes": [
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct afs_call_type afs_RXFSStoreData_as_Status = {\n\t.name\t\t= \"FS.StoreData\",\n\t.deliver\t= afs_deliver_fs_store_status,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic const struct afs_call_type afs_RXFSStoreData_as_Status = {\n\t.name\t\t= \"FS.StoreData\",\n\t.deliver\t= afs_deliver_fs_store_status,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\nstatic int afs_fs_setattr_size(struct afs_server *server, struct key *key,\n\t\t\t       struct afs_vnode *vnode, struct iattr *attr,\n\t\t\t       const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\",%x,{%x:%u},,\",\n\t       key_serial(key), vnode->fid.vid, vnode->fid.vnode);\n\n\tASSERT(attr->ia_valid & ATTR_SIZE);\n\tif (attr->ia_size >> 32)\n\t\treturn afs_fs_setattr_size64(server, key, vnode, attr,\n\t\t\t\t\t     wait_mode);\n\n\tcall = afs_alloc_flat_call(&afs_RXFSStoreData_as_Status,\n\t\t\t\t   (4 + 6 + 3) * 4,\n\t\t\t\t   (21 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\tcall->store_version = vnode->status.data_version + 1;\n\tcall->operation_ID = FSSTOREDATA;\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(FSSTOREDATA);\n\t*bp++ = htonl(vnode->fid.vid);\n\t*bp++ = htonl(vnode->fid.vnode);\n\t*bp++ = htonl(vnode->fid.unique);\n\n\txdr_encode_AFS_StoreStatus(&bp, attr);\n\n\t*bp++ = 0;\t\t\t\t/* position of start of write */\n\t*bp++ = 0;\t\t\t\t/* size of write */\n\t*bp++ = htonl(attr->ia_size);\t\t/* new file length */\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic const struct afs_call_type afs_RXFSStoreStatus = {\n\t.name\t\t= \"FS.StoreStatus\",\n\t.deliver\t= afs_deliver_fs_store_status,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\nint afs_fs_setattr(struct afs_server *server, struct key *key,\n\t\t   struct afs_vnode *vnode, struct iattr *attr,\n\t\t   const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\tif (attr->ia_valid & ATTR_SIZE)\n\t\treturn afs_fs_setattr_size(server, key, vnode, attr,\n\t\t\t\t\t   wait_mode);\n\n\t_enter(\",%x,{%x:%u},,\",\n\t       key_serial(key), vnode->fid.vid, vnode->fid.vnode);\n\n\tcall = afs_alloc_flat_call(&afs_RXFSStoreStatus,\n\t\t\t\t   (4 + 6) * 4,\n\t\t\t\t   (21 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\tcall->operation_ID = FSSTORESTATUS;\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(FSSTORESTATUS);\n\t*bp++ = htonl(vnode->fid.vid);\n\t*bp++ = htonl(vnode->fid.vnode);\n\t*bp++ = htonl(vnode->fid.unique);\n\n\txdr_encode_AFS_StoreStatus(&bp, attr);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}"
  },
  {
    "function_name": "afs_fs_setattr_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
    "lines": "1399-1441",
    "snippet": "static int afs_fs_setattr_size(struct afs_server *server, struct key *key,\n\t\t\t       struct afs_vnode *vnode, struct iattr *attr,\n\t\t\t       const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\",%x,{%x:%u},,\",\n\t       key_serial(key), vnode->fid.vid, vnode->fid.vnode);\n\n\tASSERT(attr->ia_valid & ATTR_SIZE);\n\tif (attr->ia_size >> 32)\n\t\treturn afs_fs_setattr_size64(server, key, vnode, attr,\n\t\t\t\t\t     wait_mode);\n\n\tcall = afs_alloc_flat_call(&afs_RXFSStoreData_as_Status,\n\t\t\t\t   (4 + 6 + 3) * 4,\n\t\t\t\t   (21 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\tcall->store_version = vnode->status.data_version + 1;\n\tcall->operation_ID = FSSTOREDATA;\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(FSSTOREDATA);\n\t*bp++ = htonl(vnode->fid.vid);\n\t*bp++ = htonl(vnode->fid.vnode);\n\t*bp++ = htonl(vnode->fid.unique);\n\n\txdr_encode_AFS_StoreStatus(&bp, attr);\n\n\t*bp++ = 0;\t\t\t\t/* position of start of write */\n\t*bp++ = 0;\t\t\t\t/* size of write */\n\t*bp++ = htonl(attr->ia_size);\t\t/* new file length */\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}",
    "includes": [
      "#include \"afs_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/circ_buf.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct afs_call_type afs_RXFSStoreData_as_Status = {\n\t.name\t\t= \"FS.StoreData\",\n\t.deliver\t= afs_deliver_fs_store_status,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "afs_make_call",
          "args": [
            "&server->addr",
            "call",
            "GFP_NOFS",
            "wait_mode"
          ],
          "line": 1440
        },
        "resolved": true,
        "details": {
          "function_name": "afs_make_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "338-420",
          "snippet": "int afs_make_call(struct in_addr *addr, struct afs_call *call, gfp_t gfp,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct sockaddr_rxrpc srx;\n\tstruct rxrpc_call *rxcall;\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tint ret;\n\tstruct sk_buff *skb;\n\n\t_enter(\"%x,{%d},\", addr->s_addr, ntohs(call->port));\n\n\tASSERT(call->type != NULL);\n\tASSERT(call->type->name != NULL);\n\n\t_debug(\"____MAKE %p{%s,%x} [%d]____\",\n\t       call, call->type->name, key_serial(call->key),\n\t       atomic_read(&afs_outstanding_calls));\n\n\tcall->wait_mode = wait_mode;\n\tcall->async_workfn = afs_process_async_call;\n\tINIT_WORK(&call->async_work, afs_async_workfn);\n\n\tmemset(&srx, 0, sizeof(srx));\n\tsrx.srx_family = AF_RXRPC;\n\tsrx.srx_service = call->service_id;\n\tsrx.transport_type = SOCK_DGRAM;\n\tsrx.transport_len = sizeof(srx.transport.sin);\n\tsrx.transport.sin.sin_family = AF_INET;\n\tsrx.transport.sin.sin_port = call->port;\n\tmemcpy(&srx.transport.sin.sin_addr, addr, 4);\n\n\t/* create a call */\n\trxcall = rxrpc_kernel_begin_call(afs_socket, &srx, call->key,\n\t\t\t\t\t (unsigned long) call, gfp);\n\tcall->key = NULL;\n\tif (IS_ERR(rxcall)) {\n\t\tret = PTR_ERR(rxcall);\n\t\tgoto error_kill_call;\n\t}\n\n\tcall->rxcall = rxcall;\n\n\t/* send the request */\n\tiov[0].iov_base\t= call->request;\n\tiov[0].iov_len\t= call->request_size;\n\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1,\n\t\t      call->request_size);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= (call->send_pages ? MSG_MORE : 0);\n\n\t/* have to change the state *before* sending the last packet as RxRPC\n\t * might give us the reply before it returns from sending the\n\t * request */\n\tif (!call->send_pages)\n\t\tcall->state = AFS_CALL_AWAIT_REPLY;\n\tret = rxrpc_kernel_send_data(rxcall, &msg, call->request_size);\n\tif (ret < 0)\n\t\tgoto error_do_abort;\n\n\tif (call->send_pages) {\n\t\tret = afs_send_pages(call, &msg, iov);\n\t\tif (ret < 0)\n\t\t\tgoto error_do_abort;\n\t}\n\n\t/* at this point, an async call may no longer exist as it may have\n\t * already completed */\n\treturn wait_mode->wait(call);\n\nerror_do_abort:\n\trxrpc_kernel_abort_call(rxcall, RX_USER_ABORT);\n\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\tafs_free_skb(skb);\nerror_kill_call:\n\tafs_end_call(call);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct socket *afs_socket;",
            "static atomic_t afs_outstanding_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);",
            "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
            "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic struct socket *afs_socket;\nstatic atomic_t afs_outstanding_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\n\nint afs_make_call(struct in_addr *addr, struct afs_call *call, gfp_t gfp,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct sockaddr_rxrpc srx;\n\tstruct rxrpc_call *rxcall;\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tint ret;\n\tstruct sk_buff *skb;\n\n\t_enter(\"%x,{%d},\", addr->s_addr, ntohs(call->port));\n\n\tASSERT(call->type != NULL);\n\tASSERT(call->type->name != NULL);\n\n\t_debug(\"____MAKE %p{%s,%x} [%d]____\",\n\t       call, call->type->name, key_serial(call->key),\n\t       atomic_read(&afs_outstanding_calls));\n\n\tcall->wait_mode = wait_mode;\n\tcall->async_workfn = afs_process_async_call;\n\tINIT_WORK(&call->async_work, afs_async_workfn);\n\n\tmemset(&srx, 0, sizeof(srx));\n\tsrx.srx_family = AF_RXRPC;\n\tsrx.srx_service = call->service_id;\n\tsrx.transport_type = SOCK_DGRAM;\n\tsrx.transport_len = sizeof(srx.transport.sin);\n\tsrx.transport.sin.sin_family = AF_INET;\n\tsrx.transport.sin.sin_port = call->port;\n\tmemcpy(&srx.transport.sin.sin_addr, addr, 4);\n\n\t/* create a call */\n\trxcall = rxrpc_kernel_begin_call(afs_socket, &srx, call->key,\n\t\t\t\t\t (unsigned long) call, gfp);\n\tcall->key = NULL;\n\tif (IS_ERR(rxcall)) {\n\t\tret = PTR_ERR(rxcall);\n\t\tgoto error_kill_call;\n\t}\n\n\tcall->rxcall = rxcall;\n\n\t/* send the request */\n\tiov[0].iov_base\t= call->request;\n\tiov[0].iov_len\t= call->request_size;\n\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1,\n\t\t      call->request_size);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= (call->send_pages ? MSG_MORE : 0);\n\n\t/* have to change the state *before* sending the last packet as RxRPC\n\t * might give us the reply before it returns from sending the\n\t * request */\n\tif (!call->send_pages)\n\t\tcall->state = AFS_CALL_AWAIT_REPLY;\n\tret = rxrpc_kernel_send_data(rxcall, &msg, call->request_size);\n\tif (ret < 0)\n\t\tgoto error_do_abort;\n\n\tif (call->send_pages) {\n\t\tret = afs_send_pages(call, &msg, iov);\n\t\tif (ret < 0)\n\t\t\tgoto error_do_abort;\n\t}\n\n\t/* at this point, an async call may no longer exist as it may have\n\t * already completed */\n\treturn wait_mode->wait(call);\n\nerror_do_abort:\n\trxrpc_kernel_abort_call(rxcall, RX_USER_ABORT);\n\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\tafs_free_skb(skb);\nerror_kill_call:\n\tafs_end_call(call);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "attr->ia_size"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_AFS_StoreStatus",
          "args": [
            "&bp",
            "attr"
          ],
          "line": 1434
        },
        "resolved": true,
        "details": {
          "function_name": "xdr_encode_AFS_StoreStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
          "lines": "177-210",
          "snippet": "static void xdr_encode_AFS_StoreStatus(__be32 **_bp, struct iattr *attr)\n{\n\t__be32 *bp = *_bp;\n\tu32 mask = 0, mtime = 0, owner = 0, group = 0, mode = 0;\n\n\tmask = 0;\n\tif (attr->ia_valid & ATTR_MTIME) {\n\t\tmask |= AFS_SET_MTIME;\n\t\tmtime = attr->ia_mtime.tv_sec;\n\t}\n\n\tif (attr->ia_valid & ATTR_UID) {\n\t\tmask |= AFS_SET_OWNER;\n\t\towner = from_kuid(&init_user_ns, attr->ia_uid);\n\t}\n\n\tif (attr->ia_valid & ATTR_GID) {\n\t\tmask |= AFS_SET_GROUP;\n\t\tgroup = from_kgid(&init_user_ns, attr->ia_gid);\n\t}\n\n\tif (attr->ia_valid & ATTR_MODE) {\n\t\tmask |= AFS_SET_MODE;\n\t\tmode = attr->ia_mode & S_IALLUGO;\n\t}\n\n\t*bp++ = htonl(mask);\n\t*bp++ = htonl(mtime);\n\t*bp++ = htonl(owner);\n\t*bp++ = htonl(group);\n\t*bp++ = htonl(mode);\n\t*bp++ = 0;\t\t/* segment size */\n\t*_bp = bp;\n}",
          "includes": [
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic void xdr_encode_AFS_StoreStatus(__be32 **_bp, struct iattr *attr)\n{\n\t__be32 *bp = *_bp;\n\tu32 mask = 0, mtime = 0, owner = 0, group = 0, mode = 0;\n\n\tmask = 0;\n\tif (attr->ia_valid & ATTR_MTIME) {\n\t\tmask |= AFS_SET_MTIME;\n\t\tmtime = attr->ia_mtime.tv_sec;\n\t}\n\n\tif (attr->ia_valid & ATTR_UID) {\n\t\tmask |= AFS_SET_OWNER;\n\t\towner = from_kuid(&init_user_ns, attr->ia_uid);\n\t}\n\n\tif (attr->ia_valid & ATTR_GID) {\n\t\tmask |= AFS_SET_GROUP;\n\t\tgroup = from_kgid(&init_user_ns, attr->ia_gid);\n\t}\n\n\tif (attr->ia_valid & ATTR_MODE) {\n\t\tmask |= AFS_SET_MODE;\n\t\tmode = attr->ia_mode & S_IALLUGO;\n\t}\n\n\t*bp++ = htonl(mask);\n\t*bp++ = htonl(mtime);\n\t*bp++ = htonl(owner);\n\t*bp++ = htonl(group);\n\t*bp++ = htonl(mode);\n\t*bp++ = 0;\t\t/* segment size */\n\t*_bp = bp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "vnode->fid.unique"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "vnode->fid.vnode"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "vnode->fid.vid"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "FSSTOREDATA"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "AFS_FS_PORT"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_alloc_flat_call",
          "args": [
            "&afs_RXFSStoreData_as_Status",
            "(4 + 6 + 3) * 4",
            "(21 + 6) * 4"
          ],
          "line": 1414
        },
        "resolved": true,
        "details": {
          "function_name": "afs_alloc_flat_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "218-255",
          "snippet": "struct afs_call *afs_alloc_flat_call(const struct afs_call_type *type,\n\t\t\t\t     size_t request_size, size_t reply_size)\n{\n\tstruct afs_call *call;\n\n\tcall = kzalloc(sizeof(*call), GFP_NOFS);\n\tif (!call)\n\t\tgoto nomem_call;\n\n\t_debug(\"CALL %p{%s} [%d]\",\n\t       call, type->name, atomic_read(&afs_outstanding_calls));\n\tatomic_inc(&afs_outstanding_calls);\n\n\tcall->type = type;\n\tcall->request_size = request_size;\n\tcall->reply_max = reply_size;\n\n\tif (request_size) {\n\t\tcall->request = kmalloc(request_size, GFP_NOFS);\n\t\tif (!call->request)\n\t\t\tgoto nomem_free;\n\t}\n\n\tif (reply_size) {\n\t\tcall->buffer = kmalloc(reply_size, GFP_NOFS);\n\t\tif (!call->buffer)\n\t\t\tgoto nomem_free;\n\t}\n\n\tinit_waitqueue_head(&call->waitq);\n\tskb_queue_head_init(&call->rx_queue);\n\treturn call;\n\nnomem_free:\n\tafs_free_call(call);\nnomem_call:\n\treturn NULL;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t afs_outstanding_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic atomic_t afs_outstanding_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nstruct afs_call *afs_alloc_flat_call(const struct afs_call_type *type,\n\t\t\t\t     size_t request_size, size_t reply_size)\n{\n\tstruct afs_call *call;\n\n\tcall = kzalloc(sizeof(*call), GFP_NOFS);\n\tif (!call)\n\t\tgoto nomem_call;\n\n\t_debug(\"CALL %p{%s} [%d]\",\n\t       call, type->name, atomic_read(&afs_outstanding_calls));\n\tatomic_inc(&afs_outstanding_calls);\n\n\tcall->type = type;\n\tcall->request_size = request_size;\n\tcall->reply_max = reply_size;\n\n\tif (request_size) {\n\t\tcall->request = kmalloc(request_size, GFP_NOFS);\n\t\tif (!call->request)\n\t\t\tgoto nomem_free;\n\t}\n\n\tif (reply_size) {\n\t\tcall->buffer = kmalloc(reply_size, GFP_NOFS);\n\t\tif (!call->buffer)\n\t\t\tgoto nomem_free;\n\t}\n\n\tinit_waitqueue_head(&call->waitq);\n\tskb_queue_head_init(&call->rx_queue);\n\treturn call;\n\nnomem_free:\n\tafs_free_call(call);\nnomem_call:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_fs_setattr_size64",
          "args": [
            "server",
            "key",
            "vnode",
            "attr",
            "wait_mode"
          ],
          "line": 1411
        },
        "resolved": true,
        "details": {
          "function_name": "afs_fs_setattr_size64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
          "lines": "1351-1393",
          "snippet": "static int afs_fs_setattr_size64(struct afs_server *server, struct key *key,\n\t\t\t\t struct afs_vnode *vnode, struct iattr *attr,\n\t\t\t\t const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\",%x,{%x:%u},,\",\n\t       key_serial(key), vnode->fid.vid, vnode->fid.vnode);\n\n\tASSERT(attr->ia_valid & ATTR_SIZE);\n\n\tcall = afs_alloc_flat_call(&afs_RXFSStoreData64_as_Status,\n\t\t\t\t   (4 + 6 + 3 * 2) * 4,\n\t\t\t\t   (21 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\tcall->store_version = vnode->status.data_version + 1;\n\tcall->operation_ID = FSSTOREDATA;\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(FSSTOREDATA64);\n\t*bp++ = htonl(vnode->fid.vid);\n\t*bp++ = htonl(vnode->fid.vnode);\n\t*bp++ = htonl(vnode->fid.unique);\n\n\txdr_encode_AFS_StoreStatus(&bp, attr);\n\n\t*bp++ = 0;\t\t\t\t/* position of start of write */\n\t*bp++ = 0;\n\t*bp++ = 0;\t\t\t\t/* size of write */\n\t*bp++ = 0;\n\t*bp++ = htonl(attr->ia_size >> 32);\t/* new file length */\n\t*bp++ = htonl((u32) attr->ia_size);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}",
          "includes": [
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct afs_call_type afs_RXFSStoreData64_as_Status = {\n\t.name\t\t= \"FS.StoreData64\",\n\t.deliver\t= afs_deliver_fs_store_status,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic const struct afs_call_type afs_RXFSStoreData64_as_Status = {\n\t.name\t\t= \"FS.StoreData64\",\n\t.deliver\t= afs_deliver_fs_store_status,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\nstatic int afs_fs_setattr_size64(struct afs_server *server, struct key *key,\n\t\t\t\t struct afs_vnode *vnode, struct iattr *attr,\n\t\t\t\t const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\",%x,{%x:%u},,\",\n\t       key_serial(key), vnode->fid.vid, vnode->fid.vnode);\n\n\tASSERT(attr->ia_valid & ATTR_SIZE);\n\n\tcall = afs_alloc_flat_call(&afs_RXFSStoreData64_as_Status,\n\t\t\t\t   (4 + 6 + 3 * 2) * 4,\n\t\t\t\t   (21 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\tcall->store_version = vnode->status.data_version + 1;\n\tcall->operation_ID = FSSTOREDATA;\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(FSSTOREDATA64);\n\t*bp++ = htonl(vnode->fid.vid);\n\t*bp++ = htonl(vnode->fid.vnode);\n\t*bp++ = htonl(vnode->fid.unique);\n\n\txdr_encode_AFS_StoreStatus(&bp, attr);\n\n\t*bp++ = 0;\t\t\t\t/* position of start of write */\n\t*bp++ = 0;\n\t*bp++ = 0;\t\t\t\t/* size of write */\n\t*bp++ = 0;\n\t*bp++ = htonl(attr->ia_size >> 32);\t/* new file length */\n\t*bp++ = htonl((u32) attr->ia_size);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "attr->ia_valid & ATTR_SIZE"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\",%x,{%x:%u},,\"",
            "key_serial(key)",
            "vnode->fid.vid",
            "vnode->fid.vnode"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_serial",
          "args": [
            "key"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic const struct afs_call_type afs_RXFSStoreData_as_Status = {\n\t.name\t\t= \"FS.StoreData\",\n\t.deliver\t= afs_deliver_fs_store_status,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\nstatic int afs_fs_setattr_size(struct afs_server *server, struct key *key,\n\t\t\t       struct afs_vnode *vnode, struct iattr *attr,\n\t\t\t       const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\",%x,{%x:%u},,\",\n\t       key_serial(key), vnode->fid.vid, vnode->fid.vnode);\n\n\tASSERT(attr->ia_valid & ATTR_SIZE);\n\tif (attr->ia_size >> 32)\n\t\treturn afs_fs_setattr_size64(server, key, vnode, attr,\n\t\t\t\t\t     wait_mode);\n\n\tcall = afs_alloc_flat_call(&afs_RXFSStoreData_as_Status,\n\t\t\t\t   (4 + 6 + 3) * 4,\n\t\t\t\t   (21 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\tcall->store_version = vnode->status.data_version + 1;\n\tcall->operation_ID = FSSTOREDATA;\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(FSSTOREDATA);\n\t*bp++ = htonl(vnode->fid.vid);\n\t*bp++ = htonl(vnode->fid.vnode);\n\t*bp++ = htonl(vnode->fid.unique);\n\n\txdr_encode_AFS_StoreStatus(&bp, attr);\n\n\t*bp++ = 0;\t\t\t\t/* position of start of write */\n\t*bp++ = 0;\t\t\t\t/* size of write */\n\t*bp++ = htonl(attr->ia_size);\t\t/* new file length */\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}"
  },
  {
    "function_name": "afs_fs_setattr_size64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
    "lines": "1351-1393",
    "snippet": "static int afs_fs_setattr_size64(struct afs_server *server, struct key *key,\n\t\t\t\t struct afs_vnode *vnode, struct iattr *attr,\n\t\t\t\t const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\",%x,{%x:%u},,\",\n\t       key_serial(key), vnode->fid.vid, vnode->fid.vnode);\n\n\tASSERT(attr->ia_valid & ATTR_SIZE);\n\n\tcall = afs_alloc_flat_call(&afs_RXFSStoreData64_as_Status,\n\t\t\t\t   (4 + 6 + 3 * 2) * 4,\n\t\t\t\t   (21 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\tcall->store_version = vnode->status.data_version + 1;\n\tcall->operation_ID = FSSTOREDATA;\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(FSSTOREDATA64);\n\t*bp++ = htonl(vnode->fid.vid);\n\t*bp++ = htonl(vnode->fid.vnode);\n\t*bp++ = htonl(vnode->fid.unique);\n\n\txdr_encode_AFS_StoreStatus(&bp, attr);\n\n\t*bp++ = 0;\t\t\t\t/* position of start of write */\n\t*bp++ = 0;\n\t*bp++ = 0;\t\t\t\t/* size of write */\n\t*bp++ = 0;\n\t*bp++ = htonl(attr->ia_size >> 32);\t/* new file length */\n\t*bp++ = htonl((u32) attr->ia_size);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}",
    "includes": [
      "#include \"afs_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/circ_buf.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct afs_call_type afs_RXFSStoreData64_as_Status = {\n\t.name\t\t= \"FS.StoreData64\",\n\t.deliver\t= afs_deliver_fs_store_status,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "afs_make_call",
          "args": [
            "&server->addr",
            "call",
            "GFP_NOFS",
            "wait_mode"
          ],
          "line": 1392
        },
        "resolved": true,
        "details": {
          "function_name": "afs_make_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "338-420",
          "snippet": "int afs_make_call(struct in_addr *addr, struct afs_call *call, gfp_t gfp,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct sockaddr_rxrpc srx;\n\tstruct rxrpc_call *rxcall;\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tint ret;\n\tstruct sk_buff *skb;\n\n\t_enter(\"%x,{%d},\", addr->s_addr, ntohs(call->port));\n\n\tASSERT(call->type != NULL);\n\tASSERT(call->type->name != NULL);\n\n\t_debug(\"____MAKE %p{%s,%x} [%d]____\",\n\t       call, call->type->name, key_serial(call->key),\n\t       atomic_read(&afs_outstanding_calls));\n\n\tcall->wait_mode = wait_mode;\n\tcall->async_workfn = afs_process_async_call;\n\tINIT_WORK(&call->async_work, afs_async_workfn);\n\n\tmemset(&srx, 0, sizeof(srx));\n\tsrx.srx_family = AF_RXRPC;\n\tsrx.srx_service = call->service_id;\n\tsrx.transport_type = SOCK_DGRAM;\n\tsrx.transport_len = sizeof(srx.transport.sin);\n\tsrx.transport.sin.sin_family = AF_INET;\n\tsrx.transport.sin.sin_port = call->port;\n\tmemcpy(&srx.transport.sin.sin_addr, addr, 4);\n\n\t/* create a call */\n\trxcall = rxrpc_kernel_begin_call(afs_socket, &srx, call->key,\n\t\t\t\t\t (unsigned long) call, gfp);\n\tcall->key = NULL;\n\tif (IS_ERR(rxcall)) {\n\t\tret = PTR_ERR(rxcall);\n\t\tgoto error_kill_call;\n\t}\n\n\tcall->rxcall = rxcall;\n\n\t/* send the request */\n\tiov[0].iov_base\t= call->request;\n\tiov[0].iov_len\t= call->request_size;\n\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1,\n\t\t      call->request_size);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= (call->send_pages ? MSG_MORE : 0);\n\n\t/* have to change the state *before* sending the last packet as RxRPC\n\t * might give us the reply before it returns from sending the\n\t * request */\n\tif (!call->send_pages)\n\t\tcall->state = AFS_CALL_AWAIT_REPLY;\n\tret = rxrpc_kernel_send_data(rxcall, &msg, call->request_size);\n\tif (ret < 0)\n\t\tgoto error_do_abort;\n\n\tif (call->send_pages) {\n\t\tret = afs_send_pages(call, &msg, iov);\n\t\tif (ret < 0)\n\t\t\tgoto error_do_abort;\n\t}\n\n\t/* at this point, an async call may no longer exist as it may have\n\t * already completed */\n\treturn wait_mode->wait(call);\n\nerror_do_abort:\n\trxrpc_kernel_abort_call(rxcall, RX_USER_ABORT);\n\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\tafs_free_skb(skb);\nerror_kill_call:\n\tafs_end_call(call);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct socket *afs_socket;",
            "static atomic_t afs_outstanding_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);",
            "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
            "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic struct socket *afs_socket;\nstatic atomic_t afs_outstanding_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\n\nint afs_make_call(struct in_addr *addr, struct afs_call *call, gfp_t gfp,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct sockaddr_rxrpc srx;\n\tstruct rxrpc_call *rxcall;\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tint ret;\n\tstruct sk_buff *skb;\n\n\t_enter(\"%x,{%d},\", addr->s_addr, ntohs(call->port));\n\n\tASSERT(call->type != NULL);\n\tASSERT(call->type->name != NULL);\n\n\t_debug(\"____MAKE %p{%s,%x} [%d]____\",\n\t       call, call->type->name, key_serial(call->key),\n\t       atomic_read(&afs_outstanding_calls));\n\n\tcall->wait_mode = wait_mode;\n\tcall->async_workfn = afs_process_async_call;\n\tINIT_WORK(&call->async_work, afs_async_workfn);\n\n\tmemset(&srx, 0, sizeof(srx));\n\tsrx.srx_family = AF_RXRPC;\n\tsrx.srx_service = call->service_id;\n\tsrx.transport_type = SOCK_DGRAM;\n\tsrx.transport_len = sizeof(srx.transport.sin);\n\tsrx.transport.sin.sin_family = AF_INET;\n\tsrx.transport.sin.sin_port = call->port;\n\tmemcpy(&srx.transport.sin.sin_addr, addr, 4);\n\n\t/* create a call */\n\trxcall = rxrpc_kernel_begin_call(afs_socket, &srx, call->key,\n\t\t\t\t\t (unsigned long) call, gfp);\n\tcall->key = NULL;\n\tif (IS_ERR(rxcall)) {\n\t\tret = PTR_ERR(rxcall);\n\t\tgoto error_kill_call;\n\t}\n\n\tcall->rxcall = rxcall;\n\n\t/* send the request */\n\tiov[0].iov_base\t= call->request;\n\tiov[0].iov_len\t= call->request_size;\n\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1,\n\t\t      call->request_size);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= (call->send_pages ? MSG_MORE : 0);\n\n\t/* have to change the state *before* sending the last packet as RxRPC\n\t * might give us the reply before it returns from sending the\n\t * request */\n\tif (!call->send_pages)\n\t\tcall->state = AFS_CALL_AWAIT_REPLY;\n\tret = rxrpc_kernel_send_data(rxcall, &msg, call->request_size);\n\tif (ret < 0)\n\t\tgoto error_do_abort;\n\n\tif (call->send_pages) {\n\t\tret = afs_send_pages(call, &msg, iov);\n\t\tif (ret < 0)\n\t\t\tgoto error_do_abort;\n\t}\n\n\t/* at this point, an async call may no longer exist as it may have\n\t * already completed */\n\treturn wait_mode->wait(call);\n\nerror_do_abort:\n\trxrpc_kernel_abort_call(rxcall, RX_USER_ABORT);\n\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\tafs_free_skb(skb);\nerror_kill_call:\n\tafs_end_call(call);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "(u32) attr->ia_size"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "attr->ia_size >> 32"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_AFS_StoreStatus",
          "args": [
            "&bp",
            "attr"
          ],
          "line": 1383
        },
        "resolved": true,
        "details": {
          "function_name": "xdr_encode_AFS_StoreStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
          "lines": "177-210",
          "snippet": "static void xdr_encode_AFS_StoreStatus(__be32 **_bp, struct iattr *attr)\n{\n\t__be32 *bp = *_bp;\n\tu32 mask = 0, mtime = 0, owner = 0, group = 0, mode = 0;\n\n\tmask = 0;\n\tif (attr->ia_valid & ATTR_MTIME) {\n\t\tmask |= AFS_SET_MTIME;\n\t\tmtime = attr->ia_mtime.tv_sec;\n\t}\n\n\tif (attr->ia_valid & ATTR_UID) {\n\t\tmask |= AFS_SET_OWNER;\n\t\towner = from_kuid(&init_user_ns, attr->ia_uid);\n\t}\n\n\tif (attr->ia_valid & ATTR_GID) {\n\t\tmask |= AFS_SET_GROUP;\n\t\tgroup = from_kgid(&init_user_ns, attr->ia_gid);\n\t}\n\n\tif (attr->ia_valid & ATTR_MODE) {\n\t\tmask |= AFS_SET_MODE;\n\t\tmode = attr->ia_mode & S_IALLUGO;\n\t}\n\n\t*bp++ = htonl(mask);\n\t*bp++ = htonl(mtime);\n\t*bp++ = htonl(owner);\n\t*bp++ = htonl(group);\n\t*bp++ = htonl(mode);\n\t*bp++ = 0;\t\t/* segment size */\n\t*_bp = bp;\n}",
          "includes": [
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic void xdr_encode_AFS_StoreStatus(__be32 **_bp, struct iattr *attr)\n{\n\t__be32 *bp = *_bp;\n\tu32 mask = 0, mtime = 0, owner = 0, group = 0, mode = 0;\n\n\tmask = 0;\n\tif (attr->ia_valid & ATTR_MTIME) {\n\t\tmask |= AFS_SET_MTIME;\n\t\tmtime = attr->ia_mtime.tv_sec;\n\t}\n\n\tif (attr->ia_valid & ATTR_UID) {\n\t\tmask |= AFS_SET_OWNER;\n\t\towner = from_kuid(&init_user_ns, attr->ia_uid);\n\t}\n\n\tif (attr->ia_valid & ATTR_GID) {\n\t\tmask |= AFS_SET_GROUP;\n\t\tgroup = from_kgid(&init_user_ns, attr->ia_gid);\n\t}\n\n\tif (attr->ia_valid & ATTR_MODE) {\n\t\tmask |= AFS_SET_MODE;\n\t\tmode = attr->ia_mode & S_IALLUGO;\n\t}\n\n\t*bp++ = htonl(mask);\n\t*bp++ = htonl(mtime);\n\t*bp++ = htonl(owner);\n\t*bp++ = htonl(group);\n\t*bp++ = htonl(mode);\n\t*bp++ = 0;\t\t/* segment size */\n\t*_bp = bp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "vnode->fid.unique"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "vnode->fid.vnode"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "vnode->fid.vid"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "FSSTOREDATA64"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "AFS_FS_PORT"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_alloc_flat_call",
          "args": [
            "&afs_RXFSStoreData64_as_Status",
            "(4 + 6 + 3 * 2) * 4",
            "(21 + 6) * 4"
          ],
          "line": 1363
        },
        "resolved": true,
        "details": {
          "function_name": "afs_alloc_flat_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "218-255",
          "snippet": "struct afs_call *afs_alloc_flat_call(const struct afs_call_type *type,\n\t\t\t\t     size_t request_size, size_t reply_size)\n{\n\tstruct afs_call *call;\n\n\tcall = kzalloc(sizeof(*call), GFP_NOFS);\n\tif (!call)\n\t\tgoto nomem_call;\n\n\t_debug(\"CALL %p{%s} [%d]\",\n\t       call, type->name, atomic_read(&afs_outstanding_calls));\n\tatomic_inc(&afs_outstanding_calls);\n\n\tcall->type = type;\n\tcall->request_size = request_size;\n\tcall->reply_max = reply_size;\n\n\tif (request_size) {\n\t\tcall->request = kmalloc(request_size, GFP_NOFS);\n\t\tif (!call->request)\n\t\t\tgoto nomem_free;\n\t}\n\n\tif (reply_size) {\n\t\tcall->buffer = kmalloc(reply_size, GFP_NOFS);\n\t\tif (!call->buffer)\n\t\t\tgoto nomem_free;\n\t}\n\n\tinit_waitqueue_head(&call->waitq);\n\tskb_queue_head_init(&call->rx_queue);\n\treturn call;\n\nnomem_free:\n\tafs_free_call(call);\nnomem_call:\n\treturn NULL;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t afs_outstanding_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic atomic_t afs_outstanding_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nstruct afs_call *afs_alloc_flat_call(const struct afs_call_type *type,\n\t\t\t\t     size_t request_size, size_t reply_size)\n{\n\tstruct afs_call *call;\n\n\tcall = kzalloc(sizeof(*call), GFP_NOFS);\n\tif (!call)\n\t\tgoto nomem_call;\n\n\t_debug(\"CALL %p{%s} [%d]\",\n\t       call, type->name, atomic_read(&afs_outstanding_calls));\n\tatomic_inc(&afs_outstanding_calls);\n\n\tcall->type = type;\n\tcall->request_size = request_size;\n\tcall->reply_max = reply_size;\n\n\tif (request_size) {\n\t\tcall->request = kmalloc(request_size, GFP_NOFS);\n\t\tif (!call->request)\n\t\t\tgoto nomem_free;\n\t}\n\n\tif (reply_size) {\n\t\tcall->buffer = kmalloc(reply_size, GFP_NOFS);\n\t\tif (!call->buffer)\n\t\t\tgoto nomem_free;\n\t}\n\n\tinit_waitqueue_head(&call->waitq);\n\tskb_queue_head_init(&call->rx_queue);\n\treturn call;\n\nnomem_free:\n\tafs_free_call(call);\nnomem_call:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "attr->ia_valid & ATTR_SIZE"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\",%x,{%x:%u},,\"",
            "key_serial(key)",
            "vnode->fid.vid",
            "vnode->fid.vnode"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_serial",
          "args": [
            "key"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic const struct afs_call_type afs_RXFSStoreData64_as_Status = {\n\t.name\t\t= \"FS.StoreData64\",\n\t.deliver\t= afs_deliver_fs_store_status,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\nstatic int afs_fs_setattr_size64(struct afs_server *server, struct key *key,\n\t\t\t\t struct afs_vnode *vnode, struct iattr *attr,\n\t\t\t\t const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\",%x,{%x:%u},,\",\n\t       key_serial(key), vnode->fid.vid, vnode->fid.vnode);\n\n\tASSERT(attr->ia_valid & ATTR_SIZE);\n\n\tcall = afs_alloc_flat_call(&afs_RXFSStoreData64_as_Status,\n\t\t\t\t   (4 + 6 + 3 * 2) * 4,\n\t\t\t\t   (21 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\tcall->store_version = vnode->status.data_version + 1;\n\tcall->operation_ID = FSSTOREDATA;\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(FSSTOREDATA64);\n\t*bp++ = htonl(vnode->fid.vid);\n\t*bp++ = htonl(vnode->fid.vnode);\n\t*bp++ = htonl(vnode->fid.unique);\n\n\txdr_encode_AFS_StoreStatus(&bp, attr);\n\n\t*bp++ = 0;\t\t\t\t/* position of start of write */\n\t*bp++ = 0;\n\t*bp++ = 0;\t\t\t\t/* size of write */\n\t*bp++ = 0;\n\t*bp++ = htonl(attr->ia_size >> 32);\t/* new file length */\n\t*bp++ = htonl((u32) attr->ia_size);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}"
  },
  {
    "function_name": "afs_deliver_fs_store_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
    "lines": "1289-1321",
    "snippet": "static int afs_deliver_fs_store_status(struct afs_call *call,\n\t\t\t\t       struct sk_buff *skb, bool last)\n{\n\tafs_dataversion_t *store_version;\n\tstruct afs_vnode *vnode = call->reply;\n\tconst __be32 *bp;\n\n\t_enter(\",,%u\", last);\n\n\tafs_transfer_reply(call, skb);\n\tif (!last) {\n\t\t_leave(\" = 0 [more]\");\n\t\treturn 0;\n\t}\n\n\tif (call->reply_size != call->reply_max) {\n\t\t_leave(\" = -EBADMSG [%u != %u]\",\n\t\t       call->reply_size, call->reply_max);\n\t\treturn -EBADMSG;\n\t}\n\n\t/* unmarshall the reply once we've received all of it */\n\tstore_version = NULL;\n\tif (call->operation_ID == FSSTOREDATA)\n\t\tstore_version = &call->store_version;\n\n\tbp = call->buffer;\n\txdr_decode_AFSFetchStatus(&bp, &vnode->status, vnode, store_version);\n\t/* xdr_decode_AFSVolSync(&bp, call->replyX); */\n\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}",
    "includes": [
      "#include \"afs_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/circ_buf.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = 0 [done]\""
          ],
          "line": 1319
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_decode_AFSFetchStatus",
          "args": [
            "&bp",
            "&vnode->status",
            "vnode",
            "store_version"
          ],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "xdr_decode_AFSFetchStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
          "lines": "35-130",
          "snippet": "static void xdr_decode_AFSFetchStatus(const __be32 **_bp,\n\t\t\t\t      struct afs_file_status *status,\n\t\t\t\t      struct afs_vnode *vnode,\n\t\t\t\t      afs_dataversion_t *store_version)\n{\n\tafs_dataversion_t expected_version;\n\tconst __be32 *bp = *_bp;\n\tumode_t mode;\n\tu64 data_version, size;\n\tu32 changed = 0; /* becomes non-zero if ctime-type changes seen */\n\tkuid_t owner;\n\tkgid_t group;\n\n#define EXTRACT(DST)\t\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tu32 x = ntohl(*bp++);\t\t\\\n\t\tchanged |= DST - x;\t\t\\\n\t\tDST = x;\t\t\t\\\n\t} while (0)\n\n\tstatus->if_version = ntohl(*bp++);\n\tEXTRACT(status->type);\n\tEXTRACT(status->nlink);\n\tsize = ntohl(*bp++);\n\tdata_version = ntohl(*bp++);\n\tEXTRACT(status->author);\n\towner = make_kuid(&init_user_ns, ntohl(*bp++));\n\tchanged |= !uid_eq(owner, status->owner);\n\tstatus->owner = owner;\n\tEXTRACT(status->caller_access); /* call ticket dependent */\n\tEXTRACT(status->anon_access);\n\tEXTRACT(status->mode);\n\tEXTRACT(status->parent.vnode);\n\tEXTRACT(status->parent.unique);\n\tbp++; /* seg size */\n\tstatus->mtime_client = ntohl(*bp++);\n\tstatus->mtime_server = ntohl(*bp++);\n\tgroup = make_kgid(&init_user_ns, ntohl(*bp++));\n\tchanged |= !gid_eq(group, status->group);\n\tstatus->group = group;\n\tbp++; /* sync counter */\n\tdata_version |= (u64) ntohl(*bp++) << 32;\n\tEXTRACT(status->lock_count);\n\tsize |= (u64) ntohl(*bp++) << 32;\n\tbp++; /* spare 4 */\n\t*_bp = bp;\n\n\tif (size != status->size) {\n\t\tstatus->size = size;\n\t\tchanged |= true;\n\t}\n\tstatus->mode &= S_IALLUGO;\n\n\t_debug(\"vnode time %lx, %lx\",\n\t       status->mtime_client, status->mtime_server);\n\n\tif (vnode) {\n\t\tstatus->parent.vid = vnode->fid.vid;\n\t\tif (changed && !test_bit(AFS_VNODE_UNSET, &vnode->flags)) {\n\t\t\t_debug(\"vnode changed\");\n\t\t\ti_size_write(&vnode->vfs_inode, size);\n\t\t\tvnode->vfs_inode.i_uid = status->owner;\n\t\t\tvnode->vfs_inode.i_gid = status->group;\n\t\t\tvnode->vfs_inode.i_generation = vnode->fid.unique;\n\t\t\tset_nlink(&vnode->vfs_inode, status->nlink);\n\n\t\t\tmode = vnode->vfs_inode.i_mode;\n\t\t\tmode &= ~S_IALLUGO;\n\t\t\tmode |= status->mode;\n\t\t\tbarrier();\n\t\t\tvnode->vfs_inode.i_mode = mode;\n\t\t}\n\n\t\tvnode->vfs_inode.i_ctime.tv_sec\t= status->mtime_server;\n\t\tvnode->vfs_inode.i_mtime\t= vnode->vfs_inode.i_ctime;\n\t\tvnode->vfs_inode.i_atime\t= vnode->vfs_inode.i_ctime;\n\t\tvnode->vfs_inode.i_version\t= data_version;\n\t}\n\n\texpected_version = status->data_version;\n\tif (store_version)\n\t\texpected_version = *store_version;\n\n\tif (expected_version != data_version) {\n\t\tstatus->data_version = data_version;\n\t\tif (vnode && !test_bit(AFS_VNODE_UNSET, &vnode->flags)) {\n\t\t\t_debug(\"vnode modified %llx on {%x:%u}\",\n\t\t\t       (unsigned long long) data_version,\n\t\t\t       vnode->fid.vid, vnode->fid.vnode);\n\t\t\tset_bit(AFS_VNODE_MODIFIED, &vnode->flags);\n\t\t\tset_bit(AFS_VNODE_ZAP_DATA, &vnode->flags);\n\t\t}\n\t} else if (store_version) {\n\t\tstatus->data_version = data_version;\n\t}\n}",
          "includes": [
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic void xdr_decode_AFSFetchStatus(const __be32 **_bp,\n\t\t\t\t      struct afs_file_status *status,\n\t\t\t\t      struct afs_vnode *vnode,\n\t\t\t\t      afs_dataversion_t *store_version)\n{\n\tafs_dataversion_t expected_version;\n\tconst __be32 *bp = *_bp;\n\tumode_t mode;\n\tu64 data_version, size;\n\tu32 changed = 0; /* becomes non-zero if ctime-type changes seen */\n\tkuid_t owner;\n\tkgid_t group;\n\n#define EXTRACT(DST)\t\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tu32 x = ntohl(*bp++);\t\t\\\n\t\tchanged |= DST - x;\t\t\\\n\t\tDST = x;\t\t\t\\\n\t} while (0)\n\n\tstatus->if_version = ntohl(*bp++);\n\tEXTRACT(status->type);\n\tEXTRACT(status->nlink);\n\tsize = ntohl(*bp++);\n\tdata_version = ntohl(*bp++);\n\tEXTRACT(status->author);\n\towner = make_kuid(&init_user_ns, ntohl(*bp++));\n\tchanged |= !uid_eq(owner, status->owner);\n\tstatus->owner = owner;\n\tEXTRACT(status->caller_access); /* call ticket dependent */\n\tEXTRACT(status->anon_access);\n\tEXTRACT(status->mode);\n\tEXTRACT(status->parent.vnode);\n\tEXTRACT(status->parent.unique);\n\tbp++; /* seg size */\n\tstatus->mtime_client = ntohl(*bp++);\n\tstatus->mtime_server = ntohl(*bp++);\n\tgroup = make_kgid(&init_user_ns, ntohl(*bp++));\n\tchanged |= !gid_eq(group, status->group);\n\tstatus->group = group;\n\tbp++; /* sync counter */\n\tdata_version |= (u64) ntohl(*bp++) << 32;\n\tEXTRACT(status->lock_count);\n\tsize |= (u64) ntohl(*bp++) << 32;\n\tbp++; /* spare 4 */\n\t*_bp = bp;\n\n\tif (size != status->size) {\n\t\tstatus->size = size;\n\t\tchanged |= true;\n\t}\n\tstatus->mode &= S_IALLUGO;\n\n\t_debug(\"vnode time %lx, %lx\",\n\t       status->mtime_client, status->mtime_server);\n\n\tif (vnode) {\n\t\tstatus->parent.vid = vnode->fid.vid;\n\t\tif (changed && !test_bit(AFS_VNODE_UNSET, &vnode->flags)) {\n\t\t\t_debug(\"vnode changed\");\n\t\t\ti_size_write(&vnode->vfs_inode, size);\n\t\t\tvnode->vfs_inode.i_uid = status->owner;\n\t\t\tvnode->vfs_inode.i_gid = status->group;\n\t\t\tvnode->vfs_inode.i_generation = vnode->fid.unique;\n\t\t\tset_nlink(&vnode->vfs_inode, status->nlink);\n\n\t\t\tmode = vnode->vfs_inode.i_mode;\n\t\t\tmode &= ~S_IALLUGO;\n\t\t\tmode |= status->mode;\n\t\t\tbarrier();\n\t\t\tvnode->vfs_inode.i_mode = mode;\n\t\t}\n\n\t\tvnode->vfs_inode.i_ctime.tv_sec\t= status->mtime_server;\n\t\tvnode->vfs_inode.i_mtime\t= vnode->vfs_inode.i_ctime;\n\t\tvnode->vfs_inode.i_atime\t= vnode->vfs_inode.i_ctime;\n\t\tvnode->vfs_inode.i_version\t= data_version;\n\t}\n\n\texpected_version = status->data_version;\n\tif (store_version)\n\t\texpected_version = *store_version;\n\n\tif (expected_version != data_version) {\n\t\tstatus->data_version = data_version;\n\t\tif (vnode && !test_bit(AFS_VNODE_UNSET, &vnode->flags)) {\n\t\t\t_debug(\"vnode modified %llx on {%x:%u}\",\n\t\t\t       (unsigned long long) data_version,\n\t\t\t       vnode->fid.vid, vnode->fid.vnode);\n\t\t\tset_bit(AFS_VNODE_MODIFIED, &vnode->flags);\n\t\t\tset_bit(AFS_VNODE_ZAP_DATA, &vnode->flags);\n\t\t}\n\t} else if (store_version) {\n\t\tstatus->data_version = data_version;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = -EBADMSG [%u != %u]\"",
            "call->reply_size",
            "call->reply_max"
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "are_leaves_removable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "698-757",
          "snippet": "static int are_leaves_removable(struct tree_balance *tb, int lfree, int rfree)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint ih_size;\n\tstruct buffer_head *S0;\n\n\tS0 = PATH_H_PBUFFER(tb->tb_path, 0);\n\n\tih_size = 0;\n\tif (vn->vn_nr_item) {\n\t\tif (vn->vn_vi[0].vi_type & VI_TYPE_LEFT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\n\t\tif (vn->vn_vi[vn->vn_nr_item - 1].\n\t\t    vi_type & VI_TYPE_RIGHT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\t} else {\n\t\t/* there was only one item and it will be deleted */\n\t\tstruct item_head *ih;\n\n\t\tRFALSE(B_NR_ITEMS(S0) != 1,\n\t\t       \"vs-8125: item number must be 1: it is %d\",\n\t\t       B_NR_ITEMS(S0));\n\n\t\tih = item_head(S0, 0);\n\t\tif (tb->CFR[0]\n\t\t    && !comp_short_le_keys(&ih->ih_key,\n\t\t\t\t\t   internal_key(tb->CFR[0],\n\t\t\t\t\t\t\t  tb->rkey[0])))\n\t\t\t/*\n\t\t\t * Directory must be in correct state here: that is\n\t\t\t * somewhere at the left side should exist first\n\t\t\t * directory item. But the item being deleted can\n\t\t\t * not be that first one because its right neighbor\n\t\t\t * is item of the same directory. (But first item\n\t\t\t * always gets deleted in last turn). So, neighbors\n\t\t\t * of deleted item can be merged, so we can save\n\t\t\t * ih_size\n\t\t\t */\n\t\t\tif (is_direntry_le_ih(ih)) {\n\t\t\t\tih_size = IH_SIZE;\n\n\t\t\t\t/*\n\t\t\t\t * we might check that left neighbor exists\n\t\t\t\t * and is of the same directory\n\t\t\t\t */\n\t\t\t\tRFALSE(le_ih_k_offset(ih) == DOT_OFFSET,\n\t\t\t\t       \"vs-8130: first directory item can not be removed until directory is not empty\");\n\t\t\t}\n\n\t}\n\n\tif (MAX_CHILD_SIZE(S0) + vn->vn_size <= rfree + lfree + ih_size) {\n\t\tset_parameters(tb, 0, -1, -1, -1, NULL, -1, -1);\n\t\tPROC_INFO_INC(tb->tb_sb, leaves_removable);\n\t\treturn 1;\n\t}\n\treturn 0;\n\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int are_leaves_removable(struct tree_balance *tb, int lfree, int rfree)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint ih_size;\n\tstruct buffer_head *S0;\n\n\tS0 = PATH_H_PBUFFER(tb->tb_path, 0);\n\n\tih_size = 0;\n\tif (vn->vn_nr_item) {\n\t\tif (vn->vn_vi[0].vi_type & VI_TYPE_LEFT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\n\t\tif (vn->vn_vi[vn->vn_nr_item - 1].\n\t\t    vi_type & VI_TYPE_RIGHT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\t} else {\n\t\t/* there was only one item and it will be deleted */\n\t\tstruct item_head *ih;\n\n\t\tRFALSE(B_NR_ITEMS(S0) != 1,\n\t\t       \"vs-8125: item number must be 1: it is %d\",\n\t\t       B_NR_ITEMS(S0));\n\n\t\tih = item_head(S0, 0);\n\t\tif (tb->CFR[0]\n\t\t    && !comp_short_le_keys(&ih->ih_key,\n\t\t\t\t\t   internal_key(tb->CFR[0],\n\t\t\t\t\t\t\t  tb->rkey[0])))\n\t\t\t/*\n\t\t\t * Directory must be in correct state here: that is\n\t\t\t * somewhere at the left side should exist first\n\t\t\t * directory item. But the item being deleted can\n\t\t\t * not be that first one because its right neighbor\n\t\t\t * is item of the same directory. (But first item\n\t\t\t * always gets deleted in last turn). So, neighbors\n\t\t\t * of deleted item can be merged, so we can save\n\t\t\t * ih_size\n\t\t\t */\n\t\t\tif (is_direntry_le_ih(ih)) {\n\t\t\t\tih_size = IH_SIZE;\n\n\t\t\t\t/*\n\t\t\t\t * we might check that left neighbor exists\n\t\t\t\t * and is of the same directory\n\t\t\t\t */\n\t\t\t\tRFALSE(le_ih_k_offset(ih) == DOT_OFFSET,\n\t\t\t\t       \"vs-8130: first directory item can not be removed until directory is not empty\");\n\t\t\t}\n\n\t}\n\n\tif (MAX_CHILD_SIZE(S0) + vn->vn_size <= rfree + lfree + ih_size) {\n\t\tset_parameters(tb, 0, -1, -1, -1, NULL, -1, -1);\n\t\tPROC_INFO_INC(tb->tb_sb, leaves_removable);\n\t\treturn 1;\n\t}\n\treturn 0;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_transfer_reply",
          "args": [
            "call",
            "skb"
          ],
          "line": 1298
        },
        "resolved": true,
        "details": {
          "function_name": "afs_transfer_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "668-675",
          "snippet": "void afs_transfer_reply(struct afs_call *call, struct sk_buff *skb)\n{\n\tsize_t len = skb->len;\n\n\tif (skb_copy_bits(skb, 0, call->buffer + call->reply_size, len) < 0)\n\t\tBUG();\n\tcall->reply_size += len;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);",
            "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
            "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\n\nvoid afs_transfer_reply(struct afs_call *call, struct sk_buff *skb)\n{\n\tsize_t len = skb->len;\n\n\tif (skb_copy_bits(skb, 0, call->buffer + call->reply_size, len) < 0)\n\t\tBUG();\n\tcall->reply_size += len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\",,%u\"",
            "last"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic int afs_deliver_fs_store_status(struct afs_call *call,\n\t\t\t\t       struct sk_buff *skb, bool last)\n{\n\tafs_dataversion_t *store_version;\n\tstruct afs_vnode *vnode = call->reply;\n\tconst __be32 *bp;\n\n\t_enter(\",,%u\", last);\n\n\tafs_transfer_reply(call, skb);\n\tif (!last) {\n\t\t_leave(\" = 0 [more]\");\n\t\treturn 0;\n\t}\n\n\tif (call->reply_size != call->reply_max) {\n\t\t_leave(\" = -EBADMSG [%u != %u]\",\n\t\t       call->reply_size, call->reply_max);\n\t\treturn -EBADMSG;\n\t}\n\n\t/* unmarshall the reply once we've received all of it */\n\tstore_version = NULL;\n\tif (call->operation_ID == FSSTOREDATA)\n\t\tstore_version = &call->store_version;\n\n\tbp = call->buffer;\n\txdr_decode_AFSFetchStatus(&bp, &vnode->status, vnode, store_version);\n\t/* xdr_decode_AFSVolSync(&bp, call->replyX); */\n\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}"
  },
  {
    "function_name": "afs_fs_store_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
    "lines": "1215-1284",
    "snippet": "int afs_fs_store_data(struct afs_server *server, struct afs_writeback *wb,\n\t\t      pgoff_t first, pgoff_t last,\n\t\t      unsigned offset, unsigned to,\n\t\t      const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_vnode *vnode = wb->vnode;\n\tstruct afs_call *call;\n\tloff_t size, pos, i_size;\n\t__be32 *bp;\n\n\t_enter(\",%x,{%x:%u},,\",\n\t       key_serial(wb->key), vnode->fid.vid, vnode->fid.vnode);\n\n\tsize = to - offset;\n\tif (first != last)\n\t\tsize += (loff_t)(last - first) << PAGE_SHIFT;\n\tpos = (loff_t)first << PAGE_SHIFT;\n\tpos += offset;\n\n\ti_size = i_size_read(&vnode->vfs_inode);\n\tif (pos + size > i_size)\n\t\ti_size = size + pos;\n\n\t_debug(\"size %llx, at %llx, i_size %llx\",\n\t       (unsigned long long) size, (unsigned long long) pos,\n\t       (unsigned long long) i_size);\n\n\tif (pos >> 32 || i_size >> 32 || size >> 32 || (pos + size) >> 32)\n\t\treturn afs_fs_store_data64(server, wb, first, last, offset, to,\n\t\t\t\t\t   size, pos, i_size, wait_mode);\n\n\tcall = afs_alloc_flat_call(&afs_RXFSStoreData,\n\t\t\t\t   (4 + 6 + 3) * 4,\n\t\t\t\t   (21 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->wb = wb;\n\tcall->key = wb->key;\n\tcall->reply = vnode;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\tcall->mapping = vnode->vfs_inode.i_mapping;\n\tcall->first = first;\n\tcall->last = last;\n\tcall->first_offset = offset;\n\tcall->last_to = to;\n\tcall->send_pages = true;\n\tcall->store_version = vnode->status.data_version + 1;\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(FSSTOREDATA);\n\t*bp++ = htonl(vnode->fid.vid);\n\t*bp++ = htonl(vnode->fid.vnode);\n\t*bp++ = htonl(vnode->fid.unique);\n\n\t*bp++ = 0; /* mask */\n\t*bp++ = 0; /* mtime */\n\t*bp++ = 0; /* owner */\n\t*bp++ = 0; /* group */\n\t*bp++ = 0; /* unix mode */\n\t*bp++ = 0; /* segment size */\n\n\t*bp++ = htonl(pos);\n\t*bp++ = htonl(size);\n\t*bp++ = htonl(i_size);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}",
    "includes": [
      "#include \"afs_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/circ_buf.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct afs_call_type afs_RXFSStoreData = {\n\t.name\t\t= \"FS.StoreData\",\n\t.deliver\t= afs_deliver_fs_store_data,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "afs_make_call",
          "args": [
            "&server->addr",
            "call",
            "GFP_NOFS",
            "wait_mode"
          ],
          "line": 1283
        },
        "resolved": true,
        "details": {
          "function_name": "afs_make_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "338-420",
          "snippet": "int afs_make_call(struct in_addr *addr, struct afs_call *call, gfp_t gfp,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct sockaddr_rxrpc srx;\n\tstruct rxrpc_call *rxcall;\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tint ret;\n\tstruct sk_buff *skb;\n\n\t_enter(\"%x,{%d},\", addr->s_addr, ntohs(call->port));\n\n\tASSERT(call->type != NULL);\n\tASSERT(call->type->name != NULL);\n\n\t_debug(\"____MAKE %p{%s,%x} [%d]____\",\n\t       call, call->type->name, key_serial(call->key),\n\t       atomic_read(&afs_outstanding_calls));\n\n\tcall->wait_mode = wait_mode;\n\tcall->async_workfn = afs_process_async_call;\n\tINIT_WORK(&call->async_work, afs_async_workfn);\n\n\tmemset(&srx, 0, sizeof(srx));\n\tsrx.srx_family = AF_RXRPC;\n\tsrx.srx_service = call->service_id;\n\tsrx.transport_type = SOCK_DGRAM;\n\tsrx.transport_len = sizeof(srx.transport.sin);\n\tsrx.transport.sin.sin_family = AF_INET;\n\tsrx.transport.sin.sin_port = call->port;\n\tmemcpy(&srx.transport.sin.sin_addr, addr, 4);\n\n\t/* create a call */\n\trxcall = rxrpc_kernel_begin_call(afs_socket, &srx, call->key,\n\t\t\t\t\t (unsigned long) call, gfp);\n\tcall->key = NULL;\n\tif (IS_ERR(rxcall)) {\n\t\tret = PTR_ERR(rxcall);\n\t\tgoto error_kill_call;\n\t}\n\n\tcall->rxcall = rxcall;\n\n\t/* send the request */\n\tiov[0].iov_base\t= call->request;\n\tiov[0].iov_len\t= call->request_size;\n\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1,\n\t\t      call->request_size);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= (call->send_pages ? MSG_MORE : 0);\n\n\t/* have to change the state *before* sending the last packet as RxRPC\n\t * might give us the reply before it returns from sending the\n\t * request */\n\tif (!call->send_pages)\n\t\tcall->state = AFS_CALL_AWAIT_REPLY;\n\tret = rxrpc_kernel_send_data(rxcall, &msg, call->request_size);\n\tif (ret < 0)\n\t\tgoto error_do_abort;\n\n\tif (call->send_pages) {\n\t\tret = afs_send_pages(call, &msg, iov);\n\t\tif (ret < 0)\n\t\t\tgoto error_do_abort;\n\t}\n\n\t/* at this point, an async call may no longer exist as it may have\n\t * already completed */\n\treturn wait_mode->wait(call);\n\nerror_do_abort:\n\trxrpc_kernel_abort_call(rxcall, RX_USER_ABORT);\n\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\tafs_free_skb(skb);\nerror_kill_call:\n\tafs_end_call(call);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct socket *afs_socket;",
            "static atomic_t afs_outstanding_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);",
            "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
            "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic struct socket *afs_socket;\nstatic atomic_t afs_outstanding_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\n\nint afs_make_call(struct in_addr *addr, struct afs_call *call, gfp_t gfp,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct sockaddr_rxrpc srx;\n\tstruct rxrpc_call *rxcall;\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tint ret;\n\tstruct sk_buff *skb;\n\n\t_enter(\"%x,{%d},\", addr->s_addr, ntohs(call->port));\n\n\tASSERT(call->type != NULL);\n\tASSERT(call->type->name != NULL);\n\n\t_debug(\"____MAKE %p{%s,%x} [%d]____\",\n\t       call, call->type->name, key_serial(call->key),\n\t       atomic_read(&afs_outstanding_calls));\n\n\tcall->wait_mode = wait_mode;\n\tcall->async_workfn = afs_process_async_call;\n\tINIT_WORK(&call->async_work, afs_async_workfn);\n\n\tmemset(&srx, 0, sizeof(srx));\n\tsrx.srx_family = AF_RXRPC;\n\tsrx.srx_service = call->service_id;\n\tsrx.transport_type = SOCK_DGRAM;\n\tsrx.transport_len = sizeof(srx.transport.sin);\n\tsrx.transport.sin.sin_family = AF_INET;\n\tsrx.transport.sin.sin_port = call->port;\n\tmemcpy(&srx.transport.sin.sin_addr, addr, 4);\n\n\t/* create a call */\n\trxcall = rxrpc_kernel_begin_call(afs_socket, &srx, call->key,\n\t\t\t\t\t (unsigned long) call, gfp);\n\tcall->key = NULL;\n\tif (IS_ERR(rxcall)) {\n\t\tret = PTR_ERR(rxcall);\n\t\tgoto error_kill_call;\n\t}\n\n\tcall->rxcall = rxcall;\n\n\t/* send the request */\n\tiov[0].iov_base\t= call->request;\n\tiov[0].iov_len\t= call->request_size;\n\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1,\n\t\t      call->request_size);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= (call->send_pages ? MSG_MORE : 0);\n\n\t/* have to change the state *before* sending the last packet as RxRPC\n\t * might give us the reply before it returns from sending the\n\t * request */\n\tif (!call->send_pages)\n\t\tcall->state = AFS_CALL_AWAIT_REPLY;\n\tret = rxrpc_kernel_send_data(rxcall, &msg, call->request_size);\n\tif (ret < 0)\n\t\tgoto error_do_abort;\n\n\tif (call->send_pages) {\n\t\tret = afs_send_pages(call, &msg, iov);\n\t\tif (ret < 0)\n\t\t\tgoto error_do_abort;\n\t}\n\n\t/* at this point, an async call may no longer exist as it may have\n\t * already completed */\n\treturn wait_mode->wait(call);\n\nerror_do_abort:\n\trxrpc_kernel_abort_call(rxcall, RX_USER_ABORT);\n\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\tafs_free_skb(skb);\nerror_kill_call:\n\tafs_end_call(call);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "i_size"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "size"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "pos"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "vnode->fid.unique"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "vnode->fid.vnode"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "vnode->fid.vid"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "FSSTOREDATA"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "AFS_FS_PORT"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_alloc_flat_call",
          "args": [
            "&afs_RXFSStoreData",
            "(4 + 6 + 3) * 4",
            "(21 + 6) * 4"
          ],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "afs_alloc_flat_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "218-255",
          "snippet": "struct afs_call *afs_alloc_flat_call(const struct afs_call_type *type,\n\t\t\t\t     size_t request_size, size_t reply_size)\n{\n\tstruct afs_call *call;\n\n\tcall = kzalloc(sizeof(*call), GFP_NOFS);\n\tif (!call)\n\t\tgoto nomem_call;\n\n\t_debug(\"CALL %p{%s} [%d]\",\n\t       call, type->name, atomic_read(&afs_outstanding_calls));\n\tatomic_inc(&afs_outstanding_calls);\n\n\tcall->type = type;\n\tcall->request_size = request_size;\n\tcall->reply_max = reply_size;\n\n\tif (request_size) {\n\t\tcall->request = kmalloc(request_size, GFP_NOFS);\n\t\tif (!call->request)\n\t\t\tgoto nomem_free;\n\t}\n\n\tif (reply_size) {\n\t\tcall->buffer = kmalloc(reply_size, GFP_NOFS);\n\t\tif (!call->buffer)\n\t\t\tgoto nomem_free;\n\t}\n\n\tinit_waitqueue_head(&call->waitq);\n\tskb_queue_head_init(&call->rx_queue);\n\treturn call;\n\nnomem_free:\n\tafs_free_call(call);\nnomem_call:\n\treturn NULL;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t afs_outstanding_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic atomic_t afs_outstanding_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nstruct afs_call *afs_alloc_flat_call(const struct afs_call_type *type,\n\t\t\t\t     size_t request_size, size_t reply_size)\n{\n\tstruct afs_call *call;\n\n\tcall = kzalloc(sizeof(*call), GFP_NOFS);\n\tif (!call)\n\t\tgoto nomem_call;\n\n\t_debug(\"CALL %p{%s} [%d]\",\n\t       call, type->name, atomic_read(&afs_outstanding_calls));\n\tatomic_inc(&afs_outstanding_calls);\n\n\tcall->type = type;\n\tcall->request_size = request_size;\n\tcall->reply_max = reply_size;\n\n\tif (request_size) {\n\t\tcall->request = kmalloc(request_size, GFP_NOFS);\n\t\tif (!call->request)\n\t\t\tgoto nomem_free;\n\t}\n\n\tif (reply_size) {\n\t\tcall->buffer = kmalloc(reply_size, GFP_NOFS);\n\t\tif (!call->buffer)\n\t\t\tgoto nomem_free;\n\t}\n\n\tinit_waitqueue_head(&call->waitq);\n\tskb_queue_head_init(&call->rx_queue);\n\treturn call;\n\nnomem_free:\n\tafs_free_call(call);\nnomem_call:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_fs_store_data64",
          "args": [
            "server",
            "wb",
            "first",
            "last",
            "offset",
            "to",
            "size",
            "pos",
            "i_size",
            "wait_mode"
          ],
          "line": 1243
        },
        "resolved": true,
        "details": {
          "function_name": "afs_fs_store_data64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
          "lines": "1155-1210",
          "snippet": "static int afs_fs_store_data64(struct afs_server *server,\n\t\t\t       struct afs_writeback *wb,\n\t\t\t       pgoff_t first, pgoff_t last,\n\t\t\t       unsigned offset, unsigned to,\n\t\t\t       loff_t size, loff_t pos, loff_t i_size,\n\t\t\t       const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_vnode *vnode = wb->vnode;\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\",%x,{%x:%u},,\",\n\t       key_serial(wb->key), vnode->fid.vid, vnode->fid.vnode);\n\n\tcall = afs_alloc_flat_call(&afs_RXFSStoreData64,\n\t\t\t\t   (4 + 6 + 3 * 2) * 4,\n\t\t\t\t   (21 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->wb = wb;\n\tcall->key = wb->key;\n\tcall->reply = vnode;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\tcall->mapping = vnode->vfs_inode.i_mapping;\n\tcall->first = first;\n\tcall->last = last;\n\tcall->first_offset = offset;\n\tcall->last_to = to;\n\tcall->send_pages = true;\n\tcall->store_version = vnode->status.data_version + 1;\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(FSSTOREDATA64);\n\t*bp++ = htonl(vnode->fid.vid);\n\t*bp++ = htonl(vnode->fid.vnode);\n\t*bp++ = htonl(vnode->fid.unique);\n\n\t*bp++ = 0; /* mask */\n\t*bp++ = 0; /* mtime */\n\t*bp++ = 0; /* owner */\n\t*bp++ = 0; /* group */\n\t*bp++ = 0; /* unix mode */\n\t*bp++ = 0; /* segment size */\n\n\t*bp++ = htonl(pos >> 32);\n\t*bp++ = htonl((u32) pos);\n\t*bp++ = htonl(size >> 32);\n\t*bp++ = htonl((u32) size);\n\t*bp++ = htonl(i_size >> 32);\n\t*bp++ = htonl((u32) i_size);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}",
          "includes": [
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct afs_call_type afs_RXFSStoreData64 = {\n\t.name\t\t= \"FS.StoreData64\",\n\t.deliver\t= afs_deliver_fs_store_data,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic const struct afs_call_type afs_RXFSStoreData64 = {\n\t.name\t\t= \"FS.StoreData64\",\n\t.deliver\t= afs_deliver_fs_store_data,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\nstatic int afs_fs_store_data64(struct afs_server *server,\n\t\t\t       struct afs_writeback *wb,\n\t\t\t       pgoff_t first, pgoff_t last,\n\t\t\t       unsigned offset, unsigned to,\n\t\t\t       loff_t size, loff_t pos, loff_t i_size,\n\t\t\t       const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_vnode *vnode = wb->vnode;\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\",%x,{%x:%u},,\",\n\t       key_serial(wb->key), vnode->fid.vid, vnode->fid.vnode);\n\n\tcall = afs_alloc_flat_call(&afs_RXFSStoreData64,\n\t\t\t\t   (4 + 6 + 3 * 2) * 4,\n\t\t\t\t   (21 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->wb = wb;\n\tcall->key = wb->key;\n\tcall->reply = vnode;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\tcall->mapping = vnode->vfs_inode.i_mapping;\n\tcall->first = first;\n\tcall->last = last;\n\tcall->first_offset = offset;\n\tcall->last_to = to;\n\tcall->send_pages = true;\n\tcall->store_version = vnode->status.data_version + 1;\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(FSSTOREDATA64);\n\t*bp++ = htonl(vnode->fid.vid);\n\t*bp++ = htonl(vnode->fid.vnode);\n\t*bp++ = htonl(vnode->fid.unique);\n\n\t*bp++ = 0; /* mask */\n\t*bp++ = 0; /* mtime */\n\t*bp++ = 0; /* owner */\n\t*bp++ = 0; /* group */\n\t*bp++ = 0; /* unix mode */\n\t*bp++ = 0; /* segment size */\n\n\t*bp++ = htonl(pos >> 32);\n\t*bp++ = htonl((u32) pos);\n\t*bp++ = htonl(size >> 32);\n\t*bp++ = htonl((u32) size);\n\t*bp++ = htonl(i_size >> 32);\n\t*bp++ = htonl((u32) i_size);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"size %llx, at %llx, i_size %llx\"",
            "(unsigned long long) size",
            "(unsigned long long) pos",
            "(unsigned long long) i_size"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "&vnode->vfs_inode"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "last - first"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\",%x,{%x:%u},,\"",
            "key_serial(wb->key)",
            "vnode->fid.vid",
            "vnode->fid.vnode"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_serial",
          "args": [
            "wb->key"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic const struct afs_call_type afs_RXFSStoreData = {\n\t.name\t\t= \"FS.StoreData\",\n\t.deliver\t= afs_deliver_fs_store_data,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\nint afs_fs_store_data(struct afs_server *server, struct afs_writeback *wb,\n\t\t      pgoff_t first, pgoff_t last,\n\t\t      unsigned offset, unsigned to,\n\t\t      const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_vnode *vnode = wb->vnode;\n\tstruct afs_call *call;\n\tloff_t size, pos, i_size;\n\t__be32 *bp;\n\n\t_enter(\",%x,{%x:%u},,\",\n\t       key_serial(wb->key), vnode->fid.vid, vnode->fid.vnode);\n\n\tsize = to - offset;\n\tif (first != last)\n\t\tsize += (loff_t)(last - first) << PAGE_SHIFT;\n\tpos = (loff_t)first << PAGE_SHIFT;\n\tpos += offset;\n\n\ti_size = i_size_read(&vnode->vfs_inode);\n\tif (pos + size > i_size)\n\t\ti_size = size + pos;\n\n\t_debug(\"size %llx, at %llx, i_size %llx\",\n\t       (unsigned long long) size, (unsigned long long) pos,\n\t       (unsigned long long) i_size);\n\n\tif (pos >> 32 || i_size >> 32 || size >> 32 || (pos + size) >> 32)\n\t\treturn afs_fs_store_data64(server, wb, first, last, offset, to,\n\t\t\t\t\t   size, pos, i_size, wait_mode);\n\n\tcall = afs_alloc_flat_call(&afs_RXFSStoreData,\n\t\t\t\t   (4 + 6 + 3) * 4,\n\t\t\t\t   (21 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->wb = wb;\n\tcall->key = wb->key;\n\tcall->reply = vnode;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\tcall->mapping = vnode->vfs_inode.i_mapping;\n\tcall->first = first;\n\tcall->last = last;\n\tcall->first_offset = offset;\n\tcall->last_to = to;\n\tcall->send_pages = true;\n\tcall->store_version = vnode->status.data_version + 1;\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(FSSTOREDATA);\n\t*bp++ = htonl(vnode->fid.vid);\n\t*bp++ = htonl(vnode->fid.vnode);\n\t*bp++ = htonl(vnode->fid.unique);\n\n\t*bp++ = 0; /* mask */\n\t*bp++ = 0; /* mtime */\n\t*bp++ = 0; /* owner */\n\t*bp++ = 0; /* group */\n\t*bp++ = 0; /* unix mode */\n\t*bp++ = 0; /* segment size */\n\n\t*bp++ = htonl(pos);\n\t*bp++ = htonl(size);\n\t*bp++ = htonl(i_size);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}"
  },
  {
    "function_name": "afs_fs_store_data64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
    "lines": "1155-1210",
    "snippet": "static int afs_fs_store_data64(struct afs_server *server,\n\t\t\t       struct afs_writeback *wb,\n\t\t\t       pgoff_t first, pgoff_t last,\n\t\t\t       unsigned offset, unsigned to,\n\t\t\t       loff_t size, loff_t pos, loff_t i_size,\n\t\t\t       const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_vnode *vnode = wb->vnode;\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\",%x,{%x:%u},,\",\n\t       key_serial(wb->key), vnode->fid.vid, vnode->fid.vnode);\n\n\tcall = afs_alloc_flat_call(&afs_RXFSStoreData64,\n\t\t\t\t   (4 + 6 + 3 * 2) * 4,\n\t\t\t\t   (21 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->wb = wb;\n\tcall->key = wb->key;\n\tcall->reply = vnode;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\tcall->mapping = vnode->vfs_inode.i_mapping;\n\tcall->first = first;\n\tcall->last = last;\n\tcall->first_offset = offset;\n\tcall->last_to = to;\n\tcall->send_pages = true;\n\tcall->store_version = vnode->status.data_version + 1;\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(FSSTOREDATA64);\n\t*bp++ = htonl(vnode->fid.vid);\n\t*bp++ = htonl(vnode->fid.vnode);\n\t*bp++ = htonl(vnode->fid.unique);\n\n\t*bp++ = 0; /* mask */\n\t*bp++ = 0; /* mtime */\n\t*bp++ = 0; /* owner */\n\t*bp++ = 0; /* group */\n\t*bp++ = 0; /* unix mode */\n\t*bp++ = 0; /* segment size */\n\n\t*bp++ = htonl(pos >> 32);\n\t*bp++ = htonl((u32) pos);\n\t*bp++ = htonl(size >> 32);\n\t*bp++ = htonl((u32) size);\n\t*bp++ = htonl(i_size >> 32);\n\t*bp++ = htonl((u32) i_size);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}",
    "includes": [
      "#include \"afs_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/circ_buf.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct afs_call_type afs_RXFSStoreData64 = {\n\t.name\t\t= \"FS.StoreData64\",\n\t.deliver\t= afs_deliver_fs_store_data,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "afs_make_call",
          "args": [
            "&server->addr",
            "call",
            "GFP_NOFS",
            "wait_mode"
          ],
          "line": 1209
        },
        "resolved": true,
        "details": {
          "function_name": "afs_make_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "338-420",
          "snippet": "int afs_make_call(struct in_addr *addr, struct afs_call *call, gfp_t gfp,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct sockaddr_rxrpc srx;\n\tstruct rxrpc_call *rxcall;\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tint ret;\n\tstruct sk_buff *skb;\n\n\t_enter(\"%x,{%d},\", addr->s_addr, ntohs(call->port));\n\n\tASSERT(call->type != NULL);\n\tASSERT(call->type->name != NULL);\n\n\t_debug(\"____MAKE %p{%s,%x} [%d]____\",\n\t       call, call->type->name, key_serial(call->key),\n\t       atomic_read(&afs_outstanding_calls));\n\n\tcall->wait_mode = wait_mode;\n\tcall->async_workfn = afs_process_async_call;\n\tINIT_WORK(&call->async_work, afs_async_workfn);\n\n\tmemset(&srx, 0, sizeof(srx));\n\tsrx.srx_family = AF_RXRPC;\n\tsrx.srx_service = call->service_id;\n\tsrx.transport_type = SOCK_DGRAM;\n\tsrx.transport_len = sizeof(srx.transport.sin);\n\tsrx.transport.sin.sin_family = AF_INET;\n\tsrx.transport.sin.sin_port = call->port;\n\tmemcpy(&srx.transport.sin.sin_addr, addr, 4);\n\n\t/* create a call */\n\trxcall = rxrpc_kernel_begin_call(afs_socket, &srx, call->key,\n\t\t\t\t\t (unsigned long) call, gfp);\n\tcall->key = NULL;\n\tif (IS_ERR(rxcall)) {\n\t\tret = PTR_ERR(rxcall);\n\t\tgoto error_kill_call;\n\t}\n\n\tcall->rxcall = rxcall;\n\n\t/* send the request */\n\tiov[0].iov_base\t= call->request;\n\tiov[0].iov_len\t= call->request_size;\n\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1,\n\t\t      call->request_size);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= (call->send_pages ? MSG_MORE : 0);\n\n\t/* have to change the state *before* sending the last packet as RxRPC\n\t * might give us the reply before it returns from sending the\n\t * request */\n\tif (!call->send_pages)\n\t\tcall->state = AFS_CALL_AWAIT_REPLY;\n\tret = rxrpc_kernel_send_data(rxcall, &msg, call->request_size);\n\tif (ret < 0)\n\t\tgoto error_do_abort;\n\n\tif (call->send_pages) {\n\t\tret = afs_send_pages(call, &msg, iov);\n\t\tif (ret < 0)\n\t\t\tgoto error_do_abort;\n\t}\n\n\t/* at this point, an async call may no longer exist as it may have\n\t * already completed */\n\treturn wait_mode->wait(call);\n\nerror_do_abort:\n\trxrpc_kernel_abort_call(rxcall, RX_USER_ABORT);\n\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\tafs_free_skb(skb);\nerror_kill_call:\n\tafs_end_call(call);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct socket *afs_socket;",
            "static atomic_t afs_outstanding_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);",
            "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
            "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic struct socket *afs_socket;\nstatic atomic_t afs_outstanding_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\n\nint afs_make_call(struct in_addr *addr, struct afs_call *call, gfp_t gfp,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct sockaddr_rxrpc srx;\n\tstruct rxrpc_call *rxcall;\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tint ret;\n\tstruct sk_buff *skb;\n\n\t_enter(\"%x,{%d},\", addr->s_addr, ntohs(call->port));\n\n\tASSERT(call->type != NULL);\n\tASSERT(call->type->name != NULL);\n\n\t_debug(\"____MAKE %p{%s,%x} [%d]____\",\n\t       call, call->type->name, key_serial(call->key),\n\t       atomic_read(&afs_outstanding_calls));\n\n\tcall->wait_mode = wait_mode;\n\tcall->async_workfn = afs_process_async_call;\n\tINIT_WORK(&call->async_work, afs_async_workfn);\n\n\tmemset(&srx, 0, sizeof(srx));\n\tsrx.srx_family = AF_RXRPC;\n\tsrx.srx_service = call->service_id;\n\tsrx.transport_type = SOCK_DGRAM;\n\tsrx.transport_len = sizeof(srx.transport.sin);\n\tsrx.transport.sin.sin_family = AF_INET;\n\tsrx.transport.sin.sin_port = call->port;\n\tmemcpy(&srx.transport.sin.sin_addr, addr, 4);\n\n\t/* create a call */\n\trxcall = rxrpc_kernel_begin_call(afs_socket, &srx, call->key,\n\t\t\t\t\t (unsigned long) call, gfp);\n\tcall->key = NULL;\n\tif (IS_ERR(rxcall)) {\n\t\tret = PTR_ERR(rxcall);\n\t\tgoto error_kill_call;\n\t}\n\n\tcall->rxcall = rxcall;\n\n\t/* send the request */\n\tiov[0].iov_base\t= call->request;\n\tiov[0].iov_len\t= call->request_size;\n\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1,\n\t\t      call->request_size);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= (call->send_pages ? MSG_MORE : 0);\n\n\t/* have to change the state *before* sending the last packet as RxRPC\n\t * might give us the reply before it returns from sending the\n\t * request */\n\tif (!call->send_pages)\n\t\tcall->state = AFS_CALL_AWAIT_REPLY;\n\tret = rxrpc_kernel_send_data(rxcall, &msg, call->request_size);\n\tif (ret < 0)\n\t\tgoto error_do_abort;\n\n\tif (call->send_pages) {\n\t\tret = afs_send_pages(call, &msg, iov);\n\t\tif (ret < 0)\n\t\t\tgoto error_do_abort;\n\t}\n\n\t/* at this point, an async call may no longer exist as it may have\n\t * already completed */\n\treturn wait_mode->wait(call);\n\nerror_do_abort:\n\trxrpc_kernel_abort_call(rxcall, RX_USER_ABORT);\n\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\tafs_free_skb(skb);\nerror_kill_call:\n\tafs_end_call(call);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "(u32) i_size"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "i_size >> 32"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "(u32) size"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "size >> 32"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "(u32) pos"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "pos >> 32"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "vnode->fid.unique"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "vnode->fid.vnode"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "vnode->fid.vid"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "FSSTOREDATA64"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "AFS_FS_PORT"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_alloc_flat_call",
          "args": [
            "&afs_RXFSStoreData64",
            "(4 + 6 + 3 * 2) * 4",
            "(21 + 6) * 4"
          ],
          "line": 1169
        },
        "resolved": true,
        "details": {
          "function_name": "afs_alloc_flat_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "218-255",
          "snippet": "struct afs_call *afs_alloc_flat_call(const struct afs_call_type *type,\n\t\t\t\t     size_t request_size, size_t reply_size)\n{\n\tstruct afs_call *call;\n\n\tcall = kzalloc(sizeof(*call), GFP_NOFS);\n\tif (!call)\n\t\tgoto nomem_call;\n\n\t_debug(\"CALL %p{%s} [%d]\",\n\t       call, type->name, atomic_read(&afs_outstanding_calls));\n\tatomic_inc(&afs_outstanding_calls);\n\n\tcall->type = type;\n\tcall->request_size = request_size;\n\tcall->reply_max = reply_size;\n\n\tif (request_size) {\n\t\tcall->request = kmalloc(request_size, GFP_NOFS);\n\t\tif (!call->request)\n\t\t\tgoto nomem_free;\n\t}\n\n\tif (reply_size) {\n\t\tcall->buffer = kmalloc(reply_size, GFP_NOFS);\n\t\tif (!call->buffer)\n\t\t\tgoto nomem_free;\n\t}\n\n\tinit_waitqueue_head(&call->waitq);\n\tskb_queue_head_init(&call->rx_queue);\n\treturn call;\n\nnomem_free:\n\tafs_free_call(call);\nnomem_call:\n\treturn NULL;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t afs_outstanding_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic atomic_t afs_outstanding_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nstruct afs_call *afs_alloc_flat_call(const struct afs_call_type *type,\n\t\t\t\t     size_t request_size, size_t reply_size)\n{\n\tstruct afs_call *call;\n\n\tcall = kzalloc(sizeof(*call), GFP_NOFS);\n\tif (!call)\n\t\tgoto nomem_call;\n\n\t_debug(\"CALL %p{%s} [%d]\",\n\t       call, type->name, atomic_read(&afs_outstanding_calls));\n\tatomic_inc(&afs_outstanding_calls);\n\n\tcall->type = type;\n\tcall->request_size = request_size;\n\tcall->reply_max = reply_size;\n\n\tif (request_size) {\n\t\tcall->request = kmalloc(request_size, GFP_NOFS);\n\t\tif (!call->request)\n\t\t\tgoto nomem_free;\n\t}\n\n\tif (reply_size) {\n\t\tcall->buffer = kmalloc(reply_size, GFP_NOFS);\n\t\tif (!call->buffer)\n\t\t\tgoto nomem_free;\n\t}\n\n\tinit_waitqueue_head(&call->waitq);\n\tskb_queue_head_init(&call->rx_queue);\n\treturn call;\n\nnomem_free:\n\tafs_free_call(call);\nnomem_call:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\",%x,{%x:%u},,\"",
            "key_serial(wb->key)",
            "vnode->fid.vid",
            "vnode->fid.vnode"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_serial",
          "args": [
            "wb->key"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic const struct afs_call_type afs_RXFSStoreData64 = {\n\t.name\t\t= \"FS.StoreData64\",\n\t.deliver\t= afs_deliver_fs_store_data,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\nstatic int afs_fs_store_data64(struct afs_server *server,\n\t\t\t       struct afs_writeback *wb,\n\t\t\t       pgoff_t first, pgoff_t last,\n\t\t\t       unsigned offset, unsigned to,\n\t\t\t       loff_t size, loff_t pos, loff_t i_size,\n\t\t\t       const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_vnode *vnode = wb->vnode;\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\",%x,{%x:%u},,\",\n\t       key_serial(wb->key), vnode->fid.vid, vnode->fid.vnode);\n\n\tcall = afs_alloc_flat_call(&afs_RXFSStoreData64,\n\t\t\t\t   (4 + 6 + 3 * 2) * 4,\n\t\t\t\t   (21 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->wb = wb;\n\tcall->key = wb->key;\n\tcall->reply = vnode;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\tcall->mapping = vnode->vfs_inode.i_mapping;\n\tcall->first = first;\n\tcall->last = last;\n\tcall->first_offset = offset;\n\tcall->last_to = to;\n\tcall->send_pages = true;\n\tcall->store_version = vnode->status.data_version + 1;\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(FSSTOREDATA64);\n\t*bp++ = htonl(vnode->fid.vid);\n\t*bp++ = htonl(vnode->fid.vnode);\n\t*bp++ = htonl(vnode->fid.unique);\n\n\t*bp++ = 0; /* mask */\n\t*bp++ = 0; /* mtime */\n\t*bp++ = 0; /* owner */\n\t*bp++ = 0; /* group */\n\t*bp++ = 0; /* unix mode */\n\t*bp++ = 0; /* segment size */\n\n\t*bp++ = htonl(pos >> 32);\n\t*bp++ = htonl((u32) pos);\n\t*bp++ = htonl(size >> 32);\n\t*bp++ = htonl((u32) size);\n\t*bp++ = htonl(i_size >> 32);\n\t*bp++ = htonl((u32) i_size);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}"
  },
  {
    "function_name": "afs_deliver_fs_store_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
    "lines": "1103-1133",
    "snippet": "static int afs_deliver_fs_store_data(struct afs_call *call,\n\t\t\t\t     struct sk_buff *skb, bool last)\n{\n\tstruct afs_vnode *vnode = call->reply;\n\tconst __be32 *bp;\n\n\t_enter(\",,%u\", last);\n\n\tafs_transfer_reply(call, skb);\n\tif (!last) {\n\t\t_leave(\" = 0 [more]\");\n\t\treturn 0;\n\t}\n\n\tif (call->reply_size != call->reply_max) {\n\t\t_leave(\" = -EBADMSG [%u != %u]\",\n\t\t       call->reply_size, call->reply_max);\n\t\treturn -EBADMSG;\n\t}\n\n\t/* unmarshall the reply once we've received all of it */\n\tbp = call->buffer;\n\txdr_decode_AFSFetchStatus(&bp, &vnode->status, vnode,\n\t\t\t\t  &call->store_version);\n\t/* xdr_decode_AFSVolSync(&bp, call->replyX); */\n\n\tafs_pages_written_back(vnode, call);\n\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}",
    "includes": [
      "#include \"afs_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/circ_buf.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = 0 [done]\""
          ],
          "line": 1131
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_pages_written_back",
          "args": [
            "vnode",
            "call"
          ],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "afs_pages_written_back",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/write.c",
          "lines": "572-623",
          "snippet": "void afs_pages_written_back(struct afs_vnode *vnode, struct afs_call *call)\n{\n\tstruct afs_writeback *wb = call->wb;\n\tstruct pagevec pv;\n\tunsigned count, loop;\n\tpgoff_t first = call->first, last = call->last;\n\tbool free_wb;\n\n\t_enter(\"{%x:%u},{%lx-%lx}\",\n\t       vnode->fid.vid, vnode->fid.vnode, first, last);\n\n\tASSERT(wb != NULL);\n\n\tpagevec_init(&pv, 0);\n\n\tdo {\n\t\t_debug(\"done %lx-%lx\", first, last);\n\n\t\tcount = last - first + 1;\n\t\tif (count > PAGEVEC_SIZE)\n\t\t\tcount = PAGEVEC_SIZE;\n\t\tpv.nr = find_get_pages_contig(call->mapping, first, count,\n\t\t\t\t\t      pv.pages);\n\t\tASSERTCMP(pv.nr, ==, count);\n\n\t\tspin_lock(&vnode->writeback_lock);\n\t\tfor (loop = 0; loop < count; loop++) {\n\t\t\tstruct page *page = pv.pages[loop];\n\t\t\tend_page_writeback(page);\n\t\t\tif (page_private(page) == (unsigned long) wb) {\n\t\t\t\tset_page_private(page, 0);\n\t\t\t\tClearPagePrivate(page);\n\t\t\t\twb->usage--;\n\t\t\t}\n\t\t}\n\t\tfree_wb = false;\n\t\tif (wb->usage == 0) {\n\t\t\tafs_unlink_writeback(wb);\n\t\t\tfree_wb = true;\n\t\t}\n\t\tspin_unlock(&vnode->writeback_lock);\n\t\tfirst += count;\n\t\tif (free_wb) {\n\t\t\tafs_free_writeback(wb);\n\t\t\twb = NULL;\n\t\t}\n\n\t\t__pagevec_release(&pv);\n\t} while (first <= last);\n\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int afs_write_back_from_locked_page(struct afs_writeback *wb,\n\t\t\t\t\t   struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n\nstatic int afs_write_back_from_locked_page(struct afs_writeback *wb,\n\t\t\t\t\t   struct page *page);\n\nvoid afs_pages_written_back(struct afs_vnode *vnode, struct afs_call *call)\n{\n\tstruct afs_writeback *wb = call->wb;\n\tstruct pagevec pv;\n\tunsigned count, loop;\n\tpgoff_t first = call->first, last = call->last;\n\tbool free_wb;\n\n\t_enter(\"{%x:%u},{%lx-%lx}\",\n\t       vnode->fid.vid, vnode->fid.vnode, first, last);\n\n\tASSERT(wb != NULL);\n\n\tpagevec_init(&pv, 0);\n\n\tdo {\n\t\t_debug(\"done %lx-%lx\", first, last);\n\n\t\tcount = last - first + 1;\n\t\tif (count > PAGEVEC_SIZE)\n\t\t\tcount = PAGEVEC_SIZE;\n\t\tpv.nr = find_get_pages_contig(call->mapping, first, count,\n\t\t\t\t\t      pv.pages);\n\t\tASSERTCMP(pv.nr, ==, count);\n\n\t\tspin_lock(&vnode->writeback_lock);\n\t\tfor (loop = 0; loop < count; loop++) {\n\t\t\tstruct page *page = pv.pages[loop];\n\t\t\tend_page_writeback(page);\n\t\t\tif (page_private(page) == (unsigned long) wb) {\n\t\t\t\tset_page_private(page, 0);\n\t\t\t\tClearPagePrivate(page);\n\t\t\t\twb->usage--;\n\t\t\t}\n\t\t}\n\t\tfree_wb = false;\n\t\tif (wb->usage == 0) {\n\t\t\tafs_unlink_writeback(wb);\n\t\t\tfree_wb = true;\n\t\t}\n\t\tspin_unlock(&vnode->writeback_lock);\n\t\tfirst += count;\n\t\tif (free_wb) {\n\t\t\tafs_free_writeback(wb);\n\t\t\twb = NULL;\n\t\t}\n\n\t\t__pagevec_release(&pv);\n\t} while (first <= last);\n\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_decode_AFSFetchStatus",
          "args": [
            "&bp",
            "&vnode->status",
            "vnode",
            "&call->store_version"
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "xdr_decode_AFSFetchStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
          "lines": "35-130",
          "snippet": "static void xdr_decode_AFSFetchStatus(const __be32 **_bp,\n\t\t\t\t      struct afs_file_status *status,\n\t\t\t\t      struct afs_vnode *vnode,\n\t\t\t\t      afs_dataversion_t *store_version)\n{\n\tafs_dataversion_t expected_version;\n\tconst __be32 *bp = *_bp;\n\tumode_t mode;\n\tu64 data_version, size;\n\tu32 changed = 0; /* becomes non-zero if ctime-type changes seen */\n\tkuid_t owner;\n\tkgid_t group;\n\n#define EXTRACT(DST)\t\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tu32 x = ntohl(*bp++);\t\t\\\n\t\tchanged |= DST - x;\t\t\\\n\t\tDST = x;\t\t\t\\\n\t} while (0)\n\n\tstatus->if_version = ntohl(*bp++);\n\tEXTRACT(status->type);\n\tEXTRACT(status->nlink);\n\tsize = ntohl(*bp++);\n\tdata_version = ntohl(*bp++);\n\tEXTRACT(status->author);\n\towner = make_kuid(&init_user_ns, ntohl(*bp++));\n\tchanged |= !uid_eq(owner, status->owner);\n\tstatus->owner = owner;\n\tEXTRACT(status->caller_access); /* call ticket dependent */\n\tEXTRACT(status->anon_access);\n\tEXTRACT(status->mode);\n\tEXTRACT(status->parent.vnode);\n\tEXTRACT(status->parent.unique);\n\tbp++; /* seg size */\n\tstatus->mtime_client = ntohl(*bp++);\n\tstatus->mtime_server = ntohl(*bp++);\n\tgroup = make_kgid(&init_user_ns, ntohl(*bp++));\n\tchanged |= !gid_eq(group, status->group);\n\tstatus->group = group;\n\tbp++; /* sync counter */\n\tdata_version |= (u64) ntohl(*bp++) << 32;\n\tEXTRACT(status->lock_count);\n\tsize |= (u64) ntohl(*bp++) << 32;\n\tbp++; /* spare 4 */\n\t*_bp = bp;\n\n\tif (size != status->size) {\n\t\tstatus->size = size;\n\t\tchanged |= true;\n\t}\n\tstatus->mode &= S_IALLUGO;\n\n\t_debug(\"vnode time %lx, %lx\",\n\t       status->mtime_client, status->mtime_server);\n\n\tif (vnode) {\n\t\tstatus->parent.vid = vnode->fid.vid;\n\t\tif (changed && !test_bit(AFS_VNODE_UNSET, &vnode->flags)) {\n\t\t\t_debug(\"vnode changed\");\n\t\t\ti_size_write(&vnode->vfs_inode, size);\n\t\t\tvnode->vfs_inode.i_uid = status->owner;\n\t\t\tvnode->vfs_inode.i_gid = status->group;\n\t\t\tvnode->vfs_inode.i_generation = vnode->fid.unique;\n\t\t\tset_nlink(&vnode->vfs_inode, status->nlink);\n\n\t\t\tmode = vnode->vfs_inode.i_mode;\n\t\t\tmode &= ~S_IALLUGO;\n\t\t\tmode |= status->mode;\n\t\t\tbarrier();\n\t\t\tvnode->vfs_inode.i_mode = mode;\n\t\t}\n\n\t\tvnode->vfs_inode.i_ctime.tv_sec\t= status->mtime_server;\n\t\tvnode->vfs_inode.i_mtime\t= vnode->vfs_inode.i_ctime;\n\t\tvnode->vfs_inode.i_atime\t= vnode->vfs_inode.i_ctime;\n\t\tvnode->vfs_inode.i_version\t= data_version;\n\t}\n\n\texpected_version = status->data_version;\n\tif (store_version)\n\t\texpected_version = *store_version;\n\n\tif (expected_version != data_version) {\n\t\tstatus->data_version = data_version;\n\t\tif (vnode && !test_bit(AFS_VNODE_UNSET, &vnode->flags)) {\n\t\t\t_debug(\"vnode modified %llx on {%x:%u}\",\n\t\t\t       (unsigned long long) data_version,\n\t\t\t       vnode->fid.vid, vnode->fid.vnode);\n\t\t\tset_bit(AFS_VNODE_MODIFIED, &vnode->flags);\n\t\t\tset_bit(AFS_VNODE_ZAP_DATA, &vnode->flags);\n\t\t}\n\t} else if (store_version) {\n\t\tstatus->data_version = data_version;\n\t}\n}",
          "includes": [
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic void xdr_decode_AFSFetchStatus(const __be32 **_bp,\n\t\t\t\t      struct afs_file_status *status,\n\t\t\t\t      struct afs_vnode *vnode,\n\t\t\t\t      afs_dataversion_t *store_version)\n{\n\tafs_dataversion_t expected_version;\n\tconst __be32 *bp = *_bp;\n\tumode_t mode;\n\tu64 data_version, size;\n\tu32 changed = 0; /* becomes non-zero if ctime-type changes seen */\n\tkuid_t owner;\n\tkgid_t group;\n\n#define EXTRACT(DST)\t\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tu32 x = ntohl(*bp++);\t\t\\\n\t\tchanged |= DST - x;\t\t\\\n\t\tDST = x;\t\t\t\\\n\t} while (0)\n\n\tstatus->if_version = ntohl(*bp++);\n\tEXTRACT(status->type);\n\tEXTRACT(status->nlink);\n\tsize = ntohl(*bp++);\n\tdata_version = ntohl(*bp++);\n\tEXTRACT(status->author);\n\towner = make_kuid(&init_user_ns, ntohl(*bp++));\n\tchanged |= !uid_eq(owner, status->owner);\n\tstatus->owner = owner;\n\tEXTRACT(status->caller_access); /* call ticket dependent */\n\tEXTRACT(status->anon_access);\n\tEXTRACT(status->mode);\n\tEXTRACT(status->parent.vnode);\n\tEXTRACT(status->parent.unique);\n\tbp++; /* seg size */\n\tstatus->mtime_client = ntohl(*bp++);\n\tstatus->mtime_server = ntohl(*bp++);\n\tgroup = make_kgid(&init_user_ns, ntohl(*bp++));\n\tchanged |= !gid_eq(group, status->group);\n\tstatus->group = group;\n\tbp++; /* sync counter */\n\tdata_version |= (u64) ntohl(*bp++) << 32;\n\tEXTRACT(status->lock_count);\n\tsize |= (u64) ntohl(*bp++) << 32;\n\tbp++; /* spare 4 */\n\t*_bp = bp;\n\n\tif (size != status->size) {\n\t\tstatus->size = size;\n\t\tchanged |= true;\n\t}\n\tstatus->mode &= S_IALLUGO;\n\n\t_debug(\"vnode time %lx, %lx\",\n\t       status->mtime_client, status->mtime_server);\n\n\tif (vnode) {\n\t\tstatus->parent.vid = vnode->fid.vid;\n\t\tif (changed && !test_bit(AFS_VNODE_UNSET, &vnode->flags)) {\n\t\t\t_debug(\"vnode changed\");\n\t\t\ti_size_write(&vnode->vfs_inode, size);\n\t\t\tvnode->vfs_inode.i_uid = status->owner;\n\t\t\tvnode->vfs_inode.i_gid = status->group;\n\t\t\tvnode->vfs_inode.i_generation = vnode->fid.unique;\n\t\t\tset_nlink(&vnode->vfs_inode, status->nlink);\n\n\t\t\tmode = vnode->vfs_inode.i_mode;\n\t\t\tmode &= ~S_IALLUGO;\n\t\t\tmode |= status->mode;\n\t\t\tbarrier();\n\t\t\tvnode->vfs_inode.i_mode = mode;\n\t\t}\n\n\t\tvnode->vfs_inode.i_ctime.tv_sec\t= status->mtime_server;\n\t\tvnode->vfs_inode.i_mtime\t= vnode->vfs_inode.i_ctime;\n\t\tvnode->vfs_inode.i_atime\t= vnode->vfs_inode.i_ctime;\n\t\tvnode->vfs_inode.i_version\t= data_version;\n\t}\n\n\texpected_version = status->data_version;\n\tif (store_version)\n\t\texpected_version = *store_version;\n\n\tif (expected_version != data_version) {\n\t\tstatus->data_version = data_version;\n\t\tif (vnode && !test_bit(AFS_VNODE_UNSET, &vnode->flags)) {\n\t\t\t_debug(\"vnode modified %llx on {%x:%u}\",\n\t\t\t       (unsigned long long) data_version,\n\t\t\t       vnode->fid.vid, vnode->fid.vnode);\n\t\t\tset_bit(AFS_VNODE_MODIFIED, &vnode->flags);\n\t\t\tset_bit(AFS_VNODE_ZAP_DATA, &vnode->flags);\n\t\t}\n\t} else if (store_version) {\n\t\tstatus->data_version = data_version;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = -EBADMSG [%u != %u]\"",
            "call->reply_size",
            "call->reply_max"
          ],
          "line": 1118
        },
        "resolved": true,
        "details": {
          "function_name": "are_leaves_removable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "698-757",
          "snippet": "static int are_leaves_removable(struct tree_balance *tb, int lfree, int rfree)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint ih_size;\n\tstruct buffer_head *S0;\n\n\tS0 = PATH_H_PBUFFER(tb->tb_path, 0);\n\n\tih_size = 0;\n\tif (vn->vn_nr_item) {\n\t\tif (vn->vn_vi[0].vi_type & VI_TYPE_LEFT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\n\t\tif (vn->vn_vi[vn->vn_nr_item - 1].\n\t\t    vi_type & VI_TYPE_RIGHT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\t} else {\n\t\t/* there was only one item and it will be deleted */\n\t\tstruct item_head *ih;\n\n\t\tRFALSE(B_NR_ITEMS(S0) != 1,\n\t\t       \"vs-8125: item number must be 1: it is %d\",\n\t\t       B_NR_ITEMS(S0));\n\n\t\tih = item_head(S0, 0);\n\t\tif (tb->CFR[0]\n\t\t    && !comp_short_le_keys(&ih->ih_key,\n\t\t\t\t\t   internal_key(tb->CFR[0],\n\t\t\t\t\t\t\t  tb->rkey[0])))\n\t\t\t/*\n\t\t\t * Directory must be in correct state here: that is\n\t\t\t * somewhere at the left side should exist first\n\t\t\t * directory item. But the item being deleted can\n\t\t\t * not be that first one because its right neighbor\n\t\t\t * is item of the same directory. (But first item\n\t\t\t * always gets deleted in last turn). So, neighbors\n\t\t\t * of deleted item can be merged, so we can save\n\t\t\t * ih_size\n\t\t\t */\n\t\t\tif (is_direntry_le_ih(ih)) {\n\t\t\t\tih_size = IH_SIZE;\n\n\t\t\t\t/*\n\t\t\t\t * we might check that left neighbor exists\n\t\t\t\t * and is of the same directory\n\t\t\t\t */\n\t\t\t\tRFALSE(le_ih_k_offset(ih) == DOT_OFFSET,\n\t\t\t\t       \"vs-8130: first directory item can not be removed until directory is not empty\");\n\t\t\t}\n\n\t}\n\n\tif (MAX_CHILD_SIZE(S0) + vn->vn_size <= rfree + lfree + ih_size) {\n\t\tset_parameters(tb, 0, -1, -1, -1, NULL, -1, -1);\n\t\tPROC_INFO_INC(tb->tb_sb, leaves_removable);\n\t\treturn 1;\n\t}\n\treturn 0;\n\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int are_leaves_removable(struct tree_balance *tb, int lfree, int rfree)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint ih_size;\n\tstruct buffer_head *S0;\n\n\tS0 = PATH_H_PBUFFER(tb->tb_path, 0);\n\n\tih_size = 0;\n\tif (vn->vn_nr_item) {\n\t\tif (vn->vn_vi[0].vi_type & VI_TYPE_LEFT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\n\t\tif (vn->vn_vi[vn->vn_nr_item - 1].\n\t\t    vi_type & VI_TYPE_RIGHT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\t} else {\n\t\t/* there was only one item and it will be deleted */\n\t\tstruct item_head *ih;\n\n\t\tRFALSE(B_NR_ITEMS(S0) != 1,\n\t\t       \"vs-8125: item number must be 1: it is %d\",\n\t\t       B_NR_ITEMS(S0));\n\n\t\tih = item_head(S0, 0);\n\t\tif (tb->CFR[0]\n\t\t    && !comp_short_le_keys(&ih->ih_key,\n\t\t\t\t\t   internal_key(tb->CFR[0],\n\t\t\t\t\t\t\t  tb->rkey[0])))\n\t\t\t/*\n\t\t\t * Directory must be in correct state here: that is\n\t\t\t * somewhere at the left side should exist first\n\t\t\t * directory item. But the item being deleted can\n\t\t\t * not be that first one because its right neighbor\n\t\t\t * is item of the same directory. (But first item\n\t\t\t * always gets deleted in last turn). So, neighbors\n\t\t\t * of deleted item can be merged, so we can save\n\t\t\t * ih_size\n\t\t\t */\n\t\t\tif (is_direntry_le_ih(ih)) {\n\t\t\t\tih_size = IH_SIZE;\n\n\t\t\t\t/*\n\t\t\t\t * we might check that left neighbor exists\n\t\t\t\t * and is of the same directory\n\t\t\t\t */\n\t\t\t\tRFALSE(le_ih_k_offset(ih) == DOT_OFFSET,\n\t\t\t\t       \"vs-8130: first directory item can not be removed until directory is not empty\");\n\t\t\t}\n\n\t}\n\n\tif (MAX_CHILD_SIZE(S0) + vn->vn_size <= rfree + lfree + ih_size) {\n\t\tset_parameters(tb, 0, -1, -1, -1, NULL, -1, -1);\n\t\tPROC_INFO_INC(tb->tb_sb, leaves_removable);\n\t\treturn 1;\n\t}\n\treturn 0;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_transfer_reply",
          "args": [
            "call",
            "skb"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "afs_transfer_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "668-675",
          "snippet": "void afs_transfer_reply(struct afs_call *call, struct sk_buff *skb)\n{\n\tsize_t len = skb->len;\n\n\tif (skb_copy_bits(skb, 0, call->buffer + call->reply_size, len) < 0)\n\t\tBUG();\n\tcall->reply_size += len;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);",
            "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
            "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\n\nvoid afs_transfer_reply(struct afs_call *call, struct sk_buff *skb)\n{\n\tsize_t len = skb->len;\n\n\tif (skb_copy_bits(skb, 0, call->buffer + call->reply_size, len) < 0)\n\t\tBUG();\n\tcall->reply_size += len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\",,%u\"",
            "last"
          ],
          "line": 1109
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic int afs_deliver_fs_store_data(struct afs_call *call,\n\t\t\t\t     struct sk_buff *skb, bool last)\n{\n\tstruct afs_vnode *vnode = call->reply;\n\tconst __be32 *bp;\n\n\t_enter(\",,%u\", last);\n\n\tafs_transfer_reply(call, skb);\n\tif (!last) {\n\t\t_leave(\" = 0 [more]\");\n\t\treturn 0;\n\t}\n\n\tif (call->reply_size != call->reply_max) {\n\t\t_leave(\" = -EBADMSG [%u != %u]\",\n\t\t       call->reply_size, call->reply_max);\n\t\treturn -EBADMSG;\n\t}\n\n\t/* unmarshall the reply once we've received all of it */\n\tbp = call->buffer;\n\txdr_decode_AFSFetchStatus(&bp, &vnode->status, vnode,\n\t\t\t\t  &call->store_version);\n\t/* xdr_decode_AFSVolSync(&bp, call->replyX); */\n\n\tafs_pages_written_back(vnode, call);\n\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}"
  },
  {
    "function_name": "afs_fs_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
    "lines": "1037-1098",
    "snippet": "int afs_fs_rename(struct afs_server *server,\n\t\t  struct key *key,\n\t\t  struct afs_vnode *orig_dvnode,\n\t\t  const char *orig_name,\n\t\t  struct afs_vnode *new_dvnode,\n\t\t  const char *new_name,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\tsize_t reqsz, o_namesz, o_padsz, n_namesz, n_padsz;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\to_namesz = strlen(orig_name);\n\to_padsz = (4 - (o_namesz & 3)) & 3;\n\n\tn_namesz = strlen(new_name);\n\tn_padsz = (4 - (n_namesz & 3)) & 3;\n\n\treqsz = (4 * 4) +\n\t\t4 + o_namesz + o_padsz +\n\t\t(3 * 4) +\n\t\t4 + n_namesz + n_padsz;\n\n\tcall = afs_alloc_flat_call(&afs_RXFSRename, reqsz, (21 + 21 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = orig_dvnode;\n\tcall->reply2 = new_dvnode;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(FSRENAME);\n\t*bp++ = htonl(orig_dvnode->fid.vid);\n\t*bp++ = htonl(orig_dvnode->fid.vnode);\n\t*bp++ = htonl(orig_dvnode->fid.unique);\n\t*bp++ = htonl(o_namesz);\n\tmemcpy(bp, orig_name, o_namesz);\n\tbp = (void *) bp + o_namesz;\n\tif (o_padsz > 0) {\n\t\tmemset(bp, 0, o_padsz);\n\t\tbp = (void *) bp + o_padsz;\n\t}\n\n\t*bp++ = htonl(new_dvnode->fid.vid);\n\t*bp++ = htonl(new_dvnode->fid.vnode);\n\t*bp++ = htonl(new_dvnode->fid.unique);\n\t*bp++ = htonl(n_namesz);\n\tmemcpy(bp, new_name, n_namesz);\n\tbp = (void *) bp + n_namesz;\n\tif (n_padsz > 0) {\n\t\tmemset(bp, 0, n_padsz);\n\t\tbp = (void *) bp + n_padsz;\n\t}\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}",
    "includes": [
      "#include \"afs_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/circ_buf.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct afs_call_type afs_RXFSRename = {\n\t.name\t\t= \"FS.Rename\",\n\t.deliver\t= afs_deliver_fs_rename,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "afs_make_call",
          "args": [
            "&server->addr",
            "call",
            "GFP_NOFS",
            "wait_mode"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "afs_make_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "338-420",
          "snippet": "int afs_make_call(struct in_addr *addr, struct afs_call *call, gfp_t gfp,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct sockaddr_rxrpc srx;\n\tstruct rxrpc_call *rxcall;\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tint ret;\n\tstruct sk_buff *skb;\n\n\t_enter(\"%x,{%d},\", addr->s_addr, ntohs(call->port));\n\n\tASSERT(call->type != NULL);\n\tASSERT(call->type->name != NULL);\n\n\t_debug(\"____MAKE %p{%s,%x} [%d]____\",\n\t       call, call->type->name, key_serial(call->key),\n\t       atomic_read(&afs_outstanding_calls));\n\n\tcall->wait_mode = wait_mode;\n\tcall->async_workfn = afs_process_async_call;\n\tINIT_WORK(&call->async_work, afs_async_workfn);\n\n\tmemset(&srx, 0, sizeof(srx));\n\tsrx.srx_family = AF_RXRPC;\n\tsrx.srx_service = call->service_id;\n\tsrx.transport_type = SOCK_DGRAM;\n\tsrx.transport_len = sizeof(srx.transport.sin);\n\tsrx.transport.sin.sin_family = AF_INET;\n\tsrx.transport.sin.sin_port = call->port;\n\tmemcpy(&srx.transport.sin.sin_addr, addr, 4);\n\n\t/* create a call */\n\trxcall = rxrpc_kernel_begin_call(afs_socket, &srx, call->key,\n\t\t\t\t\t (unsigned long) call, gfp);\n\tcall->key = NULL;\n\tif (IS_ERR(rxcall)) {\n\t\tret = PTR_ERR(rxcall);\n\t\tgoto error_kill_call;\n\t}\n\n\tcall->rxcall = rxcall;\n\n\t/* send the request */\n\tiov[0].iov_base\t= call->request;\n\tiov[0].iov_len\t= call->request_size;\n\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1,\n\t\t      call->request_size);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= (call->send_pages ? MSG_MORE : 0);\n\n\t/* have to change the state *before* sending the last packet as RxRPC\n\t * might give us the reply before it returns from sending the\n\t * request */\n\tif (!call->send_pages)\n\t\tcall->state = AFS_CALL_AWAIT_REPLY;\n\tret = rxrpc_kernel_send_data(rxcall, &msg, call->request_size);\n\tif (ret < 0)\n\t\tgoto error_do_abort;\n\n\tif (call->send_pages) {\n\t\tret = afs_send_pages(call, &msg, iov);\n\t\tif (ret < 0)\n\t\t\tgoto error_do_abort;\n\t}\n\n\t/* at this point, an async call may no longer exist as it may have\n\t * already completed */\n\treturn wait_mode->wait(call);\n\nerror_do_abort:\n\trxrpc_kernel_abort_call(rxcall, RX_USER_ABORT);\n\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\tafs_free_skb(skb);\nerror_kill_call:\n\tafs_end_call(call);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct socket *afs_socket;",
            "static atomic_t afs_outstanding_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);",
            "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
            "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic struct socket *afs_socket;\nstatic atomic_t afs_outstanding_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\n\nint afs_make_call(struct in_addr *addr, struct afs_call *call, gfp_t gfp,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct sockaddr_rxrpc srx;\n\tstruct rxrpc_call *rxcall;\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tint ret;\n\tstruct sk_buff *skb;\n\n\t_enter(\"%x,{%d},\", addr->s_addr, ntohs(call->port));\n\n\tASSERT(call->type != NULL);\n\tASSERT(call->type->name != NULL);\n\n\t_debug(\"____MAKE %p{%s,%x} [%d]____\",\n\t       call, call->type->name, key_serial(call->key),\n\t       atomic_read(&afs_outstanding_calls));\n\n\tcall->wait_mode = wait_mode;\n\tcall->async_workfn = afs_process_async_call;\n\tINIT_WORK(&call->async_work, afs_async_workfn);\n\n\tmemset(&srx, 0, sizeof(srx));\n\tsrx.srx_family = AF_RXRPC;\n\tsrx.srx_service = call->service_id;\n\tsrx.transport_type = SOCK_DGRAM;\n\tsrx.transport_len = sizeof(srx.transport.sin);\n\tsrx.transport.sin.sin_family = AF_INET;\n\tsrx.transport.sin.sin_port = call->port;\n\tmemcpy(&srx.transport.sin.sin_addr, addr, 4);\n\n\t/* create a call */\n\trxcall = rxrpc_kernel_begin_call(afs_socket, &srx, call->key,\n\t\t\t\t\t (unsigned long) call, gfp);\n\tcall->key = NULL;\n\tif (IS_ERR(rxcall)) {\n\t\tret = PTR_ERR(rxcall);\n\t\tgoto error_kill_call;\n\t}\n\n\tcall->rxcall = rxcall;\n\n\t/* send the request */\n\tiov[0].iov_base\t= call->request;\n\tiov[0].iov_len\t= call->request_size;\n\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1,\n\t\t      call->request_size);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= (call->send_pages ? MSG_MORE : 0);\n\n\t/* have to change the state *before* sending the last packet as RxRPC\n\t * might give us the reply before it returns from sending the\n\t * request */\n\tif (!call->send_pages)\n\t\tcall->state = AFS_CALL_AWAIT_REPLY;\n\tret = rxrpc_kernel_send_data(rxcall, &msg, call->request_size);\n\tif (ret < 0)\n\t\tgoto error_do_abort;\n\n\tif (call->send_pages) {\n\t\tret = afs_send_pages(call, &msg, iov);\n\t\tif (ret < 0)\n\t\t\tgoto error_do_abort;\n\t}\n\n\t/* at this point, an async call may no longer exist as it may have\n\t * already completed */\n\treturn wait_mode->wait(call);\n\nerror_do_abort:\n\trxrpc_kernel_abort_call(rxcall, RX_USER_ABORT);\n\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\tafs_free_skb(skb);\nerror_kill_call:\n\tafs_end_call(call);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bp",
            "0",
            "n_padsz"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bp",
            "new_name",
            "n_namesz"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "n_namesz"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "new_dvnode->fid.unique"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "new_dvnode->fid.vnode"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "new_dvnode->fid.vid"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bp",
            "0",
            "o_padsz"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bp",
            "orig_name",
            "o_namesz"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "o_namesz"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "orig_dvnode->fid.unique"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "orig_dvnode->fid.vnode"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "orig_dvnode->fid.vid"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "FSRENAME"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "AFS_FS_PORT"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_alloc_flat_call",
          "args": [
            "&afs_RXFSRename",
            "reqsz",
            "(21 + 21 + 6) * 4"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "afs_alloc_flat_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "218-255",
          "snippet": "struct afs_call *afs_alloc_flat_call(const struct afs_call_type *type,\n\t\t\t\t     size_t request_size, size_t reply_size)\n{\n\tstruct afs_call *call;\n\n\tcall = kzalloc(sizeof(*call), GFP_NOFS);\n\tif (!call)\n\t\tgoto nomem_call;\n\n\t_debug(\"CALL %p{%s} [%d]\",\n\t       call, type->name, atomic_read(&afs_outstanding_calls));\n\tatomic_inc(&afs_outstanding_calls);\n\n\tcall->type = type;\n\tcall->request_size = request_size;\n\tcall->reply_max = reply_size;\n\n\tif (request_size) {\n\t\tcall->request = kmalloc(request_size, GFP_NOFS);\n\t\tif (!call->request)\n\t\t\tgoto nomem_free;\n\t}\n\n\tif (reply_size) {\n\t\tcall->buffer = kmalloc(reply_size, GFP_NOFS);\n\t\tif (!call->buffer)\n\t\t\tgoto nomem_free;\n\t}\n\n\tinit_waitqueue_head(&call->waitq);\n\tskb_queue_head_init(&call->rx_queue);\n\treturn call;\n\nnomem_free:\n\tafs_free_call(call);\nnomem_call:\n\treturn NULL;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t afs_outstanding_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic atomic_t afs_outstanding_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nstruct afs_call *afs_alloc_flat_call(const struct afs_call_type *type,\n\t\t\t\t     size_t request_size, size_t reply_size)\n{\n\tstruct afs_call *call;\n\n\tcall = kzalloc(sizeof(*call), GFP_NOFS);\n\tif (!call)\n\t\tgoto nomem_call;\n\n\t_debug(\"CALL %p{%s} [%d]\",\n\t       call, type->name, atomic_read(&afs_outstanding_calls));\n\tatomic_inc(&afs_outstanding_calls);\n\n\tcall->type = type;\n\tcall->request_size = request_size;\n\tcall->reply_max = reply_size;\n\n\tif (request_size) {\n\t\tcall->request = kmalloc(request_size, GFP_NOFS);\n\t\tif (!call->request)\n\t\t\tgoto nomem_free;\n\t}\n\n\tif (reply_size) {\n\t\tcall->buffer = kmalloc(reply_size, GFP_NOFS);\n\t\tif (!call->buffer)\n\t\t\tgoto nomem_free;\n\t}\n\n\tinit_waitqueue_head(&call->waitq);\n\tskb_queue_head_init(&call->rx_queue);\n\treturn call;\n\nnomem_free:\n\tafs_free_call(call);\nnomem_call:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "new_name"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic const struct afs_call_type afs_RXFSRename = {\n\t.name\t\t= \"FS.Rename\",\n\t.deliver\t= afs_deliver_fs_rename,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\nint afs_fs_rename(struct afs_server *server,\n\t\t  struct key *key,\n\t\t  struct afs_vnode *orig_dvnode,\n\t\t  const char *orig_name,\n\t\t  struct afs_vnode *new_dvnode,\n\t\t  const char *new_name,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\tsize_t reqsz, o_namesz, o_padsz, n_namesz, n_padsz;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\to_namesz = strlen(orig_name);\n\to_padsz = (4 - (o_namesz & 3)) & 3;\n\n\tn_namesz = strlen(new_name);\n\tn_padsz = (4 - (n_namesz & 3)) & 3;\n\n\treqsz = (4 * 4) +\n\t\t4 + o_namesz + o_padsz +\n\t\t(3 * 4) +\n\t\t4 + n_namesz + n_padsz;\n\n\tcall = afs_alloc_flat_call(&afs_RXFSRename, reqsz, (21 + 21 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = orig_dvnode;\n\tcall->reply2 = new_dvnode;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(FSRENAME);\n\t*bp++ = htonl(orig_dvnode->fid.vid);\n\t*bp++ = htonl(orig_dvnode->fid.vnode);\n\t*bp++ = htonl(orig_dvnode->fid.unique);\n\t*bp++ = htonl(o_namesz);\n\tmemcpy(bp, orig_name, o_namesz);\n\tbp = (void *) bp + o_namesz;\n\tif (o_padsz > 0) {\n\t\tmemset(bp, 0, o_padsz);\n\t\tbp = (void *) bp + o_padsz;\n\t}\n\n\t*bp++ = htonl(new_dvnode->fid.vid);\n\t*bp++ = htonl(new_dvnode->fid.vnode);\n\t*bp++ = htonl(new_dvnode->fid.unique);\n\t*bp++ = htonl(n_namesz);\n\tmemcpy(bp, new_name, n_namesz);\n\tbp = (void *) bp + n_namesz;\n\tif (n_padsz > 0) {\n\t\tmemset(bp, 0, n_padsz);\n\t\tbp = (void *) bp + n_padsz;\n\t}\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}"
  },
  {
    "function_name": "afs_deliver_fs_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
    "lines": "997-1022",
    "snippet": "static int afs_deliver_fs_rename(struct afs_call *call,\n\t\t\t\t  struct sk_buff *skb, bool last)\n{\n\tstruct afs_vnode *orig_dvnode = call->reply, *new_dvnode = call->reply2;\n\tconst __be32 *bp;\n\n\t_enter(\"{%u},{%u},%d\", call->unmarshall, skb->len, last);\n\n\tafs_transfer_reply(call, skb);\n\tif (!last)\n\t\treturn 0;\n\n\tif (call->reply_size != call->reply_max)\n\t\treturn -EBADMSG;\n\n\t/* unmarshall the reply once we've received all of it */\n\tbp = call->buffer;\n\txdr_decode_AFSFetchStatus(&bp, &orig_dvnode->status, orig_dvnode, NULL);\n\tif (new_dvnode != orig_dvnode)\n\t\txdr_decode_AFSFetchStatus(&bp, &new_dvnode->status, new_dvnode,\n\t\t\t\t\t  NULL);\n\t/* xdr_decode_AFSVolSync(&bp, call->replyX); */\n\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}",
    "includes": [
      "#include \"afs_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/circ_buf.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = 0 [done]\""
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_decode_AFSFetchStatus",
          "args": [
            "&bp",
            "&new_dvnode->status",
            "new_dvnode",
            "NULL"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "xdr_decode_AFSFetchStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
          "lines": "35-130",
          "snippet": "static void xdr_decode_AFSFetchStatus(const __be32 **_bp,\n\t\t\t\t      struct afs_file_status *status,\n\t\t\t\t      struct afs_vnode *vnode,\n\t\t\t\t      afs_dataversion_t *store_version)\n{\n\tafs_dataversion_t expected_version;\n\tconst __be32 *bp = *_bp;\n\tumode_t mode;\n\tu64 data_version, size;\n\tu32 changed = 0; /* becomes non-zero if ctime-type changes seen */\n\tkuid_t owner;\n\tkgid_t group;\n\n#define EXTRACT(DST)\t\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tu32 x = ntohl(*bp++);\t\t\\\n\t\tchanged |= DST - x;\t\t\\\n\t\tDST = x;\t\t\t\\\n\t} while (0)\n\n\tstatus->if_version = ntohl(*bp++);\n\tEXTRACT(status->type);\n\tEXTRACT(status->nlink);\n\tsize = ntohl(*bp++);\n\tdata_version = ntohl(*bp++);\n\tEXTRACT(status->author);\n\towner = make_kuid(&init_user_ns, ntohl(*bp++));\n\tchanged |= !uid_eq(owner, status->owner);\n\tstatus->owner = owner;\n\tEXTRACT(status->caller_access); /* call ticket dependent */\n\tEXTRACT(status->anon_access);\n\tEXTRACT(status->mode);\n\tEXTRACT(status->parent.vnode);\n\tEXTRACT(status->parent.unique);\n\tbp++; /* seg size */\n\tstatus->mtime_client = ntohl(*bp++);\n\tstatus->mtime_server = ntohl(*bp++);\n\tgroup = make_kgid(&init_user_ns, ntohl(*bp++));\n\tchanged |= !gid_eq(group, status->group);\n\tstatus->group = group;\n\tbp++; /* sync counter */\n\tdata_version |= (u64) ntohl(*bp++) << 32;\n\tEXTRACT(status->lock_count);\n\tsize |= (u64) ntohl(*bp++) << 32;\n\tbp++; /* spare 4 */\n\t*_bp = bp;\n\n\tif (size != status->size) {\n\t\tstatus->size = size;\n\t\tchanged |= true;\n\t}\n\tstatus->mode &= S_IALLUGO;\n\n\t_debug(\"vnode time %lx, %lx\",\n\t       status->mtime_client, status->mtime_server);\n\n\tif (vnode) {\n\t\tstatus->parent.vid = vnode->fid.vid;\n\t\tif (changed && !test_bit(AFS_VNODE_UNSET, &vnode->flags)) {\n\t\t\t_debug(\"vnode changed\");\n\t\t\ti_size_write(&vnode->vfs_inode, size);\n\t\t\tvnode->vfs_inode.i_uid = status->owner;\n\t\t\tvnode->vfs_inode.i_gid = status->group;\n\t\t\tvnode->vfs_inode.i_generation = vnode->fid.unique;\n\t\t\tset_nlink(&vnode->vfs_inode, status->nlink);\n\n\t\t\tmode = vnode->vfs_inode.i_mode;\n\t\t\tmode &= ~S_IALLUGO;\n\t\t\tmode |= status->mode;\n\t\t\tbarrier();\n\t\t\tvnode->vfs_inode.i_mode = mode;\n\t\t}\n\n\t\tvnode->vfs_inode.i_ctime.tv_sec\t= status->mtime_server;\n\t\tvnode->vfs_inode.i_mtime\t= vnode->vfs_inode.i_ctime;\n\t\tvnode->vfs_inode.i_atime\t= vnode->vfs_inode.i_ctime;\n\t\tvnode->vfs_inode.i_version\t= data_version;\n\t}\n\n\texpected_version = status->data_version;\n\tif (store_version)\n\t\texpected_version = *store_version;\n\n\tif (expected_version != data_version) {\n\t\tstatus->data_version = data_version;\n\t\tif (vnode && !test_bit(AFS_VNODE_UNSET, &vnode->flags)) {\n\t\t\t_debug(\"vnode modified %llx on {%x:%u}\",\n\t\t\t       (unsigned long long) data_version,\n\t\t\t       vnode->fid.vid, vnode->fid.vnode);\n\t\t\tset_bit(AFS_VNODE_MODIFIED, &vnode->flags);\n\t\t\tset_bit(AFS_VNODE_ZAP_DATA, &vnode->flags);\n\t\t}\n\t} else if (store_version) {\n\t\tstatus->data_version = data_version;\n\t}\n}",
          "includes": [
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic void xdr_decode_AFSFetchStatus(const __be32 **_bp,\n\t\t\t\t      struct afs_file_status *status,\n\t\t\t\t      struct afs_vnode *vnode,\n\t\t\t\t      afs_dataversion_t *store_version)\n{\n\tafs_dataversion_t expected_version;\n\tconst __be32 *bp = *_bp;\n\tumode_t mode;\n\tu64 data_version, size;\n\tu32 changed = 0; /* becomes non-zero if ctime-type changes seen */\n\tkuid_t owner;\n\tkgid_t group;\n\n#define EXTRACT(DST)\t\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tu32 x = ntohl(*bp++);\t\t\\\n\t\tchanged |= DST - x;\t\t\\\n\t\tDST = x;\t\t\t\\\n\t} while (0)\n\n\tstatus->if_version = ntohl(*bp++);\n\tEXTRACT(status->type);\n\tEXTRACT(status->nlink);\n\tsize = ntohl(*bp++);\n\tdata_version = ntohl(*bp++);\n\tEXTRACT(status->author);\n\towner = make_kuid(&init_user_ns, ntohl(*bp++));\n\tchanged |= !uid_eq(owner, status->owner);\n\tstatus->owner = owner;\n\tEXTRACT(status->caller_access); /* call ticket dependent */\n\tEXTRACT(status->anon_access);\n\tEXTRACT(status->mode);\n\tEXTRACT(status->parent.vnode);\n\tEXTRACT(status->parent.unique);\n\tbp++; /* seg size */\n\tstatus->mtime_client = ntohl(*bp++);\n\tstatus->mtime_server = ntohl(*bp++);\n\tgroup = make_kgid(&init_user_ns, ntohl(*bp++));\n\tchanged |= !gid_eq(group, status->group);\n\tstatus->group = group;\n\tbp++; /* sync counter */\n\tdata_version |= (u64) ntohl(*bp++) << 32;\n\tEXTRACT(status->lock_count);\n\tsize |= (u64) ntohl(*bp++) << 32;\n\tbp++; /* spare 4 */\n\t*_bp = bp;\n\n\tif (size != status->size) {\n\t\tstatus->size = size;\n\t\tchanged |= true;\n\t}\n\tstatus->mode &= S_IALLUGO;\n\n\t_debug(\"vnode time %lx, %lx\",\n\t       status->mtime_client, status->mtime_server);\n\n\tif (vnode) {\n\t\tstatus->parent.vid = vnode->fid.vid;\n\t\tif (changed && !test_bit(AFS_VNODE_UNSET, &vnode->flags)) {\n\t\t\t_debug(\"vnode changed\");\n\t\t\ti_size_write(&vnode->vfs_inode, size);\n\t\t\tvnode->vfs_inode.i_uid = status->owner;\n\t\t\tvnode->vfs_inode.i_gid = status->group;\n\t\t\tvnode->vfs_inode.i_generation = vnode->fid.unique;\n\t\t\tset_nlink(&vnode->vfs_inode, status->nlink);\n\n\t\t\tmode = vnode->vfs_inode.i_mode;\n\t\t\tmode &= ~S_IALLUGO;\n\t\t\tmode |= status->mode;\n\t\t\tbarrier();\n\t\t\tvnode->vfs_inode.i_mode = mode;\n\t\t}\n\n\t\tvnode->vfs_inode.i_ctime.tv_sec\t= status->mtime_server;\n\t\tvnode->vfs_inode.i_mtime\t= vnode->vfs_inode.i_ctime;\n\t\tvnode->vfs_inode.i_atime\t= vnode->vfs_inode.i_ctime;\n\t\tvnode->vfs_inode.i_version\t= data_version;\n\t}\n\n\texpected_version = status->data_version;\n\tif (store_version)\n\t\texpected_version = *store_version;\n\n\tif (expected_version != data_version) {\n\t\tstatus->data_version = data_version;\n\t\tif (vnode && !test_bit(AFS_VNODE_UNSET, &vnode->flags)) {\n\t\t\t_debug(\"vnode modified %llx on {%x:%u}\",\n\t\t\t       (unsigned long long) data_version,\n\t\t\t       vnode->fid.vid, vnode->fid.vnode);\n\t\t\tset_bit(AFS_VNODE_MODIFIED, &vnode->flags);\n\t\t\tset_bit(AFS_VNODE_ZAP_DATA, &vnode->flags);\n\t\t}\n\t} else if (store_version) {\n\t\tstatus->data_version = data_version;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_transfer_reply",
          "args": [
            "call",
            "skb"
          ],
          "line": 1005
        },
        "resolved": true,
        "details": {
          "function_name": "afs_transfer_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "668-675",
          "snippet": "void afs_transfer_reply(struct afs_call *call, struct sk_buff *skb)\n{\n\tsize_t len = skb->len;\n\n\tif (skb_copy_bits(skb, 0, call->buffer + call->reply_size, len) < 0)\n\t\tBUG();\n\tcall->reply_size += len;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);",
            "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
            "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\n\nvoid afs_transfer_reply(struct afs_call *call, struct sk_buff *skb)\n{\n\tsize_t len = skb->len;\n\n\tif (skb_copy_bits(skb, 0, call->buffer + call->reply_size, len) < 0)\n\t\tBUG();\n\tcall->reply_size += len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%u},{%u},%d\"",
            "call->unmarshall",
            "skb->len",
            "last"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic int afs_deliver_fs_rename(struct afs_call *call,\n\t\t\t\t  struct sk_buff *skb, bool last)\n{\n\tstruct afs_vnode *orig_dvnode = call->reply, *new_dvnode = call->reply2;\n\tconst __be32 *bp;\n\n\t_enter(\"{%u},{%u},%d\", call->unmarshall, skb->len, last);\n\n\tafs_transfer_reply(call, skb);\n\tif (!last)\n\t\treturn 0;\n\n\tif (call->reply_size != call->reply_max)\n\t\treturn -EBADMSG;\n\n\t/* unmarshall the reply once we've received all of it */\n\tbp = call->buffer;\n\txdr_decode_AFSFetchStatus(&bp, &orig_dvnode->status, orig_dvnode, NULL);\n\tif (new_dvnode != orig_dvnode)\n\t\txdr_decode_AFSFetchStatus(&bp, &new_dvnode->status, new_dvnode,\n\t\t\t\t\t  NULL);\n\t/* xdr_decode_AFSVolSync(&bp, call->replyX); */\n\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}"
  },
  {
    "function_name": "afs_fs_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
    "lines": "929-992",
    "snippet": "int afs_fs_symlink(struct afs_server *server,\n\t\t   struct key *key,\n\t\t   struct afs_vnode *vnode,\n\t\t   const char *name,\n\t\t   const char *contents,\n\t\t   struct afs_fid *newfid,\n\t\t   struct afs_file_status *newstatus,\n\t\t   const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\tsize_t namesz, reqsz, padsz, c_namesz, c_padsz;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tnamesz = strlen(name);\n\tpadsz = (4 - (namesz & 3)) & 3;\n\n\tc_namesz = strlen(contents);\n\tc_padsz = (4 - (c_namesz & 3)) & 3;\n\n\treqsz = (6 * 4) + namesz + padsz + c_namesz + c_padsz + (6 * 4);\n\n\tcall = afs_alloc_flat_call(&afs_RXFSSymlink, reqsz,\n\t\t\t\t   (3 + 21 + 21 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->reply2 = newfid;\n\tcall->reply3 = newstatus;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(FSSYMLINK);\n\t*bp++ = htonl(vnode->fid.vid);\n\t*bp++ = htonl(vnode->fid.vnode);\n\t*bp++ = htonl(vnode->fid.unique);\n\t*bp++ = htonl(namesz);\n\tmemcpy(bp, name, namesz);\n\tbp = (void *) bp + namesz;\n\tif (padsz > 0) {\n\t\tmemset(bp, 0, padsz);\n\t\tbp = (void *) bp + padsz;\n\t}\n\t*bp++ = htonl(c_namesz);\n\tmemcpy(bp, contents, c_namesz);\n\tbp = (void *) bp + c_namesz;\n\tif (c_padsz > 0) {\n\t\tmemset(bp, 0, c_padsz);\n\t\tbp = (void *) bp + c_padsz;\n\t}\n\t*bp++ = htonl(AFS_SET_MODE);\n\t*bp++ = 0; /* mtime */\n\t*bp++ = 0; /* owner */\n\t*bp++ = 0; /* group */\n\t*bp++ = htonl(S_IRWXUGO); /* unix mode */\n\t*bp++ = 0; /* segment size */\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}",
    "includes": [
      "#include \"afs_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/circ_buf.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct afs_call_type afs_RXFSSymlink = {\n\t.name\t\t= \"FS.Symlink\",\n\t.deliver\t= afs_deliver_fs_symlink,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "afs_make_call",
          "args": [
            "&server->addr",
            "call",
            "GFP_NOFS",
            "wait_mode"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "afs_make_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "338-420",
          "snippet": "int afs_make_call(struct in_addr *addr, struct afs_call *call, gfp_t gfp,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct sockaddr_rxrpc srx;\n\tstruct rxrpc_call *rxcall;\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tint ret;\n\tstruct sk_buff *skb;\n\n\t_enter(\"%x,{%d},\", addr->s_addr, ntohs(call->port));\n\n\tASSERT(call->type != NULL);\n\tASSERT(call->type->name != NULL);\n\n\t_debug(\"____MAKE %p{%s,%x} [%d]____\",\n\t       call, call->type->name, key_serial(call->key),\n\t       atomic_read(&afs_outstanding_calls));\n\n\tcall->wait_mode = wait_mode;\n\tcall->async_workfn = afs_process_async_call;\n\tINIT_WORK(&call->async_work, afs_async_workfn);\n\n\tmemset(&srx, 0, sizeof(srx));\n\tsrx.srx_family = AF_RXRPC;\n\tsrx.srx_service = call->service_id;\n\tsrx.transport_type = SOCK_DGRAM;\n\tsrx.transport_len = sizeof(srx.transport.sin);\n\tsrx.transport.sin.sin_family = AF_INET;\n\tsrx.transport.sin.sin_port = call->port;\n\tmemcpy(&srx.transport.sin.sin_addr, addr, 4);\n\n\t/* create a call */\n\trxcall = rxrpc_kernel_begin_call(afs_socket, &srx, call->key,\n\t\t\t\t\t (unsigned long) call, gfp);\n\tcall->key = NULL;\n\tif (IS_ERR(rxcall)) {\n\t\tret = PTR_ERR(rxcall);\n\t\tgoto error_kill_call;\n\t}\n\n\tcall->rxcall = rxcall;\n\n\t/* send the request */\n\tiov[0].iov_base\t= call->request;\n\tiov[0].iov_len\t= call->request_size;\n\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1,\n\t\t      call->request_size);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= (call->send_pages ? MSG_MORE : 0);\n\n\t/* have to change the state *before* sending the last packet as RxRPC\n\t * might give us the reply before it returns from sending the\n\t * request */\n\tif (!call->send_pages)\n\t\tcall->state = AFS_CALL_AWAIT_REPLY;\n\tret = rxrpc_kernel_send_data(rxcall, &msg, call->request_size);\n\tif (ret < 0)\n\t\tgoto error_do_abort;\n\n\tif (call->send_pages) {\n\t\tret = afs_send_pages(call, &msg, iov);\n\t\tif (ret < 0)\n\t\t\tgoto error_do_abort;\n\t}\n\n\t/* at this point, an async call may no longer exist as it may have\n\t * already completed */\n\treturn wait_mode->wait(call);\n\nerror_do_abort:\n\trxrpc_kernel_abort_call(rxcall, RX_USER_ABORT);\n\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\tafs_free_skb(skb);\nerror_kill_call:\n\tafs_end_call(call);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct socket *afs_socket;",
            "static atomic_t afs_outstanding_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);",
            "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
            "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic struct socket *afs_socket;\nstatic atomic_t afs_outstanding_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\n\nint afs_make_call(struct in_addr *addr, struct afs_call *call, gfp_t gfp,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct sockaddr_rxrpc srx;\n\tstruct rxrpc_call *rxcall;\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tint ret;\n\tstruct sk_buff *skb;\n\n\t_enter(\"%x,{%d},\", addr->s_addr, ntohs(call->port));\n\n\tASSERT(call->type != NULL);\n\tASSERT(call->type->name != NULL);\n\n\t_debug(\"____MAKE %p{%s,%x} [%d]____\",\n\t       call, call->type->name, key_serial(call->key),\n\t       atomic_read(&afs_outstanding_calls));\n\n\tcall->wait_mode = wait_mode;\n\tcall->async_workfn = afs_process_async_call;\n\tINIT_WORK(&call->async_work, afs_async_workfn);\n\n\tmemset(&srx, 0, sizeof(srx));\n\tsrx.srx_family = AF_RXRPC;\n\tsrx.srx_service = call->service_id;\n\tsrx.transport_type = SOCK_DGRAM;\n\tsrx.transport_len = sizeof(srx.transport.sin);\n\tsrx.transport.sin.sin_family = AF_INET;\n\tsrx.transport.sin.sin_port = call->port;\n\tmemcpy(&srx.transport.sin.sin_addr, addr, 4);\n\n\t/* create a call */\n\trxcall = rxrpc_kernel_begin_call(afs_socket, &srx, call->key,\n\t\t\t\t\t (unsigned long) call, gfp);\n\tcall->key = NULL;\n\tif (IS_ERR(rxcall)) {\n\t\tret = PTR_ERR(rxcall);\n\t\tgoto error_kill_call;\n\t}\n\n\tcall->rxcall = rxcall;\n\n\t/* send the request */\n\tiov[0].iov_base\t= call->request;\n\tiov[0].iov_len\t= call->request_size;\n\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1,\n\t\t      call->request_size);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= (call->send_pages ? MSG_MORE : 0);\n\n\t/* have to change the state *before* sending the last packet as RxRPC\n\t * might give us the reply before it returns from sending the\n\t * request */\n\tif (!call->send_pages)\n\t\tcall->state = AFS_CALL_AWAIT_REPLY;\n\tret = rxrpc_kernel_send_data(rxcall, &msg, call->request_size);\n\tif (ret < 0)\n\t\tgoto error_do_abort;\n\n\tif (call->send_pages) {\n\t\tret = afs_send_pages(call, &msg, iov);\n\t\tif (ret < 0)\n\t\t\tgoto error_do_abort;\n\t}\n\n\t/* at this point, an async call may no longer exist as it may have\n\t * already completed */\n\treturn wait_mode->wait(call);\n\nerror_do_abort:\n\trxrpc_kernel_abort_call(rxcall, RX_USER_ABORT);\n\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\tafs_free_skb(skb);\nerror_kill_call:\n\tafs_end_call(call);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "S_IRWXUGO"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "AFS_SET_MODE"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bp",
            "0",
            "c_padsz"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bp",
            "contents",
            "c_namesz"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "c_namesz"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bp",
            "0",
            "padsz"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bp",
            "name",
            "namesz"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "namesz"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "vnode->fid.unique"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "vnode->fid.vnode"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "vnode->fid.vid"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "FSSYMLINK"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "AFS_FS_PORT"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_alloc_flat_call",
          "args": [
            "&afs_RXFSSymlink",
            "reqsz",
            "(3 + 21 + 21 + 6) * 4"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "afs_alloc_flat_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "218-255",
          "snippet": "struct afs_call *afs_alloc_flat_call(const struct afs_call_type *type,\n\t\t\t\t     size_t request_size, size_t reply_size)\n{\n\tstruct afs_call *call;\n\n\tcall = kzalloc(sizeof(*call), GFP_NOFS);\n\tif (!call)\n\t\tgoto nomem_call;\n\n\t_debug(\"CALL %p{%s} [%d]\",\n\t       call, type->name, atomic_read(&afs_outstanding_calls));\n\tatomic_inc(&afs_outstanding_calls);\n\n\tcall->type = type;\n\tcall->request_size = request_size;\n\tcall->reply_max = reply_size;\n\n\tif (request_size) {\n\t\tcall->request = kmalloc(request_size, GFP_NOFS);\n\t\tif (!call->request)\n\t\t\tgoto nomem_free;\n\t}\n\n\tif (reply_size) {\n\t\tcall->buffer = kmalloc(reply_size, GFP_NOFS);\n\t\tif (!call->buffer)\n\t\t\tgoto nomem_free;\n\t}\n\n\tinit_waitqueue_head(&call->waitq);\n\tskb_queue_head_init(&call->rx_queue);\n\treturn call;\n\nnomem_free:\n\tafs_free_call(call);\nnomem_call:\n\treturn NULL;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t afs_outstanding_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic atomic_t afs_outstanding_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nstruct afs_call *afs_alloc_flat_call(const struct afs_call_type *type,\n\t\t\t\t     size_t request_size, size_t reply_size)\n{\n\tstruct afs_call *call;\n\n\tcall = kzalloc(sizeof(*call), GFP_NOFS);\n\tif (!call)\n\t\tgoto nomem_call;\n\n\t_debug(\"CALL %p{%s} [%d]\",\n\t       call, type->name, atomic_read(&afs_outstanding_calls));\n\tatomic_inc(&afs_outstanding_calls);\n\n\tcall->type = type;\n\tcall->request_size = request_size;\n\tcall->reply_max = reply_size;\n\n\tif (request_size) {\n\t\tcall->request = kmalloc(request_size, GFP_NOFS);\n\t\tif (!call->request)\n\t\t\tgoto nomem_free;\n\t}\n\n\tif (reply_size) {\n\t\tcall->buffer = kmalloc(reply_size, GFP_NOFS);\n\t\tif (!call->buffer)\n\t\t\tgoto nomem_free;\n\t}\n\n\tinit_waitqueue_head(&call->waitq);\n\tskb_queue_head_init(&call->rx_queue);\n\treturn call;\n\nnomem_free:\n\tafs_free_call(call);\nnomem_call:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "contents"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic const struct afs_call_type afs_RXFSSymlink = {\n\t.name\t\t= \"FS.Symlink\",\n\t.deliver\t= afs_deliver_fs_symlink,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\nint afs_fs_symlink(struct afs_server *server,\n\t\t   struct key *key,\n\t\t   struct afs_vnode *vnode,\n\t\t   const char *name,\n\t\t   const char *contents,\n\t\t   struct afs_fid *newfid,\n\t\t   struct afs_file_status *newstatus,\n\t\t   const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\tsize_t namesz, reqsz, padsz, c_namesz, c_padsz;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tnamesz = strlen(name);\n\tpadsz = (4 - (namesz & 3)) & 3;\n\n\tc_namesz = strlen(contents);\n\tc_padsz = (4 - (c_namesz & 3)) & 3;\n\n\treqsz = (6 * 4) + namesz + padsz + c_namesz + c_padsz + (6 * 4);\n\n\tcall = afs_alloc_flat_call(&afs_RXFSSymlink, reqsz,\n\t\t\t\t   (3 + 21 + 21 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->reply2 = newfid;\n\tcall->reply3 = newstatus;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(FSSYMLINK);\n\t*bp++ = htonl(vnode->fid.vid);\n\t*bp++ = htonl(vnode->fid.vnode);\n\t*bp++ = htonl(vnode->fid.unique);\n\t*bp++ = htonl(namesz);\n\tmemcpy(bp, name, namesz);\n\tbp = (void *) bp + namesz;\n\tif (padsz > 0) {\n\t\tmemset(bp, 0, padsz);\n\t\tbp = (void *) bp + padsz;\n\t}\n\t*bp++ = htonl(c_namesz);\n\tmemcpy(bp, contents, c_namesz);\n\tbp = (void *) bp + c_namesz;\n\tif (c_padsz > 0) {\n\t\tmemset(bp, 0, c_padsz);\n\t\tbp = (void *) bp + c_padsz;\n\t}\n\t*bp++ = htonl(AFS_SET_MODE);\n\t*bp++ = 0; /* mtime */\n\t*bp++ = 0; /* owner */\n\t*bp++ = 0; /* group */\n\t*bp++ = htonl(S_IRWXUGO); /* unix mode */\n\t*bp++ = 0; /* segment size */\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}"
  },
  {
    "function_name": "afs_deliver_fs_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
    "lines": "890-914",
    "snippet": "static int afs_deliver_fs_symlink(struct afs_call *call,\n\t\t\t\t  struct sk_buff *skb, bool last)\n{\n\tstruct afs_vnode *vnode = call->reply;\n\tconst __be32 *bp;\n\n\t_enter(\"{%u},{%u},%d\", call->unmarshall, skb->len, last);\n\n\tafs_transfer_reply(call, skb);\n\tif (!last)\n\t\treturn 0;\n\n\tif (call->reply_size != call->reply_max)\n\t\treturn -EBADMSG;\n\n\t/* unmarshall the reply once we've received all of it */\n\tbp = call->buffer;\n\txdr_decode_AFSFid(&bp, call->reply2);\n\txdr_decode_AFSFetchStatus(&bp, call->reply3, NULL, NULL);\n\txdr_decode_AFSFetchStatus(&bp, &vnode->status, vnode, NULL);\n\t/* xdr_decode_AFSVolSync(&bp, call->replyX); */\n\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}",
    "includes": [
      "#include \"afs_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/circ_buf.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = 0 [done]\""
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_decode_AFSFetchStatus",
          "args": [
            "&bp",
            "&vnode->status",
            "vnode",
            "NULL"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "xdr_decode_AFSFetchStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
          "lines": "35-130",
          "snippet": "static void xdr_decode_AFSFetchStatus(const __be32 **_bp,\n\t\t\t\t      struct afs_file_status *status,\n\t\t\t\t      struct afs_vnode *vnode,\n\t\t\t\t      afs_dataversion_t *store_version)\n{\n\tafs_dataversion_t expected_version;\n\tconst __be32 *bp = *_bp;\n\tumode_t mode;\n\tu64 data_version, size;\n\tu32 changed = 0; /* becomes non-zero if ctime-type changes seen */\n\tkuid_t owner;\n\tkgid_t group;\n\n#define EXTRACT(DST)\t\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tu32 x = ntohl(*bp++);\t\t\\\n\t\tchanged |= DST - x;\t\t\\\n\t\tDST = x;\t\t\t\\\n\t} while (0)\n\n\tstatus->if_version = ntohl(*bp++);\n\tEXTRACT(status->type);\n\tEXTRACT(status->nlink);\n\tsize = ntohl(*bp++);\n\tdata_version = ntohl(*bp++);\n\tEXTRACT(status->author);\n\towner = make_kuid(&init_user_ns, ntohl(*bp++));\n\tchanged |= !uid_eq(owner, status->owner);\n\tstatus->owner = owner;\n\tEXTRACT(status->caller_access); /* call ticket dependent */\n\tEXTRACT(status->anon_access);\n\tEXTRACT(status->mode);\n\tEXTRACT(status->parent.vnode);\n\tEXTRACT(status->parent.unique);\n\tbp++; /* seg size */\n\tstatus->mtime_client = ntohl(*bp++);\n\tstatus->mtime_server = ntohl(*bp++);\n\tgroup = make_kgid(&init_user_ns, ntohl(*bp++));\n\tchanged |= !gid_eq(group, status->group);\n\tstatus->group = group;\n\tbp++; /* sync counter */\n\tdata_version |= (u64) ntohl(*bp++) << 32;\n\tEXTRACT(status->lock_count);\n\tsize |= (u64) ntohl(*bp++) << 32;\n\tbp++; /* spare 4 */\n\t*_bp = bp;\n\n\tif (size != status->size) {\n\t\tstatus->size = size;\n\t\tchanged |= true;\n\t}\n\tstatus->mode &= S_IALLUGO;\n\n\t_debug(\"vnode time %lx, %lx\",\n\t       status->mtime_client, status->mtime_server);\n\n\tif (vnode) {\n\t\tstatus->parent.vid = vnode->fid.vid;\n\t\tif (changed && !test_bit(AFS_VNODE_UNSET, &vnode->flags)) {\n\t\t\t_debug(\"vnode changed\");\n\t\t\ti_size_write(&vnode->vfs_inode, size);\n\t\t\tvnode->vfs_inode.i_uid = status->owner;\n\t\t\tvnode->vfs_inode.i_gid = status->group;\n\t\t\tvnode->vfs_inode.i_generation = vnode->fid.unique;\n\t\t\tset_nlink(&vnode->vfs_inode, status->nlink);\n\n\t\t\tmode = vnode->vfs_inode.i_mode;\n\t\t\tmode &= ~S_IALLUGO;\n\t\t\tmode |= status->mode;\n\t\t\tbarrier();\n\t\t\tvnode->vfs_inode.i_mode = mode;\n\t\t}\n\n\t\tvnode->vfs_inode.i_ctime.tv_sec\t= status->mtime_server;\n\t\tvnode->vfs_inode.i_mtime\t= vnode->vfs_inode.i_ctime;\n\t\tvnode->vfs_inode.i_atime\t= vnode->vfs_inode.i_ctime;\n\t\tvnode->vfs_inode.i_version\t= data_version;\n\t}\n\n\texpected_version = status->data_version;\n\tif (store_version)\n\t\texpected_version = *store_version;\n\n\tif (expected_version != data_version) {\n\t\tstatus->data_version = data_version;\n\t\tif (vnode && !test_bit(AFS_VNODE_UNSET, &vnode->flags)) {\n\t\t\t_debug(\"vnode modified %llx on {%x:%u}\",\n\t\t\t       (unsigned long long) data_version,\n\t\t\t       vnode->fid.vid, vnode->fid.vnode);\n\t\t\tset_bit(AFS_VNODE_MODIFIED, &vnode->flags);\n\t\t\tset_bit(AFS_VNODE_ZAP_DATA, &vnode->flags);\n\t\t}\n\t} else if (store_version) {\n\t\tstatus->data_version = data_version;\n\t}\n}",
          "includes": [
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic void xdr_decode_AFSFetchStatus(const __be32 **_bp,\n\t\t\t\t      struct afs_file_status *status,\n\t\t\t\t      struct afs_vnode *vnode,\n\t\t\t\t      afs_dataversion_t *store_version)\n{\n\tafs_dataversion_t expected_version;\n\tconst __be32 *bp = *_bp;\n\tumode_t mode;\n\tu64 data_version, size;\n\tu32 changed = 0; /* becomes non-zero if ctime-type changes seen */\n\tkuid_t owner;\n\tkgid_t group;\n\n#define EXTRACT(DST)\t\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tu32 x = ntohl(*bp++);\t\t\\\n\t\tchanged |= DST - x;\t\t\\\n\t\tDST = x;\t\t\t\\\n\t} while (0)\n\n\tstatus->if_version = ntohl(*bp++);\n\tEXTRACT(status->type);\n\tEXTRACT(status->nlink);\n\tsize = ntohl(*bp++);\n\tdata_version = ntohl(*bp++);\n\tEXTRACT(status->author);\n\towner = make_kuid(&init_user_ns, ntohl(*bp++));\n\tchanged |= !uid_eq(owner, status->owner);\n\tstatus->owner = owner;\n\tEXTRACT(status->caller_access); /* call ticket dependent */\n\tEXTRACT(status->anon_access);\n\tEXTRACT(status->mode);\n\tEXTRACT(status->parent.vnode);\n\tEXTRACT(status->parent.unique);\n\tbp++; /* seg size */\n\tstatus->mtime_client = ntohl(*bp++);\n\tstatus->mtime_server = ntohl(*bp++);\n\tgroup = make_kgid(&init_user_ns, ntohl(*bp++));\n\tchanged |= !gid_eq(group, status->group);\n\tstatus->group = group;\n\tbp++; /* sync counter */\n\tdata_version |= (u64) ntohl(*bp++) << 32;\n\tEXTRACT(status->lock_count);\n\tsize |= (u64) ntohl(*bp++) << 32;\n\tbp++; /* spare 4 */\n\t*_bp = bp;\n\n\tif (size != status->size) {\n\t\tstatus->size = size;\n\t\tchanged |= true;\n\t}\n\tstatus->mode &= S_IALLUGO;\n\n\t_debug(\"vnode time %lx, %lx\",\n\t       status->mtime_client, status->mtime_server);\n\n\tif (vnode) {\n\t\tstatus->parent.vid = vnode->fid.vid;\n\t\tif (changed && !test_bit(AFS_VNODE_UNSET, &vnode->flags)) {\n\t\t\t_debug(\"vnode changed\");\n\t\t\ti_size_write(&vnode->vfs_inode, size);\n\t\t\tvnode->vfs_inode.i_uid = status->owner;\n\t\t\tvnode->vfs_inode.i_gid = status->group;\n\t\t\tvnode->vfs_inode.i_generation = vnode->fid.unique;\n\t\t\tset_nlink(&vnode->vfs_inode, status->nlink);\n\n\t\t\tmode = vnode->vfs_inode.i_mode;\n\t\t\tmode &= ~S_IALLUGO;\n\t\t\tmode |= status->mode;\n\t\t\tbarrier();\n\t\t\tvnode->vfs_inode.i_mode = mode;\n\t\t}\n\n\t\tvnode->vfs_inode.i_ctime.tv_sec\t= status->mtime_server;\n\t\tvnode->vfs_inode.i_mtime\t= vnode->vfs_inode.i_ctime;\n\t\tvnode->vfs_inode.i_atime\t= vnode->vfs_inode.i_ctime;\n\t\tvnode->vfs_inode.i_version\t= data_version;\n\t}\n\n\texpected_version = status->data_version;\n\tif (store_version)\n\t\texpected_version = *store_version;\n\n\tif (expected_version != data_version) {\n\t\tstatus->data_version = data_version;\n\t\tif (vnode && !test_bit(AFS_VNODE_UNSET, &vnode->flags)) {\n\t\t\t_debug(\"vnode modified %llx on {%x:%u}\",\n\t\t\t       (unsigned long long) data_version,\n\t\t\t       vnode->fid.vid, vnode->fid.vnode);\n\t\t\tset_bit(AFS_VNODE_MODIFIED, &vnode->flags);\n\t\t\tset_bit(AFS_VNODE_ZAP_DATA, &vnode->flags);\n\t\t}\n\t} else if (store_version) {\n\t\tstatus->data_version = data_version;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_decode_AFSFid",
          "args": [
            "&bp",
            "call->reply2"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "xdr_decode_AFSFid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
          "lines": "22-30",
          "snippet": "static void xdr_decode_AFSFid(const __be32 **_bp, struct afs_fid *fid)\n{\n\tconst __be32 *bp = *_bp;\n\n\tfid->vid\t\t= ntohl(*bp++);\n\tfid->vnode\t\t= ntohl(*bp++);\n\tfid->unique\t\t= ntohl(*bp++);\n\t*_bp = bp;\n}",
          "includes": [
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic void xdr_decode_AFSFid(const __be32 **_bp, struct afs_fid *fid)\n{\n\tconst __be32 *bp = *_bp;\n\n\tfid->vid\t\t= ntohl(*bp++);\n\tfid->vnode\t\t= ntohl(*bp++);\n\tfid->unique\t\t= ntohl(*bp++);\n\t*_bp = bp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_transfer_reply",
          "args": [
            "call",
            "skb"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "afs_transfer_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "668-675",
          "snippet": "void afs_transfer_reply(struct afs_call *call, struct sk_buff *skb)\n{\n\tsize_t len = skb->len;\n\n\tif (skb_copy_bits(skb, 0, call->buffer + call->reply_size, len) < 0)\n\t\tBUG();\n\tcall->reply_size += len;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);",
            "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
            "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\n\nvoid afs_transfer_reply(struct afs_call *call, struct sk_buff *skb)\n{\n\tsize_t len = skb->len;\n\n\tif (skb_copy_bits(skb, 0, call->buffer + call->reply_size, len) < 0)\n\t\tBUG();\n\tcall->reply_size += len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%u},{%u},%d\"",
            "call->unmarshall",
            "skb->len",
            "last"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic int afs_deliver_fs_symlink(struct afs_call *call,\n\t\t\t\t  struct sk_buff *skb, bool last)\n{\n\tstruct afs_vnode *vnode = call->reply;\n\tconst __be32 *bp;\n\n\t_enter(\"{%u},{%u},%d\", call->unmarshall, skb->len, last);\n\n\tafs_transfer_reply(call, skb);\n\tif (!last)\n\t\treturn 0;\n\n\tif (call->reply_size != call->reply_max)\n\t\treturn -EBADMSG;\n\n\t/* unmarshall the reply once we've received all of it */\n\tbp = call->buffer;\n\txdr_decode_AFSFid(&bp, call->reply2);\n\txdr_decode_AFSFetchStatus(&bp, call->reply3, NULL, NULL);\n\txdr_decode_AFSFetchStatus(&bp, &vnode->status, vnode, NULL);\n\t/* xdr_decode_AFSVolSync(&bp, call->replyX); */\n\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}"
  },
  {
    "function_name": "afs_fs_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
    "lines": "840-885",
    "snippet": "int afs_fs_link(struct afs_server *server,\n\t\tstruct key *key,\n\t\tstruct afs_vnode *dvnode,\n\t\tstruct afs_vnode *vnode,\n\t\tconst char *name,\n\t\tconst struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\tsize_t namesz, reqsz, padsz;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tnamesz = strlen(name);\n\tpadsz = (4 - (namesz & 3)) & 3;\n\treqsz = (5 * 4) + namesz + padsz + (3 * 4);\n\n\tcall = afs_alloc_flat_call(&afs_RXFSLink, reqsz, (21 + 21 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = dvnode;\n\tcall->reply2 = vnode;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(FSLINK);\n\t*bp++ = htonl(dvnode->fid.vid);\n\t*bp++ = htonl(dvnode->fid.vnode);\n\t*bp++ = htonl(dvnode->fid.unique);\n\t*bp++ = htonl(namesz);\n\tmemcpy(bp, name, namesz);\n\tbp = (void *) bp + namesz;\n\tif (padsz > 0) {\n\t\tmemset(bp, 0, padsz);\n\t\tbp = (void *) bp + padsz;\n\t}\n\t*bp++ = htonl(vnode->fid.vid);\n\t*bp++ = htonl(vnode->fid.vnode);\n\t*bp++ = htonl(vnode->fid.unique);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}",
    "includes": [
      "#include \"afs_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/circ_buf.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct afs_call_type afs_RXFSLink = {\n\t.name\t\t= \"FS.Link\",\n\t.deliver\t= afs_deliver_fs_link,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "afs_make_call",
          "args": [
            "&server->addr",
            "call",
            "GFP_NOFS",
            "wait_mode"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "afs_make_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "338-420",
          "snippet": "int afs_make_call(struct in_addr *addr, struct afs_call *call, gfp_t gfp,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct sockaddr_rxrpc srx;\n\tstruct rxrpc_call *rxcall;\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tint ret;\n\tstruct sk_buff *skb;\n\n\t_enter(\"%x,{%d},\", addr->s_addr, ntohs(call->port));\n\n\tASSERT(call->type != NULL);\n\tASSERT(call->type->name != NULL);\n\n\t_debug(\"____MAKE %p{%s,%x} [%d]____\",\n\t       call, call->type->name, key_serial(call->key),\n\t       atomic_read(&afs_outstanding_calls));\n\n\tcall->wait_mode = wait_mode;\n\tcall->async_workfn = afs_process_async_call;\n\tINIT_WORK(&call->async_work, afs_async_workfn);\n\n\tmemset(&srx, 0, sizeof(srx));\n\tsrx.srx_family = AF_RXRPC;\n\tsrx.srx_service = call->service_id;\n\tsrx.transport_type = SOCK_DGRAM;\n\tsrx.transport_len = sizeof(srx.transport.sin);\n\tsrx.transport.sin.sin_family = AF_INET;\n\tsrx.transport.sin.sin_port = call->port;\n\tmemcpy(&srx.transport.sin.sin_addr, addr, 4);\n\n\t/* create a call */\n\trxcall = rxrpc_kernel_begin_call(afs_socket, &srx, call->key,\n\t\t\t\t\t (unsigned long) call, gfp);\n\tcall->key = NULL;\n\tif (IS_ERR(rxcall)) {\n\t\tret = PTR_ERR(rxcall);\n\t\tgoto error_kill_call;\n\t}\n\n\tcall->rxcall = rxcall;\n\n\t/* send the request */\n\tiov[0].iov_base\t= call->request;\n\tiov[0].iov_len\t= call->request_size;\n\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1,\n\t\t      call->request_size);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= (call->send_pages ? MSG_MORE : 0);\n\n\t/* have to change the state *before* sending the last packet as RxRPC\n\t * might give us the reply before it returns from sending the\n\t * request */\n\tif (!call->send_pages)\n\t\tcall->state = AFS_CALL_AWAIT_REPLY;\n\tret = rxrpc_kernel_send_data(rxcall, &msg, call->request_size);\n\tif (ret < 0)\n\t\tgoto error_do_abort;\n\n\tif (call->send_pages) {\n\t\tret = afs_send_pages(call, &msg, iov);\n\t\tif (ret < 0)\n\t\t\tgoto error_do_abort;\n\t}\n\n\t/* at this point, an async call may no longer exist as it may have\n\t * already completed */\n\treturn wait_mode->wait(call);\n\nerror_do_abort:\n\trxrpc_kernel_abort_call(rxcall, RX_USER_ABORT);\n\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\tafs_free_skb(skb);\nerror_kill_call:\n\tafs_end_call(call);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct socket *afs_socket;",
            "static atomic_t afs_outstanding_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);",
            "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
            "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic struct socket *afs_socket;\nstatic atomic_t afs_outstanding_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\n\nint afs_make_call(struct in_addr *addr, struct afs_call *call, gfp_t gfp,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct sockaddr_rxrpc srx;\n\tstruct rxrpc_call *rxcall;\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tint ret;\n\tstruct sk_buff *skb;\n\n\t_enter(\"%x,{%d},\", addr->s_addr, ntohs(call->port));\n\n\tASSERT(call->type != NULL);\n\tASSERT(call->type->name != NULL);\n\n\t_debug(\"____MAKE %p{%s,%x} [%d]____\",\n\t       call, call->type->name, key_serial(call->key),\n\t       atomic_read(&afs_outstanding_calls));\n\n\tcall->wait_mode = wait_mode;\n\tcall->async_workfn = afs_process_async_call;\n\tINIT_WORK(&call->async_work, afs_async_workfn);\n\n\tmemset(&srx, 0, sizeof(srx));\n\tsrx.srx_family = AF_RXRPC;\n\tsrx.srx_service = call->service_id;\n\tsrx.transport_type = SOCK_DGRAM;\n\tsrx.transport_len = sizeof(srx.transport.sin);\n\tsrx.transport.sin.sin_family = AF_INET;\n\tsrx.transport.sin.sin_port = call->port;\n\tmemcpy(&srx.transport.sin.sin_addr, addr, 4);\n\n\t/* create a call */\n\trxcall = rxrpc_kernel_begin_call(afs_socket, &srx, call->key,\n\t\t\t\t\t (unsigned long) call, gfp);\n\tcall->key = NULL;\n\tif (IS_ERR(rxcall)) {\n\t\tret = PTR_ERR(rxcall);\n\t\tgoto error_kill_call;\n\t}\n\n\tcall->rxcall = rxcall;\n\n\t/* send the request */\n\tiov[0].iov_base\t= call->request;\n\tiov[0].iov_len\t= call->request_size;\n\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1,\n\t\t      call->request_size);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= (call->send_pages ? MSG_MORE : 0);\n\n\t/* have to change the state *before* sending the last packet as RxRPC\n\t * might give us the reply before it returns from sending the\n\t * request */\n\tif (!call->send_pages)\n\t\tcall->state = AFS_CALL_AWAIT_REPLY;\n\tret = rxrpc_kernel_send_data(rxcall, &msg, call->request_size);\n\tif (ret < 0)\n\t\tgoto error_do_abort;\n\n\tif (call->send_pages) {\n\t\tret = afs_send_pages(call, &msg, iov);\n\t\tif (ret < 0)\n\t\t\tgoto error_do_abort;\n\t}\n\n\t/* at this point, an async call may no longer exist as it may have\n\t * already completed */\n\treturn wait_mode->wait(call);\n\nerror_do_abort:\n\trxrpc_kernel_abort_call(rxcall, RX_USER_ABORT);\n\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\tafs_free_skb(skb);\nerror_kill_call:\n\tafs_end_call(call);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "vnode->fid.unique"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "vnode->fid.vnode"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "vnode->fid.vid"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bp",
            "0",
            "padsz"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bp",
            "name",
            "namesz"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "namesz"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "dvnode->fid.unique"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "dvnode->fid.vnode"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "dvnode->fid.vid"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "FSLINK"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "AFS_FS_PORT"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_alloc_flat_call",
          "args": [
            "&afs_RXFSLink",
            "reqsz",
            "(21 + 21 + 6) * 4"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "afs_alloc_flat_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "218-255",
          "snippet": "struct afs_call *afs_alloc_flat_call(const struct afs_call_type *type,\n\t\t\t\t     size_t request_size, size_t reply_size)\n{\n\tstruct afs_call *call;\n\n\tcall = kzalloc(sizeof(*call), GFP_NOFS);\n\tif (!call)\n\t\tgoto nomem_call;\n\n\t_debug(\"CALL %p{%s} [%d]\",\n\t       call, type->name, atomic_read(&afs_outstanding_calls));\n\tatomic_inc(&afs_outstanding_calls);\n\n\tcall->type = type;\n\tcall->request_size = request_size;\n\tcall->reply_max = reply_size;\n\n\tif (request_size) {\n\t\tcall->request = kmalloc(request_size, GFP_NOFS);\n\t\tif (!call->request)\n\t\t\tgoto nomem_free;\n\t}\n\n\tif (reply_size) {\n\t\tcall->buffer = kmalloc(reply_size, GFP_NOFS);\n\t\tif (!call->buffer)\n\t\t\tgoto nomem_free;\n\t}\n\n\tinit_waitqueue_head(&call->waitq);\n\tskb_queue_head_init(&call->rx_queue);\n\treturn call;\n\nnomem_free:\n\tafs_free_call(call);\nnomem_call:\n\treturn NULL;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t afs_outstanding_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic atomic_t afs_outstanding_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nstruct afs_call *afs_alloc_flat_call(const struct afs_call_type *type,\n\t\t\t\t     size_t request_size, size_t reply_size)\n{\n\tstruct afs_call *call;\n\n\tcall = kzalloc(sizeof(*call), GFP_NOFS);\n\tif (!call)\n\t\tgoto nomem_call;\n\n\t_debug(\"CALL %p{%s} [%d]\",\n\t       call, type->name, atomic_read(&afs_outstanding_calls));\n\tatomic_inc(&afs_outstanding_calls);\n\n\tcall->type = type;\n\tcall->request_size = request_size;\n\tcall->reply_max = reply_size;\n\n\tif (request_size) {\n\t\tcall->request = kmalloc(request_size, GFP_NOFS);\n\t\tif (!call->request)\n\t\t\tgoto nomem_free;\n\t}\n\n\tif (reply_size) {\n\t\tcall->buffer = kmalloc(reply_size, GFP_NOFS);\n\t\tif (!call->buffer)\n\t\t\tgoto nomem_free;\n\t}\n\n\tinit_waitqueue_head(&call->waitq);\n\tskb_queue_head_init(&call->rx_queue);\n\treturn call;\n\nnomem_free:\n\tafs_free_call(call);\nnomem_call:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic const struct afs_call_type afs_RXFSLink = {\n\t.name\t\t= \"FS.Link\",\n\t.deliver\t= afs_deliver_fs_link,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\nint afs_fs_link(struct afs_server *server,\n\t\tstruct key *key,\n\t\tstruct afs_vnode *dvnode,\n\t\tstruct afs_vnode *vnode,\n\t\tconst char *name,\n\t\tconst struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\tsize_t namesz, reqsz, padsz;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tnamesz = strlen(name);\n\tpadsz = (4 - (namesz & 3)) & 3;\n\treqsz = (5 * 4) + namesz + padsz + (3 * 4);\n\n\tcall = afs_alloc_flat_call(&afs_RXFSLink, reqsz, (21 + 21 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = dvnode;\n\tcall->reply2 = vnode;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(FSLINK);\n\t*bp++ = htonl(dvnode->fid.vid);\n\t*bp++ = htonl(dvnode->fid.vnode);\n\t*bp++ = htonl(dvnode->fid.unique);\n\t*bp++ = htonl(namesz);\n\tmemcpy(bp, name, namesz);\n\tbp = (void *) bp + namesz;\n\tif (padsz > 0) {\n\t\tmemset(bp, 0, padsz);\n\t\tbp = (void *) bp + padsz;\n\t}\n\t*bp++ = htonl(vnode->fid.vid);\n\t*bp++ = htonl(vnode->fid.vnode);\n\t*bp++ = htonl(vnode->fid.unique);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}"
  },
  {
    "function_name": "afs_deliver_fs_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
    "lines": "802-825",
    "snippet": "static int afs_deliver_fs_link(struct afs_call *call,\n\t\t\t       struct sk_buff *skb, bool last)\n{\n\tstruct afs_vnode *dvnode = call->reply, *vnode = call->reply2;\n\tconst __be32 *bp;\n\n\t_enter(\"{%u},{%u},%d\", call->unmarshall, skb->len, last);\n\n\tafs_transfer_reply(call, skb);\n\tif (!last)\n\t\treturn 0;\n\n\tif (call->reply_size != call->reply_max)\n\t\treturn -EBADMSG;\n\n\t/* unmarshall the reply once we've received all of it */\n\tbp = call->buffer;\n\txdr_decode_AFSFetchStatus(&bp, &vnode->status, vnode, NULL);\n\txdr_decode_AFSFetchStatus(&bp, &dvnode->status, dvnode, NULL);\n\t/* xdr_decode_AFSVolSync(&bp, call->replyX); */\n\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}",
    "includes": [
      "#include \"afs_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/circ_buf.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = 0 [done]\""
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_decode_AFSFetchStatus",
          "args": [
            "&bp",
            "&dvnode->status",
            "dvnode",
            "NULL"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "xdr_decode_AFSFetchStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
          "lines": "35-130",
          "snippet": "static void xdr_decode_AFSFetchStatus(const __be32 **_bp,\n\t\t\t\t      struct afs_file_status *status,\n\t\t\t\t      struct afs_vnode *vnode,\n\t\t\t\t      afs_dataversion_t *store_version)\n{\n\tafs_dataversion_t expected_version;\n\tconst __be32 *bp = *_bp;\n\tumode_t mode;\n\tu64 data_version, size;\n\tu32 changed = 0; /* becomes non-zero if ctime-type changes seen */\n\tkuid_t owner;\n\tkgid_t group;\n\n#define EXTRACT(DST)\t\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tu32 x = ntohl(*bp++);\t\t\\\n\t\tchanged |= DST - x;\t\t\\\n\t\tDST = x;\t\t\t\\\n\t} while (0)\n\n\tstatus->if_version = ntohl(*bp++);\n\tEXTRACT(status->type);\n\tEXTRACT(status->nlink);\n\tsize = ntohl(*bp++);\n\tdata_version = ntohl(*bp++);\n\tEXTRACT(status->author);\n\towner = make_kuid(&init_user_ns, ntohl(*bp++));\n\tchanged |= !uid_eq(owner, status->owner);\n\tstatus->owner = owner;\n\tEXTRACT(status->caller_access); /* call ticket dependent */\n\tEXTRACT(status->anon_access);\n\tEXTRACT(status->mode);\n\tEXTRACT(status->parent.vnode);\n\tEXTRACT(status->parent.unique);\n\tbp++; /* seg size */\n\tstatus->mtime_client = ntohl(*bp++);\n\tstatus->mtime_server = ntohl(*bp++);\n\tgroup = make_kgid(&init_user_ns, ntohl(*bp++));\n\tchanged |= !gid_eq(group, status->group);\n\tstatus->group = group;\n\tbp++; /* sync counter */\n\tdata_version |= (u64) ntohl(*bp++) << 32;\n\tEXTRACT(status->lock_count);\n\tsize |= (u64) ntohl(*bp++) << 32;\n\tbp++; /* spare 4 */\n\t*_bp = bp;\n\n\tif (size != status->size) {\n\t\tstatus->size = size;\n\t\tchanged |= true;\n\t}\n\tstatus->mode &= S_IALLUGO;\n\n\t_debug(\"vnode time %lx, %lx\",\n\t       status->mtime_client, status->mtime_server);\n\n\tif (vnode) {\n\t\tstatus->parent.vid = vnode->fid.vid;\n\t\tif (changed && !test_bit(AFS_VNODE_UNSET, &vnode->flags)) {\n\t\t\t_debug(\"vnode changed\");\n\t\t\ti_size_write(&vnode->vfs_inode, size);\n\t\t\tvnode->vfs_inode.i_uid = status->owner;\n\t\t\tvnode->vfs_inode.i_gid = status->group;\n\t\t\tvnode->vfs_inode.i_generation = vnode->fid.unique;\n\t\t\tset_nlink(&vnode->vfs_inode, status->nlink);\n\n\t\t\tmode = vnode->vfs_inode.i_mode;\n\t\t\tmode &= ~S_IALLUGO;\n\t\t\tmode |= status->mode;\n\t\t\tbarrier();\n\t\t\tvnode->vfs_inode.i_mode = mode;\n\t\t}\n\n\t\tvnode->vfs_inode.i_ctime.tv_sec\t= status->mtime_server;\n\t\tvnode->vfs_inode.i_mtime\t= vnode->vfs_inode.i_ctime;\n\t\tvnode->vfs_inode.i_atime\t= vnode->vfs_inode.i_ctime;\n\t\tvnode->vfs_inode.i_version\t= data_version;\n\t}\n\n\texpected_version = status->data_version;\n\tif (store_version)\n\t\texpected_version = *store_version;\n\n\tif (expected_version != data_version) {\n\t\tstatus->data_version = data_version;\n\t\tif (vnode && !test_bit(AFS_VNODE_UNSET, &vnode->flags)) {\n\t\t\t_debug(\"vnode modified %llx on {%x:%u}\",\n\t\t\t       (unsigned long long) data_version,\n\t\t\t       vnode->fid.vid, vnode->fid.vnode);\n\t\t\tset_bit(AFS_VNODE_MODIFIED, &vnode->flags);\n\t\t\tset_bit(AFS_VNODE_ZAP_DATA, &vnode->flags);\n\t\t}\n\t} else if (store_version) {\n\t\tstatus->data_version = data_version;\n\t}\n}",
          "includes": [
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic void xdr_decode_AFSFetchStatus(const __be32 **_bp,\n\t\t\t\t      struct afs_file_status *status,\n\t\t\t\t      struct afs_vnode *vnode,\n\t\t\t\t      afs_dataversion_t *store_version)\n{\n\tafs_dataversion_t expected_version;\n\tconst __be32 *bp = *_bp;\n\tumode_t mode;\n\tu64 data_version, size;\n\tu32 changed = 0; /* becomes non-zero if ctime-type changes seen */\n\tkuid_t owner;\n\tkgid_t group;\n\n#define EXTRACT(DST)\t\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tu32 x = ntohl(*bp++);\t\t\\\n\t\tchanged |= DST - x;\t\t\\\n\t\tDST = x;\t\t\t\\\n\t} while (0)\n\n\tstatus->if_version = ntohl(*bp++);\n\tEXTRACT(status->type);\n\tEXTRACT(status->nlink);\n\tsize = ntohl(*bp++);\n\tdata_version = ntohl(*bp++);\n\tEXTRACT(status->author);\n\towner = make_kuid(&init_user_ns, ntohl(*bp++));\n\tchanged |= !uid_eq(owner, status->owner);\n\tstatus->owner = owner;\n\tEXTRACT(status->caller_access); /* call ticket dependent */\n\tEXTRACT(status->anon_access);\n\tEXTRACT(status->mode);\n\tEXTRACT(status->parent.vnode);\n\tEXTRACT(status->parent.unique);\n\tbp++; /* seg size */\n\tstatus->mtime_client = ntohl(*bp++);\n\tstatus->mtime_server = ntohl(*bp++);\n\tgroup = make_kgid(&init_user_ns, ntohl(*bp++));\n\tchanged |= !gid_eq(group, status->group);\n\tstatus->group = group;\n\tbp++; /* sync counter */\n\tdata_version |= (u64) ntohl(*bp++) << 32;\n\tEXTRACT(status->lock_count);\n\tsize |= (u64) ntohl(*bp++) << 32;\n\tbp++; /* spare 4 */\n\t*_bp = bp;\n\n\tif (size != status->size) {\n\t\tstatus->size = size;\n\t\tchanged |= true;\n\t}\n\tstatus->mode &= S_IALLUGO;\n\n\t_debug(\"vnode time %lx, %lx\",\n\t       status->mtime_client, status->mtime_server);\n\n\tif (vnode) {\n\t\tstatus->parent.vid = vnode->fid.vid;\n\t\tif (changed && !test_bit(AFS_VNODE_UNSET, &vnode->flags)) {\n\t\t\t_debug(\"vnode changed\");\n\t\t\ti_size_write(&vnode->vfs_inode, size);\n\t\t\tvnode->vfs_inode.i_uid = status->owner;\n\t\t\tvnode->vfs_inode.i_gid = status->group;\n\t\t\tvnode->vfs_inode.i_generation = vnode->fid.unique;\n\t\t\tset_nlink(&vnode->vfs_inode, status->nlink);\n\n\t\t\tmode = vnode->vfs_inode.i_mode;\n\t\t\tmode &= ~S_IALLUGO;\n\t\t\tmode |= status->mode;\n\t\t\tbarrier();\n\t\t\tvnode->vfs_inode.i_mode = mode;\n\t\t}\n\n\t\tvnode->vfs_inode.i_ctime.tv_sec\t= status->mtime_server;\n\t\tvnode->vfs_inode.i_mtime\t= vnode->vfs_inode.i_ctime;\n\t\tvnode->vfs_inode.i_atime\t= vnode->vfs_inode.i_ctime;\n\t\tvnode->vfs_inode.i_version\t= data_version;\n\t}\n\n\texpected_version = status->data_version;\n\tif (store_version)\n\t\texpected_version = *store_version;\n\n\tif (expected_version != data_version) {\n\t\tstatus->data_version = data_version;\n\t\tif (vnode && !test_bit(AFS_VNODE_UNSET, &vnode->flags)) {\n\t\t\t_debug(\"vnode modified %llx on {%x:%u}\",\n\t\t\t       (unsigned long long) data_version,\n\t\t\t       vnode->fid.vid, vnode->fid.vnode);\n\t\t\tset_bit(AFS_VNODE_MODIFIED, &vnode->flags);\n\t\t\tset_bit(AFS_VNODE_ZAP_DATA, &vnode->flags);\n\t\t}\n\t} else if (store_version) {\n\t\tstatus->data_version = data_version;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_transfer_reply",
          "args": [
            "call",
            "skb"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "afs_transfer_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "668-675",
          "snippet": "void afs_transfer_reply(struct afs_call *call, struct sk_buff *skb)\n{\n\tsize_t len = skb->len;\n\n\tif (skb_copy_bits(skb, 0, call->buffer + call->reply_size, len) < 0)\n\t\tBUG();\n\tcall->reply_size += len;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);",
            "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
            "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\n\nvoid afs_transfer_reply(struct afs_call *call, struct sk_buff *skb)\n{\n\tsize_t len = skb->len;\n\n\tif (skb_copy_bits(skb, 0, call->buffer + call->reply_size, len) < 0)\n\t\tBUG();\n\tcall->reply_size += len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%u},{%u},%d\"",
            "call->unmarshall",
            "skb->len",
            "last"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic int afs_deliver_fs_link(struct afs_call *call,\n\t\t\t       struct sk_buff *skb, bool last)\n{\n\tstruct afs_vnode *dvnode = call->reply, *vnode = call->reply2;\n\tconst __be32 *bp;\n\n\t_enter(\"{%u},{%u},%d\", call->unmarshall, skb->len, last);\n\n\tafs_transfer_reply(call, skb);\n\tif (!last)\n\t\treturn 0;\n\n\tif (call->reply_size != call->reply_max)\n\t\treturn -EBADMSG;\n\n\t/* unmarshall the reply once we've received all of it */\n\tbp = call->buffer;\n\txdr_decode_AFSFetchStatus(&bp, &vnode->status, vnode, NULL);\n\txdr_decode_AFSFetchStatus(&bp, &dvnode->status, dvnode, NULL);\n\t/* xdr_decode_AFSVolSync(&bp, call->replyX); */\n\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}"
  },
  {
    "function_name": "afs_fs_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
    "lines": "756-797",
    "snippet": "int afs_fs_remove(struct afs_server *server,\n\t\t  struct key *key,\n\t\t  struct afs_vnode *vnode,\n\t\t  const char *name,\n\t\t  bool isdir,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\tsize_t namesz, reqsz, padsz;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tnamesz = strlen(name);\n\tpadsz = (4 - (namesz & 3)) & 3;\n\treqsz = (5 * 4) + namesz + padsz;\n\n\tcall = afs_alloc_flat_call(&afs_RXFSRemoveXXXX, reqsz, (21 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(isdir ? FSREMOVEDIR : FSREMOVEFILE);\n\t*bp++ = htonl(vnode->fid.vid);\n\t*bp++ = htonl(vnode->fid.vnode);\n\t*bp++ = htonl(vnode->fid.unique);\n\t*bp++ = htonl(namesz);\n\tmemcpy(bp, name, namesz);\n\tbp = (void *) bp + namesz;\n\tif (padsz > 0) {\n\t\tmemset(bp, 0, padsz);\n\t\tbp = (void *) bp + padsz;\n\t}\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}",
    "includes": [
      "#include \"afs_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/circ_buf.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct afs_call_type afs_RXFSRemoveXXXX = {\n\t.name\t\t= \"FS.RemoveXXXX\",\n\t.deliver\t= afs_deliver_fs_remove,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "afs_make_call",
          "args": [
            "&server->addr",
            "call",
            "GFP_NOFS",
            "wait_mode"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "afs_make_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "338-420",
          "snippet": "int afs_make_call(struct in_addr *addr, struct afs_call *call, gfp_t gfp,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct sockaddr_rxrpc srx;\n\tstruct rxrpc_call *rxcall;\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tint ret;\n\tstruct sk_buff *skb;\n\n\t_enter(\"%x,{%d},\", addr->s_addr, ntohs(call->port));\n\n\tASSERT(call->type != NULL);\n\tASSERT(call->type->name != NULL);\n\n\t_debug(\"____MAKE %p{%s,%x} [%d]____\",\n\t       call, call->type->name, key_serial(call->key),\n\t       atomic_read(&afs_outstanding_calls));\n\n\tcall->wait_mode = wait_mode;\n\tcall->async_workfn = afs_process_async_call;\n\tINIT_WORK(&call->async_work, afs_async_workfn);\n\n\tmemset(&srx, 0, sizeof(srx));\n\tsrx.srx_family = AF_RXRPC;\n\tsrx.srx_service = call->service_id;\n\tsrx.transport_type = SOCK_DGRAM;\n\tsrx.transport_len = sizeof(srx.transport.sin);\n\tsrx.transport.sin.sin_family = AF_INET;\n\tsrx.transport.sin.sin_port = call->port;\n\tmemcpy(&srx.transport.sin.sin_addr, addr, 4);\n\n\t/* create a call */\n\trxcall = rxrpc_kernel_begin_call(afs_socket, &srx, call->key,\n\t\t\t\t\t (unsigned long) call, gfp);\n\tcall->key = NULL;\n\tif (IS_ERR(rxcall)) {\n\t\tret = PTR_ERR(rxcall);\n\t\tgoto error_kill_call;\n\t}\n\n\tcall->rxcall = rxcall;\n\n\t/* send the request */\n\tiov[0].iov_base\t= call->request;\n\tiov[0].iov_len\t= call->request_size;\n\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1,\n\t\t      call->request_size);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= (call->send_pages ? MSG_MORE : 0);\n\n\t/* have to change the state *before* sending the last packet as RxRPC\n\t * might give us the reply before it returns from sending the\n\t * request */\n\tif (!call->send_pages)\n\t\tcall->state = AFS_CALL_AWAIT_REPLY;\n\tret = rxrpc_kernel_send_data(rxcall, &msg, call->request_size);\n\tif (ret < 0)\n\t\tgoto error_do_abort;\n\n\tif (call->send_pages) {\n\t\tret = afs_send_pages(call, &msg, iov);\n\t\tif (ret < 0)\n\t\t\tgoto error_do_abort;\n\t}\n\n\t/* at this point, an async call may no longer exist as it may have\n\t * already completed */\n\treturn wait_mode->wait(call);\n\nerror_do_abort:\n\trxrpc_kernel_abort_call(rxcall, RX_USER_ABORT);\n\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\tafs_free_skb(skb);\nerror_kill_call:\n\tafs_end_call(call);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct socket *afs_socket;",
            "static atomic_t afs_outstanding_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);",
            "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
            "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic struct socket *afs_socket;\nstatic atomic_t afs_outstanding_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\n\nint afs_make_call(struct in_addr *addr, struct afs_call *call, gfp_t gfp,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct sockaddr_rxrpc srx;\n\tstruct rxrpc_call *rxcall;\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tint ret;\n\tstruct sk_buff *skb;\n\n\t_enter(\"%x,{%d},\", addr->s_addr, ntohs(call->port));\n\n\tASSERT(call->type != NULL);\n\tASSERT(call->type->name != NULL);\n\n\t_debug(\"____MAKE %p{%s,%x} [%d]____\",\n\t       call, call->type->name, key_serial(call->key),\n\t       atomic_read(&afs_outstanding_calls));\n\n\tcall->wait_mode = wait_mode;\n\tcall->async_workfn = afs_process_async_call;\n\tINIT_WORK(&call->async_work, afs_async_workfn);\n\n\tmemset(&srx, 0, sizeof(srx));\n\tsrx.srx_family = AF_RXRPC;\n\tsrx.srx_service = call->service_id;\n\tsrx.transport_type = SOCK_DGRAM;\n\tsrx.transport_len = sizeof(srx.transport.sin);\n\tsrx.transport.sin.sin_family = AF_INET;\n\tsrx.transport.sin.sin_port = call->port;\n\tmemcpy(&srx.transport.sin.sin_addr, addr, 4);\n\n\t/* create a call */\n\trxcall = rxrpc_kernel_begin_call(afs_socket, &srx, call->key,\n\t\t\t\t\t (unsigned long) call, gfp);\n\tcall->key = NULL;\n\tif (IS_ERR(rxcall)) {\n\t\tret = PTR_ERR(rxcall);\n\t\tgoto error_kill_call;\n\t}\n\n\tcall->rxcall = rxcall;\n\n\t/* send the request */\n\tiov[0].iov_base\t= call->request;\n\tiov[0].iov_len\t= call->request_size;\n\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1,\n\t\t      call->request_size);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= (call->send_pages ? MSG_MORE : 0);\n\n\t/* have to change the state *before* sending the last packet as RxRPC\n\t * might give us the reply before it returns from sending the\n\t * request */\n\tif (!call->send_pages)\n\t\tcall->state = AFS_CALL_AWAIT_REPLY;\n\tret = rxrpc_kernel_send_data(rxcall, &msg, call->request_size);\n\tif (ret < 0)\n\t\tgoto error_do_abort;\n\n\tif (call->send_pages) {\n\t\tret = afs_send_pages(call, &msg, iov);\n\t\tif (ret < 0)\n\t\t\tgoto error_do_abort;\n\t}\n\n\t/* at this point, an async call may no longer exist as it may have\n\t * already completed */\n\treturn wait_mode->wait(call);\n\nerror_do_abort:\n\trxrpc_kernel_abort_call(rxcall, RX_USER_ABORT);\n\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\tafs_free_skb(skb);\nerror_kill_call:\n\tafs_end_call(call);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bp",
            "0",
            "padsz"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bp",
            "name",
            "namesz"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "namesz"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "vnode->fid.unique"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "vnode->fid.vnode"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "vnode->fid.vid"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "isdir ? FSREMOVEDIR : FSREMOVEFILE"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "AFS_FS_PORT"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_alloc_flat_call",
          "args": [
            "&afs_RXFSRemoveXXXX",
            "reqsz",
            "(21 + 6) * 4"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "afs_alloc_flat_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "218-255",
          "snippet": "struct afs_call *afs_alloc_flat_call(const struct afs_call_type *type,\n\t\t\t\t     size_t request_size, size_t reply_size)\n{\n\tstruct afs_call *call;\n\n\tcall = kzalloc(sizeof(*call), GFP_NOFS);\n\tif (!call)\n\t\tgoto nomem_call;\n\n\t_debug(\"CALL %p{%s} [%d]\",\n\t       call, type->name, atomic_read(&afs_outstanding_calls));\n\tatomic_inc(&afs_outstanding_calls);\n\n\tcall->type = type;\n\tcall->request_size = request_size;\n\tcall->reply_max = reply_size;\n\n\tif (request_size) {\n\t\tcall->request = kmalloc(request_size, GFP_NOFS);\n\t\tif (!call->request)\n\t\t\tgoto nomem_free;\n\t}\n\n\tif (reply_size) {\n\t\tcall->buffer = kmalloc(reply_size, GFP_NOFS);\n\t\tif (!call->buffer)\n\t\t\tgoto nomem_free;\n\t}\n\n\tinit_waitqueue_head(&call->waitq);\n\tskb_queue_head_init(&call->rx_queue);\n\treturn call;\n\nnomem_free:\n\tafs_free_call(call);\nnomem_call:\n\treturn NULL;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t afs_outstanding_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic atomic_t afs_outstanding_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nstruct afs_call *afs_alloc_flat_call(const struct afs_call_type *type,\n\t\t\t\t     size_t request_size, size_t reply_size)\n{\n\tstruct afs_call *call;\n\n\tcall = kzalloc(sizeof(*call), GFP_NOFS);\n\tif (!call)\n\t\tgoto nomem_call;\n\n\t_debug(\"CALL %p{%s} [%d]\",\n\t       call, type->name, atomic_read(&afs_outstanding_calls));\n\tatomic_inc(&afs_outstanding_calls);\n\n\tcall->type = type;\n\tcall->request_size = request_size;\n\tcall->reply_max = reply_size;\n\n\tif (request_size) {\n\t\tcall->request = kmalloc(request_size, GFP_NOFS);\n\t\tif (!call->request)\n\t\t\tgoto nomem_free;\n\t}\n\n\tif (reply_size) {\n\t\tcall->buffer = kmalloc(reply_size, GFP_NOFS);\n\t\tif (!call->buffer)\n\t\t\tgoto nomem_free;\n\t}\n\n\tinit_waitqueue_head(&call->waitq);\n\tskb_queue_head_init(&call->rx_queue);\n\treturn call;\n\nnomem_free:\n\tafs_free_call(call);\nnomem_call:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic const struct afs_call_type afs_RXFSRemoveXXXX = {\n\t.name\t\t= \"FS.RemoveXXXX\",\n\t.deliver\t= afs_deliver_fs_remove,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\nint afs_fs_remove(struct afs_server *server,\n\t\t  struct key *key,\n\t\t  struct afs_vnode *vnode,\n\t\t  const char *name,\n\t\t  bool isdir,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\tsize_t namesz, reqsz, padsz;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tnamesz = strlen(name);\n\tpadsz = (4 - (namesz & 3)) & 3;\n\treqsz = (5 * 4) + namesz + padsz;\n\n\tcall = afs_alloc_flat_call(&afs_RXFSRemoveXXXX, reqsz, (21 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(isdir ? FSREMOVEDIR : FSREMOVEFILE);\n\t*bp++ = htonl(vnode->fid.vid);\n\t*bp++ = htonl(vnode->fid.vnode);\n\t*bp++ = htonl(vnode->fid.unique);\n\t*bp++ = htonl(namesz);\n\tmemcpy(bp, name, namesz);\n\tbp = (void *) bp + namesz;\n\tif (padsz > 0) {\n\t\tmemset(bp, 0, padsz);\n\t\tbp = (void *) bp + padsz;\n\t}\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}"
  },
  {
    "function_name": "afs_deliver_fs_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
    "lines": "719-741",
    "snippet": "static int afs_deliver_fs_remove(struct afs_call *call,\n\t\t\t\t struct sk_buff *skb, bool last)\n{\n\tstruct afs_vnode *vnode = call->reply;\n\tconst __be32 *bp;\n\n\t_enter(\"{%u},{%u},%d\", call->unmarshall, skb->len, last);\n\n\tafs_transfer_reply(call, skb);\n\tif (!last)\n\t\treturn 0;\n\n\tif (call->reply_size != call->reply_max)\n\t\treturn -EBADMSG;\n\n\t/* unmarshall the reply once we've received all of it */\n\tbp = call->buffer;\n\txdr_decode_AFSFetchStatus(&bp, &vnode->status, vnode, NULL);\n\t/* xdr_decode_AFSVolSync(&bp, call->replyX); */\n\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}",
    "includes": [
      "#include \"afs_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/circ_buf.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = 0 [done]\""
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_decode_AFSFetchStatus",
          "args": [
            "&bp",
            "&vnode->status",
            "vnode",
            "NULL"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "xdr_decode_AFSFetchStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
          "lines": "35-130",
          "snippet": "static void xdr_decode_AFSFetchStatus(const __be32 **_bp,\n\t\t\t\t      struct afs_file_status *status,\n\t\t\t\t      struct afs_vnode *vnode,\n\t\t\t\t      afs_dataversion_t *store_version)\n{\n\tafs_dataversion_t expected_version;\n\tconst __be32 *bp = *_bp;\n\tumode_t mode;\n\tu64 data_version, size;\n\tu32 changed = 0; /* becomes non-zero if ctime-type changes seen */\n\tkuid_t owner;\n\tkgid_t group;\n\n#define EXTRACT(DST)\t\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tu32 x = ntohl(*bp++);\t\t\\\n\t\tchanged |= DST - x;\t\t\\\n\t\tDST = x;\t\t\t\\\n\t} while (0)\n\n\tstatus->if_version = ntohl(*bp++);\n\tEXTRACT(status->type);\n\tEXTRACT(status->nlink);\n\tsize = ntohl(*bp++);\n\tdata_version = ntohl(*bp++);\n\tEXTRACT(status->author);\n\towner = make_kuid(&init_user_ns, ntohl(*bp++));\n\tchanged |= !uid_eq(owner, status->owner);\n\tstatus->owner = owner;\n\tEXTRACT(status->caller_access); /* call ticket dependent */\n\tEXTRACT(status->anon_access);\n\tEXTRACT(status->mode);\n\tEXTRACT(status->parent.vnode);\n\tEXTRACT(status->parent.unique);\n\tbp++; /* seg size */\n\tstatus->mtime_client = ntohl(*bp++);\n\tstatus->mtime_server = ntohl(*bp++);\n\tgroup = make_kgid(&init_user_ns, ntohl(*bp++));\n\tchanged |= !gid_eq(group, status->group);\n\tstatus->group = group;\n\tbp++; /* sync counter */\n\tdata_version |= (u64) ntohl(*bp++) << 32;\n\tEXTRACT(status->lock_count);\n\tsize |= (u64) ntohl(*bp++) << 32;\n\tbp++; /* spare 4 */\n\t*_bp = bp;\n\n\tif (size != status->size) {\n\t\tstatus->size = size;\n\t\tchanged |= true;\n\t}\n\tstatus->mode &= S_IALLUGO;\n\n\t_debug(\"vnode time %lx, %lx\",\n\t       status->mtime_client, status->mtime_server);\n\n\tif (vnode) {\n\t\tstatus->parent.vid = vnode->fid.vid;\n\t\tif (changed && !test_bit(AFS_VNODE_UNSET, &vnode->flags)) {\n\t\t\t_debug(\"vnode changed\");\n\t\t\ti_size_write(&vnode->vfs_inode, size);\n\t\t\tvnode->vfs_inode.i_uid = status->owner;\n\t\t\tvnode->vfs_inode.i_gid = status->group;\n\t\t\tvnode->vfs_inode.i_generation = vnode->fid.unique;\n\t\t\tset_nlink(&vnode->vfs_inode, status->nlink);\n\n\t\t\tmode = vnode->vfs_inode.i_mode;\n\t\t\tmode &= ~S_IALLUGO;\n\t\t\tmode |= status->mode;\n\t\t\tbarrier();\n\t\t\tvnode->vfs_inode.i_mode = mode;\n\t\t}\n\n\t\tvnode->vfs_inode.i_ctime.tv_sec\t= status->mtime_server;\n\t\tvnode->vfs_inode.i_mtime\t= vnode->vfs_inode.i_ctime;\n\t\tvnode->vfs_inode.i_atime\t= vnode->vfs_inode.i_ctime;\n\t\tvnode->vfs_inode.i_version\t= data_version;\n\t}\n\n\texpected_version = status->data_version;\n\tif (store_version)\n\t\texpected_version = *store_version;\n\n\tif (expected_version != data_version) {\n\t\tstatus->data_version = data_version;\n\t\tif (vnode && !test_bit(AFS_VNODE_UNSET, &vnode->flags)) {\n\t\t\t_debug(\"vnode modified %llx on {%x:%u}\",\n\t\t\t       (unsigned long long) data_version,\n\t\t\t       vnode->fid.vid, vnode->fid.vnode);\n\t\t\tset_bit(AFS_VNODE_MODIFIED, &vnode->flags);\n\t\t\tset_bit(AFS_VNODE_ZAP_DATA, &vnode->flags);\n\t\t}\n\t} else if (store_version) {\n\t\tstatus->data_version = data_version;\n\t}\n}",
          "includes": [
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic void xdr_decode_AFSFetchStatus(const __be32 **_bp,\n\t\t\t\t      struct afs_file_status *status,\n\t\t\t\t      struct afs_vnode *vnode,\n\t\t\t\t      afs_dataversion_t *store_version)\n{\n\tafs_dataversion_t expected_version;\n\tconst __be32 *bp = *_bp;\n\tumode_t mode;\n\tu64 data_version, size;\n\tu32 changed = 0; /* becomes non-zero if ctime-type changes seen */\n\tkuid_t owner;\n\tkgid_t group;\n\n#define EXTRACT(DST)\t\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tu32 x = ntohl(*bp++);\t\t\\\n\t\tchanged |= DST - x;\t\t\\\n\t\tDST = x;\t\t\t\\\n\t} while (0)\n\n\tstatus->if_version = ntohl(*bp++);\n\tEXTRACT(status->type);\n\tEXTRACT(status->nlink);\n\tsize = ntohl(*bp++);\n\tdata_version = ntohl(*bp++);\n\tEXTRACT(status->author);\n\towner = make_kuid(&init_user_ns, ntohl(*bp++));\n\tchanged |= !uid_eq(owner, status->owner);\n\tstatus->owner = owner;\n\tEXTRACT(status->caller_access); /* call ticket dependent */\n\tEXTRACT(status->anon_access);\n\tEXTRACT(status->mode);\n\tEXTRACT(status->parent.vnode);\n\tEXTRACT(status->parent.unique);\n\tbp++; /* seg size */\n\tstatus->mtime_client = ntohl(*bp++);\n\tstatus->mtime_server = ntohl(*bp++);\n\tgroup = make_kgid(&init_user_ns, ntohl(*bp++));\n\tchanged |= !gid_eq(group, status->group);\n\tstatus->group = group;\n\tbp++; /* sync counter */\n\tdata_version |= (u64) ntohl(*bp++) << 32;\n\tEXTRACT(status->lock_count);\n\tsize |= (u64) ntohl(*bp++) << 32;\n\tbp++; /* spare 4 */\n\t*_bp = bp;\n\n\tif (size != status->size) {\n\t\tstatus->size = size;\n\t\tchanged |= true;\n\t}\n\tstatus->mode &= S_IALLUGO;\n\n\t_debug(\"vnode time %lx, %lx\",\n\t       status->mtime_client, status->mtime_server);\n\n\tif (vnode) {\n\t\tstatus->parent.vid = vnode->fid.vid;\n\t\tif (changed && !test_bit(AFS_VNODE_UNSET, &vnode->flags)) {\n\t\t\t_debug(\"vnode changed\");\n\t\t\ti_size_write(&vnode->vfs_inode, size);\n\t\t\tvnode->vfs_inode.i_uid = status->owner;\n\t\t\tvnode->vfs_inode.i_gid = status->group;\n\t\t\tvnode->vfs_inode.i_generation = vnode->fid.unique;\n\t\t\tset_nlink(&vnode->vfs_inode, status->nlink);\n\n\t\t\tmode = vnode->vfs_inode.i_mode;\n\t\t\tmode &= ~S_IALLUGO;\n\t\t\tmode |= status->mode;\n\t\t\tbarrier();\n\t\t\tvnode->vfs_inode.i_mode = mode;\n\t\t}\n\n\t\tvnode->vfs_inode.i_ctime.tv_sec\t= status->mtime_server;\n\t\tvnode->vfs_inode.i_mtime\t= vnode->vfs_inode.i_ctime;\n\t\tvnode->vfs_inode.i_atime\t= vnode->vfs_inode.i_ctime;\n\t\tvnode->vfs_inode.i_version\t= data_version;\n\t}\n\n\texpected_version = status->data_version;\n\tif (store_version)\n\t\texpected_version = *store_version;\n\n\tif (expected_version != data_version) {\n\t\tstatus->data_version = data_version;\n\t\tif (vnode && !test_bit(AFS_VNODE_UNSET, &vnode->flags)) {\n\t\t\t_debug(\"vnode modified %llx on {%x:%u}\",\n\t\t\t       (unsigned long long) data_version,\n\t\t\t       vnode->fid.vid, vnode->fid.vnode);\n\t\t\tset_bit(AFS_VNODE_MODIFIED, &vnode->flags);\n\t\t\tset_bit(AFS_VNODE_ZAP_DATA, &vnode->flags);\n\t\t}\n\t} else if (store_version) {\n\t\tstatus->data_version = data_version;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_transfer_reply",
          "args": [
            "call",
            "skb"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "afs_transfer_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "668-675",
          "snippet": "void afs_transfer_reply(struct afs_call *call, struct sk_buff *skb)\n{\n\tsize_t len = skb->len;\n\n\tif (skb_copy_bits(skb, 0, call->buffer + call->reply_size, len) < 0)\n\t\tBUG();\n\tcall->reply_size += len;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);",
            "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
            "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\n\nvoid afs_transfer_reply(struct afs_call *call, struct sk_buff *skb)\n{\n\tsize_t len = skb->len;\n\n\tif (skb_copy_bits(skb, 0, call->buffer + call->reply_size, len) < 0)\n\t\tBUG();\n\tcall->reply_size += len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%u},{%u},%d\"",
            "call->unmarshall",
            "skb->len",
            "last"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic int afs_deliver_fs_remove(struct afs_call *call,\n\t\t\t\t struct sk_buff *skb, bool last)\n{\n\tstruct afs_vnode *vnode = call->reply;\n\tconst __be32 *bp;\n\n\t_enter(\"{%u},{%u},%d\", call->unmarshall, skb->len, last);\n\n\tafs_transfer_reply(call, skb);\n\tif (!last)\n\t\treturn 0;\n\n\tif (call->reply_size != call->reply_max)\n\t\treturn -EBADMSG;\n\n\t/* unmarshall the reply once we've received all of it */\n\tbp = call->buffer;\n\txdr_decode_AFSFetchStatus(&bp, &vnode->status, vnode, NULL);\n\t/* xdr_decode_AFSVolSync(&bp, call->replyX); */\n\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}"
  },
  {
    "function_name": "afs_fs_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
    "lines": "660-714",
    "snippet": "int afs_fs_create(struct afs_server *server,\n\t\t  struct key *key,\n\t\t  struct afs_vnode *vnode,\n\t\t  const char *name,\n\t\t  umode_t mode,\n\t\t  struct afs_fid *newfid,\n\t\t  struct afs_file_status *newstatus,\n\t\t  struct afs_callback *newcb,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\tsize_t namesz, reqsz, padsz;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tnamesz = strlen(name);\n\tpadsz = (4 - (namesz & 3)) & 3;\n\treqsz = (5 * 4) + namesz + padsz + (6 * 4);\n\n\tcall = afs_alloc_flat_call(&afs_RXFSCreateXXXX, reqsz,\n\t\t\t\t   (3 + 21 + 21 + 3 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->reply2 = newfid;\n\tcall->reply3 = newstatus;\n\tcall->reply4 = newcb;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(S_ISDIR(mode) ? FSMAKEDIR : FSCREATEFILE);\n\t*bp++ = htonl(vnode->fid.vid);\n\t*bp++ = htonl(vnode->fid.vnode);\n\t*bp++ = htonl(vnode->fid.unique);\n\t*bp++ = htonl(namesz);\n\tmemcpy(bp, name, namesz);\n\tbp = (void *) bp + namesz;\n\tif (padsz > 0) {\n\t\tmemset(bp, 0, padsz);\n\t\tbp = (void *) bp + padsz;\n\t}\n\t*bp++ = htonl(AFS_SET_MODE);\n\t*bp++ = 0; /* mtime */\n\t*bp++ = 0; /* owner */\n\t*bp++ = 0; /* group */\n\t*bp++ = htonl(mode & S_IALLUGO); /* unix mode */\n\t*bp++ = 0; /* segment size */\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}",
    "includes": [
      "#include \"afs_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/circ_buf.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct afs_call_type afs_RXFSCreateXXXX = {\n\t.name\t\t= \"FS.CreateXXXX\",\n\t.deliver\t= afs_deliver_fs_create_vnode,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "afs_make_call",
          "args": [
            "&server->addr",
            "call",
            "GFP_NOFS",
            "wait_mode"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "afs_make_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "338-420",
          "snippet": "int afs_make_call(struct in_addr *addr, struct afs_call *call, gfp_t gfp,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct sockaddr_rxrpc srx;\n\tstruct rxrpc_call *rxcall;\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tint ret;\n\tstruct sk_buff *skb;\n\n\t_enter(\"%x,{%d},\", addr->s_addr, ntohs(call->port));\n\n\tASSERT(call->type != NULL);\n\tASSERT(call->type->name != NULL);\n\n\t_debug(\"____MAKE %p{%s,%x} [%d]____\",\n\t       call, call->type->name, key_serial(call->key),\n\t       atomic_read(&afs_outstanding_calls));\n\n\tcall->wait_mode = wait_mode;\n\tcall->async_workfn = afs_process_async_call;\n\tINIT_WORK(&call->async_work, afs_async_workfn);\n\n\tmemset(&srx, 0, sizeof(srx));\n\tsrx.srx_family = AF_RXRPC;\n\tsrx.srx_service = call->service_id;\n\tsrx.transport_type = SOCK_DGRAM;\n\tsrx.transport_len = sizeof(srx.transport.sin);\n\tsrx.transport.sin.sin_family = AF_INET;\n\tsrx.transport.sin.sin_port = call->port;\n\tmemcpy(&srx.transport.sin.sin_addr, addr, 4);\n\n\t/* create a call */\n\trxcall = rxrpc_kernel_begin_call(afs_socket, &srx, call->key,\n\t\t\t\t\t (unsigned long) call, gfp);\n\tcall->key = NULL;\n\tif (IS_ERR(rxcall)) {\n\t\tret = PTR_ERR(rxcall);\n\t\tgoto error_kill_call;\n\t}\n\n\tcall->rxcall = rxcall;\n\n\t/* send the request */\n\tiov[0].iov_base\t= call->request;\n\tiov[0].iov_len\t= call->request_size;\n\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1,\n\t\t      call->request_size);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= (call->send_pages ? MSG_MORE : 0);\n\n\t/* have to change the state *before* sending the last packet as RxRPC\n\t * might give us the reply before it returns from sending the\n\t * request */\n\tif (!call->send_pages)\n\t\tcall->state = AFS_CALL_AWAIT_REPLY;\n\tret = rxrpc_kernel_send_data(rxcall, &msg, call->request_size);\n\tif (ret < 0)\n\t\tgoto error_do_abort;\n\n\tif (call->send_pages) {\n\t\tret = afs_send_pages(call, &msg, iov);\n\t\tif (ret < 0)\n\t\t\tgoto error_do_abort;\n\t}\n\n\t/* at this point, an async call may no longer exist as it may have\n\t * already completed */\n\treturn wait_mode->wait(call);\n\nerror_do_abort:\n\trxrpc_kernel_abort_call(rxcall, RX_USER_ABORT);\n\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\tafs_free_skb(skb);\nerror_kill_call:\n\tafs_end_call(call);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct socket *afs_socket;",
            "static atomic_t afs_outstanding_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);",
            "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
            "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic struct socket *afs_socket;\nstatic atomic_t afs_outstanding_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\n\nint afs_make_call(struct in_addr *addr, struct afs_call *call, gfp_t gfp,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct sockaddr_rxrpc srx;\n\tstruct rxrpc_call *rxcall;\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tint ret;\n\tstruct sk_buff *skb;\n\n\t_enter(\"%x,{%d},\", addr->s_addr, ntohs(call->port));\n\n\tASSERT(call->type != NULL);\n\tASSERT(call->type->name != NULL);\n\n\t_debug(\"____MAKE %p{%s,%x} [%d]____\",\n\t       call, call->type->name, key_serial(call->key),\n\t       atomic_read(&afs_outstanding_calls));\n\n\tcall->wait_mode = wait_mode;\n\tcall->async_workfn = afs_process_async_call;\n\tINIT_WORK(&call->async_work, afs_async_workfn);\n\n\tmemset(&srx, 0, sizeof(srx));\n\tsrx.srx_family = AF_RXRPC;\n\tsrx.srx_service = call->service_id;\n\tsrx.transport_type = SOCK_DGRAM;\n\tsrx.transport_len = sizeof(srx.transport.sin);\n\tsrx.transport.sin.sin_family = AF_INET;\n\tsrx.transport.sin.sin_port = call->port;\n\tmemcpy(&srx.transport.sin.sin_addr, addr, 4);\n\n\t/* create a call */\n\trxcall = rxrpc_kernel_begin_call(afs_socket, &srx, call->key,\n\t\t\t\t\t (unsigned long) call, gfp);\n\tcall->key = NULL;\n\tif (IS_ERR(rxcall)) {\n\t\tret = PTR_ERR(rxcall);\n\t\tgoto error_kill_call;\n\t}\n\n\tcall->rxcall = rxcall;\n\n\t/* send the request */\n\tiov[0].iov_base\t= call->request;\n\tiov[0].iov_len\t= call->request_size;\n\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1,\n\t\t      call->request_size);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= (call->send_pages ? MSG_MORE : 0);\n\n\t/* have to change the state *before* sending the last packet as RxRPC\n\t * might give us the reply before it returns from sending the\n\t * request */\n\tif (!call->send_pages)\n\t\tcall->state = AFS_CALL_AWAIT_REPLY;\n\tret = rxrpc_kernel_send_data(rxcall, &msg, call->request_size);\n\tif (ret < 0)\n\t\tgoto error_do_abort;\n\n\tif (call->send_pages) {\n\t\tret = afs_send_pages(call, &msg, iov);\n\t\tif (ret < 0)\n\t\t\tgoto error_do_abort;\n\t}\n\n\t/* at this point, an async call may no longer exist as it may have\n\t * already completed */\n\treturn wait_mode->wait(call);\n\nerror_do_abort:\n\trxrpc_kernel_abort_call(rxcall, RX_USER_ABORT);\n\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\tafs_free_skb(skb);\nerror_kill_call:\n\tafs_end_call(call);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "mode & S_IALLUGO"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "AFS_SET_MODE"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bp",
            "0",
            "padsz"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bp",
            "name",
            "namesz"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "namesz"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "vnode->fid.unique"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "vnode->fid.vnode"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "vnode->fid.vid"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "S_ISDIR(mode) ? FSMAKEDIR : FSCREATEFILE"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "AFS_FS_PORT"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_alloc_flat_call",
          "args": [
            "&afs_RXFSCreateXXXX",
            "reqsz",
            "(3 + 21 + 21 + 3 + 6) * 4"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "afs_alloc_flat_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "218-255",
          "snippet": "struct afs_call *afs_alloc_flat_call(const struct afs_call_type *type,\n\t\t\t\t     size_t request_size, size_t reply_size)\n{\n\tstruct afs_call *call;\n\n\tcall = kzalloc(sizeof(*call), GFP_NOFS);\n\tif (!call)\n\t\tgoto nomem_call;\n\n\t_debug(\"CALL %p{%s} [%d]\",\n\t       call, type->name, atomic_read(&afs_outstanding_calls));\n\tatomic_inc(&afs_outstanding_calls);\n\n\tcall->type = type;\n\tcall->request_size = request_size;\n\tcall->reply_max = reply_size;\n\n\tif (request_size) {\n\t\tcall->request = kmalloc(request_size, GFP_NOFS);\n\t\tif (!call->request)\n\t\t\tgoto nomem_free;\n\t}\n\n\tif (reply_size) {\n\t\tcall->buffer = kmalloc(reply_size, GFP_NOFS);\n\t\tif (!call->buffer)\n\t\t\tgoto nomem_free;\n\t}\n\n\tinit_waitqueue_head(&call->waitq);\n\tskb_queue_head_init(&call->rx_queue);\n\treturn call;\n\nnomem_free:\n\tafs_free_call(call);\nnomem_call:\n\treturn NULL;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t afs_outstanding_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic atomic_t afs_outstanding_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nstruct afs_call *afs_alloc_flat_call(const struct afs_call_type *type,\n\t\t\t\t     size_t request_size, size_t reply_size)\n{\n\tstruct afs_call *call;\n\n\tcall = kzalloc(sizeof(*call), GFP_NOFS);\n\tif (!call)\n\t\tgoto nomem_call;\n\n\t_debug(\"CALL %p{%s} [%d]\",\n\t       call, type->name, atomic_read(&afs_outstanding_calls));\n\tatomic_inc(&afs_outstanding_calls);\n\n\tcall->type = type;\n\tcall->request_size = request_size;\n\tcall->reply_max = reply_size;\n\n\tif (request_size) {\n\t\tcall->request = kmalloc(request_size, GFP_NOFS);\n\t\tif (!call->request)\n\t\t\tgoto nomem_free;\n\t}\n\n\tif (reply_size) {\n\t\tcall->buffer = kmalloc(reply_size, GFP_NOFS);\n\t\tif (!call->buffer)\n\t\t\tgoto nomem_free;\n\t}\n\n\tinit_waitqueue_head(&call->waitq);\n\tskb_queue_head_init(&call->rx_queue);\n\treturn call;\n\nnomem_free:\n\tafs_free_call(call);\nnomem_call:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic const struct afs_call_type afs_RXFSCreateXXXX = {\n\t.name\t\t= \"FS.CreateXXXX\",\n\t.deliver\t= afs_deliver_fs_create_vnode,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\nint afs_fs_create(struct afs_server *server,\n\t\t  struct key *key,\n\t\t  struct afs_vnode *vnode,\n\t\t  const char *name,\n\t\t  umode_t mode,\n\t\t  struct afs_fid *newfid,\n\t\t  struct afs_file_status *newstatus,\n\t\t  struct afs_callback *newcb,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\tsize_t namesz, reqsz, padsz;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tnamesz = strlen(name);\n\tpadsz = (4 - (namesz & 3)) & 3;\n\treqsz = (5 * 4) + namesz + padsz + (6 * 4);\n\n\tcall = afs_alloc_flat_call(&afs_RXFSCreateXXXX, reqsz,\n\t\t\t\t   (3 + 21 + 21 + 3 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->reply2 = newfid;\n\tcall->reply3 = newstatus;\n\tcall->reply4 = newcb;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(S_ISDIR(mode) ? FSMAKEDIR : FSCREATEFILE);\n\t*bp++ = htonl(vnode->fid.vid);\n\t*bp++ = htonl(vnode->fid.vnode);\n\t*bp++ = htonl(vnode->fid.unique);\n\t*bp++ = htonl(namesz);\n\tmemcpy(bp, name, namesz);\n\tbp = (void *) bp + namesz;\n\tif (padsz > 0) {\n\t\tmemset(bp, 0, padsz);\n\t\tbp = (void *) bp + padsz;\n\t}\n\t*bp++ = htonl(AFS_SET_MODE);\n\t*bp++ = 0; /* mtime */\n\t*bp++ = 0; /* owner */\n\t*bp++ = 0; /* group */\n\t*bp++ = htonl(mode & S_IALLUGO); /* unix mode */\n\t*bp++ = 0; /* segment size */\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}"
  },
  {
    "function_name": "afs_deliver_fs_create_vnode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
    "lines": "620-645",
    "snippet": "static int afs_deliver_fs_create_vnode(struct afs_call *call,\n\t\t\t\t       struct sk_buff *skb, bool last)\n{\n\tstruct afs_vnode *vnode = call->reply;\n\tconst __be32 *bp;\n\n\t_enter(\"{%u},{%u},%d\", call->unmarshall, skb->len, last);\n\n\tafs_transfer_reply(call, skb);\n\tif (!last)\n\t\treturn 0;\n\n\tif (call->reply_size != call->reply_max)\n\t\treturn -EBADMSG;\n\n\t/* unmarshall the reply once we've received all of it */\n\tbp = call->buffer;\n\txdr_decode_AFSFid(&bp, call->reply2);\n\txdr_decode_AFSFetchStatus(&bp, call->reply3, NULL, NULL);\n\txdr_decode_AFSFetchStatus(&bp, &vnode->status, vnode, NULL);\n\txdr_decode_AFSCallBack_raw(&bp, call->reply4);\n\t/* xdr_decode_AFSVolSync(&bp, call->replyX); */\n\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}",
    "includes": [
      "#include \"afs_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/circ_buf.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = 0 [done]\""
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_decode_AFSCallBack_raw",
          "args": [
            "&bp",
            "call->reply4"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "xdr_decode_AFSCallBack_raw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
          "lines": "146-155",
          "snippet": "static void xdr_decode_AFSCallBack_raw(const __be32 **_bp,\n\t\t\t\t       struct afs_callback *cb)\n{\n\tconst __be32 *bp = *_bp;\n\n\tcb->version\t= ntohl(*bp++);\n\tcb->expiry\t= ntohl(*bp++);\n\tcb->type\t= ntohl(*bp++);\n\t*_bp = bp;\n}",
          "includes": [
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic void xdr_decode_AFSCallBack_raw(const __be32 **_bp,\n\t\t\t\t       struct afs_callback *cb)\n{\n\tconst __be32 *bp = *_bp;\n\n\tcb->version\t= ntohl(*bp++);\n\tcb->expiry\t= ntohl(*bp++);\n\tcb->type\t= ntohl(*bp++);\n\t*_bp = bp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_decode_AFSFetchStatus",
          "args": [
            "&bp",
            "&vnode->status",
            "vnode",
            "NULL"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "xdr_decode_AFSFetchStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
          "lines": "35-130",
          "snippet": "static void xdr_decode_AFSFetchStatus(const __be32 **_bp,\n\t\t\t\t      struct afs_file_status *status,\n\t\t\t\t      struct afs_vnode *vnode,\n\t\t\t\t      afs_dataversion_t *store_version)\n{\n\tafs_dataversion_t expected_version;\n\tconst __be32 *bp = *_bp;\n\tumode_t mode;\n\tu64 data_version, size;\n\tu32 changed = 0; /* becomes non-zero if ctime-type changes seen */\n\tkuid_t owner;\n\tkgid_t group;\n\n#define EXTRACT(DST)\t\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tu32 x = ntohl(*bp++);\t\t\\\n\t\tchanged |= DST - x;\t\t\\\n\t\tDST = x;\t\t\t\\\n\t} while (0)\n\n\tstatus->if_version = ntohl(*bp++);\n\tEXTRACT(status->type);\n\tEXTRACT(status->nlink);\n\tsize = ntohl(*bp++);\n\tdata_version = ntohl(*bp++);\n\tEXTRACT(status->author);\n\towner = make_kuid(&init_user_ns, ntohl(*bp++));\n\tchanged |= !uid_eq(owner, status->owner);\n\tstatus->owner = owner;\n\tEXTRACT(status->caller_access); /* call ticket dependent */\n\tEXTRACT(status->anon_access);\n\tEXTRACT(status->mode);\n\tEXTRACT(status->parent.vnode);\n\tEXTRACT(status->parent.unique);\n\tbp++; /* seg size */\n\tstatus->mtime_client = ntohl(*bp++);\n\tstatus->mtime_server = ntohl(*bp++);\n\tgroup = make_kgid(&init_user_ns, ntohl(*bp++));\n\tchanged |= !gid_eq(group, status->group);\n\tstatus->group = group;\n\tbp++; /* sync counter */\n\tdata_version |= (u64) ntohl(*bp++) << 32;\n\tEXTRACT(status->lock_count);\n\tsize |= (u64) ntohl(*bp++) << 32;\n\tbp++; /* spare 4 */\n\t*_bp = bp;\n\n\tif (size != status->size) {\n\t\tstatus->size = size;\n\t\tchanged |= true;\n\t}\n\tstatus->mode &= S_IALLUGO;\n\n\t_debug(\"vnode time %lx, %lx\",\n\t       status->mtime_client, status->mtime_server);\n\n\tif (vnode) {\n\t\tstatus->parent.vid = vnode->fid.vid;\n\t\tif (changed && !test_bit(AFS_VNODE_UNSET, &vnode->flags)) {\n\t\t\t_debug(\"vnode changed\");\n\t\t\ti_size_write(&vnode->vfs_inode, size);\n\t\t\tvnode->vfs_inode.i_uid = status->owner;\n\t\t\tvnode->vfs_inode.i_gid = status->group;\n\t\t\tvnode->vfs_inode.i_generation = vnode->fid.unique;\n\t\t\tset_nlink(&vnode->vfs_inode, status->nlink);\n\n\t\t\tmode = vnode->vfs_inode.i_mode;\n\t\t\tmode &= ~S_IALLUGO;\n\t\t\tmode |= status->mode;\n\t\t\tbarrier();\n\t\t\tvnode->vfs_inode.i_mode = mode;\n\t\t}\n\n\t\tvnode->vfs_inode.i_ctime.tv_sec\t= status->mtime_server;\n\t\tvnode->vfs_inode.i_mtime\t= vnode->vfs_inode.i_ctime;\n\t\tvnode->vfs_inode.i_atime\t= vnode->vfs_inode.i_ctime;\n\t\tvnode->vfs_inode.i_version\t= data_version;\n\t}\n\n\texpected_version = status->data_version;\n\tif (store_version)\n\t\texpected_version = *store_version;\n\n\tif (expected_version != data_version) {\n\t\tstatus->data_version = data_version;\n\t\tif (vnode && !test_bit(AFS_VNODE_UNSET, &vnode->flags)) {\n\t\t\t_debug(\"vnode modified %llx on {%x:%u}\",\n\t\t\t       (unsigned long long) data_version,\n\t\t\t       vnode->fid.vid, vnode->fid.vnode);\n\t\t\tset_bit(AFS_VNODE_MODIFIED, &vnode->flags);\n\t\t\tset_bit(AFS_VNODE_ZAP_DATA, &vnode->flags);\n\t\t}\n\t} else if (store_version) {\n\t\tstatus->data_version = data_version;\n\t}\n}",
          "includes": [
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic void xdr_decode_AFSFetchStatus(const __be32 **_bp,\n\t\t\t\t      struct afs_file_status *status,\n\t\t\t\t      struct afs_vnode *vnode,\n\t\t\t\t      afs_dataversion_t *store_version)\n{\n\tafs_dataversion_t expected_version;\n\tconst __be32 *bp = *_bp;\n\tumode_t mode;\n\tu64 data_version, size;\n\tu32 changed = 0; /* becomes non-zero if ctime-type changes seen */\n\tkuid_t owner;\n\tkgid_t group;\n\n#define EXTRACT(DST)\t\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tu32 x = ntohl(*bp++);\t\t\\\n\t\tchanged |= DST - x;\t\t\\\n\t\tDST = x;\t\t\t\\\n\t} while (0)\n\n\tstatus->if_version = ntohl(*bp++);\n\tEXTRACT(status->type);\n\tEXTRACT(status->nlink);\n\tsize = ntohl(*bp++);\n\tdata_version = ntohl(*bp++);\n\tEXTRACT(status->author);\n\towner = make_kuid(&init_user_ns, ntohl(*bp++));\n\tchanged |= !uid_eq(owner, status->owner);\n\tstatus->owner = owner;\n\tEXTRACT(status->caller_access); /* call ticket dependent */\n\tEXTRACT(status->anon_access);\n\tEXTRACT(status->mode);\n\tEXTRACT(status->parent.vnode);\n\tEXTRACT(status->parent.unique);\n\tbp++; /* seg size */\n\tstatus->mtime_client = ntohl(*bp++);\n\tstatus->mtime_server = ntohl(*bp++);\n\tgroup = make_kgid(&init_user_ns, ntohl(*bp++));\n\tchanged |= !gid_eq(group, status->group);\n\tstatus->group = group;\n\tbp++; /* sync counter */\n\tdata_version |= (u64) ntohl(*bp++) << 32;\n\tEXTRACT(status->lock_count);\n\tsize |= (u64) ntohl(*bp++) << 32;\n\tbp++; /* spare 4 */\n\t*_bp = bp;\n\n\tif (size != status->size) {\n\t\tstatus->size = size;\n\t\tchanged |= true;\n\t}\n\tstatus->mode &= S_IALLUGO;\n\n\t_debug(\"vnode time %lx, %lx\",\n\t       status->mtime_client, status->mtime_server);\n\n\tif (vnode) {\n\t\tstatus->parent.vid = vnode->fid.vid;\n\t\tif (changed && !test_bit(AFS_VNODE_UNSET, &vnode->flags)) {\n\t\t\t_debug(\"vnode changed\");\n\t\t\ti_size_write(&vnode->vfs_inode, size);\n\t\t\tvnode->vfs_inode.i_uid = status->owner;\n\t\t\tvnode->vfs_inode.i_gid = status->group;\n\t\t\tvnode->vfs_inode.i_generation = vnode->fid.unique;\n\t\t\tset_nlink(&vnode->vfs_inode, status->nlink);\n\n\t\t\tmode = vnode->vfs_inode.i_mode;\n\t\t\tmode &= ~S_IALLUGO;\n\t\t\tmode |= status->mode;\n\t\t\tbarrier();\n\t\t\tvnode->vfs_inode.i_mode = mode;\n\t\t}\n\n\t\tvnode->vfs_inode.i_ctime.tv_sec\t= status->mtime_server;\n\t\tvnode->vfs_inode.i_mtime\t= vnode->vfs_inode.i_ctime;\n\t\tvnode->vfs_inode.i_atime\t= vnode->vfs_inode.i_ctime;\n\t\tvnode->vfs_inode.i_version\t= data_version;\n\t}\n\n\texpected_version = status->data_version;\n\tif (store_version)\n\t\texpected_version = *store_version;\n\n\tif (expected_version != data_version) {\n\t\tstatus->data_version = data_version;\n\t\tif (vnode && !test_bit(AFS_VNODE_UNSET, &vnode->flags)) {\n\t\t\t_debug(\"vnode modified %llx on {%x:%u}\",\n\t\t\t       (unsigned long long) data_version,\n\t\t\t       vnode->fid.vid, vnode->fid.vnode);\n\t\t\tset_bit(AFS_VNODE_MODIFIED, &vnode->flags);\n\t\t\tset_bit(AFS_VNODE_ZAP_DATA, &vnode->flags);\n\t\t}\n\t} else if (store_version) {\n\t\tstatus->data_version = data_version;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_decode_AFSFid",
          "args": [
            "&bp",
            "call->reply2"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "xdr_decode_AFSFid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
          "lines": "22-30",
          "snippet": "static void xdr_decode_AFSFid(const __be32 **_bp, struct afs_fid *fid)\n{\n\tconst __be32 *bp = *_bp;\n\n\tfid->vid\t\t= ntohl(*bp++);\n\tfid->vnode\t\t= ntohl(*bp++);\n\tfid->unique\t\t= ntohl(*bp++);\n\t*_bp = bp;\n}",
          "includes": [
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic void xdr_decode_AFSFid(const __be32 **_bp, struct afs_fid *fid)\n{\n\tconst __be32 *bp = *_bp;\n\n\tfid->vid\t\t= ntohl(*bp++);\n\tfid->vnode\t\t= ntohl(*bp++);\n\tfid->unique\t\t= ntohl(*bp++);\n\t*_bp = bp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_transfer_reply",
          "args": [
            "call",
            "skb"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "afs_transfer_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "668-675",
          "snippet": "void afs_transfer_reply(struct afs_call *call, struct sk_buff *skb)\n{\n\tsize_t len = skb->len;\n\n\tif (skb_copy_bits(skb, 0, call->buffer + call->reply_size, len) < 0)\n\t\tBUG();\n\tcall->reply_size += len;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);",
            "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
            "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\n\nvoid afs_transfer_reply(struct afs_call *call, struct sk_buff *skb)\n{\n\tsize_t len = skb->len;\n\n\tif (skb_copy_bits(skb, 0, call->buffer + call->reply_size, len) < 0)\n\t\tBUG();\n\tcall->reply_size += len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%u},{%u},%d\"",
            "call->unmarshall",
            "skb->len",
            "last"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic int afs_deliver_fs_create_vnode(struct afs_call *call,\n\t\t\t\t       struct sk_buff *skb, bool last)\n{\n\tstruct afs_vnode *vnode = call->reply;\n\tconst __be32 *bp;\n\n\t_enter(\"{%u},{%u},%d\", call->unmarshall, skb->len, last);\n\n\tafs_transfer_reply(call, skb);\n\tif (!last)\n\t\treturn 0;\n\n\tif (call->reply_size != call->reply_max)\n\t\treturn -EBADMSG;\n\n\t/* unmarshall the reply once we've received all of it */\n\tbp = call->buffer;\n\txdr_decode_AFSFid(&bp, call->reply2);\n\txdr_decode_AFSFetchStatus(&bp, call->reply3, NULL, NULL);\n\txdr_decode_AFSFetchStatus(&bp, &vnode->status, vnode, NULL);\n\txdr_decode_AFSCallBack_raw(&bp, call->reply4);\n\t/* xdr_decode_AFSVolSync(&bp, call->replyX); */\n\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}"
  },
  {
    "function_name": "afs_fs_give_up_callbacks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
    "lines": "559-615",
    "snippet": "int afs_fs_give_up_callbacks(struct afs_server *server,\n\t\t\t     const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\tsize_t ncallbacks;\n\t__be32 *bp, *tp;\n\tint loop;\n\n\tncallbacks = CIRC_CNT(server->cb_break_head, server->cb_break_tail,\n\t\t\t      ARRAY_SIZE(server->cb_break));\n\n\t_enter(\"{%zu},\", ncallbacks);\n\n\tif (ncallbacks == 0)\n\t\treturn 0;\n\tif (ncallbacks > AFSCBMAX)\n\t\tncallbacks = AFSCBMAX;\n\n\t_debug(\"break %zu callbacks\", ncallbacks);\n\n\tcall = afs_alloc_flat_call(&afs_RXFSGiveUpCallBacks,\n\t\t\t\t   12 + ncallbacks * 6 * 4, 0);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\ttp = bp + 2 + ncallbacks * 3;\n\t*bp++ = htonl(FSGIVEUPCALLBACKS);\n\t*bp++ = htonl(ncallbacks);\n\t*tp++ = htonl(ncallbacks);\n\n\tatomic_sub(ncallbacks, &server->cb_break_n);\n\tfor (loop = ncallbacks; loop > 0; loop--) {\n\t\tstruct afs_callback *cb =\n\t\t\t&server->cb_break[server->cb_break_tail];\n\n\t\t*bp++ = htonl(cb->fid.vid);\n\t\t*bp++ = htonl(cb->fid.vnode);\n\t\t*bp++ = htonl(cb->fid.unique);\n\t\t*tp++ = htonl(cb->version);\n\t\t*tp++ = htonl(cb->expiry);\n\t\t*tp++ = htonl(cb->type);\n\t\tsmp_mb();\n\t\tserver->cb_break_tail =\n\t\t\t(server->cb_break_tail + 1) &\n\t\t\t(ARRAY_SIZE(server->cb_break) - 1);\n\t}\n\n\tASSERT(ncallbacks > 0);\n\twake_up_nr(&server->cb_break_waitq, ncallbacks);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}",
    "includes": [
      "#include \"afs_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/circ_buf.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct afs_call_type afs_RXFSGiveUpCallBacks = {\n\t.name\t\t= \"FS.GiveUpCallBacks\",\n\t.deliver\t= afs_deliver_fs_give_up_callbacks,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "afs_make_call",
          "args": [
            "&server->addr",
            "call",
            "GFP_NOFS",
            "wait_mode"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "afs_make_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "338-420",
          "snippet": "int afs_make_call(struct in_addr *addr, struct afs_call *call, gfp_t gfp,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct sockaddr_rxrpc srx;\n\tstruct rxrpc_call *rxcall;\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tint ret;\n\tstruct sk_buff *skb;\n\n\t_enter(\"%x,{%d},\", addr->s_addr, ntohs(call->port));\n\n\tASSERT(call->type != NULL);\n\tASSERT(call->type->name != NULL);\n\n\t_debug(\"____MAKE %p{%s,%x} [%d]____\",\n\t       call, call->type->name, key_serial(call->key),\n\t       atomic_read(&afs_outstanding_calls));\n\n\tcall->wait_mode = wait_mode;\n\tcall->async_workfn = afs_process_async_call;\n\tINIT_WORK(&call->async_work, afs_async_workfn);\n\n\tmemset(&srx, 0, sizeof(srx));\n\tsrx.srx_family = AF_RXRPC;\n\tsrx.srx_service = call->service_id;\n\tsrx.transport_type = SOCK_DGRAM;\n\tsrx.transport_len = sizeof(srx.transport.sin);\n\tsrx.transport.sin.sin_family = AF_INET;\n\tsrx.transport.sin.sin_port = call->port;\n\tmemcpy(&srx.transport.sin.sin_addr, addr, 4);\n\n\t/* create a call */\n\trxcall = rxrpc_kernel_begin_call(afs_socket, &srx, call->key,\n\t\t\t\t\t (unsigned long) call, gfp);\n\tcall->key = NULL;\n\tif (IS_ERR(rxcall)) {\n\t\tret = PTR_ERR(rxcall);\n\t\tgoto error_kill_call;\n\t}\n\n\tcall->rxcall = rxcall;\n\n\t/* send the request */\n\tiov[0].iov_base\t= call->request;\n\tiov[0].iov_len\t= call->request_size;\n\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1,\n\t\t      call->request_size);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= (call->send_pages ? MSG_MORE : 0);\n\n\t/* have to change the state *before* sending the last packet as RxRPC\n\t * might give us the reply before it returns from sending the\n\t * request */\n\tif (!call->send_pages)\n\t\tcall->state = AFS_CALL_AWAIT_REPLY;\n\tret = rxrpc_kernel_send_data(rxcall, &msg, call->request_size);\n\tif (ret < 0)\n\t\tgoto error_do_abort;\n\n\tif (call->send_pages) {\n\t\tret = afs_send_pages(call, &msg, iov);\n\t\tif (ret < 0)\n\t\t\tgoto error_do_abort;\n\t}\n\n\t/* at this point, an async call may no longer exist as it may have\n\t * already completed */\n\treturn wait_mode->wait(call);\n\nerror_do_abort:\n\trxrpc_kernel_abort_call(rxcall, RX_USER_ABORT);\n\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\tafs_free_skb(skb);\nerror_kill_call:\n\tafs_end_call(call);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct socket *afs_socket;",
            "static atomic_t afs_outstanding_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);",
            "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
            "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic struct socket *afs_socket;\nstatic atomic_t afs_outstanding_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\n\nint afs_make_call(struct in_addr *addr, struct afs_call *call, gfp_t gfp,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct sockaddr_rxrpc srx;\n\tstruct rxrpc_call *rxcall;\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tint ret;\n\tstruct sk_buff *skb;\n\n\t_enter(\"%x,{%d},\", addr->s_addr, ntohs(call->port));\n\n\tASSERT(call->type != NULL);\n\tASSERT(call->type->name != NULL);\n\n\t_debug(\"____MAKE %p{%s,%x} [%d]____\",\n\t       call, call->type->name, key_serial(call->key),\n\t       atomic_read(&afs_outstanding_calls));\n\n\tcall->wait_mode = wait_mode;\n\tcall->async_workfn = afs_process_async_call;\n\tINIT_WORK(&call->async_work, afs_async_workfn);\n\n\tmemset(&srx, 0, sizeof(srx));\n\tsrx.srx_family = AF_RXRPC;\n\tsrx.srx_service = call->service_id;\n\tsrx.transport_type = SOCK_DGRAM;\n\tsrx.transport_len = sizeof(srx.transport.sin);\n\tsrx.transport.sin.sin_family = AF_INET;\n\tsrx.transport.sin.sin_port = call->port;\n\tmemcpy(&srx.transport.sin.sin_addr, addr, 4);\n\n\t/* create a call */\n\trxcall = rxrpc_kernel_begin_call(afs_socket, &srx, call->key,\n\t\t\t\t\t (unsigned long) call, gfp);\n\tcall->key = NULL;\n\tif (IS_ERR(rxcall)) {\n\t\tret = PTR_ERR(rxcall);\n\t\tgoto error_kill_call;\n\t}\n\n\tcall->rxcall = rxcall;\n\n\t/* send the request */\n\tiov[0].iov_base\t= call->request;\n\tiov[0].iov_len\t= call->request_size;\n\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1,\n\t\t      call->request_size);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= (call->send_pages ? MSG_MORE : 0);\n\n\t/* have to change the state *before* sending the last packet as RxRPC\n\t * might give us the reply before it returns from sending the\n\t * request */\n\tif (!call->send_pages)\n\t\tcall->state = AFS_CALL_AWAIT_REPLY;\n\tret = rxrpc_kernel_send_data(rxcall, &msg, call->request_size);\n\tif (ret < 0)\n\t\tgoto error_do_abort;\n\n\tif (call->send_pages) {\n\t\tret = afs_send_pages(call, &msg, iov);\n\t\tif (ret < 0)\n\t\t\tgoto error_do_abort;\n\t}\n\n\t/* at this point, an async call may no longer exist as it may have\n\t * already completed */\n\treturn wait_mode->wait(call);\n\nerror_do_abort:\n\trxrpc_kernel_abort_call(rxcall, RX_USER_ABORT);\n\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\tafs_free_skb(skb);\nerror_kill_call:\n\tafs_end_call(call);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_nr",
          "args": [
            "&server->cb_break_waitq",
            "ncallbacks"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ncallbacks > 0"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "server->cb_break"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "cb->type"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "cb->expiry"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "cb->version"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "cb->fid.unique"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "cb->fid.vnode"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "cb->fid.vid"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_sub",
          "args": [
            "ncallbacks",
            "&server->cb_break_n"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "ncallbacks"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "ncallbacks"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "FSGIVEUPCALLBACKS"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "AFS_FS_PORT"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_alloc_flat_call",
          "args": [
            "&afs_RXFSGiveUpCallBacks",
            "12 + ncallbacks * 6 * 4",
            "0"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "afs_alloc_flat_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "218-255",
          "snippet": "struct afs_call *afs_alloc_flat_call(const struct afs_call_type *type,\n\t\t\t\t     size_t request_size, size_t reply_size)\n{\n\tstruct afs_call *call;\n\n\tcall = kzalloc(sizeof(*call), GFP_NOFS);\n\tif (!call)\n\t\tgoto nomem_call;\n\n\t_debug(\"CALL %p{%s} [%d]\",\n\t       call, type->name, atomic_read(&afs_outstanding_calls));\n\tatomic_inc(&afs_outstanding_calls);\n\n\tcall->type = type;\n\tcall->request_size = request_size;\n\tcall->reply_max = reply_size;\n\n\tif (request_size) {\n\t\tcall->request = kmalloc(request_size, GFP_NOFS);\n\t\tif (!call->request)\n\t\t\tgoto nomem_free;\n\t}\n\n\tif (reply_size) {\n\t\tcall->buffer = kmalloc(reply_size, GFP_NOFS);\n\t\tif (!call->buffer)\n\t\t\tgoto nomem_free;\n\t}\n\n\tinit_waitqueue_head(&call->waitq);\n\tskb_queue_head_init(&call->rx_queue);\n\treturn call;\n\nnomem_free:\n\tafs_free_call(call);\nnomem_call:\n\treturn NULL;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t afs_outstanding_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic atomic_t afs_outstanding_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nstruct afs_call *afs_alloc_flat_call(const struct afs_call_type *type,\n\t\t\t\t     size_t request_size, size_t reply_size)\n{\n\tstruct afs_call *call;\n\n\tcall = kzalloc(sizeof(*call), GFP_NOFS);\n\tif (!call)\n\t\tgoto nomem_call;\n\n\t_debug(\"CALL %p{%s} [%d]\",\n\t       call, type->name, atomic_read(&afs_outstanding_calls));\n\tatomic_inc(&afs_outstanding_calls);\n\n\tcall->type = type;\n\tcall->request_size = request_size;\n\tcall->reply_max = reply_size;\n\n\tif (request_size) {\n\t\tcall->request = kmalloc(request_size, GFP_NOFS);\n\t\tif (!call->request)\n\t\t\tgoto nomem_free;\n\t}\n\n\tif (reply_size) {\n\t\tcall->buffer = kmalloc(reply_size, GFP_NOFS);\n\t\tif (!call->buffer)\n\t\t\tgoto nomem_free;\n\t}\n\n\tinit_waitqueue_head(&call->waitq);\n\tskb_queue_head_init(&call->rx_queue);\n\treturn call;\n\nnomem_free:\n\tafs_free_call(call);\nnomem_call:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"break %zu callbacks\"",
            "ncallbacks"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "392-395",
          "snippet": "static int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_destroy_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_destroy_inode(struct inode *inode);\n\nstatic int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%zu},\"",
            "ncallbacks"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIRC_CNT",
          "args": [
            "server->cb_break_head",
            "server->cb_break_tail",
            "ARRAY_SIZE(server->cb_break)"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "server->cb_break"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic const struct afs_call_type afs_RXFSGiveUpCallBacks = {\n\t.name\t\t= \"FS.GiveUpCallBacks\",\n\t.deliver\t= afs_deliver_fs_give_up_callbacks,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\nint afs_fs_give_up_callbacks(struct afs_server *server,\n\t\t\t     const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\tsize_t ncallbacks;\n\t__be32 *bp, *tp;\n\tint loop;\n\n\tncallbacks = CIRC_CNT(server->cb_break_head, server->cb_break_tail,\n\t\t\t      ARRAY_SIZE(server->cb_break));\n\n\t_enter(\"{%zu},\", ncallbacks);\n\n\tif (ncallbacks == 0)\n\t\treturn 0;\n\tif (ncallbacks > AFSCBMAX)\n\t\tncallbacks = AFSCBMAX;\n\n\t_debug(\"break %zu callbacks\", ncallbacks);\n\n\tcall = afs_alloc_flat_call(&afs_RXFSGiveUpCallBacks,\n\t\t\t\t   12 + ncallbacks * 6 * 4, 0);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\ttp = bp + 2 + ncallbacks * 3;\n\t*bp++ = htonl(FSGIVEUPCALLBACKS);\n\t*bp++ = htonl(ncallbacks);\n\t*tp++ = htonl(ncallbacks);\n\n\tatomic_sub(ncallbacks, &server->cb_break_n);\n\tfor (loop = ncallbacks; loop > 0; loop--) {\n\t\tstruct afs_callback *cb =\n\t\t\t&server->cb_break[server->cb_break_tail];\n\n\t\t*bp++ = htonl(cb->fid.vid);\n\t\t*bp++ = htonl(cb->fid.vnode);\n\t\t*bp++ = htonl(cb->fid.unique);\n\t\t*tp++ = htonl(cb->version);\n\t\t*tp++ = htonl(cb->expiry);\n\t\t*tp++ = htonl(cb->type);\n\t\tsmp_mb();\n\t\tserver->cb_break_tail =\n\t\t\t(server->cb_break_tail + 1) &\n\t\t\t(ARRAY_SIZE(server->cb_break) - 1);\n\t}\n\n\tASSERT(ncallbacks > 0);\n\twake_up_nr(&server->cb_break_waitq, ncallbacks);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}"
  },
  {
    "function_name": "afs_deliver_fs_give_up_callbacks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
    "lines": "535-543",
    "snippet": "static int afs_deliver_fs_give_up_callbacks(struct afs_call *call,\n\t\t\t\t\t    struct sk_buff *skb, bool last)\n{\n\t_enter(\",{%u},%d\", skb->len, last);\n\n\tif (skb->len > 0)\n\t\treturn -EBADMSG; /* shouldn't be any reply data */\n\treturn 0;\n}",
    "includes": [
      "#include \"afs_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/circ_buf.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\",{%u},%d\"",
            "skb->len",
            "last"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic int afs_deliver_fs_give_up_callbacks(struct afs_call *call,\n\t\t\t\t\t    struct sk_buff *skb, bool last)\n{\n\t_enter(\",{%u},%d\", skb->len, last);\n\n\tif (skb->len > 0)\n\t\treturn -EBADMSG; /* shouldn't be any reply data */\n\treturn 0;\n}"
  },
  {
    "function_name": "afs_fs_fetch_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
    "lines": "492-530",
    "snippet": "int afs_fs_fetch_data(struct afs_server *server,\n\t\t      struct key *key,\n\t\t      struct afs_vnode *vnode,\n\t\t      off_t offset, size_t length,\n\t\t      struct page *buffer,\n\t\t      const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\tif (upper_32_bits(offset) || upper_32_bits(offset + length))\n\t\treturn afs_fs_fetch_data64(server, key, vnode, offset, length,\n\t\t\t\t\t   buffer, wait_mode);\n\n\t_enter(\"\");\n\n\tcall = afs_alloc_flat_call(&afs_RXFSFetchData, 24, (21 + 3 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->reply2 = NULL; /* volsync */\n\tcall->reply3 = buffer;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\tcall->operation_ID = FSFETCHDATA;\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\tbp[0] = htonl(FSFETCHDATA);\n\tbp[1] = htonl(vnode->fid.vid);\n\tbp[2] = htonl(vnode->fid.vnode);\n\tbp[3] = htonl(vnode->fid.unique);\n\tbp[4] = htonl(offset);\n\tbp[5] = htonl(length);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}",
    "includes": [
      "#include \"afs_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/circ_buf.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct afs_call_type afs_RXFSFetchData = {\n\t.name\t\t= \"FS.FetchData\",\n\t.deliver\t= afs_deliver_fs_fetch_data,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "afs_make_call",
          "args": [
            "&server->addr",
            "call",
            "GFP_NOFS",
            "wait_mode"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "afs_make_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "338-420",
          "snippet": "int afs_make_call(struct in_addr *addr, struct afs_call *call, gfp_t gfp,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct sockaddr_rxrpc srx;\n\tstruct rxrpc_call *rxcall;\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tint ret;\n\tstruct sk_buff *skb;\n\n\t_enter(\"%x,{%d},\", addr->s_addr, ntohs(call->port));\n\n\tASSERT(call->type != NULL);\n\tASSERT(call->type->name != NULL);\n\n\t_debug(\"____MAKE %p{%s,%x} [%d]____\",\n\t       call, call->type->name, key_serial(call->key),\n\t       atomic_read(&afs_outstanding_calls));\n\n\tcall->wait_mode = wait_mode;\n\tcall->async_workfn = afs_process_async_call;\n\tINIT_WORK(&call->async_work, afs_async_workfn);\n\n\tmemset(&srx, 0, sizeof(srx));\n\tsrx.srx_family = AF_RXRPC;\n\tsrx.srx_service = call->service_id;\n\tsrx.transport_type = SOCK_DGRAM;\n\tsrx.transport_len = sizeof(srx.transport.sin);\n\tsrx.transport.sin.sin_family = AF_INET;\n\tsrx.transport.sin.sin_port = call->port;\n\tmemcpy(&srx.transport.sin.sin_addr, addr, 4);\n\n\t/* create a call */\n\trxcall = rxrpc_kernel_begin_call(afs_socket, &srx, call->key,\n\t\t\t\t\t (unsigned long) call, gfp);\n\tcall->key = NULL;\n\tif (IS_ERR(rxcall)) {\n\t\tret = PTR_ERR(rxcall);\n\t\tgoto error_kill_call;\n\t}\n\n\tcall->rxcall = rxcall;\n\n\t/* send the request */\n\tiov[0].iov_base\t= call->request;\n\tiov[0].iov_len\t= call->request_size;\n\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1,\n\t\t      call->request_size);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= (call->send_pages ? MSG_MORE : 0);\n\n\t/* have to change the state *before* sending the last packet as RxRPC\n\t * might give us the reply before it returns from sending the\n\t * request */\n\tif (!call->send_pages)\n\t\tcall->state = AFS_CALL_AWAIT_REPLY;\n\tret = rxrpc_kernel_send_data(rxcall, &msg, call->request_size);\n\tif (ret < 0)\n\t\tgoto error_do_abort;\n\n\tif (call->send_pages) {\n\t\tret = afs_send_pages(call, &msg, iov);\n\t\tif (ret < 0)\n\t\t\tgoto error_do_abort;\n\t}\n\n\t/* at this point, an async call may no longer exist as it may have\n\t * already completed */\n\treturn wait_mode->wait(call);\n\nerror_do_abort:\n\trxrpc_kernel_abort_call(rxcall, RX_USER_ABORT);\n\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\tafs_free_skb(skb);\nerror_kill_call:\n\tafs_end_call(call);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct socket *afs_socket;",
            "static atomic_t afs_outstanding_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);",
            "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
            "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic struct socket *afs_socket;\nstatic atomic_t afs_outstanding_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\n\nint afs_make_call(struct in_addr *addr, struct afs_call *call, gfp_t gfp,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct sockaddr_rxrpc srx;\n\tstruct rxrpc_call *rxcall;\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tint ret;\n\tstruct sk_buff *skb;\n\n\t_enter(\"%x,{%d},\", addr->s_addr, ntohs(call->port));\n\n\tASSERT(call->type != NULL);\n\tASSERT(call->type->name != NULL);\n\n\t_debug(\"____MAKE %p{%s,%x} [%d]____\",\n\t       call, call->type->name, key_serial(call->key),\n\t       atomic_read(&afs_outstanding_calls));\n\n\tcall->wait_mode = wait_mode;\n\tcall->async_workfn = afs_process_async_call;\n\tINIT_WORK(&call->async_work, afs_async_workfn);\n\n\tmemset(&srx, 0, sizeof(srx));\n\tsrx.srx_family = AF_RXRPC;\n\tsrx.srx_service = call->service_id;\n\tsrx.transport_type = SOCK_DGRAM;\n\tsrx.transport_len = sizeof(srx.transport.sin);\n\tsrx.transport.sin.sin_family = AF_INET;\n\tsrx.transport.sin.sin_port = call->port;\n\tmemcpy(&srx.transport.sin.sin_addr, addr, 4);\n\n\t/* create a call */\n\trxcall = rxrpc_kernel_begin_call(afs_socket, &srx, call->key,\n\t\t\t\t\t (unsigned long) call, gfp);\n\tcall->key = NULL;\n\tif (IS_ERR(rxcall)) {\n\t\tret = PTR_ERR(rxcall);\n\t\tgoto error_kill_call;\n\t}\n\n\tcall->rxcall = rxcall;\n\n\t/* send the request */\n\tiov[0].iov_base\t= call->request;\n\tiov[0].iov_len\t= call->request_size;\n\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1,\n\t\t      call->request_size);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= (call->send_pages ? MSG_MORE : 0);\n\n\t/* have to change the state *before* sending the last packet as RxRPC\n\t * might give us the reply before it returns from sending the\n\t * request */\n\tif (!call->send_pages)\n\t\tcall->state = AFS_CALL_AWAIT_REPLY;\n\tret = rxrpc_kernel_send_data(rxcall, &msg, call->request_size);\n\tif (ret < 0)\n\t\tgoto error_do_abort;\n\n\tif (call->send_pages) {\n\t\tret = afs_send_pages(call, &msg, iov);\n\t\tif (ret < 0)\n\t\t\tgoto error_do_abort;\n\t}\n\n\t/* at this point, an async call may no longer exist as it may have\n\t * already completed */\n\treturn wait_mode->wait(call);\n\nerror_do_abort:\n\trxrpc_kernel_abort_call(rxcall, RX_USER_ABORT);\n\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\tafs_free_skb(skb);\nerror_kill_call:\n\tafs_end_call(call);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "length"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "offset"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "vnode->fid.unique"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "vnode->fid.vnode"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "vnode->fid.vid"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "FSFETCHDATA"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "AFS_FS_PORT"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_alloc_flat_call",
          "args": [
            "&afs_RXFSFetchData",
            "24",
            "(21 + 3 + 6) * 4"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "afs_alloc_flat_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "218-255",
          "snippet": "struct afs_call *afs_alloc_flat_call(const struct afs_call_type *type,\n\t\t\t\t     size_t request_size, size_t reply_size)\n{\n\tstruct afs_call *call;\n\n\tcall = kzalloc(sizeof(*call), GFP_NOFS);\n\tif (!call)\n\t\tgoto nomem_call;\n\n\t_debug(\"CALL %p{%s} [%d]\",\n\t       call, type->name, atomic_read(&afs_outstanding_calls));\n\tatomic_inc(&afs_outstanding_calls);\n\n\tcall->type = type;\n\tcall->request_size = request_size;\n\tcall->reply_max = reply_size;\n\n\tif (request_size) {\n\t\tcall->request = kmalloc(request_size, GFP_NOFS);\n\t\tif (!call->request)\n\t\t\tgoto nomem_free;\n\t}\n\n\tif (reply_size) {\n\t\tcall->buffer = kmalloc(reply_size, GFP_NOFS);\n\t\tif (!call->buffer)\n\t\t\tgoto nomem_free;\n\t}\n\n\tinit_waitqueue_head(&call->waitq);\n\tskb_queue_head_init(&call->rx_queue);\n\treturn call;\n\nnomem_free:\n\tafs_free_call(call);\nnomem_call:\n\treturn NULL;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t afs_outstanding_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic atomic_t afs_outstanding_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nstruct afs_call *afs_alloc_flat_call(const struct afs_call_type *type,\n\t\t\t\t     size_t request_size, size_t reply_size)\n{\n\tstruct afs_call *call;\n\n\tcall = kzalloc(sizeof(*call), GFP_NOFS);\n\tif (!call)\n\t\tgoto nomem_call;\n\n\t_debug(\"CALL %p{%s} [%d]\",\n\t       call, type->name, atomic_read(&afs_outstanding_calls));\n\tatomic_inc(&afs_outstanding_calls);\n\n\tcall->type = type;\n\tcall->request_size = request_size;\n\tcall->reply_max = reply_size;\n\n\tif (request_size) {\n\t\tcall->request = kmalloc(request_size, GFP_NOFS);\n\t\tif (!call->request)\n\t\t\tgoto nomem_free;\n\t}\n\n\tif (reply_size) {\n\t\tcall->buffer = kmalloc(reply_size, GFP_NOFS);\n\t\tif (!call->buffer)\n\t\t\tgoto nomem_free;\n\t}\n\n\tinit_waitqueue_head(&call->waitq);\n\tskb_queue_head_init(&call->rx_queue);\n\treturn call;\n\nnomem_free:\n\tafs_free_call(call);\nnomem_call:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_fs_fetch_data64",
          "args": [
            "server",
            "key",
            "vnode",
            "offset",
            "length",
            "buffer",
            "wait_mode"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "afs_fs_fetch_data64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
          "lines": "449-487",
          "snippet": "static int afs_fs_fetch_data64(struct afs_server *server,\n\t\t\t       struct key *key,\n\t\t\t       struct afs_vnode *vnode,\n\t\t\t       off_t offset, size_t length,\n\t\t\t       struct page *buffer,\n\t\t\t       const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tASSERTCMP(length, <, ULONG_MAX);\n\n\tcall = afs_alloc_flat_call(&afs_RXFSFetchData64, 32, (21 + 3 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->reply2 = NULL; /* volsync */\n\tcall->reply3 = buffer;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\tcall->operation_ID = FSFETCHDATA64;\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\tbp[0] = htonl(FSFETCHDATA64);\n\tbp[1] = htonl(vnode->fid.vid);\n\tbp[2] = htonl(vnode->fid.vnode);\n\tbp[3] = htonl(vnode->fid.unique);\n\tbp[4] = htonl(upper_32_bits(offset));\n\tbp[5] = htonl((u32) offset);\n\tbp[6] = 0;\n\tbp[7] = htonl((u32) length);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}",
          "includes": [
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct afs_call_type afs_RXFSFetchData64 = {\n\t.name\t\t= \"FS.FetchData64\",\n\t.deliver\t= afs_deliver_fs_fetch_data,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic const struct afs_call_type afs_RXFSFetchData64 = {\n\t.name\t\t= \"FS.FetchData64\",\n\t.deliver\t= afs_deliver_fs_fetch_data,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\nstatic int afs_fs_fetch_data64(struct afs_server *server,\n\t\t\t       struct key *key,\n\t\t\t       struct afs_vnode *vnode,\n\t\t\t       off_t offset, size_t length,\n\t\t\t       struct page *buffer,\n\t\t\t       const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tASSERTCMP(length, <, ULONG_MAX);\n\n\tcall = afs_alloc_flat_call(&afs_RXFSFetchData64, 32, (21 + 3 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->reply2 = NULL; /* volsync */\n\tcall->reply3 = buffer;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\tcall->operation_ID = FSFETCHDATA64;\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\tbp[0] = htonl(FSFETCHDATA64);\n\tbp[1] = htonl(vnode->fid.vid);\n\tbp[2] = htonl(vnode->fid.vnode);\n\tbp[3] = htonl(vnode->fid.unique);\n\tbp[4] = htonl(upper_32_bits(offset));\n\tbp[5] = htonl((u32) offset);\n\tbp[6] = 0;\n\tbp[7] = htonl((u32) length);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "upper_32_bits",
          "args": [
            "offset + length"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "upper_32_bits",
          "args": [
            "offset"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic const struct afs_call_type afs_RXFSFetchData = {\n\t.name\t\t= \"FS.FetchData\",\n\t.deliver\t= afs_deliver_fs_fetch_data,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\nint afs_fs_fetch_data(struct afs_server *server,\n\t\t      struct key *key,\n\t\t      struct afs_vnode *vnode,\n\t\t      off_t offset, size_t length,\n\t\t      struct page *buffer,\n\t\t      const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\tif (upper_32_bits(offset) || upper_32_bits(offset + length))\n\t\treturn afs_fs_fetch_data64(server, key, vnode, offset, length,\n\t\t\t\t\t   buffer, wait_mode);\n\n\t_enter(\"\");\n\n\tcall = afs_alloc_flat_call(&afs_RXFSFetchData, 24, (21 + 3 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->reply2 = NULL; /* volsync */\n\tcall->reply3 = buffer;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\tcall->operation_ID = FSFETCHDATA;\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\tbp[0] = htonl(FSFETCHDATA);\n\tbp[1] = htonl(vnode->fid.vid);\n\tbp[2] = htonl(vnode->fid.vnode);\n\tbp[3] = htonl(vnode->fid.unique);\n\tbp[4] = htonl(offset);\n\tbp[5] = htonl(length);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}"
  },
  {
    "function_name": "afs_fs_fetch_data64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
    "lines": "449-487",
    "snippet": "static int afs_fs_fetch_data64(struct afs_server *server,\n\t\t\t       struct key *key,\n\t\t\t       struct afs_vnode *vnode,\n\t\t\t       off_t offset, size_t length,\n\t\t\t       struct page *buffer,\n\t\t\t       const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tASSERTCMP(length, <, ULONG_MAX);\n\n\tcall = afs_alloc_flat_call(&afs_RXFSFetchData64, 32, (21 + 3 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->reply2 = NULL; /* volsync */\n\tcall->reply3 = buffer;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\tcall->operation_ID = FSFETCHDATA64;\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\tbp[0] = htonl(FSFETCHDATA64);\n\tbp[1] = htonl(vnode->fid.vid);\n\tbp[2] = htonl(vnode->fid.vnode);\n\tbp[3] = htonl(vnode->fid.unique);\n\tbp[4] = htonl(upper_32_bits(offset));\n\tbp[5] = htonl((u32) offset);\n\tbp[6] = 0;\n\tbp[7] = htonl((u32) length);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}",
    "includes": [
      "#include \"afs_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/circ_buf.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct afs_call_type afs_RXFSFetchData64 = {\n\t.name\t\t= \"FS.FetchData64\",\n\t.deliver\t= afs_deliver_fs_fetch_data,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "afs_make_call",
          "args": [
            "&server->addr",
            "call",
            "GFP_NOFS",
            "wait_mode"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "afs_make_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "338-420",
          "snippet": "int afs_make_call(struct in_addr *addr, struct afs_call *call, gfp_t gfp,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct sockaddr_rxrpc srx;\n\tstruct rxrpc_call *rxcall;\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tint ret;\n\tstruct sk_buff *skb;\n\n\t_enter(\"%x,{%d},\", addr->s_addr, ntohs(call->port));\n\n\tASSERT(call->type != NULL);\n\tASSERT(call->type->name != NULL);\n\n\t_debug(\"____MAKE %p{%s,%x} [%d]____\",\n\t       call, call->type->name, key_serial(call->key),\n\t       atomic_read(&afs_outstanding_calls));\n\n\tcall->wait_mode = wait_mode;\n\tcall->async_workfn = afs_process_async_call;\n\tINIT_WORK(&call->async_work, afs_async_workfn);\n\n\tmemset(&srx, 0, sizeof(srx));\n\tsrx.srx_family = AF_RXRPC;\n\tsrx.srx_service = call->service_id;\n\tsrx.transport_type = SOCK_DGRAM;\n\tsrx.transport_len = sizeof(srx.transport.sin);\n\tsrx.transport.sin.sin_family = AF_INET;\n\tsrx.transport.sin.sin_port = call->port;\n\tmemcpy(&srx.transport.sin.sin_addr, addr, 4);\n\n\t/* create a call */\n\trxcall = rxrpc_kernel_begin_call(afs_socket, &srx, call->key,\n\t\t\t\t\t (unsigned long) call, gfp);\n\tcall->key = NULL;\n\tif (IS_ERR(rxcall)) {\n\t\tret = PTR_ERR(rxcall);\n\t\tgoto error_kill_call;\n\t}\n\n\tcall->rxcall = rxcall;\n\n\t/* send the request */\n\tiov[0].iov_base\t= call->request;\n\tiov[0].iov_len\t= call->request_size;\n\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1,\n\t\t      call->request_size);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= (call->send_pages ? MSG_MORE : 0);\n\n\t/* have to change the state *before* sending the last packet as RxRPC\n\t * might give us the reply before it returns from sending the\n\t * request */\n\tif (!call->send_pages)\n\t\tcall->state = AFS_CALL_AWAIT_REPLY;\n\tret = rxrpc_kernel_send_data(rxcall, &msg, call->request_size);\n\tif (ret < 0)\n\t\tgoto error_do_abort;\n\n\tif (call->send_pages) {\n\t\tret = afs_send_pages(call, &msg, iov);\n\t\tif (ret < 0)\n\t\t\tgoto error_do_abort;\n\t}\n\n\t/* at this point, an async call may no longer exist as it may have\n\t * already completed */\n\treturn wait_mode->wait(call);\n\nerror_do_abort:\n\trxrpc_kernel_abort_call(rxcall, RX_USER_ABORT);\n\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\tafs_free_skb(skb);\nerror_kill_call:\n\tafs_end_call(call);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct socket *afs_socket;",
            "static atomic_t afs_outstanding_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);",
            "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
            "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic struct socket *afs_socket;\nstatic atomic_t afs_outstanding_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\n\nint afs_make_call(struct in_addr *addr, struct afs_call *call, gfp_t gfp,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct sockaddr_rxrpc srx;\n\tstruct rxrpc_call *rxcall;\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tint ret;\n\tstruct sk_buff *skb;\n\n\t_enter(\"%x,{%d},\", addr->s_addr, ntohs(call->port));\n\n\tASSERT(call->type != NULL);\n\tASSERT(call->type->name != NULL);\n\n\t_debug(\"____MAKE %p{%s,%x} [%d]____\",\n\t       call, call->type->name, key_serial(call->key),\n\t       atomic_read(&afs_outstanding_calls));\n\n\tcall->wait_mode = wait_mode;\n\tcall->async_workfn = afs_process_async_call;\n\tINIT_WORK(&call->async_work, afs_async_workfn);\n\n\tmemset(&srx, 0, sizeof(srx));\n\tsrx.srx_family = AF_RXRPC;\n\tsrx.srx_service = call->service_id;\n\tsrx.transport_type = SOCK_DGRAM;\n\tsrx.transport_len = sizeof(srx.transport.sin);\n\tsrx.transport.sin.sin_family = AF_INET;\n\tsrx.transport.sin.sin_port = call->port;\n\tmemcpy(&srx.transport.sin.sin_addr, addr, 4);\n\n\t/* create a call */\n\trxcall = rxrpc_kernel_begin_call(afs_socket, &srx, call->key,\n\t\t\t\t\t (unsigned long) call, gfp);\n\tcall->key = NULL;\n\tif (IS_ERR(rxcall)) {\n\t\tret = PTR_ERR(rxcall);\n\t\tgoto error_kill_call;\n\t}\n\n\tcall->rxcall = rxcall;\n\n\t/* send the request */\n\tiov[0].iov_base\t= call->request;\n\tiov[0].iov_len\t= call->request_size;\n\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1,\n\t\t      call->request_size);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= (call->send_pages ? MSG_MORE : 0);\n\n\t/* have to change the state *before* sending the last packet as RxRPC\n\t * might give us the reply before it returns from sending the\n\t * request */\n\tif (!call->send_pages)\n\t\tcall->state = AFS_CALL_AWAIT_REPLY;\n\tret = rxrpc_kernel_send_data(rxcall, &msg, call->request_size);\n\tif (ret < 0)\n\t\tgoto error_do_abort;\n\n\tif (call->send_pages) {\n\t\tret = afs_send_pages(call, &msg, iov);\n\t\tif (ret < 0)\n\t\t\tgoto error_do_abort;\n\t}\n\n\t/* at this point, an async call may no longer exist as it may have\n\t * already completed */\n\treturn wait_mode->wait(call);\n\nerror_do_abort:\n\trxrpc_kernel_abort_call(rxcall, RX_USER_ABORT);\n\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\tafs_free_skb(skb);\nerror_kill_call:\n\tafs_end_call(call);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "(u32) length"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "(u32) offset"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "upper_32_bits(offset)"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "upper_32_bits",
          "args": [
            "offset"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "vnode->fid.unique"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "vnode->fid.vnode"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "vnode->fid.vid"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "FSFETCHDATA64"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "AFS_FS_PORT"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_alloc_flat_call",
          "args": [
            "&afs_RXFSFetchData64",
            "32",
            "(21 + 3 + 6) * 4"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "afs_alloc_flat_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "218-255",
          "snippet": "struct afs_call *afs_alloc_flat_call(const struct afs_call_type *type,\n\t\t\t\t     size_t request_size, size_t reply_size)\n{\n\tstruct afs_call *call;\n\n\tcall = kzalloc(sizeof(*call), GFP_NOFS);\n\tif (!call)\n\t\tgoto nomem_call;\n\n\t_debug(\"CALL %p{%s} [%d]\",\n\t       call, type->name, atomic_read(&afs_outstanding_calls));\n\tatomic_inc(&afs_outstanding_calls);\n\n\tcall->type = type;\n\tcall->request_size = request_size;\n\tcall->reply_max = reply_size;\n\n\tif (request_size) {\n\t\tcall->request = kmalloc(request_size, GFP_NOFS);\n\t\tif (!call->request)\n\t\t\tgoto nomem_free;\n\t}\n\n\tif (reply_size) {\n\t\tcall->buffer = kmalloc(reply_size, GFP_NOFS);\n\t\tif (!call->buffer)\n\t\t\tgoto nomem_free;\n\t}\n\n\tinit_waitqueue_head(&call->waitq);\n\tskb_queue_head_init(&call->rx_queue);\n\treturn call;\n\nnomem_free:\n\tafs_free_call(call);\nnomem_call:\n\treturn NULL;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t afs_outstanding_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic atomic_t afs_outstanding_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nstruct afs_call *afs_alloc_flat_call(const struct afs_call_type *type,\n\t\t\t\t     size_t request_size, size_t reply_size)\n{\n\tstruct afs_call *call;\n\n\tcall = kzalloc(sizeof(*call), GFP_NOFS);\n\tif (!call)\n\t\tgoto nomem_call;\n\n\t_debug(\"CALL %p{%s} [%d]\",\n\t       call, type->name, atomic_read(&afs_outstanding_calls));\n\tatomic_inc(&afs_outstanding_calls);\n\n\tcall->type = type;\n\tcall->request_size = request_size;\n\tcall->reply_max = reply_size;\n\n\tif (request_size) {\n\t\tcall->request = kmalloc(request_size, GFP_NOFS);\n\t\tif (!call->request)\n\t\t\tgoto nomem_free;\n\t}\n\n\tif (reply_size) {\n\t\tcall->buffer = kmalloc(reply_size, GFP_NOFS);\n\t\tif (!call->buffer)\n\t\t\tgoto nomem_free;\n\t}\n\n\tinit_waitqueue_head(&call->waitq);\n\tskb_queue_head_init(&call->rx_queue);\n\treturn call;\n\nnomem_free:\n\tafs_free_call(call);\nnomem_call:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "length",
            "<,ULONG_MAX"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic const struct afs_call_type afs_RXFSFetchData64 = {\n\t.name\t\t= \"FS.FetchData64\",\n\t.deliver\t= afs_deliver_fs_fetch_data,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\nstatic int afs_fs_fetch_data64(struct afs_server *server,\n\t\t\t       struct key *key,\n\t\t\t       struct afs_vnode *vnode,\n\t\t\t       off_t offset, size_t length,\n\t\t\t       struct page *buffer,\n\t\t\t       const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tASSERTCMP(length, <, ULONG_MAX);\n\n\tcall = afs_alloc_flat_call(&afs_RXFSFetchData64, 32, (21 + 3 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->reply2 = NULL; /* volsync */\n\tcall->reply3 = buffer;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\tcall->operation_ID = FSFETCHDATA64;\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\tbp[0] = htonl(FSFETCHDATA64);\n\tbp[1] = htonl(vnode->fid.vid);\n\tbp[2] = htonl(vnode->fid.vnode);\n\tbp[3] = htonl(vnode->fid.unique);\n\tbp[4] = htonl(upper_32_bits(offset));\n\tbp[5] = htonl((u32) offset);\n\tbp[6] = 0;\n\tbp[7] = htonl((u32) length);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}"
  },
  {
    "function_name": "afs_deliver_fs_fetch_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
    "lines": "312-427",
    "snippet": "static int afs_deliver_fs_fetch_data(struct afs_call *call,\n\t\t\t\t     struct sk_buff *skb, bool last)\n{\n\tstruct afs_vnode *vnode = call->reply;\n\tconst __be32 *bp;\n\tstruct page *page;\n\tvoid *buffer;\n\tint ret;\n\n\t_enter(\"{%u},{%u},%d\", call->unmarshall, skb->len, last);\n\n\tswitch (call->unmarshall) {\n\tcase 0:\n\t\tcall->offset = 0;\n\t\tcall->unmarshall++;\n\t\tif (call->operation_ID != FSFETCHDATA64) {\n\t\t\tcall->unmarshall++;\n\t\t\tgoto no_msw;\n\t\t}\n\n\t\t/* extract the upper part of the returned data length of an\n\t\t * FSFETCHDATA64 op (which should always be 0 using this\n\t\t * client) */\n\tcase 1:\n\t\t_debug(\"extract data length (MSW)\");\n\t\tret = afs_extract_data(call, skb, last, &call->tmp, 4);\n\t\tswitch (ret) {\n\t\tcase 0:\t\tbreak;\n\t\tcase -EAGAIN:\treturn 0;\n\t\tdefault:\treturn ret;\n\t\t}\n\n\t\tcall->count = ntohl(call->tmp);\n\t\t_debug(\"DATA length MSW: %u\", call->count);\n\t\tif (call->count > 0)\n\t\t\treturn -EBADMSG;\n\t\tcall->offset = 0;\n\t\tcall->unmarshall++;\n\n\tno_msw:\n\t\t/* extract the returned data length */\n\tcase 2:\n\t\t_debug(\"extract data length\");\n\t\tret = afs_extract_data(call, skb, last, &call->tmp, 4);\n\t\tswitch (ret) {\n\t\tcase 0:\t\tbreak;\n\t\tcase -EAGAIN:\treturn 0;\n\t\tdefault:\treturn ret;\n\t\t}\n\n\t\tcall->count = ntohl(call->tmp);\n\t\t_debug(\"DATA length: %u\", call->count);\n\t\tif (call->count > PAGE_SIZE)\n\t\t\treturn -EBADMSG;\n\t\tcall->offset = 0;\n\t\tcall->unmarshall++;\n\n\t\t/* extract the returned data */\n\tcase 3:\n\t\t_debug(\"extract data\");\n\t\tif (call->count > 0) {\n\t\t\tpage = call->reply3;\n\t\t\tbuffer = kmap_atomic(page);\n\t\t\tret = afs_extract_data(call, skb, last, buffer,\n\t\t\t\t\t       call->count);\n\t\t\tkunmap_atomic(buffer);\n\t\t\tswitch (ret) {\n\t\t\tcase 0:\t\tbreak;\n\t\t\tcase -EAGAIN:\treturn 0;\n\t\t\tdefault:\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tcall->offset = 0;\n\t\tcall->unmarshall++;\n\n\t\t/* extract the metadata */\n\tcase 4:\n\t\tret = afs_extract_data(call, skb, last, call->buffer,\n\t\t\t\t       (21 + 3 + 6) * 4);\n\t\tswitch (ret) {\n\t\tcase 0:\t\tbreak;\n\t\tcase -EAGAIN:\treturn 0;\n\t\tdefault:\treturn ret;\n\t\t}\n\n\t\tbp = call->buffer;\n\t\txdr_decode_AFSFetchStatus(&bp, &vnode->status, vnode, NULL);\n\t\txdr_decode_AFSCallBack(&bp, vnode);\n\t\tif (call->reply2)\n\t\t\txdr_decode_AFSVolSync(&bp, call->reply2);\n\n\t\tcall->offset = 0;\n\t\tcall->unmarshall++;\n\n\tcase 5:\n\t\t_debug(\"trailer\");\n\t\tif (skb->len != 0)\n\t\t\treturn -EBADMSG;\n\t\tbreak;\n\t}\n\n\tif (!last)\n\t\treturn 0;\n\n\tif (call->count < PAGE_SIZE) {\n\t\t_debug(\"clear\");\n\t\tpage = call->reply3;\n\t\tbuffer = kmap_atomic(page);\n\t\tmemset(buffer + call->count, 0, PAGE_SIZE - call->count);\n\t\tkunmap_atomic(buffer);\n\t}\n\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}",
    "includes": [
      "#include \"afs_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/circ_buf.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = 0 [done]\""
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "buffer"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buffer + call->count",
            "0",
            "PAGE_SIZE - call->count"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"clear\""
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_decode_AFSVolSync",
          "args": [
            "&bp",
            "call->reply2"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "xdr_decode_AFSVolSync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
          "lines": "160-172",
          "snippet": "static void xdr_decode_AFSVolSync(const __be32 **_bp,\n\t\t\t\t  struct afs_volsync *volsync)\n{\n\tconst __be32 *bp = *_bp;\n\n\tvolsync->creation = ntohl(*bp++);\n\tbp++; /* spare2 */\n\tbp++; /* spare3 */\n\tbp++; /* spare4 */\n\tbp++; /* spare5 */\n\tbp++; /* spare6 */\n\t*_bp = bp;\n}",
          "includes": [
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic void xdr_decode_AFSVolSync(const __be32 **_bp,\n\t\t\t\t  struct afs_volsync *volsync)\n{\n\tconst __be32 *bp = *_bp;\n\n\tvolsync->creation = ntohl(*bp++);\n\tbp++; /* spare2 */\n\tbp++; /* spare3 */\n\tbp++; /* spare4 */\n\tbp++; /* spare5 */\n\tbp++; /* spare6 */\n\t*_bp = bp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_decode_AFSCallBack",
          "args": [
            "&bp",
            "vnode"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "xdr_decode_AFSCallBack_raw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
          "lines": "146-155",
          "snippet": "static void xdr_decode_AFSCallBack_raw(const __be32 **_bp,\n\t\t\t\t       struct afs_callback *cb)\n{\n\tconst __be32 *bp = *_bp;\n\n\tcb->version\t= ntohl(*bp++);\n\tcb->expiry\t= ntohl(*bp++);\n\tcb->type\t= ntohl(*bp++);\n\t*_bp = bp;\n}",
          "includes": [
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic void xdr_decode_AFSCallBack_raw(const __be32 **_bp,\n\t\t\t\t       struct afs_callback *cb)\n{\n\tconst __be32 *bp = *_bp;\n\n\tcb->version\t= ntohl(*bp++);\n\tcb->expiry\t= ntohl(*bp++);\n\tcb->type\t= ntohl(*bp++);\n\t*_bp = bp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_decode_AFSFetchStatus",
          "args": [
            "&bp",
            "&vnode->status",
            "vnode",
            "NULL"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "xdr_decode_AFSFetchStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
          "lines": "35-130",
          "snippet": "static void xdr_decode_AFSFetchStatus(const __be32 **_bp,\n\t\t\t\t      struct afs_file_status *status,\n\t\t\t\t      struct afs_vnode *vnode,\n\t\t\t\t      afs_dataversion_t *store_version)\n{\n\tafs_dataversion_t expected_version;\n\tconst __be32 *bp = *_bp;\n\tumode_t mode;\n\tu64 data_version, size;\n\tu32 changed = 0; /* becomes non-zero if ctime-type changes seen */\n\tkuid_t owner;\n\tkgid_t group;\n\n#define EXTRACT(DST)\t\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tu32 x = ntohl(*bp++);\t\t\\\n\t\tchanged |= DST - x;\t\t\\\n\t\tDST = x;\t\t\t\\\n\t} while (0)\n\n\tstatus->if_version = ntohl(*bp++);\n\tEXTRACT(status->type);\n\tEXTRACT(status->nlink);\n\tsize = ntohl(*bp++);\n\tdata_version = ntohl(*bp++);\n\tEXTRACT(status->author);\n\towner = make_kuid(&init_user_ns, ntohl(*bp++));\n\tchanged |= !uid_eq(owner, status->owner);\n\tstatus->owner = owner;\n\tEXTRACT(status->caller_access); /* call ticket dependent */\n\tEXTRACT(status->anon_access);\n\tEXTRACT(status->mode);\n\tEXTRACT(status->parent.vnode);\n\tEXTRACT(status->parent.unique);\n\tbp++; /* seg size */\n\tstatus->mtime_client = ntohl(*bp++);\n\tstatus->mtime_server = ntohl(*bp++);\n\tgroup = make_kgid(&init_user_ns, ntohl(*bp++));\n\tchanged |= !gid_eq(group, status->group);\n\tstatus->group = group;\n\tbp++; /* sync counter */\n\tdata_version |= (u64) ntohl(*bp++) << 32;\n\tEXTRACT(status->lock_count);\n\tsize |= (u64) ntohl(*bp++) << 32;\n\tbp++; /* spare 4 */\n\t*_bp = bp;\n\n\tif (size != status->size) {\n\t\tstatus->size = size;\n\t\tchanged |= true;\n\t}\n\tstatus->mode &= S_IALLUGO;\n\n\t_debug(\"vnode time %lx, %lx\",\n\t       status->mtime_client, status->mtime_server);\n\n\tif (vnode) {\n\t\tstatus->parent.vid = vnode->fid.vid;\n\t\tif (changed && !test_bit(AFS_VNODE_UNSET, &vnode->flags)) {\n\t\t\t_debug(\"vnode changed\");\n\t\t\ti_size_write(&vnode->vfs_inode, size);\n\t\t\tvnode->vfs_inode.i_uid = status->owner;\n\t\t\tvnode->vfs_inode.i_gid = status->group;\n\t\t\tvnode->vfs_inode.i_generation = vnode->fid.unique;\n\t\t\tset_nlink(&vnode->vfs_inode, status->nlink);\n\n\t\t\tmode = vnode->vfs_inode.i_mode;\n\t\t\tmode &= ~S_IALLUGO;\n\t\t\tmode |= status->mode;\n\t\t\tbarrier();\n\t\t\tvnode->vfs_inode.i_mode = mode;\n\t\t}\n\n\t\tvnode->vfs_inode.i_ctime.tv_sec\t= status->mtime_server;\n\t\tvnode->vfs_inode.i_mtime\t= vnode->vfs_inode.i_ctime;\n\t\tvnode->vfs_inode.i_atime\t= vnode->vfs_inode.i_ctime;\n\t\tvnode->vfs_inode.i_version\t= data_version;\n\t}\n\n\texpected_version = status->data_version;\n\tif (store_version)\n\t\texpected_version = *store_version;\n\n\tif (expected_version != data_version) {\n\t\tstatus->data_version = data_version;\n\t\tif (vnode && !test_bit(AFS_VNODE_UNSET, &vnode->flags)) {\n\t\t\t_debug(\"vnode modified %llx on {%x:%u}\",\n\t\t\t       (unsigned long long) data_version,\n\t\t\t       vnode->fid.vid, vnode->fid.vnode);\n\t\t\tset_bit(AFS_VNODE_MODIFIED, &vnode->flags);\n\t\t\tset_bit(AFS_VNODE_ZAP_DATA, &vnode->flags);\n\t\t}\n\t} else if (store_version) {\n\t\tstatus->data_version = data_version;\n\t}\n}",
          "includes": [
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic void xdr_decode_AFSFetchStatus(const __be32 **_bp,\n\t\t\t\t      struct afs_file_status *status,\n\t\t\t\t      struct afs_vnode *vnode,\n\t\t\t\t      afs_dataversion_t *store_version)\n{\n\tafs_dataversion_t expected_version;\n\tconst __be32 *bp = *_bp;\n\tumode_t mode;\n\tu64 data_version, size;\n\tu32 changed = 0; /* becomes non-zero if ctime-type changes seen */\n\tkuid_t owner;\n\tkgid_t group;\n\n#define EXTRACT(DST)\t\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tu32 x = ntohl(*bp++);\t\t\\\n\t\tchanged |= DST - x;\t\t\\\n\t\tDST = x;\t\t\t\\\n\t} while (0)\n\n\tstatus->if_version = ntohl(*bp++);\n\tEXTRACT(status->type);\n\tEXTRACT(status->nlink);\n\tsize = ntohl(*bp++);\n\tdata_version = ntohl(*bp++);\n\tEXTRACT(status->author);\n\towner = make_kuid(&init_user_ns, ntohl(*bp++));\n\tchanged |= !uid_eq(owner, status->owner);\n\tstatus->owner = owner;\n\tEXTRACT(status->caller_access); /* call ticket dependent */\n\tEXTRACT(status->anon_access);\n\tEXTRACT(status->mode);\n\tEXTRACT(status->parent.vnode);\n\tEXTRACT(status->parent.unique);\n\tbp++; /* seg size */\n\tstatus->mtime_client = ntohl(*bp++);\n\tstatus->mtime_server = ntohl(*bp++);\n\tgroup = make_kgid(&init_user_ns, ntohl(*bp++));\n\tchanged |= !gid_eq(group, status->group);\n\tstatus->group = group;\n\tbp++; /* sync counter */\n\tdata_version |= (u64) ntohl(*bp++) << 32;\n\tEXTRACT(status->lock_count);\n\tsize |= (u64) ntohl(*bp++) << 32;\n\tbp++; /* spare 4 */\n\t*_bp = bp;\n\n\tif (size != status->size) {\n\t\tstatus->size = size;\n\t\tchanged |= true;\n\t}\n\tstatus->mode &= S_IALLUGO;\n\n\t_debug(\"vnode time %lx, %lx\",\n\t       status->mtime_client, status->mtime_server);\n\n\tif (vnode) {\n\t\tstatus->parent.vid = vnode->fid.vid;\n\t\tif (changed && !test_bit(AFS_VNODE_UNSET, &vnode->flags)) {\n\t\t\t_debug(\"vnode changed\");\n\t\t\ti_size_write(&vnode->vfs_inode, size);\n\t\t\tvnode->vfs_inode.i_uid = status->owner;\n\t\t\tvnode->vfs_inode.i_gid = status->group;\n\t\t\tvnode->vfs_inode.i_generation = vnode->fid.unique;\n\t\t\tset_nlink(&vnode->vfs_inode, status->nlink);\n\n\t\t\tmode = vnode->vfs_inode.i_mode;\n\t\t\tmode &= ~S_IALLUGO;\n\t\t\tmode |= status->mode;\n\t\t\tbarrier();\n\t\t\tvnode->vfs_inode.i_mode = mode;\n\t\t}\n\n\t\tvnode->vfs_inode.i_ctime.tv_sec\t= status->mtime_server;\n\t\tvnode->vfs_inode.i_mtime\t= vnode->vfs_inode.i_ctime;\n\t\tvnode->vfs_inode.i_atime\t= vnode->vfs_inode.i_ctime;\n\t\tvnode->vfs_inode.i_version\t= data_version;\n\t}\n\n\texpected_version = status->data_version;\n\tif (store_version)\n\t\texpected_version = *store_version;\n\n\tif (expected_version != data_version) {\n\t\tstatus->data_version = data_version;\n\t\tif (vnode && !test_bit(AFS_VNODE_UNSET, &vnode->flags)) {\n\t\t\t_debug(\"vnode modified %llx on {%x:%u}\",\n\t\t\t       (unsigned long long) data_version,\n\t\t\t       vnode->fid.vid, vnode->fid.vnode);\n\t\t\tset_bit(AFS_VNODE_MODIFIED, &vnode->flags);\n\t\t\tset_bit(AFS_VNODE_ZAP_DATA, &vnode->flags);\n\t\t}\n\t} else if (store_version) {\n\t\tstatus->data_version = data_version;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_extract_data",
          "args": [
            "call",
            "skb",
            "last",
            "call->buffer",
            "(21 + 3 + 6) * 4"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "afs_extract_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "841-865",
          "snippet": "int afs_extract_data(struct afs_call *call, struct sk_buff *skb,\n\t\t     bool last, void *buf, size_t count)\n{\n\tsize_t len = skb->len;\n\n\t_enter(\"{%u},{%zu},%d,,%zu\", call->offset, len, last, count);\n\n\tASSERTCMP(call->offset, <, count);\n\n\tlen = min_t(size_t, len, count - call->offset);\n\tif (skb_copy_bits(skb, 0, buf + call->offset, len) < 0 ||\n\t    !pskb_pull(skb, len))\n\t\tBUG();\n\tcall->offset += len;\n\n\tif (call->offset < count) {\n\t\tif (last) {\n\t\t\t_leave(\" = -EBADMSG [%d < %zu]\", call->offset, count);\n\t\t\treturn -EBADMSG;\n\t\t}\n\t\t_leave(\" = -EAGAIN\");\n\t\treturn -EAGAIN;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);",
            "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
            "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\n\nint afs_extract_data(struct afs_call *call, struct sk_buff *skb,\n\t\t     bool last, void *buf, size_t count)\n{\n\tsize_t len = skb->len;\n\n\t_enter(\"{%u},{%zu},%d,,%zu\", call->offset, len, last, count);\n\n\tASSERTCMP(call->offset, <, count);\n\n\tlen = min_t(size_t, len, count - call->offset);\n\tif (skb_copy_bits(skb, 0, buf + call->offset, len) < 0 ||\n\t    !pskb_pull(skb, len))\n\t\tBUG();\n\tcall->offset += len;\n\n\tif (call->offset < count) {\n\t\tif (last) {\n\t\t\t_leave(\" = -EBADMSG [%d < %zu]\", call->offset, count);\n\t\t\treturn -EBADMSG;\n\t\t}\n\t\t_leave(\" = -EAGAIN\");\n\t\treturn -EAGAIN;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "buffer"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"DATA length: %u\"",
            "call->count"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "392-395",
          "snippet": "static int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_destroy_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_destroy_inode(struct inode *inode);\n\nstatic int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "call->tmp"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "call->tmp"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%u},{%u},%d\"",
            "call->unmarshall",
            "skb->len",
            "last"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic int afs_deliver_fs_fetch_data(struct afs_call *call,\n\t\t\t\t     struct sk_buff *skb, bool last)\n{\n\tstruct afs_vnode *vnode = call->reply;\n\tconst __be32 *bp;\n\tstruct page *page;\n\tvoid *buffer;\n\tint ret;\n\n\t_enter(\"{%u},{%u},%d\", call->unmarshall, skb->len, last);\n\n\tswitch (call->unmarshall) {\n\tcase 0:\n\t\tcall->offset = 0;\n\t\tcall->unmarshall++;\n\t\tif (call->operation_ID != FSFETCHDATA64) {\n\t\t\tcall->unmarshall++;\n\t\t\tgoto no_msw;\n\t\t}\n\n\t\t/* extract the upper part of the returned data length of an\n\t\t * FSFETCHDATA64 op (which should always be 0 using this\n\t\t * client) */\n\tcase 1:\n\t\t_debug(\"extract data length (MSW)\");\n\t\tret = afs_extract_data(call, skb, last, &call->tmp, 4);\n\t\tswitch (ret) {\n\t\tcase 0:\t\tbreak;\n\t\tcase -EAGAIN:\treturn 0;\n\t\tdefault:\treturn ret;\n\t\t}\n\n\t\tcall->count = ntohl(call->tmp);\n\t\t_debug(\"DATA length MSW: %u\", call->count);\n\t\tif (call->count > 0)\n\t\t\treturn -EBADMSG;\n\t\tcall->offset = 0;\n\t\tcall->unmarshall++;\n\n\tno_msw:\n\t\t/* extract the returned data length */\n\tcase 2:\n\t\t_debug(\"extract data length\");\n\t\tret = afs_extract_data(call, skb, last, &call->tmp, 4);\n\t\tswitch (ret) {\n\t\tcase 0:\t\tbreak;\n\t\tcase -EAGAIN:\treturn 0;\n\t\tdefault:\treturn ret;\n\t\t}\n\n\t\tcall->count = ntohl(call->tmp);\n\t\t_debug(\"DATA length: %u\", call->count);\n\t\tif (call->count > PAGE_SIZE)\n\t\t\treturn -EBADMSG;\n\t\tcall->offset = 0;\n\t\tcall->unmarshall++;\n\n\t\t/* extract the returned data */\n\tcase 3:\n\t\t_debug(\"extract data\");\n\t\tif (call->count > 0) {\n\t\t\tpage = call->reply3;\n\t\t\tbuffer = kmap_atomic(page);\n\t\t\tret = afs_extract_data(call, skb, last, buffer,\n\t\t\t\t\t       call->count);\n\t\t\tkunmap_atomic(buffer);\n\t\t\tswitch (ret) {\n\t\t\tcase 0:\t\tbreak;\n\t\t\tcase -EAGAIN:\treturn 0;\n\t\t\tdefault:\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tcall->offset = 0;\n\t\tcall->unmarshall++;\n\n\t\t/* extract the metadata */\n\tcase 4:\n\t\tret = afs_extract_data(call, skb, last, call->buffer,\n\t\t\t\t       (21 + 3 + 6) * 4);\n\t\tswitch (ret) {\n\t\tcase 0:\t\tbreak;\n\t\tcase -EAGAIN:\treturn 0;\n\t\tdefault:\treturn ret;\n\t\t}\n\n\t\tbp = call->buffer;\n\t\txdr_decode_AFSFetchStatus(&bp, &vnode->status, vnode, NULL);\n\t\txdr_decode_AFSCallBack(&bp, vnode);\n\t\tif (call->reply2)\n\t\t\txdr_decode_AFSVolSync(&bp, call->reply2);\n\n\t\tcall->offset = 0;\n\t\tcall->unmarshall++;\n\n\tcase 5:\n\t\t_debug(\"trailer\");\n\t\tif (skb->len != 0)\n\t\t\treturn -EBADMSG;\n\t\tbreak;\n\t}\n\n\tif (!last)\n\t\treturn 0;\n\n\tif (call->count < PAGE_SIZE) {\n\t\t_debug(\"clear\");\n\t\tpage = call->reply3;\n\t\tbuffer = kmap_atomic(page);\n\t\tmemset(buffer + call->count, 0, PAGE_SIZE - call->count);\n\t\tkunmap_atomic(buffer);\n\t}\n\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}"
  },
  {
    "function_name": "afs_fs_fetch_file_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
    "lines": "277-307",
    "snippet": "int afs_fs_fetch_file_status(struct afs_server *server,\n\t\t\t     struct key *key,\n\t\t\t     struct afs_vnode *vnode,\n\t\t\t     struct afs_volsync *volsync,\n\t\t\t     const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\",%x,{%x:%u},,\",\n\t       key_serial(key), vnode->fid.vid, vnode->fid.vnode);\n\n\tcall = afs_alloc_flat_call(&afs_RXFSFetchStatus, 16, (21 + 3 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->reply2 = volsync;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\tbp[0] = htonl(FSFETCHSTATUS);\n\tbp[1] = htonl(vnode->fid.vid);\n\tbp[2] = htonl(vnode->fid.vnode);\n\tbp[3] = htonl(vnode->fid.unique);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}",
    "includes": [
      "#include \"afs_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/circ_buf.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct afs_call_type afs_RXFSFetchStatus = {\n\t.name\t\t= \"FS.FetchStatus\",\n\t.deliver\t= afs_deliver_fs_fetch_status,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "afs_make_call",
          "args": [
            "&server->addr",
            "call",
            "GFP_NOFS",
            "wait_mode"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "afs_make_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "338-420",
          "snippet": "int afs_make_call(struct in_addr *addr, struct afs_call *call, gfp_t gfp,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct sockaddr_rxrpc srx;\n\tstruct rxrpc_call *rxcall;\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tint ret;\n\tstruct sk_buff *skb;\n\n\t_enter(\"%x,{%d},\", addr->s_addr, ntohs(call->port));\n\n\tASSERT(call->type != NULL);\n\tASSERT(call->type->name != NULL);\n\n\t_debug(\"____MAKE %p{%s,%x} [%d]____\",\n\t       call, call->type->name, key_serial(call->key),\n\t       atomic_read(&afs_outstanding_calls));\n\n\tcall->wait_mode = wait_mode;\n\tcall->async_workfn = afs_process_async_call;\n\tINIT_WORK(&call->async_work, afs_async_workfn);\n\n\tmemset(&srx, 0, sizeof(srx));\n\tsrx.srx_family = AF_RXRPC;\n\tsrx.srx_service = call->service_id;\n\tsrx.transport_type = SOCK_DGRAM;\n\tsrx.transport_len = sizeof(srx.transport.sin);\n\tsrx.transport.sin.sin_family = AF_INET;\n\tsrx.transport.sin.sin_port = call->port;\n\tmemcpy(&srx.transport.sin.sin_addr, addr, 4);\n\n\t/* create a call */\n\trxcall = rxrpc_kernel_begin_call(afs_socket, &srx, call->key,\n\t\t\t\t\t (unsigned long) call, gfp);\n\tcall->key = NULL;\n\tif (IS_ERR(rxcall)) {\n\t\tret = PTR_ERR(rxcall);\n\t\tgoto error_kill_call;\n\t}\n\n\tcall->rxcall = rxcall;\n\n\t/* send the request */\n\tiov[0].iov_base\t= call->request;\n\tiov[0].iov_len\t= call->request_size;\n\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1,\n\t\t      call->request_size);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= (call->send_pages ? MSG_MORE : 0);\n\n\t/* have to change the state *before* sending the last packet as RxRPC\n\t * might give us the reply before it returns from sending the\n\t * request */\n\tif (!call->send_pages)\n\t\tcall->state = AFS_CALL_AWAIT_REPLY;\n\tret = rxrpc_kernel_send_data(rxcall, &msg, call->request_size);\n\tif (ret < 0)\n\t\tgoto error_do_abort;\n\n\tif (call->send_pages) {\n\t\tret = afs_send_pages(call, &msg, iov);\n\t\tif (ret < 0)\n\t\t\tgoto error_do_abort;\n\t}\n\n\t/* at this point, an async call may no longer exist as it may have\n\t * already completed */\n\treturn wait_mode->wait(call);\n\nerror_do_abort:\n\trxrpc_kernel_abort_call(rxcall, RX_USER_ABORT);\n\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\tafs_free_skb(skb);\nerror_kill_call:\n\tafs_end_call(call);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct socket *afs_socket;",
            "static atomic_t afs_outstanding_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);",
            "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
            "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic struct socket *afs_socket;\nstatic atomic_t afs_outstanding_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\n\nint afs_make_call(struct in_addr *addr, struct afs_call *call, gfp_t gfp,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct sockaddr_rxrpc srx;\n\tstruct rxrpc_call *rxcall;\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tint ret;\n\tstruct sk_buff *skb;\n\n\t_enter(\"%x,{%d},\", addr->s_addr, ntohs(call->port));\n\n\tASSERT(call->type != NULL);\n\tASSERT(call->type->name != NULL);\n\n\t_debug(\"____MAKE %p{%s,%x} [%d]____\",\n\t       call, call->type->name, key_serial(call->key),\n\t       atomic_read(&afs_outstanding_calls));\n\n\tcall->wait_mode = wait_mode;\n\tcall->async_workfn = afs_process_async_call;\n\tINIT_WORK(&call->async_work, afs_async_workfn);\n\n\tmemset(&srx, 0, sizeof(srx));\n\tsrx.srx_family = AF_RXRPC;\n\tsrx.srx_service = call->service_id;\n\tsrx.transport_type = SOCK_DGRAM;\n\tsrx.transport_len = sizeof(srx.transport.sin);\n\tsrx.transport.sin.sin_family = AF_INET;\n\tsrx.transport.sin.sin_port = call->port;\n\tmemcpy(&srx.transport.sin.sin_addr, addr, 4);\n\n\t/* create a call */\n\trxcall = rxrpc_kernel_begin_call(afs_socket, &srx, call->key,\n\t\t\t\t\t (unsigned long) call, gfp);\n\tcall->key = NULL;\n\tif (IS_ERR(rxcall)) {\n\t\tret = PTR_ERR(rxcall);\n\t\tgoto error_kill_call;\n\t}\n\n\tcall->rxcall = rxcall;\n\n\t/* send the request */\n\tiov[0].iov_base\t= call->request;\n\tiov[0].iov_len\t= call->request_size;\n\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1,\n\t\t      call->request_size);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= (call->send_pages ? MSG_MORE : 0);\n\n\t/* have to change the state *before* sending the last packet as RxRPC\n\t * might give us the reply before it returns from sending the\n\t * request */\n\tif (!call->send_pages)\n\t\tcall->state = AFS_CALL_AWAIT_REPLY;\n\tret = rxrpc_kernel_send_data(rxcall, &msg, call->request_size);\n\tif (ret < 0)\n\t\tgoto error_do_abort;\n\n\tif (call->send_pages) {\n\t\tret = afs_send_pages(call, &msg, iov);\n\t\tif (ret < 0)\n\t\t\tgoto error_do_abort;\n\t}\n\n\t/* at this point, an async call may no longer exist as it may have\n\t * already completed */\n\treturn wait_mode->wait(call);\n\nerror_do_abort:\n\trxrpc_kernel_abort_call(rxcall, RX_USER_ABORT);\n\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\tafs_free_skb(skb);\nerror_kill_call:\n\tafs_end_call(call);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "vnode->fid.unique"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "vnode->fid.vnode"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "vnode->fid.vid"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "FSFETCHSTATUS"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "AFS_FS_PORT"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_alloc_flat_call",
          "args": [
            "&afs_RXFSFetchStatus",
            "16",
            "(21 + 3 + 6) * 4"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "afs_alloc_flat_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "218-255",
          "snippet": "struct afs_call *afs_alloc_flat_call(const struct afs_call_type *type,\n\t\t\t\t     size_t request_size, size_t reply_size)\n{\n\tstruct afs_call *call;\n\n\tcall = kzalloc(sizeof(*call), GFP_NOFS);\n\tif (!call)\n\t\tgoto nomem_call;\n\n\t_debug(\"CALL %p{%s} [%d]\",\n\t       call, type->name, atomic_read(&afs_outstanding_calls));\n\tatomic_inc(&afs_outstanding_calls);\n\n\tcall->type = type;\n\tcall->request_size = request_size;\n\tcall->reply_max = reply_size;\n\n\tif (request_size) {\n\t\tcall->request = kmalloc(request_size, GFP_NOFS);\n\t\tif (!call->request)\n\t\t\tgoto nomem_free;\n\t}\n\n\tif (reply_size) {\n\t\tcall->buffer = kmalloc(reply_size, GFP_NOFS);\n\t\tif (!call->buffer)\n\t\t\tgoto nomem_free;\n\t}\n\n\tinit_waitqueue_head(&call->waitq);\n\tskb_queue_head_init(&call->rx_queue);\n\treturn call;\n\nnomem_free:\n\tafs_free_call(call);\nnomem_call:\n\treturn NULL;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t afs_outstanding_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic atomic_t afs_outstanding_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nstruct afs_call *afs_alloc_flat_call(const struct afs_call_type *type,\n\t\t\t\t     size_t request_size, size_t reply_size)\n{\n\tstruct afs_call *call;\n\n\tcall = kzalloc(sizeof(*call), GFP_NOFS);\n\tif (!call)\n\t\tgoto nomem_call;\n\n\t_debug(\"CALL %p{%s} [%d]\",\n\t       call, type->name, atomic_read(&afs_outstanding_calls));\n\tatomic_inc(&afs_outstanding_calls);\n\n\tcall->type = type;\n\tcall->request_size = request_size;\n\tcall->reply_max = reply_size;\n\n\tif (request_size) {\n\t\tcall->request = kmalloc(request_size, GFP_NOFS);\n\t\tif (!call->request)\n\t\t\tgoto nomem_free;\n\t}\n\n\tif (reply_size) {\n\t\tcall->buffer = kmalloc(reply_size, GFP_NOFS);\n\t\tif (!call->buffer)\n\t\t\tgoto nomem_free;\n\t}\n\n\tinit_waitqueue_head(&call->waitq);\n\tskb_queue_head_init(&call->rx_queue);\n\treturn call;\n\nnomem_free:\n\tafs_free_call(call);\nnomem_call:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\",%x,{%x:%u},,\"",
            "key_serial(key)",
            "vnode->fid.vid",
            "vnode->fid.vnode"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_serial",
          "args": [
            "key"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic const struct afs_call_type afs_RXFSFetchStatus = {\n\t.name\t\t= \"FS.FetchStatus\",\n\t.deliver\t= afs_deliver_fs_fetch_status,\n\t.abort_to_error\t= afs_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\nint afs_fs_fetch_file_status(struct afs_server *server,\n\t\t\t     struct key *key,\n\t\t\t     struct afs_vnode *vnode,\n\t\t\t     struct afs_volsync *volsync,\n\t\t\t     const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\",%x,{%x:%u},,\",\n\t       key_serial(key), vnode->fid.vid, vnode->fid.vnode);\n\n\tcall = afs_alloc_flat_call(&afs_RXFSFetchStatus, 16, (21 + 3 + 6) * 4);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = vnode;\n\tcall->reply2 = volsync;\n\tcall->service_id = FS_SERVICE;\n\tcall->port = htons(AFS_FS_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\tbp[0] = htonl(FSFETCHSTATUS);\n\tbp[1] = htonl(vnode->fid.vid);\n\tbp[2] = htonl(vnode->fid.vnode);\n\tbp[3] = htonl(vnode->fid.unique);\n\n\treturn afs_make_call(&server->addr, call, GFP_NOFS, wait_mode);\n}"
  },
  {
    "function_name": "afs_deliver_fs_fetch_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
    "lines": "238-262",
    "snippet": "static int afs_deliver_fs_fetch_status(struct afs_call *call,\n\t\t\t\t       struct sk_buff *skb, bool last)\n{\n\tstruct afs_vnode *vnode = call->reply;\n\tconst __be32 *bp;\n\n\t_enter(\",,%u\", last);\n\n\tafs_transfer_reply(call, skb);\n\tif (!last)\n\t\treturn 0;\n\n\tif (call->reply_size != call->reply_max)\n\t\treturn -EBADMSG;\n\n\t/* unmarshall the reply once we've received all of it */\n\tbp = call->buffer;\n\txdr_decode_AFSFetchStatus(&bp, &vnode->status, vnode, NULL);\n\txdr_decode_AFSCallBack(&bp, vnode);\n\tif (call->reply2)\n\t\txdr_decode_AFSVolSync(&bp, call->reply2);\n\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}",
    "includes": [
      "#include \"afs_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/circ_buf.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = 0 [done]\""
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_decode_AFSVolSync",
          "args": [
            "&bp",
            "call->reply2"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "xdr_decode_AFSVolSync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
          "lines": "160-172",
          "snippet": "static void xdr_decode_AFSVolSync(const __be32 **_bp,\n\t\t\t\t  struct afs_volsync *volsync)\n{\n\tconst __be32 *bp = *_bp;\n\n\tvolsync->creation = ntohl(*bp++);\n\tbp++; /* spare2 */\n\tbp++; /* spare3 */\n\tbp++; /* spare4 */\n\tbp++; /* spare5 */\n\tbp++; /* spare6 */\n\t*_bp = bp;\n}",
          "includes": [
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic void xdr_decode_AFSVolSync(const __be32 **_bp,\n\t\t\t\t  struct afs_volsync *volsync)\n{\n\tconst __be32 *bp = *_bp;\n\n\tvolsync->creation = ntohl(*bp++);\n\tbp++; /* spare2 */\n\tbp++; /* spare3 */\n\tbp++; /* spare4 */\n\tbp++; /* spare5 */\n\tbp++; /* spare6 */\n\t*_bp = bp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_decode_AFSCallBack",
          "args": [
            "&bp",
            "vnode"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "xdr_decode_AFSCallBack_raw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
          "lines": "146-155",
          "snippet": "static void xdr_decode_AFSCallBack_raw(const __be32 **_bp,\n\t\t\t\t       struct afs_callback *cb)\n{\n\tconst __be32 *bp = *_bp;\n\n\tcb->version\t= ntohl(*bp++);\n\tcb->expiry\t= ntohl(*bp++);\n\tcb->type\t= ntohl(*bp++);\n\t*_bp = bp;\n}",
          "includes": [
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic void xdr_decode_AFSCallBack_raw(const __be32 **_bp,\n\t\t\t\t       struct afs_callback *cb)\n{\n\tconst __be32 *bp = *_bp;\n\n\tcb->version\t= ntohl(*bp++);\n\tcb->expiry\t= ntohl(*bp++);\n\tcb->type\t= ntohl(*bp++);\n\t*_bp = bp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_decode_AFSFetchStatus",
          "args": [
            "&bp",
            "&vnode->status",
            "vnode",
            "NULL"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "xdr_decode_AFSFetchStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
          "lines": "35-130",
          "snippet": "static void xdr_decode_AFSFetchStatus(const __be32 **_bp,\n\t\t\t\t      struct afs_file_status *status,\n\t\t\t\t      struct afs_vnode *vnode,\n\t\t\t\t      afs_dataversion_t *store_version)\n{\n\tafs_dataversion_t expected_version;\n\tconst __be32 *bp = *_bp;\n\tumode_t mode;\n\tu64 data_version, size;\n\tu32 changed = 0; /* becomes non-zero if ctime-type changes seen */\n\tkuid_t owner;\n\tkgid_t group;\n\n#define EXTRACT(DST)\t\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tu32 x = ntohl(*bp++);\t\t\\\n\t\tchanged |= DST - x;\t\t\\\n\t\tDST = x;\t\t\t\\\n\t} while (0)\n\n\tstatus->if_version = ntohl(*bp++);\n\tEXTRACT(status->type);\n\tEXTRACT(status->nlink);\n\tsize = ntohl(*bp++);\n\tdata_version = ntohl(*bp++);\n\tEXTRACT(status->author);\n\towner = make_kuid(&init_user_ns, ntohl(*bp++));\n\tchanged |= !uid_eq(owner, status->owner);\n\tstatus->owner = owner;\n\tEXTRACT(status->caller_access); /* call ticket dependent */\n\tEXTRACT(status->anon_access);\n\tEXTRACT(status->mode);\n\tEXTRACT(status->parent.vnode);\n\tEXTRACT(status->parent.unique);\n\tbp++; /* seg size */\n\tstatus->mtime_client = ntohl(*bp++);\n\tstatus->mtime_server = ntohl(*bp++);\n\tgroup = make_kgid(&init_user_ns, ntohl(*bp++));\n\tchanged |= !gid_eq(group, status->group);\n\tstatus->group = group;\n\tbp++; /* sync counter */\n\tdata_version |= (u64) ntohl(*bp++) << 32;\n\tEXTRACT(status->lock_count);\n\tsize |= (u64) ntohl(*bp++) << 32;\n\tbp++; /* spare 4 */\n\t*_bp = bp;\n\n\tif (size != status->size) {\n\t\tstatus->size = size;\n\t\tchanged |= true;\n\t}\n\tstatus->mode &= S_IALLUGO;\n\n\t_debug(\"vnode time %lx, %lx\",\n\t       status->mtime_client, status->mtime_server);\n\n\tif (vnode) {\n\t\tstatus->parent.vid = vnode->fid.vid;\n\t\tif (changed && !test_bit(AFS_VNODE_UNSET, &vnode->flags)) {\n\t\t\t_debug(\"vnode changed\");\n\t\t\ti_size_write(&vnode->vfs_inode, size);\n\t\t\tvnode->vfs_inode.i_uid = status->owner;\n\t\t\tvnode->vfs_inode.i_gid = status->group;\n\t\t\tvnode->vfs_inode.i_generation = vnode->fid.unique;\n\t\t\tset_nlink(&vnode->vfs_inode, status->nlink);\n\n\t\t\tmode = vnode->vfs_inode.i_mode;\n\t\t\tmode &= ~S_IALLUGO;\n\t\t\tmode |= status->mode;\n\t\t\tbarrier();\n\t\t\tvnode->vfs_inode.i_mode = mode;\n\t\t}\n\n\t\tvnode->vfs_inode.i_ctime.tv_sec\t= status->mtime_server;\n\t\tvnode->vfs_inode.i_mtime\t= vnode->vfs_inode.i_ctime;\n\t\tvnode->vfs_inode.i_atime\t= vnode->vfs_inode.i_ctime;\n\t\tvnode->vfs_inode.i_version\t= data_version;\n\t}\n\n\texpected_version = status->data_version;\n\tif (store_version)\n\t\texpected_version = *store_version;\n\n\tif (expected_version != data_version) {\n\t\tstatus->data_version = data_version;\n\t\tif (vnode && !test_bit(AFS_VNODE_UNSET, &vnode->flags)) {\n\t\t\t_debug(\"vnode modified %llx on {%x:%u}\",\n\t\t\t       (unsigned long long) data_version,\n\t\t\t       vnode->fid.vid, vnode->fid.vnode);\n\t\t\tset_bit(AFS_VNODE_MODIFIED, &vnode->flags);\n\t\t\tset_bit(AFS_VNODE_ZAP_DATA, &vnode->flags);\n\t\t}\n\t} else if (store_version) {\n\t\tstatus->data_version = data_version;\n\t}\n}",
          "includes": [
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic void xdr_decode_AFSFetchStatus(const __be32 **_bp,\n\t\t\t\t      struct afs_file_status *status,\n\t\t\t\t      struct afs_vnode *vnode,\n\t\t\t\t      afs_dataversion_t *store_version)\n{\n\tafs_dataversion_t expected_version;\n\tconst __be32 *bp = *_bp;\n\tumode_t mode;\n\tu64 data_version, size;\n\tu32 changed = 0; /* becomes non-zero if ctime-type changes seen */\n\tkuid_t owner;\n\tkgid_t group;\n\n#define EXTRACT(DST)\t\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tu32 x = ntohl(*bp++);\t\t\\\n\t\tchanged |= DST - x;\t\t\\\n\t\tDST = x;\t\t\t\\\n\t} while (0)\n\n\tstatus->if_version = ntohl(*bp++);\n\tEXTRACT(status->type);\n\tEXTRACT(status->nlink);\n\tsize = ntohl(*bp++);\n\tdata_version = ntohl(*bp++);\n\tEXTRACT(status->author);\n\towner = make_kuid(&init_user_ns, ntohl(*bp++));\n\tchanged |= !uid_eq(owner, status->owner);\n\tstatus->owner = owner;\n\tEXTRACT(status->caller_access); /* call ticket dependent */\n\tEXTRACT(status->anon_access);\n\tEXTRACT(status->mode);\n\tEXTRACT(status->parent.vnode);\n\tEXTRACT(status->parent.unique);\n\tbp++; /* seg size */\n\tstatus->mtime_client = ntohl(*bp++);\n\tstatus->mtime_server = ntohl(*bp++);\n\tgroup = make_kgid(&init_user_ns, ntohl(*bp++));\n\tchanged |= !gid_eq(group, status->group);\n\tstatus->group = group;\n\tbp++; /* sync counter */\n\tdata_version |= (u64) ntohl(*bp++) << 32;\n\tEXTRACT(status->lock_count);\n\tsize |= (u64) ntohl(*bp++) << 32;\n\tbp++; /* spare 4 */\n\t*_bp = bp;\n\n\tif (size != status->size) {\n\t\tstatus->size = size;\n\t\tchanged |= true;\n\t}\n\tstatus->mode &= S_IALLUGO;\n\n\t_debug(\"vnode time %lx, %lx\",\n\t       status->mtime_client, status->mtime_server);\n\n\tif (vnode) {\n\t\tstatus->parent.vid = vnode->fid.vid;\n\t\tif (changed && !test_bit(AFS_VNODE_UNSET, &vnode->flags)) {\n\t\t\t_debug(\"vnode changed\");\n\t\t\ti_size_write(&vnode->vfs_inode, size);\n\t\t\tvnode->vfs_inode.i_uid = status->owner;\n\t\t\tvnode->vfs_inode.i_gid = status->group;\n\t\t\tvnode->vfs_inode.i_generation = vnode->fid.unique;\n\t\t\tset_nlink(&vnode->vfs_inode, status->nlink);\n\n\t\t\tmode = vnode->vfs_inode.i_mode;\n\t\t\tmode &= ~S_IALLUGO;\n\t\t\tmode |= status->mode;\n\t\t\tbarrier();\n\t\t\tvnode->vfs_inode.i_mode = mode;\n\t\t}\n\n\t\tvnode->vfs_inode.i_ctime.tv_sec\t= status->mtime_server;\n\t\tvnode->vfs_inode.i_mtime\t= vnode->vfs_inode.i_ctime;\n\t\tvnode->vfs_inode.i_atime\t= vnode->vfs_inode.i_ctime;\n\t\tvnode->vfs_inode.i_version\t= data_version;\n\t}\n\n\texpected_version = status->data_version;\n\tif (store_version)\n\t\texpected_version = *store_version;\n\n\tif (expected_version != data_version) {\n\t\tstatus->data_version = data_version;\n\t\tif (vnode && !test_bit(AFS_VNODE_UNSET, &vnode->flags)) {\n\t\t\t_debug(\"vnode modified %llx on {%x:%u}\",\n\t\t\t       (unsigned long long) data_version,\n\t\t\t       vnode->fid.vid, vnode->fid.vnode);\n\t\t\tset_bit(AFS_VNODE_MODIFIED, &vnode->flags);\n\t\t\tset_bit(AFS_VNODE_ZAP_DATA, &vnode->flags);\n\t\t}\n\t} else if (store_version) {\n\t\tstatus->data_version = data_version;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_transfer_reply",
          "args": [
            "call",
            "skb"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "afs_transfer_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "668-675",
          "snippet": "void afs_transfer_reply(struct afs_call *call, struct sk_buff *skb)\n{\n\tsize_t len = skb->len;\n\n\tif (skb_copy_bits(skb, 0, call->buffer + call->reply_size, len) < 0)\n\t\tBUG();\n\tcall->reply_size += len;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);",
            "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
            "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\n\nvoid afs_transfer_reply(struct afs_call *call, struct sk_buff *skb)\n{\n\tsize_t len = skb->len;\n\n\tif (skb_copy_bits(skb, 0, call->buffer + call->reply_size, len) < 0)\n\t\tBUG();\n\tcall->reply_size += len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\",,%u\"",
            "last"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic int afs_deliver_fs_fetch_status(struct afs_call *call,\n\t\t\t\t       struct sk_buff *skb, bool last)\n{\n\tstruct afs_vnode *vnode = call->reply;\n\tconst __be32 *bp;\n\n\t_enter(\",,%u\", last);\n\n\tafs_transfer_reply(call, skb);\n\tif (!last)\n\t\treturn 0;\n\n\tif (call->reply_size != call->reply_max)\n\t\treturn -EBADMSG;\n\n\t/* unmarshall the reply once we've received all of it */\n\tbp = call->buffer;\n\txdr_decode_AFSFetchStatus(&bp, &vnode->status, vnode, NULL);\n\txdr_decode_AFSCallBack(&bp, vnode);\n\tif (call->reply2)\n\t\txdr_decode_AFSVolSync(&bp, call->reply2);\n\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}"
  },
  {
    "function_name": "xdr_decode_AFSFetchVolumeStatus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
    "lines": "215-233",
    "snippet": "static void xdr_decode_AFSFetchVolumeStatus(const __be32 **_bp,\n\t\t\t\t\t    struct afs_volume_status *vs)\n{\n\tconst __be32 *bp = *_bp;\n\n\tvs->vid\t\t\t= ntohl(*bp++);\n\tvs->parent_id\t\t= ntohl(*bp++);\n\tvs->online\t\t= ntohl(*bp++);\n\tvs->in_service\t\t= ntohl(*bp++);\n\tvs->blessed\t\t= ntohl(*bp++);\n\tvs->needs_salvage\t= ntohl(*bp++);\n\tvs->type\t\t= ntohl(*bp++);\n\tvs->min_quota\t\t= ntohl(*bp++);\n\tvs->max_quota\t\t= ntohl(*bp++);\n\tvs->blocks_in_use\t= ntohl(*bp++);\n\tvs->part_blocks_avail\t= ntohl(*bp++);\n\tvs->part_max_blocks\t= ntohl(*bp++);\n\t*_bp = bp;\n}",
    "includes": [
      "#include \"afs_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/circ_buf.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*bp++"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*bp++"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*bp++"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*bp++"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*bp++"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*bp++"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*bp++"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*bp++"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*bp++"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*bp++"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*bp++"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*bp++"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic void xdr_decode_AFSFetchVolumeStatus(const __be32 **_bp,\n\t\t\t\t\t    struct afs_volume_status *vs)\n{\n\tconst __be32 *bp = *_bp;\n\n\tvs->vid\t\t\t= ntohl(*bp++);\n\tvs->parent_id\t\t= ntohl(*bp++);\n\tvs->online\t\t= ntohl(*bp++);\n\tvs->in_service\t\t= ntohl(*bp++);\n\tvs->blessed\t\t= ntohl(*bp++);\n\tvs->needs_salvage\t= ntohl(*bp++);\n\tvs->type\t\t= ntohl(*bp++);\n\tvs->min_quota\t\t= ntohl(*bp++);\n\tvs->max_quota\t\t= ntohl(*bp++);\n\tvs->blocks_in_use\t= ntohl(*bp++);\n\tvs->part_blocks_avail\t= ntohl(*bp++);\n\tvs->part_max_blocks\t= ntohl(*bp++);\n\t*_bp = bp;\n}"
  },
  {
    "function_name": "xdr_encode_AFS_StoreStatus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
    "lines": "177-210",
    "snippet": "static void xdr_encode_AFS_StoreStatus(__be32 **_bp, struct iattr *attr)\n{\n\t__be32 *bp = *_bp;\n\tu32 mask = 0, mtime = 0, owner = 0, group = 0, mode = 0;\n\n\tmask = 0;\n\tif (attr->ia_valid & ATTR_MTIME) {\n\t\tmask |= AFS_SET_MTIME;\n\t\tmtime = attr->ia_mtime.tv_sec;\n\t}\n\n\tif (attr->ia_valid & ATTR_UID) {\n\t\tmask |= AFS_SET_OWNER;\n\t\towner = from_kuid(&init_user_ns, attr->ia_uid);\n\t}\n\n\tif (attr->ia_valid & ATTR_GID) {\n\t\tmask |= AFS_SET_GROUP;\n\t\tgroup = from_kgid(&init_user_ns, attr->ia_gid);\n\t}\n\n\tif (attr->ia_valid & ATTR_MODE) {\n\t\tmask |= AFS_SET_MODE;\n\t\tmode = attr->ia_mode & S_IALLUGO;\n\t}\n\n\t*bp++ = htonl(mask);\n\t*bp++ = htonl(mtime);\n\t*bp++ = htonl(owner);\n\t*bp++ = htonl(group);\n\t*bp++ = htonl(mode);\n\t*bp++ = 0;\t\t/* segment size */\n\t*_bp = bp;\n}",
    "includes": [
      "#include \"afs_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/circ_buf.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "mode"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "group"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "owner"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "mtime"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "mask"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "attr->ia_gid"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "attr->ia_uid"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic void xdr_encode_AFS_StoreStatus(__be32 **_bp, struct iattr *attr)\n{\n\t__be32 *bp = *_bp;\n\tu32 mask = 0, mtime = 0, owner = 0, group = 0, mode = 0;\n\n\tmask = 0;\n\tif (attr->ia_valid & ATTR_MTIME) {\n\t\tmask |= AFS_SET_MTIME;\n\t\tmtime = attr->ia_mtime.tv_sec;\n\t}\n\n\tif (attr->ia_valid & ATTR_UID) {\n\t\tmask |= AFS_SET_OWNER;\n\t\towner = from_kuid(&init_user_ns, attr->ia_uid);\n\t}\n\n\tif (attr->ia_valid & ATTR_GID) {\n\t\tmask |= AFS_SET_GROUP;\n\t\tgroup = from_kgid(&init_user_ns, attr->ia_gid);\n\t}\n\n\tif (attr->ia_valid & ATTR_MODE) {\n\t\tmask |= AFS_SET_MODE;\n\t\tmode = attr->ia_mode & S_IALLUGO;\n\t}\n\n\t*bp++ = htonl(mask);\n\t*bp++ = htonl(mtime);\n\t*bp++ = htonl(owner);\n\t*bp++ = htonl(group);\n\t*bp++ = htonl(mode);\n\t*bp++ = 0;\t\t/* segment size */\n\t*_bp = bp;\n}"
  },
  {
    "function_name": "xdr_decode_AFSVolSync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
    "lines": "160-172",
    "snippet": "static void xdr_decode_AFSVolSync(const __be32 **_bp,\n\t\t\t\t  struct afs_volsync *volsync)\n{\n\tconst __be32 *bp = *_bp;\n\n\tvolsync->creation = ntohl(*bp++);\n\tbp++; /* spare2 */\n\tbp++; /* spare3 */\n\tbp++; /* spare4 */\n\tbp++; /* spare5 */\n\tbp++; /* spare6 */\n\t*_bp = bp;\n}",
    "includes": [
      "#include \"afs_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/circ_buf.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*bp++"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic void xdr_decode_AFSVolSync(const __be32 **_bp,\n\t\t\t\t  struct afs_volsync *volsync)\n{\n\tconst __be32 *bp = *_bp;\n\n\tvolsync->creation = ntohl(*bp++);\n\tbp++; /* spare2 */\n\tbp++; /* spare3 */\n\tbp++; /* spare4 */\n\tbp++; /* spare5 */\n\tbp++; /* spare6 */\n\t*_bp = bp;\n}"
  },
  {
    "function_name": "xdr_decode_AFSCallBack_raw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
    "lines": "146-155",
    "snippet": "static void xdr_decode_AFSCallBack_raw(const __be32 **_bp,\n\t\t\t\t       struct afs_callback *cb)\n{\n\tconst __be32 *bp = *_bp;\n\n\tcb->version\t= ntohl(*bp++);\n\tcb->expiry\t= ntohl(*bp++);\n\tcb->type\t= ntohl(*bp++);\n\t*_bp = bp;\n}",
    "includes": [
      "#include \"afs_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/circ_buf.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*bp++"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*bp++"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*bp++"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic void xdr_decode_AFSCallBack_raw(const __be32 **_bp,\n\t\t\t\t       struct afs_callback *cb)\n{\n\tconst __be32 *bp = *_bp;\n\n\tcb->version\t= ntohl(*bp++);\n\tcb->expiry\t= ntohl(*bp++);\n\tcb->type\t= ntohl(*bp++);\n\t*_bp = bp;\n}"
  },
  {
    "function_name": "xdr_decode_AFSCallBack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
    "lines": "135-144",
    "snippet": "static void xdr_decode_AFSCallBack(const __be32 **_bp, struct afs_vnode *vnode)\n{\n\tconst __be32 *bp = *_bp;\n\n\tvnode->cb_version\t= ntohl(*bp++);\n\tvnode->cb_expiry\t= ntohl(*bp++);\n\tvnode->cb_type\t\t= ntohl(*bp++);\n\tvnode->cb_expires\t= vnode->cb_expiry + get_seconds();\n\t*_bp = bp;\n}",
    "includes": [
      "#include \"afs_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/circ_buf.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*bp++"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*bp++"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*bp++"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic void xdr_decode_AFSCallBack(const __be32 **_bp, struct afs_vnode *vnode)\n{\n\tconst __be32 *bp = *_bp;\n\n\tvnode->cb_version\t= ntohl(*bp++);\n\tvnode->cb_expiry\t= ntohl(*bp++);\n\tvnode->cb_type\t\t= ntohl(*bp++);\n\tvnode->cb_expires\t= vnode->cb_expiry + get_seconds();\n\t*_bp = bp;\n}"
  },
  {
    "function_name": "xdr_decode_AFSFetchStatus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
    "lines": "35-130",
    "snippet": "static void xdr_decode_AFSFetchStatus(const __be32 **_bp,\n\t\t\t\t      struct afs_file_status *status,\n\t\t\t\t      struct afs_vnode *vnode,\n\t\t\t\t      afs_dataversion_t *store_version)\n{\n\tafs_dataversion_t expected_version;\n\tconst __be32 *bp = *_bp;\n\tumode_t mode;\n\tu64 data_version, size;\n\tu32 changed = 0; /* becomes non-zero if ctime-type changes seen */\n\tkuid_t owner;\n\tkgid_t group;\n\n#define EXTRACT(DST)\t\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tu32 x = ntohl(*bp++);\t\t\\\n\t\tchanged |= DST - x;\t\t\\\n\t\tDST = x;\t\t\t\\\n\t} while (0)\n\n\tstatus->if_version = ntohl(*bp++);\n\tEXTRACT(status->type);\n\tEXTRACT(status->nlink);\n\tsize = ntohl(*bp++);\n\tdata_version = ntohl(*bp++);\n\tEXTRACT(status->author);\n\towner = make_kuid(&init_user_ns, ntohl(*bp++));\n\tchanged |= !uid_eq(owner, status->owner);\n\tstatus->owner = owner;\n\tEXTRACT(status->caller_access); /* call ticket dependent */\n\tEXTRACT(status->anon_access);\n\tEXTRACT(status->mode);\n\tEXTRACT(status->parent.vnode);\n\tEXTRACT(status->parent.unique);\n\tbp++; /* seg size */\n\tstatus->mtime_client = ntohl(*bp++);\n\tstatus->mtime_server = ntohl(*bp++);\n\tgroup = make_kgid(&init_user_ns, ntohl(*bp++));\n\tchanged |= !gid_eq(group, status->group);\n\tstatus->group = group;\n\tbp++; /* sync counter */\n\tdata_version |= (u64) ntohl(*bp++) << 32;\n\tEXTRACT(status->lock_count);\n\tsize |= (u64) ntohl(*bp++) << 32;\n\tbp++; /* spare 4 */\n\t*_bp = bp;\n\n\tif (size != status->size) {\n\t\tstatus->size = size;\n\t\tchanged |= true;\n\t}\n\tstatus->mode &= S_IALLUGO;\n\n\t_debug(\"vnode time %lx, %lx\",\n\t       status->mtime_client, status->mtime_server);\n\n\tif (vnode) {\n\t\tstatus->parent.vid = vnode->fid.vid;\n\t\tif (changed && !test_bit(AFS_VNODE_UNSET, &vnode->flags)) {\n\t\t\t_debug(\"vnode changed\");\n\t\t\ti_size_write(&vnode->vfs_inode, size);\n\t\t\tvnode->vfs_inode.i_uid = status->owner;\n\t\t\tvnode->vfs_inode.i_gid = status->group;\n\t\t\tvnode->vfs_inode.i_generation = vnode->fid.unique;\n\t\t\tset_nlink(&vnode->vfs_inode, status->nlink);\n\n\t\t\tmode = vnode->vfs_inode.i_mode;\n\t\t\tmode &= ~S_IALLUGO;\n\t\t\tmode |= status->mode;\n\t\t\tbarrier();\n\t\t\tvnode->vfs_inode.i_mode = mode;\n\t\t}\n\n\t\tvnode->vfs_inode.i_ctime.tv_sec\t= status->mtime_server;\n\t\tvnode->vfs_inode.i_mtime\t= vnode->vfs_inode.i_ctime;\n\t\tvnode->vfs_inode.i_atime\t= vnode->vfs_inode.i_ctime;\n\t\tvnode->vfs_inode.i_version\t= data_version;\n\t}\n\n\texpected_version = status->data_version;\n\tif (store_version)\n\t\texpected_version = *store_version;\n\n\tif (expected_version != data_version) {\n\t\tstatus->data_version = data_version;\n\t\tif (vnode && !test_bit(AFS_VNODE_UNSET, &vnode->flags)) {\n\t\t\t_debug(\"vnode modified %llx on {%x:%u}\",\n\t\t\t       (unsigned long long) data_version,\n\t\t\t       vnode->fid.vid, vnode->fid.vnode);\n\t\t\tset_bit(AFS_VNODE_MODIFIED, &vnode->flags);\n\t\t\tset_bit(AFS_VNODE_ZAP_DATA, &vnode->flags);\n\t\t}\n\t} else if (store_version) {\n\t\tstatus->data_version = data_version;\n\t}\n}",
    "includes": [
      "#include \"afs_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/circ_buf.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "AFS_VNODE_ZAP_DATA",
            "&vnode->flags"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"vnode modified %llx on {%x:%u}\"",
            "(unsigned long long) data_version",
            "vnode->fid.vid",
            "vnode->fid.vnode"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "AFS_VNODE_UNSET",
            "&vnode->flags"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "&vnode->vfs_inode",
            "status->nlink"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "&vnode->vfs_inode",
            "size"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"vnode changed\""
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*bp++"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXTRACT",
          "args": [
            "status->lock_count"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*bp++"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "group",
            "status->group"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "&init_user_ns",
            "ntohl(*bp++)"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*bp++"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*bp++"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*bp++"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXTRACT",
          "args": [
            "status->parent.unique"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXTRACT",
          "args": [
            "status->parent.vnode"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXTRACT",
          "args": [
            "status->mode"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXTRACT",
          "args": [
            "status->anon_access"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXTRACT",
          "args": [
            "status->caller_access"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "owner",
            "status->owner"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "&init_user_ns",
            "ntohl(*bp++)"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*bp++"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXTRACT",
          "args": [
            "status->author"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*bp++"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*bp++"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXTRACT",
          "args": [
            "status->nlink"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXTRACT",
          "args": [
            "status->type"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*bp++"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic void xdr_decode_AFSFetchStatus(const __be32 **_bp,\n\t\t\t\t      struct afs_file_status *status,\n\t\t\t\t      struct afs_vnode *vnode,\n\t\t\t\t      afs_dataversion_t *store_version)\n{\n\tafs_dataversion_t expected_version;\n\tconst __be32 *bp = *_bp;\n\tumode_t mode;\n\tu64 data_version, size;\n\tu32 changed = 0; /* becomes non-zero if ctime-type changes seen */\n\tkuid_t owner;\n\tkgid_t group;\n\n#define EXTRACT(DST)\t\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tu32 x = ntohl(*bp++);\t\t\\\n\t\tchanged |= DST - x;\t\t\\\n\t\tDST = x;\t\t\t\\\n\t} while (0)\n\n\tstatus->if_version = ntohl(*bp++);\n\tEXTRACT(status->type);\n\tEXTRACT(status->nlink);\n\tsize = ntohl(*bp++);\n\tdata_version = ntohl(*bp++);\n\tEXTRACT(status->author);\n\towner = make_kuid(&init_user_ns, ntohl(*bp++));\n\tchanged |= !uid_eq(owner, status->owner);\n\tstatus->owner = owner;\n\tEXTRACT(status->caller_access); /* call ticket dependent */\n\tEXTRACT(status->anon_access);\n\tEXTRACT(status->mode);\n\tEXTRACT(status->parent.vnode);\n\tEXTRACT(status->parent.unique);\n\tbp++; /* seg size */\n\tstatus->mtime_client = ntohl(*bp++);\n\tstatus->mtime_server = ntohl(*bp++);\n\tgroup = make_kgid(&init_user_ns, ntohl(*bp++));\n\tchanged |= !gid_eq(group, status->group);\n\tstatus->group = group;\n\tbp++; /* sync counter */\n\tdata_version |= (u64) ntohl(*bp++) << 32;\n\tEXTRACT(status->lock_count);\n\tsize |= (u64) ntohl(*bp++) << 32;\n\tbp++; /* spare 4 */\n\t*_bp = bp;\n\n\tif (size != status->size) {\n\t\tstatus->size = size;\n\t\tchanged |= true;\n\t}\n\tstatus->mode &= S_IALLUGO;\n\n\t_debug(\"vnode time %lx, %lx\",\n\t       status->mtime_client, status->mtime_server);\n\n\tif (vnode) {\n\t\tstatus->parent.vid = vnode->fid.vid;\n\t\tif (changed && !test_bit(AFS_VNODE_UNSET, &vnode->flags)) {\n\t\t\t_debug(\"vnode changed\");\n\t\t\ti_size_write(&vnode->vfs_inode, size);\n\t\t\tvnode->vfs_inode.i_uid = status->owner;\n\t\t\tvnode->vfs_inode.i_gid = status->group;\n\t\t\tvnode->vfs_inode.i_generation = vnode->fid.unique;\n\t\t\tset_nlink(&vnode->vfs_inode, status->nlink);\n\n\t\t\tmode = vnode->vfs_inode.i_mode;\n\t\t\tmode &= ~S_IALLUGO;\n\t\t\tmode |= status->mode;\n\t\t\tbarrier();\n\t\t\tvnode->vfs_inode.i_mode = mode;\n\t\t}\n\n\t\tvnode->vfs_inode.i_ctime.tv_sec\t= status->mtime_server;\n\t\tvnode->vfs_inode.i_mtime\t= vnode->vfs_inode.i_ctime;\n\t\tvnode->vfs_inode.i_atime\t= vnode->vfs_inode.i_ctime;\n\t\tvnode->vfs_inode.i_version\t= data_version;\n\t}\n\n\texpected_version = status->data_version;\n\tif (store_version)\n\t\texpected_version = *store_version;\n\n\tif (expected_version != data_version) {\n\t\tstatus->data_version = data_version;\n\t\tif (vnode && !test_bit(AFS_VNODE_UNSET, &vnode->flags)) {\n\t\t\t_debug(\"vnode modified %llx on {%x:%u}\",\n\t\t\t       (unsigned long long) data_version,\n\t\t\t       vnode->fid.vid, vnode->fid.vnode);\n\t\t\tset_bit(AFS_VNODE_MODIFIED, &vnode->flags);\n\t\t\tset_bit(AFS_VNODE_ZAP_DATA, &vnode->flags);\n\t\t}\n\t} else if (store_version) {\n\t\tstatus->data_version = data_version;\n\t}\n}"
  },
  {
    "function_name": "xdr_decode_AFSFid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/fsclient.c",
    "lines": "22-30",
    "snippet": "static void xdr_decode_AFSFid(const __be32 **_bp, struct afs_fid *fid)\n{\n\tconst __be32 *bp = *_bp;\n\n\tfid->vid\t\t= ntohl(*bp++);\n\tfid->vnode\t\t= ntohl(*bp++);\n\tfid->unique\t\t= ntohl(*bp++);\n\t*_bp = bp;\n}",
    "includes": [
      "#include \"afs_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/circ_buf.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*bp++"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*bp++"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*bp++"
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic void xdr_decode_AFSFid(const __be32 **_bp, struct afs_fid *fid)\n{\n\tconst __be32 *bp = *_bp;\n\n\tfid->vid\t\t= ntohl(*bp++);\n\tfid->vnode\t\t= ntohl(*bp++);\n\tfid->unique\t\t= ntohl(*bp++);\n\t*_bp = bp;\n}"
  }
]