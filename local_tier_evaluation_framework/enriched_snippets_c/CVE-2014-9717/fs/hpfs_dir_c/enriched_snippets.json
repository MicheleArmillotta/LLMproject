[
  {
    "function_name": "hpfs_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dir.c",
    "lines": "196-321",
    "snippet": "struct dentry *hpfs_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\n{\n\tconst unsigned char *name = dentry->d_name.name;\n\tunsigned len = dentry->d_name.len;\n\tstruct quad_buffer_head qbh;\n\tstruct hpfs_dirent *de;\n\tino_t ino;\n\tint err;\n\tstruct inode *result = NULL;\n\tstruct hpfs_inode_info *hpfs_result;\n\n\thpfs_lock(dir->i_sb);\n\tif ((err = hpfs_chk_name(name, &len))) {\n\t\tif (err == -ENAMETOOLONG) {\n\t\t\thpfs_unlock(dir->i_sb);\n\t\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t\t}\n\t\tgoto end_add;\n\t}\n\n\t/*\n\t * '.' and '..' will never be passed here.\n\t */\n\n\tde = map_dirent(dir, hpfs_i(dir)->i_dno, name, len, NULL, &qbh);\n\n\t/*\n\t * This is not really a bailout, just means file not found.\n\t */\n\n\tif (!de) goto end;\n\n\t/*\n\t * Get inode number, what we're after.\n\t */\n\n\tino = le32_to_cpu(de->fnode);\n\n\t/*\n\t * Go find or make an inode.\n\t */\n\n\tresult = iget_locked(dir->i_sb, ino);\n\tif (!result) {\n\t\thpfs_error(dir->i_sb, \"hpfs_lookup: can't get inode\");\n\t\tgoto bail1;\n\t}\n\tif (result->i_state & I_NEW) {\n\t\thpfs_init_inode(result);\n\t\tif (de->directory)\n\t\t\thpfs_read_inode(result);\n\t\telse if (le32_to_cpu(de->ea_size) && hpfs_sb(dir->i_sb)->sb_eas)\n\t\t\thpfs_read_inode(result);\n\t\telse {\n\t\t\tresult->i_mode |= S_IFREG;\n\t\t\tresult->i_mode &= ~0111;\n\t\t\tresult->i_op = &hpfs_file_iops;\n\t\t\tresult->i_fop = &hpfs_file_ops;\n\t\t\tset_nlink(result, 1);\n\t\t}\n\t\tunlock_new_inode(result);\n\t}\n\thpfs_result = hpfs_i(result);\n\tif (!de->directory) hpfs_result->i_parent_dir = dir->i_ino;\n\n\tif (de->has_acl || de->has_xtd_perm) if (!(dir->i_sb->s_flags & MS_RDONLY)) {\n\t\thpfs_error(result->i_sb, \"ACLs or XPERM found. This is probably HPFS386. This driver doesn't support it now. Send me some info on these structures\");\n\t\tgoto bail1;\n\t}\n\n\t/*\n\t * Fill in the info from the directory if this is a newly created\n\t * inode.\n\t */\n\n\tif (!result->i_ctime.tv_sec) {\n\t\tif (!(result->i_ctime.tv_sec = local_to_gmt(dir->i_sb, le32_to_cpu(de->creation_date))))\n\t\t\tresult->i_ctime.tv_sec = 1;\n\t\tresult->i_ctime.tv_nsec = 0;\n\t\tresult->i_mtime.tv_sec = local_to_gmt(dir->i_sb, le32_to_cpu(de->write_date));\n\t\tresult->i_mtime.tv_nsec = 0;\n\t\tresult->i_atime.tv_sec = local_to_gmt(dir->i_sb, le32_to_cpu(de->read_date));\n\t\tresult->i_atime.tv_nsec = 0;\n\t\thpfs_result->i_ea_size = le32_to_cpu(de->ea_size);\n\t\tif (!hpfs_result->i_ea_mode && de->read_only)\n\t\t\tresult->i_mode &= ~0222;\n\t\tif (!de->directory) {\n\t\t\tif (result->i_size == -1) {\n\t\t\t\tresult->i_size = le32_to_cpu(de->file_size);\n\t\t\t\tresult->i_data.a_ops = &hpfs_aops;\n\t\t\t\thpfs_i(result)->mmu_private = result->i_size;\n\t\t\t/*\n\t\t\t * i_blocks should count the fnode and any anodes.\n\t\t\t * We count 1 for the fnode and don't bother about\n\t\t\t * anodes -- the disk heads are on the directory band\n\t\t\t * and we want them to stay there.\n\t\t\t */\n\t\t\t\tresult->i_blocks = 1 + ((result->i_size + 511) >> 9);\n\t\t\t}\n\t\t}\n\t}\n\n\thpfs_brelse4(&qbh);\n\n\t/*\n\t * Made it.\n\t */\n\n\tend:\n\tend_add:\n\thpfs_unlock(dir->i_sb);\n\td_add(dentry, result);\n\treturn NULL;\n\n\t/*\n\t * Didn't.\n\t */\n\tbail1:\n\t\n\thpfs_brelse4(&qbh);\n\t\n\t/*bail:*/\n\n\thpfs_unlock(dir->i_sb);\n\treturn ERR_PTR(-ENOENT);\n}",
    "includes": [
      "#include \"hpfs_fn.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_unlock",
          "args": [
            "dir->i_sb"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "353-357",
          "snippet": "static inline void hpfs_unlock(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tmutex_unlock(&sbi->hpfs_mutex);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_unlock(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tmutex_unlock(&sbi->hpfs_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_brelse4",
          "args": [
            "&qbh"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "result"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_i",
          "args": [
            "result"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "305-308",
          "snippet": "static inline struct hpfs_inode_info *hpfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct hpfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void hpfs_truncate(struct inode *);",
            "void hpfs_init_inode(struct inode *);",
            "void hpfs_read_inode(struct inode *);",
            "void hpfs_write_inode(struct inode *);",
            "void hpfs_write_inode_nolock(struct inode *);",
            "void hpfs_write_if_changed(struct inode *);",
            "void hpfs_evict_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nvoid hpfs_truncate(struct inode *);\nvoid hpfs_init_inode(struct inode *);\nvoid hpfs_read_inode(struct inode *);\nvoid hpfs_write_inode(struct inode *);\nvoid hpfs_write_inode_nolock(struct inode *);\nvoid hpfs_write_if_changed(struct inode *);\nvoid hpfs_evict_inode(struct inode *);\n\nstatic inline struct hpfs_inode_info *hpfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct hpfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "de->file_size"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_to_gmt",
          "args": [
            "dir->i_sb",
            "le32_to_cpu(de->read_date)"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "local_to_gmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "326-330",
          "snippet": "static inline time_t local_to_gmt(struct super_block *s, time32_t t)\n{\n\textern struct timezone sys_tz;\n\treturn t + sys_tz.tz_minuteswest * 60 + hpfs_sb(s)->sb_timeshift;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline time_t local_to_gmt(struct super_block *s, time32_t t)\n{\n\textern struct timezone sys_tz;\n\treturn t + sys_tz.tz_minuteswest * 60 + hpfs_sb(s)->sb_timeshift;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_error",
          "args": [
            "result->i_sb",
            "\"ACLs or XPERM found. This is probably HPFS386. This driver doesn't support it now. Send me some info on these structures\""
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "57-86",
          "snippet": "void hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char err_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic char err_buf[1024];\n\nvoid hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "result"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "result",
            "1"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_read_inode",
          "args": [
            "result"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_read_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/inode.c",
          "lines": "43-142",
          "snippet": "void hpfs_read_inode(struct inode *i)\n{\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tstruct super_block *sb = i->i_sb;\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tvoid *ea;\n\tint ea_size;\n\n\tif (!(fnode = hpfs_map_fnode(sb, i->i_ino, &bh))) {\n\t\t/*i->i_mode |= S_IFREG;\n\t\ti->i_mode &= ~0111;\n\t\ti->i_op = &hpfs_file_iops;\n\t\ti->i_fop = &hpfs_file_ops;\n\t\tclear_nlink(i);*/\n\t\tmake_bad_inode(i);\n\t\treturn;\n\t}\n\tif (hpfs_sb(i->i_sb)->sb_eas) {\n\t\tif ((ea = hpfs_get_ea(i->i_sb, fnode, \"UID\", &ea_size))) {\n\t\t\tif (ea_size == 2) {\n\t\t\t\ti_uid_write(i, le16_to_cpu(*(__le16*)ea));\n\t\t\t\thpfs_inode->i_ea_uid = 1;\n\t\t\t}\n\t\t\tkfree(ea);\n\t\t}\n\t\tif ((ea = hpfs_get_ea(i->i_sb, fnode, \"GID\", &ea_size))) {\n\t\t\tif (ea_size == 2) {\n\t\t\t\ti_gid_write(i, le16_to_cpu(*(__le16*)ea));\n\t\t\t\thpfs_inode->i_ea_gid = 1;\n\t\t\t}\n\t\t\tkfree(ea);\n\t\t}\n\t\tif ((ea = hpfs_get_ea(i->i_sb, fnode, \"SYMLINK\", &ea_size))) {\n\t\t\tkfree(ea);\n\t\t\ti->i_mode = S_IFLNK | 0777;\n\t\t\ti->i_op = &page_symlink_inode_operations;\n\t\t\ti->i_data.a_ops = &hpfs_symlink_aops;\n\t\t\tset_nlink(i, 1);\n\t\t\ti->i_size = ea_size;\n\t\t\ti->i_blocks = 1;\n\t\t\tbrelse(bh);\n\t\t\treturn;\n\t\t}\n\t\tif ((ea = hpfs_get_ea(i->i_sb, fnode, \"MODE\", &ea_size))) {\n\t\t\tint rdev = 0;\n\t\t\tumode_t mode = hpfs_sb(sb)->sb_mode;\n\t\t\tif (ea_size == 2) {\n\t\t\t\tmode = le16_to_cpu(*(__le16*)ea);\n\t\t\t\thpfs_inode->i_ea_mode = 1;\n\t\t\t}\n\t\t\tkfree(ea);\n\t\t\ti->i_mode = mode;\n\t\t\tif (S_ISBLK(mode) || S_ISCHR(mode)) {\n\t\t\t\tif ((ea = hpfs_get_ea(i->i_sb, fnode, \"DEV\", &ea_size))) {\n\t\t\t\t\tif (ea_size == 4)\n\t\t\t\t\t\trdev = le32_to_cpu(*(__le32*)ea);\n\t\t\t\t\tkfree(ea);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (S_ISBLK(mode) || S_ISCHR(mode) || S_ISFIFO(mode) || S_ISSOCK(mode)) {\n\t\t\t\tbrelse(bh);\n\t\t\t\tset_nlink(i, 1);\n\t\t\t\ti->i_size = 0;\n\t\t\t\ti->i_blocks = 1;\n\t\t\t\tinit_special_inode(i, mode,\n\t\t\t\t\tnew_decode_dev(rdev));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tif (fnode_is_dir(fnode)) {\n\t\tint n_dnodes, n_subdirs;\n\t\ti->i_mode |= S_IFDIR;\n\t\ti->i_op = &hpfs_dir_iops;\n\t\ti->i_fop = &hpfs_dir_ops;\n\t\thpfs_inode->i_parent_dir = le32_to_cpu(fnode->up);\n\t\thpfs_inode->i_dno = le32_to_cpu(fnode->u.external[0].disk_secno);\n\t\tif (hpfs_sb(sb)->sb_chk >= 2) {\n\t\t\tstruct buffer_head *bh0;\n\t\t\tif (hpfs_map_fnode(sb, hpfs_inode->i_parent_dir, &bh0)) brelse(bh0);\n\t\t}\n\t\tn_dnodes = 0; n_subdirs = 0;\n\t\thpfs_count_dnodes(i->i_sb, hpfs_inode->i_dno, &n_dnodes, &n_subdirs, NULL);\n\t\ti->i_blocks = 4 * n_dnodes;\n\t\ti->i_size = 2048 * n_dnodes;\n\t\tset_nlink(i, 2 + n_subdirs);\n\t} else {\n\t\ti->i_mode |= S_IFREG;\n\t\tif (!hpfs_inode->i_ea_mode) i->i_mode &= ~0111;\n\t\ti->i_op = &hpfs_file_iops;\n\t\ti->i_fop = &hpfs_file_ops;\n\t\tset_nlink(i, 1);\n\t\ti->i_size = le32_to_cpu(fnode->file_size);\n\t\ti->i_blocks = ((i->i_size + 511) >> 9) + 1;\n\t\ti->i_data.a_ops = &hpfs_aops;\n\t\thpfs_i(i)->mmu_private = i->i_size;\n\t}\n\tbrelse(bh);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n\nvoid hpfs_read_inode(struct inode *i)\n{\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tstruct super_block *sb = i->i_sb;\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tvoid *ea;\n\tint ea_size;\n\n\tif (!(fnode = hpfs_map_fnode(sb, i->i_ino, &bh))) {\n\t\t/*i->i_mode |= S_IFREG;\n\t\ti->i_mode &= ~0111;\n\t\ti->i_op = &hpfs_file_iops;\n\t\ti->i_fop = &hpfs_file_ops;\n\t\tclear_nlink(i);*/\n\t\tmake_bad_inode(i);\n\t\treturn;\n\t}\n\tif (hpfs_sb(i->i_sb)->sb_eas) {\n\t\tif ((ea = hpfs_get_ea(i->i_sb, fnode, \"UID\", &ea_size))) {\n\t\t\tif (ea_size == 2) {\n\t\t\t\ti_uid_write(i, le16_to_cpu(*(__le16*)ea));\n\t\t\t\thpfs_inode->i_ea_uid = 1;\n\t\t\t}\n\t\t\tkfree(ea);\n\t\t}\n\t\tif ((ea = hpfs_get_ea(i->i_sb, fnode, \"GID\", &ea_size))) {\n\t\t\tif (ea_size == 2) {\n\t\t\t\ti_gid_write(i, le16_to_cpu(*(__le16*)ea));\n\t\t\t\thpfs_inode->i_ea_gid = 1;\n\t\t\t}\n\t\t\tkfree(ea);\n\t\t}\n\t\tif ((ea = hpfs_get_ea(i->i_sb, fnode, \"SYMLINK\", &ea_size))) {\n\t\t\tkfree(ea);\n\t\t\ti->i_mode = S_IFLNK | 0777;\n\t\t\ti->i_op = &page_symlink_inode_operations;\n\t\t\ti->i_data.a_ops = &hpfs_symlink_aops;\n\t\t\tset_nlink(i, 1);\n\t\t\ti->i_size = ea_size;\n\t\t\ti->i_blocks = 1;\n\t\t\tbrelse(bh);\n\t\t\treturn;\n\t\t}\n\t\tif ((ea = hpfs_get_ea(i->i_sb, fnode, \"MODE\", &ea_size))) {\n\t\t\tint rdev = 0;\n\t\t\tumode_t mode = hpfs_sb(sb)->sb_mode;\n\t\t\tif (ea_size == 2) {\n\t\t\t\tmode = le16_to_cpu(*(__le16*)ea);\n\t\t\t\thpfs_inode->i_ea_mode = 1;\n\t\t\t}\n\t\t\tkfree(ea);\n\t\t\ti->i_mode = mode;\n\t\t\tif (S_ISBLK(mode) || S_ISCHR(mode)) {\n\t\t\t\tif ((ea = hpfs_get_ea(i->i_sb, fnode, \"DEV\", &ea_size))) {\n\t\t\t\t\tif (ea_size == 4)\n\t\t\t\t\t\trdev = le32_to_cpu(*(__le32*)ea);\n\t\t\t\t\tkfree(ea);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (S_ISBLK(mode) || S_ISCHR(mode) || S_ISFIFO(mode) || S_ISSOCK(mode)) {\n\t\t\t\tbrelse(bh);\n\t\t\t\tset_nlink(i, 1);\n\t\t\t\ti->i_size = 0;\n\t\t\t\ti->i_blocks = 1;\n\t\t\t\tinit_special_inode(i, mode,\n\t\t\t\t\tnew_decode_dev(rdev));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tif (fnode_is_dir(fnode)) {\n\t\tint n_dnodes, n_subdirs;\n\t\ti->i_mode |= S_IFDIR;\n\t\ti->i_op = &hpfs_dir_iops;\n\t\ti->i_fop = &hpfs_dir_ops;\n\t\thpfs_inode->i_parent_dir = le32_to_cpu(fnode->up);\n\t\thpfs_inode->i_dno = le32_to_cpu(fnode->u.external[0].disk_secno);\n\t\tif (hpfs_sb(sb)->sb_chk >= 2) {\n\t\t\tstruct buffer_head *bh0;\n\t\t\tif (hpfs_map_fnode(sb, hpfs_inode->i_parent_dir, &bh0)) brelse(bh0);\n\t\t}\n\t\tn_dnodes = 0; n_subdirs = 0;\n\t\thpfs_count_dnodes(i->i_sb, hpfs_inode->i_dno, &n_dnodes, &n_subdirs, NULL);\n\t\ti->i_blocks = 4 * n_dnodes;\n\t\ti->i_size = 2048 * n_dnodes;\n\t\tset_nlink(i, 2 + n_subdirs);\n\t} else {\n\t\ti->i_mode |= S_IFREG;\n\t\tif (!hpfs_inode->i_ea_mode) i->i_mode &= ~0111;\n\t\ti->i_op = &hpfs_file_iops;\n\t\ti->i_fop = &hpfs_file_ops;\n\t\tset_nlink(i, 1);\n\t\ti->i_size = le32_to_cpu(fnode->file_size);\n\t\ti->i_blocks = ((i->i_size + 511) >> 9) + 1;\n\t\ti->i_data.a_ops = &hpfs_aops;\n\t\thpfs_i(i)->mmu_private = i->i_size;\n\t}\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "dir->i_sb"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_init_inode",
          "args": [
            "result"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_init_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/inode.c",
          "lines": "13-41",
          "snippet": "void hpfs_init_inode(struct inode *i)\n{\n\tstruct super_block *sb = i->i_sb;\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\n\ti->i_uid = hpfs_sb(sb)->sb_uid;\n\ti->i_gid = hpfs_sb(sb)->sb_gid;\n\ti->i_mode = hpfs_sb(sb)->sb_mode;\n\ti->i_size = -1;\n\ti->i_blocks = -1;\n\t\n\thpfs_inode->i_dno = 0;\n\thpfs_inode->i_n_secs = 0;\n\thpfs_inode->i_file_sec = 0;\n\thpfs_inode->i_disk_sec = 0;\n\thpfs_inode->i_dpos = 0;\n\thpfs_inode->i_dsubdno = 0;\n\thpfs_inode->i_ea_mode = 0;\n\thpfs_inode->i_ea_uid = 0;\n\thpfs_inode->i_ea_gid = 0;\n\thpfs_inode->i_ea_size = 0;\n\n\thpfs_inode->i_rddir_off = NULL;\n\thpfs_inode->i_dirty = 0;\n\n\ti->i_ctime.tv_sec = i->i_ctime.tv_nsec = 0;\n\ti->i_mtime.tv_sec = i->i_mtime.tv_nsec = 0;\n\ti->i_atime.tv_sec = i->i_atime.tv_nsec = 0;\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n\nvoid hpfs_init_inode(struct inode *i)\n{\n\tstruct super_block *sb = i->i_sb;\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\n\ti->i_uid = hpfs_sb(sb)->sb_uid;\n\ti->i_gid = hpfs_sb(sb)->sb_gid;\n\ti->i_mode = hpfs_sb(sb)->sb_mode;\n\ti->i_size = -1;\n\ti->i_blocks = -1;\n\t\n\thpfs_inode->i_dno = 0;\n\thpfs_inode->i_n_secs = 0;\n\thpfs_inode->i_file_sec = 0;\n\thpfs_inode->i_disk_sec = 0;\n\thpfs_inode->i_dpos = 0;\n\thpfs_inode->i_dsubdno = 0;\n\thpfs_inode->i_ea_mode = 0;\n\thpfs_inode->i_ea_uid = 0;\n\thpfs_inode->i_ea_gid = 0;\n\thpfs_inode->i_ea_size = 0;\n\n\thpfs_inode->i_rddir_off = NULL;\n\thpfs_inode->i_dirty = 0;\n\n\ti->i_ctime.tv_sec = i->i_ctime.tv_nsec = 0;\n\ti->i_mtime.tv_sec = i->i_mtime.tv_nsec = 0;\n\ti->i_atime.tv_sec = i->i_atime.tv_nsec = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iget_locked",
          "args": [
            "dir->i_sb",
            "ino"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "iget_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1063-1109",
          "snippet": "struct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_dirent",
          "args": [
            "dir",
            "hpfs_i(dir)->i_dno",
            "name",
            "len",
            "NULL",
            "&qbh"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "map_dirent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "907-940",
          "snippet": "struct hpfs_dirent *map_dirent(struct inode *inode, dnode_secno dno,\n\t\t\t       const unsigned char *name, unsigned len,\n\t\t\t       dnode_secno *dd, struct quad_buffer_head *qbh)\n{\n\tstruct dnode *dnode;\n\tstruct hpfs_dirent *de;\n\tstruct hpfs_dirent *de_end;\n\tint c1, c2 = 0;\n\n\tif (!S_ISDIR(inode->i_mode)) hpfs_error(inode->i_sb, \"map_dirent: not a directory\\n\");\n\tagain:\n\tif (hpfs_sb(inode->i_sb)->sb_chk)\n\t\tif (hpfs_stop_cycles(inode->i_sb, dno, &c1, &c2, \"map_dirent\")) return NULL;\n\tif (!(dnode = hpfs_map_dnode(inode->i_sb, dno, qbh))) return NULL;\n\t\n\tde_end = dnode_end_de(dnode);\n\tfor (de = dnode_first_de(dnode); de < de_end; de = de_next_de(de)) {\n\t\tint t = hpfs_compare_names(inode->i_sb, name, len, de->name, de->namelen, de->last);\n\t\tif (!t) {\n\t\t\tif (dd) *dd = dno;\n\t\t\treturn de;\n\t\t}\n\t\tif (t < 0) {\n\t\t\tif (de->down) {\n\t\t\t\tdno = de_down_pointer(de);\n\t\t\t\thpfs_brelse4(qbh);\n\t\t\t\tgoto again;\n\t\t\t}\n\t\tbreak;\n\t\t}\n\t}\n\thpfs_brelse4(qbh);\n\treturn NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct hpfs_dirent *map_dirent(struct inode *inode, dnode_secno dno,\n\t\t\t       const unsigned char *name, unsigned len,\n\t\t\t       dnode_secno *dd, struct quad_buffer_head *qbh)\n{\n\tstruct dnode *dnode;\n\tstruct hpfs_dirent *de;\n\tstruct hpfs_dirent *de_end;\n\tint c1, c2 = 0;\n\n\tif (!S_ISDIR(inode->i_mode)) hpfs_error(inode->i_sb, \"map_dirent: not a directory\\n\");\n\tagain:\n\tif (hpfs_sb(inode->i_sb)->sb_chk)\n\t\tif (hpfs_stop_cycles(inode->i_sb, dno, &c1, &c2, \"map_dirent\")) return NULL;\n\tif (!(dnode = hpfs_map_dnode(inode->i_sb, dno, qbh))) return NULL;\n\t\n\tde_end = dnode_end_de(dnode);\n\tfor (de = dnode_first_de(dnode); de < de_end; de = de_next_de(de)) {\n\t\tint t = hpfs_compare_names(inode->i_sb, name, len, de->name, de->namelen, de->last);\n\t\tif (!t) {\n\t\t\tif (dd) *dd = dno;\n\t\t\treturn de;\n\t\t}\n\t\tif (t < 0) {\n\t\t\tif (de->down) {\n\t\t\t\tdno = de_down_pointer(de);\n\t\t\t\thpfs_brelse4(qbh);\n\t\t\t\tgoto again;\n\t\t\t}\n\t\tbreak;\n\t\t}\n\t}\n\thpfs_brelse4(qbh);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENAMETOOLONG"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_chk_name",
          "args": [
            "name",
            "&len"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_chk_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/name.c",
          "lines": "41-51",
          "snippet": "int hpfs_chk_name(const unsigned char *name, unsigned *len)\n{\n\tint i;\n\tif (*len > 254) return -ENAMETOOLONG;\n\thpfs_adjust_length(name, len);\n\tif (!*len) return -EINVAL;\n\tfor (i = 0; i < *len; i++) if (not_allowed_char(name[i])) return -EINVAL;\n\tif (*len == 1) if (name[0] == '.') return -EINVAL;\n\tif (*len == 2) if (name[0] == '.' && name[1] == '.') return -EINVAL;\n\treturn 0;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_chk_name(const unsigned char *name, unsigned *len)\n{\n\tint i;\n\tif (*len > 254) return -ENAMETOOLONG;\n\thpfs_adjust_length(name, len);\n\tif (!*len) return -EINVAL;\n\tfor (i = 0; i < *len; i++) if (not_allowed_char(name[i])) return -EINVAL;\n\tif (*len == 1) if (name[0] == '.') return -EINVAL;\n\tif (*len == 2) if (name[0] == '.' && name[1] == '.') return -EINVAL;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_lock",
          "args": [
            "dir->i_sb"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/slab.h>\n\nstruct dentry *hpfs_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\n{\n\tconst unsigned char *name = dentry->d_name.name;\n\tunsigned len = dentry->d_name.len;\n\tstruct quad_buffer_head qbh;\n\tstruct hpfs_dirent *de;\n\tino_t ino;\n\tint err;\n\tstruct inode *result = NULL;\n\tstruct hpfs_inode_info *hpfs_result;\n\n\thpfs_lock(dir->i_sb);\n\tif ((err = hpfs_chk_name(name, &len))) {\n\t\tif (err == -ENAMETOOLONG) {\n\t\t\thpfs_unlock(dir->i_sb);\n\t\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t\t}\n\t\tgoto end_add;\n\t}\n\n\t/*\n\t * '.' and '..' will never be passed here.\n\t */\n\n\tde = map_dirent(dir, hpfs_i(dir)->i_dno, name, len, NULL, &qbh);\n\n\t/*\n\t * This is not really a bailout, just means file not found.\n\t */\n\n\tif (!de) goto end;\n\n\t/*\n\t * Get inode number, what we're after.\n\t */\n\n\tino = le32_to_cpu(de->fnode);\n\n\t/*\n\t * Go find or make an inode.\n\t */\n\n\tresult = iget_locked(dir->i_sb, ino);\n\tif (!result) {\n\t\thpfs_error(dir->i_sb, \"hpfs_lookup: can't get inode\");\n\t\tgoto bail1;\n\t}\n\tif (result->i_state & I_NEW) {\n\t\thpfs_init_inode(result);\n\t\tif (de->directory)\n\t\t\thpfs_read_inode(result);\n\t\telse if (le32_to_cpu(de->ea_size) && hpfs_sb(dir->i_sb)->sb_eas)\n\t\t\thpfs_read_inode(result);\n\t\telse {\n\t\t\tresult->i_mode |= S_IFREG;\n\t\t\tresult->i_mode &= ~0111;\n\t\t\tresult->i_op = &hpfs_file_iops;\n\t\t\tresult->i_fop = &hpfs_file_ops;\n\t\t\tset_nlink(result, 1);\n\t\t}\n\t\tunlock_new_inode(result);\n\t}\n\thpfs_result = hpfs_i(result);\n\tif (!de->directory) hpfs_result->i_parent_dir = dir->i_ino;\n\n\tif (de->has_acl || de->has_xtd_perm) if (!(dir->i_sb->s_flags & MS_RDONLY)) {\n\t\thpfs_error(result->i_sb, \"ACLs or XPERM found. This is probably HPFS386. This driver doesn't support it now. Send me some info on these structures\");\n\t\tgoto bail1;\n\t}\n\n\t/*\n\t * Fill in the info from the directory if this is a newly created\n\t * inode.\n\t */\n\n\tif (!result->i_ctime.tv_sec) {\n\t\tif (!(result->i_ctime.tv_sec = local_to_gmt(dir->i_sb, le32_to_cpu(de->creation_date))))\n\t\t\tresult->i_ctime.tv_sec = 1;\n\t\tresult->i_ctime.tv_nsec = 0;\n\t\tresult->i_mtime.tv_sec = local_to_gmt(dir->i_sb, le32_to_cpu(de->write_date));\n\t\tresult->i_mtime.tv_nsec = 0;\n\t\tresult->i_atime.tv_sec = local_to_gmt(dir->i_sb, le32_to_cpu(de->read_date));\n\t\tresult->i_atime.tv_nsec = 0;\n\t\thpfs_result->i_ea_size = le32_to_cpu(de->ea_size);\n\t\tif (!hpfs_result->i_ea_mode && de->read_only)\n\t\t\tresult->i_mode &= ~0222;\n\t\tif (!de->directory) {\n\t\t\tif (result->i_size == -1) {\n\t\t\t\tresult->i_size = le32_to_cpu(de->file_size);\n\t\t\t\tresult->i_data.a_ops = &hpfs_aops;\n\t\t\t\thpfs_i(result)->mmu_private = result->i_size;\n\t\t\t/*\n\t\t\t * i_blocks should count the fnode and any anodes.\n\t\t\t * We count 1 for the fnode and don't bother about\n\t\t\t * anodes -- the disk heads are on the directory band\n\t\t\t * and we want them to stay there.\n\t\t\t */\n\t\t\t\tresult->i_blocks = 1 + ((result->i_size + 511) >> 9);\n\t\t\t}\n\t\t}\n\t}\n\n\thpfs_brelse4(&qbh);\n\n\t/*\n\t * Made it.\n\t */\n\n\tend:\n\tend_add:\n\thpfs_unlock(dir->i_sb);\n\td_add(dentry, result);\n\treturn NULL;\n\n\t/*\n\t * Didn't.\n\t */\n\tbail1:\n\t\n\thpfs_brelse4(&qbh);\n\t\n\t/*bail:*/\n\n\thpfs_unlock(dir->i_sb);\n\treturn ERR_PTR(-ENOENT);\n}"
  },
  {
    "function_name": "hpfs_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dir.c",
    "lines": "60-179",
    "snippet": "static int hpfs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(inode);\n\tstruct quad_buffer_head qbh;\n\tstruct hpfs_dirent *de;\n\tint lc;\n\tloff_t next_pos;\n\tunsigned char *tempname;\n\tint c1, c2 = 0;\n\tint ret = 0;\n\n\thpfs_lock(inode->i_sb);\n\n\tif (hpfs_sb(inode->i_sb)->sb_chk) {\n\t\tif (hpfs_chk_sectors(inode->i_sb, inode->i_ino, 1, \"dir_fnode\")) {\n\t\t\tret = -EFSERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif (hpfs_chk_sectors(inode->i_sb, hpfs_inode->i_dno, 4, \"dir_dnode\")) {\n\t\t\tret = -EFSERROR;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (hpfs_sb(inode->i_sb)->sb_chk >= 2) {\n\t\tstruct buffer_head *bh;\n\t\tstruct fnode *fno;\n\t\tint e = 0;\n\t\tif (!(fno = hpfs_map_fnode(inode->i_sb, inode->i_ino, &bh))) {\n\t\t\tret = -EIOERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!fnode_is_dir(fno)) {\n\t\t\te = 1;\n\t\t\thpfs_error(inode->i_sb, \"not a directory, fnode %08lx\",\n\t\t\t\t\t(unsigned long)inode->i_ino);\n\t\t}\n\t\tif (hpfs_inode->i_dno != le32_to_cpu(fno->u.external[0].disk_secno)) {\n\t\t\te = 1;\n\t\t\thpfs_error(inode->i_sb, \"corrupted inode: i_dno == %08x, fnode -> dnode == %08x\", hpfs_inode->i_dno, le32_to_cpu(fno->u.external[0].disk_secno));\n\t\t}\n\t\tbrelse(bh);\n\t\tif (e) {\n\t\t\tret = -EFSERROR;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tlc = hpfs_sb(inode->i_sb)->sb_lowercase;\n\tif (ctx->pos == 12) { /* diff -r requires this (note, that diff -r */\n\t\tctx->pos = 13; /* also fails on msdos filesystem in 2.0) */\n\t\tgoto out;\n\t}\n\tif (ctx->pos == 13) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\t\n\twhile (1) {\n\t\tagain:\n\t\t/* This won't work when cycle is longer than number of dirents\n\t\t   accepted by filldir, but what can I do?\n\t\t   maybe killall -9 ls helps */\n\t\tif (hpfs_sb(inode->i_sb)->sb_chk)\n\t\t\tif (hpfs_stop_cycles(inode->i_sb, ctx->pos, &c1, &c2, \"hpfs_readdir\")) {\n\t\t\t\tret = -EFSERROR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\tif (ctx->pos == 12)\n\t\t\tgoto out;\n\t\tif (ctx->pos == 3 || ctx->pos == 4 || ctx->pos == 5) {\n\t\t\tpr_err(\"pos==%d\\n\", (int)ctx->pos);\n\t\t\tgoto out;\n\t\t}\n\t\tif (ctx->pos == 0) {\n\t\t\tif (!dir_emit_dot(file, ctx))\n\t\t\t\tgoto out;\n\t\t\tctx->pos = 11;\n\t\t}\n\t\tif (ctx->pos == 11) {\n\t\t\tif (!dir_emit(ctx, \"..\", 2, hpfs_inode->i_parent_dir, DT_DIR))\n\t\t\t\tgoto out;\n\t\t\tctx->pos = 1;\n\t\t}\n\t\tif (ctx->pos == 1) {\n\t\t\tctx->pos = ((loff_t) hpfs_de_as_down_as_possible(inode->i_sb, hpfs_inode->i_dno) << 4) + 1;\n\t\t\thpfs_add_pos(inode, &file->f_pos);\n\t\t\tfile->f_version = inode->i_version;\n\t\t}\n\t\tnext_pos = ctx->pos;\n\t\tif (!(de = map_pos_dirent(inode, &next_pos, &qbh))) {\n\t\t\tctx->pos = next_pos;\n\t\t\tret = -EIOERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif (de->first || de->last) {\n\t\t\tif (hpfs_sb(inode->i_sb)->sb_chk) {\n\t\t\t\tif (de->first && !de->last && (de->namelen != 2\n\t\t\t\t    || de ->name[0] != 1 || de->name[1] != 1))\n\t\t\t\t\thpfs_error(inode->i_sb, \"hpfs_readdir: bad ^A^A entry; pos = %08lx\", (unsigned long)ctx->pos);\n\t\t\t\tif (de->last && (de->namelen != 1 || de ->name[0] != 255))\n\t\t\t\t\thpfs_error(inode->i_sb, \"hpfs_readdir: bad \\\\377 entry; pos = %08lx\", (unsigned long)ctx->pos);\n\t\t\t}\n\t\t\thpfs_brelse4(&qbh);\n\t\t\tctx->pos = next_pos;\n\t\t\tgoto again;\n\t\t}\n\t\ttempname = hpfs_translate_name(inode->i_sb, de->name, de->namelen, lc, de->not_8x3);\n\t\tif (!dir_emit(ctx, tempname, de->namelen, le32_to_cpu(de->fnode), DT_UNKNOWN)) {\n\t\t\tif (tempname != de->name) kfree(tempname);\n\t\t\thpfs_brelse4(&qbh);\n\t\t\tgoto out;\n\t\t}\n\t\tctx->pos = next_pos;\n\t\tif (tempname != de->name) kfree(tempname);\n\t\thpfs_brelse4(&qbh);\n\t}\nout:\n\thpfs_unlock(inode->i_sb);\n\treturn ret;\n}",
    "includes": [
      "#include \"hpfs_fn.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_unlock",
          "args": [
            "inode->i_sb"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "353-357",
          "snippet": "static inline void hpfs_unlock(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tmutex_unlock(&sbi->hpfs_mutex);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_unlock(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tmutex_unlock(&sbi->hpfs_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_brelse4",
          "args": [
            "&qbh"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tempname"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tempname"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "tempname",
            "de->namelen",
            "le32_to_cpu(de->fnode)",
            "DT_UNKNOWN"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "de->fnode"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_translate_name",
          "args": [
            "inode->i_sb",
            "de->name",
            "de->namelen",
            "lc",
            "de->not_8x3"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_translate_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/name.c",
          "lines": "53-72",
          "snippet": "unsigned char *hpfs_translate_name(struct super_block *s, unsigned char *from,\n\t\t\t  unsigned len, int lc, int lng)\n{\n\tunsigned char *to;\n\tint i;\n\tif (hpfs_sb(s)->sb_chk >= 2) if (hpfs_is_name_long(from, len) != lng) {\n\t\tpr_err(\"Long name flag mismatch - name \");\n\t\tfor (i = 0; i < len; i++)\n\t\t\tpr_cont(\"%c\", from[i]);\n\t\tpr_cont(\" misidentified as %s.\\n\", lng ? \"short\" : \"long\");\n\t\tpr_err(\"It's nothing serious. It could happen because of bug in OS/2.\\nSet checks=normal to disable this message.\\n\");\n\t}\n\tif (!lc) return from;\n\tif (!(to = kmalloc(len, GFP_KERNEL))) {\n\t\tpr_err(\"can't allocate memory for name conversion buffer\\n\");\n\t\treturn from;\n\t}\n\tfor (i = 0; i < len; i++) to[i] = locase(hpfs_sb(s)->sb_cp_table,from[i]);\n\treturn to;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nunsigned char *hpfs_translate_name(struct super_block *s, unsigned char *from,\n\t\t\t  unsigned len, int lc, int lng)\n{\n\tunsigned char *to;\n\tint i;\n\tif (hpfs_sb(s)->sb_chk >= 2) if (hpfs_is_name_long(from, len) != lng) {\n\t\tpr_err(\"Long name flag mismatch - name \");\n\t\tfor (i = 0; i < len; i++)\n\t\t\tpr_cont(\"%c\", from[i]);\n\t\tpr_cont(\" misidentified as %s.\\n\", lng ? \"short\" : \"long\");\n\t\tpr_err(\"It's nothing serious. It could happen because of bug in OS/2.\\nSet checks=normal to disable this message.\\n\");\n\t}\n\tif (!lc) return from;\n\tif (!(to = kmalloc(len, GFP_KERNEL))) {\n\t\tpr_err(\"can't allocate memory for name conversion buffer\\n\");\n\t\treturn from;\n\t}\n\tfor (i = 0; i < len; i++) to[i] = locase(hpfs_sb(s)->sb_cp_table,from[i]);\n\treturn to;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_error",
          "args": [
            "inode->i_sb",
            "\"hpfs_readdir: bad \\\\377 entry; pos = %08lx\"",
            "(unsigned long)ctx->pos"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "57-86",
          "snippet": "void hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char err_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic char err_buf[1024];\n\nvoid hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "inode->i_sb"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_pos_dirent",
          "args": [
            "inode",
            "&next_pos",
            "&qbh"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "map_pos_dirent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "842-903",
          "snippet": "struct hpfs_dirent *map_pos_dirent(struct inode *inode, loff_t *posp,\n\t\t\t\t   struct quad_buffer_head *qbh)\n{\n\tloff_t pos;\n\tunsigned c;\n\tdnode_secno dno;\n\tstruct hpfs_dirent *de, *d;\n\tstruct hpfs_dirent *up_de;\n\tstruct hpfs_dirent *end_up_de;\n\tstruct dnode *dnode;\n\tstruct dnode *up_dnode;\n\tstruct quad_buffer_head qbh0;\n\n\tpos = *posp;\n\tdno = pos >> 6 << 2;\n\tpos &= 077;\n\tif (!(de = map_nth_dirent(inode->i_sb, dno, pos, qbh, &dnode)))\n\t\tgoto bail;\n\n\t/* Going to the next dirent */\n\tif ((d = de_next_de(de)) < dnode_end_de(dnode)) {\n\t\tif (!(++*posp & 077)) {\n\t\t\thpfs_error(inode->i_sb,\n\t\t\t\t\"map_pos_dirent: pos crossed dnode boundary; pos = %08llx\",\n\t\t\t\t(unsigned long long)*posp);\n\t\t\tgoto bail;\n\t\t}\n\t\t/* We're going down the tree */\n\t\tif (d->down) {\n\t\t\t*posp = ((loff_t) hpfs_de_as_down_as_possible(inode->i_sb, de_down_pointer(d)) << 4) + 1;\n\t\t}\n\t\n\t\treturn de;\n\t}\n\n\t/* Going up */\n\tif (dnode->root_dnode) goto bail;\n\n\tif (!(up_dnode = hpfs_map_dnode(inode->i_sb, le32_to_cpu(dnode->up), &qbh0)))\n\t\tgoto bail;\n\n\tend_up_de = dnode_end_de(up_dnode);\n\tc = 0;\n\tfor (up_de = dnode_first_de(up_dnode); up_de < end_up_de;\n\t     up_de = de_next_de(up_de)) {\n\t\tif (!(++c & 077)) hpfs_error(inode->i_sb,\n\t\t\t\"map_pos_dirent: pos crossed dnode boundary; dnode = %08x\", le32_to_cpu(dnode->up));\n\t\tif (up_de->down && de_down_pointer(up_de) == dno) {\n\t\t\t*posp = ((loff_t) le32_to_cpu(dnode->up) << 4) + c;\n\t\t\thpfs_brelse4(&qbh0);\n\t\t\treturn de;\n\t\t}\n\t}\n\t\n\thpfs_error(inode->i_sb, \"map_pos_dirent: pointer to dnode %08x not found in parent dnode %08x\",\n\t\tdno, le32_to_cpu(dnode->up));\n\thpfs_brelse4(&qbh0);\n\t\n\tbail:\n\t*posp = 12;\n\treturn de;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct hpfs_dirent *map_pos_dirent(struct inode *inode, loff_t *posp,\n\t\t\t\t   struct quad_buffer_head *qbh)\n{\n\tloff_t pos;\n\tunsigned c;\n\tdnode_secno dno;\n\tstruct hpfs_dirent *de, *d;\n\tstruct hpfs_dirent *up_de;\n\tstruct hpfs_dirent *end_up_de;\n\tstruct dnode *dnode;\n\tstruct dnode *up_dnode;\n\tstruct quad_buffer_head qbh0;\n\n\tpos = *posp;\n\tdno = pos >> 6 << 2;\n\tpos &= 077;\n\tif (!(de = map_nth_dirent(inode->i_sb, dno, pos, qbh, &dnode)))\n\t\tgoto bail;\n\n\t/* Going to the next dirent */\n\tif ((d = de_next_de(de)) < dnode_end_de(dnode)) {\n\t\tif (!(++*posp & 077)) {\n\t\t\thpfs_error(inode->i_sb,\n\t\t\t\t\"map_pos_dirent: pos crossed dnode boundary; pos = %08llx\",\n\t\t\t\t(unsigned long long)*posp);\n\t\t\tgoto bail;\n\t\t}\n\t\t/* We're going down the tree */\n\t\tif (d->down) {\n\t\t\t*posp = ((loff_t) hpfs_de_as_down_as_possible(inode->i_sb, de_down_pointer(d)) << 4) + 1;\n\t\t}\n\t\n\t\treturn de;\n\t}\n\n\t/* Going up */\n\tif (dnode->root_dnode) goto bail;\n\n\tif (!(up_dnode = hpfs_map_dnode(inode->i_sb, le32_to_cpu(dnode->up), &qbh0)))\n\t\tgoto bail;\n\n\tend_up_de = dnode_end_de(up_dnode);\n\tc = 0;\n\tfor (up_de = dnode_first_de(up_dnode); up_de < end_up_de;\n\t     up_de = de_next_de(up_de)) {\n\t\tif (!(++c & 077)) hpfs_error(inode->i_sb,\n\t\t\t\"map_pos_dirent: pos crossed dnode boundary; dnode = %08x\", le32_to_cpu(dnode->up));\n\t\tif (up_de->down && de_down_pointer(up_de) == dno) {\n\t\t\t*posp = ((loff_t) le32_to_cpu(dnode->up) << 4) + c;\n\t\t\thpfs_brelse4(&qbh0);\n\t\t\treturn de;\n\t\t}\n\t}\n\t\n\thpfs_error(inode->i_sb, \"map_pos_dirent: pointer to dnode %08x not found in parent dnode %08x\",\n\t\tdno, le32_to_cpu(dnode->up));\n\thpfs_brelse4(&qbh0);\n\t\n\tbail:\n\t*posp = 12;\n\treturn de;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_add_pos",
          "args": [
            "inode",
            "&file->f_pos"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_add_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "24-46",
          "snippet": "void hpfs_add_pos(struct inode *inode, loff_t *pos)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(inode);\n\tint i = 0;\n\tloff_t **ppos;\n\n\tif (hpfs_inode->i_rddir_off)\n\t\tfor (; hpfs_inode->i_rddir_off[i]; i++)\n\t\t\tif (hpfs_inode->i_rddir_off[i] == pos) return;\n\tif (!(i&0x0f)) {\n\t\tif (!(ppos = kmalloc((i+0x11) * sizeof(loff_t*), GFP_NOFS))) {\n\t\t\tpr_err(\"out of memory for position list\\n\");\n\t\t\treturn;\n\t\t}\n\t\tif (hpfs_inode->i_rddir_off) {\n\t\t\tmemcpy(ppos, hpfs_inode->i_rddir_off, i * sizeof(loff_t));\n\t\t\tkfree(hpfs_inode->i_rddir_off);\n\t\t}\n\t\thpfs_inode->i_rddir_off = ppos;\n\t}\n\thpfs_inode->i_rddir_off[i] = pos;\n\thpfs_inode->i_rddir_off[i + 1] = NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_add_pos(struct inode *inode, loff_t *pos)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(inode);\n\tint i = 0;\n\tloff_t **ppos;\n\n\tif (hpfs_inode->i_rddir_off)\n\t\tfor (; hpfs_inode->i_rddir_off[i]; i++)\n\t\t\tif (hpfs_inode->i_rddir_off[i] == pos) return;\n\tif (!(i&0x0f)) {\n\t\tif (!(ppos = kmalloc((i+0x11) * sizeof(loff_t*), GFP_NOFS))) {\n\t\t\tpr_err(\"out of memory for position list\\n\");\n\t\t\treturn;\n\t\t}\n\t\tif (hpfs_inode->i_rddir_off) {\n\t\t\tmemcpy(ppos, hpfs_inode->i_rddir_off, i * sizeof(loff_t));\n\t\t\tkfree(hpfs_inode->i_rddir_off);\n\t\t}\n\t\thpfs_inode->i_rddir_off = ppos;\n\t}\n\thpfs_inode->i_rddir_off[i] = pos;\n\thpfs_inode->i_rddir_off[i + 1] = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_de_as_down_as_possible",
          "args": [
            "inode->i_sb",
            "hpfs_inode->i_dno"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_de_as_down_as_possible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "816-840",
          "snippet": "dnode_secno hpfs_de_as_down_as_possible(struct super_block *s, dnode_secno dno)\n{\n\tstruct quad_buffer_head qbh;\n\tdnode_secno d = dno;\n\tdnode_secno up = 0;\n\tstruct hpfs_dirent *de;\n\tint c1, c2 = 0;\n\n\tagain:\n\tif (hpfs_sb(s)->sb_chk)\n\t\tif (hpfs_stop_cycles(s, d, &c1, &c2, \"hpfs_de_as_down_as_possible\"))\n\t\t\treturn d;\n\tif (!(de = map_nth_dirent(s, d, 1, &qbh, NULL))) return dno;\n\tif (hpfs_sb(s)->sb_chk)\n\t\tif (up && le32_to_cpu(((struct dnode *)qbh.data)->up) != up)\n\t\t\thpfs_error(s, \"hpfs_de_as_down_as_possible: bad up pointer; dnode %08x, down %08x points to %08x\", up, d, le32_to_cpu(((struct dnode *)qbh.data)->up));\n\tif (!de->down) {\n\t\thpfs_brelse4(&qbh);\n\t\treturn d;\n\t}\n\tup = d;\n\td = de_down_pointer(de);\n\thpfs_brelse4(&qbh);\n\tgoto again;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\ndnode_secno hpfs_de_as_down_as_possible(struct super_block *s, dnode_secno dno)\n{\n\tstruct quad_buffer_head qbh;\n\tdnode_secno d = dno;\n\tdnode_secno up = 0;\n\tstruct hpfs_dirent *de;\n\tint c1, c2 = 0;\n\n\tagain:\n\tif (hpfs_sb(s)->sb_chk)\n\t\tif (hpfs_stop_cycles(s, d, &c1, &c2, \"hpfs_de_as_down_as_possible\"))\n\t\t\treturn d;\n\tif (!(de = map_nth_dirent(s, d, 1, &qbh, NULL))) return dno;\n\tif (hpfs_sb(s)->sb_chk)\n\t\tif (up && le32_to_cpu(((struct dnode *)qbh.data)->up) != up)\n\t\t\thpfs_error(s, \"hpfs_de_as_down_as_possible: bad up pointer; dnode %08x, down %08x points to %08x\", up, d, le32_to_cpu(((struct dnode *)qbh.data)->up));\n\tif (!de->down) {\n\t\thpfs_brelse4(&qbh);\n\t\treturn d;\n\t}\n\tup = d;\n\td = de_down_pointer(de);\n\thpfs_brelse4(&qbh);\n\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "\"..\"",
            "2",
            "hpfs_inode->i_parent_dir",
            "DT_DIR"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_emit_dot",
          "args": [
            "file",
            "ctx"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"pos==%d\\n\"",
            "(int)ctx->pos"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_stop_cycles",
          "args": [
            "inode->i_sb",
            "ctx->pos",
            "&c1",
            "&c2",
            "\"hpfs_readdir\""
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_stop_cycles",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "96-106",
          "snippet": "int hpfs_stop_cycles(struct super_block *s, int key, int *c1, int *c2,\n\t\tchar *msg)\n{\n\tif (*c2 && *c1 == key) {\n\t\thpfs_error(s, \"cycle detected on key %08x in %s\", key, msg);\n\t\treturn 1;\n\t}\n\t(*c2)++;\n\tif (!((*c2 - 1) & *c2)) *c1 = key;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nint hpfs_stop_cycles(struct super_block *s, int key, int *c1, int *c2,\n\t\tchar *msg)\n{\n\tif (*c2 && *c1 == key) {\n\t\thpfs_error(s, \"cycle detected on key %08x in %s\", key, msg);\n\t\treturn 1;\n\t}\n\t(*c2)++;\n\tif (!((*c2 - 1) & *c2)) *c1 = key;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fnode_is_dir",
          "args": [
            "fno"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "fnode_is_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs.h",
          "lines": "480-483",
          "snippet": "static inline bool fnode_is_dir(struct fnode *p)\n{\n\treturn (p->flags & FNODE_dir) != 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool fnode_is_dir(struct fnode *p)\n{\n\treturn (p->flags & FNODE_dir) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_map_fnode",
          "args": [
            "inode->i_sb",
            "inode->i_ino",
            "&bh"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_fnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
          "lines": "137-192",
          "snippet": "struct fnode *hpfs_map_fnode(struct super_block *s, ino_t ino, struct buffer_head **bhp)\n{\n\tstruct fnode *fnode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ino, 1, \"fnode\")) {\n\t\treturn NULL;\n\t}\n\tif ((fnode = hpfs_map_sector(s, ino, bhp, FNODE_RD_AHEAD))) {\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tstruct extended_attribute *ea;\n\t\t\tstruct extended_attribute *ea_end;\n\t\t\tif (le32_to_cpu(fnode->magic) != FNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on fnode %08lx\",\n\t\t\t\t\t(unsigned long)ino);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (!fnode_is_dir(fnode)) {\n\t\t\t\tif ((unsigned)fnode->btree.n_used_nodes + (unsigned)fnode->btree.n_free_nodes !=\n\t\t\t\t    (bp_internal(&fnode->btree) ? 12 : 8)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t   \"bad number of nodes in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (le16_to_cpu(fnode->btree.first_free) !=\n\t\t\t\t    8 + fnode->btree.n_used_nodes * (bp_internal(&fnode->btree) ? 8 : 12)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t    \"bad first_free pointer in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (le16_to_cpu(fnode->ea_size_s) && (le16_to_cpu(fnode->ea_offs) < 0xc4 ||\n\t\t\t   le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s) > 0x200)) {\n\t\t\t\thpfs_error(s,\n\t\t\t\t\t\"bad EA info in fnode %08lx: ea_offs == %04x ea_size_s == %04x\",\n\t\t\t\t\t(unsigned long)ino,\n\t\t\t\t\tle16_to_cpu(fnode->ea_offs), le16_to_cpu(fnode->ea_size_s));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tea = fnode_ea(fnode);\n\t\t\tea_end = fnode_end_ea(fnode);\n\t\t\twhile (ea != ea_end) {\n\t\t\t\tif (ea > ea_end) {\n\t\t\t\t\thpfs_error(s, \"bad EA in fnode %08lx\",\n\t\t\t\t\t\t(unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tea = next_ea(ea);\n\t\t\t}\n\t\t}\n\t}\n\treturn fnode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct fnode *hpfs_map_fnode(struct super_block *s, ino_t ino, struct buffer_head **bhp)\n{\n\tstruct fnode *fnode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ino, 1, \"fnode\")) {\n\t\treturn NULL;\n\t}\n\tif ((fnode = hpfs_map_sector(s, ino, bhp, FNODE_RD_AHEAD))) {\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tstruct extended_attribute *ea;\n\t\t\tstruct extended_attribute *ea_end;\n\t\t\tif (le32_to_cpu(fnode->magic) != FNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on fnode %08lx\",\n\t\t\t\t\t(unsigned long)ino);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (!fnode_is_dir(fnode)) {\n\t\t\t\tif ((unsigned)fnode->btree.n_used_nodes + (unsigned)fnode->btree.n_free_nodes !=\n\t\t\t\t    (bp_internal(&fnode->btree) ? 12 : 8)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t   \"bad number of nodes in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (le16_to_cpu(fnode->btree.first_free) !=\n\t\t\t\t    8 + fnode->btree.n_used_nodes * (bp_internal(&fnode->btree) ? 8 : 12)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t    \"bad first_free pointer in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (le16_to_cpu(fnode->ea_size_s) && (le16_to_cpu(fnode->ea_offs) < 0xc4 ||\n\t\t\t   le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s) > 0x200)) {\n\t\t\t\thpfs_error(s,\n\t\t\t\t\t\"bad EA info in fnode %08lx: ea_offs == %04x ea_size_s == %04x\",\n\t\t\t\t\t(unsigned long)ino,\n\t\t\t\t\tle16_to_cpu(fnode->ea_offs), le16_to_cpu(fnode->ea_size_s));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tea = fnode_ea(fnode);\n\t\t\tea_end = fnode_end_ea(fnode);\n\t\t\twhile (ea != ea_end) {\n\t\t\t\tif (ea > ea_end) {\n\t\t\t\t\thpfs_error(s, \"bad EA in fnode %08lx\",\n\t\t\t\t\t\t(unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tea = next_ea(ea);\n\t\t\t}\n\t\t}\n\t}\n\treturn fnode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_chk_sectors",
          "args": [
            "inode->i_sb",
            "hpfs_inode->i_dno",
            "4",
            "\"dir_dnode\""
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_chk_sectors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "99-112",
          "snippet": "int hpfs_chk_sectors(struct super_block *s, secno start, int len, char *msg)\n{\n\tif (start + len < start || start < 0x12 ||\n\t    start + len > hpfs_sb(s)->sb_fs_size) {\n\t    \thpfs_error(s, \"sector(s) '%s' badly placed at %08x\", msg, start);\n\t\treturn 1;\n\t}\n\tif (hpfs_sb(s)->sb_chk>=2) {\n\t\tint i;\n\t\tfor (i = 0; i < len; i++)\n\t\t\tif (chk_if_allocated(s, start + i, msg)) return 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_chk_sectors(struct super_block *s, secno start, int len, char *msg)\n{\n\tif (start + len < start || start < 0x12 ||\n\t    start + len > hpfs_sb(s)->sb_fs_size) {\n\t    \thpfs_error(s, \"sector(s) '%s' badly placed at %08x\", msg, start);\n\t\treturn 1;\n\t}\n\tif (hpfs_sb(s)->sb_chk>=2) {\n\t\tint i;\n\t\tfor (i = 0; i < len; i++)\n\t\t\tif (chk_if_allocated(s, start + i, msg)) return 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_lock",
          "args": [
            "inode->i_sb"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_i",
          "args": [
            "inode"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "305-308",
          "snippet": "static inline struct hpfs_inode_info *hpfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct hpfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void hpfs_truncate(struct inode *);",
            "void hpfs_init_inode(struct inode *);",
            "void hpfs_read_inode(struct inode *);",
            "void hpfs_write_inode(struct inode *);",
            "void hpfs_write_inode_nolock(struct inode *);",
            "void hpfs_write_if_changed(struct inode *);",
            "void hpfs_evict_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nvoid hpfs_truncate(struct inode *);\nvoid hpfs_init_inode(struct inode *);\nvoid hpfs_read_inode(struct inode *);\nvoid hpfs_write_inode(struct inode *);\nvoid hpfs_write_inode_nolock(struct inode *);\nvoid hpfs_write_if_changed(struct inode *);\nvoid hpfs_evict_inode(struct inode *);\n\nstatic inline struct hpfs_inode_info *hpfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct hpfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/slab.h>\n\nstatic int hpfs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(inode);\n\tstruct quad_buffer_head qbh;\n\tstruct hpfs_dirent *de;\n\tint lc;\n\tloff_t next_pos;\n\tunsigned char *tempname;\n\tint c1, c2 = 0;\n\tint ret = 0;\n\n\thpfs_lock(inode->i_sb);\n\n\tif (hpfs_sb(inode->i_sb)->sb_chk) {\n\t\tif (hpfs_chk_sectors(inode->i_sb, inode->i_ino, 1, \"dir_fnode\")) {\n\t\t\tret = -EFSERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif (hpfs_chk_sectors(inode->i_sb, hpfs_inode->i_dno, 4, \"dir_dnode\")) {\n\t\t\tret = -EFSERROR;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (hpfs_sb(inode->i_sb)->sb_chk >= 2) {\n\t\tstruct buffer_head *bh;\n\t\tstruct fnode *fno;\n\t\tint e = 0;\n\t\tif (!(fno = hpfs_map_fnode(inode->i_sb, inode->i_ino, &bh))) {\n\t\t\tret = -EIOERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!fnode_is_dir(fno)) {\n\t\t\te = 1;\n\t\t\thpfs_error(inode->i_sb, \"not a directory, fnode %08lx\",\n\t\t\t\t\t(unsigned long)inode->i_ino);\n\t\t}\n\t\tif (hpfs_inode->i_dno != le32_to_cpu(fno->u.external[0].disk_secno)) {\n\t\t\te = 1;\n\t\t\thpfs_error(inode->i_sb, \"corrupted inode: i_dno == %08x, fnode -> dnode == %08x\", hpfs_inode->i_dno, le32_to_cpu(fno->u.external[0].disk_secno));\n\t\t}\n\t\tbrelse(bh);\n\t\tif (e) {\n\t\t\tret = -EFSERROR;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tlc = hpfs_sb(inode->i_sb)->sb_lowercase;\n\tif (ctx->pos == 12) { /* diff -r requires this (note, that diff -r */\n\t\tctx->pos = 13; /* also fails on msdos filesystem in 2.0) */\n\t\tgoto out;\n\t}\n\tif (ctx->pos == 13) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\t\n\twhile (1) {\n\t\tagain:\n\t\t/* This won't work when cycle is longer than number of dirents\n\t\t   accepted by filldir, but what can I do?\n\t\t   maybe killall -9 ls helps */\n\t\tif (hpfs_sb(inode->i_sb)->sb_chk)\n\t\t\tif (hpfs_stop_cycles(inode->i_sb, ctx->pos, &c1, &c2, \"hpfs_readdir\")) {\n\t\t\t\tret = -EFSERROR;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\tif (ctx->pos == 12)\n\t\t\tgoto out;\n\t\tif (ctx->pos == 3 || ctx->pos == 4 || ctx->pos == 5) {\n\t\t\tpr_err(\"pos==%d\\n\", (int)ctx->pos);\n\t\t\tgoto out;\n\t\t}\n\t\tif (ctx->pos == 0) {\n\t\t\tif (!dir_emit_dot(file, ctx))\n\t\t\t\tgoto out;\n\t\t\tctx->pos = 11;\n\t\t}\n\t\tif (ctx->pos == 11) {\n\t\t\tif (!dir_emit(ctx, \"..\", 2, hpfs_inode->i_parent_dir, DT_DIR))\n\t\t\t\tgoto out;\n\t\t\tctx->pos = 1;\n\t\t}\n\t\tif (ctx->pos == 1) {\n\t\t\tctx->pos = ((loff_t) hpfs_de_as_down_as_possible(inode->i_sb, hpfs_inode->i_dno) << 4) + 1;\n\t\t\thpfs_add_pos(inode, &file->f_pos);\n\t\t\tfile->f_version = inode->i_version;\n\t\t}\n\t\tnext_pos = ctx->pos;\n\t\tif (!(de = map_pos_dirent(inode, &next_pos, &qbh))) {\n\t\t\tctx->pos = next_pos;\n\t\t\tret = -EIOERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif (de->first || de->last) {\n\t\t\tif (hpfs_sb(inode->i_sb)->sb_chk) {\n\t\t\t\tif (de->first && !de->last && (de->namelen != 2\n\t\t\t\t    || de ->name[0] != 1 || de->name[1] != 1))\n\t\t\t\t\thpfs_error(inode->i_sb, \"hpfs_readdir: bad ^A^A entry; pos = %08lx\", (unsigned long)ctx->pos);\n\t\t\t\tif (de->last && (de->namelen != 1 || de ->name[0] != 255))\n\t\t\t\t\thpfs_error(inode->i_sb, \"hpfs_readdir: bad \\\\377 entry; pos = %08lx\", (unsigned long)ctx->pos);\n\t\t\t}\n\t\t\thpfs_brelse4(&qbh);\n\t\t\tctx->pos = next_pos;\n\t\t\tgoto again;\n\t\t}\n\t\ttempname = hpfs_translate_name(inode->i_sb, de->name, de->namelen, lc, de->not_8x3);\n\t\tif (!dir_emit(ctx, tempname, de->namelen, le32_to_cpu(de->fnode), DT_UNKNOWN)) {\n\t\t\tif (tempname != de->name) kfree(tempname);\n\t\t\thpfs_brelse4(&qbh);\n\t\t\tgoto out;\n\t\t}\n\t\tctx->pos = next_pos;\n\t\tif (tempname != de->name) kfree(tempname);\n\t\thpfs_brelse4(&qbh);\n\t}\nout:\n\thpfs_unlock(inode->i_sb);\n\treturn ret;\n}"
  },
  {
    "function_name": "hpfs_dir_lseek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dir.c",
    "lines": "23-58",
    "snippet": "static loff_t hpfs_dir_lseek(struct file *filp, loff_t off, int whence)\n{\n\tloff_t new_off = off + (whence == 1 ? filp->f_pos : 0);\n\tloff_t pos;\n\tstruct quad_buffer_head qbh;\n\tstruct inode *i = file_inode(filp);\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tstruct super_block *s = i->i_sb;\n\n\t/* Somebody else will have to figure out what to do here */\n\tif (whence == SEEK_DATA || whence == SEEK_HOLE)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&i->i_mutex);\n\thpfs_lock(s);\n\n\t/*pr_info(\"dir lseek\\n\");*/\n\tif (new_off == 0 || new_off == 1 || new_off == 11 || new_off == 12 || new_off == 13) goto ok;\n\tpos = ((loff_t) hpfs_de_as_down_as_possible(s, hpfs_inode->i_dno) << 4) + 1;\n\twhile (pos != new_off) {\n\t\tif (map_pos_dirent(i, &pos, &qbh)) hpfs_brelse4(&qbh);\n\t\telse goto fail;\n\t\tif (pos == 12) goto fail;\n\t}\n\thpfs_add_pos(i, &filp->f_pos);\nok:\n\tfilp->f_pos = new_off;\n\thpfs_unlock(s);\n\tmutex_unlock(&i->i_mutex);\n\treturn new_off;\nfail:\n\t/*pr_warn(\"illegal lseek: %016llx\\n\", new_off);*/\n\thpfs_unlock(s);\n\tmutex_unlock(&i->i_mutex);\n\treturn -ESPIPE;\n}",
    "includes": [
      "#include \"hpfs_fn.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&i->i_mutex"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_unlock",
          "args": [
            "s"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "353-357",
          "snippet": "static inline void hpfs_unlock(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tmutex_unlock(&sbi->hpfs_mutex);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_unlock(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tmutex_unlock(&sbi->hpfs_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&i->i_mutex"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_add_pos",
          "args": [
            "i",
            "&filp->f_pos"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_add_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "24-46",
          "snippet": "void hpfs_add_pos(struct inode *inode, loff_t *pos)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(inode);\n\tint i = 0;\n\tloff_t **ppos;\n\n\tif (hpfs_inode->i_rddir_off)\n\t\tfor (; hpfs_inode->i_rddir_off[i]; i++)\n\t\t\tif (hpfs_inode->i_rddir_off[i] == pos) return;\n\tif (!(i&0x0f)) {\n\t\tif (!(ppos = kmalloc((i+0x11) * sizeof(loff_t*), GFP_NOFS))) {\n\t\t\tpr_err(\"out of memory for position list\\n\");\n\t\t\treturn;\n\t\t}\n\t\tif (hpfs_inode->i_rddir_off) {\n\t\t\tmemcpy(ppos, hpfs_inode->i_rddir_off, i * sizeof(loff_t));\n\t\t\tkfree(hpfs_inode->i_rddir_off);\n\t\t}\n\t\thpfs_inode->i_rddir_off = ppos;\n\t}\n\thpfs_inode->i_rddir_off[i] = pos;\n\thpfs_inode->i_rddir_off[i + 1] = NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_add_pos(struct inode *inode, loff_t *pos)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(inode);\n\tint i = 0;\n\tloff_t **ppos;\n\n\tif (hpfs_inode->i_rddir_off)\n\t\tfor (; hpfs_inode->i_rddir_off[i]; i++)\n\t\t\tif (hpfs_inode->i_rddir_off[i] == pos) return;\n\tif (!(i&0x0f)) {\n\t\tif (!(ppos = kmalloc((i+0x11) * sizeof(loff_t*), GFP_NOFS))) {\n\t\t\tpr_err(\"out of memory for position list\\n\");\n\t\t\treturn;\n\t\t}\n\t\tif (hpfs_inode->i_rddir_off) {\n\t\t\tmemcpy(ppos, hpfs_inode->i_rddir_off, i * sizeof(loff_t));\n\t\t\tkfree(hpfs_inode->i_rddir_off);\n\t\t}\n\t\thpfs_inode->i_rddir_off = ppos;\n\t}\n\thpfs_inode->i_rddir_off[i] = pos;\n\thpfs_inode->i_rddir_off[i + 1] = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_brelse4",
          "args": [
            "&qbh"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_pos_dirent",
          "args": [
            "i",
            "&pos",
            "&qbh"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "map_pos_dirent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "842-903",
          "snippet": "struct hpfs_dirent *map_pos_dirent(struct inode *inode, loff_t *posp,\n\t\t\t\t   struct quad_buffer_head *qbh)\n{\n\tloff_t pos;\n\tunsigned c;\n\tdnode_secno dno;\n\tstruct hpfs_dirent *de, *d;\n\tstruct hpfs_dirent *up_de;\n\tstruct hpfs_dirent *end_up_de;\n\tstruct dnode *dnode;\n\tstruct dnode *up_dnode;\n\tstruct quad_buffer_head qbh0;\n\n\tpos = *posp;\n\tdno = pos >> 6 << 2;\n\tpos &= 077;\n\tif (!(de = map_nth_dirent(inode->i_sb, dno, pos, qbh, &dnode)))\n\t\tgoto bail;\n\n\t/* Going to the next dirent */\n\tif ((d = de_next_de(de)) < dnode_end_de(dnode)) {\n\t\tif (!(++*posp & 077)) {\n\t\t\thpfs_error(inode->i_sb,\n\t\t\t\t\"map_pos_dirent: pos crossed dnode boundary; pos = %08llx\",\n\t\t\t\t(unsigned long long)*posp);\n\t\t\tgoto bail;\n\t\t}\n\t\t/* We're going down the tree */\n\t\tif (d->down) {\n\t\t\t*posp = ((loff_t) hpfs_de_as_down_as_possible(inode->i_sb, de_down_pointer(d)) << 4) + 1;\n\t\t}\n\t\n\t\treturn de;\n\t}\n\n\t/* Going up */\n\tif (dnode->root_dnode) goto bail;\n\n\tif (!(up_dnode = hpfs_map_dnode(inode->i_sb, le32_to_cpu(dnode->up), &qbh0)))\n\t\tgoto bail;\n\n\tend_up_de = dnode_end_de(up_dnode);\n\tc = 0;\n\tfor (up_de = dnode_first_de(up_dnode); up_de < end_up_de;\n\t     up_de = de_next_de(up_de)) {\n\t\tif (!(++c & 077)) hpfs_error(inode->i_sb,\n\t\t\t\"map_pos_dirent: pos crossed dnode boundary; dnode = %08x\", le32_to_cpu(dnode->up));\n\t\tif (up_de->down && de_down_pointer(up_de) == dno) {\n\t\t\t*posp = ((loff_t) le32_to_cpu(dnode->up) << 4) + c;\n\t\t\thpfs_brelse4(&qbh0);\n\t\t\treturn de;\n\t\t}\n\t}\n\t\n\thpfs_error(inode->i_sb, \"map_pos_dirent: pointer to dnode %08x not found in parent dnode %08x\",\n\t\tdno, le32_to_cpu(dnode->up));\n\thpfs_brelse4(&qbh0);\n\t\n\tbail:\n\t*posp = 12;\n\treturn de;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct hpfs_dirent *map_pos_dirent(struct inode *inode, loff_t *posp,\n\t\t\t\t   struct quad_buffer_head *qbh)\n{\n\tloff_t pos;\n\tunsigned c;\n\tdnode_secno dno;\n\tstruct hpfs_dirent *de, *d;\n\tstruct hpfs_dirent *up_de;\n\tstruct hpfs_dirent *end_up_de;\n\tstruct dnode *dnode;\n\tstruct dnode *up_dnode;\n\tstruct quad_buffer_head qbh0;\n\n\tpos = *posp;\n\tdno = pos >> 6 << 2;\n\tpos &= 077;\n\tif (!(de = map_nth_dirent(inode->i_sb, dno, pos, qbh, &dnode)))\n\t\tgoto bail;\n\n\t/* Going to the next dirent */\n\tif ((d = de_next_de(de)) < dnode_end_de(dnode)) {\n\t\tif (!(++*posp & 077)) {\n\t\t\thpfs_error(inode->i_sb,\n\t\t\t\t\"map_pos_dirent: pos crossed dnode boundary; pos = %08llx\",\n\t\t\t\t(unsigned long long)*posp);\n\t\t\tgoto bail;\n\t\t}\n\t\t/* We're going down the tree */\n\t\tif (d->down) {\n\t\t\t*posp = ((loff_t) hpfs_de_as_down_as_possible(inode->i_sb, de_down_pointer(d)) << 4) + 1;\n\t\t}\n\t\n\t\treturn de;\n\t}\n\n\t/* Going up */\n\tif (dnode->root_dnode) goto bail;\n\n\tif (!(up_dnode = hpfs_map_dnode(inode->i_sb, le32_to_cpu(dnode->up), &qbh0)))\n\t\tgoto bail;\n\n\tend_up_de = dnode_end_de(up_dnode);\n\tc = 0;\n\tfor (up_de = dnode_first_de(up_dnode); up_de < end_up_de;\n\t     up_de = de_next_de(up_de)) {\n\t\tif (!(++c & 077)) hpfs_error(inode->i_sb,\n\t\t\t\"map_pos_dirent: pos crossed dnode boundary; dnode = %08x\", le32_to_cpu(dnode->up));\n\t\tif (up_de->down && de_down_pointer(up_de) == dno) {\n\t\t\t*posp = ((loff_t) le32_to_cpu(dnode->up) << 4) + c;\n\t\t\thpfs_brelse4(&qbh0);\n\t\t\treturn de;\n\t\t}\n\t}\n\t\n\thpfs_error(inode->i_sb, \"map_pos_dirent: pointer to dnode %08x not found in parent dnode %08x\",\n\t\tdno, le32_to_cpu(dnode->up));\n\thpfs_brelse4(&qbh0);\n\t\n\tbail:\n\t*posp = 12;\n\treturn de;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_de_as_down_as_possible",
          "args": [
            "s",
            "hpfs_inode->i_dno"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_de_as_down_as_possible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "816-840",
          "snippet": "dnode_secno hpfs_de_as_down_as_possible(struct super_block *s, dnode_secno dno)\n{\n\tstruct quad_buffer_head qbh;\n\tdnode_secno d = dno;\n\tdnode_secno up = 0;\n\tstruct hpfs_dirent *de;\n\tint c1, c2 = 0;\n\n\tagain:\n\tif (hpfs_sb(s)->sb_chk)\n\t\tif (hpfs_stop_cycles(s, d, &c1, &c2, \"hpfs_de_as_down_as_possible\"))\n\t\t\treturn d;\n\tif (!(de = map_nth_dirent(s, d, 1, &qbh, NULL))) return dno;\n\tif (hpfs_sb(s)->sb_chk)\n\t\tif (up && le32_to_cpu(((struct dnode *)qbh.data)->up) != up)\n\t\t\thpfs_error(s, \"hpfs_de_as_down_as_possible: bad up pointer; dnode %08x, down %08x points to %08x\", up, d, le32_to_cpu(((struct dnode *)qbh.data)->up));\n\tif (!de->down) {\n\t\thpfs_brelse4(&qbh);\n\t\treturn d;\n\t}\n\tup = d;\n\td = de_down_pointer(de);\n\thpfs_brelse4(&qbh);\n\tgoto again;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\ndnode_secno hpfs_de_as_down_as_possible(struct super_block *s, dnode_secno dno)\n{\n\tstruct quad_buffer_head qbh;\n\tdnode_secno d = dno;\n\tdnode_secno up = 0;\n\tstruct hpfs_dirent *de;\n\tint c1, c2 = 0;\n\n\tagain:\n\tif (hpfs_sb(s)->sb_chk)\n\t\tif (hpfs_stop_cycles(s, d, &c1, &c2, \"hpfs_de_as_down_as_possible\"))\n\t\t\treturn d;\n\tif (!(de = map_nth_dirent(s, d, 1, &qbh, NULL))) return dno;\n\tif (hpfs_sb(s)->sb_chk)\n\t\tif (up && le32_to_cpu(((struct dnode *)qbh.data)->up) != up)\n\t\t\thpfs_error(s, \"hpfs_de_as_down_as_possible: bad up pointer; dnode %08x, down %08x points to %08x\", up, d, le32_to_cpu(((struct dnode *)qbh.data)->up));\n\tif (!de->down) {\n\t\thpfs_brelse4(&qbh);\n\t\treturn d;\n\t}\n\tup = d;\n\td = de_down_pointer(de);\n\thpfs_brelse4(&qbh);\n\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_lock",
          "args": [
            "s"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&i->i_mutex"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_i",
          "args": [
            "i"
          ],
          "line": 29
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "305-308",
          "snippet": "static inline struct hpfs_inode_info *hpfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct hpfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void hpfs_truncate(struct inode *);",
            "void hpfs_init_inode(struct inode *);",
            "void hpfs_read_inode(struct inode *);",
            "void hpfs_write_inode(struct inode *);",
            "void hpfs_write_inode_nolock(struct inode *);",
            "void hpfs_write_if_changed(struct inode *);",
            "void hpfs_evict_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nvoid hpfs_truncate(struct inode *);\nvoid hpfs_init_inode(struct inode *);\nvoid hpfs_read_inode(struct inode *);\nvoid hpfs_write_inode(struct inode *);\nvoid hpfs_write_inode_nolock(struct inode *);\nvoid hpfs_write_if_changed(struct inode *);\nvoid hpfs_evict_inode(struct inode *);\n\nstatic inline struct hpfs_inode_info *hpfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct hpfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 28
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/slab.h>\n\nstatic loff_t hpfs_dir_lseek(struct file *filp, loff_t off, int whence)\n{\n\tloff_t new_off = off + (whence == 1 ? filp->f_pos : 0);\n\tloff_t pos;\n\tstruct quad_buffer_head qbh;\n\tstruct inode *i = file_inode(filp);\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tstruct super_block *s = i->i_sb;\n\n\t/* Somebody else will have to figure out what to do here */\n\tif (whence == SEEK_DATA || whence == SEEK_HOLE)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&i->i_mutex);\n\thpfs_lock(s);\n\n\t/*pr_info(\"dir lseek\\n\");*/\n\tif (new_off == 0 || new_off == 1 || new_off == 11 || new_off == 12 || new_off == 13) goto ok;\n\tpos = ((loff_t) hpfs_de_as_down_as_possible(s, hpfs_inode->i_dno) << 4) + 1;\n\twhile (pos != new_off) {\n\t\tif (map_pos_dirent(i, &pos, &qbh)) hpfs_brelse4(&qbh);\n\t\telse goto fail;\n\t\tif (pos == 12) goto fail;\n\t}\n\thpfs_add_pos(i, &filp->f_pos);\nok:\n\tfilp->f_pos = new_off;\n\thpfs_unlock(s);\n\tmutex_unlock(&i->i_mutex);\n\treturn new_off;\nfail:\n\t/*pr_warn(\"illegal lseek: %016llx\\n\", new_off);*/\n\thpfs_unlock(s);\n\tmutex_unlock(&i->i_mutex);\n\treturn -ESPIPE;\n}"
  },
  {
    "function_name": "hpfs_dir_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dir.c",
    "lines": "12-19",
    "snippet": "static int hpfs_dir_release(struct inode *inode, struct file *filp)\n{\n\thpfs_lock(inode->i_sb);\n\thpfs_del_pos(inode, &filp->f_pos);\n\t/*hpfs_write_if_changed(inode);*/\n\thpfs_unlock(inode->i_sb);\n\treturn 0;\n}",
    "includes": [
      "#include \"hpfs_fn.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_unlock",
          "args": [
            "inode->i_sb"
          ],
          "line": 17
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "353-357",
          "snippet": "static inline void hpfs_unlock(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tmutex_unlock(&sbi->hpfs_mutex);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_unlock(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tmutex_unlock(&sbi->hpfs_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_del_pos",
          "args": [
            "inode",
            "&filp->f_pos"
          ],
          "line": 15
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_del_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "48-69",
          "snippet": "void hpfs_del_pos(struct inode *inode, loff_t *pos)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(inode);\n\tloff_t **i, **j;\n\n\tif (!hpfs_inode->i_rddir_off) goto not_f;\n\tfor (i = hpfs_inode->i_rddir_off; *i; i++) if (*i == pos) goto fnd;\n\tgoto not_f;\n\tfnd:\n\tfor (j = i + 1; *j; j++) ;\n\t*i = *(j - 1);\n\t*(j - 1) = NULL;\n\tif (j - 1 == hpfs_inode->i_rddir_off) {\n\t\tkfree(hpfs_inode->i_rddir_off);\n\t\thpfs_inode->i_rddir_off = NULL;\n\t}\n\treturn;\n\tnot_f:\n\t/*pr_warn(\"position pointer %p->%08x not found\\n\",\n\t\t  pos, (int)*pos);*/\n\treturn;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_del_pos(struct inode *inode, loff_t *pos)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(inode);\n\tloff_t **i, **j;\n\n\tif (!hpfs_inode->i_rddir_off) goto not_f;\n\tfor (i = hpfs_inode->i_rddir_off; *i; i++) if (*i == pos) goto fnd;\n\tgoto not_f;\n\tfnd:\n\tfor (j = i + 1; *j; j++) ;\n\t*i = *(j - 1);\n\t*(j - 1) = NULL;\n\tif (j - 1 == hpfs_inode->i_rddir_off) {\n\t\tkfree(hpfs_inode->i_rddir_off);\n\t\thpfs_inode->i_rddir_off = NULL;\n\t}\n\treturn;\n\tnot_f:\n\t/*pr_warn(\"position pointer %p->%08x not found\\n\",\n\t\t  pos, (int)*pos);*/\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_lock",
          "args": [
            "inode->i_sb"
          ],
          "line": 14
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/slab.h>\n\nstatic int hpfs_dir_release(struct inode *inode, struct file *filp)\n{\n\thpfs_lock(inode->i_sb);\n\thpfs_del_pos(inode, &filp->f_pos);\n\t/*hpfs_write_if_changed(inode);*/\n\thpfs_unlock(inode->i_sb);\n\treturn 0;\n}"
  }
]