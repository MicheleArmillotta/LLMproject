[
  {
    "function_name": "coda_downcall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
    "lines": "807-881",
    "snippet": "int coda_downcall(struct venus_comm *vcp, int opcode, union outputArgs *out)\n{\n\tstruct inode *inode = NULL;\n\tstruct CodaFid *fid = NULL, *newfid;\n\tstruct super_block *sb;\n\n\t/* Handle invalidation requests. */\n\tmutex_lock(&vcp->vc_mutex);\n\tsb = vcp->vc_sb;\n\tif (!sb || !sb->s_root)\n\t\tgoto unlock_out;\n\n\tswitch (opcode) {\n\tcase CODA_FLUSH:\n\t\tcoda_cache_clear_all(sb);\n\t\tshrink_dcache_sb(sb);\n\t\tif (sb->s_root->d_inode)\n\t\t\tcoda_flag_inode(sb->s_root->d_inode, C_FLUSH);\n\t\tbreak;\n\n\tcase CODA_PURGEUSER:\n\t\tcoda_cache_clear_all(sb);\n\t\tbreak;\n\n\tcase CODA_ZAPDIR:\n\t\tfid = &out->coda_zapdir.CodaFid;\n\t\tbreak;\n\n\tcase CODA_ZAPFILE:\n\t\tfid = &out->coda_zapfile.CodaFid;\n\t\tbreak;\n\n\tcase CODA_PURGEFID:\n\t\tfid = &out->coda_purgefid.CodaFid;\n\t\tbreak;\n\n\tcase CODA_REPLACE:\n\t\tfid = &out->coda_replace.OldFid;\n\t\tbreak;\n\t}\n\tif (fid)\n\t\tinode = coda_fid_to_inode(fid, sb);\n\nunlock_out:\n\tmutex_unlock(&vcp->vc_mutex);\n\n\tif (!inode)\n\t\treturn 0;\n\n\tswitch (opcode) {\n\tcase CODA_ZAPDIR:\n\t\tcoda_flag_inode_children(inode, C_PURGE);\n\t\tcoda_flag_inode(inode, C_VATTR);\n\t\tbreak;\n\n\tcase CODA_ZAPFILE:\n\t\tcoda_flag_inode(inode, C_VATTR);\n\t\tbreak;\n\n\tcase CODA_PURGEFID:\n\t\tcoda_flag_inode_children(inode, C_PURGE);\n\n\t\t/* catch the dentries later if some are still busy */\n\t\tcoda_flag_inode(inode, C_PURGE);\n\t\td_prune_aliases(inode);\n\t\tbreak;\n\n\tcase CODA_REPLACE:\n\t\tnewfid = &out->coda_replace.NewFid;\n\t\tcoda_replace_fid(inode, fid, newfid);\n\t\tbreak;\n\t}\n\tiput(inode);\n\treturn 0;\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_cache.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/vfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_replace_fid",
          "args": [
            "inode",
            "fid",
            "newfid"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "coda_replace_fid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cnode.c",
          "lines": "117-131",
          "snippet": "void coda_replace_fid(struct inode *inode, struct CodaFid *oldfid, \n\t\t      struct CodaFid *newfid)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\tunsigned long hash = coda_f2i(newfid);\n\t\n\tBUG_ON(!coda_fideq(&cii->c_fid, oldfid));\n\n\t/* replace fid and rehash inode */\n\t/* XXX we probably need to hold some lock here! */\n\tremove_inode_hash(inode);\n\tcii->c_fid = *newfid;\n\tinode->i_ino = hash;\n\t__insert_inode_hash(inode, hash);\n}",
          "includes": [
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\nvoid coda_replace_fid(struct inode *inode, struct CodaFid *oldfid, \n\t\t      struct CodaFid *newfid)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\tunsigned long hash = coda_f2i(newfid);\n\t\n\tBUG_ON(!coda_fideq(&cii->c_fid, oldfid));\n\n\t/* replace fid and rehash inode */\n\t/* XXX we probably need to hold some lock here! */\n\tremove_inode_hash(inode);\n\tcii->c_fid = *newfid;\n\tinode->i_ino = hash;\n\t__insert_inode_hash(inode, hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_prune_aliases",
          "args": [
            "inode"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "d_prune_aliases",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "882-902",
          "snippet": "void d_prune_aliases(struct inode *inode)\n{\n\tstruct dentry *dentry;\nrestart:\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry(dentry, &inode->i_dentry, d_u.d_alias) {\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (!dentry->d_lockref.count) {\n\t\t\tstruct dentry *parent = lock_parent(dentry);\n\t\t\tif (likely(!dentry->d_lockref.count)) {\n\t\t\t\t__dentry_kill(dentry);\n\t\t\t\tdput(parent);\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t\tif (parent)\n\t\t\t\tspin_unlock(&parent->d_lock);\n\t\t}\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid d_prune_aliases(struct inode *inode)\n{\n\tstruct dentry *dentry;\nrestart:\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry(dentry, &inode->i_dentry, d_u.d_alias) {\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (!dentry->d_lockref.count) {\n\t\t\tstruct dentry *parent = lock_parent(dentry);\n\t\t\tif (likely(!dentry->d_lockref.count)) {\n\t\t\t\t__dentry_kill(dentry);\n\t\t\t\tdput(parent);\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t\tif (parent)\n\t\t\t\tspin_unlock(&parent->d_lock);\n\t\t}\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_flag_inode",
          "args": [
            "inode",
            "C_PURGE"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "coda_flag_inode_children",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "104-117",
          "snippet": "void coda_flag_inode_children(struct inode *inode, int flag)\n{\n\tstruct dentry *alias_de;\n\n\tif ( !inode || !S_ISDIR(inode->i_mode)) \n\t\treturn; \n\n\talias_de = d_find_alias(inode);\n\tif (!alias_de)\n\t\treturn;\n\tcoda_flag_children(alias_de, flag);\n\tshrink_dcache_parent(alias_de);\n\tdput(alias_de);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid coda_flag_inode_children(struct inode *inode, int flag)\n{\n\tstruct dentry *alias_de;\n\n\tif ( !inode || !S_ISDIR(inode->i_mode)) \n\t\treturn; \n\n\talias_de = d_find_alias(inode);\n\tif (!alias_de)\n\t\treturn;\n\tcoda_flag_children(alias_de, flag);\n\tshrink_dcache_parent(alias_de);\n\tdput(alias_de);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&vcp->vc_mutex"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coda_fid_to_inode",
          "args": [
            "fid",
            "sb"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "coda_fid_to_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cnode.c",
          "lines": "134-153",
          "snippet": "struct inode *coda_fid_to_inode(struct CodaFid *fid, struct super_block *sb) \n{\n\tstruct inode *inode;\n\tunsigned long hash = coda_f2i(fid);\n\n\tif ( !sb ) {\n\t\tpr_warn(\"%s: no sb!\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tinode = ilookup5(sb, hash, coda_test_inode, fid);\n\tif ( !inode )\n\t\treturn NULL;\n\n\t/* we should never see newly created inodes because we intentionally\n\t * fail in the initialization callback */\n\tBUG_ON(inode->i_state & I_NEW);\n\n\treturn inode;\n}",
          "includes": [
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\nstruct inode *coda_fid_to_inode(struct CodaFid *fid, struct super_block *sb) \n{\n\tstruct inode *inode;\n\tunsigned long hash = coda_f2i(fid);\n\n\tif ( !sb ) {\n\t\tpr_warn(\"%s: no sb!\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tinode = ilookup5(sb, hash, coda_test_inode, fid);\n\tif ( !inode )\n\t\treturn NULL;\n\n\t/* we should never see newly created inodes because we intentionally\n\t * fail in the initialization callback */\n\tBUG_ON(inode->i_state & I_NEW);\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_cache_clear_all",
          "args": [
            "sb"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_clear_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "54-57",
          "snippet": "void coda_cache_clear_all(struct super_block *sb)\n{\n\tatomic_inc(&permission_epoch);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_clear_all(struct super_block *sb)\n{\n\tatomic_inc(&permission_epoch);\n}"
        }
      },
      {
        "call_info": {
          "callee": "shrink_dcache_sb",
          "args": [
            "sb"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "shrink_dcache_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1094-1107",
          "snippet": "void shrink_dcache_sb(struct super_block *sb)\n{\n\tlong freed;\n\n\tdo {\n\t\tLIST_HEAD(dispose);\n\n\t\tfreed = list_lru_walk(&sb->s_dentry_lru,\n\t\t\tdentry_lru_isolate_shrink, &dispose, UINT_MAX);\n\n\t\tthis_cpu_sub(nr_dentry_unused, freed);\n\t\tshrink_dentry_list(&dispose);\n\t} while (freed > 0);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(long, nr_dentry_unused);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic DEFINE_PER_CPU(long, nr_dentry_unused);\n\nvoid shrink_dcache_sb(struct super_block *sb)\n{\n\tlong freed;\n\n\tdo {\n\t\tLIST_HEAD(dispose);\n\n\t\tfreed = list_lru_walk(&sb->s_dentry_lru,\n\t\t\tdentry_lru_isolate_shrink, &dispose, UINT_MAX);\n\n\t\tthis_cpu_sub(nr_dentry_unused, freed);\n\t\tshrink_dentry_list(&dispose);\n\t} while (freed > 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&vcp->vc_mutex"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nint coda_downcall(struct venus_comm *vcp, int opcode, union outputArgs *out)\n{\n\tstruct inode *inode = NULL;\n\tstruct CodaFid *fid = NULL, *newfid;\n\tstruct super_block *sb;\n\n\t/* Handle invalidation requests. */\n\tmutex_lock(&vcp->vc_mutex);\n\tsb = vcp->vc_sb;\n\tif (!sb || !sb->s_root)\n\t\tgoto unlock_out;\n\n\tswitch (opcode) {\n\tcase CODA_FLUSH:\n\t\tcoda_cache_clear_all(sb);\n\t\tshrink_dcache_sb(sb);\n\t\tif (sb->s_root->d_inode)\n\t\t\tcoda_flag_inode(sb->s_root->d_inode, C_FLUSH);\n\t\tbreak;\n\n\tcase CODA_PURGEUSER:\n\t\tcoda_cache_clear_all(sb);\n\t\tbreak;\n\n\tcase CODA_ZAPDIR:\n\t\tfid = &out->coda_zapdir.CodaFid;\n\t\tbreak;\n\n\tcase CODA_ZAPFILE:\n\t\tfid = &out->coda_zapfile.CodaFid;\n\t\tbreak;\n\n\tcase CODA_PURGEFID:\n\t\tfid = &out->coda_purgefid.CodaFid;\n\t\tbreak;\n\n\tcase CODA_REPLACE:\n\t\tfid = &out->coda_replace.OldFid;\n\t\tbreak;\n\t}\n\tif (fid)\n\t\tinode = coda_fid_to_inode(fid, sb);\n\nunlock_out:\n\tmutex_unlock(&vcp->vc_mutex);\n\n\tif (!inode)\n\t\treturn 0;\n\n\tswitch (opcode) {\n\tcase CODA_ZAPDIR:\n\t\tcoda_flag_inode_children(inode, C_PURGE);\n\t\tcoda_flag_inode(inode, C_VATTR);\n\t\tbreak;\n\n\tcase CODA_ZAPFILE:\n\t\tcoda_flag_inode(inode, C_VATTR);\n\t\tbreak;\n\n\tcase CODA_PURGEFID:\n\t\tcoda_flag_inode_children(inode, C_PURGE);\n\n\t\t/* catch the dentries later if some are still busy */\n\t\tcoda_flag_inode(inode, C_PURGE);\n\t\td_prune_aliases(inode);\n\t\tbreak;\n\n\tcase CODA_REPLACE:\n\t\tnewfid = &out->coda_replace.NewFid;\n\t\tcoda_replace_fid(inode, fid, newfid);\n\t\tbreak;\n\t}\n\tiput(inode);\n\treturn 0;\n}"
  },
  {
    "function_name": "coda_upcall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
    "lines": "666-771",
    "snippet": "static int coda_upcall(struct venus_comm *vcp,\n\t\t       int inSize, int *outSize,\n\t\t       union inputArgs *buffer)\n{\n\tunion outputArgs *out;\n\tunion inputArgs *sig_inputArgs;\n\tstruct upc_req *req = NULL, *sig_req;\n\tint error;\n\n\tmutex_lock(&vcp->vc_mutex);\n\n\tif (!vcp->vc_inuse) {\n\t\tpr_notice(\"Venus dead, not sending upcall\\n\");\n\t\terror = -ENXIO;\n\t\tgoto exit;\n\t}\n\n\t/* Format the request message. */\n\treq = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!req) {\n\t\terror = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\treq->uc_data = (void *)buffer;\n\treq->uc_flags = 0;\n\treq->uc_inSize = inSize;\n\treq->uc_outSize = *outSize ? *outSize : inSize;\n\treq->uc_opcode = ((union inputArgs *)buffer)->ih.opcode;\n\treq->uc_unique = ++vcp->vc_seq;\n\tinit_waitqueue_head(&req->uc_sleep);\n\n\t/* Fill in the common input args. */\n\t((union inputArgs *)buffer)->ih.unique = req->uc_unique;\n\n\t/* Append msg to pending queue and poke Venus. */\n\tlist_add_tail(&req->uc_chain, &vcp->vc_pending);\n\n\twake_up_interruptible(&vcp->vc_waitq);\n\t/* We can be interrupted while we wait for Venus to process\n\t * our request.  If the interrupt occurs before Venus has read\n\t * the request, we dequeue and return. If it occurs after the\n\t * read but before the reply, we dequeue, send a signal\n\t * message, and return. If it occurs after the reply we ignore\n\t * it. In no case do we want to restart the syscall.  If it\n\t * was interrupted by a venus shutdown (psdev_close), return\n\t * ENODEV.  */\n\n\t/* Go to sleep.  Wake up on signals only after the timeout. */\n\tcoda_waitfor_upcall(vcp, req);\n\n\t/* Op went through, interrupt or not... */\n\tif (req->uc_flags & CODA_REQ_WRITE) {\n\t\tout = (union outputArgs *)req->uc_data;\n\t\t/* here we map positive Venus errors to kernel errors */\n\t\terror = -out->oh.result;\n\t\t*outSize = req->uc_outSize;\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tif ((req->uc_flags & CODA_REQ_ABORT) || !signal_pending(current)) {\n\t\tpr_warn(\"Unexpected interruption.\\n\");\n\t\tgoto exit;\n\t}\n\n\t/* Interrupted before venus read it. */\n\tif (!(req->uc_flags & CODA_REQ_READ))\n\t\tgoto exit;\n\n\t/* Venus saw the upcall, make sure we can send interrupt signal */\n\tif (!vcp->vc_inuse) {\n\t\tpr_info(\"Venus dead, not sending signal.\\n\");\n\t\tgoto exit;\n\t}\n\n\terror = -ENOMEM;\n\tsig_req = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!sig_req) goto exit;\n\n\tCODA_ALLOC((sig_req->uc_data), char *, sizeof(struct coda_in_hdr));\n\tif (!sig_req->uc_data) {\n\t\tkfree(sig_req);\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tsig_inputArgs = (union inputArgs *)sig_req->uc_data;\n\tsig_inputArgs->ih.opcode = CODA_SIGNAL;\n\tsig_inputArgs->ih.unique = req->uc_unique;\n\n\tsig_req->uc_flags = CODA_REQ_ASYNC;\n\tsig_req->uc_opcode = sig_inputArgs->ih.opcode;\n\tsig_req->uc_unique = sig_inputArgs->ih.unique;\n\tsig_req->uc_inSize = sizeof(struct coda_in_hdr);\n\tsig_req->uc_outSize = sizeof(struct coda_in_hdr);\n\n\t/* insert at head of queue! */\n\tlist_add(&(sig_req->uc_chain), &vcp->vc_pending);\n\twake_up_interruptible(&vcp->vc_waitq);\n\nexit:\n\tkfree(req);\n\tmutex_unlock(&vcp->vc_mutex);\n\treturn error;\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_cache.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/vfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int coda_upcall(struct venus_comm *vc, int inSize, int *outSize,\n\t\t       union inputArgs *buffer);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&vcp->vc_mutex"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "req"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_interruptible",
          "args": [
            "&vcp->vc_waitq"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&(sig_req->uc_chain)",
            "&vcp->vc_pending"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sig_req"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CODA_ALLOC",
          "args": [
            "(sig_req->uc_data)",
            "char*",
            "sizeof(struct coda_in_hdr)"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct upc_req)",
            "GFP_KERNEL"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Venus dead, not sending signal.\\n\""
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Unexpected interruption.\\n\""
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coda_waitfor_upcall",
          "args": [
            "vcp",
            "req"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "coda_waitfor_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
          "lines": "608-654",
          "snippet": "static inline void coda_waitfor_upcall(struct venus_comm *vcp,\n\t\t\t\t       struct upc_req *req)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tunsigned long timeout = jiffies + coda_timeout * HZ;\n\tsigset_t old;\n\tint blocked;\n\n\tcoda_block_signals(&old);\n\tblocked = 1;\n\n\tadd_wait_queue(&req->uc_sleep, &wait);\n\tfor (;;) {\n\t\tif (CODA_INTERRUPTIBLE(req))\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\telse\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\n\t\t/* got a reply */\n\t\tif (req->uc_flags & (CODA_REQ_WRITE | CODA_REQ_ABORT))\n\t\t\tbreak;\n\n\t\tif (blocked && time_after(jiffies, timeout) &&\n\t\t    CODA_INTERRUPTIBLE(req))\n\t\t{\n\t\t\tcoda_unblock_signals(&old);\n\t\t\tblocked = 0;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\tlist_del(&req->uc_chain);\n\t\t\tbreak;\n\t\t}\n\n\t\tmutex_unlock(&vcp->vc_mutex);\n\t\tif (blocked)\n\t\t\tschedule_timeout(HZ);\n\t\telse\n\t\t\tschedule();\n\t\tmutex_lock(&vcp->vc_mutex);\n\t}\n\tif (blocked)\n\t\tcoda_unblock_signals(&old);\n\n\tremove_wait_queue(&req->uc_sleep, &wait);\n\tset_current_state(TASK_RUNNING);\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/vfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nstatic inline void coda_waitfor_upcall(struct venus_comm *vcp,\n\t\t\t\t       struct upc_req *req)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tunsigned long timeout = jiffies + coda_timeout * HZ;\n\tsigset_t old;\n\tint blocked;\n\n\tcoda_block_signals(&old);\n\tblocked = 1;\n\n\tadd_wait_queue(&req->uc_sleep, &wait);\n\tfor (;;) {\n\t\tif (CODA_INTERRUPTIBLE(req))\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\telse\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\n\t\t/* got a reply */\n\t\tif (req->uc_flags & (CODA_REQ_WRITE | CODA_REQ_ABORT))\n\t\t\tbreak;\n\n\t\tif (blocked && time_after(jiffies, timeout) &&\n\t\t    CODA_INTERRUPTIBLE(req))\n\t\t{\n\t\t\tcoda_unblock_signals(&old);\n\t\t\tblocked = 0;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\tlist_del(&req->uc_chain);\n\t\t\tbreak;\n\t\t}\n\n\t\tmutex_unlock(&vcp->vc_mutex);\n\t\tif (blocked)\n\t\t\tschedule_timeout(HZ);\n\t\telse\n\t\t\tschedule();\n\t\tmutex_lock(&vcp->vc_mutex);\n\t}\n\tif (blocked)\n\t\tcoda_unblock_signals(&old);\n\n\tremove_wait_queue(&req->uc_sleep, &wait);\n\tset_current_state(TASK_RUNNING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_interruptible",
          "args": [
            "&vcp->vc_waitq"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&req->uc_chain",
            "&vcp->vc_pending"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&req->uc_sleep"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_notice",
          "args": [
            "\"Venus dead, not sending upcall\\n\""
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&vcp->vc_mutex"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nstatic int coda_upcall(struct venus_comm *vc, int inSize, int *outSize,\n\t\t       union inputArgs *buffer);\n\nstatic int coda_upcall(struct venus_comm *vcp,\n\t\t       int inSize, int *outSize,\n\t\t       union inputArgs *buffer)\n{\n\tunion outputArgs *out;\n\tunion inputArgs *sig_inputArgs;\n\tstruct upc_req *req = NULL, *sig_req;\n\tint error;\n\n\tmutex_lock(&vcp->vc_mutex);\n\n\tif (!vcp->vc_inuse) {\n\t\tpr_notice(\"Venus dead, not sending upcall\\n\");\n\t\terror = -ENXIO;\n\t\tgoto exit;\n\t}\n\n\t/* Format the request message. */\n\treq = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!req) {\n\t\terror = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\treq->uc_data = (void *)buffer;\n\treq->uc_flags = 0;\n\treq->uc_inSize = inSize;\n\treq->uc_outSize = *outSize ? *outSize : inSize;\n\treq->uc_opcode = ((union inputArgs *)buffer)->ih.opcode;\n\treq->uc_unique = ++vcp->vc_seq;\n\tinit_waitqueue_head(&req->uc_sleep);\n\n\t/* Fill in the common input args. */\n\t((union inputArgs *)buffer)->ih.unique = req->uc_unique;\n\n\t/* Append msg to pending queue and poke Venus. */\n\tlist_add_tail(&req->uc_chain, &vcp->vc_pending);\n\n\twake_up_interruptible(&vcp->vc_waitq);\n\t/* We can be interrupted while we wait for Venus to process\n\t * our request.  If the interrupt occurs before Venus has read\n\t * the request, we dequeue and return. If it occurs after the\n\t * read but before the reply, we dequeue, send a signal\n\t * message, and return. If it occurs after the reply we ignore\n\t * it. In no case do we want to restart the syscall.  If it\n\t * was interrupted by a venus shutdown (psdev_close), return\n\t * ENODEV.  */\n\n\t/* Go to sleep.  Wake up on signals only after the timeout. */\n\tcoda_waitfor_upcall(vcp, req);\n\n\t/* Op went through, interrupt or not... */\n\tif (req->uc_flags & CODA_REQ_WRITE) {\n\t\tout = (union outputArgs *)req->uc_data;\n\t\t/* here we map positive Venus errors to kernel errors */\n\t\terror = -out->oh.result;\n\t\t*outSize = req->uc_outSize;\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tif ((req->uc_flags & CODA_REQ_ABORT) || !signal_pending(current)) {\n\t\tpr_warn(\"Unexpected interruption.\\n\");\n\t\tgoto exit;\n\t}\n\n\t/* Interrupted before venus read it. */\n\tif (!(req->uc_flags & CODA_REQ_READ))\n\t\tgoto exit;\n\n\t/* Venus saw the upcall, make sure we can send interrupt signal */\n\tif (!vcp->vc_inuse) {\n\t\tpr_info(\"Venus dead, not sending signal.\\n\");\n\t\tgoto exit;\n\t}\n\n\terror = -ENOMEM;\n\tsig_req = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!sig_req) goto exit;\n\n\tCODA_ALLOC((sig_req->uc_data), char *, sizeof(struct coda_in_hdr));\n\tif (!sig_req->uc_data) {\n\t\tkfree(sig_req);\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tsig_inputArgs = (union inputArgs *)sig_req->uc_data;\n\tsig_inputArgs->ih.opcode = CODA_SIGNAL;\n\tsig_inputArgs->ih.unique = req->uc_unique;\n\n\tsig_req->uc_flags = CODA_REQ_ASYNC;\n\tsig_req->uc_opcode = sig_inputArgs->ih.opcode;\n\tsig_req->uc_unique = sig_inputArgs->ih.unique;\n\tsig_req->uc_inSize = sizeof(struct coda_in_hdr);\n\tsig_req->uc_outSize = sizeof(struct coda_in_hdr);\n\n\t/* insert at head of queue! */\n\tlist_add(&(sig_req->uc_chain), &vcp->vc_pending);\n\twake_up_interruptible(&vcp->vc_waitq);\n\nexit:\n\tkfree(req);\n\tmutex_unlock(&vcp->vc_mutex);\n\treturn error;\n}"
  },
  {
    "function_name": "coda_waitfor_upcall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
    "lines": "608-654",
    "snippet": "static inline void coda_waitfor_upcall(struct venus_comm *vcp,\n\t\t\t\t       struct upc_req *req)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tunsigned long timeout = jiffies + coda_timeout * HZ;\n\tsigset_t old;\n\tint blocked;\n\n\tcoda_block_signals(&old);\n\tblocked = 1;\n\n\tadd_wait_queue(&req->uc_sleep, &wait);\n\tfor (;;) {\n\t\tif (CODA_INTERRUPTIBLE(req))\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\telse\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\n\t\t/* got a reply */\n\t\tif (req->uc_flags & (CODA_REQ_WRITE | CODA_REQ_ABORT))\n\t\t\tbreak;\n\n\t\tif (blocked && time_after(jiffies, timeout) &&\n\t\t    CODA_INTERRUPTIBLE(req))\n\t\t{\n\t\t\tcoda_unblock_signals(&old);\n\t\t\tblocked = 0;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\tlist_del(&req->uc_chain);\n\t\t\tbreak;\n\t\t}\n\n\t\tmutex_unlock(&vcp->vc_mutex);\n\t\tif (blocked)\n\t\t\tschedule_timeout(HZ);\n\t\telse\n\t\t\tschedule();\n\t\tmutex_lock(&vcp->vc_mutex);\n\t}\n\tif (blocked)\n\t\tcoda_unblock_signals(&old);\n\n\tremove_wait_queue(&req->uc_sleep, &wait);\n\tset_current_state(TASK_RUNNING);\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_cache.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/vfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_wait_queue",
          "args": [
            "&req->uc_sleep",
            "&wait"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coda_unblock_signals",
          "args": [
            "&old"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "coda_unblock_signals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
          "lines": "589-595",
          "snippet": "static void coda_unblock_signals(sigset_t *old)\n{\n\tspin_lock_irq(&current->sighand->siglock);\n\tcurrent->blocked = *old;\n\trecalc_sigpending();\n\tspin_unlock_irq(&current->sighand->siglock);\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/vfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nstatic void coda_unblock_signals(sigset_t *old)\n{\n\tspin_lock_irq(&current->sighand->siglock);\n\tcurrent->blocked = *old;\n\trecalc_sigpending();\n\tspin_unlock_irq(&current->sighand->siglock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&vcp->vc_mutex"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout",
          "args": [
            "HZ"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&vcp->vc_mutex"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&req->uc_chain"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CODA_INTERRUPTIBLE",
          "args": [
            "req"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "jiffies",
            "timeout"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CODA_INTERRUPTIBLE",
          "args": [
            "req"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_wait_queue",
          "args": [
            "&req->uc_sleep",
            "&wait"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coda_block_signals",
          "args": [
            "&old"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "coda_block_signals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
          "lines": "575-587",
          "snippet": "static void coda_block_signals(sigset_t *old)\n{\n\tspin_lock_irq(&current->sighand->siglock);\n\t*old = current->blocked;\n\n\tsigfillset(&current->blocked);\n\tsigdelset(&current->blocked, SIGKILL);\n\tsigdelset(&current->blocked, SIGSTOP);\n\tsigdelset(&current->blocked, SIGINT);\n\n\trecalc_sigpending();\n\tspin_unlock_irq(&current->sighand->siglock);\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/vfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nstatic void coda_block_signals(sigset_t *old)\n{\n\tspin_lock_irq(&current->sighand->siglock);\n\t*old = current->blocked;\n\n\tsigfillset(&current->blocked);\n\tsigdelset(&current->blocked, SIGKILL);\n\tsigdelset(&current->blocked, SIGSTOP);\n\tsigdelset(&current->blocked, SIGINT);\n\n\trecalc_sigpending();\n\tspin_unlock_irq(&current->sighand->siglock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DECLARE_WAITQUEUE",
          "args": [
            "wait",
            "current"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nstatic inline void coda_waitfor_upcall(struct venus_comm *vcp,\n\t\t\t\t       struct upc_req *req)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tunsigned long timeout = jiffies + coda_timeout * HZ;\n\tsigset_t old;\n\tint blocked;\n\n\tcoda_block_signals(&old);\n\tblocked = 1;\n\n\tadd_wait_queue(&req->uc_sleep, &wait);\n\tfor (;;) {\n\t\tif (CODA_INTERRUPTIBLE(req))\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\telse\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\n\t\t/* got a reply */\n\t\tif (req->uc_flags & (CODA_REQ_WRITE | CODA_REQ_ABORT))\n\t\t\tbreak;\n\n\t\tif (blocked && time_after(jiffies, timeout) &&\n\t\t    CODA_INTERRUPTIBLE(req))\n\t\t{\n\t\t\tcoda_unblock_signals(&old);\n\t\t\tblocked = 0;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\tlist_del(&req->uc_chain);\n\t\t\tbreak;\n\t\t}\n\n\t\tmutex_unlock(&vcp->vc_mutex);\n\t\tif (blocked)\n\t\t\tschedule_timeout(HZ);\n\t\telse\n\t\t\tschedule();\n\t\tmutex_lock(&vcp->vc_mutex);\n\t}\n\tif (blocked)\n\t\tcoda_unblock_signals(&old);\n\n\tremove_wait_queue(&req->uc_sleep, &wait);\n\tset_current_state(TASK_RUNNING);\n}"
  },
  {
    "function_name": "coda_unblock_signals",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
    "lines": "589-595",
    "snippet": "static void coda_unblock_signals(sigset_t *old)\n{\n\tspin_lock_irq(&current->sighand->siglock);\n\tcurrent->blocked = *old;\n\trecalc_sigpending();\n\tspin_unlock_irq(&current->sighand->siglock);\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_cache.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/vfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recalc_sigpending",
          "args": [],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nstatic void coda_unblock_signals(sigset_t *old)\n{\n\tspin_lock_irq(&current->sighand->siglock);\n\tcurrent->blocked = *old;\n\trecalc_sigpending();\n\tspin_unlock_irq(&current->sighand->siglock);\n}"
  },
  {
    "function_name": "coda_block_signals",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
    "lines": "575-587",
    "snippet": "static void coda_block_signals(sigset_t *old)\n{\n\tspin_lock_irq(&current->sighand->siglock);\n\t*old = current->blocked;\n\n\tsigfillset(&current->blocked);\n\tsigdelset(&current->blocked, SIGKILL);\n\tsigdelset(&current->blocked, SIGSTOP);\n\tsigdelset(&current->blocked, SIGINT);\n\n\trecalc_sigpending();\n\tspin_unlock_irq(&current->sighand->siglock);\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_cache.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/vfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recalc_sigpending",
          "args": [],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigdelset",
          "args": [
            "&current->blocked",
            "SIGINT"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigdelset",
          "args": [
            "&current->blocked",
            "SIGSTOP"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigdelset",
          "args": [
            "&current->blocked",
            "SIGKILL"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigfillset",
          "args": [
            "&current->blocked"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nstatic void coda_block_signals(sigset_t *old)\n{\n\tspin_lock_irq(&current->sighand->siglock);\n\t*old = current->blocked;\n\n\tsigfillset(&current->blocked);\n\tsigdelset(&current->blocked, SIGKILL);\n\tsigdelset(&current->blocked, SIGSTOP);\n\tsigdelset(&current->blocked, SIGINT);\n\n\trecalc_sigpending();\n\tspin_unlock_irq(&current->sighand->siglock);\n}"
  },
  {
    "function_name": "venus_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
    "lines": "550-570",
    "snippet": "int venus_statfs(struct dentry *dentry, struct kstatfs *sfs)\n{ \n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n        \n\tinsize = max_t(unsigned int, INSIZE(statfs), OUTSIZE(statfs));\n\tUPARG(CODA_STATFS);\n\n\terror = coda_upcall(coda_vcp(dentry->d_sb), insize, &outsize, inp);\n\tif (!error) {\n\t\tsfs->f_blocks = outp->coda_statfs.stat.f_blocks;\n\t\tsfs->f_bfree  = outp->coda_statfs.stat.f_bfree;\n\t\tsfs->f_bavail = outp->coda_statfs.stat.f_bavail;\n\t\tsfs->f_files  = outp->coda_statfs.stat.f_files;\n\t\tsfs->f_ffree  = outp->coda_statfs.stat.f_ffree;\n\t}\n\n        CODA_FREE(inp, insize);\n        return error;\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_cache.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/vfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CODA_FREE",
          "args": [
            "inp",
            "insize"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coda_upcall",
          "args": [
            "coda_vcp(dentry->d_sb)",
            "insize",
            "&outsize",
            "inp"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "coda_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
          "lines": "666-771",
          "snippet": "static int coda_upcall(struct venus_comm *vcp,\n\t\t       int inSize, int *outSize,\n\t\t       union inputArgs *buffer)\n{\n\tunion outputArgs *out;\n\tunion inputArgs *sig_inputArgs;\n\tstruct upc_req *req = NULL, *sig_req;\n\tint error;\n\n\tmutex_lock(&vcp->vc_mutex);\n\n\tif (!vcp->vc_inuse) {\n\t\tpr_notice(\"Venus dead, not sending upcall\\n\");\n\t\terror = -ENXIO;\n\t\tgoto exit;\n\t}\n\n\t/* Format the request message. */\n\treq = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!req) {\n\t\terror = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\treq->uc_data = (void *)buffer;\n\treq->uc_flags = 0;\n\treq->uc_inSize = inSize;\n\treq->uc_outSize = *outSize ? *outSize : inSize;\n\treq->uc_opcode = ((union inputArgs *)buffer)->ih.opcode;\n\treq->uc_unique = ++vcp->vc_seq;\n\tinit_waitqueue_head(&req->uc_sleep);\n\n\t/* Fill in the common input args. */\n\t((union inputArgs *)buffer)->ih.unique = req->uc_unique;\n\n\t/* Append msg to pending queue and poke Venus. */\n\tlist_add_tail(&req->uc_chain, &vcp->vc_pending);\n\n\twake_up_interruptible(&vcp->vc_waitq);\n\t/* We can be interrupted while we wait for Venus to process\n\t * our request.  If the interrupt occurs before Venus has read\n\t * the request, we dequeue and return. If it occurs after the\n\t * read but before the reply, we dequeue, send a signal\n\t * message, and return. If it occurs after the reply we ignore\n\t * it. In no case do we want to restart the syscall.  If it\n\t * was interrupted by a venus shutdown (psdev_close), return\n\t * ENODEV.  */\n\n\t/* Go to sleep.  Wake up on signals only after the timeout. */\n\tcoda_waitfor_upcall(vcp, req);\n\n\t/* Op went through, interrupt or not... */\n\tif (req->uc_flags & CODA_REQ_WRITE) {\n\t\tout = (union outputArgs *)req->uc_data;\n\t\t/* here we map positive Venus errors to kernel errors */\n\t\terror = -out->oh.result;\n\t\t*outSize = req->uc_outSize;\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tif ((req->uc_flags & CODA_REQ_ABORT) || !signal_pending(current)) {\n\t\tpr_warn(\"Unexpected interruption.\\n\");\n\t\tgoto exit;\n\t}\n\n\t/* Interrupted before venus read it. */\n\tif (!(req->uc_flags & CODA_REQ_READ))\n\t\tgoto exit;\n\n\t/* Venus saw the upcall, make sure we can send interrupt signal */\n\tif (!vcp->vc_inuse) {\n\t\tpr_info(\"Venus dead, not sending signal.\\n\");\n\t\tgoto exit;\n\t}\n\n\terror = -ENOMEM;\n\tsig_req = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!sig_req) goto exit;\n\n\tCODA_ALLOC((sig_req->uc_data), char *, sizeof(struct coda_in_hdr));\n\tif (!sig_req->uc_data) {\n\t\tkfree(sig_req);\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tsig_inputArgs = (union inputArgs *)sig_req->uc_data;\n\tsig_inputArgs->ih.opcode = CODA_SIGNAL;\n\tsig_inputArgs->ih.unique = req->uc_unique;\n\n\tsig_req->uc_flags = CODA_REQ_ASYNC;\n\tsig_req->uc_opcode = sig_inputArgs->ih.opcode;\n\tsig_req->uc_unique = sig_inputArgs->ih.unique;\n\tsig_req->uc_inSize = sizeof(struct coda_in_hdr);\n\tsig_req->uc_outSize = sizeof(struct coda_in_hdr);\n\n\t/* insert at head of queue! */\n\tlist_add(&(sig_req->uc_chain), &vcp->vc_pending);\n\twake_up_interruptible(&vcp->vc_waitq);\n\nexit:\n\tkfree(req);\n\tmutex_unlock(&vcp->vc_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/vfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int coda_upcall(struct venus_comm *vc, int inSize, int *outSize,\n\t\t       union inputArgs *buffer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nstatic int coda_upcall(struct venus_comm *vc, int inSize, int *outSize,\n\t\t       union inputArgs *buffer);\n\nstatic int coda_upcall(struct venus_comm *vcp,\n\t\t       int inSize, int *outSize,\n\t\t       union inputArgs *buffer)\n{\n\tunion outputArgs *out;\n\tunion inputArgs *sig_inputArgs;\n\tstruct upc_req *req = NULL, *sig_req;\n\tint error;\n\n\tmutex_lock(&vcp->vc_mutex);\n\n\tif (!vcp->vc_inuse) {\n\t\tpr_notice(\"Venus dead, not sending upcall\\n\");\n\t\terror = -ENXIO;\n\t\tgoto exit;\n\t}\n\n\t/* Format the request message. */\n\treq = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!req) {\n\t\terror = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\treq->uc_data = (void *)buffer;\n\treq->uc_flags = 0;\n\treq->uc_inSize = inSize;\n\treq->uc_outSize = *outSize ? *outSize : inSize;\n\treq->uc_opcode = ((union inputArgs *)buffer)->ih.opcode;\n\treq->uc_unique = ++vcp->vc_seq;\n\tinit_waitqueue_head(&req->uc_sleep);\n\n\t/* Fill in the common input args. */\n\t((union inputArgs *)buffer)->ih.unique = req->uc_unique;\n\n\t/* Append msg to pending queue and poke Venus. */\n\tlist_add_tail(&req->uc_chain, &vcp->vc_pending);\n\n\twake_up_interruptible(&vcp->vc_waitq);\n\t/* We can be interrupted while we wait for Venus to process\n\t * our request.  If the interrupt occurs before Venus has read\n\t * the request, we dequeue and return. If it occurs after the\n\t * read but before the reply, we dequeue, send a signal\n\t * message, and return. If it occurs after the reply we ignore\n\t * it. In no case do we want to restart the syscall.  If it\n\t * was interrupted by a venus shutdown (psdev_close), return\n\t * ENODEV.  */\n\n\t/* Go to sleep.  Wake up on signals only after the timeout. */\n\tcoda_waitfor_upcall(vcp, req);\n\n\t/* Op went through, interrupt or not... */\n\tif (req->uc_flags & CODA_REQ_WRITE) {\n\t\tout = (union outputArgs *)req->uc_data;\n\t\t/* here we map positive Venus errors to kernel errors */\n\t\terror = -out->oh.result;\n\t\t*outSize = req->uc_outSize;\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tif ((req->uc_flags & CODA_REQ_ABORT) || !signal_pending(current)) {\n\t\tpr_warn(\"Unexpected interruption.\\n\");\n\t\tgoto exit;\n\t}\n\n\t/* Interrupted before venus read it. */\n\tif (!(req->uc_flags & CODA_REQ_READ))\n\t\tgoto exit;\n\n\t/* Venus saw the upcall, make sure we can send interrupt signal */\n\tif (!vcp->vc_inuse) {\n\t\tpr_info(\"Venus dead, not sending signal.\\n\");\n\t\tgoto exit;\n\t}\n\n\terror = -ENOMEM;\n\tsig_req = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!sig_req) goto exit;\n\n\tCODA_ALLOC((sig_req->uc_data), char *, sizeof(struct coda_in_hdr));\n\tif (!sig_req->uc_data) {\n\t\tkfree(sig_req);\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tsig_inputArgs = (union inputArgs *)sig_req->uc_data;\n\tsig_inputArgs->ih.opcode = CODA_SIGNAL;\n\tsig_inputArgs->ih.unique = req->uc_unique;\n\n\tsig_req->uc_flags = CODA_REQ_ASYNC;\n\tsig_req->uc_opcode = sig_inputArgs->ih.opcode;\n\tsig_req->uc_unique = sig_inputArgs->ih.unique;\n\tsig_req->uc_inSize = sizeof(struct coda_in_hdr);\n\tsig_req->uc_outSize = sizeof(struct coda_in_hdr);\n\n\t/* insert at head of queue! */\n\tlist_add(&(sig_req->uc_chain), &vcp->vc_pending);\n\twake_up_interruptible(&vcp->vc_waitq);\n\nexit:\n\tkfree(req);\n\tmutex_unlock(&vcp->vc_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_vcp",
          "args": [
            "dentry->d_sb"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UPARG",
          "args": [
            "CODA_STATFS"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "unsignedint",
            "INSIZE(statfs)",
            "OUTSIZE(statfs)"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTSIZE",
          "args": [
            "statfs"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INSIZE",
          "args": [
            "statfs"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nint venus_statfs(struct dentry *dentry, struct kstatfs *sfs)\n{ \n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n        \n\tinsize = max_t(unsigned int, INSIZE(statfs), OUTSIZE(statfs));\n\tUPARG(CODA_STATFS);\n\n\terror = coda_upcall(coda_vcp(dentry->d_sb), insize, &outsize, inp);\n\tif (!error) {\n\t\tsfs->f_blocks = outp->coda_statfs.stat.f_blocks;\n\t\tsfs->f_bfree  = outp->coda_statfs.stat.f_bfree;\n\t\tsfs->f_bavail = outp->coda_statfs.stat.f_bavail;\n\t\tsfs->f_files  = outp->coda_statfs.stat.f_files;\n\t\tsfs->f_ffree  = outp->coda_statfs.stat.f_ffree;\n\t}\n\n        CODA_FREE(inp, insize);\n        return error;\n}"
  },
  {
    "function_name": "venus_pioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
    "lines": "475-548",
    "snippet": "int venus_pioctl(struct super_block *sb, struct CodaFid *fid,\n\t\t unsigned int cmd, struct PioctlData *data)\n{\n        union inputArgs *inp;\n        union outputArgs *outp;  \n\tint insize, outsize, error;\n\tint iocsize;\n\n\tinsize = VC_MAXMSGSIZE;\n\tUPARG(CODA_IOCTL);\n\n        /* build packet for Venus */\n        if (data->vi.in_size > VC_MAXDATASIZE) {\n\t\terror = -EINVAL;\n\t\tgoto exit;\n        }\n\n        if (data->vi.out_size > VC_MAXDATASIZE) {\n\t\terror = -EINVAL;\n\t\tgoto exit;\n\t}\n\n        inp->coda_ioctl.VFid = *fid;\n    \n        /* the cmd field was mutated by increasing its size field to\n         * reflect the path and follow args. We need to subtract that\n         * out before sending the command to Venus.  */\n        inp->coda_ioctl.cmd = (cmd & ~(PIOCPARM_MASK << 16));\t\n        iocsize = ((cmd >> 16) & PIOCPARM_MASK) - sizeof(char *) - sizeof(int);\n        inp->coda_ioctl.cmd |= (iocsize & PIOCPARM_MASK) <<\t16;\t\n    \n        /* in->coda_ioctl.rwflag = flag; */\n        inp->coda_ioctl.len = data->vi.in_size;\n        inp->coda_ioctl.data = (char *)(INSIZE(ioctl));\n     \n        /* get the data out of user space */\n\tif (copy_from_user((char *)inp + (long)inp->coda_ioctl.data,\n\t\t\t   data->vi.in, data->vi.in_size)) {\n\t\terror = -EINVAL;\n\t        goto exit;\n\t}\n\n\terror = coda_upcall(coda_vcp(sb), SIZE(ioctl) + data->vi.in_size,\n\t\t\t    &outsize, inp);\n\n        if (error) {\n\t\tpr_warn(\"%s: Venus returns: %d for %s\\n\",\n\t\t\t__func__, error, coda_f2s(fid));\n\t\tgoto exit; \n\t}\n\n\tif (outsize < (long)outp->coda_ioctl.data + outp->coda_ioctl.len) {\n\t\terror = -EINVAL;\n\t\tgoto exit;\n\t}\n        \n\t/* Copy out the OUT buffer. */\n        if (outp->coda_ioctl.len > data->vi.out_size) {\n\t\terror = -EINVAL;\n\t\tgoto exit;\n        }\n\n\t/* Copy out the OUT buffer. */\n\tif (copy_to_user(data->vi.out,\n\t\t\t (char *)outp + (long)outp->coda_ioctl.data,\n\t\t\t outp->coda_ioctl.len)) {\n\t\terror = -EFAULT;\n\t\tgoto exit;\n\t}\n\n exit:\n\tCODA_FREE(inp, insize);\n\treturn error;\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_cache.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/vfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int coda_upcall(struct venus_comm *vc, int inSize, int *outSize,\n\t\t       union inputArgs *buffer);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CODA_FREE",
          "args": [
            "inp",
            "insize"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "data->vi.out",
            "(char *)outp + (long)outp->coda_ioctl.data",
            "outp->coda_ioctl.len"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: Venus returns: %d for %s\\n\"",
            "__func__",
            "error",
            "coda_f2s(fid)"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coda_f2s",
          "args": [
            "fid"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "coda_f2s",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/coda_linux.c",
          "lines": "27-34",
          "snippet": "char * coda_f2s(struct CodaFid *f)\n{\n\tstatic char s[60];\n\n \tsprintf(s, \"(%08x.%08x.%08x.%08x)\", f->opaque[0], f->opaque[1], f->opaque[2], f->opaque[3]);\n\n\treturn s;\n}",
          "includes": [
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nchar * coda_f2s(struct CodaFid *f)\n{\n\tstatic char s[60];\n\n \tsprintf(s, \"(%08x.%08x.%08x.%08x)\", f->opaque[0], f->opaque[1], f->opaque[2], f->opaque[3]);\n\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_upcall",
          "args": [
            "coda_vcp(sb)",
            "SIZE(ioctl) + data->vi.in_size",
            "&outsize",
            "inp"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "coda_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
          "lines": "666-771",
          "snippet": "static int coda_upcall(struct venus_comm *vcp,\n\t\t       int inSize, int *outSize,\n\t\t       union inputArgs *buffer)\n{\n\tunion outputArgs *out;\n\tunion inputArgs *sig_inputArgs;\n\tstruct upc_req *req = NULL, *sig_req;\n\tint error;\n\n\tmutex_lock(&vcp->vc_mutex);\n\n\tif (!vcp->vc_inuse) {\n\t\tpr_notice(\"Venus dead, not sending upcall\\n\");\n\t\terror = -ENXIO;\n\t\tgoto exit;\n\t}\n\n\t/* Format the request message. */\n\treq = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!req) {\n\t\terror = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\treq->uc_data = (void *)buffer;\n\treq->uc_flags = 0;\n\treq->uc_inSize = inSize;\n\treq->uc_outSize = *outSize ? *outSize : inSize;\n\treq->uc_opcode = ((union inputArgs *)buffer)->ih.opcode;\n\treq->uc_unique = ++vcp->vc_seq;\n\tinit_waitqueue_head(&req->uc_sleep);\n\n\t/* Fill in the common input args. */\n\t((union inputArgs *)buffer)->ih.unique = req->uc_unique;\n\n\t/* Append msg to pending queue and poke Venus. */\n\tlist_add_tail(&req->uc_chain, &vcp->vc_pending);\n\n\twake_up_interruptible(&vcp->vc_waitq);\n\t/* We can be interrupted while we wait for Venus to process\n\t * our request.  If the interrupt occurs before Venus has read\n\t * the request, we dequeue and return. If it occurs after the\n\t * read but before the reply, we dequeue, send a signal\n\t * message, and return. If it occurs after the reply we ignore\n\t * it. In no case do we want to restart the syscall.  If it\n\t * was interrupted by a venus shutdown (psdev_close), return\n\t * ENODEV.  */\n\n\t/* Go to sleep.  Wake up on signals only after the timeout. */\n\tcoda_waitfor_upcall(vcp, req);\n\n\t/* Op went through, interrupt or not... */\n\tif (req->uc_flags & CODA_REQ_WRITE) {\n\t\tout = (union outputArgs *)req->uc_data;\n\t\t/* here we map positive Venus errors to kernel errors */\n\t\terror = -out->oh.result;\n\t\t*outSize = req->uc_outSize;\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tif ((req->uc_flags & CODA_REQ_ABORT) || !signal_pending(current)) {\n\t\tpr_warn(\"Unexpected interruption.\\n\");\n\t\tgoto exit;\n\t}\n\n\t/* Interrupted before venus read it. */\n\tif (!(req->uc_flags & CODA_REQ_READ))\n\t\tgoto exit;\n\n\t/* Venus saw the upcall, make sure we can send interrupt signal */\n\tif (!vcp->vc_inuse) {\n\t\tpr_info(\"Venus dead, not sending signal.\\n\");\n\t\tgoto exit;\n\t}\n\n\terror = -ENOMEM;\n\tsig_req = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!sig_req) goto exit;\n\n\tCODA_ALLOC((sig_req->uc_data), char *, sizeof(struct coda_in_hdr));\n\tif (!sig_req->uc_data) {\n\t\tkfree(sig_req);\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tsig_inputArgs = (union inputArgs *)sig_req->uc_data;\n\tsig_inputArgs->ih.opcode = CODA_SIGNAL;\n\tsig_inputArgs->ih.unique = req->uc_unique;\n\n\tsig_req->uc_flags = CODA_REQ_ASYNC;\n\tsig_req->uc_opcode = sig_inputArgs->ih.opcode;\n\tsig_req->uc_unique = sig_inputArgs->ih.unique;\n\tsig_req->uc_inSize = sizeof(struct coda_in_hdr);\n\tsig_req->uc_outSize = sizeof(struct coda_in_hdr);\n\n\t/* insert at head of queue! */\n\tlist_add(&(sig_req->uc_chain), &vcp->vc_pending);\n\twake_up_interruptible(&vcp->vc_waitq);\n\nexit:\n\tkfree(req);\n\tmutex_unlock(&vcp->vc_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/vfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int coda_upcall(struct venus_comm *vc, int inSize, int *outSize,\n\t\t       union inputArgs *buffer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nstatic int coda_upcall(struct venus_comm *vc, int inSize, int *outSize,\n\t\t       union inputArgs *buffer);\n\nstatic int coda_upcall(struct venus_comm *vcp,\n\t\t       int inSize, int *outSize,\n\t\t       union inputArgs *buffer)\n{\n\tunion outputArgs *out;\n\tunion inputArgs *sig_inputArgs;\n\tstruct upc_req *req = NULL, *sig_req;\n\tint error;\n\n\tmutex_lock(&vcp->vc_mutex);\n\n\tif (!vcp->vc_inuse) {\n\t\tpr_notice(\"Venus dead, not sending upcall\\n\");\n\t\terror = -ENXIO;\n\t\tgoto exit;\n\t}\n\n\t/* Format the request message. */\n\treq = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!req) {\n\t\terror = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\treq->uc_data = (void *)buffer;\n\treq->uc_flags = 0;\n\treq->uc_inSize = inSize;\n\treq->uc_outSize = *outSize ? *outSize : inSize;\n\treq->uc_opcode = ((union inputArgs *)buffer)->ih.opcode;\n\treq->uc_unique = ++vcp->vc_seq;\n\tinit_waitqueue_head(&req->uc_sleep);\n\n\t/* Fill in the common input args. */\n\t((union inputArgs *)buffer)->ih.unique = req->uc_unique;\n\n\t/* Append msg to pending queue and poke Venus. */\n\tlist_add_tail(&req->uc_chain, &vcp->vc_pending);\n\n\twake_up_interruptible(&vcp->vc_waitq);\n\t/* We can be interrupted while we wait for Venus to process\n\t * our request.  If the interrupt occurs before Venus has read\n\t * the request, we dequeue and return. If it occurs after the\n\t * read but before the reply, we dequeue, send a signal\n\t * message, and return. If it occurs after the reply we ignore\n\t * it. In no case do we want to restart the syscall.  If it\n\t * was interrupted by a venus shutdown (psdev_close), return\n\t * ENODEV.  */\n\n\t/* Go to sleep.  Wake up on signals only after the timeout. */\n\tcoda_waitfor_upcall(vcp, req);\n\n\t/* Op went through, interrupt or not... */\n\tif (req->uc_flags & CODA_REQ_WRITE) {\n\t\tout = (union outputArgs *)req->uc_data;\n\t\t/* here we map positive Venus errors to kernel errors */\n\t\terror = -out->oh.result;\n\t\t*outSize = req->uc_outSize;\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tif ((req->uc_flags & CODA_REQ_ABORT) || !signal_pending(current)) {\n\t\tpr_warn(\"Unexpected interruption.\\n\");\n\t\tgoto exit;\n\t}\n\n\t/* Interrupted before venus read it. */\n\tif (!(req->uc_flags & CODA_REQ_READ))\n\t\tgoto exit;\n\n\t/* Venus saw the upcall, make sure we can send interrupt signal */\n\tif (!vcp->vc_inuse) {\n\t\tpr_info(\"Venus dead, not sending signal.\\n\");\n\t\tgoto exit;\n\t}\n\n\terror = -ENOMEM;\n\tsig_req = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!sig_req) goto exit;\n\n\tCODA_ALLOC((sig_req->uc_data), char *, sizeof(struct coda_in_hdr));\n\tif (!sig_req->uc_data) {\n\t\tkfree(sig_req);\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tsig_inputArgs = (union inputArgs *)sig_req->uc_data;\n\tsig_inputArgs->ih.opcode = CODA_SIGNAL;\n\tsig_inputArgs->ih.unique = req->uc_unique;\n\n\tsig_req->uc_flags = CODA_REQ_ASYNC;\n\tsig_req->uc_opcode = sig_inputArgs->ih.opcode;\n\tsig_req->uc_unique = sig_inputArgs->ih.unique;\n\tsig_req->uc_inSize = sizeof(struct coda_in_hdr);\n\tsig_req->uc_outSize = sizeof(struct coda_in_hdr);\n\n\t/* insert at head of queue! */\n\tlist_add(&(sig_req->uc_chain), &vcp->vc_pending);\n\twake_up_interruptible(&vcp->vc_waitq);\n\nexit:\n\tkfree(req);\n\tmutex_unlock(&vcp->vc_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIZE",
          "args": [
            "ioctl"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "MPTY_SCAN_SIZE(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
          "lines": "62-67",
          "snippet": "tatic inline uint32_t EMPTY_SCAN_SIZE(uint32_t sector_size) {\n\tif (sector_size < DEFAULT_EMPTY_SCAN_SIZE)\n\t\treturn sector_size;\n\telse\n\t\treturn DEFAULT_EMPTY_SCAN_SIZE;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"summary.h\"\n#",
            "include \"nodelist.h\"\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic inline uint32_t EMPTY_SCAN_SIZE(uint32_t sector_size) {\n\tif (sector_size < DEFAULT_EMPTY_SCAN_SIZE)\n\t\treturn sector_size;\n\telse\n\t\treturn DEFAULT_EMPTY_SCAN_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_vcp",
          "args": [
            "sb"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "(char *)inp + (long)inp->coda_ioctl.data",
            "data->vi.in",
            "data->vi.in_size"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INSIZE",
          "args": [
            "ioctl"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UPARG",
          "args": [
            "CODA_IOCTL"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nstatic int coda_upcall(struct venus_comm *vc, int inSize, int *outSize,\n\t\t       union inputArgs *buffer);\n\nint venus_pioctl(struct super_block *sb, struct CodaFid *fid,\n\t\t unsigned int cmd, struct PioctlData *data)\n{\n        union inputArgs *inp;\n        union outputArgs *outp;  \n\tint insize, outsize, error;\n\tint iocsize;\n\n\tinsize = VC_MAXMSGSIZE;\n\tUPARG(CODA_IOCTL);\n\n        /* build packet for Venus */\n        if (data->vi.in_size > VC_MAXDATASIZE) {\n\t\terror = -EINVAL;\n\t\tgoto exit;\n        }\n\n        if (data->vi.out_size > VC_MAXDATASIZE) {\n\t\terror = -EINVAL;\n\t\tgoto exit;\n\t}\n\n        inp->coda_ioctl.VFid = *fid;\n    \n        /* the cmd field was mutated by increasing its size field to\n         * reflect the path and follow args. We need to subtract that\n         * out before sending the command to Venus.  */\n        inp->coda_ioctl.cmd = (cmd & ~(PIOCPARM_MASK << 16));\t\n        iocsize = ((cmd >> 16) & PIOCPARM_MASK) - sizeof(char *) - sizeof(int);\n        inp->coda_ioctl.cmd |= (iocsize & PIOCPARM_MASK) <<\t16;\t\n    \n        /* in->coda_ioctl.rwflag = flag; */\n        inp->coda_ioctl.len = data->vi.in_size;\n        inp->coda_ioctl.data = (char *)(INSIZE(ioctl));\n     \n        /* get the data out of user space */\n\tif (copy_from_user((char *)inp + (long)inp->coda_ioctl.data,\n\t\t\t   data->vi.in, data->vi.in_size)) {\n\t\terror = -EINVAL;\n\t        goto exit;\n\t}\n\n\terror = coda_upcall(coda_vcp(sb), SIZE(ioctl) + data->vi.in_size,\n\t\t\t    &outsize, inp);\n\n        if (error) {\n\t\tpr_warn(\"%s: Venus returns: %d for %s\\n\",\n\t\t\t__func__, error, coda_f2s(fid));\n\t\tgoto exit; \n\t}\n\n\tif (outsize < (long)outp->coda_ioctl.data + outp->coda_ioctl.len) {\n\t\terror = -EINVAL;\n\t\tgoto exit;\n\t}\n        \n\t/* Copy out the OUT buffer. */\n        if (outp->coda_ioctl.len > data->vi.out_size) {\n\t\terror = -EINVAL;\n\t\tgoto exit;\n        }\n\n\t/* Copy out the OUT buffer. */\n\tif (copy_to_user(data->vi.out,\n\t\t\t (char *)outp + (long)outp->coda_ioctl.data,\n\t\t\t outp->coda_ioctl.len)) {\n\t\terror = -EFAULT;\n\t\tgoto exit;\n\t}\n\n exit:\n\tCODA_FREE(inp, insize);\n\treturn error;\n}"
  },
  {
    "function_name": "venus_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
    "lines": "456-472",
    "snippet": "int venus_access(struct super_block *sb, struct CodaFid *fid, int mask)\n{\n        union inputArgs *inp;\n        union outputArgs *outp; \n\tint insize, outsize, error;\n\n\tinsize = SIZE(access);\n\tUPARG(CODA_ACCESS);\n\n        inp->coda_access.VFid = *fid;\n        inp->coda_access.flags = mask;\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\n\tCODA_FREE(inp, insize);\n\treturn error;\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_cache.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/vfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CODA_FREE",
          "args": [
            "inp",
            "insize"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coda_upcall",
          "args": [
            "coda_vcp(sb)",
            "insize",
            "&outsize",
            "inp"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "coda_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
          "lines": "666-771",
          "snippet": "static int coda_upcall(struct venus_comm *vcp,\n\t\t       int inSize, int *outSize,\n\t\t       union inputArgs *buffer)\n{\n\tunion outputArgs *out;\n\tunion inputArgs *sig_inputArgs;\n\tstruct upc_req *req = NULL, *sig_req;\n\tint error;\n\n\tmutex_lock(&vcp->vc_mutex);\n\n\tif (!vcp->vc_inuse) {\n\t\tpr_notice(\"Venus dead, not sending upcall\\n\");\n\t\terror = -ENXIO;\n\t\tgoto exit;\n\t}\n\n\t/* Format the request message. */\n\treq = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!req) {\n\t\terror = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\treq->uc_data = (void *)buffer;\n\treq->uc_flags = 0;\n\treq->uc_inSize = inSize;\n\treq->uc_outSize = *outSize ? *outSize : inSize;\n\treq->uc_opcode = ((union inputArgs *)buffer)->ih.opcode;\n\treq->uc_unique = ++vcp->vc_seq;\n\tinit_waitqueue_head(&req->uc_sleep);\n\n\t/* Fill in the common input args. */\n\t((union inputArgs *)buffer)->ih.unique = req->uc_unique;\n\n\t/* Append msg to pending queue and poke Venus. */\n\tlist_add_tail(&req->uc_chain, &vcp->vc_pending);\n\n\twake_up_interruptible(&vcp->vc_waitq);\n\t/* We can be interrupted while we wait for Venus to process\n\t * our request.  If the interrupt occurs before Venus has read\n\t * the request, we dequeue and return. If it occurs after the\n\t * read but before the reply, we dequeue, send a signal\n\t * message, and return. If it occurs after the reply we ignore\n\t * it. In no case do we want to restart the syscall.  If it\n\t * was interrupted by a venus shutdown (psdev_close), return\n\t * ENODEV.  */\n\n\t/* Go to sleep.  Wake up on signals only after the timeout. */\n\tcoda_waitfor_upcall(vcp, req);\n\n\t/* Op went through, interrupt or not... */\n\tif (req->uc_flags & CODA_REQ_WRITE) {\n\t\tout = (union outputArgs *)req->uc_data;\n\t\t/* here we map positive Venus errors to kernel errors */\n\t\terror = -out->oh.result;\n\t\t*outSize = req->uc_outSize;\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tif ((req->uc_flags & CODA_REQ_ABORT) || !signal_pending(current)) {\n\t\tpr_warn(\"Unexpected interruption.\\n\");\n\t\tgoto exit;\n\t}\n\n\t/* Interrupted before venus read it. */\n\tif (!(req->uc_flags & CODA_REQ_READ))\n\t\tgoto exit;\n\n\t/* Venus saw the upcall, make sure we can send interrupt signal */\n\tif (!vcp->vc_inuse) {\n\t\tpr_info(\"Venus dead, not sending signal.\\n\");\n\t\tgoto exit;\n\t}\n\n\terror = -ENOMEM;\n\tsig_req = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!sig_req) goto exit;\n\n\tCODA_ALLOC((sig_req->uc_data), char *, sizeof(struct coda_in_hdr));\n\tif (!sig_req->uc_data) {\n\t\tkfree(sig_req);\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tsig_inputArgs = (union inputArgs *)sig_req->uc_data;\n\tsig_inputArgs->ih.opcode = CODA_SIGNAL;\n\tsig_inputArgs->ih.unique = req->uc_unique;\n\n\tsig_req->uc_flags = CODA_REQ_ASYNC;\n\tsig_req->uc_opcode = sig_inputArgs->ih.opcode;\n\tsig_req->uc_unique = sig_inputArgs->ih.unique;\n\tsig_req->uc_inSize = sizeof(struct coda_in_hdr);\n\tsig_req->uc_outSize = sizeof(struct coda_in_hdr);\n\n\t/* insert at head of queue! */\n\tlist_add(&(sig_req->uc_chain), &vcp->vc_pending);\n\twake_up_interruptible(&vcp->vc_waitq);\n\nexit:\n\tkfree(req);\n\tmutex_unlock(&vcp->vc_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/vfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int coda_upcall(struct venus_comm *vc, int inSize, int *outSize,\n\t\t       union inputArgs *buffer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nstatic int coda_upcall(struct venus_comm *vc, int inSize, int *outSize,\n\t\t       union inputArgs *buffer);\n\nstatic int coda_upcall(struct venus_comm *vcp,\n\t\t       int inSize, int *outSize,\n\t\t       union inputArgs *buffer)\n{\n\tunion outputArgs *out;\n\tunion inputArgs *sig_inputArgs;\n\tstruct upc_req *req = NULL, *sig_req;\n\tint error;\n\n\tmutex_lock(&vcp->vc_mutex);\n\n\tif (!vcp->vc_inuse) {\n\t\tpr_notice(\"Venus dead, not sending upcall\\n\");\n\t\terror = -ENXIO;\n\t\tgoto exit;\n\t}\n\n\t/* Format the request message. */\n\treq = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!req) {\n\t\terror = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\treq->uc_data = (void *)buffer;\n\treq->uc_flags = 0;\n\treq->uc_inSize = inSize;\n\treq->uc_outSize = *outSize ? *outSize : inSize;\n\treq->uc_opcode = ((union inputArgs *)buffer)->ih.opcode;\n\treq->uc_unique = ++vcp->vc_seq;\n\tinit_waitqueue_head(&req->uc_sleep);\n\n\t/* Fill in the common input args. */\n\t((union inputArgs *)buffer)->ih.unique = req->uc_unique;\n\n\t/* Append msg to pending queue and poke Venus. */\n\tlist_add_tail(&req->uc_chain, &vcp->vc_pending);\n\n\twake_up_interruptible(&vcp->vc_waitq);\n\t/* We can be interrupted while we wait for Venus to process\n\t * our request.  If the interrupt occurs before Venus has read\n\t * the request, we dequeue and return. If it occurs after the\n\t * read but before the reply, we dequeue, send a signal\n\t * message, and return. If it occurs after the reply we ignore\n\t * it. In no case do we want to restart the syscall.  If it\n\t * was interrupted by a venus shutdown (psdev_close), return\n\t * ENODEV.  */\n\n\t/* Go to sleep.  Wake up on signals only after the timeout. */\n\tcoda_waitfor_upcall(vcp, req);\n\n\t/* Op went through, interrupt or not... */\n\tif (req->uc_flags & CODA_REQ_WRITE) {\n\t\tout = (union outputArgs *)req->uc_data;\n\t\t/* here we map positive Venus errors to kernel errors */\n\t\terror = -out->oh.result;\n\t\t*outSize = req->uc_outSize;\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tif ((req->uc_flags & CODA_REQ_ABORT) || !signal_pending(current)) {\n\t\tpr_warn(\"Unexpected interruption.\\n\");\n\t\tgoto exit;\n\t}\n\n\t/* Interrupted before venus read it. */\n\tif (!(req->uc_flags & CODA_REQ_READ))\n\t\tgoto exit;\n\n\t/* Venus saw the upcall, make sure we can send interrupt signal */\n\tif (!vcp->vc_inuse) {\n\t\tpr_info(\"Venus dead, not sending signal.\\n\");\n\t\tgoto exit;\n\t}\n\n\terror = -ENOMEM;\n\tsig_req = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!sig_req) goto exit;\n\n\tCODA_ALLOC((sig_req->uc_data), char *, sizeof(struct coda_in_hdr));\n\tif (!sig_req->uc_data) {\n\t\tkfree(sig_req);\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tsig_inputArgs = (union inputArgs *)sig_req->uc_data;\n\tsig_inputArgs->ih.opcode = CODA_SIGNAL;\n\tsig_inputArgs->ih.unique = req->uc_unique;\n\n\tsig_req->uc_flags = CODA_REQ_ASYNC;\n\tsig_req->uc_opcode = sig_inputArgs->ih.opcode;\n\tsig_req->uc_unique = sig_inputArgs->ih.unique;\n\tsig_req->uc_inSize = sizeof(struct coda_in_hdr);\n\tsig_req->uc_outSize = sizeof(struct coda_in_hdr);\n\n\t/* insert at head of queue! */\n\tlist_add(&(sig_req->uc_chain), &vcp->vc_pending);\n\twake_up_interruptible(&vcp->vc_waitq);\n\nexit:\n\tkfree(req);\n\tmutex_unlock(&vcp->vc_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_vcp",
          "args": [
            "sb"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UPARG",
          "args": [
            "CODA_ACCESS"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIZE",
          "args": [
            "access"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "MPTY_SCAN_SIZE(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
          "lines": "62-67",
          "snippet": "tatic inline uint32_t EMPTY_SCAN_SIZE(uint32_t sector_size) {\n\tif (sector_size < DEFAULT_EMPTY_SCAN_SIZE)\n\t\treturn sector_size;\n\telse\n\t\treturn DEFAULT_EMPTY_SCAN_SIZE;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"summary.h\"\n#",
            "include \"nodelist.h\"\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic inline uint32_t EMPTY_SCAN_SIZE(uint32_t sector_size) {\n\tif (sector_size < DEFAULT_EMPTY_SCAN_SIZE)\n\t\treturn sector_size;\n\telse\n\t\treturn DEFAULT_EMPTY_SCAN_SIZE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nint venus_access(struct super_block *sb, struct CodaFid *fid, int mask)\n{\n        union inputArgs *inp;\n        union outputArgs *outp; \n\tint insize, outsize, error;\n\n\tinsize = SIZE(access);\n\tUPARG(CODA_ACCESS);\n\n        inp->coda_access.VFid = *fid;\n        inp->coda_access.flags = mask;\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\n\tCODA_FREE(inp, insize);\n\treturn error;\n}"
  },
  {
    "function_name": "venus_fsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
    "lines": "439-454",
    "snippet": "int venus_fsync(struct super_block *sb, struct CodaFid *fid)\n{\n        union inputArgs *inp;\n        union outputArgs *outp; \n\tint insize, outsize, error;\n\t\n\tinsize=SIZE(fsync);\n\tUPARG(CODA_FSYNC);\n\n\tinp->coda_fsync.VFid = *fid;\n\terror = coda_upcall(coda_vcp(sb), sizeof(union inputArgs),\n\t\t\t    &outsize, inp);\n\n\tCODA_FREE(inp, insize);\n\treturn error;\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_cache.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/vfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CODA_FREE",
          "args": [
            "inp",
            "insize"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coda_upcall",
          "args": [
            "coda_vcp(sb)",
            "sizeof(union inputArgs)",
            "&outsize",
            "inp"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "coda_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
          "lines": "666-771",
          "snippet": "static int coda_upcall(struct venus_comm *vcp,\n\t\t       int inSize, int *outSize,\n\t\t       union inputArgs *buffer)\n{\n\tunion outputArgs *out;\n\tunion inputArgs *sig_inputArgs;\n\tstruct upc_req *req = NULL, *sig_req;\n\tint error;\n\n\tmutex_lock(&vcp->vc_mutex);\n\n\tif (!vcp->vc_inuse) {\n\t\tpr_notice(\"Venus dead, not sending upcall\\n\");\n\t\terror = -ENXIO;\n\t\tgoto exit;\n\t}\n\n\t/* Format the request message. */\n\treq = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!req) {\n\t\terror = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\treq->uc_data = (void *)buffer;\n\treq->uc_flags = 0;\n\treq->uc_inSize = inSize;\n\treq->uc_outSize = *outSize ? *outSize : inSize;\n\treq->uc_opcode = ((union inputArgs *)buffer)->ih.opcode;\n\treq->uc_unique = ++vcp->vc_seq;\n\tinit_waitqueue_head(&req->uc_sleep);\n\n\t/* Fill in the common input args. */\n\t((union inputArgs *)buffer)->ih.unique = req->uc_unique;\n\n\t/* Append msg to pending queue and poke Venus. */\n\tlist_add_tail(&req->uc_chain, &vcp->vc_pending);\n\n\twake_up_interruptible(&vcp->vc_waitq);\n\t/* We can be interrupted while we wait for Venus to process\n\t * our request.  If the interrupt occurs before Venus has read\n\t * the request, we dequeue and return. If it occurs after the\n\t * read but before the reply, we dequeue, send a signal\n\t * message, and return. If it occurs after the reply we ignore\n\t * it. In no case do we want to restart the syscall.  If it\n\t * was interrupted by a venus shutdown (psdev_close), return\n\t * ENODEV.  */\n\n\t/* Go to sleep.  Wake up on signals only after the timeout. */\n\tcoda_waitfor_upcall(vcp, req);\n\n\t/* Op went through, interrupt or not... */\n\tif (req->uc_flags & CODA_REQ_WRITE) {\n\t\tout = (union outputArgs *)req->uc_data;\n\t\t/* here we map positive Venus errors to kernel errors */\n\t\terror = -out->oh.result;\n\t\t*outSize = req->uc_outSize;\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tif ((req->uc_flags & CODA_REQ_ABORT) || !signal_pending(current)) {\n\t\tpr_warn(\"Unexpected interruption.\\n\");\n\t\tgoto exit;\n\t}\n\n\t/* Interrupted before venus read it. */\n\tif (!(req->uc_flags & CODA_REQ_READ))\n\t\tgoto exit;\n\n\t/* Venus saw the upcall, make sure we can send interrupt signal */\n\tif (!vcp->vc_inuse) {\n\t\tpr_info(\"Venus dead, not sending signal.\\n\");\n\t\tgoto exit;\n\t}\n\n\terror = -ENOMEM;\n\tsig_req = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!sig_req) goto exit;\n\n\tCODA_ALLOC((sig_req->uc_data), char *, sizeof(struct coda_in_hdr));\n\tif (!sig_req->uc_data) {\n\t\tkfree(sig_req);\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tsig_inputArgs = (union inputArgs *)sig_req->uc_data;\n\tsig_inputArgs->ih.opcode = CODA_SIGNAL;\n\tsig_inputArgs->ih.unique = req->uc_unique;\n\n\tsig_req->uc_flags = CODA_REQ_ASYNC;\n\tsig_req->uc_opcode = sig_inputArgs->ih.opcode;\n\tsig_req->uc_unique = sig_inputArgs->ih.unique;\n\tsig_req->uc_inSize = sizeof(struct coda_in_hdr);\n\tsig_req->uc_outSize = sizeof(struct coda_in_hdr);\n\n\t/* insert at head of queue! */\n\tlist_add(&(sig_req->uc_chain), &vcp->vc_pending);\n\twake_up_interruptible(&vcp->vc_waitq);\n\nexit:\n\tkfree(req);\n\tmutex_unlock(&vcp->vc_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/vfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int coda_upcall(struct venus_comm *vc, int inSize, int *outSize,\n\t\t       union inputArgs *buffer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nstatic int coda_upcall(struct venus_comm *vc, int inSize, int *outSize,\n\t\t       union inputArgs *buffer);\n\nstatic int coda_upcall(struct venus_comm *vcp,\n\t\t       int inSize, int *outSize,\n\t\t       union inputArgs *buffer)\n{\n\tunion outputArgs *out;\n\tunion inputArgs *sig_inputArgs;\n\tstruct upc_req *req = NULL, *sig_req;\n\tint error;\n\n\tmutex_lock(&vcp->vc_mutex);\n\n\tif (!vcp->vc_inuse) {\n\t\tpr_notice(\"Venus dead, not sending upcall\\n\");\n\t\terror = -ENXIO;\n\t\tgoto exit;\n\t}\n\n\t/* Format the request message. */\n\treq = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!req) {\n\t\terror = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\treq->uc_data = (void *)buffer;\n\treq->uc_flags = 0;\n\treq->uc_inSize = inSize;\n\treq->uc_outSize = *outSize ? *outSize : inSize;\n\treq->uc_opcode = ((union inputArgs *)buffer)->ih.opcode;\n\treq->uc_unique = ++vcp->vc_seq;\n\tinit_waitqueue_head(&req->uc_sleep);\n\n\t/* Fill in the common input args. */\n\t((union inputArgs *)buffer)->ih.unique = req->uc_unique;\n\n\t/* Append msg to pending queue and poke Venus. */\n\tlist_add_tail(&req->uc_chain, &vcp->vc_pending);\n\n\twake_up_interruptible(&vcp->vc_waitq);\n\t/* We can be interrupted while we wait for Venus to process\n\t * our request.  If the interrupt occurs before Venus has read\n\t * the request, we dequeue and return. If it occurs after the\n\t * read but before the reply, we dequeue, send a signal\n\t * message, and return. If it occurs after the reply we ignore\n\t * it. In no case do we want to restart the syscall.  If it\n\t * was interrupted by a venus shutdown (psdev_close), return\n\t * ENODEV.  */\n\n\t/* Go to sleep.  Wake up on signals only after the timeout. */\n\tcoda_waitfor_upcall(vcp, req);\n\n\t/* Op went through, interrupt or not... */\n\tif (req->uc_flags & CODA_REQ_WRITE) {\n\t\tout = (union outputArgs *)req->uc_data;\n\t\t/* here we map positive Venus errors to kernel errors */\n\t\terror = -out->oh.result;\n\t\t*outSize = req->uc_outSize;\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tif ((req->uc_flags & CODA_REQ_ABORT) || !signal_pending(current)) {\n\t\tpr_warn(\"Unexpected interruption.\\n\");\n\t\tgoto exit;\n\t}\n\n\t/* Interrupted before venus read it. */\n\tif (!(req->uc_flags & CODA_REQ_READ))\n\t\tgoto exit;\n\n\t/* Venus saw the upcall, make sure we can send interrupt signal */\n\tif (!vcp->vc_inuse) {\n\t\tpr_info(\"Venus dead, not sending signal.\\n\");\n\t\tgoto exit;\n\t}\n\n\terror = -ENOMEM;\n\tsig_req = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!sig_req) goto exit;\n\n\tCODA_ALLOC((sig_req->uc_data), char *, sizeof(struct coda_in_hdr));\n\tif (!sig_req->uc_data) {\n\t\tkfree(sig_req);\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tsig_inputArgs = (union inputArgs *)sig_req->uc_data;\n\tsig_inputArgs->ih.opcode = CODA_SIGNAL;\n\tsig_inputArgs->ih.unique = req->uc_unique;\n\n\tsig_req->uc_flags = CODA_REQ_ASYNC;\n\tsig_req->uc_opcode = sig_inputArgs->ih.opcode;\n\tsig_req->uc_unique = sig_inputArgs->ih.unique;\n\tsig_req->uc_inSize = sizeof(struct coda_in_hdr);\n\tsig_req->uc_outSize = sizeof(struct coda_in_hdr);\n\n\t/* insert at head of queue! */\n\tlist_add(&(sig_req->uc_chain), &vcp->vc_pending);\n\twake_up_interruptible(&vcp->vc_waitq);\n\nexit:\n\tkfree(req);\n\tmutex_unlock(&vcp->vc_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_vcp",
          "args": [
            "sb"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UPARG",
          "args": [
            "CODA_FSYNC"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIZE",
          "args": [
            "fsync"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "MPTY_SCAN_SIZE(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
          "lines": "62-67",
          "snippet": "tatic inline uint32_t EMPTY_SCAN_SIZE(uint32_t sector_size) {\n\tif (sector_size < DEFAULT_EMPTY_SCAN_SIZE)\n\t\treturn sector_size;\n\telse\n\t\treturn DEFAULT_EMPTY_SCAN_SIZE;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"summary.h\"\n#",
            "include \"nodelist.h\"\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic inline uint32_t EMPTY_SCAN_SIZE(uint32_t sector_size) {\n\tif (sector_size < DEFAULT_EMPTY_SCAN_SIZE)\n\t\treturn sector_size;\n\telse\n\t\treturn DEFAULT_EMPTY_SCAN_SIZE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nint venus_fsync(struct super_block *sb, struct CodaFid *fid)\n{\n        union inputArgs *inp;\n        union outputArgs *outp; \n\tint insize, outsize, error;\n\t\n\tinsize=SIZE(fsync);\n\tUPARG(CODA_FSYNC);\n\n\tinp->coda_fsync.VFid = *fid;\n\terror = coda_upcall(coda_vcp(sb), sizeof(union inputArgs),\n\t\t\t    &outsize, inp);\n\n\tCODA_FREE(inp, insize);\n\treturn error;\n}"
  },
  {
    "function_name": "venus_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
    "lines": "404-437",
    "snippet": "int venus_symlink(struct super_block *sb, struct CodaFid *fid,\n\t\t     const char *name, int len,\n\t\t     const char *symname, int symlen)\n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n        int offset, s;\n\n        offset = INSIZE(symlink);\n\tinsize = max_t(unsigned int, offset + len + symlen + 8, OUTSIZE(symlink));\n\tUPARG(CODA_SYMLINK);\n        \n        /*        inp->coda_symlink.attr = *tva; XXXXXX */ \n        inp->coda_symlink.VFid = *fid;\n\n\t/* Round up to word boundary and null terminate */\n        inp->coda_symlink.srcname = offset;\n        s = ( symlen  & ~0x3 ) + 4; \n        memcpy((char *)(inp) + offset, symname, symlen);\n        *((char *)inp + offset + symlen) = '\\0';\n        \n\t/* Round up to word boundary and null terminate */\n        offset += s;\n        inp->coda_symlink.tname = offset;\n        s = (len & ~0x3) + 4;\n        memcpy((char *)(inp) + offset, name, len);\n        *((char *)inp + offset + len) = '\\0';\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\n\tCODA_FREE(inp, insize);\n        return error;\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_cache.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/vfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CODA_FREE",
          "args": [
            "inp",
            "insize"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coda_upcall",
          "args": [
            "coda_vcp(sb)",
            "insize",
            "&outsize",
            "inp"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "coda_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
          "lines": "666-771",
          "snippet": "static int coda_upcall(struct venus_comm *vcp,\n\t\t       int inSize, int *outSize,\n\t\t       union inputArgs *buffer)\n{\n\tunion outputArgs *out;\n\tunion inputArgs *sig_inputArgs;\n\tstruct upc_req *req = NULL, *sig_req;\n\tint error;\n\n\tmutex_lock(&vcp->vc_mutex);\n\n\tif (!vcp->vc_inuse) {\n\t\tpr_notice(\"Venus dead, not sending upcall\\n\");\n\t\terror = -ENXIO;\n\t\tgoto exit;\n\t}\n\n\t/* Format the request message. */\n\treq = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!req) {\n\t\terror = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\treq->uc_data = (void *)buffer;\n\treq->uc_flags = 0;\n\treq->uc_inSize = inSize;\n\treq->uc_outSize = *outSize ? *outSize : inSize;\n\treq->uc_opcode = ((union inputArgs *)buffer)->ih.opcode;\n\treq->uc_unique = ++vcp->vc_seq;\n\tinit_waitqueue_head(&req->uc_sleep);\n\n\t/* Fill in the common input args. */\n\t((union inputArgs *)buffer)->ih.unique = req->uc_unique;\n\n\t/* Append msg to pending queue and poke Venus. */\n\tlist_add_tail(&req->uc_chain, &vcp->vc_pending);\n\n\twake_up_interruptible(&vcp->vc_waitq);\n\t/* We can be interrupted while we wait for Venus to process\n\t * our request.  If the interrupt occurs before Venus has read\n\t * the request, we dequeue and return. If it occurs after the\n\t * read but before the reply, we dequeue, send a signal\n\t * message, and return. If it occurs after the reply we ignore\n\t * it. In no case do we want to restart the syscall.  If it\n\t * was interrupted by a venus shutdown (psdev_close), return\n\t * ENODEV.  */\n\n\t/* Go to sleep.  Wake up on signals only after the timeout. */\n\tcoda_waitfor_upcall(vcp, req);\n\n\t/* Op went through, interrupt or not... */\n\tif (req->uc_flags & CODA_REQ_WRITE) {\n\t\tout = (union outputArgs *)req->uc_data;\n\t\t/* here we map positive Venus errors to kernel errors */\n\t\terror = -out->oh.result;\n\t\t*outSize = req->uc_outSize;\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tif ((req->uc_flags & CODA_REQ_ABORT) || !signal_pending(current)) {\n\t\tpr_warn(\"Unexpected interruption.\\n\");\n\t\tgoto exit;\n\t}\n\n\t/* Interrupted before venus read it. */\n\tif (!(req->uc_flags & CODA_REQ_READ))\n\t\tgoto exit;\n\n\t/* Venus saw the upcall, make sure we can send interrupt signal */\n\tif (!vcp->vc_inuse) {\n\t\tpr_info(\"Venus dead, not sending signal.\\n\");\n\t\tgoto exit;\n\t}\n\n\terror = -ENOMEM;\n\tsig_req = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!sig_req) goto exit;\n\n\tCODA_ALLOC((sig_req->uc_data), char *, sizeof(struct coda_in_hdr));\n\tif (!sig_req->uc_data) {\n\t\tkfree(sig_req);\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tsig_inputArgs = (union inputArgs *)sig_req->uc_data;\n\tsig_inputArgs->ih.opcode = CODA_SIGNAL;\n\tsig_inputArgs->ih.unique = req->uc_unique;\n\n\tsig_req->uc_flags = CODA_REQ_ASYNC;\n\tsig_req->uc_opcode = sig_inputArgs->ih.opcode;\n\tsig_req->uc_unique = sig_inputArgs->ih.unique;\n\tsig_req->uc_inSize = sizeof(struct coda_in_hdr);\n\tsig_req->uc_outSize = sizeof(struct coda_in_hdr);\n\n\t/* insert at head of queue! */\n\tlist_add(&(sig_req->uc_chain), &vcp->vc_pending);\n\twake_up_interruptible(&vcp->vc_waitq);\n\nexit:\n\tkfree(req);\n\tmutex_unlock(&vcp->vc_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/vfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int coda_upcall(struct venus_comm *vc, int inSize, int *outSize,\n\t\t       union inputArgs *buffer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nstatic int coda_upcall(struct venus_comm *vc, int inSize, int *outSize,\n\t\t       union inputArgs *buffer);\n\nstatic int coda_upcall(struct venus_comm *vcp,\n\t\t       int inSize, int *outSize,\n\t\t       union inputArgs *buffer)\n{\n\tunion outputArgs *out;\n\tunion inputArgs *sig_inputArgs;\n\tstruct upc_req *req = NULL, *sig_req;\n\tint error;\n\n\tmutex_lock(&vcp->vc_mutex);\n\n\tif (!vcp->vc_inuse) {\n\t\tpr_notice(\"Venus dead, not sending upcall\\n\");\n\t\terror = -ENXIO;\n\t\tgoto exit;\n\t}\n\n\t/* Format the request message. */\n\treq = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!req) {\n\t\terror = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\treq->uc_data = (void *)buffer;\n\treq->uc_flags = 0;\n\treq->uc_inSize = inSize;\n\treq->uc_outSize = *outSize ? *outSize : inSize;\n\treq->uc_opcode = ((union inputArgs *)buffer)->ih.opcode;\n\treq->uc_unique = ++vcp->vc_seq;\n\tinit_waitqueue_head(&req->uc_sleep);\n\n\t/* Fill in the common input args. */\n\t((union inputArgs *)buffer)->ih.unique = req->uc_unique;\n\n\t/* Append msg to pending queue and poke Venus. */\n\tlist_add_tail(&req->uc_chain, &vcp->vc_pending);\n\n\twake_up_interruptible(&vcp->vc_waitq);\n\t/* We can be interrupted while we wait for Venus to process\n\t * our request.  If the interrupt occurs before Venus has read\n\t * the request, we dequeue and return. If it occurs after the\n\t * read but before the reply, we dequeue, send a signal\n\t * message, and return. If it occurs after the reply we ignore\n\t * it. In no case do we want to restart the syscall.  If it\n\t * was interrupted by a venus shutdown (psdev_close), return\n\t * ENODEV.  */\n\n\t/* Go to sleep.  Wake up on signals only after the timeout. */\n\tcoda_waitfor_upcall(vcp, req);\n\n\t/* Op went through, interrupt or not... */\n\tif (req->uc_flags & CODA_REQ_WRITE) {\n\t\tout = (union outputArgs *)req->uc_data;\n\t\t/* here we map positive Venus errors to kernel errors */\n\t\terror = -out->oh.result;\n\t\t*outSize = req->uc_outSize;\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tif ((req->uc_flags & CODA_REQ_ABORT) || !signal_pending(current)) {\n\t\tpr_warn(\"Unexpected interruption.\\n\");\n\t\tgoto exit;\n\t}\n\n\t/* Interrupted before venus read it. */\n\tif (!(req->uc_flags & CODA_REQ_READ))\n\t\tgoto exit;\n\n\t/* Venus saw the upcall, make sure we can send interrupt signal */\n\tif (!vcp->vc_inuse) {\n\t\tpr_info(\"Venus dead, not sending signal.\\n\");\n\t\tgoto exit;\n\t}\n\n\terror = -ENOMEM;\n\tsig_req = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!sig_req) goto exit;\n\n\tCODA_ALLOC((sig_req->uc_data), char *, sizeof(struct coda_in_hdr));\n\tif (!sig_req->uc_data) {\n\t\tkfree(sig_req);\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tsig_inputArgs = (union inputArgs *)sig_req->uc_data;\n\tsig_inputArgs->ih.opcode = CODA_SIGNAL;\n\tsig_inputArgs->ih.unique = req->uc_unique;\n\n\tsig_req->uc_flags = CODA_REQ_ASYNC;\n\tsig_req->uc_opcode = sig_inputArgs->ih.opcode;\n\tsig_req->uc_unique = sig_inputArgs->ih.unique;\n\tsig_req->uc_inSize = sizeof(struct coda_in_hdr);\n\tsig_req->uc_outSize = sizeof(struct coda_in_hdr);\n\n\t/* insert at head of queue! */\n\tlist_add(&(sig_req->uc_chain), &vcp->vc_pending);\n\twake_up_interruptible(&vcp->vc_waitq);\n\nexit:\n\tkfree(req);\n\tmutex_unlock(&vcp->vc_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_vcp",
          "args": [
            "sb"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *)(inp) + offset",
            "name",
            "len"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *)(inp) + offset",
            "symname",
            "symlen"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UPARG",
          "args": [
            "CODA_SYMLINK"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "unsignedint",
            "offset + len + symlen + 8",
            "OUTSIZE(symlink)"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTSIZE",
          "args": [
            "symlink"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INSIZE",
          "args": [
            "symlink"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nint venus_symlink(struct super_block *sb, struct CodaFid *fid,\n\t\t     const char *name, int len,\n\t\t     const char *symname, int symlen)\n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n        int offset, s;\n\n        offset = INSIZE(symlink);\n\tinsize = max_t(unsigned int, offset + len + symlen + 8, OUTSIZE(symlink));\n\tUPARG(CODA_SYMLINK);\n        \n        /*        inp->coda_symlink.attr = *tva; XXXXXX */ \n        inp->coda_symlink.VFid = *fid;\n\n\t/* Round up to word boundary and null terminate */\n        inp->coda_symlink.srcname = offset;\n        s = ( symlen  & ~0x3 ) + 4; \n        memcpy((char *)(inp) + offset, symname, symlen);\n        *((char *)inp + offset + symlen) = '\\0';\n        \n\t/* Round up to word boundary and null terminate */\n        offset += s;\n        inp->coda_symlink.tname = offset;\n        s = (len & ~0x3) + 4;\n        memcpy((char *)(inp) + offset, name, len);\n        *((char *)inp + offset + len) = '\\0';\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\n\tCODA_FREE(inp, insize);\n        return error;\n}"
  },
  {
    "function_name": "venus_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
    "lines": "378-402",
    "snippet": "int venus_link(struct super_block *sb, struct CodaFid *fid, \n\t\t  struct CodaFid *dirfid, const char *name, int len )\n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n        int offset;\n\n\toffset = INSIZE(link);\n\tinsize = max_t(unsigned int, offset  + len + 1, OUTSIZE(link));\n        UPARG(CODA_LINK);\n\n        inp->coda_link.sourceFid = *fid;\n        inp->coda_link.destFid = *dirfid;\n        inp->coda_link.tname = offset;\n\n        /* make sure strings are null terminated */\n        memcpy((char *)(inp) + offset, name, len);\n        *((char *)inp + offset + len) = '\\0';\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\n\tCODA_FREE(inp, insize);\n        return error;\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_cache.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/vfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CODA_FREE",
          "args": [
            "inp",
            "insize"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coda_upcall",
          "args": [
            "coda_vcp(sb)",
            "insize",
            "&outsize",
            "inp"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "coda_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
          "lines": "666-771",
          "snippet": "static int coda_upcall(struct venus_comm *vcp,\n\t\t       int inSize, int *outSize,\n\t\t       union inputArgs *buffer)\n{\n\tunion outputArgs *out;\n\tunion inputArgs *sig_inputArgs;\n\tstruct upc_req *req = NULL, *sig_req;\n\tint error;\n\n\tmutex_lock(&vcp->vc_mutex);\n\n\tif (!vcp->vc_inuse) {\n\t\tpr_notice(\"Venus dead, not sending upcall\\n\");\n\t\terror = -ENXIO;\n\t\tgoto exit;\n\t}\n\n\t/* Format the request message. */\n\treq = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!req) {\n\t\terror = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\treq->uc_data = (void *)buffer;\n\treq->uc_flags = 0;\n\treq->uc_inSize = inSize;\n\treq->uc_outSize = *outSize ? *outSize : inSize;\n\treq->uc_opcode = ((union inputArgs *)buffer)->ih.opcode;\n\treq->uc_unique = ++vcp->vc_seq;\n\tinit_waitqueue_head(&req->uc_sleep);\n\n\t/* Fill in the common input args. */\n\t((union inputArgs *)buffer)->ih.unique = req->uc_unique;\n\n\t/* Append msg to pending queue and poke Venus. */\n\tlist_add_tail(&req->uc_chain, &vcp->vc_pending);\n\n\twake_up_interruptible(&vcp->vc_waitq);\n\t/* We can be interrupted while we wait for Venus to process\n\t * our request.  If the interrupt occurs before Venus has read\n\t * the request, we dequeue and return. If it occurs after the\n\t * read but before the reply, we dequeue, send a signal\n\t * message, and return. If it occurs after the reply we ignore\n\t * it. In no case do we want to restart the syscall.  If it\n\t * was interrupted by a venus shutdown (psdev_close), return\n\t * ENODEV.  */\n\n\t/* Go to sleep.  Wake up on signals only after the timeout. */\n\tcoda_waitfor_upcall(vcp, req);\n\n\t/* Op went through, interrupt or not... */\n\tif (req->uc_flags & CODA_REQ_WRITE) {\n\t\tout = (union outputArgs *)req->uc_data;\n\t\t/* here we map positive Venus errors to kernel errors */\n\t\terror = -out->oh.result;\n\t\t*outSize = req->uc_outSize;\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tif ((req->uc_flags & CODA_REQ_ABORT) || !signal_pending(current)) {\n\t\tpr_warn(\"Unexpected interruption.\\n\");\n\t\tgoto exit;\n\t}\n\n\t/* Interrupted before venus read it. */\n\tif (!(req->uc_flags & CODA_REQ_READ))\n\t\tgoto exit;\n\n\t/* Venus saw the upcall, make sure we can send interrupt signal */\n\tif (!vcp->vc_inuse) {\n\t\tpr_info(\"Venus dead, not sending signal.\\n\");\n\t\tgoto exit;\n\t}\n\n\terror = -ENOMEM;\n\tsig_req = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!sig_req) goto exit;\n\n\tCODA_ALLOC((sig_req->uc_data), char *, sizeof(struct coda_in_hdr));\n\tif (!sig_req->uc_data) {\n\t\tkfree(sig_req);\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tsig_inputArgs = (union inputArgs *)sig_req->uc_data;\n\tsig_inputArgs->ih.opcode = CODA_SIGNAL;\n\tsig_inputArgs->ih.unique = req->uc_unique;\n\n\tsig_req->uc_flags = CODA_REQ_ASYNC;\n\tsig_req->uc_opcode = sig_inputArgs->ih.opcode;\n\tsig_req->uc_unique = sig_inputArgs->ih.unique;\n\tsig_req->uc_inSize = sizeof(struct coda_in_hdr);\n\tsig_req->uc_outSize = sizeof(struct coda_in_hdr);\n\n\t/* insert at head of queue! */\n\tlist_add(&(sig_req->uc_chain), &vcp->vc_pending);\n\twake_up_interruptible(&vcp->vc_waitq);\n\nexit:\n\tkfree(req);\n\tmutex_unlock(&vcp->vc_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/vfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int coda_upcall(struct venus_comm *vc, int inSize, int *outSize,\n\t\t       union inputArgs *buffer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nstatic int coda_upcall(struct venus_comm *vc, int inSize, int *outSize,\n\t\t       union inputArgs *buffer);\n\nstatic int coda_upcall(struct venus_comm *vcp,\n\t\t       int inSize, int *outSize,\n\t\t       union inputArgs *buffer)\n{\n\tunion outputArgs *out;\n\tunion inputArgs *sig_inputArgs;\n\tstruct upc_req *req = NULL, *sig_req;\n\tint error;\n\n\tmutex_lock(&vcp->vc_mutex);\n\n\tif (!vcp->vc_inuse) {\n\t\tpr_notice(\"Venus dead, not sending upcall\\n\");\n\t\terror = -ENXIO;\n\t\tgoto exit;\n\t}\n\n\t/* Format the request message. */\n\treq = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!req) {\n\t\terror = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\treq->uc_data = (void *)buffer;\n\treq->uc_flags = 0;\n\treq->uc_inSize = inSize;\n\treq->uc_outSize = *outSize ? *outSize : inSize;\n\treq->uc_opcode = ((union inputArgs *)buffer)->ih.opcode;\n\treq->uc_unique = ++vcp->vc_seq;\n\tinit_waitqueue_head(&req->uc_sleep);\n\n\t/* Fill in the common input args. */\n\t((union inputArgs *)buffer)->ih.unique = req->uc_unique;\n\n\t/* Append msg to pending queue and poke Venus. */\n\tlist_add_tail(&req->uc_chain, &vcp->vc_pending);\n\n\twake_up_interruptible(&vcp->vc_waitq);\n\t/* We can be interrupted while we wait for Venus to process\n\t * our request.  If the interrupt occurs before Venus has read\n\t * the request, we dequeue and return. If it occurs after the\n\t * read but before the reply, we dequeue, send a signal\n\t * message, and return. If it occurs after the reply we ignore\n\t * it. In no case do we want to restart the syscall.  If it\n\t * was interrupted by a venus shutdown (psdev_close), return\n\t * ENODEV.  */\n\n\t/* Go to sleep.  Wake up on signals only after the timeout. */\n\tcoda_waitfor_upcall(vcp, req);\n\n\t/* Op went through, interrupt or not... */\n\tif (req->uc_flags & CODA_REQ_WRITE) {\n\t\tout = (union outputArgs *)req->uc_data;\n\t\t/* here we map positive Venus errors to kernel errors */\n\t\terror = -out->oh.result;\n\t\t*outSize = req->uc_outSize;\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tif ((req->uc_flags & CODA_REQ_ABORT) || !signal_pending(current)) {\n\t\tpr_warn(\"Unexpected interruption.\\n\");\n\t\tgoto exit;\n\t}\n\n\t/* Interrupted before venus read it. */\n\tif (!(req->uc_flags & CODA_REQ_READ))\n\t\tgoto exit;\n\n\t/* Venus saw the upcall, make sure we can send interrupt signal */\n\tif (!vcp->vc_inuse) {\n\t\tpr_info(\"Venus dead, not sending signal.\\n\");\n\t\tgoto exit;\n\t}\n\n\terror = -ENOMEM;\n\tsig_req = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!sig_req) goto exit;\n\n\tCODA_ALLOC((sig_req->uc_data), char *, sizeof(struct coda_in_hdr));\n\tif (!sig_req->uc_data) {\n\t\tkfree(sig_req);\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tsig_inputArgs = (union inputArgs *)sig_req->uc_data;\n\tsig_inputArgs->ih.opcode = CODA_SIGNAL;\n\tsig_inputArgs->ih.unique = req->uc_unique;\n\n\tsig_req->uc_flags = CODA_REQ_ASYNC;\n\tsig_req->uc_opcode = sig_inputArgs->ih.opcode;\n\tsig_req->uc_unique = sig_inputArgs->ih.unique;\n\tsig_req->uc_inSize = sizeof(struct coda_in_hdr);\n\tsig_req->uc_outSize = sizeof(struct coda_in_hdr);\n\n\t/* insert at head of queue! */\n\tlist_add(&(sig_req->uc_chain), &vcp->vc_pending);\n\twake_up_interruptible(&vcp->vc_waitq);\n\nexit:\n\tkfree(req);\n\tmutex_unlock(&vcp->vc_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_vcp",
          "args": [
            "sb"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *)(inp) + offset",
            "name",
            "len"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UPARG",
          "args": [
            "CODA_LINK"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "unsignedint",
            "offset  + len + 1",
            "OUTSIZE(link)"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTSIZE",
          "args": [
            "link"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INSIZE",
          "args": [
            "link"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nint venus_link(struct super_block *sb, struct CodaFid *fid, \n\t\t  struct CodaFid *dirfid, const char *name, int len )\n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n        int offset;\n\n\toffset = INSIZE(link);\n\tinsize = max_t(unsigned int, offset  + len + 1, OUTSIZE(link));\n        UPARG(CODA_LINK);\n\n        inp->coda_link.sourceFid = *fid;\n        inp->coda_link.destFid = *dirfid;\n        inp->coda_link.tname = offset;\n\n        /* make sure strings are null terminated */\n        memcpy((char *)(inp) + offset, name, len);\n        *((char *)inp + offset + len) = '\\0';\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\n\tCODA_FREE(inp, insize);\n        return error;\n}"
  },
  {
    "function_name": "venus_readlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
    "lines": "346-374",
    "snippet": "int venus_readlink(struct super_block *sb, struct CodaFid *fid, \n\t\t      char *buffer, int *length)\n{ \n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n        int retlen;\n        char *result;\n        \n\tinsize = max_t(unsigned int,\n\t\t     INSIZE(readlink), OUTSIZE(readlink)+ *length + 1);\n\tUPARG(CODA_READLINK);\n\n        inp->coda_readlink.VFid = *fid;\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\tif (!error) {\n\t\tretlen = outp->coda_readlink.count;\n\t\tif ( retlen > *length )\n\t\t\tretlen = *length;\n\t\t*length = retlen;\n\t\tresult =  (char *)outp + (long)outp->coda_readlink.data;\n\t\tmemcpy(buffer, result, retlen);\n\t\t*(buffer + retlen) = '\\0';\n\t}\n\n        CODA_FREE(inp, insize);\n        return error;\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_cache.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/vfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int coda_upcall(struct venus_comm *vc, int inSize, int *outSize,\n\t\t       union inputArgs *buffer);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CODA_FREE",
          "args": [
            "inp",
            "insize"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "result",
            "retlen"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coda_upcall",
          "args": [
            "coda_vcp(sb)",
            "insize",
            "&outsize",
            "inp"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "coda_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
          "lines": "666-771",
          "snippet": "static int coda_upcall(struct venus_comm *vcp,\n\t\t       int inSize, int *outSize,\n\t\t       union inputArgs *buffer)\n{\n\tunion outputArgs *out;\n\tunion inputArgs *sig_inputArgs;\n\tstruct upc_req *req = NULL, *sig_req;\n\tint error;\n\n\tmutex_lock(&vcp->vc_mutex);\n\n\tif (!vcp->vc_inuse) {\n\t\tpr_notice(\"Venus dead, not sending upcall\\n\");\n\t\terror = -ENXIO;\n\t\tgoto exit;\n\t}\n\n\t/* Format the request message. */\n\treq = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!req) {\n\t\terror = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\treq->uc_data = (void *)buffer;\n\treq->uc_flags = 0;\n\treq->uc_inSize = inSize;\n\treq->uc_outSize = *outSize ? *outSize : inSize;\n\treq->uc_opcode = ((union inputArgs *)buffer)->ih.opcode;\n\treq->uc_unique = ++vcp->vc_seq;\n\tinit_waitqueue_head(&req->uc_sleep);\n\n\t/* Fill in the common input args. */\n\t((union inputArgs *)buffer)->ih.unique = req->uc_unique;\n\n\t/* Append msg to pending queue and poke Venus. */\n\tlist_add_tail(&req->uc_chain, &vcp->vc_pending);\n\n\twake_up_interruptible(&vcp->vc_waitq);\n\t/* We can be interrupted while we wait for Venus to process\n\t * our request.  If the interrupt occurs before Venus has read\n\t * the request, we dequeue and return. If it occurs after the\n\t * read but before the reply, we dequeue, send a signal\n\t * message, and return. If it occurs after the reply we ignore\n\t * it. In no case do we want to restart the syscall.  If it\n\t * was interrupted by a venus shutdown (psdev_close), return\n\t * ENODEV.  */\n\n\t/* Go to sleep.  Wake up on signals only after the timeout. */\n\tcoda_waitfor_upcall(vcp, req);\n\n\t/* Op went through, interrupt or not... */\n\tif (req->uc_flags & CODA_REQ_WRITE) {\n\t\tout = (union outputArgs *)req->uc_data;\n\t\t/* here we map positive Venus errors to kernel errors */\n\t\terror = -out->oh.result;\n\t\t*outSize = req->uc_outSize;\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tif ((req->uc_flags & CODA_REQ_ABORT) || !signal_pending(current)) {\n\t\tpr_warn(\"Unexpected interruption.\\n\");\n\t\tgoto exit;\n\t}\n\n\t/* Interrupted before venus read it. */\n\tif (!(req->uc_flags & CODA_REQ_READ))\n\t\tgoto exit;\n\n\t/* Venus saw the upcall, make sure we can send interrupt signal */\n\tif (!vcp->vc_inuse) {\n\t\tpr_info(\"Venus dead, not sending signal.\\n\");\n\t\tgoto exit;\n\t}\n\n\terror = -ENOMEM;\n\tsig_req = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!sig_req) goto exit;\n\n\tCODA_ALLOC((sig_req->uc_data), char *, sizeof(struct coda_in_hdr));\n\tif (!sig_req->uc_data) {\n\t\tkfree(sig_req);\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tsig_inputArgs = (union inputArgs *)sig_req->uc_data;\n\tsig_inputArgs->ih.opcode = CODA_SIGNAL;\n\tsig_inputArgs->ih.unique = req->uc_unique;\n\n\tsig_req->uc_flags = CODA_REQ_ASYNC;\n\tsig_req->uc_opcode = sig_inputArgs->ih.opcode;\n\tsig_req->uc_unique = sig_inputArgs->ih.unique;\n\tsig_req->uc_inSize = sizeof(struct coda_in_hdr);\n\tsig_req->uc_outSize = sizeof(struct coda_in_hdr);\n\n\t/* insert at head of queue! */\n\tlist_add(&(sig_req->uc_chain), &vcp->vc_pending);\n\twake_up_interruptible(&vcp->vc_waitq);\n\nexit:\n\tkfree(req);\n\tmutex_unlock(&vcp->vc_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/vfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int coda_upcall(struct venus_comm *vc, int inSize, int *outSize,\n\t\t       union inputArgs *buffer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nstatic int coda_upcall(struct venus_comm *vc, int inSize, int *outSize,\n\t\t       union inputArgs *buffer);\n\nstatic int coda_upcall(struct venus_comm *vcp,\n\t\t       int inSize, int *outSize,\n\t\t       union inputArgs *buffer)\n{\n\tunion outputArgs *out;\n\tunion inputArgs *sig_inputArgs;\n\tstruct upc_req *req = NULL, *sig_req;\n\tint error;\n\n\tmutex_lock(&vcp->vc_mutex);\n\n\tif (!vcp->vc_inuse) {\n\t\tpr_notice(\"Venus dead, not sending upcall\\n\");\n\t\terror = -ENXIO;\n\t\tgoto exit;\n\t}\n\n\t/* Format the request message. */\n\treq = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!req) {\n\t\terror = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\treq->uc_data = (void *)buffer;\n\treq->uc_flags = 0;\n\treq->uc_inSize = inSize;\n\treq->uc_outSize = *outSize ? *outSize : inSize;\n\treq->uc_opcode = ((union inputArgs *)buffer)->ih.opcode;\n\treq->uc_unique = ++vcp->vc_seq;\n\tinit_waitqueue_head(&req->uc_sleep);\n\n\t/* Fill in the common input args. */\n\t((union inputArgs *)buffer)->ih.unique = req->uc_unique;\n\n\t/* Append msg to pending queue and poke Venus. */\n\tlist_add_tail(&req->uc_chain, &vcp->vc_pending);\n\n\twake_up_interruptible(&vcp->vc_waitq);\n\t/* We can be interrupted while we wait for Venus to process\n\t * our request.  If the interrupt occurs before Venus has read\n\t * the request, we dequeue and return. If it occurs after the\n\t * read but before the reply, we dequeue, send a signal\n\t * message, and return. If it occurs after the reply we ignore\n\t * it. In no case do we want to restart the syscall.  If it\n\t * was interrupted by a venus shutdown (psdev_close), return\n\t * ENODEV.  */\n\n\t/* Go to sleep.  Wake up on signals only after the timeout. */\n\tcoda_waitfor_upcall(vcp, req);\n\n\t/* Op went through, interrupt or not... */\n\tif (req->uc_flags & CODA_REQ_WRITE) {\n\t\tout = (union outputArgs *)req->uc_data;\n\t\t/* here we map positive Venus errors to kernel errors */\n\t\terror = -out->oh.result;\n\t\t*outSize = req->uc_outSize;\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tif ((req->uc_flags & CODA_REQ_ABORT) || !signal_pending(current)) {\n\t\tpr_warn(\"Unexpected interruption.\\n\");\n\t\tgoto exit;\n\t}\n\n\t/* Interrupted before venus read it. */\n\tif (!(req->uc_flags & CODA_REQ_READ))\n\t\tgoto exit;\n\n\t/* Venus saw the upcall, make sure we can send interrupt signal */\n\tif (!vcp->vc_inuse) {\n\t\tpr_info(\"Venus dead, not sending signal.\\n\");\n\t\tgoto exit;\n\t}\n\n\terror = -ENOMEM;\n\tsig_req = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!sig_req) goto exit;\n\n\tCODA_ALLOC((sig_req->uc_data), char *, sizeof(struct coda_in_hdr));\n\tif (!sig_req->uc_data) {\n\t\tkfree(sig_req);\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tsig_inputArgs = (union inputArgs *)sig_req->uc_data;\n\tsig_inputArgs->ih.opcode = CODA_SIGNAL;\n\tsig_inputArgs->ih.unique = req->uc_unique;\n\n\tsig_req->uc_flags = CODA_REQ_ASYNC;\n\tsig_req->uc_opcode = sig_inputArgs->ih.opcode;\n\tsig_req->uc_unique = sig_inputArgs->ih.unique;\n\tsig_req->uc_inSize = sizeof(struct coda_in_hdr);\n\tsig_req->uc_outSize = sizeof(struct coda_in_hdr);\n\n\t/* insert at head of queue! */\n\tlist_add(&(sig_req->uc_chain), &vcp->vc_pending);\n\twake_up_interruptible(&vcp->vc_waitq);\n\nexit:\n\tkfree(req);\n\tmutex_unlock(&vcp->vc_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_vcp",
          "args": [
            "sb"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UPARG",
          "args": [
            "CODA_READLINK"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "unsignedint",
            "INSIZE(readlink)",
            "OUTSIZE(readlink)+ *length + 1"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTSIZE",
          "args": [
            "readlink"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INSIZE",
          "args": [
            "readlink"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nstatic int coda_upcall(struct venus_comm *vc, int inSize, int *outSize,\n\t\t       union inputArgs *buffer);\n\nint venus_readlink(struct super_block *sb, struct CodaFid *fid, \n\t\t      char *buffer, int *length)\n{ \n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n        int retlen;\n        char *result;\n        \n\tinsize = max_t(unsigned int,\n\t\t     INSIZE(readlink), OUTSIZE(readlink)+ *length + 1);\n\tUPARG(CODA_READLINK);\n\n        inp->coda_readlink.VFid = *fid;\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\tif (!error) {\n\t\tretlen = outp->coda_readlink.count;\n\t\tif ( retlen > *length )\n\t\t\tretlen = *length;\n\t\t*length = retlen;\n\t\tresult =  (char *)outp + (long)outp->coda_readlink.data;\n\t\tmemcpy(buffer, result, retlen);\n\t\t*(buffer + retlen) = '\\0';\n\t}\n\n        CODA_FREE(inp, insize);\n        return error;\n}"
  },
  {
    "function_name": "venus_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
    "lines": "324-344",
    "snippet": "int venus_remove(struct super_block *sb, struct CodaFid *dirfid, \n\t\t    const char *name, int length)\n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int error=0, insize, outsize, offset;\n\n        offset = INSIZE(remove);\n\tinsize = max_t(unsigned int, offset + length + 1, OUTSIZE(remove));\n\tUPARG(CODA_REMOVE);\n\n        inp->coda_remove.VFid = *dirfid;\n        inp->coda_remove.name = offset;\n        memcpy((char *)(inp) + offset, name, length);\n\t*((char *)inp + offset + length) = '\\0';\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\n\tCODA_FREE(inp, insize);\n\treturn error;\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_cache.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/vfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CODA_FREE",
          "args": [
            "inp",
            "insize"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coda_upcall",
          "args": [
            "coda_vcp(sb)",
            "insize",
            "&outsize",
            "inp"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "coda_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
          "lines": "666-771",
          "snippet": "static int coda_upcall(struct venus_comm *vcp,\n\t\t       int inSize, int *outSize,\n\t\t       union inputArgs *buffer)\n{\n\tunion outputArgs *out;\n\tunion inputArgs *sig_inputArgs;\n\tstruct upc_req *req = NULL, *sig_req;\n\tint error;\n\n\tmutex_lock(&vcp->vc_mutex);\n\n\tif (!vcp->vc_inuse) {\n\t\tpr_notice(\"Venus dead, not sending upcall\\n\");\n\t\terror = -ENXIO;\n\t\tgoto exit;\n\t}\n\n\t/* Format the request message. */\n\treq = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!req) {\n\t\terror = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\treq->uc_data = (void *)buffer;\n\treq->uc_flags = 0;\n\treq->uc_inSize = inSize;\n\treq->uc_outSize = *outSize ? *outSize : inSize;\n\treq->uc_opcode = ((union inputArgs *)buffer)->ih.opcode;\n\treq->uc_unique = ++vcp->vc_seq;\n\tinit_waitqueue_head(&req->uc_sleep);\n\n\t/* Fill in the common input args. */\n\t((union inputArgs *)buffer)->ih.unique = req->uc_unique;\n\n\t/* Append msg to pending queue and poke Venus. */\n\tlist_add_tail(&req->uc_chain, &vcp->vc_pending);\n\n\twake_up_interruptible(&vcp->vc_waitq);\n\t/* We can be interrupted while we wait for Venus to process\n\t * our request.  If the interrupt occurs before Venus has read\n\t * the request, we dequeue and return. If it occurs after the\n\t * read but before the reply, we dequeue, send a signal\n\t * message, and return. If it occurs after the reply we ignore\n\t * it. In no case do we want to restart the syscall.  If it\n\t * was interrupted by a venus shutdown (psdev_close), return\n\t * ENODEV.  */\n\n\t/* Go to sleep.  Wake up on signals only after the timeout. */\n\tcoda_waitfor_upcall(vcp, req);\n\n\t/* Op went through, interrupt or not... */\n\tif (req->uc_flags & CODA_REQ_WRITE) {\n\t\tout = (union outputArgs *)req->uc_data;\n\t\t/* here we map positive Venus errors to kernel errors */\n\t\terror = -out->oh.result;\n\t\t*outSize = req->uc_outSize;\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tif ((req->uc_flags & CODA_REQ_ABORT) || !signal_pending(current)) {\n\t\tpr_warn(\"Unexpected interruption.\\n\");\n\t\tgoto exit;\n\t}\n\n\t/* Interrupted before venus read it. */\n\tif (!(req->uc_flags & CODA_REQ_READ))\n\t\tgoto exit;\n\n\t/* Venus saw the upcall, make sure we can send interrupt signal */\n\tif (!vcp->vc_inuse) {\n\t\tpr_info(\"Venus dead, not sending signal.\\n\");\n\t\tgoto exit;\n\t}\n\n\terror = -ENOMEM;\n\tsig_req = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!sig_req) goto exit;\n\n\tCODA_ALLOC((sig_req->uc_data), char *, sizeof(struct coda_in_hdr));\n\tif (!sig_req->uc_data) {\n\t\tkfree(sig_req);\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tsig_inputArgs = (union inputArgs *)sig_req->uc_data;\n\tsig_inputArgs->ih.opcode = CODA_SIGNAL;\n\tsig_inputArgs->ih.unique = req->uc_unique;\n\n\tsig_req->uc_flags = CODA_REQ_ASYNC;\n\tsig_req->uc_opcode = sig_inputArgs->ih.opcode;\n\tsig_req->uc_unique = sig_inputArgs->ih.unique;\n\tsig_req->uc_inSize = sizeof(struct coda_in_hdr);\n\tsig_req->uc_outSize = sizeof(struct coda_in_hdr);\n\n\t/* insert at head of queue! */\n\tlist_add(&(sig_req->uc_chain), &vcp->vc_pending);\n\twake_up_interruptible(&vcp->vc_waitq);\n\nexit:\n\tkfree(req);\n\tmutex_unlock(&vcp->vc_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/vfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int coda_upcall(struct venus_comm *vc, int inSize, int *outSize,\n\t\t       union inputArgs *buffer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nstatic int coda_upcall(struct venus_comm *vc, int inSize, int *outSize,\n\t\t       union inputArgs *buffer);\n\nstatic int coda_upcall(struct venus_comm *vcp,\n\t\t       int inSize, int *outSize,\n\t\t       union inputArgs *buffer)\n{\n\tunion outputArgs *out;\n\tunion inputArgs *sig_inputArgs;\n\tstruct upc_req *req = NULL, *sig_req;\n\tint error;\n\n\tmutex_lock(&vcp->vc_mutex);\n\n\tif (!vcp->vc_inuse) {\n\t\tpr_notice(\"Venus dead, not sending upcall\\n\");\n\t\terror = -ENXIO;\n\t\tgoto exit;\n\t}\n\n\t/* Format the request message. */\n\treq = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!req) {\n\t\terror = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\treq->uc_data = (void *)buffer;\n\treq->uc_flags = 0;\n\treq->uc_inSize = inSize;\n\treq->uc_outSize = *outSize ? *outSize : inSize;\n\treq->uc_opcode = ((union inputArgs *)buffer)->ih.opcode;\n\treq->uc_unique = ++vcp->vc_seq;\n\tinit_waitqueue_head(&req->uc_sleep);\n\n\t/* Fill in the common input args. */\n\t((union inputArgs *)buffer)->ih.unique = req->uc_unique;\n\n\t/* Append msg to pending queue and poke Venus. */\n\tlist_add_tail(&req->uc_chain, &vcp->vc_pending);\n\n\twake_up_interruptible(&vcp->vc_waitq);\n\t/* We can be interrupted while we wait for Venus to process\n\t * our request.  If the interrupt occurs before Venus has read\n\t * the request, we dequeue and return. If it occurs after the\n\t * read but before the reply, we dequeue, send a signal\n\t * message, and return. If it occurs after the reply we ignore\n\t * it. In no case do we want to restart the syscall.  If it\n\t * was interrupted by a venus shutdown (psdev_close), return\n\t * ENODEV.  */\n\n\t/* Go to sleep.  Wake up on signals only after the timeout. */\n\tcoda_waitfor_upcall(vcp, req);\n\n\t/* Op went through, interrupt or not... */\n\tif (req->uc_flags & CODA_REQ_WRITE) {\n\t\tout = (union outputArgs *)req->uc_data;\n\t\t/* here we map positive Venus errors to kernel errors */\n\t\terror = -out->oh.result;\n\t\t*outSize = req->uc_outSize;\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tif ((req->uc_flags & CODA_REQ_ABORT) || !signal_pending(current)) {\n\t\tpr_warn(\"Unexpected interruption.\\n\");\n\t\tgoto exit;\n\t}\n\n\t/* Interrupted before venus read it. */\n\tif (!(req->uc_flags & CODA_REQ_READ))\n\t\tgoto exit;\n\n\t/* Venus saw the upcall, make sure we can send interrupt signal */\n\tif (!vcp->vc_inuse) {\n\t\tpr_info(\"Venus dead, not sending signal.\\n\");\n\t\tgoto exit;\n\t}\n\n\terror = -ENOMEM;\n\tsig_req = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!sig_req) goto exit;\n\n\tCODA_ALLOC((sig_req->uc_data), char *, sizeof(struct coda_in_hdr));\n\tif (!sig_req->uc_data) {\n\t\tkfree(sig_req);\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tsig_inputArgs = (union inputArgs *)sig_req->uc_data;\n\tsig_inputArgs->ih.opcode = CODA_SIGNAL;\n\tsig_inputArgs->ih.unique = req->uc_unique;\n\n\tsig_req->uc_flags = CODA_REQ_ASYNC;\n\tsig_req->uc_opcode = sig_inputArgs->ih.opcode;\n\tsig_req->uc_unique = sig_inputArgs->ih.unique;\n\tsig_req->uc_inSize = sizeof(struct coda_in_hdr);\n\tsig_req->uc_outSize = sizeof(struct coda_in_hdr);\n\n\t/* insert at head of queue! */\n\tlist_add(&(sig_req->uc_chain), &vcp->vc_pending);\n\twake_up_interruptible(&vcp->vc_waitq);\n\nexit:\n\tkfree(req);\n\tmutex_unlock(&vcp->vc_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_vcp",
          "args": [
            "sb"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *)(inp) + offset",
            "name",
            "length"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UPARG",
          "args": [
            "CODA_REMOVE"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "unsignedint",
            "offset + length + 1",
            "OUTSIZE(remove)"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTSIZE",
          "args": [
            "remove"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INSIZE",
          "args": [
            "remove"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nint venus_remove(struct super_block *sb, struct CodaFid *dirfid, \n\t\t    const char *name, int length)\n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int error=0, insize, outsize, offset;\n\n        offset = INSIZE(remove);\n\tinsize = max_t(unsigned int, offset + length + 1, OUTSIZE(remove));\n\tUPARG(CODA_REMOVE);\n\n        inp->coda_remove.VFid = *dirfid;\n        inp->coda_remove.name = offset;\n        memcpy((char *)(inp) + offset, name, length);\n\t*((char *)inp + offset + length) = '\\0';\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\n\tCODA_FREE(inp, insize);\n\treturn error;\n}"
  },
  {
    "function_name": "venus_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
    "lines": "301-322",
    "snippet": "int venus_rmdir(struct super_block *sb, struct CodaFid *dirfid, \n\t\t    const char *name, int length)\n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n        int offset;\n\n        offset = INSIZE(rmdir);\n\tinsize = max_t(unsigned int, offset + length + 1, OUTSIZE(rmdir));\n\tUPARG(CODA_RMDIR);\n\n        inp->coda_rmdir.VFid = *dirfid;\n        inp->coda_rmdir.name = offset;\n        memcpy((char *)(inp) + offset, name, length);\n\t*((char *)inp + offset + length) = '\\0';\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\n\tCODA_FREE(inp, insize);\n\treturn error;\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_cache.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/vfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CODA_FREE",
          "args": [
            "inp",
            "insize"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coda_upcall",
          "args": [
            "coda_vcp(sb)",
            "insize",
            "&outsize",
            "inp"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "coda_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
          "lines": "666-771",
          "snippet": "static int coda_upcall(struct venus_comm *vcp,\n\t\t       int inSize, int *outSize,\n\t\t       union inputArgs *buffer)\n{\n\tunion outputArgs *out;\n\tunion inputArgs *sig_inputArgs;\n\tstruct upc_req *req = NULL, *sig_req;\n\tint error;\n\n\tmutex_lock(&vcp->vc_mutex);\n\n\tif (!vcp->vc_inuse) {\n\t\tpr_notice(\"Venus dead, not sending upcall\\n\");\n\t\terror = -ENXIO;\n\t\tgoto exit;\n\t}\n\n\t/* Format the request message. */\n\treq = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!req) {\n\t\terror = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\treq->uc_data = (void *)buffer;\n\treq->uc_flags = 0;\n\treq->uc_inSize = inSize;\n\treq->uc_outSize = *outSize ? *outSize : inSize;\n\treq->uc_opcode = ((union inputArgs *)buffer)->ih.opcode;\n\treq->uc_unique = ++vcp->vc_seq;\n\tinit_waitqueue_head(&req->uc_sleep);\n\n\t/* Fill in the common input args. */\n\t((union inputArgs *)buffer)->ih.unique = req->uc_unique;\n\n\t/* Append msg to pending queue and poke Venus. */\n\tlist_add_tail(&req->uc_chain, &vcp->vc_pending);\n\n\twake_up_interruptible(&vcp->vc_waitq);\n\t/* We can be interrupted while we wait for Venus to process\n\t * our request.  If the interrupt occurs before Venus has read\n\t * the request, we dequeue and return. If it occurs after the\n\t * read but before the reply, we dequeue, send a signal\n\t * message, and return. If it occurs after the reply we ignore\n\t * it. In no case do we want to restart the syscall.  If it\n\t * was interrupted by a venus shutdown (psdev_close), return\n\t * ENODEV.  */\n\n\t/* Go to sleep.  Wake up on signals only after the timeout. */\n\tcoda_waitfor_upcall(vcp, req);\n\n\t/* Op went through, interrupt or not... */\n\tif (req->uc_flags & CODA_REQ_WRITE) {\n\t\tout = (union outputArgs *)req->uc_data;\n\t\t/* here we map positive Venus errors to kernel errors */\n\t\terror = -out->oh.result;\n\t\t*outSize = req->uc_outSize;\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tif ((req->uc_flags & CODA_REQ_ABORT) || !signal_pending(current)) {\n\t\tpr_warn(\"Unexpected interruption.\\n\");\n\t\tgoto exit;\n\t}\n\n\t/* Interrupted before venus read it. */\n\tif (!(req->uc_flags & CODA_REQ_READ))\n\t\tgoto exit;\n\n\t/* Venus saw the upcall, make sure we can send interrupt signal */\n\tif (!vcp->vc_inuse) {\n\t\tpr_info(\"Venus dead, not sending signal.\\n\");\n\t\tgoto exit;\n\t}\n\n\terror = -ENOMEM;\n\tsig_req = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!sig_req) goto exit;\n\n\tCODA_ALLOC((sig_req->uc_data), char *, sizeof(struct coda_in_hdr));\n\tif (!sig_req->uc_data) {\n\t\tkfree(sig_req);\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tsig_inputArgs = (union inputArgs *)sig_req->uc_data;\n\tsig_inputArgs->ih.opcode = CODA_SIGNAL;\n\tsig_inputArgs->ih.unique = req->uc_unique;\n\n\tsig_req->uc_flags = CODA_REQ_ASYNC;\n\tsig_req->uc_opcode = sig_inputArgs->ih.opcode;\n\tsig_req->uc_unique = sig_inputArgs->ih.unique;\n\tsig_req->uc_inSize = sizeof(struct coda_in_hdr);\n\tsig_req->uc_outSize = sizeof(struct coda_in_hdr);\n\n\t/* insert at head of queue! */\n\tlist_add(&(sig_req->uc_chain), &vcp->vc_pending);\n\twake_up_interruptible(&vcp->vc_waitq);\n\nexit:\n\tkfree(req);\n\tmutex_unlock(&vcp->vc_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/vfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int coda_upcall(struct venus_comm *vc, int inSize, int *outSize,\n\t\t       union inputArgs *buffer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nstatic int coda_upcall(struct venus_comm *vc, int inSize, int *outSize,\n\t\t       union inputArgs *buffer);\n\nstatic int coda_upcall(struct venus_comm *vcp,\n\t\t       int inSize, int *outSize,\n\t\t       union inputArgs *buffer)\n{\n\tunion outputArgs *out;\n\tunion inputArgs *sig_inputArgs;\n\tstruct upc_req *req = NULL, *sig_req;\n\tint error;\n\n\tmutex_lock(&vcp->vc_mutex);\n\n\tif (!vcp->vc_inuse) {\n\t\tpr_notice(\"Venus dead, not sending upcall\\n\");\n\t\terror = -ENXIO;\n\t\tgoto exit;\n\t}\n\n\t/* Format the request message. */\n\treq = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!req) {\n\t\terror = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\treq->uc_data = (void *)buffer;\n\treq->uc_flags = 0;\n\treq->uc_inSize = inSize;\n\treq->uc_outSize = *outSize ? *outSize : inSize;\n\treq->uc_opcode = ((union inputArgs *)buffer)->ih.opcode;\n\treq->uc_unique = ++vcp->vc_seq;\n\tinit_waitqueue_head(&req->uc_sleep);\n\n\t/* Fill in the common input args. */\n\t((union inputArgs *)buffer)->ih.unique = req->uc_unique;\n\n\t/* Append msg to pending queue and poke Venus. */\n\tlist_add_tail(&req->uc_chain, &vcp->vc_pending);\n\n\twake_up_interruptible(&vcp->vc_waitq);\n\t/* We can be interrupted while we wait for Venus to process\n\t * our request.  If the interrupt occurs before Venus has read\n\t * the request, we dequeue and return. If it occurs after the\n\t * read but before the reply, we dequeue, send a signal\n\t * message, and return. If it occurs after the reply we ignore\n\t * it. In no case do we want to restart the syscall.  If it\n\t * was interrupted by a venus shutdown (psdev_close), return\n\t * ENODEV.  */\n\n\t/* Go to sleep.  Wake up on signals only after the timeout. */\n\tcoda_waitfor_upcall(vcp, req);\n\n\t/* Op went through, interrupt or not... */\n\tif (req->uc_flags & CODA_REQ_WRITE) {\n\t\tout = (union outputArgs *)req->uc_data;\n\t\t/* here we map positive Venus errors to kernel errors */\n\t\terror = -out->oh.result;\n\t\t*outSize = req->uc_outSize;\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tif ((req->uc_flags & CODA_REQ_ABORT) || !signal_pending(current)) {\n\t\tpr_warn(\"Unexpected interruption.\\n\");\n\t\tgoto exit;\n\t}\n\n\t/* Interrupted before venus read it. */\n\tif (!(req->uc_flags & CODA_REQ_READ))\n\t\tgoto exit;\n\n\t/* Venus saw the upcall, make sure we can send interrupt signal */\n\tif (!vcp->vc_inuse) {\n\t\tpr_info(\"Venus dead, not sending signal.\\n\");\n\t\tgoto exit;\n\t}\n\n\terror = -ENOMEM;\n\tsig_req = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!sig_req) goto exit;\n\n\tCODA_ALLOC((sig_req->uc_data), char *, sizeof(struct coda_in_hdr));\n\tif (!sig_req->uc_data) {\n\t\tkfree(sig_req);\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tsig_inputArgs = (union inputArgs *)sig_req->uc_data;\n\tsig_inputArgs->ih.opcode = CODA_SIGNAL;\n\tsig_inputArgs->ih.unique = req->uc_unique;\n\n\tsig_req->uc_flags = CODA_REQ_ASYNC;\n\tsig_req->uc_opcode = sig_inputArgs->ih.opcode;\n\tsig_req->uc_unique = sig_inputArgs->ih.unique;\n\tsig_req->uc_inSize = sizeof(struct coda_in_hdr);\n\tsig_req->uc_outSize = sizeof(struct coda_in_hdr);\n\n\t/* insert at head of queue! */\n\tlist_add(&(sig_req->uc_chain), &vcp->vc_pending);\n\twake_up_interruptible(&vcp->vc_waitq);\n\nexit:\n\tkfree(req);\n\tmutex_unlock(&vcp->vc_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_vcp",
          "args": [
            "sb"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *)(inp) + offset",
            "name",
            "length"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UPARG",
          "args": [
            "CODA_RMDIR"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "unsignedint",
            "offset + length + 1",
            "OUTSIZE(rmdir)"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTSIZE",
          "args": [
            "rmdir"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INSIZE",
          "args": [
            "rmdir"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nint venus_rmdir(struct super_block *sb, struct CodaFid *dirfid, \n\t\t    const char *name, int length)\n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n        int offset;\n\n        offset = INSIZE(rmdir);\n\tinsize = max_t(unsigned int, offset + length + 1, OUTSIZE(rmdir));\n\tUPARG(CODA_RMDIR);\n\n        inp->coda_rmdir.VFid = *dirfid;\n        inp->coda_rmdir.name = offset;\n        memcpy((char *)(inp) + offset, name, length);\n\t*((char *)inp + offset + length) = '\\0';\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\n\tCODA_FREE(inp, insize);\n\treturn error;\n}"
  },
  {
    "function_name": "venus_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
    "lines": "268-299",
    "snippet": "int venus_create(struct super_block *sb, struct CodaFid *dirfid, \n\t\t const char *name, int length, int excl, int mode,\n\t\t struct CodaFid *newfid, struct coda_vattr *attrs) \n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n        int offset;\n\n        offset = INSIZE(create);\n\tinsize = max_t(unsigned int, offset + length + 1, OUTSIZE(create));\n\tUPARG(CODA_CREATE);\n\n        inp->coda_create.VFid = *dirfid;\n        inp->coda_create.attr.va_mode = mode;\n\tinp->coda_create.excl = excl;\n        inp->coda_create.mode = mode;\n        inp->coda_create.name = offset;\n\n        /* Venus must get null terminated string */\n        memcpy((char *)(inp) + offset, name, length);\n        *((char *)inp + offset + length) = '\\0';\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\tif (!error) {\n\t\t*attrs = outp->coda_create.attr;\n\t\t*newfid = outp->coda_create.VFid;\n\t}\n\n\tCODA_FREE(inp, insize);\n\treturn error;        \n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_cache.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/vfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CODA_FREE",
          "args": [
            "inp",
            "insize"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coda_upcall",
          "args": [
            "coda_vcp(sb)",
            "insize",
            "&outsize",
            "inp"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "coda_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
          "lines": "666-771",
          "snippet": "static int coda_upcall(struct venus_comm *vcp,\n\t\t       int inSize, int *outSize,\n\t\t       union inputArgs *buffer)\n{\n\tunion outputArgs *out;\n\tunion inputArgs *sig_inputArgs;\n\tstruct upc_req *req = NULL, *sig_req;\n\tint error;\n\n\tmutex_lock(&vcp->vc_mutex);\n\n\tif (!vcp->vc_inuse) {\n\t\tpr_notice(\"Venus dead, not sending upcall\\n\");\n\t\terror = -ENXIO;\n\t\tgoto exit;\n\t}\n\n\t/* Format the request message. */\n\treq = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!req) {\n\t\terror = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\treq->uc_data = (void *)buffer;\n\treq->uc_flags = 0;\n\treq->uc_inSize = inSize;\n\treq->uc_outSize = *outSize ? *outSize : inSize;\n\treq->uc_opcode = ((union inputArgs *)buffer)->ih.opcode;\n\treq->uc_unique = ++vcp->vc_seq;\n\tinit_waitqueue_head(&req->uc_sleep);\n\n\t/* Fill in the common input args. */\n\t((union inputArgs *)buffer)->ih.unique = req->uc_unique;\n\n\t/* Append msg to pending queue and poke Venus. */\n\tlist_add_tail(&req->uc_chain, &vcp->vc_pending);\n\n\twake_up_interruptible(&vcp->vc_waitq);\n\t/* We can be interrupted while we wait for Venus to process\n\t * our request.  If the interrupt occurs before Venus has read\n\t * the request, we dequeue and return. If it occurs after the\n\t * read but before the reply, we dequeue, send a signal\n\t * message, and return. If it occurs after the reply we ignore\n\t * it. In no case do we want to restart the syscall.  If it\n\t * was interrupted by a venus shutdown (psdev_close), return\n\t * ENODEV.  */\n\n\t/* Go to sleep.  Wake up on signals only after the timeout. */\n\tcoda_waitfor_upcall(vcp, req);\n\n\t/* Op went through, interrupt or not... */\n\tif (req->uc_flags & CODA_REQ_WRITE) {\n\t\tout = (union outputArgs *)req->uc_data;\n\t\t/* here we map positive Venus errors to kernel errors */\n\t\terror = -out->oh.result;\n\t\t*outSize = req->uc_outSize;\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tif ((req->uc_flags & CODA_REQ_ABORT) || !signal_pending(current)) {\n\t\tpr_warn(\"Unexpected interruption.\\n\");\n\t\tgoto exit;\n\t}\n\n\t/* Interrupted before venus read it. */\n\tif (!(req->uc_flags & CODA_REQ_READ))\n\t\tgoto exit;\n\n\t/* Venus saw the upcall, make sure we can send interrupt signal */\n\tif (!vcp->vc_inuse) {\n\t\tpr_info(\"Venus dead, not sending signal.\\n\");\n\t\tgoto exit;\n\t}\n\n\terror = -ENOMEM;\n\tsig_req = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!sig_req) goto exit;\n\n\tCODA_ALLOC((sig_req->uc_data), char *, sizeof(struct coda_in_hdr));\n\tif (!sig_req->uc_data) {\n\t\tkfree(sig_req);\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tsig_inputArgs = (union inputArgs *)sig_req->uc_data;\n\tsig_inputArgs->ih.opcode = CODA_SIGNAL;\n\tsig_inputArgs->ih.unique = req->uc_unique;\n\n\tsig_req->uc_flags = CODA_REQ_ASYNC;\n\tsig_req->uc_opcode = sig_inputArgs->ih.opcode;\n\tsig_req->uc_unique = sig_inputArgs->ih.unique;\n\tsig_req->uc_inSize = sizeof(struct coda_in_hdr);\n\tsig_req->uc_outSize = sizeof(struct coda_in_hdr);\n\n\t/* insert at head of queue! */\n\tlist_add(&(sig_req->uc_chain), &vcp->vc_pending);\n\twake_up_interruptible(&vcp->vc_waitq);\n\nexit:\n\tkfree(req);\n\tmutex_unlock(&vcp->vc_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/vfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int coda_upcall(struct venus_comm *vc, int inSize, int *outSize,\n\t\t       union inputArgs *buffer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nstatic int coda_upcall(struct venus_comm *vc, int inSize, int *outSize,\n\t\t       union inputArgs *buffer);\n\nstatic int coda_upcall(struct venus_comm *vcp,\n\t\t       int inSize, int *outSize,\n\t\t       union inputArgs *buffer)\n{\n\tunion outputArgs *out;\n\tunion inputArgs *sig_inputArgs;\n\tstruct upc_req *req = NULL, *sig_req;\n\tint error;\n\n\tmutex_lock(&vcp->vc_mutex);\n\n\tif (!vcp->vc_inuse) {\n\t\tpr_notice(\"Venus dead, not sending upcall\\n\");\n\t\terror = -ENXIO;\n\t\tgoto exit;\n\t}\n\n\t/* Format the request message. */\n\treq = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!req) {\n\t\terror = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\treq->uc_data = (void *)buffer;\n\treq->uc_flags = 0;\n\treq->uc_inSize = inSize;\n\treq->uc_outSize = *outSize ? *outSize : inSize;\n\treq->uc_opcode = ((union inputArgs *)buffer)->ih.opcode;\n\treq->uc_unique = ++vcp->vc_seq;\n\tinit_waitqueue_head(&req->uc_sleep);\n\n\t/* Fill in the common input args. */\n\t((union inputArgs *)buffer)->ih.unique = req->uc_unique;\n\n\t/* Append msg to pending queue and poke Venus. */\n\tlist_add_tail(&req->uc_chain, &vcp->vc_pending);\n\n\twake_up_interruptible(&vcp->vc_waitq);\n\t/* We can be interrupted while we wait for Venus to process\n\t * our request.  If the interrupt occurs before Venus has read\n\t * the request, we dequeue and return. If it occurs after the\n\t * read but before the reply, we dequeue, send a signal\n\t * message, and return. If it occurs after the reply we ignore\n\t * it. In no case do we want to restart the syscall.  If it\n\t * was interrupted by a venus shutdown (psdev_close), return\n\t * ENODEV.  */\n\n\t/* Go to sleep.  Wake up on signals only after the timeout. */\n\tcoda_waitfor_upcall(vcp, req);\n\n\t/* Op went through, interrupt or not... */\n\tif (req->uc_flags & CODA_REQ_WRITE) {\n\t\tout = (union outputArgs *)req->uc_data;\n\t\t/* here we map positive Venus errors to kernel errors */\n\t\terror = -out->oh.result;\n\t\t*outSize = req->uc_outSize;\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tif ((req->uc_flags & CODA_REQ_ABORT) || !signal_pending(current)) {\n\t\tpr_warn(\"Unexpected interruption.\\n\");\n\t\tgoto exit;\n\t}\n\n\t/* Interrupted before venus read it. */\n\tif (!(req->uc_flags & CODA_REQ_READ))\n\t\tgoto exit;\n\n\t/* Venus saw the upcall, make sure we can send interrupt signal */\n\tif (!vcp->vc_inuse) {\n\t\tpr_info(\"Venus dead, not sending signal.\\n\");\n\t\tgoto exit;\n\t}\n\n\terror = -ENOMEM;\n\tsig_req = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!sig_req) goto exit;\n\n\tCODA_ALLOC((sig_req->uc_data), char *, sizeof(struct coda_in_hdr));\n\tif (!sig_req->uc_data) {\n\t\tkfree(sig_req);\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tsig_inputArgs = (union inputArgs *)sig_req->uc_data;\n\tsig_inputArgs->ih.opcode = CODA_SIGNAL;\n\tsig_inputArgs->ih.unique = req->uc_unique;\n\n\tsig_req->uc_flags = CODA_REQ_ASYNC;\n\tsig_req->uc_opcode = sig_inputArgs->ih.opcode;\n\tsig_req->uc_unique = sig_inputArgs->ih.unique;\n\tsig_req->uc_inSize = sizeof(struct coda_in_hdr);\n\tsig_req->uc_outSize = sizeof(struct coda_in_hdr);\n\n\t/* insert at head of queue! */\n\tlist_add(&(sig_req->uc_chain), &vcp->vc_pending);\n\twake_up_interruptible(&vcp->vc_waitq);\n\nexit:\n\tkfree(req);\n\tmutex_unlock(&vcp->vc_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_vcp",
          "args": [
            "sb"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *)(inp) + offset",
            "name",
            "length"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UPARG",
          "args": [
            "CODA_CREATE"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "unsignedint",
            "offset + length + 1",
            "OUTSIZE(create)"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTSIZE",
          "args": [
            "create"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INSIZE",
          "args": [
            "create"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nint venus_create(struct super_block *sb, struct CodaFid *dirfid, \n\t\t const char *name, int length, int excl, int mode,\n\t\t struct CodaFid *newfid, struct coda_vattr *attrs) \n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n        int offset;\n\n        offset = INSIZE(create);\n\tinsize = max_t(unsigned int, offset + length + 1, OUTSIZE(create));\n\tUPARG(CODA_CREATE);\n\n        inp->coda_create.VFid = *dirfid;\n        inp->coda_create.attr.va_mode = mode;\n\tinp->coda_create.excl = excl;\n        inp->coda_create.mode = mode;\n        inp->coda_create.name = offset;\n\n        /* Venus must get null terminated string */\n        memcpy((char *)(inp) + offset, name, length);\n        *((char *)inp + offset + length) = '\\0';\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\tif (!error) {\n\t\t*attrs = outp->coda_create.attr;\n\t\t*newfid = outp->coda_create.VFid;\n\t}\n\n\tCODA_FREE(inp, insize);\n\treturn error;        \n}"
  },
  {
    "function_name": "venus_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
    "lines": "231-266",
    "snippet": "int venus_rename(struct super_block *sb, struct CodaFid *old_fid, \n\t\t struct CodaFid *new_fid, size_t old_length, \n\t\t size_t new_length, const char *old_name, \n\t\t const char *new_name)\n{\n\tunion inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error; \n\tint offset, s;\n\t\n\toffset = INSIZE(rename);\n\tinsize = max_t(unsigned int, offset + new_length + old_length + 8,\n\t\t     OUTSIZE(rename)); \n \tUPARG(CODA_RENAME);\n\n        inp->coda_rename.sourceFid = *old_fid;\n        inp->coda_rename.destFid =  *new_fid;\n        inp->coda_rename.srcname = offset;\n\n        /* Venus must receive an null terminated string */\n        s = ( old_length & ~0x3) +4; /* round up to word boundary */\n        memcpy((char *)(inp) + offset, old_name, old_length);\n        *((char *)inp + offset + old_length) = '\\0';\n\n        /* another null terminated string for Venus */\n        offset += s;\n        inp->coda_rename.destname = offset;\n        s = ( new_length & ~0x3) +4; /* round up to word boundary */\n        memcpy((char *)(inp) + offset, new_name, new_length);\n        *((char *)inp + offset + new_length) = '\\0';\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\n\tCODA_FREE(inp, insize);\n\treturn error;\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_cache.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/vfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CODA_FREE",
          "args": [
            "inp",
            "insize"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coda_upcall",
          "args": [
            "coda_vcp(sb)",
            "insize",
            "&outsize",
            "inp"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "coda_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
          "lines": "666-771",
          "snippet": "static int coda_upcall(struct venus_comm *vcp,\n\t\t       int inSize, int *outSize,\n\t\t       union inputArgs *buffer)\n{\n\tunion outputArgs *out;\n\tunion inputArgs *sig_inputArgs;\n\tstruct upc_req *req = NULL, *sig_req;\n\tint error;\n\n\tmutex_lock(&vcp->vc_mutex);\n\n\tif (!vcp->vc_inuse) {\n\t\tpr_notice(\"Venus dead, not sending upcall\\n\");\n\t\terror = -ENXIO;\n\t\tgoto exit;\n\t}\n\n\t/* Format the request message. */\n\treq = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!req) {\n\t\terror = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\treq->uc_data = (void *)buffer;\n\treq->uc_flags = 0;\n\treq->uc_inSize = inSize;\n\treq->uc_outSize = *outSize ? *outSize : inSize;\n\treq->uc_opcode = ((union inputArgs *)buffer)->ih.opcode;\n\treq->uc_unique = ++vcp->vc_seq;\n\tinit_waitqueue_head(&req->uc_sleep);\n\n\t/* Fill in the common input args. */\n\t((union inputArgs *)buffer)->ih.unique = req->uc_unique;\n\n\t/* Append msg to pending queue and poke Venus. */\n\tlist_add_tail(&req->uc_chain, &vcp->vc_pending);\n\n\twake_up_interruptible(&vcp->vc_waitq);\n\t/* We can be interrupted while we wait for Venus to process\n\t * our request.  If the interrupt occurs before Venus has read\n\t * the request, we dequeue and return. If it occurs after the\n\t * read but before the reply, we dequeue, send a signal\n\t * message, and return. If it occurs after the reply we ignore\n\t * it. In no case do we want to restart the syscall.  If it\n\t * was interrupted by a venus shutdown (psdev_close), return\n\t * ENODEV.  */\n\n\t/* Go to sleep.  Wake up on signals only after the timeout. */\n\tcoda_waitfor_upcall(vcp, req);\n\n\t/* Op went through, interrupt or not... */\n\tif (req->uc_flags & CODA_REQ_WRITE) {\n\t\tout = (union outputArgs *)req->uc_data;\n\t\t/* here we map positive Venus errors to kernel errors */\n\t\terror = -out->oh.result;\n\t\t*outSize = req->uc_outSize;\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tif ((req->uc_flags & CODA_REQ_ABORT) || !signal_pending(current)) {\n\t\tpr_warn(\"Unexpected interruption.\\n\");\n\t\tgoto exit;\n\t}\n\n\t/* Interrupted before venus read it. */\n\tif (!(req->uc_flags & CODA_REQ_READ))\n\t\tgoto exit;\n\n\t/* Venus saw the upcall, make sure we can send interrupt signal */\n\tif (!vcp->vc_inuse) {\n\t\tpr_info(\"Venus dead, not sending signal.\\n\");\n\t\tgoto exit;\n\t}\n\n\terror = -ENOMEM;\n\tsig_req = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!sig_req) goto exit;\n\n\tCODA_ALLOC((sig_req->uc_data), char *, sizeof(struct coda_in_hdr));\n\tif (!sig_req->uc_data) {\n\t\tkfree(sig_req);\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tsig_inputArgs = (union inputArgs *)sig_req->uc_data;\n\tsig_inputArgs->ih.opcode = CODA_SIGNAL;\n\tsig_inputArgs->ih.unique = req->uc_unique;\n\n\tsig_req->uc_flags = CODA_REQ_ASYNC;\n\tsig_req->uc_opcode = sig_inputArgs->ih.opcode;\n\tsig_req->uc_unique = sig_inputArgs->ih.unique;\n\tsig_req->uc_inSize = sizeof(struct coda_in_hdr);\n\tsig_req->uc_outSize = sizeof(struct coda_in_hdr);\n\n\t/* insert at head of queue! */\n\tlist_add(&(sig_req->uc_chain), &vcp->vc_pending);\n\twake_up_interruptible(&vcp->vc_waitq);\n\nexit:\n\tkfree(req);\n\tmutex_unlock(&vcp->vc_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/vfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int coda_upcall(struct venus_comm *vc, int inSize, int *outSize,\n\t\t       union inputArgs *buffer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nstatic int coda_upcall(struct venus_comm *vc, int inSize, int *outSize,\n\t\t       union inputArgs *buffer);\n\nstatic int coda_upcall(struct venus_comm *vcp,\n\t\t       int inSize, int *outSize,\n\t\t       union inputArgs *buffer)\n{\n\tunion outputArgs *out;\n\tunion inputArgs *sig_inputArgs;\n\tstruct upc_req *req = NULL, *sig_req;\n\tint error;\n\n\tmutex_lock(&vcp->vc_mutex);\n\n\tif (!vcp->vc_inuse) {\n\t\tpr_notice(\"Venus dead, not sending upcall\\n\");\n\t\terror = -ENXIO;\n\t\tgoto exit;\n\t}\n\n\t/* Format the request message. */\n\treq = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!req) {\n\t\terror = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\treq->uc_data = (void *)buffer;\n\treq->uc_flags = 0;\n\treq->uc_inSize = inSize;\n\treq->uc_outSize = *outSize ? *outSize : inSize;\n\treq->uc_opcode = ((union inputArgs *)buffer)->ih.opcode;\n\treq->uc_unique = ++vcp->vc_seq;\n\tinit_waitqueue_head(&req->uc_sleep);\n\n\t/* Fill in the common input args. */\n\t((union inputArgs *)buffer)->ih.unique = req->uc_unique;\n\n\t/* Append msg to pending queue and poke Venus. */\n\tlist_add_tail(&req->uc_chain, &vcp->vc_pending);\n\n\twake_up_interruptible(&vcp->vc_waitq);\n\t/* We can be interrupted while we wait for Venus to process\n\t * our request.  If the interrupt occurs before Venus has read\n\t * the request, we dequeue and return. If it occurs after the\n\t * read but before the reply, we dequeue, send a signal\n\t * message, and return. If it occurs after the reply we ignore\n\t * it. In no case do we want to restart the syscall.  If it\n\t * was interrupted by a venus shutdown (psdev_close), return\n\t * ENODEV.  */\n\n\t/* Go to sleep.  Wake up on signals only after the timeout. */\n\tcoda_waitfor_upcall(vcp, req);\n\n\t/* Op went through, interrupt or not... */\n\tif (req->uc_flags & CODA_REQ_WRITE) {\n\t\tout = (union outputArgs *)req->uc_data;\n\t\t/* here we map positive Venus errors to kernel errors */\n\t\terror = -out->oh.result;\n\t\t*outSize = req->uc_outSize;\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tif ((req->uc_flags & CODA_REQ_ABORT) || !signal_pending(current)) {\n\t\tpr_warn(\"Unexpected interruption.\\n\");\n\t\tgoto exit;\n\t}\n\n\t/* Interrupted before venus read it. */\n\tif (!(req->uc_flags & CODA_REQ_READ))\n\t\tgoto exit;\n\n\t/* Venus saw the upcall, make sure we can send interrupt signal */\n\tif (!vcp->vc_inuse) {\n\t\tpr_info(\"Venus dead, not sending signal.\\n\");\n\t\tgoto exit;\n\t}\n\n\terror = -ENOMEM;\n\tsig_req = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!sig_req) goto exit;\n\n\tCODA_ALLOC((sig_req->uc_data), char *, sizeof(struct coda_in_hdr));\n\tif (!sig_req->uc_data) {\n\t\tkfree(sig_req);\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tsig_inputArgs = (union inputArgs *)sig_req->uc_data;\n\tsig_inputArgs->ih.opcode = CODA_SIGNAL;\n\tsig_inputArgs->ih.unique = req->uc_unique;\n\n\tsig_req->uc_flags = CODA_REQ_ASYNC;\n\tsig_req->uc_opcode = sig_inputArgs->ih.opcode;\n\tsig_req->uc_unique = sig_inputArgs->ih.unique;\n\tsig_req->uc_inSize = sizeof(struct coda_in_hdr);\n\tsig_req->uc_outSize = sizeof(struct coda_in_hdr);\n\n\t/* insert at head of queue! */\n\tlist_add(&(sig_req->uc_chain), &vcp->vc_pending);\n\twake_up_interruptible(&vcp->vc_waitq);\n\nexit:\n\tkfree(req);\n\tmutex_unlock(&vcp->vc_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_vcp",
          "args": [
            "sb"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *)(inp) + offset",
            "new_name",
            "new_length"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *)(inp) + offset",
            "old_name",
            "old_length"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UPARG",
          "args": [
            "CODA_RENAME"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "unsignedint",
            "offset + new_length + old_length + 8",
            "OUTSIZE(rename)"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTSIZE",
          "args": [
            "rename"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INSIZE",
          "args": [
            "rename"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nint venus_rename(struct super_block *sb, struct CodaFid *old_fid, \n\t\t struct CodaFid *new_fid, size_t old_length, \n\t\t size_t new_length, const char *old_name, \n\t\t const char *new_name)\n{\n\tunion inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error; \n\tint offset, s;\n\t\n\toffset = INSIZE(rename);\n\tinsize = max_t(unsigned int, offset + new_length + old_length + 8,\n\t\t     OUTSIZE(rename)); \n \tUPARG(CODA_RENAME);\n\n        inp->coda_rename.sourceFid = *old_fid;\n        inp->coda_rename.destFid =  *new_fid;\n        inp->coda_rename.srcname = offset;\n\n        /* Venus must receive an null terminated string */\n        s = ( old_length & ~0x3) +4; /* round up to word boundary */\n        memcpy((char *)(inp) + offset, old_name, old_length);\n        *((char *)inp + offset + old_length) = '\\0';\n\n        /* another null terminated string for Venus */\n        offset += s;\n        inp->coda_rename.destname = offset;\n        s = ( new_length & ~0x3) +4; /* round up to word boundary */\n        memcpy((char *)(inp) + offset, new_name, new_length);\n        *((char *)inp + offset + new_length) = '\\0';\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\n\tCODA_FREE(inp, insize);\n\treturn error;\n}"
  },
  {
    "function_name": "venus_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
    "lines": "200-228",
    "snippet": "int venus_mkdir(struct super_block *sb, struct CodaFid *dirfid, \n\t\t   const char *name, int length, \n\t\t   struct CodaFid *newfid, struct coda_vattr *attrs)\n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n        int offset;\n\n\toffset = INSIZE(mkdir);\n\tinsize = max_t(unsigned int, offset + length + 1, OUTSIZE(mkdir));\n\tUPARG(CODA_MKDIR);\n\n        inp->coda_mkdir.VFid = *dirfid;\n        inp->coda_mkdir.attr = *attrs;\n\tinp->coda_mkdir.name = offset;\n        /* Venus must get null terminated string */\n        memcpy((char *)(inp) + offset, name, length);\n        *((char *)inp + offset + length) = '\\0';\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\tif (!error) {\n\t\t*attrs = outp->coda_mkdir.attr;\n\t\t*newfid = outp->coda_mkdir.VFid;\n\t}\n\n\tCODA_FREE(inp, insize);\n\treturn error;        \n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_cache.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/vfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CODA_FREE",
          "args": [
            "inp",
            "insize"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coda_upcall",
          "args": [
            "coda_vcp(sb)",
            "insize",
            "&outsize",
            "inp"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "coda_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
          "lines": "666-771",
          "snippet": "static int coda_upcall(struct venus_comm *vcp,\n\t\t       int inSize, int *outSize,\n\t\t       union inputArgs *buffer)\n{\n\tunion outputArgs *out;\n\tunion inputArgs *sig_inputArgs;\n\tstruct upc_req *req = NULL, *sig_req;\n\tint error;\n\n\tmutex_lock(&vcp->vc_mutex);\n\n\tif (!vcp->vc_inuse) {\n\t\tpr_notice(\"Venus dead, not sending upcall\\n\");\n\t\terror = -ENXIO;\n\t\tgoto exit;\n\t}\n\n\t/* Format the request message. */\n\treq = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!req) {\n\t\terror = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\treq->uc_data = (void *)buffer;\n\treq->uc_flags = 0;\n\treq->uc_inSize = inSize;\n\treq->uc_outSize = *outSize ? *outSize : inSize;\n\treq->uc_opcode = ((union inputArgs *)buffer)->ih.opcode;\n\treq->uc_unique = ++vcp->vc_seq;\n\tinit_waitqueue_head(&req->uc_sleep);\n\n\t/* Fill in the common input args. */\n\t((union inputArgs *)buffer)->ih.unique = req->uc_unique;\n\n\t/* Append msg to pending queue and poke Venus. */\n\tlist_add_tail(&req->uc_chain, &vcp->vc_pending);\n\n\twake_up_interruptible(&vcp->vc_waitq);\n\t/* We can be interrupted while we wait for Venus to process\n\t * our request.  If the interrupt occurs before Venus has read\n\t * the request, we dequeue and return. If it occurs after the\n\t * read but before the reply, we dequeue, send a signal\n\t * message, and return. If it occurs after the reply we ignore\n\t * it. In no case do we want to restart the syscall.  If it\n\t * was interrupted by a venus shutdown (psdev_close), return\n\t * ENODEV.  */\n\n\t/* Go to sleep.  Wake up on signals only after the timeout. */\n\tcoda_waitfor_upcall(vcp, req);\n\n\t/* Op went through, interrupt or not... */\n\tif (req->uc_flags & CODA_REQ_WRITE) {\n\t\tout = (union outputArgs *)req->uc_data;\n\t\t/* here we map positive Venus errors to kernel errors */\n\t\terror = -out->oh.result;\n\t\t*outSize = req->uc_outSize;\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tif ((req->uc_flags & CODA_REQ_ABORT) || !signal_pending(current)) {\n\t\tpr_warn(\"Unexpected interruption.\\n\");\n\t\tgoto exit;\n\t}\n\n\t/* Interrupted before venus read it. */\n\tif (!(req->uc_flags & CODA_REQ_READ))\n\t\tgoto exit;\n\n\t/* Venus saw the upcall, make sure we can send interrupt signal */\n\tif (!vcp->vc_inuse) {\n\t\tpr_info(\"Venus dead, not sending signal.\\n\");\n\t\tgoto exit;\n\t}\n\n\terror = -ENOMEM;\n\tsig_req = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!sig_req) goto exit;\n\n\tCODA_ALLOC((sig_req->uc_data), char *, sizeof(struct coda_in_hdr));\n\tif (!sig_req->uc_data) {\n\t\tkfree(sig_req);\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tsig_inputArgs = (union inputArgs *)sig_req->uc_data;\n\tsig_inputArgs->ih.opcode = CODA_SIGNAL;\n\tsig_inputArgs->ih.unique = req->uc_unique;\n\n\tsig_req->uc_flags = CODA_REQ_ASYNC;\n\tsig_req->uc_opcode = sig_inputArgs->ih.opcode;\n\tsig_req->uc_unique = sig_inputArgs->ih.unique;\n\tsig_req->uc_inSize = sizeof(struct coda_in_hdr);\n\tsig_req->uc_outSize = sizeof(struct coda_in_hdr);\n\n\t/* insert at head of queue! */\n\tlist_add(&(sig_req->uc_chain), &vcp->vc_pending);\n\twake_up_interruptible(&vcp->vc_waitq);\n\nexit:\n\tkfree(req);\n\tmutex_unlock(&vcp->vc_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/vfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int coda_upcall(struct venus_comm *vc, int inSize, int *outSize,\n\t\t       union inputArgs *buffer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nstatic int coda_upcall(struct venus_comm *vc, int inSize, int *outSize,\n\t\t       union inputArgs *buffer);\n\nstatic int coda_upcall(struct venus_comm *vcp,\n\t\t       int inSize, int *outSize,\n\t\t       union inputArgs *buffer)\n{\n\tunion outputArgs *out;\n\tunion inputArgs *sig_inputArgs;\n\tstruct upc_req *req = NULL, *sig_req;\n\tint error;\n\n\tmutex_lock(&vcp->vc_mutex);\n\n\tif (!vcp->vc_inuse) {\n\t\tpr_notice(\"Venus dead, not sending upcall\\n\");\n\t\terror = -ENXIO;\n\t\tgoto exit;\n\t}\n\n\t/* Format the request message. */\n\treq = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!req) {\n\t\terror = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\treq->uc_data = (void *)buffer;\n\treq->uc_flags = 0;\n\treq->uc_inSize = inSize;\n\treq->uc_outSize = *outSize ? *outSize : inSize;\n\treq->uc_opcode = ((union inputArgs *)buffer)->ih.opcode;\n\treq->uc_unique = ++vcp->vc_seq;\n\tinit_waitqueue_head(&req->uc_sleep);\n\n\t/* Fill in the common input args. */\n\t((union inputArgs *)buffer)->ih.unique = req->uc_unique;\n\n\t/* Append msg to pending queue and poke Venus. */\n\tlist_add_tail(&req->uc_chain, &vcp->vc_pending);\n\n\twake_up_interruptible(&vcp->vc_waitq);\n\t/* We can be interrupted while we wait for Venus to process\n\t * our request.  If the interrupt occurs before Venus has read\n\t * the request, we dequeue and return. If it occurs after the\n\t * read but before the reply, we dequeue, send a signal\n\t * message, and return. If it occurs after the reply we ignore\n\t * it. In no case do we want to restart the syscall.  If it\n\t * was interrupted by a venus shutdown (psdev_close), return\n\t * ENODEV.  */\n\n\t/* Go to sleep.  Wake up on signals only after the timeout. */\n\tcoda_waitfor_upcall(vcp, req);\n\n\t/* Op went through, interrupt or not... */\n\tif (req->uc_flags & CODA_REQ_WRITE) {\n\t\tout = (union outputArgs *)req->uc_data;\n\t\t/* here we map positive Venus errors to kernel errors */\n\t\terror = -out->oh.result;\n\t\t*outSize = req->uc_outSize;\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tif ((req->uc_flags & CODA_REQ_ABORT) || !signal_pending(current)) {\n\t\tpr_warn(\"Unexpected interruption.\\n\");\n\t\tgoto exit;\n\t}\n\n\t/* Interrupted before venus read it. */\n\tif (!(req->uc_flags & CODA_REQ_READ))\n\t\tgoto exit;\n\n\t/* Venus saw the upcall, make sure we can send interrupt signal */\n\tif (!vcp->vc_inuse) {\n\t\tpr_info(\"Venus dead, not sending signal.\\n\");\n\t\tgoto exit;\n\t}\n\n\terror = -ENOMEM;\n\tsig_req = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!sig_req) goto exit;\n\n\tCODA_ALLOC((sig_req->uc_data), char *, sizeof(struct coda_in_hdr));\n\tif (!sig_req->uc_data) {\n\t\tkfree(sig_req);\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tsig_inputArgs = (union inputArgs *)sig_req->uc_data;\n\tsig_inputArgs->ih.opcode = CODA_SIGNAL;\n\tsig_inputArgs->ih.unique = req->uc_unique;\n\n\tsig_req->uc_flags = CODA_REQ_ASYNC;\n\tsig_req->uc_opcode = sig_inputArgs->ih.opcode;\n\tsig_req->uc_unique = sig_inputArgs->ih.unique;\n\tsig_req->uc_inSize = sizeof(struct coda_in_hdr);\n\tsig_req->uc_outSize = sizeof(struct coda_in_hdr);\n\n\t/* insert at head of queue! */\n\tlist_add(&(sig_req->uc_chain), &vcp->vc_pending);\n\twake_up_interruptible(&vcp->vc_waitq);\n\nexit:\n\tkfree(req);\n\tmutex_unlock(&vcp->vc_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_vcp",
          "args": [
            "sb"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *)(inp) + offset",
            "name",
            "length"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UPARG",
          "args": [
            "CODA_MKDIR"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "unsignedint",
            "offset + length + 1",
            "OUTSIZE(mkdir)"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTSIZE",
          "args": [
            "mkdir"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INSIZE",
          "args": [
            "mkdir"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nint venus_mkdir(struct super_block *sb, struct CodaFid *dirfid, \n\t\t   const char *name, int length, \n\t\t   struct CodaFid *newfid, struct coda_vattr *attrs)\n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n        int offset;\n\n\toffset = INSIZE(mkdir);\n\tinsize = max_t(unsigned int, offset + length + 1, OUTSIZE(mkdir));\n\tUPARG(CODA_MKDIR);\n\n        inp->coda_mkdir.VFid = *dirfid;\n        inp->coda_mkdir.attr = *attrs;\n\tinp->coda_mkdir.name = offset;\n        /* Venus must get null terminated string */\n        memcpy((char *)(inp) + offset, name, length);\n        *((char *)inp + offset + length) = '\\0';\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\tif (!error) {\n\t\t*attrs = outp->coda_mkdir.attr;\n\t\t*newfid = outp->coda_mkdir.VFid;\n\t}\n\n\tCODA_FREE(inp, insize);\n\treturn error;        \n}"
  },
  {
    "function_name": "venus_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
    "lines": "179-198",
    "snippet": "int venus_open(struct super_block *sb, struct CodaFid *fid,\n\t\t  int flags, struct file **fh)\n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n       \n\tinsize = SIZE(open_by_fd);\n\tUPARG(CODA_OPEN_BY_FD);\n\n\tinp->coda_open_by_fd.VFid = *fid;\n\tinp->coda_open_by_fd.flags = flags;\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\tif (!error)\n\t\t*fh = outp->coda_open_by_fd.fh;\n\n\tCODA_FREE(inp, insize);\n\treturn error;\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_cache.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/vfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CODA_FREE",
          "args": [
            "inp",
            "insize"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coda_upcall",
          "args": [
            "coda_vcp(sb)",
            "insize",
            "&outsize",
            "inp"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "coda_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
          "lines": "666-771",
          "snippet": "static int coda_upcall(struct venus_comm *vcp,\n\t\t       int inSize, int *outSize,\n\t\t       union inputArgs *buffer)\n{\n\tunion outputArgs *out;\n\tunion inputArgs *sig_inputArgs;\n\tstruct upc_req *req = NULL, *sig_req;\n\tint error;\n\n\tmutex_lock(&vcp->vc_mutex);\n\n\tif (!vcp->vc_inuse) {\n\t\tpr_notice(\"Venus dead, not sending upcall\\n\");\n\t\terror = -ENXIO;\n\t\tgoto exit;\n\t}\n\n\t/* Format the request message. */\n\treq = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!req) {\n\t\terror = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\treq->uc_data = (void *)buffer;\n\treq->uc_flags = 0;\n\treq->uc_inSize = inSize;\n\treq->uc_outSize = *outSize ? *outSize : inSize;\n\treq->uc_opcode = ((union inputArgs *)buffer)->ih.opcode;\n\treq->uc_unique = ++vcp->vc_seq;\n\tinit_waitqueue_head(&req->uc_sleep);\n\n\t/* Fill in the common input args. */\n\t((union inputArgs *)buffer)->ih.unique = req->uc_unique;\n\n\t/* Append msg to pending queue and poke Venus. */\n\tlist_add_tail(&req->uc_chain, &vcp->vc_pending);\n\n\twake_up_interruptible(&vcp->vc_waitq);\n\t/* We can be interrupted while we wait for Venus to process\n\t * our request.  If the interrupt occurs before Venus has read\n\t * the request, we dequeue and return. If it occurs after the\n\t * read but before the reply, we dequeue, send a signal\n\t * message, and return. If it occurs after the reply we ignore\n\t * it. In no case do we want to restart the syscall.  If it\n\t * was interrupted by a venus shutdown (psdev_close), return\n\t * ENODEV.  */\n\n\t/* Go to sleep.  Wake up on signals only after the timeout. */\n\tcoda_waitfor_upcall(vcp, req);\n\n\t/* Op went through, interrupt or not... */\n\tif (req->uc_flags & CODA_REQ_WRITE) {\n\t\tout = (union outputArgs *)req->uc_data;\n\t\t/* here we map positive Venus errors to kernel errors */\n\t\terror = -out->oh.result;\n\t\t*outSize = req->uc_outSize;\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tif ((req->uc_flags & CODA_REQ_ABORT) || !signal_pending(current)) {\n\t\tpr_warn(\"Unexpected interruption.\\n\");\n\t\tgoto exit;\n\t}\n\n\t/* Interrupted before venus read it. */\n\tif (!(req->uc_flags & CODA_REQ_READ))\n\t\tgoto exit;\n\n\t/* Venus saw the upcall, make sure we can send interrupt signal */\n\tif (!vcp->vc_inuse) {\n\t\tpr_info(\"Venus dead, not sending signal.\\n\");\n\t\tgoto exit;\n\t}\n\n\terror = -ENOMEM;\n\tsig_req = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!sig_req) goto exit;\n\n\tCODA_ALLOC((sig_req->uc_data), char *, sizeof(struct coda_in_hdr));\n\tif (!sig_req->uc_data) {\n\t\tkfree(sig_req);\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tsig_inputArgs = (union inputArgs *)sig_req->uc_data;\n\tsig_inputArgs->ih.opcode = CODA_SIGNAL;\n\tsig_inputArgs->ih.unique = req->uc_unique;\n\n\tsig_req->uc_flags = CODA_REQ_ASYNC;\n\tsig_req->uc_opcode = sig_inputArgs->ih.opcode;\n\tsig_req->uc_unique = sig_inputArgs->ih.unique;\n\tsig_req->uc_inSize = sizeof(struct coda_in_hdr);\n\tsig_req->uc_outSize = sizeof(struct coda_in_hdr);\n\n\t/* insert at head of queue! */\n\tlist_add(&(sig_req->uc_chain), &vcp->vc_pending);\n\twake_up_interruptible(&vcp->vc_waitq);\n\nexit:\n\tkfree(req);\n\tmutex_unlock(&vcp->vc_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/vfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int coda_upcall(struct venus_comm *vc, int inSize, int *outSize,\n\t\t       union inputArgs *buffer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nstatic int coda_upcall(struct venus_comm *vc, int inSize, int *outSize,\n\t\t       union inputArgs *buffer);\n\nstatic int coda_upcall(struct venus_comm *vcp,\n\t\t       int inSize, int *outSize,\n\t\t       union inputArgs *buffer)\n{\n\tunion outputArgs *out;\n\tunion inputArgs *sig_inputArgs;\n\tstruct upc_req *req = NULL, *sig_req;\n\tint error;\n\n\tmutex_lock(&vcp->vc_mutex);\n\n\tif (!vcp->vc_inuse) {\n\t\tpr_notice(\"Venus dead, not sending upcall\\n\");\n\t\terror = -ENXIO;\n\t\tgoto exit;\n\t}\n\n\t/* Format the request message. */\n\treq = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!req) {\n\t\terror = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\treq->uc_data = (void *)buffer;\n\treq->uc_flags = 0;\n\treq->uc_inSize = inSize;\n\treq->uc_outSize = *outSize ? *outSize : inSize;\n\treq->uc_opcode = ((union inputArgs *)buffer)->ih.opcode;\n\treq->uc_unique = ++vcp->vc_seq;\n\tinit_waitqueue_head(&req->uc_sleep);\n\n\t/* Fill in the common input args. */\n\t((union inputArgs *)buffer)->ih.unique = req->uc_unique;\n\n\t/* Append msg to pending queue and poke Venus. */\n\tlist_add_tail(&req->uc_chain, &vcp->vc_pending);\n\n\twake_up_interruptible(&vcp->vc_waitq);\n\t/* We can be interrupted while we wait for Venus to process\n\t * our request.  If the interrupt occurs before Venus has read\n\t * the request, we dequeue and return. If it occurs after the\n\t * read but before the reply, we dequeue, send a signal\n\t * message, and return. If it occurs after the reply we ignore\n\t * it. In no case do we want to restart the syscall.  If it\n\t * was interrupted by a venus shutdown (psdev_close), return\n\t * ENODEV.  */\n\n\t/* Go to sleep.  Wake up on signals only after the timeout. */\n\tcoda_waitfor_upcall(vcp, req);\n\n\t/* Op went through, interrupt or not... */\n\tif (req->uc_flags & CODA_REQ_WRITE) {\n\t\tout = (union outputArgs *)req->uc_data;\n\t\t/* here we map positive Venus errors to kernel errors */\n\t\terror = -out->oh.result;\n\t\t*outSize = req->uc_outSize;\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tif ((req->uc_flags & CODA_REQ_ABORT) || !signal_pending(current)) {\n\t\tpr_warn(\"Unexpected interruption.\\n\");\n\t\tgoto exit;\n\t}\n\n\t/* Interrupted before venus read it. */\n\tif (!(req->uc_flags & CODA_REQ_READ))\n\t\tgoto exit;\n\n\t/* Venus saw the upcall, make sure we can send interrupt signal */\n\tif (!vcp->vc_inuse) {\n\t\tpr_info(\"Venus dead, not sending signal.\\n\");\n\t\tgoto exit;\n\t}\n\n\terror = -ENOMEM;\n\tsig_req = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!sig_req) goto exit;\n\n\tCODA_ALLOC((sig_req->uc_data), char *, sizeof(struct coda_in_hdr));\n\tif (!sig_req->uc_data) {\n\t\tkfree(sig_req);\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tsig_inputArgs = (union inputArgs *)sig_req->uc_data;\n\tsig_inputArgs->ih.opcode = CODA_SIGNAL;\n\tsig_inputArgs->ih.unique = req->uc_unique;\n\n\tsig_req->uc_flags = CODA_REQ_ASYNC;\n\tsig_req->uc_opcode = sig_inputArgs->ih.opcode;\n\tsig_req->uc_unique = sig_inputArgs->ih.unique;\n\tsig_req->uc_inSize = sizeof(struct coda_in_hdr);\n\tsig_req->uc_outSize = sizeof(struct coda_in_hdr);\n\n\t/* insert at head of queue! */\n\tlist_add(&(sig_req->uc_chain), &vcp->vc_pending);\n\twake_up_interruptible(&vcp->vc_waitq);\n\nexit:\n\tkfree(req);\n\tmutex_unlock(&vcp->vc_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_vcp",
          "args": [
            "sb"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UPARG",
          "args": [
            "CODA_OPEN_BY_FD"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIZE",
          "args": [
            "open_by_fd"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "MPTY_SCAN_SIZE(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
          "lines": "62-67",
          "snippet": "tatic inline uint32_t EMPTY_SCAN_SIZE(uint32_t sector_size) {\n\tif (sector_size < DEFAULT_EMPTY_SCAN_SIZE)\n\t\treturn sector_size;\n\telse\n\t\treturn DEFAULT_EMPTY_SCAN_SIZE;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"summary.h\"\n#",
            "include \"nodelist.h\"\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic inline uint32_t EMPTY_SCAN_SIZE(uint32_t sector_size) {\n\tif (sector_size < DEFAULT_EMPTY_SCAN_SIZE)\n\t\treturn sector_size;\n\telse\n\t\treturn DEFAULT_EMPTY_SCAN_SIZE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nint venus_open(struct super_block *sb, struct CodaFid *fid,\n\t\t  int flags, struct file **fh)\n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n       \n\tinsize = SIZE(open_by_fd);\n\tUPARG(CODA_OPEN_BY_FD);\n\n\tinp->coda_open_by_fd.VFid = *fid;\n\tinp->coda_open_by_fd.flags = flags;\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\tif (!error)\n\t\t*fh = outp->coda_open_by_fd.fh;\n\n\tCODA_FREE(inp, insize);\n\treturn error;\n}"
  },
  {
    "function_name": "venus_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
    "lines": "159-177",
    "snippet": "int venus_close(struct super_block *sb, struct CodaFid *fid, int flags,\n\t\tkuid_t uid)\n{\n\tunion inputArgs *inp;\n\tunion outputArgs *outp;\n\tint insize, outsize, error;\n\t\n\tinsize = SIZE(release);\n\tUPARG(CODA_CLOSE);\n\t\n\tinp->ih.uid = from_kuid(&init_user_ns, uid);\n        inp->coda_close.VFid = *fid;\n        inp->coda_close.flags = flags;\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\n\tCODA_FREE(inp, insize);\n        return error;\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_cache.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/vfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CODA_FREE",
          "args": [
            "inp",
            "insize"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coda_upcall",
          "args": [
            "coda_vcp(sb)",
            "insize",
            "&outsize",
            "inp"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "coda_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
          "lines": "666-771",
          "snippet": "static int coda_upcall(struct venus_comm *vcp,\n\t\t       int inSize, int *outSize,\n\t\t       union inputArgs *buffer)\n{\n\tunion outputArgs *out;\n\tunion inputArgs *sig_inputArgs;\n\tstruct upc_req *req = NULL, *sig_req;\n\tint error;\n\n\tmutex_lock(&vcp->vc_mutex);\n\n\tif (!vcp->vc_inuse) {\n\t\tpr_notice(\"Venus dead, not sending upcall\\n\");\n\t\terror = -ENXIO;\n\t\tgoto exit;\n\t}\n\n\t/* Format the request message. */\n\treq = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!req) {\n\t\terror = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\treq->uc_data = (void *)buffer;\n\treq->uc_flags = 0;\n\treq->uc_inSize = inSize;\n\treq->uc_outSize = *outSize ? *outSize : inSize;\n\treq->uc_opcode = ((union inputArgs *)buffer)->ih.opcode;\n\treq->uc_unique = ++vcp->vc_seq;\n\tinit_waitqueue_head(&req->uc_sleep);\n\n\t/* Fill in the common input args. */\n\t((union inputArgs *)buffer)->ih.unique = req->uc_unique;\n\n\t/* Append msg to pending queue and poke Venus. */\n\tlist_add_tail(&req->uc_chain, &vcp->vc_pending);\n\n\twake_up_interruptible(&vcp->vc_waitq);\n\t/* We can be interrupted while we wait for Venus to process\n\t * our request.  If the interrupt occurs before Venus has read\n\t * the request, we dequeue and return. If it occurs after the\n\t * read but before the reply, we dequeue, send a signal\n\t * message, and return. If it occurs after the reply we ignore\n\t * it. In no case do we want to restart the syscall.  If it\n\t * was interrupted by a venus shutdown (psdev_close), return\n\t * ENODEV.  */\n\n\t/* Go to sleep.  Wake up on signals only after the timeout. */\n\tcoda_waitfor_upcall(vcp, req);\n\n\t/* Op went through, interrupt or not... */\n\tif (req->uc_flags & CODA_REQ_WRITE) {\n\t\tout = (union outputArgs *)req->uc_data;\n\t\t/* here we map positive Venus errors to kernel errors */\n\t\terror = -out->oh.result;\n\t\t*outSize = req->uc_outSize;\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tif ((req->uc_flags & CODA_REQ_ABORT) || !signal_pending(current)) {\n\t\tpr_warn(\"Unexpected interruption.\\n\");\n\t\tgoto exit;\n\t}\n\n\t/* Interrupted before venus read it. */\n\tif (!(req->uc_flags & CODA_REQ_READ))\n\t\tgoto exit;\n\n\t/* Venus saw the upcall, make sure we can send interrupt signal */\n\tif (!vcp->vc_inuse) {\n\t\tpr_info(\"Venus dead, not sending signal.\\n\");\n\t\tgoto exit;\n\t}\n\n\terror = -ENOMEM;\n\tsig_req = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!sig_req) goto exit;\n\n\tCODA_ALLOC((sig_req->uc_data), char *, sizeof(struct coda_in_hdr));\n\tif (!sig_req->uc_data) {\n\t\tkfree(sig_req);\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tsig_inputArgs = (union inputArgs *)sig_req->uc_data;\n\tsig_inputArgs->ih.opcode = CODA_SIGNAL;\n\tsig_inputArgs->ih.unique = req->uc_unique;\n\n\tsig_req->uc_flags = CODA_REQ_ASYNC;\n\tsig_req->uc_opcode = sig_inputArgs->ih.opcode;\n\tsig_req->uc_unique = sig_inputArgs->ih.unique;\n\tsig_req->uc_inSize = sizeof(struct coda_in_hdr);\n\tsig_req->uc_outSize = sizeof(struct coda_in_hdr);\n\n\t/* insert at head of queue! */\n\tlist_add(&(sig_req->uc_chain), &vcp->vc_pending);\n\twake_up_interruptible(&vcp->vc_waitq);\n\nexit:\n\tkfree(req);\n\tmutex_unlock(&vcp->vc_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/vfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int coda_upcall(struct venus_comm *vc, int inSize, int *outSize,\n\t\t       union inputArgs *buffer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nstatic int coda_upcall(struct venus_comm *vc, int inSize, int *outSize,\n\t\t       union inputArgs *buffer);\n\nstatic int coda_upcall(struct venus_comm *vcp,\n\t\t       int inSize, int *outSize,\n\t\t       union inputArgs *buffer)\n{\n\tunion outputArgs *out;\n\tunion inputArgs *sig_inputArgs;\n\tstruct upc_req *req = NULL, *sig_req;\n\tint error;\n\n\tmutex_lock(&vcp->vc_mutex);\n\n\tif (!vcp->vc_inuse) {\n\t\tpr_notice(\"Venus dead, not sending upcall\\n\");\n\t\terror = -ENXIO;\n\t\tgoto exit;\n\t}\n\n\t/* Format the request message. */\n\treq = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!req) {\n\t\terror = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\treq->uc_data = (void *)buffer;\n\treq->uc_flags = 0;\n\treq->uc_inSize = inSize;\n\treq->uc_outSize = *outSize ? *outSize : inSize;\n\treq->uc_opcode = ((union inputArgs *)buffer)->ih.opcode;\n\treq->uc_unique = ++vcp->vc_seq;\n\tinit_waitqueue_head(&req->uc_sleep);\n\n\t/* Fill in the common input args. */\n\t((union inputArgs *)buffer)->ih.unique = req->uc_unique;\n\n\t/* Append msg to pending queue and poke Venus. */\n\tlist_add_tail(&req->uc_chain, &vcp->vc_pending);\n\n\twake_up_interruptible(&vcp->vc_waitq);\n\t/* We can be interrupted while we wait for Venus to process\n\t * our request.  If the interrupt occurs before Venus has read\n\t * the request, we dequeue and return. If it occurs after the\n\t * read but before the reply, we dequeue, send a signal\n\t * message, and return. If it occurs after the reply we ignore\n\t * it. In no case do we want to restart the syscall.  If it\n\t * was interrupted by a venus shutdown (psdev_close), return\n\t * ENODEV.  */\n\n\t/* Go to sleep.  Wake up on signals only after the timeout. */\n\tcoda_waitfor_upcall(vcp, req);\n\n\t/* Op went through, interrupt or not... */\n\tif (req->uc_flags & CODA_REQ_WRITE) {\n\t\tout = (union outputArgs *)req->uc_data;\n\t\t/* here we map positive Venus errors to kernel errors */\n\t\terror = -out->oh.result;\n\t\t*outSize = req->uc_outSize;\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tif ((req->uc_flags & CODA_REQ_ABORT) || !signal_pending(current)) {\n\t\tpr_warn(\"Unexpected interruption.\\n\");\n\t\tgoto exit;\n\t}\n\n\t/* Interrupted before venus read it. */\n\tif (!(req->uc_flags & CODA_REQ_READ))\n\t\tgoto exit;\n\n\t/* Venus saw the upcall, make sure we can send interrupt signal */\n\tif (!vcp->vc_inuse) {\n\t\tpr_info(\"Venus dead, not sending signal.\\n\");\n\t\tgoto exit;\n\t}\n\n\terror = -ENOMEM;\n\tsig_req = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!sig_req) goto exit;\n\n\tCODA_ALLOC((sig_req->uc_data), char *, sizeof(struct coda_in_hdr));\n\tif (!sig_req->uc_data) {\n\t\tkfree(sig_req);\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tsig_inputArgs = (union inputArgs *)sig_req->uc_data;\n\tsig_inputArgs->ih.opcode = CODA_SIGNAL;\n\tsig_inputArgs->ih.unique = req->uc_unique;\n\n\tsig_req->uc_flags = CODA_REQ_ASYNC;\n\tsig_req->uc_opcode = sig_inputArgs->ih.opcode;\n\tsig_req->uc_unique = sig_inputArgs->ih.unique;\n\tsig_req->uc_inSize = sizeof(struct coda_in_hdr);\n\tsig_req->uc_outSize = sizeof(struct coda_in_hdr);\n\n\t/* insert at head of queue! */\n\tlist_add(&(sig_req->uc_chain), &vcp->vc_pending);\n\twake_up_interruptible(&vcp->vc_waitq);\n\nexit:\n\tkfree(req);\n\tmutex_unlock(&vcp->vc_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_vcp",
          "args": [
            "sb"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "uid"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UPARG",
          "args": [
            "CODA_CLOSE"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIZE",
          "args": [
            "release"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "MPTY_SCAN_SIZE(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
          "lines": "62-67",
          "snippet": "tatic inline uint32_t EMPTY_SCAN_SIZE(uint32_t sector_size) {\n\tif (sector_size < DEFAULT_EMPTY_SCAN_SIZE)\n\t\treturn sector_size;\n\telse\n\t\treturn DEFAULT_EMPTY_SCAN_SIZE;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"summary.h\"\n#",
            "include \"nodelist.h\"\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic inline uint32_t EMPTY_SCAN_SIZE(uint32_t sector_size) {\n\tif (sector_size < DEFAULT_EMPTY_SCAN_SIZE)\n\t\treturn sector_size;\n\telse\n\t\treturn DEFAULT_EMPTY_SCAN_SIZE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nint venus_close(struct super_block *sb, struct CodaFid *fid, int flags,\n\t\tkuid_t uid)\n{\n\tunion inputArgs *inp;\n\tunion outputArgs *outp;\n\tint insize, outsize, error;\n\t\n\tinsize = SIZE(release);\n\tUPARG(CODA_CLOSE);\n\t\n\tinp->ih.uid = from_kuid(&init_user_ns, uid);\n        inp->coda_close.VFid = *fid;\n        inp->coda_close.flags = flags;\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\n\tCODA_FREE(inp, insize);\n        return error;\n}"
  },
  {
    "function_name": "venus_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
    "lines": "129-157",
    "snippet": "int venus_lookup(struct super_block *sb, struct CodaFid *fid, \n\t\t    const char *name, int length, int * type, \n\t\t    struct CodaFid *resfid)\n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n\tint offset;\n\n\toffset = INSIZE(lookup);\n        insize = max_t(unsigned int, offset + length +1, OUTSIZE(lookup));\n\tUPARG(CODA_LOOKUP);\n\n        inp->coda_lookup.VFid = *fid;\n\tinp->coda_lookup.name = offset;\n\tinp->coda_lookup.flags = CLU_CASE_SENSITIVE;\n        /* send Venus a null terminated string */\n        memcpy((char *)(inp) + offset, name, length);\n        *((char *)inp + offset + length) = '\\0';\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\tif (!error) {\n\t\t*resfid = outp->coda_lookup.VFid;\n\t\t*type = outp->coda_lookup.vtype;\n\t}\n\n\tCODA_FREE(inp, insize);\n\treturn error;\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_cache.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/vfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CODA_FREE",
          "args": [
            "inp",
            "insize"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coda_upcall",
          "args": [
            "coda_vcp(sb)",
            "insize",
            "&outsize",
            "inp"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "coda_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
          "lines": "666-771",
          "snippet": "static int coda_upcall(struct venus_comm *vcp,\n\t\t       int inSize, int *outSize,\n\t\t       union inputArgs *buffer)\n{\n\tunion outputArgs *out;\n\tunion inputArgs *sig_inputArgs;\n\tstruct upc_req *req = NULL, *sig_req;\n\tint error;\n\n\tmutex_lock(&vcp->vc_mutex);\n\n\tif (!vcp->vc_inuse) {\n\t\tpr_notice(\"Venus dead, not sending upcall\\n\");\n\t\terror = -ENXIO;\n\t\tgoto exit;\n\t}\n\n\t/* Format the request message. */\n\treq = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!req) {\n\t\terror = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\treq->uc_data = (void *)buffer;\n\treq->uc_flags = 0;\n\treq->uc_inSize = inSize;\n\treq->uc_outSize = *outSize ? *outSize : inSize;\n\treq->uc_opcode = ((union inputArgs *)buffer)->ih.opcode;\n\treq->uc_unique = ++vcp->vc_seq;\n\tinit_waitqueue_head(&req->uc_sleep);\n\n\t/* Fill in the common input args. */\n\t((union inputArgs *)buffer)->ih.unique = req->uc_unique;\n\n\t/* Append msg to pending queue and poke Venus. */\n\tlist_add_tail(&req->uc_chain, &vcp->vc_pending);\n\n\twake_up_interruptible(&vcp->vc_waitq);\n\t/* We can be interrupted while we wait for Venus to process\n\t * our request.  If the interrupt occurs before Venus has read\n\t * the request, we dequeue and return. If it occurs after the\n\t * read but before the reply, we dequeue, send a signal\n\t * message, and return. If it occurs after the reply we ignore\n\t * it. In no case do we want to restart the syscall.  If it\n\t * was interrupted by a venus shutdown (psdev_close), return\n\t * ENODEV.  */\n\n\t/* Go to sleep.  Wake up on signals only after the timeout. */\n\tcoda_waitfor_upcall(vcp, req);\n\n\t/* Op went through, interrupt or not... */\n\tif (req->uc_flags & CODA_REQ_WRITE) {\n\t\tout = (union outputArgs *)req->uc_data;\n\t\t/* here we map positive Venus errors to kernel errors */\n\t\terror = -out->oh.result;\n\t\t*outSize = req->uc_outSize;\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tif ((req->uc_flags & CODA_REQ_ABORT) || !signal_pending(current)) {\n\t\tpr_warn(\"Unexpected interruption.\\n\");\n\t\tgoto exit;\n\t}\n\n\t/* Interrupted before venus read it. */\n\tif (!(req->uc_flags & CODA_REQ_READ))\n\t\tgoto exit;\n\n\t/* Venus saw the upcall, make sure we can send interrupt signal */\n\tif (!vcp->vc_inuse) {\n\t\tpr_info(\"Venus dead, not sending signal.\\n\");\n\t\tgoto exit;\n\t}\n\n\terror = -ENOMEM;\n\tsig_req = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!sig_req) goto exit;\n\n\tCODA_ALLOC((sig_req->uc_data), char *, sizeof(struct coda_in_hdr));\n\tif (!sig_req->uc_data) {\n\t\tkfree(sig_req);\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tsig_inputArgs = (union inputArgs *)sig_req->uc_data;\n\tsig_inputArgs->ih.opcode = CODA_SIGNAL;\n\tsig_inputArgs->ih.unique = req->uc_unique;\n\n\tsig_req->uc_flags = CODA_REQ_ASYNC;\n\tsig_req->uc_opcode = sig_inputArgs->ih.opcode;\n\tsig_req->uc_unique = sig_inputArgs->ih.unique;\n\tsig_req->uc_inSize = sizeof(struct coda_in_hdr);\n\tsig_req->uc_outSize = sizeof(struct coda_in_hdr);\n\n\t/* insert at head of queue! */\n\tlist_add(&(sig_req->uc_chain), &vcp->vc_pending);\n\twake_up_interruptible(&vcp->vc_waitq);\n\nexit:\n\tkfree(req);\n\tmutex_unlock(&vcp->vc_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/vfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int coda_upcall(struct venus_comm *vc, int inSize, int *outSize,\n\t\t       union inputArgs *buffer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nstatic int coda_upcall(struct venus_comm *vc, int inSize, int *outSize,\n\t\t       union inputArgs *buffer);\n\nstatic int coda_upcall(struct venus_comm *vcp,\n\t\t       int inSize, int *outSize,\n\t\t       union inputArgs *buffer)\n{\n\tunion outputArgs *out;\n\tunion inputArgs *sig_inputArgs;\n\tstruct upc_req *req = NULL, *sig_req;\n\tint error;\n\n\tmutex_lock(&vcp->vc_mutex);\n\n\tif (!vcp->vc_inuse) {\n\t\tpr_notice(\"Venus dead, not sending upcall\\n\");\n\t\terror = -ENXIO;\n\t\tgoto exit;\n\t}\n\n\t/* Format the request message. */\n\treq = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!req) {\n\t\terror = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\treq->uc_data = (void *)buffer;\n\treq->uc_flags = 0;\n\treq->uc_inSize = inSize;\n\treq->uc_outSize = *outSize ? *outSize : inSize;\n\treq->uc_opcode = ((union inputArgs *)buffer)->ih.opcode;\n\treq->uc_unique = ++vcp->vc_seq;\n\tinit_waitqueue_head(&req->uc_sleep);\n\n\t/* Fill in the common input args. */\n\t((union inputArgs *)buffer)->ih.unique = req->uc_unique;\n\n\t/* Append msg to pending queue and poke Venus. */\n\tlist_add_tail(&req->uc_chain, &vcp->vc_pending);\n\n\twake_up_interruptible(&vcp->vc_waitq);\n\t/* We can be interrupted while we wait for Venus to process\n\t * our request.  If the interrupt occurs before Venus has read\n\t * the request, we dequeue and return. If it occurs after the\n\t * read but before the reply, we dequeue, send a signal\n\t * message, and return. If it occurs after the reply we ignore\n\t * it. In no case do we want to restart the syscall.  If it\n\t * was interrupted by a venus shutdown (psdev_close), return\n\t * ENODEV.  */\n\n\t/* Go to sleep.  Wake up on signals only after the timeout. */\n\tcoda_waitfor_upcall(vcp, req);\n\n\t/* Op went through, interrupt or not... */\n\tif (req->uc_flags & CODA_REQ_WRITE) {\n\t\tout = (union outputArgs *)req->uc_data;\n\t\t/* here we map positive Venus errors to kernel errors */\n\t\terror = -out->oh.result;\n\t\t*outSize = req->uc_outSize;\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tif ((req->uc_flags & CODA_REQ_ABORT) || !signal_pending(current)) {\n\t\tpr_warn(\"Unexpected interruption.\\n\");\n\t\tgoto exit;\n\t}\n\n\t/* Interrupted before venus read it. */\n\tif (!(req->uc_flags & CODA_REQ_READ))\n\t\tgoto exit;\n\n\t/* Venus saw the upcall, make sure we can send interrupt signal */\n\tif (!vcp->vc_inuse) {\n\t\tpr_info(\"Venus dead, not sending signal.\\n\");\n\t\tgoto exit;\n\t}\n\n\terror = -ENOMEM;\n\tsig_req = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!sig_req) goto exit;\n\n\tCODA_ALLOC((sig_req->uc_data), char *, sizeof(struct coda_in_hdr));\n\tif (!sig_req->uc_data) {\n\t\tkfree(sig_req);\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tsig_inputArgs = (union inputArgs *)sig_req->uc_data;\n\tsig_inputArgs->ih.opcode = CODA_SIGNAL;\n\tsig_inputArgs->ih.unique = req->uc_unique;\n\n\tsig_req->uc_flags = CODA_REQ_ASYNC;\n\tsig_req->uc_opcode = sig_inputArgs->ih.opcode;\n\tsig_req->uc_unique = sig_inputArgs->ih.unique;\n\tsig_req->uc_inSize = sizeof(struct coda_in_hdr);\n\tsig_req->uc_outSize = sizeof(struct coda_in_hdr);\n\n\t/* insert at head of queue! */\n\tlist_add(&(sig_req->uc_chain), &vcp->vc_pending);\n\twake_up_interruptible(&vcp->vc_waitq);\n\nexit:\n\tkfree(req);\n\tmutex_unlock(&vcp->vc_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_vcp",
          "args": [
            "sb"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *)(inp) + offset",
            "name",
            "length"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UPARG",
          "args": [
            "CODA_LOOKUP"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "unsignedint",
            "offset + length +1",
            "OUTSIZE(lookup)"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OUTSIZE",
          "args": [
            "lookup"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INSIZE",
          "args": [
            "lookup"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nint venus_lookup(struct super_block *sb, struct CodaFid *fid, \n\t\t    const char *name, int length, int * type, \n\t\t    struct CodaFid *resfid)\n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n\tint offset;\n\n\toffset = INSIZE(lookup);\n        insize = max_t(unsigned int, offset + length +1, OUTSIZE(lookup));\n\tUPARG(CODA_LOOKUP);\n\n        inp->coda_lookup.VFid = *fid;\n\tinp->coda_lookup.name = offset;\n\tinp->coda_lookup.flags = CLU_CASE_SENSITIVE;\n        /* send Venus a null terminated string */\n        memcpy((char *)(inp) + offset, name, length);\n        *((char *)inp + offset + length) = '\\0';\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\tif (!error) {\n\t\t*resfid = outp->coda_lookup.VFid;\n\t\t*type = outp->coda_lookup.vtype;\n\t}\n\n\tCODA_FREE(inp, insize);\n\treturn error;\n}"
  },
  {
    "function_name": "venus_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
    "lines": "110-127",
    "snippet": "int venus_setattr(struct super_block *sb, struct CodaFid *fid, \n\t\t  struct coda_vattr *vattr)\n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n\t\n\tinsize = SIZE(setattr);\n\tUPARG(CODA_SETATTR);\n\n        inp->coda_setattr.VFid = *fid;\n\tinp->coda_setattr.attr = *vattr;\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\n        CODA_FREE(inp, insize);\n        return error;\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_cache.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/vfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CODA_FREE",
          "args": [
            "inp",
            "insize"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coda_upcall",
          "args": [
            "coda_vcp(sb)",
            "insize",
            "&outsize",
            "inp"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "coda_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
          "lines": "666-771",
          "snippet": "static int coda_upcall(struct venus_comm *vcp,\n\t\t       int inSize, int *outSize,\n\t\t       union inputArgs *buffer)\n{\n\tunion outputArgs *out;\n\tunion inputArgs *sig_inputArgs;\n\tstruct upc_req *req = NULL, *sig_req;\n\tint error;\n\n\tmutex_lock(&vcp->vc_mutex);\n\n\tif (!vcp->vc_inuse) {\n\t\tpr_notice(\"Venus dead, not sending upcall\\n\");\n\t\terror = -ENXIO;\n\t\tgoto exit;\n\t}\n\n\t/* Format the request message. */\n\treq = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!req) {\n\t\terror = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\treq->uc_data = (void *)buffer;\n\treq->uc_flags = 0;\n\treq->uc_inSize = inSize;\n\treq->uc_outSize = *outSize ? *outSize : inSize;\n\treq->uc_opcode = ((union inputArgs *)buffer)->ih.opcode;\n\treq->uc_unique = ++vcp->vc_seq;\n\tinit_waitqueue_head(&req->uc_sleep);\n\n\t/* Fill in the common input args. */\n\t((union inputArgs *)buffer)->ih.unique = req->uc_unique;\n\n\t/* Append msg to pending queue and poke Venus. */\n\tlist_add_tail(&req->uc_chain, &vcp->vc_pending);\n\n\twake_up_interruptible(&vcp->vc_waitq);\n\t/* We can be interrupted while we wait for Venus to process\n\t * our request.  If the interrupt occurs before Venus has read\n\t * the request, we dequeue and return. If it occurs after the\n\t * read but before the reply, we dequeue, send a signal\n\t * message, and return. If it occurs after the reply we ignore\n\t * it. In no case do we want to restart the syscall.  If it\n\t * was interrupted by a venus shutdown (psdev_close), return\n\t * ENODEV.  */\n\n\t/* Go to sleep.  Wake up on signals only after the timeout. */\n\tcoda_waitfor_upcall(vcp, req);\n\n\t/* Op went through, interrupt or not... */\n\tif (req->uc_flags & CODA_REQ_WRITE) {\n\t\tout = (union outputArgs *)req->uc_data;\n\t\t/* here we map positive Venus errors to kernel errors */\n\t\terror = -out->oh.result;\n\t\t*outSize = req->uc_outSize;\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tif ((req->uc_flags & CODA_REQ_ABORT) || !signal_pending(current)) {\n\t\tpr_warn(\"Unexpected interruption.\\n\");\n\t\tgoto exit;\n\t}\n\n\t/* Interrupted before venus read it. */\n\tif (!(req->uc_flags & CODA_REQ_READ))\n\t\tgoto exit;\n\n\t/* Venus saw the upcall, make sure we can send interrupt signal */\n\tif (!vcp->vc_inuse) {\n\t\tpr_info(\"Venus dead, not sending signal.\\n\");\n\t\tgoto exit;\n\t}\n\n\terror = -ENOMEM;\n\tsig_req = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!sig_req) goto exit;\n\n\tCODA_ALLOC((sig_req->uc_data), char *, sizeof(struct coda_in_hdr));\n\tif (!sig_req->uc_data) {\n\t\tkfree(sig_req);\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tsig_inputArgs = (union inputArgs *)sig_req->uc_data;\n\tsig_inputArgs->ih.opcode = CODA_SIGNAL;\n\tsig_inputArgs->ih.unique = req->uc_unique;\n\n\tsig_req->uc_flags = CODA_REQ_ASYNC;\n\tsig_req->uc_opcode = sig_inputArgs->ih.opcode;\n\tsig_req->uc_unique = sig_inputArgs->ih.unique;\n\tsig_req->uc_inSize = sizeof(struct coda_in_hdr);\n\tsig_req->uc_outSize = sizeof(struct coda_in_hdr);\n\n\t/* insert at head of queue! */\n\tlist_add(&(sig_req->uc_chain), &vcp->vc_pending);\n\twake_up_interruptible(&vcp->vc_waitq);\n\nexit:\n\tkfree(req);\n\tmutex_unlock(&vcp->vc_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/vfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int coda_upcall(struct venus_comm *vc, int inSize, int *outSize,\n\t\t       union inputArgs *buffer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nstatic int coda_upcall(struct venus_comm *vc, int inSize, int *outSize,\n\t\t       union inputArgs *buffer);\n\nstatic int coda_upcall(struct venus_comm *vcp,\n\t\t       int inSize, int *outSize,\n\t\t       union inputArgs *buffer)\n{\n\tunion outputArgs *out;\n\tunion inputArgs *sig_inputArgs;\n\tstruct upc_req *req = NULL, *sig_req;\n\tint error;\n\n\tmutex_lock(&vcp->vc_mutex);\n\n\tif (!vcp->vc_inuse) {\n\t\tpr_notice(\"Venus dead, not sending upcall\\n\");\n\t\terror = -ENXIO;\n\t\tgoto exit;\n\t}\n\n\t/* Format the request message. */\n\treq = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!req) {\n\t\terror = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\treq->uc_data = (void *)buffer;\n\treq->uc_flags = 0;\n\treq->uc_inSize = inSize;\n\treq->uc_outSize = *outSize ? *outSize : inSize;\n\treq->uc_opcode = ((union inputArgs *)buffer)->ih.opcode;\n\treq->uc_unique = ++vcp->vc_seq;\n\tinit_waitqueue_head(&req->uc_sleep);\n\n\t/* Fill in the common input args. */\n\t((union inputArgs *)buffer)->ih.unique = req->uc_unique;\n\n\t/* Append msg to pending queue and poke Venus. */\n\tlist_add_tail(&req->uc_chain, &vcp->vc_pending);\n\n\twake_up_interruptible(&vcp->vc_waitq);\n\t/* We can be interrupted while we wait for Venus to process\n\t * our request.  If the interrupt occurs before Venus has read\n\t * the request, we dequeue and return. If it occurs after the\n\t * read but before the reply, we dequeue, send a signal\n\t * message, and return. If it occurs after the reply we ignore\n\t * it. In no case do we want to restart the syscall.  If it\n\t * was interrupted by a venus shutdown (psdev_close), return\n\t * ENODEV.  */\n\n\t/* Go to sleep.  Wake up on signals only after the timeout. */\n\tcoda_waitfor_upcall(vcp, req);\n\n\t/* Op went through, interrupt or not... */\n\tif (req->uc_flags & CODA_REQ_WRITE) {\n\t\tout = (union outputArgs *)req->uc_data;\n\t\t/* here we map positive Venus errors to kernel errors */\n\t\terror = -out->oh.result;\n\t\t*outSize = req->uc_outSize;\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tif ((req->uc_flags & CODA_REQ_ABORT) || !signal_pending(current)) {\n\t\tpr_warn(\"Unexpected interruption.\\n\");\n\t\tgoto exit;\n\t}\n\n\t/* Interrupted before venus read it. */\n\tif (!(req->uc_flags & CODA_REQ_READ))\n\t\tgoto exit;\n\n\t/* Venus saw the upcall, make sure we can send interrupt signal */\n\tif (!vcp->vc_inuse) {\n\t\tpr_info(\"Venus dead, not sending signal.\\n\");\n\t\tgoto exit;\n\t}\n\n\terror = -ENOMEM;\n\tsig_req = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!sig_req) goto exit;\n\n\tCODA_ALLOC((sig_req->uc_data), char *, sizeof(struct coda_in_hdr));\n\tif (!sig_req->uc_data) {\n\t\tkfree(sig_req);\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tsig_inputArgs = (union inputArgs *)sig_req->uc_data;\n\tsig_inputArgs->ih.opcode = CODA_SIGNAL;\n\tsig_inputArgs->ih.unique = req->uc_unique;\n\n\tsig_req->uc_flags = CODA_REQ_ASYNC;\n\tsig_req->uc_opcode = sig_inputArgs->ih.opcode;\n\tsig_req->uc_unique = sig_inputArgs->ih.unique;\n\tsig_req->uc_inSize = sizeof(struct coda_in_hdr);\n\tsig_req->uc_outSize = sizeof(struct coda_in_hdr);\n\n\t/* insert at head of queue! */\n\tlist_add(&(sig_req->uc_chain), &vcp->vc_pending);\n\twake_up_interruptible(&vcp->vc_waitq);\n\nexit:\n\tkfree(req);\n\tmutex_unlock(&vcp->vc_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_vcp",
          "args": [
            "sb"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UPARG",
          "args": [
            "CODA_SETATTR"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIZE",
          "args": [
            "setattr"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "MPTY_SCAN_SIZE(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
          "lines": "62-67",
          "snippet": "tatic inline uint32_t EMPTY_SCAN_SIZE(uint32_t sector_size) {\n\tif (sector_size < DEFAULT_EMPTY_SCAN_SIZE)\n\t\treturn sector_size;\n\telse\n\t\treturn DEFAULT_EMPTY_SCAN_SIZE;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"summary.h\"\n#",
            "include \"nodelist.h\"\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic inline uint32_t EMPTY_SCAN_SIZE(uint32_t sector_size) {\n\tif (sector_size < DEFAULT_EMPTY_SCAN_SIZE)\n\t\treturn sector_size;\n\telse\n\t\treturn DEFAULT_EMPTY_SCAN_SIZE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nint venus_setattr(struct super_block *sb, struct CodaFid *fid, \n\t\t  struct coda_vattr *vattr)\n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n\t\n\tinsize = SIZE(setattr);\n\tUPARG(CODA_SETATTR);\n\n        inp->coda_setattr.VFid = *fid;\n\tinp->coda_setattr.attr = *vattr;\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\n        CODA_FREE(inp, insize);\n        return error;\n}"
  },
  {
    "function_name": "venus_getattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
    "lines": "91-108",
    "snippet": "int venus_getattr(struct super_block *sb, struct CodaFid *fid, \n\t\t     struct coda_vattr *attr) \n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n\n        insize = SIZE(getattr); \n\tUPARG(CODA_GETATTR);\n        inp->coda_getattr.VFid = *fid;\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\tif (!error)\n\t\t*attr = outp->coda_getattr.attr;\n\n\tCODA_FREE(inp, insize);\n        return error;\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_cache.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/vfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CODA_FREE",
          "args": [
            "inp",
            "insize"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coda_upcall",
          "args": [
            "coda_vcp(sb)",
            "insize",
            "&outsize",
            "inp"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "coda_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
          "lines": "666-771",
          "snippet": "static int coda_upcall(struct venus_comm *vcp,\n\t\t       int inSize, int *outSize,\n\t\t       union inputArgs *buffer)\n{\n\tunion outputArgs *out;\n\tunion inputArgs *sig_inputArgs;\n\tstruct upc_req *req = NULL, *sig_req;\n\tint error;\n\n\tmutex_lock(&vcp->vc_mutex);\n\n\tif (!vcp->vc_inuse) {\n\t\tpr_notice(\"Venus dead, not sending upcall\\n\");\n\t\terror = -ENXIO;\n\t\tgoto exit;\n\t}\n\n\t/* Format the request message. */\n\treq = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!req) {\n\t\terror = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\treq->uc_data = (void *)buffer;\n\treq->uc_flags = 0;\n\treq->uc_inSize = inSize;\n\treq->uc_outSize = *outSize ? *outSize : inSize;\n\treq->uc_opcode = ((union inputArgs *)buffer)->ih.opcode;\n\treq->uc_unique = ++vcp->vc_seq;\n\tinit_waitqueue_head(&req->uc_sleep);\n\n\t/* Fill in the common input args. */\n\t((union inputArgs *)buffer)->ih.unique = req->uc_unique;\n\n\t/* Append msg to pending queue and poke Venus. */\n\tlist_add_tail(&req->uc_chain, &vcp->vc_pending);\n\n\twake_up_interruptible(&vcp->vc_waitq);\n\t/* We can be interrupted while we wait for Venus to process\n\t * our request.  If the interrupt occurs before Venus has read\n\t * the request, we dequeue and return. If it occurs after the\n\t * read but before the reply, we dequeue, send a signal\n\t * message, and return. If it occurs after the reply we ignore\n\t * it. In no case do we want to restart the syscall.  If it\n\t * was interrupted by a venus shutdown (psdev_close), return\n\t * ENODEV.  */\n\n\t/* Go to sleep.  Wake up on signals only after the timeout. */\n\tcoda_waitfor_upcall(vcp, req);\n\n\t/* Op went through, interrupt or not... */\n\tif (req->uc_flags & CODA_REQ_WRITE) {\n\t\tout = (union outputArgs *)req->uc_data;\n\t\t/* here we map positive Venus errors to kernel errors */\n\t\terror = -out->oh.result;\n\t\t*outSize = req->uc_outSize;\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tif ((req->uc_flags & CODA_REQ_ABORT) || !signal_pending(current)) {\n\t\tpr_warn(\"Unexpected interruption.\\n\");\n\t\tgoto exit;\n\t}\n\n\t/* Interrupted before venus read it. */\n\tif (!(req->uc_flags & CODA_REQ_READ))\n\t\tgoto exit;\n\n\t/* Venus saw the upcall, make sure we can send interrupt signal */\n\tif (!vcp->vc_inuse) {\n\t\tpr_info(\"Venus dead, not sending signal.\\n\");\n\t\tgoto exit;\n\t}\n\n\terror = -ENOMEM;\n\tsig_req = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!sig_req) goto exit;\n\n\tCODA_ALLOC((sig_req->uc_data), char *, sizeof(struct coda_in_hdr));\n\tif (!sig_req->uc_data) {\n\t\tkfree(sig_req);\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tsig_inputArgs = (union inputArgs *)sig_req->uc_data;\n\tsig_inputArgs->ih.opcode = CODA_SIGNAL;\n\tsig_inputArgs->ih.unique = req->uc_unique;\n\n\tsig_req->uc_flags = CODA_REQ_ASYNC;\n\tsig_req->uc_opcode = sig_inputArgs->ih.opcode;\n\tsig_req->uc_unique = sig_inputArgs->ih.unique;\n\tsig_req->uc_inSize = sizeof(struct coda_in_hdr);\n\tsig_req->uc_outSize = sizeof(struct coda_in_hdr);\n\n\t/* insert at head of queue! */\n\tlist_add(&(sig_req->uc_chain), &vcp->vc_pending);\n\twake_up_interruptible(&vcp->vc_waitq);\n\nexit:\n\tkfree(req);\n\tmutex_unlock(&vcp->vc_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/vfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int coda_upcall(struct venus_comm *vc, int inSize, int *outSize,\n\t\t       union inputArgs *buffer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nstatic int coda_upcall(struct venus_comm *vc, int inSize, int *outSize,\n\t\t       union inputArgs *buffer);\n\nstatic int coda_upcall(struct venus_comm *vcp,\n\t\t       int inSize, int *outSize,\n\t\t       union inputArgs *buffer)\n{\n\tunion outputArgs *out;\n\tunion inputArgs *sig_inputArgs;\n\tstruct upc_req *req = NULL, *sig_req;\n\tint error;\n\n\tmutex_lock(&vcp->vc_mutex);\n\n\tif (!vcp->vc_inuse) {\n\t\tpr_notice(\"Venus dead, not sending upcall\\n\");\n\t\terror = -ENXIO;\n\t\tgoto exit;\n\t}\n\n\t/* Format the request message. */\n\treq = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!req) {\n\t\terror = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\treq->uc_data = (void *)buffer;\n\treq->uc_flags = 0;\n\treq->uc_inSize = inSize;\n\treq->uc_outSize = *outSize ? *outSize : inSize;\n\treq->uc_opcode = ((union inputArgs *)buffer)->ih.opcode;\n\treq->uc_unique = ++vcp->vc_seq;\n\tinit_waitqueue_head(&req->uc_sleep);\n\n\t/* Fill in the common input args. */\n\t((union inputArgs *)buffer)->ih.unique = req->uc_unique;\n\n\t/* Append msg to pending queue and poke Venus. */\n\tlist_add_tail(&req->uc_chain, &vcp->vc_pending);\n\n\twake_up_interruptible(&vcp->vc_waitq);\n\t/* We can be interrupted while we wait for Venus to process\n\t * our request.  If the interrupt occurs before Venus has read\n\t * the request, we dequeue and return. If it occurs after the\n\t * read but before the reply, we dequeue, send a signal\n\t * message, and return. If it occurs after the reply we ignore\n\t * it. In no case do we want to restart the syscall.  If it\n\t * was interrupted by a venus shutdown (psdev_close), return\n\t * ENODEV.  */\n\n\t/* Go to sleep.  Wake up on signals only after the timeout. */\n\tcoda_waitfor_upcall(vcp, req);\n\n\t/* Op went through, interrupt or not... */\n\tif (req->uc_flags & CODA_REQ_WRITE) {\n\t\tout = (union outputArgs *)req->uc_data;\n\t\t/* here we map positive Venus errors to kernel errors */\n\t\terror = -out->oh.result;\n\t\t*outSize = req->uc_outSize;\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tif ((req->uc_flags & CODA_REQ_ABORT) || !signal_pending(current)) {\n\t\tpr_warn(\"Unexpected interruption.\\n\");\n\t\tgoto exit;\n\t}\n\n\t/* Interrupted before venus read it. */\n\tif (!(req->uc_flags & CODA_REQ_READ))\n\t\tgoto exit;\n\n\t/* Venus saw the upcall, make sure we can send interrupt signal */\n\tif (!vcp->vc_inuse) {\n\t\tpr_info(\"Venus dead, not sending signal.\\n\");\n\t\tgoto exit;\n\t}\n\n\terror = -ENOMEM;\n\tsig_req = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!sig_req) goto exit;\n\n\tCODA_ALLOC((sig_req->uc_data), char *, sizeof(struct coda_in_hdr));\n\tif (!sig_req->uc_data) {\n\t\tkfree(sig_req);\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tsig_inputArgs = (union inputArgs *)sig_req->uc_data;\n\tsig_inputArgs->ih.opcode = CODA_SIGNAL;\n\tsig_inputArgs->ih.unique = req->uc_unique;\n\n\tsig_req->uc_flags = CODA_REQ_ASYNC;\n\tsig_req->uc_opcode = sig_inputArgs->ih.opcode;\n\tsig_req->uc_unique = sig_inputArgs->ih.unique;\n\tsig_req->uc_inSize = sizeof(struct coda_in_hdr);\n\tsig_req->uc_outSize = sizeof(struct coda_in_hdr);\n\n\t/* insert at head of queue! */\n\tlist_add(&(sig_req->uc_chain), &vcp->vc_pending);\n\twake_up_interruptible(&vcp->vc_waitq);\n\nexit:\n\tkfree(req);\n\tmutex_unlock(&vcp->vc_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_vcp",
          "args": [
            "sb"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UPARG",
          "args": [
            "CODA_GETATTR"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIZE",
          "args": [
            "getattr"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "MPTY_SCAN_SIZE(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
          "lines": "62-67",
          "snippet": "tatic inline uint32_t EMPTY_SCAN_SIZE(uint32_t sector_size) {\n\tif (sector_size < DEFAULT_EMPTY_SCAN_SIZE)\n\t\treturn sector_size;\n\telse\n\t\treturn DEFAULT_EMPTY_SCAN_SIZE;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"summary.h\"\n#",
            "include \"nodelist.h\"\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic inline uint32_t EMPTY_SCAN_SIZE(uint32_t sector_size) {\n\tif (sector_size < DEFAULT_EMPTY_SCAN_SIZE)\n\t\treturn sector_size;\n\telse\n\t\treturn DEFAULT_EMPTY_SCAN_SIZE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nint venus_getattr(struct super_block *sb, struct CodaFid *fid, \n\t\t     struct coda_vattr *attr) \n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n\n        insize = SIZE(getattr); \n\tUPARG(CODA_GETATTR);\n        inp->coda_getattr.VFid = *fid;\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\tif (!error)\n\t\t*attr = outp->coda_getattr.attr;\n\n\tCODA_FREE(inp, insize);\n        return error;\n}"
  },
  {
    "function_name": "venus_rootfid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
    "lines": "74-89",
    "snippet": "int venus_rootfid(struct super_block *sb, struct CodaFid *fidp)\n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n\n        insize = SIZE(root);\n        UPARG(CODA_ROOT);\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\tif (!error)\n\t\t*fidp = outp->coda_root.VFid;\n\n\tCODA_FREE(inp, insize);\n\treturn error;\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_cache.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/vfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CODA_FREE",
          "args": [
            "inp",
            "insize"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coda_upcall",
          "args": [
            "coda_vcp(sb)",
            "insize",
            "&outsize",
            "inp"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "coda_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
          "lines": "666-771",
          "snippet": "static int coda_upcall(struct venus_comm *vcp,\n\t\t       int inSize, int *outSize,\n\t\t       union inputArgs *buffer)\n{\n\tunion outputArgs *out;\n\tunion inputArgs *sig_inputArgs;\n\tstruct upc_req *req = NULL, *sig_req;\n\tint error;\n\n\tmutex_lock(&vcp->vc_mutex);\n\n\tif (!vcp->vc_inuse) {\n\t\tpr_notice(\"Venus dead, not sending upcall\\n\");\n\t\terror = -ENXIO;\n\t\tgoto exit;\n\t}\n\n\t/* Format the request message. */\n\treq = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!req) {\n\t\terror = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\treq->uc_data = (void *)buffer;\n\treq->uc_flags = 0;\n\treq->uc_inSize = inSize;\n\treq->uc_outSize = *outSize ? *outSize : inSize;\n\treq->uc_opcode = ((union inputArgs *)buffer)->ih.opcode;\n\treq->uc_unique = ++vcp->vc_seq;\n\tinit_waitqueue_head(&req->uc_sleep);\n\n\t/* Fill in the common input args. */\n\t((union inputArgs *)buffer)->ih.unique = req->uc_unique;\n\n\t/* Append msg to pending queue and poke Venus. */\n\tlist_add_tail(&req->uc_chain, &vcp->vc_pending);\n\n\twake_up_interruptible(&vcp->vc_waitq);\n\t/* We can be interrupted while we wait for Venus to process\n\t * our request.  If the interrupt occurs before Venus has read\n\t * the request, we dequeue and return. If it occurs after the\n\t * read but before the reply, we dequeue, send a signal\n\t * message, and return. If it occurs after the reply we ignore\n\t * it. In no case do we want to restart the syscall.  If it\n\t * was interrupted by a venus shutdown (psdev_close), return\n\t * ENODEV.  */\n\n\t/* Go to sleep.  Wake up on signals only after the timeout. */\n\tcoda_waitfor_upcall(vcp, req);\n\n\t/* Op went through, interrupt or not... */\n\tif (req->uc_flags & CODA_REQ_WRITE) {\n\t\tout = (union outputArgs *)req->uc_data;\n\t\t/* here we map positive Venus errors to kernel errors */\n\t\terror = -out->oh.result;\n\t\t*outSize = req->uc_outSize;\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tif ((req->uc_flags & CODA_REQ_ABORT) || !signal_pending(current)) {\n\t\tpr_warn(\"Unexpected interruption.\\n\");\n\t\tgoto exit;\n\t}\n\n\t/* Interrupted before venus read it. */\n\tif (!(req->uc_flags & CODA_REQ_READ))\n\t\tgoto exit;\n\n\t/* Venus saw the upcall, make sure we can send interrupt signal */\n\tif (!vcp->vc_inuse) {\n\t\tpr_info(\"Venus dead, not sending signal.\\n\");\n\t\tgoto exit;\n\t}\n\n\terror = -ENOMEM;\n\tsig_req = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!sig_req) goto exit;\n\n\tCODA_ALLOC((sig_req->uc_data), char *, sizeof(struct coda_in_hdr));\n\tif (!sig_req->uc_data) {\n\t\tkfree(sig_req);\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tsig_inputArgs = (union inputArgs *)sig_req->uc_data;\n\tsig_inputArgs->ih.opcode = CODA_SIGNAL;\n\tsig_inputArgs->ih.unique = req->uc_unique;\n\n\tsig_req->uc_flags = CODA_REQ_ASYNC;\n\tsig_req->uc_opcode = sig_inputArgs->ih.opcode;\n\tsig_req->uc_unique = sig_inputArgs->ih.unique;\n\tsig_req->uc_inSize = sizeof(struct coda_in_hdr);\n\tsig_req->uc_outSize = sizeof(struct coda_in_hdr);\n\n\t/* insert at head of queue! */\n\tlist_add(&(sig_req->uc_chain), &vcp->vc_pending);\n\twake_up_interruptible(&vcp->vc_waitq);\n\nexit:\n\tkfree(req);\n\tmutex_unlock(&vcp->vc_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/vfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int coda_upcall(struct venus_comm *vc, int inSize, int *outSize,\n\t\t       union inputArgs *buffer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nstatic int coda_upcall(struct venus_comm *vc, int inSize, int *outSize,\n\t\t       union inputArgs *buffer);\n\nstatic int coda_upcall(struct venus_comm *vcp,\n\t\t       int inSize, int *outSize,\n\t\t       union inputArgs *buffer)\n{\n\tunion outputArgs *out;\n\tunion inputArgs *sig_inputArgs;\n\tstruct upc_req *req = NULL, *sig_req;\n\tint error;\n\n\tmutex_lock(&vcp->vc_mutex);\n\n\tif (!vcp->vc_inuse) {\n\t\tpr_notice(\"Venus dead, not sending upcall\\n\");\n\t\terror = -ENXIO;\n\t\tgoto exit;\n\t}\n\n\t/* Format the request message. */\n\treq = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!req) {\n\t\terror = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\treq->uc_data = (void *)buffer;\n\treq->uc_flags = 0;\n\treq->uc_inSize = inSize;\n\treq->uc_outSize = *outSize ? *outSize : inSize;\n\treq->uc_opcode = ((union inputArgs *)buffer)->ih.opcode;\n\treq->uc_unique = ++vcp->vc_seq;\n\tinit_waitqueue_head(&req->uc_sleep);\n\n\t/* Fill in the common input args. */\n\t((union inputArgs *)buffer)->ih.unique = req->uc_unique;\n\n\t/* Append msg to pending queue and poke Venus. */\n\tlist_add_tail(&req->uc_chain, &vcp->vc_pending);\n\n\twake_up_interruptible(&vcp->vc_waitq);\n\t/* We can be interrupted while we wait for Venus to process\n\t * our request.  If the interrupt occurs before Venus has read\n\t * the request, we dequeue and return. If it occurs after the\n\t * read but before the reply, we dequeue, send a signal\n\t * message, and return. If it occurs after the reply we ignore\n\t * it. In no case do we want to restart the syscall.  If it\n\t * was interrupted by a venus shutdown (psdev_close), return\n\t * ENODEV.  */\n\n\t/* Go to sleep.  Wake up on signals only after the timeout. */\n\tcoda_waitfor_upcall(vcp, req);\n\n\t/* Op went through, interrupt or not... */\n\tif (req->uc_flags & CODA_REQ_WRITE) {\n\t\tout = (union outputArgs *)req->uc_data;\n\t\t/* here we map positive Venus errors to kernel errors */\n\t\terror = -out->oh.result;\n\t\t*outSize = req->uc_outSize;\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tif ((req->uc_flags & CODA_REQ_ABORT) || !signal_pending(current)) {\n\t\tpr_warn(\"Unexpected interruption.\\n\");\n\t\tgoto exit;\n\t}\n\n\t/* Interrupted before venus read it. */\n\tif (!(req->uc_flags & CODA_REQ_READ))\n\t\tgoto exit;\n\n\t/* Venus saw the upcall, make sure we can send interrupt signal */\n\tif (!vcp->vc_inuse) {\n\t\tpr_info(\"Venus dead, not sending signal.\\n\");\n\t\tgoto exit;\n\t}\n\n\terror = -ENOMEM;\n\tsig_req = kmalloc(sizeof(struct upc_req), GFP_KERNEL);\n\tif (!sig_req) goto exit;\n\n\tCODA_ALLOC((sig_req->uc_data), char *, sizeof(struct coda_in_hdr));\n\tif (!sig_req->uc_data) {\n\t\tkfree(sig_req);\n\t\tgoto exit;\n\t}\n\n\terror = -EINTR;\n\tsig_inputArgs = (union inputArgs *)sig_req->uc_data;\n\tsig_inputArgs->ih.opcode = CODA_SIGNAL;\n\tsig_inputArgs->ih.unique = req->uc_unique;\n\n\tsig_req->uc_flags = CODA_REQ_ASYNC;\n\tsig_req->uc_opcode = sig_inputArgs->ih.opcode;\n\tsig_req->uc_unique = sig_inputArgs->ih.unique;\n\tsig_req->uc_inSize = sizeof(struct coda_in_hdr);\n\tsig_req->uc_outSize = sizeof(struct coda_in_hdr);\n\n\t/* insert at head of queue! */\n\tlist_add(&(sig_req->uc_chain), &vcp->vc_pending);\n\twake_up_interruptible(&vcp->vc_waitq);\n\nexit:\n\tkfree(req);\n\tmutex_unlock(&vcp->vc_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_vcp",
          "args": [
            "sb"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UPARG",
          "args": [
            "CODA_ROOT"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIZE",
          "args": [
            "root"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "MPTY_SCAN_SIZE(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
          "lines": "62-67",
          "snippet": "tatic inline uint32_t EMPTY_SCAN_SIZE(uint32_t sector_size) {\n\tif (sector_size < DEFAULT_EMPTY_SCAN_SIZE)\n\t\treturn sector_size;\n\telse\n\t\treturn DEFAULT_EMPTY_SCAN_SIZE;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"summary.h\"\n#",
            "include \"nodelist.h\"\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic inline uint32_t EMPTY_SCAN_SIZE(uint32_t sector_size) {\n\tif (sector_size < DEFAULT_EMPTY_SCAN_SIZE)\n\t\treturn sector_size;\n\telse\n\t\treturn DEFAULT_EMPTY_SCAN_SIZE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nint venus_rootfid(struct super_block *sb, struct CodaFid *fidp)\n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n\n        insize = SIZE(root);\n        UPARG(CODA_ROOT);\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\tif (!error)\n\t\t*fidp = outp->coda_root.VFid;\n\n\tCODA_FREE(inp, insize);\n\treturn error;\n}"
  },
  {
    "function_name": "alloc_upcall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
    "lines": "44-58",
    "snippet": "static void *alloc_upcall(int opcode, int size)\n{\n\tunion inputArgs *inp;\n\n\tCODA_ALLOC(inp, union inputArgs *, size);\n        if (!inp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n        inp->ih.opcode = opcode;\n\tinp->ih.pid = task_pid_nr_ns(current, &init_pid_ns);\n\tinp->ih.pgid = task_pgrp_nr_ns(current, &init_pid_ns);\n\tinp->ih.uid = from_kuid(&init_user_ns, current_fsuid());\n\n\treturn (void*)inp;\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_cache.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/vfs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/errno.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "current_fsuid()"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pgrp_nr_ns",
          "args": [
            "current",
            "&init_pid_ns"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr_ns",
          "args": [
            "current",
            "&init_pid_ns"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CODA_ALLOC",
          "args": [
            "inp",
            "unioninputArgs*",
            "size"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nstatic void *alloc_upcall(int opcode, int size)\n{\n\tunion inputArgs *inp;\n\n\tCODA_ALLOC(inp, union inputArgs *, size);\n        if (!inp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n        inp->ih.opcode = opcode;\n\tinp->ih.pid = task_pid_nr_ns(current, &init_pid_ns);\n\tinp->ih.pgid = task_pgrp_nr_ns(current, &init_pid_ns);\n\tinp->ih.uid = from_kuid(&init_user_ns, current_fsuid());\n\n\treturn (void*)inp;\n}"
  }
]