[
  {
    "function_name": "f2fs_read_inline_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inline.c",
    "lines": "500-523",
    "snippet": "int f2fs_read_inline_dir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct f2fs_inline_dentry *inline_dentry = NULL;\n\tstruct page *ipage = NULL;\n\tstruct f2fs_dentry_ptr d;\n\n\tif (ctx->pos == NR_INLINE_DENTRY)\n\t\treturn 0;\n\n\tipage = get_node_page(F2FS_I_SB(inode), inode->i_ino);\n\tif (IS_ERR(ipage))\n\t\treturn PTR_ERR(ipage);\n\n\tinline_dentry = inline_data_addr(ipage);\n\n\tmake_dentry_ptr(&d, (void *)inline_dentry, 2);\n\n\tif (!f2fs_fill_dentries(ctx, &d, 0))\n\t\tctx->pos = NR_INLINE_DENTRY;\n\n\tf2fs_put_page(ipage, 1);\n\treturn 0;\n}",
    "includes": [
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "ipage",
            "1"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_fill_dentries",
          "args": [
            "ctx",
            "&d",
            "0"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_fill_dentries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "716-744",
          "snippet": "bool f2fs_fill_dentries(struct dir_context *ctx, struct f2fs_dentry_ptr *d,\n\t\t\t\t\t\tunsigned int start_pos)\n{\n\tunsigned char d_type = DT_UNKNOWN;\n\tunsigned int bit_pos;\n\tstruct f2fs_dir_entry *de = NULL;\n\n\tbit_pos = ((unsigned long)ctx->pos % d->max);\n\n\twhile (bit_pos < d->max) {\n\t\tbit_pos = find_next_bit_le(d->bitmap, d->max, bit_pos);\n\t\tif (bit_pos >= d->max)\n\t\t\tbreak;\n\n\t\tde = &d->dentry[bit_pos];\n\t\tif (de->file_type < F2FS_FT_MAX)\n\t\t\td_type = f2fs_filetype_table[de->file_type];\n\t\telse\n\t\t\td_type = DT_UNKNOWN;\n\t\tif (!dir_emit(ctx, d->filename[bit_pos],\n\t\t\t\t\tle16_to_cpu(de->name_len),\n\t\t\t\t\tle32_to_cpu(de->ino), d_type))\n\t\t\treturn true;\n\n\t\tbit_pos += GET_DENTRY_SLOTS(le16_to_cpu(de->name_len));\n\t\tctx->pos = start_pos + bit_pos;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned char f2fs_filetype_table[F2FS_FT_MAX] = {\n\t[F2FS_FT_UNKNOWN]\t= DT_UNKNOWN,\n\t[F2FS_FT_REG_FILE]\t= DT_REG,\n\t[F2FS_FT_DIR]\t\t= DT_DIR,\n\t[F2FS_FT_CHRDEV]\t= DT_CHR,\n\t[F2FS_FT_BLKDEV]\t= DT_BLK,\n\t[F2FS_FT_FIFO]\t\t= DT_FIFO,\n\t[F2FS_FT_SOCK]\t\t= DT_SOCK,\n\t[F2FS_FT_SYMLINK]\t= DT_LNK,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nunsigned char f2fs_filetype_table[F2FS_FT_MAX] = {\n\t[F2FS_FT_UNKNOWN]\t= DT_UNKNOWN,\n\t[F2FS_FT_REG_FILE]\t= DT_REG,\n\t[F2FS_FT_DIR]\t\t= DT_DIR,\n\t[F2FS_FT_CHRDEV]\t= DT_CHR,\n\t[F2FS_FT_BLKDEV]\t= DT_BLK,\n\t[F2FS_FT_FIFO]\t\t= DT_FIFO,\n\t[F2FS_FT_SOCK]\t\t= DT_SOCK,\n\t[F2FS_FT_SYMLINK]\t= DT_LNK,\n};\n\nbool f2fs_fill_dentries(struct dir_context *ctx, struct f2fs_dentry_ptr *d,\n\t\t\t\t\t\tunsigned int start_pos)\n{\n\tunsigned char d_type = DT_UNKNOWN;\n\tunsigned int bit_pos;\n\tstruct f2fs_dir_entry *de = NULL;\n\n\tbit_pos = ((unsigned long)ctx->pos % d->max);\n\n\twhile (bit_pos < d->max) {\n\t\tbit_pos = find_next_bit_le(d->bitmap, d->max, bit_pos);\n\t\tif (bit_pos >= d->max)\n\t\t\tbreak;\n\n\t\tde = &d->dentry[bit_pos];\n\t\tif (de->file_type < F2FS_FT_MAX)\n\t\t\td_type = f2fs_filetype_table[de->file_type];\n\t\telse\n\t\t\td_type = DT_UNKNOWN;\n\t\tif (!dir_emit(ctx, d->filename[bit_pos],\n\t\t\t\t\tle16_to_cpu(de->name_len),\n\t\t\t\t\tle32_to_cpu(de->ino), d_type))\n\t\t\treturn true;\n\n\t\tbit_pos += GET_DENTRY_SLOTS(le16_to_cpu(de->name_len));\n\t\tctx->pos = start_pos + bit_pos;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_dentry_ptr",
          "args": [
            "&d",
            "(void *)inline_dentry",
            "2"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "make_dentry_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "238-254",
          "snippet": "static inline void make_dentry_ptr(struct f2fs_dentry_ptr *d,\n\t\t\t\t\tvoid *src, int type)\n{\n\tif (type == 1) {\n\t\tstruct f2fs_dentry_block *t = (struct f2fs_dentry_block *)src;\n\t\td->max = NR_DENTRY_IN_BLOCK;\n\t\td->bitmap = &t->dentry_bitmap;\n\t\td->dentry = t->dentry;\n\t\td->filename = t->filename;\n\t} else {\n\t\tstruct f2fs_inline_dentry *t = (struct f2fs_inline_dentry *)src;\n\t\td->max = NR_INLINE_DENTRY;\n\t\td->bitmap = &t->dentry_bitmap;\n\t\td->dentry = t->dentry;\n\t\td->filename = t->filename;\n\t}\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void make_dentry_ptr(struct f2fs_dentry_ptr *d,\n\t\t\t\t\tvoid *src, int type)\n{\n\tif (type == 1) {\n\t\tstruct f2fs_dentry_block *t = (struct f2fs_dentry_block *)src;\n\t\td->max = NR_DENTRY_IN_BLOCK;\n\t\td->bitmap = &t->dentry_bitmap;\n\t\td->dentry = t->dentry;\n\t\td->filename = t->filename;\n\t} else {\n\t\tstruct f2fs_inline_dentry *t = (struct f2fs_inline_dentry *)src;\n\t\td->max = NR_INLINE_DENTRY;\n\t\td->bitmap = &t->dentry_bitmap;\n\t\td->dentry = t->dentry;\n\t\td->filename = t->filename;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inline_data_addr",
          "args": [
            "ipage"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "inline_data_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1282-1286",
          "snippet": "static inline void *inline_data_addr(struct page *page)\n{\n\tstruct f2fs_inode *ri = F2FS_INODE(page);\n\treturn (void *)&(ri->i_addr[1]);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *inline_data_addr(struct page *page)\n{\n\tstruct f2fs_inode *ri = F2FS_INODE(page);\n\treturn (void *)&(ri->i_addr[1]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ipage"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ipage"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node_page",
          "args": [
            "F2FS_I_SB(inode)",
            "inode->i_ino"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_page_ra",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1066-1114",
          "snippet": "struct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "inode"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_read_inline_dir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct f2fs_inline_dentry *inline_dentry = NULL;\n\tstruct page *ipage = NULL;\n\tstruct f2fs_dentry_ptr d;\n\n\tif (ctx->pos == NR_INLINE_DENTRY)\n\t\treturn 0;\n\n\tipage = get_node_page(F2FS_I_SB(inode), inode->i_ino);\n\tif (IS_ERR(ipage))\n\t\treturn PTR_ERR(ipage);\n\n\tinline_dentry = inline_data_addr(ipage);\n\n\tmake_dentry_ptr(&d, (void *)inline_dentry, 2);\n\n\tif (!f2fs_fill_dentries(ctx, &d, 0))\n\t\tctx->pos = NR_INLINE_DENTRY;\n\n\tf2fs_put_page(ipage, 1);\n\treturn 0;\n}"
  },
  {
    "function_name": "f2fs_empty_inline_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inline.c",
    "lines": "476-498",
    "snippet": "bool f2fs_empty_inline_dir(struct inode *dir)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tstruct page *ipage;\n\tunsigned int bit_pos = 2;\n\tstruct f2fs_inline_dentry *dentry_blk;\n\n\tipage = get_node_page(sbi, dir->i_ino);\n\tif (IS_ERR(ipage))\n\t\treturn false;\n\n\tdentry_blk = inline_data_addr(ipage);\n\tbit_pos = find_next_bit_le(&dentry_blk->dentry_bitmap,\n\t\t\t\t\tNR_INLINE_DENTRY,\n\t\t\t\t\tbit_pos);\n\n\tf2fs_put_page(ipage, 1);\n\n\tif (bit_pos < NR_INLINE_DENTRY)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "ipage",
            "1"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_next_bit_le",
          "args": [
            "&dentry_blk->dentry_bitmap",
            "NR_INLINE_DENTRY",
            "bit_pos"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inline_data_addr",
          "args": [
            "ipage"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "inline_data_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1282-1286",
          "snippet": "static inline void *inline_data_addr(struct page *page)\n{\n\tstruct f2fs_inode *ri = F2FS_INODE(page);\n\treturn (void *)&(ri->i_addr[1]);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *inline_data_addr(struct page *page)\n{\n\tstruct f2fs_inode *ri = F2FS_INODE(page);\n\treturn (void *)&(ri->i_addr[1]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ipage"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node_page",
          "args": [
            "sbi",
            "dir->i_ino"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_page_ra",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1066-1114",
          "snippet": "struct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "dir"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nbool f2fs_empty_inline_dir(struct inode *dir)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tstruct page *ipage;\n\tunsigned int bit_pos = 2;\n\tstruct f2fs_inline_dentry *dentry_blk;\n\n\tipage = get_node_page(sbi, dir->i_ino);\n\tif (IS_ERR(ipage))\n\t\treturn false;\n\n\tdentry_blk = inline_data_addr(ipage);\n\tbit_pos = find_next_bit_le(&dentry_blk->dentry_bitmap,\n\t\t\t\t\tNR_INLINE_DENTRY,\n\t\t\t\t\tbit_pos);\n\n\tf2fs_put_page(ipage, 1);\n\n\tif (bit_pos < NR_INLINE_DENTRY)\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "f2fs_delete_inline_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inline.c",
    "lines": "449-474",
    "snippet": "void f2fs_delete_inline_entry(struct f2fs_dir_entry *dentry, struct page *page,\n\t\t\t\t\tstruct inode *dir, struct inode *inode)\n{\n\tstruct f2fs_inline_dentry *inline_dentry;\n\tint slots = GET_DENTRY_SLOTS(le16_to_cpu(dentry->name_len));\n\tunsigned int bit_pos;\n\tint i;\n\n\tlock_page(page);\n\tf2fs_wait_on_page_writeback(page, NODE);\n\n\tinline_dentry = inline_data_addr(page);\n\tbit_pos = dentry - inline_dentry->dentry;\n\tfor (i = 0; i < slots; i++)\n\t\ttest_and_clear_bit_le(bit_pos + i,\n\t\t\t\t&inline_dentry->dentry_bitmap);\n\n\tset_page_dirty(page);\n\n\tdir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\n\tif (inode)\n\t\tf2fs_drop_nlink(dir, inode, page);\n\n\tf2fs_put_page(page, 1);\n}",
    "includes": [
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "page",
            "1"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_drop_nlink",
          "args": [
            "dir",
            "inode",
            "page"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "605-632",
          "snippet": "void f2fs_drop_nlink(struct inode *dir, struct inode *inode, struct page *page)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\n\tdown_write(&F2FS_I(inode)->i_sem);\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tdrop_nlink(dir);\n\t\tif (page)\n\t\t\tupdate_inode(dir, page);\n\t\telse\n\t\t\tupdate_inode_page(dir);\n\t}\n\tinode->i_ctime = CURRENT_TIME;\n\n\tdrop_nlink(inode);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tdrop_nlink(inode);\n\t\ti_size_write(inode, 0);\n\t}\n\tup_write(&F2FS_I(inode)->i_sem);\n\tupdate_inode_page(inode);\n\n\tif (inode->i_nlink == 0)\n\t\tadd_orphan_inode(sbi, inode->i_ino);\n\telse\n\t\trelease_orphan_inode(sbi);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_drop_nlink(struct inode *dir, struct inode *inode, struct page *page)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\n\tdown_write(&F2FS_I(inode)->i_sem);\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tdrop_nlink(dir);\n\t\tif (page)\n\t\t\tupdate_inode(dir, page);\n\t\telse\n\t\t\tupdate_inode_page(dir);\n\t}\n\tinode->i_ctime = CURRENT_TIME;\n\n\tdrop_nlink(inode);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tdrop_nlink(inode);\n\t\ti_size_write(inode, 0);\n\t}\n\tup_write(&F2FS_I(inode)->i_sem);\n\tupdate_inode_page(inode);\n\n\tif (inode->i_nlink == 0)\n\t\tadd_orphan_inode(sbi, inode->i_ino);\n\telse\n\t\trelease_orphan_inode(sbi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit_le",
          "args": [
            "bit_pos + i",
            "&inline_dentry->dentry_bitmap"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inline_data_addr",
          "args": [
            "page"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "inline_data_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1282-1286",
          "snippet": "static inline void *inline_data_addr(struct page *page)\n{\n\tstruct f2fs_inode *ri = F2FS_INODE(page);\n\treturn (void *)&(ri->i_addr[1]);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *inline_data_addr(struct page *page)\n{\n\tstruct f2fs_inode *ri = F2FS_INODE(page);\n\treturn (void *)&(ri->i_addr[1]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_wait_on_page_writeback",
          "args": [
            "page",
            "NODE"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_wait_on_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1321-1331",
          "snippet": "void f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_page",
          "args": [
            "page"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_DENTRY_SLOTS",
          "args": [
            "le16_to_cpu(dentry->name_len)"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "dentry->name_len"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_delete_inline_entry(struct f2fs_dir_entry *dentry, struct page *page,\n\t\t\t\t\tstruct inode *dir, struct inode *inode)\n{\n\tstruct f2fs_inline_dentry *inline_dentry;\n\tint slots = GET_DENTRY_SLOTS(le16_to_cpu(dentry->name_len));\n\tunsigned int bit_pos;\n\tint i;\n\n\tlock_page(page);\n\tf2fs_wait_on_page_writeback(page, NODE);\n\n\tinline_dentry = inline_data_addr(page);\n\tbit_pos = dentry - inline_dentry->dentry;\n\tfor (i = 0; i < slots; i++)\n\t\ttest_and_clear_bit_le(bit_pos + i,\n\t\t\t\t&inline_dentry->dentry_bitmap);\n\n\tset_page_dirty(page);\n\n\tdir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\n\tif (inode)\n\t\tf2fs_drop_nlink(dir, inode, page);\n\n\tf2fs_put_page(page, 1);\n}"
  },
  {
    "function_name": "f2fs_add_inline_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inline.c",
    "lines": "382-447",
    "snippet": "int f2fs_add_inline_entry(struct inode *dir, const struct qstr *name,\n\t\t\t\t\t\tstruct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tstruct page *ipage;\n\tunsigned int bit_pos;\n\tf2fs_hash_t name_hash;\n\tstruct f2fs_dir_entry *de;\n\tsize_t namelen = name->len;\n\tstruct f2fs_inline_dentry *dentry_blk = NULL;\n\tint slots = GET_DENTRY_SLOTS(namelen);\n\tstruct page *page;\n\tint err = 0;\n\tint i;\n\n\tname_hash = f2fs_dentry_hash(name);\n\n\tipage = get_node_page(sbi, dir->i_ino);\n\tif (IS_ERR(ipage))\n\t\treturn PTR_ERR(ipage);\n\n\tdentry_blk = inline_data_addr(ipage);\n\tbit_pos = room_for_filename(&dentry_blk->dentry_bitmap,\n\t\t\t\t\t\tslots, NR_INLINE_DENTRY);\n\tif (bit_pos >= NR_INLINE_DENTRY) {\n\t\terr = f2fs_convert_inline_dir(dir, ipage, dentry_blk);\n\t\tif (!err)\n\t\t\terr = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tdown_write(&F2FS_I(inode)->i_sem);\n\tpage = init_inode_metadata(inode, dir, name, ipage);\n\tif (IS_ERR(page)) {\n\t\terr = PTR_ERR(page);\n\t\tgoto fail;\n\t}\n\n\tf2fs_wait_on_page_writeback(ipage, NODE);\n\tde = &dentry_blk->dentry[bit_pos];\n\tde->hash_code = name_hash;\n\tde->name_len = cpu_to_le16(namelen);\n\tmemcpy(dentry_blk->filename[bit_pos], name->name, name->len);\n\tde->ino = cpu_to_le32(inode->i_ino);\n\tset_de_type(de, inode);\n\tfor (i = 0; i < slots; i++)\n\t\ttest_and_set_bit_le(bit_pos + i, &dentry_blk->dentry_bitmap);\n\tset_page_dirty(ipage);\n\n\t/* we don't need to mark_inode_dirty now */\n\tF2FS_I(inode)->i_pino = dir->i_ino;\n\tupdate_inode(inode, page);\n\tf2fs_put_page(page, 1);\n\n\tupdate_parent_metadata(dir, inode, 0);\nfail:\n\tup_write(&F2FS_I(inode)->i_sem);\n\n\tif (is_inode_flag_set(F2FS_I(dir), FI_UPDATE_DIR)) {\n\t\tupdate_inode(dir, ipage);\n\t\tclear_inode_flag(F2FS_I(dir), FI_UPDATE_DIR);\n\t}\nout:\n\tf2fs_put_page(ipage, 1);\n\treturn err;\n}",
    "includes": [
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "ipage",
            "1"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_inode_flag",
          "args": [
            "F2FS_I(dir)",
            "FI_UPDATE_DIR"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1184-1188",
          "snippet": "static inline void clear_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (test_bit(flag, &fi->flags))\n\t\tclear_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void clear_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (test_bit(flag, &fi->flags))\n\t\tclear_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "dir"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_inode",
          "args": [
            "dir",
            "ipage"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "update_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
          "lines": "208-244",
          "snippet": "void update_inode(struct inode *inode, struct page *node_page)\n{\n\tstruct f2fs_inode *ri;\n\n\tf2fs_wait_on_page_writeback(node_page, NODE);\n\n\tri = F2FS_INODE(node_page);\n\n\tri->i_mode = cpu_to_le16(inode->i_mode);\n\tri->i_advise = F2FS_I(inode)->i_advise;\n\tri->i_uid = cpu_to_le32(i_uid_read(inode));\n\tri->i_gid = cpu_to_le32(i_gid_read(inode));\n\tri->i_links = cpu_to_le32(inode->i_nlink);\n\tri->i_size = cpu_to_le64(i_size_read(inode));\n\tri->i_blocks = cpu_to_le64(inode->i_blocks);\n\tset_raw_extent(&F2FS_I(inode)->ext, &ri->i_ext);\n\tset_raw_inline(F2FS_I(inode), ri);\n\n\tri->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tri->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tri->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tri->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tri->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tri->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\tri->i_current_depth = cpu_to_le32(F2FS_I(inode)->i_current_depth);\n\tri->i_xattr_nid = cpu_to_le32(F2FS_I(inode)->i_xattr_nid);\n\tri->i_flags = cpu_to_le32(F2FS_I(inode)->i_flags);\n\tri->i_pino = cpu_to_le32(F2FS_I(inode)->i_pino);\n\tri->i_generation = cpu_to_le32(inode->i_generation);\n\tri->i_dir_level = F2FS_I(inode)->i_dir_level;\n\n\t__set_inode_rdev(inode, ri);\n\tset_cold_node(inode, node_page);\n\tset_page_dirty(node_page);\n\n\tclear_inode_flag(F2FS_I(inode), FI_DIRTY_INODE);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid update_inode(struct inode *inode, struct page *node_page)\n{\n\tstruct f2fs_inode *ri;\n\n\tf2fs_wait_on_page_writeback(node_page, NODE);\n\n\tri = F2FS_INODE(node_page);\n\n\tri->i_mode = cpu_to_le16(inode->i_mode);\n\tri->i_advise = F2FS_I(inode)->i_advise;\n\tri->i_uid = cpu_to_le32(i_uid_read(inode));\n\tri->i_gid = cpu_to_le32(i_gid_read(inode));\n\tri->i_links = cpu_to_le32(inode->i_nlink);\n\tri->i_size = cpu_to_le64(i_size_read(inode));\n\tri->i_blocks = cpu_to_le64(inode->i_blocks);\n\tset_raw_extent(&F2FS_I(inode)->ext, &ri->i_ext);\n\tset_raw_inline(F2FS_I(inode), ri);\n\n\tri->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tri->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tri->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tri->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tri->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tri->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\tri->i_current_depth = cpu_to_le32(F2FS_I(inode)->i_current_depth);\n\tri->i_xattr_nid = cpu_to_le32(F2FS_I(inode)->i_xattr_nid);\n\tri->i_flags = cpu_to_le32(F2FS_I(inode)->i_flags);\n\tri->i_pino = cpu_to_le32(F2FS_I(inode)->i_pino);\n\tri->i_generation = cpu_to_le32(inode->i_generation);\n\tri->i_dir_level = F2FS_I(inode)->i_dir_level;\n\n\t__set_inode_rdev(inode, ri);\n\tset_cold_node(inode, node_page);\n\tset_page_dirty(node_page);\n\n\tclear_inode_flag(F2FS_I(inode), FI_DIRTY_INODE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_inode_flag_set",
          "args": [
            "F2FS_I(dir)",
            "FI_UPDATE_DIR"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "is_inode_flag_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1179-1182",
          "snippet": "static inline int is_inode_flag_set(struct f2fs_inode_info *fi, int flag)\n{\n\treturn test_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int is_inode_flag_set(struct f2fs_inode_info *fi, int flag)\n{\n\treturn test_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&F2FS_I(inode)->i_sem"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_parent_metadata",
          "args": [
            "dir",
            "inode",
            "0"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "update_parent_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "435-455",
          "snippet": "void update_parent_metadata(struct inode *dir, struct inode *inode,\n\t\t\t\t\t\tunsigned int current_depth)\n{\n\tif (is_inode_flag_set(F2FS_I(inode), FI_NEW_INODE)) {\n\t\tif (S_ISDIR(inode->i_mode)) {\n\t\t\tinc_nlink(dir);\n\t\t\tset_inode_flag(F2FS_I(dir), FI_UPDATE_DIR);\n\t\t}\n\t\tclear_inode_flag(F2FS_I(inode), FI_NEW_INODE);\n\t}\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME;\n\tmark_inode_dirty(dir);\n\n\tif (F2FS_I(dir)->i_current_depth != current_depth) {\n\t\tF2FS_I(dir)->i_current_depth = current_depth;\n\t\tset_inode_flag(F2FS_I(dir), FI_UPDATE_DIR);\n\t}\n\n\tif (is_inode_flag_set(F2FS_I(inode), FI_INC_LINK))\n\t\tclear_inode_flag(F2FS_I(inode), FI_INC_LINK);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid update_parent_metadata(struct inode *dir, struct inode *inode,\n\t\t\t\t\t\tunsigned int current_depth)\n{\n\tif (is_inode_flag_set(F2FS_I(inode), FI_NEW_INODE)) {\n\t\tif (S_ISDIR(inode->i_mode)) {\n\t\t\tinc_nlink(dir);\n\t\t\tset_inode_flag(F2FS_I(dir), FI_UPDATE_DIR);\n\t\t}\n\t\tclear_inode_flag(F2FS_I(inode), FI_NEW_INODE);\n\t}\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME;\n\tmark_inode_dirty(dir);\n\n\tif (F2FS_I(dir)->i_current_depth != current_depth) {\n\t\tF2FS_I(dir)->i_current_depth = current_depth;\n\t\tset_inode_flag(F2FS_I(dir), FI_UPDATE_DIR);\n\t}\n\n\tif (is_inode_flag_set(F2FS_I(inode), FI_INC_LINK))\n\t\tclear_inode_flag(F2FS_I(inode), FI_INC_LINK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "ipage"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit_le",
          "args": [
            "bit_pos + i",
            "&dentry_blk->dentry_bitmap"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_de_type",
          "args": [
            "de",
            "inode"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "set_de_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "62-66",
          "snippet": "void set_de_type(struct f2fs_dir_entry *de, struct inode *inode)\n{\n\tumode_t mode = inode->i_mode;\n\tde->file_type = f2fs_type_by_mode[(mode & S_IFMT) >> S_SHIFT];\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define S_SHIFT 12"
          ],
          "globals_used": [
            "static unsigned char f2fs_type_by_mode[S_IFMT >> S_SHIFT] = {\n\t[S_IFREG >> S_SHIFT]\t= F2FS_FT_REG_FILE,\n\t[S_IFDIR >> S_SHIFT]\t= F2FS_FT_DIR,\n\t[S_IFCHR >> S_SHIFT]\t= F2FS_FT_CHRDEV,\n\t[S_IFBLK >> S_SHIFT]\t= F2FS_FT_BLKDEV,\n\t[S_IFIFO >> S_SHIFT]\t= F2FS_FT_FIFO,\n\t[S_IFSOCK >> S_SHIFT]\t= F2FS_FT_SOCK,\n\t[S_IFLNK >> S_SHIFT]\t= F2FS_FT_SYMLINK,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\n#define S_SHIFT 12\n\nstatic unsigned char f2fs_type_by_mode[S_IFMT >> S_SHIFT] = {\n\t[S_IFREG >> S_SHIFT]\t= F2FS_FT_REG_FILE,\n\t[S_IFDIR >> S_SHIFT]\t= F2FS_FT_DIR,\n\t[S_IFCHR >> S_SHIFT]\t= F2FS_FT_CHRDEV,\n\t[S_IFBLK >> S_SHIFT]\t= F2FS_FT_BLKDEV,\n\t[S_IFIFO >> S_SHIFT]\t= F2FS_FT_FIFO,\n\t[S_IFSOCK >> S_SHIFT]\t= F2FS_FT_SOCK,\n\t[S_IFLNK >> S_SHIFT]\t= F2FS_FT_SYMLINK,\n};\n\nvoid set_de_type(struct f2fs_dir_entry *de, struct inode *inode)\n{\n\tumode_t mode = inode->i_mode;\n\tde->file_type = f2fs_type_by_mode[(mode & S_IFMT) >> S_SHIFT];\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_ino"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dentry_blk->filename[bit_pos]",
            "name->name",
            "name->len"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "namelen"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_wait_on_page_writeback",
          "args": [
            "ipage",
            "NODE"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_wait_on_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1321-1331",
          "snippet": "void f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_inode_metadata",
          "args": [
            "inode",
            "dir",
            "name",
            "ipage"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "init_inode_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "373-433",
          "snippet": "struct page *init_inode_metadata(struct inode *inode, struct inode *dir,\n\t\t\tconst struct qstr *name, struct page *dpage)\n{\n\tstruct page *page;\n\tint err;\n\n\tif (is_inode_flag_set(F2FS_I(inode), FI_NEW_INODE)) {\n\t\tpage = new_inode_page(inode);\n\t\tif (IS_ERR(page))\n\t\t\treturn page;\n\n\t\tif (S_ISDIR(inode->i_mode)) {\n\t\t\terr = make_empty_dir(inode, dir, page);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\terr = f2fs_init_acl(inode, dir, page, dpage);\n\t\tif (err)\n\t\t\tgoto put_error;\n\n\t\terr = f2fs_init_security(inode, dir, name, page);\n\t\tif (err)\n\t\t\tgoto put_error;\n\t} else {\n\t\tpage = get_node_page(F2FS_I_SB(dir), inode->i_ino);\n\t\tif (IS_ERR(page))\n\t\t\treturn page;\n\n\t\tset_cold_node(inode, page);\n\t}\n\n\tif (name)\n\t\tinit_dent_inode(name, page);\n\n\t/*\n\t * This file should be checkpointed during fsync.\n\t * We lost i_pino from now on.\n\t */\n\tif (is_inode_flag_set(F2FS_I(inode), FI_INC_LINK)) {\n\t\tfile_lost_pino(inode);\n\t\t/*\n\t\t * If link the tmpfile to alias through linkat path,\n\t\t * we should remove this inode from orphan list.\n\t\t */\n\t\tif (inode->i_nlink == 0)\n\t\t\tremove_orphan_inode(F2FS_I_SB(dir), inode->i_ino);\n\t\tinc_nlink(inode);\n\t}\n\treturn page;\n\nput_error:\n\tf2fs_put_page(page, 1);\nerror:\n\t/* once the failed inode becomes a bad inode, i_mode is S_IFREG */\n\ttruncate_inode_pages(&inode->i_data, 0);\n\ttruncate_blocks(inode, 0, false);\n\tremove_dirty_dir_inode(inode);\n\tremove_inode_page(inode);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *init_inode_metadata(struct inode *inode, struct inode *dir,\n\t\t\tconst struct qstr *name, struct page *dpage)\n{\n\tstruct page *page;\n\tint err;\n\n\tif (is_inode_flag_set(F2FS_I(inode), FI_NEW_INODE)) {\n\t\tpage = new_inode_page(inode);\n\t\tif (IS_ERR(page))\n\t\t\treturn page;\n\n\t\tif (S_ISDIR(inode->i_mode)) {\n\t\t\terr = make_empty_dir(inode, dir, page);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\terr = f2fs_init_acl(inode, dir, page, dpage);\n\t\tif (err)\n\t\t\tgoto put_error;\n\n\t\terr = f2fs_init_security(inode, dir, name, page);\n\t\tif (err)\n\t\t\tgoto put_error;\n\t} else {\n\t\tpage = get_node_page(F2FS_I_SB(dir), inode->i_ino);\n\t\tif (IS_ERR(page))\n\t\t\treturn page;\n\n\t\tset_cold_node(inode, page);\n\t}\n\n\tif (name)\n\t\tinit_dent_inode(name, page);\n\n\t/*\n\t * This file should be checkpointed during fsync.\n\t * We lost i_pino from now on.\n\t */\n\tif (is_inode_flag_set(F2FS_I(inode), FI_INC_LINK)) {\n\t\tfile_lost_pino(inode);\n\t\t/*\n\t\t * If link the tmpfile to alias through linkat path,\n\t\t * we should remove this inode from orphan list.\n\t\t */\n\t\tif (inode->i_nlink == 0)\n\t\t\tremove_orphan_inode(F2FS_I_SB(dir), inode->i_ino);\n\t\tinc_nlink(inode);\n\t}\n\treturn page;\n\nput_error:\n\tf2fs_put_page(page, 1);\nerror:\n\t/* once the failed inode becomes a bad inode, i_mode is S_IFREG */\n\ttruncate_inode_pages(&inode->i_data, 0);\n\ttruncate_blocks(inode, 0, false);\n\tremove_dirty_dir_inode(inode);\n\tremove_inode_page(inode);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&F2FS_I(inode)->i_sem"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_convert_inline_dir",
          "args": [
            "dir",
            "ipage",
            "dentry_blk"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_convert_inline_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inline.c",
          "lines": "331-380",
          "snippet": "static int f2fs_convert_inline_dir(struct inode *dir, struct page *ipage,\n\t\t\t\tstruct f2fs_inline_dentry *inline_dentry)\n{\n\tstruct page *page;\n\tstruct dnode_of_data dn;\n\tstruct f2fs_dentry_block *dentry_blk;\n\tint err;\n\n\tpage = grab_cache_page(dir->i_mapping, 0);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tset_new_dnode(&dn, dir, ipage, NULL, 0);\n\terr = f2fs_reserve_block(&dn, 0);\n\tif (err)\n\t\tgoto out;\n\n\tf2fs_wait_on_page_writeback(page, DATA);\n\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\n\tdentry_blk = kmap_atomic(page);\n\n\t/* copy data from inline dentry block to new dentry block */\n\tmemcpy(dentry_blk->dentry_bitmap, inline_dentry->dentry_bitmap,\n\t\t\t\t\tINLINE_DENTRY_BITMAP_SIZE);\n\tmemcpy(dentry_blk->dentry, inline_dentry->dentry,\n\t\t\tsizeof(struct f2fs_dir_entry) * NR_INLINE_DENTRY);\n\tmemcpy(dentry_blk->filename, inline_dentry->filename,\n\t\t\t\t\tNR_INLINE_DENTRY * F2FS_SLOT_LEN);\n\n\tkunmap_atomic(dentry_blk);\n\tSetPageUptodate(page);\n\tset_page_dirty(page);\n\n\t/* clear inline dir and flag after data writeback */\n\ttruncate_inline_data(ipage);\n\n\tstat_dec_inline_dir(dir);\n\tclear_inode_flag(F2FS_I(dir), FI_INLINE_DENTRY);\n\n\tif (i_size_read(dir) < PAGE_CACHE_SIZE) {\n\t\ti_size_write(dir, PAGE_CACHE_SIZE);\n\t\tset_inode_flag(F2FS_I(dir), FI_UPDATE_DIR);\n\t}\n\n\tsync_inode_page(&dn);\nout:\n\tf2fs_put_page(page, 1);\n\treturn err;\n}",
          "includes": [
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int f2fs_convert_inline_dir(struct inode *dir, struct page *ipage,\n\t\t\t\tstruct f2fs_inline_dentry *inline_dentry)\n{\n\tstruct page *page;\n\tstruct dnode_of_data dn;\n\tstruct f2fs_dentry_block *dentry_blk;\n\tint err;\n\n\tpage = grab_cache_page(dir->i_mapping, 0);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tset_new_dnode(&dn, dir, ipage, NULL, 0);\n\terr = f2fs_reserve_block(&dn, 0);\n\tif (err)\n\t\tgoto out;\n\n\tf2fs_wait_on_page_writeback(page, DATA);\n\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\n\tdentry_blk = kmap_atomic(page);\n\n\t/* copy data from inline dentry block to new dentry block */\n\tmemcpy(dentry_blk->dentry_bitmap, inline_dentry->dentry_bitmap,\n\t\t\t\t\tINLINE_DENTRY_BITMAP_SIZE);\n\tmemcpy(dentry_blk->dentry, inline_dentry->dentry,\n\t\t\tsizeof(struct f2fs_dir_entry) * NR_INLINE_DENTRY);\n\tmemcpy(dentry_blk->filename, inline_dentry->filename,\n\t\t\t\t\tNR_INLINE_DENTRY * F2FS_SLOT_LEN);\n\n\tkunmap_atomic(dentry_blk);\n\tSetPageUptodate(page);\n\tset_page_dirty(page);\n\n\t/* clear inline dir and flag after data writeback */\n\ttruncate_inline_data(ipage);\n\n\tstat_dec_inline_dir(dir);\n\tclear_inode_flag(F2FS_I(dir), FI_INLINE_DENTRY);\n\n\tif (i_size_read(dir) < PAGE_CACHE_SIZE) {\n\t\ti_size_write(dir, PAGE_CACHE_SIZE);\n\t\tset_inode_flag(F2FS_I(dir), FI_UPDATE_DIR);\n\t}\n\n\tsync_inode_page(&dn);\nout:\n\tf2fs_put_page(page, 1);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "room_for_filename",
          "args": [
            "&dentry_blk->dentry_bitmap",
            "slots",
            "NR_INLINE_DENTRY"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "room_for_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "457-475",
          "snippet": "int room_for_filename(const void *bitmap, int slots, int max_slots)\n{\n\tint bit_start = 0;\n\tint zero_start, zero_end;\nnext:\n\tzero_start = find_next_zero_bit_le(bitmap, max_slots, bit_start);\n\tif (zero_start >= max_slots)\n\t\treturn max_slots;\n\n\tzero_end = find_next_bit_le(bitmap, max_slots, zero_start);\n\tif (zero_end - zero_start >= slots)\n\t\treturn zero_start;\n\n\tbit_start = zero_end + 1;\n\n\tif (zero_end + 1 >= max_slots)\n\t\treturn max_slots;\n\tgoto next;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint room_for_filename(const void *bitmap, int slots, int max_slots)\n{\n\tint bit_start = 0;\n\tint zero_start, zero_end;\nnext:\n\tzero_start = find_next_zero_bit_le(bitmap, max_slots, bit_start);\n\tif (zero_start >= max_slots)\n\t\treturn max_slots;\n\n\tzero_end = find_next_bit_le(bitmap, max_slots, zero_start);\n\tif (zero_end - zero_start >= slots)\n\t\treturn zero_start;\n\n\tbit_start = zero_end + 1;\n\n\tif (zero_end + 1 >= max_slots)\n\t\treturn max_slots;\n\tgoto next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inline_data_addr",
          "args": [
            "ipage"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "inline_data_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1282-1286",
          "snippet": "static inline void *inline_data_addr(struct page *page)\n{\n\tstruct f2fs_inode *ri = F2FS_INODE(page);\n\treturn (void *)&(ri->i_addr[1]);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *inline_data_addr(struct page *page)\n{\n\tstruct f2fs_inode *ri = F2FS_INODE(page);\n\treturn (void *)&(ri->i_addr[1]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ipage"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ipage"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node_page",
          "args": [
            "sbi",
            "dir->i_ino"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_page_ra",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1066-1114",
          "snippet": "struct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_dentry_hash",
          "args": [
            "name"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_dentry_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/hash.c",
          "lines": "73-104",
          "snippet": "f2fs_hash_t f2fs_dentry_hash(const struct qstr *name_info)\n{\n\t__u32 hash;\n\tf2fs_hash_t f2fs_hash;\n\tconst unsigned char *p;\n\t__u32 in[8], buf[4];\n\tconst unsigned char *name = name_info->name;\n\tsize_t len = name_info->len;\n\n\tif ((len <= 2) && (name[0] == '.') &&\n\t\t(name[1] == '.' || name[1] == '\\0'))\n\t\treturn 0;\n\n\t/* Initialize the default seed for the hash checksum functions */\n\tbuf[0] = 0x67452301;\n\tbuf[1] = 0xefcdab89;\n\tbuf[2] = 0x98badcfe;\n\tbuf[3] = 0x10325476;\n\n\tp = name;\n\twhile (1) {\n\t\tstr2hashbuf(p, len, in, 4);\n\t\tTEA_transform(buf, in);\n\t\tp += 16;\n\t\tif (len <= 16)\n\t\t\tbreak;\n\t\tlen -= 16;\n\t}\n\thash = buf[0];\n\tf2fs_hash = cpu_to_le32(hash & ~F2FS_HASH_COL_BIT);\n\treturn f2fs_hash;\n}",
          "includes": [
            "#include \"f2fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/cryptohash.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"f2fs.h\"\n#include <linux/pagemap.h>\n#include <linux/cryptohash.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nf2fs_hash_t f2fs_dentry_hash(const struct qstr *name_info)\n{\n\t__u32 hash;\n\tf2fs_hash_t f2fs_hash;\n\tconst unsigned char *p;\n\t__u32 in[8], buf[4];\n\tconst unsigned char *name = name_info->name;\n\tsize_t len = name_info->len;\n\n\tif ((len <= 2) && (name[0] == '.') &&\n\t\t(name[1] == '.' || name[1] == '\\0'))\n\t\treturn 0;\n\n\t/* Initialize the default seed for the hash checksum functions */\n\tbuf[0] = 0x67452301;\n\tbuf[1] = 0xefcdab89;\n\tbuf[2] = 0x98badcfe;\n\tbuf[3] = 0x10325476;\n\n\tp = name;\n\twhile (1) {\n\t\tstr2hashbuf(p, len, in, 4);\n\t\tTEA_transform(buf, in);\n\t\tp += 16;\n\t\tif (len <= 16)\n\t\t\tbreak;\n\t\tlen -= 16;\n\t}\n\thash = buf[0];\n\tf2fs_hash = cpu_to_le32(hash & ~F2FS_HASH_COL_BIT);\n\treturn f2fs_hash;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_DENTRY_SLOTS",
          "args": [
            "namelen"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "dir"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_add_inline_entry(struct inode *dir, const struct qstr *name,\n\t\t\t\t\t\tstruct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tstruct page *ipage;\n\tunsigned int bit_pos;\n\tf2fs_hash_t name_hash;\n\tstruct f2fs_dir_entry *de;\n\tsize_t namelen = name->len;\n\tstruct f2fs_inline_dentry *dentry_blk = NULL;\n\tint slots = GET_DENTRY_SLOTS(namelen);\n\tstruct page *page;\n\tint err = 0;\n\tint i;\n\n\tname_hash = f2fs_dentry_hash(name);\n\n\tipage = get_node_page(sbi, dir->i_ino);\n\tif (IS_ERR(ipage))\n\t\treturn PTR_ERR(ipage);\n\n\tdentry_blk = inline_data_addr(ipage);\n\tbit_pos = room_for_filename(&dentry_blk->dentry_bitmap,\n\t\t\t\t\t\tslots, NR_INLINE_DENTRY);\n\tif (bit_pos >= NR_INLINE_DENTRY) {\n\t\terr = f2fs_convert_inline_dir(dir, ipage, dentry_blk);\n\t\tif (!err)\n\t\t\terr = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tdown_write(&F2FS_I(inode)->i_sem);\n\tpage = init_inode_metadata(inode, dir, name, ipage);\n\tif (IS_ERR(page)) {\n\t\terr = PTR_ERR(page);\n\t\tgoto fail;\n\t}\n\n\tf2fs_wait_on_page_writeback(ipage, NODE);\n\tde = &dentry_blk->dentry[bit_pos];\n\tde->hash_code = name_hash;\n\tde->name_len = cpu_to_le16(namelen);\n\tmemcpy(dentry_blk->filename[bit_pos], name->name, name->len);\n\tde->ino = cpu_to_le32(inode->i_ino);\n\tset_de_type(de, inode);\n\tfor (i = 0; i < slots; i++)\n\t\ttest_and_set_bit_le(bit_pos + i, &dentry_blk->dentry_bitmap);\n\tset_page_dirty(ipage);\n\n\t/* we don't need to mark_inode_dirty now */\n\tF2FS_I(inode)->i_pino = dir->i_ino;\n\tupdate_inode(inode, page);\n\tf2fs_put_page(page, 1);\n\n\tupdate_parent_metadata(dir, inode, 0);\nfail:\n\tup_write(&F2FS_I(inode)->i_sem);\n\n\tif (is_inode_flag_set(F2FS_I(dir), FI_UPDATE_DIR)) {\n\t\tupdate_inode(dir, ipage);\n\t\tclear_inode_flag(F2FS_I(dir), FI_UPDATE_DIR);\n\t}\nout:\n\tf2fs_put_page(ipage, 1);\n\treturn err;\n}"
  },
  {
    "function_name": "f2fs_convert_inline_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inline.c",
    "lines": "331-380",
    "snippet": "static int f2fs_convert_inline_dir(struct inode *dir, struct page *ipage,\n\t\t\t\tstruct f2fs_inline_dentry *inline_dentry)\n{\n\tstruct page *page;\n\tstruct dnode_of_data dn;\n\tstruct f2fs_dentry_block *dentry_blk;\n\tint err;\n\n\tpage = grab_cache_page(dir->i_mapping, 0);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tset_new_dnode(&dn, dir, ipage, NULL, 0);\n\terr = f2fs_reserve_block(&dn, 0);\n\tif (err)\n\t\tgoto out;\n\n\tf2fs_wait_on_page_writeback(page, DATA);\n\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\n\tdentry_blk = kmap_atomic(page);\n\n\t/* copy data from inline dentry block to new dentry block */\n\tmemcpy(dentry_blk->dentry_bitmap, inline_dentry->dentry_bitmap,\n\t\t\t\t\tINLINE_DENTRY_BITMAP_SIZE);\n\tmemcpy(dentry_blk->dentry, inline_dentry->dentry,\n\t\t\tsizeof(struct f2fs_dir_entry) * NR_INLINE_DENTRY);\n\tmemcpy(dentry_blk->filename, inline_dentry->filename,\n\t\t\t\t\tNR_INLINE_DENTRY * F2FS_SLOT_LEN);\n\n\tkunmap_atomic(dentry_blk);\n\tSetPageUptodate(page);\n\tset_page_dirty(page);\n\n\t/* clear inline dir and flag after data writeback */\n\ttruncate_inline_data(ipage);\n\n\tstat_dec_inline_dir(dir);\n\tclear_inode_flag(F2FS_I(dir), FI_INLINE_DENTRY);\n\n\tif (i_size_read(dir) < PAGE_CACHE_SIZE) {\n\t\ti_size_write(dir, PAGE_CACHE_SIZE);\n\t\tset_inode_flag(F2FS_I(dir), FI_UPDATE_DIR);\n\t}\n\n\tsync_inode_page(&dn);\nout:\n\tf2fs_put_page(page, 1);\n\treturn err;\n}",
    "includes": [
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "page",
            "1"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_inode_page",
          "args": [
            "&dn"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "sync_inode_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1116-1129",
          "snippet": "void sync_inode_page(struct dnode_of_data *dn)\n{\n\tif (IS_INODE(dn->node_page) || dn->inode_page == dn->node_page) {\n\t\tupdate_inode(dn->inode, dn->node_page);\n\t} else if (dn->inode_page) {\n\t\tif (!dn->inode_page_locked)\n\t\t\tlock_page(dn->inode_page);\n\t\tupdate_inode(dn->inode, dn->inode_page);\n\t\tif (!dn->inode_page_locked)\n\t\t\tunlock_page(dn->inode_page);\n\t} else {\n\t\tupdate_inode_page(dn->inode);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid sync_inode_page(struct dnode_of_data *dn)\n{\n\tif (IS_INODE(dn->node_page) || dn->inode_page == dn->node_page) {\n\t\tupdate_inode(dn->inode, dn->node_page);\n\t} else if (dn->inode_page) {\n\t\tif (!dn->inode_page_locked)\n\t\t\tlock_page(dn->inode_page);\n\t\tupdate_inode(dn->inode, dn->inode_page);\n\t\tif (!dn->inode_page_locked)\n\t\t\tunlock_page(dn->inode_page);\n\t} else {\n\t\tupdate_inode_page(dn->inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_inode_flag",
          "args": [
            "F2FS_I(dir)",
            "FI_UPDATE_DIR"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "set_inode_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1173-1177",
          "snippet": "static inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "dir"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "dir",
            "PAGE_CACHE_SIZE"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "dir"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_inode_flag",
          "args": [
            "F2FS_I(dir)",
            "FI_INLINE_DENTRY"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1184-1188",
          "snippet": "static inline void clear_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (test_bit(flag, &fi->flags))\n\t\tclear_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void clear_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (test_bit(flag, &fi->flags))\n\t\tclear_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat_dec_inline_dir",
          "args": [
            "dir"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truncate_inline_data",
          "args": [
            "ipage"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inline.c",
          "lines": "53-57",
          "snippet": "static void truncate_inline_data(struct page *ipage)\n{\n\tf2fs_wait_on_page_writeback(ipage, NODE);\n\tmemset(inline_data_addr(ipage), 0, MAX_INLINE_DATA);\n}",
          "includes": [
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void truncate_inline_data(struct page *ipage)\n{\n\tf2fs_wait_on_page_writeback(ipage, NODE);\n\tmemset(inline_data_addr(ipage), 0, MAX_INLINE_DATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "dentry_blk"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dentry_blk->filename",
            "inline_dentry->filename",
            "NR_INLINE_DENTRY * F2FS_SLOT_LEN"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dentry_blk->dentry",
            "inline_dentry->dentry",
            "sizeof(struct f2fs_dir_entry) * NR_INLINE_DENTRY"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dentry_blk->dentry_bitmap",
            "inline_dentry->dentry_bitmap",
            "INLINE_DENTRY_BITMAP_SIZE"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "page",
            "0",
            "PAGE_CACHE_SIZE"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_wait_on_page_writeback",
          "args": [
            "page",
            "DATA"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_wait_on_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1321-1331",
          "snippet": "void f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_reserve_block",
          "args": [
            "&dn",
            "0"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_reserve_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "235-249",
          "snippet": "int f2fs_reserve_block(struct dnode_of_data *dn, pgoff_t index)\n{\n\tbool need_put = dn->inode_page ? false : true;\n\tint err;\n\n\terr = get_dnode_of_data(dn, index, ALLOC_NODE);\n\tif (err)\n\t\treturn err;\n\n\tif (dn->data_blkaddr == NULL_ADDR)\n\t\terr = reserve_new_block(dn);\n\tif (err || need_put)\n\t\tf2fs_put_dnode(dn);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_reserve_block(struct dnode_of_data *dn, pgoff_t index)\n{\n\tbool need_put = dn->inode_page ? false : true;\n\tint err;\n\n\terr = get_dnode_of_data(dn, index, ALLOC_NODE);\n\tif (err)\n\t\treturn err;\n\n\tif (dn->data_blkaddr == NULL_ADDR)\n\t\terr = reserve_new_block(dn);\n\tif (err || need_put)\n\t\tf2fs_put_dnode(dn);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_new_dnode",
          "args": [
            "&dn",
            "dir",
            "ipage",
            "NULL",
            "0"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "set_new_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "381-389",
          "snippet": "static inline void set_new_dnode(struct dnode_of_data *dn, struct inode *inode,\n\t\tstruct page *ipage, struct page *npage, nid_t nid)\n{\n\tmemset(dn, 0, sizeof(*dn));\n\tdn->inode = inode;\n\tdn->inode_page = ipage;\n\tdn->node_page = npage;\n\tdn->nid = nid;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_new_dnode(struct dnode_of_data *dn, struct inode *inode,\n\t\tstruct page *ipage, struct page *npage, nid_t nid)\n{\n\tmemset(dn, 0, sizeof(*dn));\n\tdn->inode = inode;\n\tdn->inode_page = ipage;\n\tdn->node_page = npage;\n\tdn->nid = nid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "grab_cache_page",
          "args": [
            "dir->i_mapping",
            "0"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int f2fs_convert_inline_dir(struct inode *dir, struct page *ipage,\n\t\t\t\tstruct f2fs_inline_dentry *inline_dentry)\n{\n\tstruct page *page;\n\tstruct dnode_of_data dn;\n\tstruct f2fs_dentry_block *dentry_blk;\n\tint err;\n\n\tpage = grab_cache_page(dir->i_mapping, 0);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tset_new_dnode(&dn, dir, ipage, NULL, 0);\n\terr = f2fs_reserve_block(&dn, 0);\n\tif (err)\n\t\tgoto out;\n\n\tf2fs_wait_on_page_writeback(page, DATA);\n\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\n\tdentry_blk = kmap_atomic(page);\n\n\t/* copy data from inline dentry block to new dentry block */\n\tmemcpy(dentry_blk->dentry_bitmap, inline_dentry->dentry_bitmap,\n\t\t\t\t\tINLINE_DENTRY_BITMAP_SIZE);\n\tmemcpy(dentry_blk->dentry, inline_dentry->dentry,\n\t\t\tsizeof(struct f2fs_dir_entry) * NR_INLINE_DENTRY);\n\tmemcpy(dentry_blk->filename, inline_dentry->filename,\n\t\t\t\t\tNR_INLINE_DENTRY * F2FS_SLOT_LEN);\n\n\tkunmap_atomic(dentry_blk);\n\tSetPageUptodate(page);\n\tset_page_dirty(page);\n\n\t/* clear inline dir and flag after data writeback */\n\ttruncate_inline_data(ipage);\n\n\tstat_dec_inline_dir(dir);\n\tclear_inode_flag(F2FS_I(dir), FI_INLINE_DENTRY);\n\n\tif (i_size_read(dir) < PAGE_CACHE_SIZE) {\n\t\ti_size_write(dir, PAGE_CACHE_SIZE);\n\t\tset_inode_flag(F2FS_I(dir), FI_UPDATE_DIR);\n\t}\n\n\tsync_inode_page(&dn);\nout:\n\tf2fs_put_page(page, 1);\n\treturn err;\n}"
  },
  {
    "function_name": "make_empty_inline_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inline.c",
    "lines": "310-329",
    "snippet": "int make_empty_inline_dir(struct inode *inode, struct inode *parent,\n\t\t\t\t\t\t\tstruct page *ipage)\n{\n\tstruct f2fs_inline_dentry *dentry_blk;\n\tstruct f2fs_dentry_ptr d;\n\n\tdentry_blk = inline_data_addr(ipage);\n\n\tmake_dentry_ptr(&d, (void *)dentry_blk, 2);\n\tdo_make_empty_dir(inode, parent, &d);\n\n\tset_page_dirty(ipage);\n\n\t/* update i_size to MAX_INLINE_DATA */\n\tif (i_size_read(inode) < MAX_INLINE_DATA) {\n\t\ti_size_write(inode, MAX_INLINE_DATA);\n\t\tset_inode_flag(F2FS_I(inode), FI_UPDATE_DIR);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_inode_flag",
          "args": [
            "F2FS_I(inode)",
            "FI_UPDATE_DIR"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "set_inode_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1173-1177",
          "snippet": "static inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "MAX_INLINE_DATA"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "ipage"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_make_empty_dir",
          "args": [
            "inode",
            "parent",
            "&d"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "do_make_empty_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "324-345",
          "snippet": "void do_make_empty_dir(struct inode *inode, struct inode *parent,\n\t\t\t\t\tstruct f2fs_dentry_ptr *d)\n{\n\tstruct f2fs_dir_entry *de;\n\n\tde = &d->dentry[0];\n\tde->name_len = cpu_to_le16(1);\n\tde->hash_code = 0;\n\tde->ino = cpu_to_le32(inode->i_ino);\n\tmemcpy(d->filename[0], \".\", 1);\n\tset_de_type(de, inode);\n\n\tde = &d->dentry[1];\n\tde->hash_code = 0;\n\tde->name_len = cpu_to_le16(2);\n\tde->ino = cpu_to_le32(parent->i_ino);\n\tmemcpy(d->filename[1], \"..\", 2);\n\tset_de_type(de, inode);\n\n\ttest_and_set_bit_le(0, (void *)d->bitmap);\n\ttest_and_set_bit_le(1, (void *)d->bitmap);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid do_make_empty_dir(struct inode *inode, struct inode *parent,\n\t\t\t\t\tstruct f2fs_dentry_ptr *d)\n{\n\tstruct f2fs_dir_entry *de;\n\n\tde = &d->dentry[0];\n\tde->name_len = cpu_to_le16(1);\n\tde->hash_code = 0;\n\tde->ino = cpu_to_le32(inode->i_ino);\n\tmemcpy(d->filename[0], \".\", 1);\n\tset_de_type(de, inode);\n\n\tde = &d->dentry[1];\n\tde->hash_code = 0;\n\tde->name_len = cpu_to_le16(2);\n\tde->ino = cpu_to_le32(parent->i_ino);\n\tmemcpy(d->filename[1], \"..\", 2);\n\tset_de_type(de, inode);\n\n\ttest_and_set_bit_le(0, (void *)d->bitmap);\n\ttest_and_set_bit_le(1, (void *)d->bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_dentry_ptr",
          "args": [
            "&d",
            "(void *)dentry_blk",
            "2"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "make_dentry_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "238-254",
          "snippet": "static inline void make_dentry_ptr(struct f2fs_dentry_ptr *d,\n\t\t\t\t\tvoid *src, int type)\n{\n\tif (type == 1) {\n\t\tstruct f2fs_dentry_block *t = (struct f2fs_dentry_block *)src;\n\t\td->max = NR_DENTRY_IN_BLOCK;\n\t\td->bitmap = &t->dentry_bitmap;\n\t\td->dentry = t->dentry;\n\t\td->filename = t->filename;\n\t} else {\n\t\tstruct f2fs_inline_dentry *t = (struct f2fs_inline_dentry *)src;\n\t\td->max = NR_INLINE_DENTRY;\n\t\td->bitmap = &t->dentry_bitmap;\n\t\td->dentry = t->dentry;\n\t\td->filename = t->filename;\n\t}\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void make_dentry_ptr(struct f2fs_dentry_ptr *d,\n\t\t\t\t\tvoid *src, int type)\n{\n\tif (type == 1) {\n\t\tstruct f2fs_dentry_block *t = (struct f2fs_dentry_block *)src;\n\t\td->max = NR_DENTRY_IN_BLOCK;\n\t\td->bitmap = &t->dentry_bitmap;\n\t\td->dentry = t->dentry;\n\t\td->filename = t->filename;\n\t} else {\n\t\tstruct f2fs_inline_dentry *t = (struct f2fs_inline_dentry *)src;\n\t\td->max = NR_INLINE_DENTRY;\n\t\td->bitmap = &t->dentry_bitmap;\n\t\td->dentry = t->dentry;\n\t\td->filename = t->filename;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inline_data_addr",
          "args": [
            "ipage"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "inline_data_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1282-1286",
          "snippet": "static inline void *inline_data_addr(struct page *page)\n{\n\tstruct f2fs_inode *ri = F2FS_INODE(page);\n\treturn (void *)&(ri->i_addr[1]);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *inline_data_addr(struct page *page)\n{\n\tstruct f2fs_inode *ri = F2FS_INODE(page);\n\treturn (void *)&(ri->i_addr[1]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint make_empty_inline_dir(struct inode *inode, struct inode *parent,\n\t\t\t\t\t\t\tstruct page *ipage)\n{\n\tstruct f2fs_inline_dentry *dentry_blk;\n\tstruct f2fs_dentry_ptr d;\n\n\tdentry_blk = inline_data_addr(ipage);\n\n\tmake_dentry_ptr(&d, (void *)dentry_blk, 2);\n\tdo_make_empty_dir(inode, parent, &d);\n\n\tset_page_dirty(ipage);\n\n\t/* update i_size to MAX_INLINE_DATA */\n\tif (i_size_read(inode) < MAX_INLINE_DATA) {\n\t\ti_size_write(inode, MAX_INLINE_DATA);\n\t\tset_inode_flag(F2FS_I(inode), FI_UPDATE_DIR);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "f2fs_parent_inline_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inline.c",
    "lines": "291-308",
    "snippet": "struct f2fs_dir_entry *f2fs_parent_inline_dir(struct inode *dir,\n\t\t\t\t\t\t\tstruct page **p)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tstruct page *ipage;\n\tstruct f2fs_dir_entry *de;\n\tstruct f2fs_inline_dentry *dentry_blk;\n\n\tipage = get_node_page(sbi, dir->i_ino);\n\tif (IS_ERR(ipage))\n\t\treturn NULL;\n\n\tdentry_blk = inline_data_addr(ipage);\n\tde = &dentry_blk->dentry[1];\n\t*p = ipage;\n\tunlock_page(ipage);\n\treturn de;\n}",
    "includes": [
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "ipage"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inline_data_addr",
          "args": [
            "ipage"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "inline_data_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1282-1286",
          "snippet": "static inline void *inline_data_addr(struct page *page)\n{\n\tstruct f2fs_inode *ri = F2FS_INODE(page);\n\treturn (void *)&(ri->i_addr[1]);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *inline_data_addr(struct page *page)\n{\n\tstruct f2fs_inode *ri = F2FS_INODE(page);\n\treturn (void *)&(ri->i_addr[1]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ipage"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node_page",
          "args": [
            "sbi",
            "dir->i_ino"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_page_ra",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1066-1114",
          "snippet": "struct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "dir"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct f2fs_dir_entry *f2fs_parent_inline_dir(struct inode *dir,\n\t\t\t\t\t\t\tstruct page **p)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tstruct page *ipage;\n\tstruct f2fs_dir_entry *de;\n\tstruct f2fs_inline_dentry *dentry_blk;\n\n\tipage = get_node_page(sbi, dir->i_ino);\n\tif (IS_ERR(ipage))\n\t\treturn NULL;\n\n\tdentry_blk = inline_data_addr(ipage);\n\tde = &dentry_blk->dentry[1];\n\t*p = ipage;\n\tunlock_page(ipage);\n\treturn de;\n}"
  },
  {
    "function_name": "find_in_inline_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inline.c",
    "lines": "259-289",
    "snippet": "struct f2fs_dir_entry *find_in_inline_dir(struct inode *dir,\n\t\t\t\tstruct qstr *name, struct page **res_page)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(dir->i_sb);\n\tstruct f2fs_inline_dentry *inline_dentry;\n\tstruct f2fs_dir_entry *de;\n\tstruct f2fs_dentry_ptr d;\n\tstruct page *ipage;\n\n\tipage = get_node_page(sbi, dir->i_ino);\n\tif (IS_ERR(ipage))\n\t\treturn NULL;\n\n\tinline_dentry = inline_data_addr(ipage);\n\n\tmake_dentry_ptr(&d, (void *)inline_dentry, 2);\n\tde = find_target_dentry(name, NULL, &d);\n\n\tunlock_page(ipage);\n\tif (de)\n\t\t*res_page = ipage;\n\telse\n\t\tf2fs_put_page(ipage, 0);\n\n\t/*\n\t * For the most part, it should be a bug when name_len is zero.\n\t * We stop here for figuring out where the bugs has occurred.\n\t */\n\tf2fs_bug_on(sbi, d.max < 0);\n\treturn de;\n}",
    "includes": [
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "d.max < 0"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "ipage",
            "0"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "ipage"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_target_dentry",
          "args": [
            "name",
            "NULL",
            "&d"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "find_target_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "118-159",
          "snippet": "struct f2fs_dir_entry *find_target_dentry(struct qstr *name, int *max_slots,\n\t\t\t\t\t\tstruct f2fs_dentry_ptr *d)\n{\n\tstruct f2fs_dir_entry *de;\n\tunsigned long bit_pos = 0;\n\tf2fs_hash_t namehash = f2fs_dentry_hash(name);\n\tint max_len = 0;\n\n\tif (max_slots)\n\t\t*max_slots = 0;\n\twhile (bit_pos < d->max) {\n\t\tif (!test_bit_le(bit_pos, d->bitmap)) {\n\t\t\tif (bit_pos == 0)\n\t\t\t\tmax_len = 1;\n\t\t\telse if (!test_bit_le(bit_pos - 1, d->bitmap))\n\t\t\t\tmax_len++;\n\t\t\tbit_pos++;\n\t\t\tcontinue;\n\t\t}\n\t\tde = &d->dentry[bit_pos];\n\t\tif (early_match_name(name->len, namehash, de) &&\n\t\t\t!memcmp(d->filename[bit_pos], name->name, name->len))\n\t\t\tgoto found;\n\n\t\tif (max_slots && *max_slots >= 0 && max_len > *max_slots) {\n\t\t\t*max_slots = max_len;\n\t\t\tmax_len = 0;\n\t\t}\n\n\t\t/* remain bug on condition */\n\t\tif (unlikely(!de->name_len))\n\t\t\td->max = -1;\n\n\t\tbit_pos += GET_DENTRY_SLOTS(le16_to_cpu(de->name_len));\n\t}\n\n\tde = NULL;\nfound:\n\tif (max_slots && max_len > *max_slots)\n\t\t*max_slots = max_len;\n\treturn de;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct f2fs_dir_entry *find_target_dentry(struct qstr *name, int *max_slots,\n\t\t\t\t\t\tstruct f2fs_dentry_ptr *d)\n{\n\tstruct f2fs_dir_entry *de;\n\tunsigned long bit_pos = 0;\n\tf2fs_hash_t namehash = f2fs_dentry_hash(name);\n\tint max_len = 0;\n\n\tif (max_slots)\n\t\t*max_slots = 0;\n\twhile (bit_pos < d->max) {\n\t\tif (!test_bit_le(bit_pos, d->bitmap)) {\n\t\t\tif (bit_pos == 0)\n\t\t\t\tmax_len = 1;\n\t\t\telse if (!test_bit_le(bit_pos - 1, d->bitmap))\n\t\t\t\tmax_len++;\n\t\t\tbit_pos++;\n\t\t\tcontinue;\n\t\t}\n\t\tde = &d->dentry[bit_pos];\n\t\tif (early_match_name(name->len, namehash, de) &&\n\t\t\t!memcmp(d->filename[bit_pos], name->name, name->len))\n\t\t\tgoto found;\n\n\t\tif (max_slots && *max_slots >= 0 && max_len > *max_slots) {\n\t\t\t*max_slots = max_len;\n\t\t\tmax_len = 0;\n\t\t}\n\n\t\t/* remain bug on condition */\n\t\tif (unlikely(!de->name_len))\n\t\t\td->max = -1;\n\n\t\tbit_pos += GET_DENTRY_SLOTS(le16_to_cpu(de->name_len));\n\t}\n\n\tde = NULL;\nfound:\n\tif (max_slots && max_len > *max_slots)\n\t\t*max_slots = max_len;\n\treturn de;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_dentry_ptr",
          "args": [
            "&d",
            "(void *)inline_dentry",
            "2"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "make_dentry_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "238-254",
          "snippet": "static inline void make_dentry_ptr(struct f2fs_dentry_ptr *d,\n\t\t\t\t\tvoid *src, int type)\n{\n\tif (type == 1) {\n\t\tstruct f2fs_dentry_block *t = (struct f2fs_dentry_block *)src;\n\t\td->max = NR_DENTRY_IN_BLOCK;\n\t\td->bitmap = &t->dentry_bitmap;\n\t\td->dentry = t->dentry;\n\t\td->filename = t->filename;\n\t} else {\n\t\tstruct f2fs_inline_dentry *t = (struct f2fs_inline_dentry *)src;\n\t\td->max = NR_INLINE_DENTRY;\n\t\td->bitmap = &t->dentry_bitmap;\n\t\td->dentry = t->dentry;\n\t\td->filename = t->filename;\n\t}\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void make_dentry_ptr(struct f2fs_dentry_ptr *d,\n\t\t\t\t\tvoid *src, int type)\n{\n\tif (type == 1) {\n\t\tstruct f2fs_dentry_block *t = (struct f2fs_dentry_block *)src;\n\t\td->max = NR_DENTRY_IN_BLOCK;\n\t\td->bitmap = &t->dentry_bitmap;\n\t\td->dentry = t->dentry;\n\t\td->filename = t->filename;\n\t} else {\n\t\tstruct f2fs_inline_dentry *t = (struct f2fs_inline_dentry *)src;\n\t\td->max = NR_INLINE_DENTRY;\n\t\td->bitmap = &t->dentry_bitmap;\n\t\td->dentry = t->dentry;\n\t\td->filename = t->filename;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inline_data_addr",
          "args": [
            "ipage"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "inline_data_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1282-1286",
          "snippet": "static inline void *inline_data_addr(struct page *page)\n{\n\tstruct f2fs_inode *ri = F2FS_INODE(page);\n\treturn (void *)&(ri->i_addr[1]);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *inline_data_addr(struct page *page)\n{\n\tstruct f2fs_inode *ri = F2FS_INODE(page);\n\treturn (void *)&(ri->i_addr[1]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ipage"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node_page",
          "args": [
            "sbi",
            "dir->i_ino"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_page_ra",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1066-1114",
          "snippet": "struct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "640-643",
          "snippet": "static inline struct f2fs_sb_info *F2FS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct f2fs_dir_entry *find_in_inline_dir(struct inode *dir,\n\t\t\t\tstruct qstr *name, struct page **res_page)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(dir->i_sb);\n\tstruct f2fs_inline_dentry *inline_dentry;\n\tstruct f2fs_dir_entry *de;\n\tstruct f2fs_dentry_ptr d;\n\tstruct page *ipage;\n\n\tipage = get_node_page(sbi, dir->i_ino);\n\tif (IS_ERR(ipage))\n\t\treturn NULL;\n\n\tinline_dentry = inline_data_addr(ipage);\n\n\tmake_dentry_ptr(&d, (void *)inline_dentry, 2);\n\tde = find_target_dentry(name, NULL, &d);\n\n\tunlock_page(ipage);\n\tif (de)\n\t\t*res_page = ipage;\n\telse\n\t\tf2fs_put_page(ipage, 0);\n\n\t/*\n\t * For the most part, it should be a bug when name_len is zero.\n\t * We stop here for figuring out where the bugs has occurred.\n\t */\n\tf2fs_bug_on(sbi, d.max < 0);\n\treturn de;\n}"
  },
  {
    "function_name": "recover_inline_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inline.c",
    "lines": "207-257",
    "snippet": "bool recover_inline_data(struct inode *inode, struct page *npage)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_inode *ri = NULL;\n\tvoid *src_addr, *dst_addr;\n\tstruct page *ipage;\n\n\t/*\n\t * The inline_data recovery policy is as follows.\n\t * [prev.] [next] of inline_data flag\n\t *    o       o  -> recover inline_data\n\t *    o       x  -> remove inline_data, and then recover data blocks\n\t *    x       o  -> remove inline_data, and then recover inline_data\n\t *    x       x  -> recover data blocks\n\t */\n\tif (IS_INODE(npage))\n\t\tri = F2FS_INODE(npage);\n\n\tif (f2fs_has_inline_data(inode) &&\n\t\t\tri && (ri->i_inline & F2FS_INLINE_DATA)) {\nprocess_inline:\n\t\tipage = get_node_page(sbi, inode->i_ino);\n\t\tf2fs_bug_on(sbi, IS_ERR(ipage));\n\n\t\tf2fs_wait_on_page_writeback(ipage, NODE);\n\n\t\tsrc_addr = inline_data_addr(npage);\n\t\tdst_addr = inline_data_addr(ipage);\n\t\tmemcpy(dst_addr, src_addr, MAX_INLINE_DATA);\n\n\t\tset_inode_flag(F2FS_I(inode), FI_INLINE_DATA);\n\t\tset_inode_flag(F2FS_I(inode), FI_DATA_EXIST);\n\n\t\tupdate_inode(inode, ipage);\n\t\tf2fs_put_page(ipage, 1);\n\t\treturn true;\n\t}\n\n\tif (f2fs_has_inline_data(inode)) {\n\t\tipage = get_node_page(sbi, inode->i_ino);\n\t\tf2fs_bug_on(sbi, IS_ERR(ipage));\n\t\ttruncate_inline_data(ipage);\n\t\tf2fs_clear_inline_inode(inode);\n\t\tupdate_inode(inode, ipage);\n\t\tf2fs_put_page(ipage, 1);\n\t} else if (ri && (ri->i_inline & F2FS_INLINE_DATA)) {\n\t\ttruncate_blocks(inode, 0, false);\n\t\tgoto process_inline;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "truncate_blocks",
          "args": [
            "inode",
            "0",
            "false"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
          "lines": "482-540",
          "snippet": "int truncate_blocks(struct inode *inode, u64 from, bool lock)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tunsigned int blocksize = inode->i_sb->s_blocksize;\n\tstruct dnode_of_data dn;\n\tpgoff_t free_from;\n\tint count = 0, err = 0;\n\tstruct page *ipage;\n\n\ttrace_f2fs_truncate_blocks_enter(inode, from);\n\n\tfree_from = (pgoff_t)F2FS_BYTES_TO_BLK(from + blocksize - 1);\n\n\tif (lock)\n\t\tf2fs_lock_op(sbi);\n\n\tipage = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(ipage)) {\n\t\terr = PTR_ERR(ipage);\n\t\tgoto out;\n\t}\n\n\tif (f2fs_has_inline_data(inode)) {\n\t\tf2fs_put_page(ipage, 1);\n\t\tgoto out;\n\t}\n\n\tset_new_dnode(&dn, inode, ipage, NULL, 0);\n\terr = get_dnode_of_data(&dn, free_from, LOOKUP_NODE);\n\tif (err) {\n\t\tif (err == -ENOENT)\n\t\t\tgoto free_next;\n\t\tgoto out;\n\t}\n\n\tcount = ADDRS_PER_PAGE(dn.node_page, F2FS_I(inode));\n\n\tcount -= dn.ofs_in_node;\n\tf2fs_bug_on(sbi, count < 0);\n\n\tif (dn.ofs_in_node || IS_INODE(dn.node_page)) {\n\t\ttruncate_data_blocks_range(&dn, count);\n\t\tfree_from += count;\n\t}\n\n\tf2fs_put_dnode(&dn);\nfree_next:\n\terr = truncate_inode_blocks(inode, free_from);\nout:\n\tif (lock)\n\t\tf2fs_unlock_op(sbi);\n\n\t/* lastly zero out the first data page */\n\tif (!err)\n\t\terr = truncate_partial_data_page(inode, from);\n\n\ttrace_f2fs_truncate_blocks_exit(inode, err);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/types.h>",
            "#include <linux/falloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint truncate_blocks(struct inode *inode, u64 from, bool lock)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tunsigned int blocksize = inode->i_sb->s_blocksize;\n\tstruct dnode_of_data dn;\n\tpgoff_t free_from;\n\tint count = 0, err = 0;\n\tstruct page *ipage;\n\n\ttrace_f2fs_truncate_blocks_enter(inode, from);\n\n\tfree_from = (pgoff_t)F2FS_BYTES_TO_BLK(from + blocksize - 1);\n\n\tif (lock)\n\t\tf2fs_lock_op(sbi);\n\n\tipage = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(ipage)) {\n\t\terr = PTR_ERR(ipage);\n\t\tgoto out;\n\t}\n\n\tif (f2fs_has_inline_data(inode)) {\n\t\tf2fs_put_page(ipage, 1);\n\t\tgoto out;\n\t}\n\n\tset_new_dnode(&dn, inode, ipage, NULL, 0);\n\terr = get_dnode_of_data(&dn, free_from, LOOKUP_NODE);\n\tif (err) {\n\t\tif (err == -ENOENT)\n\t\t\tgoto free_next;\n\t\tgoto out;\n\t}\n\n\tcount = ADDRS_PER_PAGE(dn.node_page, F2FS_I(inode));\n\n\tcount -= dn.ofs_in_node;\n\tf2fs_bug_on(sbi, count < 0);\n\n\tif (dn.ofs_in_node || IS_INODE(dn.node_page)) {\n\t\ttruncate_data_blocks_range(&dn, count);\n\t\tfree_from += count;\n\t}\n\n\tf2fs_put_dnode(&dn);\nfree_next:\n\terr = truncate_inode_blocks(inode, free_from);\nout:\n\tif (lock)\n\t\tf2fs_unlock_op(sbi);\n\n\t/* lastly zero out the first data page */\n\tif (!err)\n\t\terr = truncate_partial_data_page(inode, from);\n\n\ttrace_f2fs_truncate_blocks_exit(inode, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "ipage",
            "1"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_inode",
          "args": [
            "inode",
            "ipage"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "update_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
          "lines": "208-244",
          "snippet": "void update_inode(struct inode *inode, struct page *node_page)\n{\n\tstruct f2fs_inode *ri;\n\n\tf2fs_wait_on_page_writeback(node_page, NODE);\n\n\tri = F2FS_INODE(node_page);\n\n\tri->i_mode = cpu_to_le16(inode->i_mode);\n\tri->i_advise = F2FS_I(inode)->i_advise;\n\tri->i_uid = cpu_to_le32(i_uid_read(inode));\n\tri->i_gid = cpu_to_le32(i_gid_read(inode));\n\tri->i_links = cpu_to_le32(inode->i_nlink);\n\tri->i_size = cpu_to_le64(i_size_read(inode));\n\tri->i_blocks = cpu_to_le64(inode->i_blocks);\n\tset_raw_extent(&F2FS_I(inode)->ext, &ri->i_ext);\n\tset_raw_inline(F2FS_I(inode), ri);\n\n\tri->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tri->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tri->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tri->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tri->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tri->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\tri->i_current_depth = cpu_to_le32(F2FS_I(inode)->i_current_depth);\n\tri->i_xattr_nid = cpu_to_le32(F2FS_I(inode)->i_xattr_nid);\n\tri->i_flags = cpu_to_le32(F2FS_I(inode)->i_flags);\n\tri->i_pino = cpu_to_le32(F2FS_I(inode)->i_pino);\n\tri->i_generation = cpu_to_le32(inode->i_generation);\n\tri->i_dir_level = F2FS_I(inode)->i_dir_level;\n\n\t__set_inode_rdev(inode, ri);\n\tset_cold_node(inode, node_page);\n\tset_page_dirty(node_page);\n\n\tclear_inode_flag(F2FS_I(inode), FI_DIRTY_INODE);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid update_inode(struct inode *inode, struct page *node_page)\n{\n\tstruct f2fs_inode *ri;\n\n\tf2fs_wait_on_page_writeback(node_page, NODE);\n\n\tri = F2FS_INODE(node_page);\n\n\tri->i_mode = cpu_to_le16(inode->i_mode);\n\tri->i_advise = F2FS_I(inode)->i_advise;\n\tri->i_uid = cpu_to_le32(i_uid_read(inode));\n\tri->i_gid = cpu_to_le32(i_gid_read(inode));\n\tri->i_links = cpu_to_le32(inode->i_nlink);\n\tri->i_size = cpu_to_le64(i_size_read(inode));\n\tri->i_blocks = cpu_to_le64(inode->i_blocks);\n\tset_raw_extent(&F2FS_I(inode)->ext, &ri->i_ext);\n\tset_raw_inline(F2FS_I(inode), ri);\n\n\tri->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tri->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tri->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tri->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tri->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tri->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\tri->i_current_depth = cpu_to_le32(F2FS_I(inode)->i_current_depth);\n\tri->i_xattr_nid = cpu_to_le32(F2FS_I(inode)->i_xattr_nid);\n\tri->i_flags = cpu_to_le32(F2FS_I(inode)->i_flags);\n\tri->i_pino = cpu_to_le32(F2FS_I(inode)->i_pino);\n\tri->i_generation = cpu_to_le32(inode->i_generation);\n\tri->i_dir_level = F2FS_I(inode)->i_dir_level;\n\n\t__set_inode_rdev(inode, ri);\n\tset_cold_node(inode, node_page);\n\tset_page_dirty(node_page);\n\n\tclear_inode_flag(F2FS_I(inode), FI_DIRTY_INODE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_clear_inline_inode",
          "args": [
            "inode"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_clear_inline_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1256-1260",
          "snippet": "static inline void f2fs_clear_inline_inode(struct inode *inode)\n{\n\tclear_inode_flag(F2FS_I(inode), FI_INLINE_DATA);\n\tclear_inode_flag(F2FS_I(inode), FI_DATA_EXIST);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_clear_inline_inode(struct inode *inode)\n{\n\tclear_inode_flag(F2FS_I(inode), FI_INLINE_DATA);\n\tclear_inode_flag(F2FS_I(inode), FI_DATA_EXIST);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inline_data",
          "args": [
            "ipage"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inline.c",
          "lines": "53-57",
          "snippet": "static void truncate_inline_data(struct page *ipage)\n{\n\tf2fs_wait_on_page_writeback(ipage, NODE);\n\tmemset(inline_data_addr(ipage), 0, MAX_INLINE_DATA);\n}",
          "includes": [
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void truncate_inline_data(struct page *ipage)\n{\n\tf2fs_wait_on_page_writeback(ipage, NODE);\n\tmemset(inline_data_addr(ipage), 0, MAX_INLINE_DATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "IS_ERR(ipage)"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ipage"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node_page",
          "args": [
            "sbi",
            "inode->i_ino"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_page_ra",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1066-1114",
          "snippet": "struct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1251-1254",
          "snippet": "static inline int f2fs_has_inline_data(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DATA);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_has_inline_data(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_inode_flag",
          "args": [
            "F2FS_I(inode)",
            "FI_DATA_EXIST"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "set_inode_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1173-1177",
          "snippet": "static inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst_addr",
            "src_addr",
            "MAX_INLINE_DATA"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inline_data_addr",
          "args": [
            "ipage"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "inline_data_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1282-1286",
          "snippet": "static inline void *inline_data_addr(struct page *page)\n{\n\tstruct f2fs_inode *ri = F2FS_INODE(page);\n\treturn (void *)&(ri->i_addr[1]);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *inline_data_addr(struct page *page)\n{\n\tstruct f2fs_inode *ri = F2FS_INODE(page);\n\treturn (void *)&(ri->i_addr[1]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_wait_on_page_writeback",
          "args": [
            "ipage",
            "NODE"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_wait_on_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1321-1331",
          "snippet": "void f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "sbi",
            "IS_ERR(ipage)"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ipage"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_INODE",
          "args": [
            "npage"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "IS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1087-1091",
          "snippet": "static inline bool IS_INODE(struct page *page)\n{\n\tstruct f2fs_node *p = F2FS_NODE(page);\n\treturn RAW_IS_INODE(p);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool IS_INODE(struct page *page)\n{\n\tstruct f2fs_node *p = F2FS_NODE(page);\n\treturn RAW_IS_INODE(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "inode"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nbool recover_inline_data(struct inode *inode, struct page *npage)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_inode *ri = NULL;\n\tvoid *src_addr, *dst_addr;\n\tstruct page *ipage;\n\n\t/*\n\t * The inline_data recovery policy is as follows.\n\t * [prev.] [next] of inline_data flag\n\t *    o       o  -> recover inline_data\n\t *    o       x  -> remove inline_data, and then recover data blocks\n\t *    x       o  -> remove inline_data, and then recover inline_data\n\t *    x       x  -> recover data blocks\n\t */\n\tif (IS_INODE(npage))\n\t\tri = F2FS_INODE(npage);\n\n\tif (f2fs_has_inline_data(inode) &&\n\t\t\tri && (ri->i_inline & F2FS_INLINE_DATA)) {\nprocess_inline:\n\t\tipage = get_node_page(sbi, inode->i_ino);\n\t\tf2fs_bug_on(sbi, IS_ERR(ipage));\n\n\t\tf2fs_wait_on_page_writeback(ipage, NODE);\n\n\t\tsrc_addr = inline_data_addr(npage);\n\t\tdst_addr = inline_data_addr(ipage);\n\t\tmemcpy(dst_addr, src_addr, MAX_INLINE_DATA);\n\n\t\tset_inode_flag(F2FS_I(inode), FI_INLINE_DATA);\n\t\tset_inode_flag(F2FS_I(inode), FI_DATA_EXIST);\n\n\t\tupdate_inode(inode, ipage);\n\t\tf2fs_put_page(ipage, 1);\n\t\treturn true;\n\t}\n\n\tif (f2fs_has_inline_data(inode)) {\n\t\tipage = get_node_page(sbi, inode->i_ino);\n\t\tf2fs_bug_on(sbi, IS_ERR(ipage));\n\t\ttruncate_inline_data(ipage);\n\t\tf2fs_clear_inline_inode(inode);\n\t\tupdate_inode(inode, ipage);\n\t\tf2fs_put_page(ipage, 1);\n\t} else if (ri && (ri->i_inline & F2FS_INLINE_DATA)) {\n\t\ttruncate_blocks(inode, 0, false);\n\t\tgoto process_inline;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "f2fs_write_inline_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inline.c",
    "lines": "175-205",
    "snippet": "int f2fs_write_inline_data(struct inode *inode, struct page *page)\n{\n\tvoid *src_addr, *dst_addr;\n\tstruct dnode_of_data dn;\n\tint err;\n\n\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\terr = get_dnode_of_data(&dn, 0, LOOKUP_NODE);\n\tif (err)\n\t\treturn err;\n\n\tif (!f2fs_has_inline_data(inode)) {\n\t\tf2fs_put_dnode(&dn);\n\t\treturn -EAGAIN;\n\t}\n\n\tf2fs_bug_on(F2FS_I_SB(inode), page->index);\n\n\tf2fs_wait_on_page_writeback(dn.inode_page, NODE);\n\tsrc_addr = kmap_atomic(page);\n\tdst_addr = inline_data_addr(dn.inode_page);\n\tmemcpy(dst_addr, src_addr, MAX_INLINE_DATA);\n\tkunmap_atomic(src_addr);\n\n\tset_inode_flag(F2FS_I(inode), FI_APPEND_WRITE);\n\tset_inode_flag(F2FS_I(inode), FI_DATA_EXIST);\n\n\tsync_inode_page(&dn);\n\tf2fs_put_dnode(&dn);\n\treturn 0;\n}",
    "includes": [
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_put_dnode",
          "args": [
            "&dn"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1048-1056",
          "snippet": "static inline void f2fs_put_dnode(struct dnode_of_data *dn)\n{\n\tif (dn->node_page)\n\t\tf2fs_put_page(dn->node_page, 1);\n\tif (dn->inode_page && dn->node_page != dn->inode_page)\n\t\tf2fs_put_page(dn->inode_page, 0);\n\tdn->node_page = NULL;\n\tdn->inode_page = NULL;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_dnode(struct dnode_of_data *dn)\n{\n\tif (dn->node_page)\n\t\tf2fs_put_page(dn->node_page, 1);\n\tif (dn->inode_page && dn->node_page != dn->inode_page)\n\t\tf2fs_put_page(dn->inode_page, 0);\n\tdn->node_page = NULL;\n\tdn->inode_page = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_inode_page",
          "args": [
            "&dn"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "sync_inode_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1116-1129",
          "snippet": "void sync_inode_page(struct dnode_of_data *dn)\n{\n\tif (IS_INODE(dn->node_page) || dn->inode_page == dn->node_page) {\n\t\tupdate_inode(dn->inode, dn->node_page);\n\t} else if (dn->inode_page) {\n\t\tif (!dn->inode_page_locked)\n\t\t\tlock_page(dn->inode_page);\n\t\tupdate_inode(dn->inode, dn->inode_page);\n\t\tif (!dn->inode_page_locked)\n\t\t\tunlock_page(dn->inode_page);\n\t} else {\n\t\tupdate_inode_page(dn->inode);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid sync_inode_page(struct dnode_of_data *dn)\n{\n\tif (IS_INODE(dn->node_page) || dn->inode_page == dn->node_page) {\n\t\tupdate_inode(dn->inode, dn->node_page);\n\t} else if (dn->inode_page) {\n\t\tif (!dn->inode_page_locked)\n\t\t\tlock_page(dn->inode_page);\n\t\tupdate_inode(dn->inode, dn->inode_page);\n\t\tif (!dn->inode_page_locked)\n\t\t\tunlock_page(dn->inode_page);\n\t} else {\n\t\tupdate_inode_page(dn->inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_inode_flag",
          "args": [
            "F2FS_I(inode)",
            "FI_DATA_EXIST"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "set_inode_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1173-1177",
          "snippet": "static inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "src_addr"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst_addr",
            "src_addr",
            "MAX_INLINE_DATA"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inline_data_addr",
          "args": [
            "dn.inode_page"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "inline_data_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1282-1286",
          "snippet": "static inline void *inline_data_addr(struct page *page)\n{\n\tstruct f2fs_inode *ri = F2FS_INODE(page);\n\treturn (void *)&(ri->i_addr[1]);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *inline_data_addr(struct page *page)\n{\n\tstruct f2fs_inode *ri = F2FS_INODE(page);\n\treturn (void *)&(ri->i_addr[1]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_wait_on_page_writeback",
          "args": [
            "dn.inode_page",
            "NODE"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_wait_on_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1321-1331",
          "snippet": "void f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "F2FS_I_SB(inode)",
            "page->index"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "inode"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1251-1254",
          "snippet": "static inline int f2fs_has_inline_data(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DATA);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_has_inline_data(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_dnode_of_data",
          "args": [
            "&dn",
            "0",
            "LOOKUP_NODE"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "get_dnode_of_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "473-572",
          "snippet": "int get_dnode_of_data(struct dnode_of_data *dn, pgoff_t index, int mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct page *npage[4];\n\tstruct page *parent = NULL;\n\tint offset[4];\n\tunsigned int noffset[4];\n\tnid_t nids[4];\n\tint level, i;\n\tint err = 0;\n\n\tlevel = get_node_path(F2FS_I(dn->inode), index, offset, noffset);\n\n\tnids[0] = dn->inode->i_ino;\n\tnpage[0] = dn->inode_page;\n\n\tif (!npage[0]) {\n\t\tnpage[0] = get_node_page(sbi, nids[0]);\n\t\tif (IS_ERR(npage[0]))\n\t\t\treturn PTR_ERR(npage[0]);\n\t}\n\n\t/* if inline_data is set, should not report any block indices */\n\tif (f2fs_has_inline_data(dn->inode) && index) {\n\t\terr = -EINVAL;\n\t\tf2fs_put_page(npage[0], 1);\n\t\tgoto release_out;\n\t}\n\n\tparent = npage[0];\n\tif (level != 0)\n\t\tnids[1] = get_nid(parent, offset[0], true);\n\tdn->inode_page = npage[0];\n\tdn->inode_page_locked = true;\n\n\t/* get indirect or direct nodes */\n\tfor (i = 1; i <= level; i++) {\n\t\tbool done = false;\n\n\t\tif (!nids[i] && mode == ALLOC_NODE) {\n\t\t\t/* alloc new node */\n\t\t\tif (!alloc_nid(sbi, &(nids[i]))) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tdn->nid = nids[i];\n\t\t\tnpage[i] = new_node_page(dn, noffset[i], NULL);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\talloc_nid_failed(sbi, nids[i]);\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tset_nid(parent, offset[i - 1], nids[i], i == 1);\n\t\t\talloc_nid_done(sbi, nids[i]);\n\t\t\tdone = true;\n\t\t} else if (mode == LOOKUP_NODE_RA && i == level && level > 1) {\n\t\t\tnpage[i] = get_node_page_ra(parent, offset[i - 1]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\t\t\tdone = true;\n\t\t}\n\t\tif (i == 1) {\n\t\t\tdn->inode_page_locked = false;\n\t\t\tunlock_page(parent);\n\t\t} else {\n\t\t\tf2fs_put_page(parent, 1);\n\t\t}\n\n\t\tif (!done) {\n\t\t\tnpage[i] = get_node_page(sbi, nids[i]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tf2fs_put_page(npage[0], 0);\n\t\t\t\tgoto release_out;\n\t\t\t}\n\t\t}\n\t\tif (i < level) {\n\t\t\tparent = npage[i];\n\t\t\tnids[i + 1] = get_nid(parent, offset[i], false);\n\t\t}\n\t}\n\tdn->nid = nids[level];\n\tdn->ofs_in_node = offset[level];\n\tdn->node_page = npage[level];\n\tdn->data_blkaddr = datablock_addr(dn->node_page, dn->ofs_in_node);\n\treturn 0;\n\nrelease_pages:\n\tf2fs_put_page(parent, 1);\n\tif (i > 1)\n\t\tf2fs_put_page(npage[0], 0);\nrelease_out:\n\tdn->inode_page = NULL;\n\tdn->node_page = NULL;\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint get_dnode_of_data(struct dnode_of_data *dn, pgoff_t index, int mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct page *npage[4];\n\tstruct page *parent = NULL;\n\tint offset[4];\n\tunsigned int noffset[4];\n\tnid_t nids[4];\n\tint level, i;\n\tint err = 0;\n\n\tlevel = get_node_path(F2FS_I(dn->inode), index, offset, noffset);\n\n\tnids[0] = dn->inode->i_ino;\n\tnpage[0] = dn->inode_page;\n\n\tif (!npage[0]) {\n\t\tnpage[0] = get_node_page(sbi, nids[0]);\n\t\tif (IS_ERR(npage[0]))\n\t\t\treturn PTR_ERR(npage[0]);\n\t}\n\n\t/* if inline_data is set, should not report any block indices */\n\tif (f2fs_has_inline_data(dn->inode) && index) {\n\t\terr = -EINVAL;\n\t\tf2fs_put_page(npage[0], 1);\n\t\tgoto release_out;\n\t}\n\n\tparent = npage[0];\n\tif (level != 0)\n\t\tnids[1] = get_nid(parent, offset[0], true);\n\tdn->inode_page = npage[0];\n\tdn->inode_page_locked = true;\n\n\t/* get indirect or direct nodes */\n\tfor (i = 1; i <= level; i++) {\n\t\tbool done = false;\n\n\t\tif (!nids[i] && mode == ALLOC_NODE) {\n\t\t\t/* alloc new node */\n\t\t\tif (!alloc_nid(sbi, &(nids[i]))) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tdn->nid = nids[i];\n\t\t\tnpage[i] = new_node_page(dn, noffset[i], NULL);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\talloc_nid_failed(sbi, nids[i]);\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tset_nid(parent, offset[i - 1], nids[i], i == 1);\n\t\t\talloc_nid_done(sbi, nids[i]);\n\t\t\tdone = true;\n\t\t} else if (mode == LOOKUP_NODE_RA && i == level && level > 1) {\n\t\t\tnpage[i] = get_node_page_ra(parent, offset[i - 1]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\t\t\tdone = true;\n\t\t}\n\t\tif (i == 1) {\n\t\t\tdn->inode_page_locked = false;\n\t\t\tunlock_page(parent);\n\t\t} else {\n\t\t\tf2fs_put_page(parent, 1);\n\t\t}\n\n\t\tif (!done) {\n\t\t\tnpage[i] = get_node_page(sbi, nids[i]);\n\t\t\tif (IS_ERR(npage[i])) {\n\t\t\t\terr = PTR_ERR(npage[i]);\n\t\t\t\tf2fs_put_page(npage[0], 0);\n\t\t\t\tgoto release_out;\n\t\t\t}\n\t\t}\n\t\tif (i < level) {\n\t\t\tparent = npage[i];\n\t\t\tnids[i + 1] = get_nid(parent, offset[i], false);\n\t\t}\n\t}\n\tdn->nid = nids[level];\n\tdn->ofs_in_node = offset[level];\n\tdn->node_page = npage[level];\n\tdn->data_blkaddr = datablock_addr(dn->node_page, dn->ofs_in_node);\n\treturn 0;\n\nrelease_pages:\n\tf2fs_put_page(parent, 1);\n\tif (i > 1)\n\t\tf2fs_put_page(npage[0], 0);\nrelease_out:\n\tdn->inode_page = NULL;\n\tdn->node_page = NULL;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_new_dnode",
          "args": [
            "&dn",
            "inode",
            "NULL",
            "NULL",
            "0"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "set_new_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "381-389",
          "snippet": "static inline void set_new_dnode(struct dnode_of_data *dn, struct inode *inode,\n\t\tstruct page *ipage, struct page *npage, nid_t nid)\n{\n\tmemset(dn, 0, sizeof(*dn));\n\tdn->inode = inode;\n\tdn->inode_page = ipage;\n\tdn->node_page = npage;\n\tdn->nid = nid;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_new_dnode(struct dnode_of_data *dn, struct inode *inode,\n\t\tstruct page *ipage, struct page *npage, nid_t nid)\n{\n\tmemset(dn, 0, sizeof(*dn));\n\tdn->inode = inode;\n\tdn->inode_page = ipage;\n\tdn->node_page = npage;\n\tdn->nid = nid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_write_inline_data(struct inode *inode, struct page *page)\n{\n\tvoid *src_addr, *dst_addr;\n\tstruct dnode_of_data dn;\n\tint err;\n\n\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\terr = get_dnode_of_data(&dn, 0, LOOKUP_NODE);\n\tif (err)\n\t\treturn err;\n\n\tif (!f2fs_has_inline_data(inode)) {\n\t\tf2fs_put_dnode(&dn);\n\t\treturn -EAGAIN;\n\t}\n\n\tf2fs_bug_on(F2FS_I_SB(inode), page->index);\n\n\tf2fs_wait_on_page_writeback(dn.inode_page, NODE);\n\tsrc_addr = kmap_atomic(page);\n\tdst_addr = inline_data_addr(dn.inode_page);\n\tmemcpy(dst_addr, src_addr, MAX_INLINE_DATA);\n\tkunmap_atomic(src_addr);\n\n\tset_inode_flag(F2FS_I(inode), FI_APPEND_WRITE);\n\tset_inode_flag(F2FS_I(inode), FI_DATA_EXIST);\n\n\tsync_inode_page(&dn);\n\tf2fs_put_dnode(&dn);\n\treturn 0;\n}"
  },
  {
    "function_name": "f2fs_convert_inline_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inline.c",
    "lines": "143-173",
    "snippet": "int f2fs_convert_inline_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct dnode_of_data dn;\n\tstruct page *ipage, *page;\n\tint err = 0;\n\n\tpage = grab_cache_page(inode->i_mapping, 0);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tf2fs_lock_op(sbi);\n\n\tipage = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(ipage)) {\n\t\terr = PTR_ERR(ipage);\n\t\tgoto out;\n\t}\n\n\tset_new_dnode(&dn, inode, ipage, ipage, 0);\n\n\tif (f2fs_has_inline_data(inode))\n\t\terr = f2fs_convert_inline_page(&dn, page);\n\n\tf2fs_put_dnode(&dn);\nout:\n\tf2fs_unlock_op(sbi);\n\n\tf2fs_put_page(page, 1);\n\treturn err;\n}",
    "includes": [
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "page",
            "1"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_unlock_op",
          "args": [
            "sbi"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_unlock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "760-763",
          "snippet": "static inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_put_dnode",
          "args": [
            "&dn"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1048-1056",
          "snippet": "static inline void f2fs_put_dnode(struct dnode_of_data *dn)\n{\n\tif (dn->node_page)\n\t\tf2fs_put_page(dn->node_page, 1);\n\tif (dn->inode_page && dn->node_page != dn->inode_page)\n\t\tf2fs_put_page(dn->inode_page, 0);\n\tdn->node_page = NULL;\n\tdn->inode_page = NULL;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_dnode(struct dnode_of_data *dn)\n{\n\tif (dn->node_page)\n\t\tf2fs_put_page(dn->node_page, 1);\n\tif (dn->inode_page && dn->node_page != dn->inode_page)\n\t\tf2fs_put_page(dn->inode_page, 0);\n\tdn->node_page = NULL;\n\tdn->inode_page = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_convert_inline_page",
          "args": [
            "&dn",
            "page"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_convert_inline_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inline.c",
          "lines": "85-141",
          "snippet": "int f2fs_convert_inline_page(struct dnode_of_data *dn, struct page *page)\n{\n\tvoid *src_addr, *dst_addr;\n\tstruct f2fs_io_info fio = {\n\t\t.type = DATA,\n\t\t.rw = WRITE_SYNC | REQ_PRIO,\n\t};\n\tint dirty, err;\n\n\tf2fs_bug_on(F2FS_I_SB(dn->inode), page->index);\n\n\tif (!f2fs_exist_data(dn->inode))\n\t\tgoto clear_out;\n\n\terr = f2fs_reserve_block(dn, 0);\n\tif (err)\n\t\treturn err;\n\n\tf2fs_wait_on_page_writeback(page, DATA);\n\n\tif (PageUptodate(page))\n\t\tgoto no_update;\n\n\tzero_user_segment(page, MAX_INLINE_DATA, PAGE_CACHE_SIZE);\n\n\t/* Copy the whole inline data block */\n\tsrc_addr = inline_data_addr(dn->inode_page);\n\tdst_addr = kmap_atomic(page);\n\tmemcpy(dst_addr, src_addr, MAX_INLINE_DATA);\n\tflush_dcache_page(page);\n\tkunmap_atomic(dst_addr);\n\tSetPageUptodate(page);\nno_update:\n\t/* clear dirty state */\n\tdirty = clear_page_dirty_for_io(page);\n\n\t/* write data page to try to make data consistent */\n\tset_page_writeback(page);\n\tfio.blk_addr = dn->data_blkaddr;\n\twrite_data_page(page, dn, &fio);\n\tupdate_extent_cache(dn);\n\tf2fs_wait_on_page_writeback(page, DATA);\n\tif (dirty)\n\t\tinode_dec_dirty_pages(dn->inode);\n\n\t/* this converted inline_data should be recovered. */\n\tset_inode_flag(F2FS_I(dn->inode), FI_APPEND_WRITE);\n\n\t/* clear inline data and flag after data writeback */\n\ttruncate_inline_data(dn->inode_page);\nclear_out:\n\tstat_dec_inline_inode(dn->inode);\n\tf2fs_clear_inline_inode(dn->inode);\n\tsync_inode_page(dn);\n\tf2fs_put_dnode(dn);\n\treturn 0;\n}",
          "includes": [
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_convert_inline_page(struct dnode_of_data *dn, struct page *page)\n{\n\tvoid *src_addr, *dst_addr;\n\tstruct f2fs_io_info fio = {\n\t\t.type = DATA,\n\t\t.rw = WRITE_SYNC | REQ_PRIO,\n\t};\n\tint dirty, err;\n\n\tf2fs_bug_on(F2FS_I_SB(dn->inode), page->index);\n\n\tif (!f2fs_exist_data(dn->inode))\n\t\tgoto clear_out;\n\n\terr = f2fs_reserve_block(dn, 0);\n\tif (err)\n\t\treturn err;\n\n\tf2fs_wait_on_page_writeback(page, DATA);\n\n\tif (PageUptodate(page))\n\t\tgoto no_update;\n\n\tzero_user_segment(page, MAX_INLINE_DATA, PAGE_CACHE_SIZE);\n\n\t/* Copy the whole inline data block */\n\tsrc_addr = inline_data_addr(dn->inode_page);\n\tdst_addr = kmap_atomic(page);\n\tmemcpy(dst_addr, src_addr, MAX_INLINE_DATA);\n\tflush_dcache_page(page);\n\tkunmap_atomic(dst_addr);\n\tSetPageUptodate(page);\nno_update:\n\t/* clear dirty state */\n\tdirty = clear_page_dirty_for_io(page);\n\n\t/* write data page to try to make data consistent */\n\tset_page_writeback(page);\n\tfio.blk_addr = dn->data_blkaddr;\n\twrite_data_page(page, dn, &fio);\n\tupdate_extent_cache(dn);\n\tf2fs_wait_on_page_writeback(page, DATA);\n\tif (dirty)\n\t\tinode_dec_dirty_pages(dn->inode);\n\n\t/* this converted inline_data should be recovered. */\n\tset_inode_flag(F2FS_I(dn->inode), FI_APPEND_WRITE);\n\n\t/* clear inline data and flag after data writeback */\n\ttruncate_inline_data(dn->inode_page);\nclear_out:\n\tstat_dec_inline_inode(dn->inode);\n\tf2fs_clear_inline_inode(dn->inode);\n\tsync_inode_page(dn);\n\tf2fs_put_dnode(dn);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1251-1254",
          "snippet": "static inline int f2fs_has_inline_data(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DATA);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_has_inline_data(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_new_dnode",
          "args": [
            "&dn",
            "inode",
            "ipage",
            "ipage",
            "0"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "set_new_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "381-389",
          "snippet": "static inline void set_new_dnode(struct dnode_of_data *dn, struct inode *inode,\n\t\tstruct page *ipage, struct page *npage, nid_t nid)\n{\n\tmemset(dn, 0, sizeof(*dn));\n\tdn->inode = inode;\n\tdn->inode_page = ipage;\n\tdn->node_page = npage;\n\tdn->nid = nid;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_new_dnode(struct dnode_of_data *dn, struct inode *inode,\n\t\tstruct page *ipage, struct page *npage, nid_t nid)\n{\n\tmemset(dn, 0, sizeof(*dn));\n\tdn->inode = inode;\n\tdn->inode_page = ipage;\n\tdn->node_page = npage;\n\tdn->nid = nid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ipage"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ipage"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node_page",
          "args": [
            "sbi",
            "inode->i_ino"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_page_ra",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1066-1114",
          "snippet": "struct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_lock_op",
          "args": [
            "sbi"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_lock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "755-758",
          "snippet": "static inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "grab_cache_page",
          "args": [
            "inode->i_mapping",
            "0"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "inode"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_convert_inline_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct dnode_of_data dn;\n\tstruct page *ipage, *page;\n\tint err = 0;\n\n\tpage = grab_cache_page(inode->i_mapping, 0);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tf2fs_lock_op(sbi);\n\n\tipage = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(ipage)) {\n\t\terr = PTR_ERR(ipage);\n\t\tgoto out;\n\t}\n\n\tset_new_dnode(&dn, inode, ipage, ipage, 0);\n\n\tif (f2fs_has_inline_data(inode))\n\t\terr = f2fs_convert_inline_page(&dn, page);\n\n\tf2fs_put_dnode(&dn);\nout:\n\tf2fs_unlock_op(sbi);\n\n\tf2fs_put_page(page, 1);\n\treturn err;\n}"
  },
  {
    "function_name": "f2fs_convert_inline_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inline.c",
    "lines": "85-141",
    "snippet": "int f2fs_convert_inline_page(struct dnode_of_data *dn, struct page *page)\n{\n\tvoid *src_addr, *dst_addr;\n\tstruct f2fs_io_info fio = {\n\t\t.type = DATA,\n\t\t.rw = WRITE_SYNC | REQ_PRIO,\n\t};\n\tint dirty, err;\n\n\tf2fs_bug_on(F2FS_I_SB(dn->inode), page->index);\n\n\tif (!f2fs_exist_data(dn->inode))\n\t\tgoto clear_out;\n\n\terr = f2fs_reserve_block(dn, 0);\n\tif (err)\n\t\treturn err;\n\n\tf2fs_wait_on_page_writeback(page, DATA);\n\n\tif (PageUptodate(page))\n\t\tgoto no_update;\n\n\tzero_user_segment(page, MAX_INLINE_DATA, PAGE_CACHE_SIZE);\n\n\t/* Copy the whole inline data block */\n\tsrc_addr = inline_data_addr(dn->inode_page);\n\tdst_addr = kmap_atomic(page);\n\tmemcpy(dst_addr, src_addr, MAX_INLINE_DATA);\n\tflush_dcache_page(page);\n\tkunmap_atomic(dst_addr);\n\tSetPageUptodate(page);\nno_update:\n\t/* clear dirty state */\n\tdirty = clear_page_dirty_for_io(page);\n\n\t/* write data page to try to make data consistent */\n\tset_page_writeback(page);\n\tfio.blk_addr = dn->data_blkaddr;\n\twrite_data_page(page, dn, &fio);\n\tupdate_extent_cache(dn);\n\tf2fs_wait_on_page_writeback(page, DATA);\n\tif (dirty)\n\t\tinode_dec_dirty_pages(dn->inode);\n\n\t/* this converted inline_data should be recovered. */\n\tset_inode_flag(F2FS_I(dn->inode), FI_APPEND_WRITE);\n\n\t/* clear inline data and flag after data writeback */\n\ttruncate_inline_data(dn->inode_page);\nclear_out:\n\tstat_dec_inline_inode(dn->inode);\n\tf2fs_clear_inline_inode(dn->inode);\n\tsync_inode_page(dn);\n\tf2fs_put_dnode(dn);\n\treturn 0;\n}",
    "includes": [
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_put_dnode",
          "args": [
            "dn"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1048-1056",
          "snippet": "static inline void f2fs_put_dnode(struct dnode_of_data *dn)\n{\n\tif (dn->node_page)\n\t\tf2fs_put_page(dn->node_page, 1);\n\tif (dn->inode_page && dn->node_page != dn->inode_page)\n\t\tf2fs_put_page(dn->inode_page, 0);\n\tdn->node_page = NULL;\n\tdn->inode_page = NULL;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_dnode(struct dnode_of_data *dn)\n{\n\tif (dn->node_page)\n\t\tf2fs_put_page(dn->node_page, 1);\n\tif (dn->inode_page && dn->node_page != dn->inode_page)\n\t\tf2fs_put_page(dn->inode_page, 0);\n\tdn->node_page = NULL;\n\tdn->inode_page = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_inode_page",
          "args": [
            "dn"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "sync_inode_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1116-1129",
          "snippet": "void sync_inode_page(struct dnode_of_data *dn)\n{\n\tif (IS_INODE(dn->node_page) || dn->inode_page == dn->node_page) {\n\t\tupdate_inode(dn->inode, dn->node_page);\n\t} else if (dn->inode_page) {\n\t\tif (!dn->inode_page_locked)\n\t\t\tlock_page(dn->inode_page);\n\t\tupdate_inode(dn->inode, dn->inode_page);\n\t\tif (!dn->inode_page_locked)\n\t\t\tunlock_page(dn->inode_page);\n\t} else {\n\t\tupdate_inode_page(dn->inode);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid sync_inode_page(struct dnode_of_data *dn)\n{\n\tif (IS_INODE(dn->node_page) || dn->inode_page == dn->node_page) {\n\t\tupdate_inode(dn->inode, dn->node_page);\n\t} else if (dn->inode_page) {\n\t\tif (!dn->inode_page_locked)\n\t\t\tlock_page(dn->inode_page);\n\t\tupdate_inode(dn->inode, dn->inode_page);\n\t\tif (!dn->inode_page_locked)\n\t\t\tunlock_page(dn->inode_page);\n\t} else {\n\t\tupdate_inode_page(dn->inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_clear_inline_inode",
          "args": [
            "dn->inode"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_clear_inline_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1256-1260",
          "snippet": "static inline void f2fs_clear_inline_inode(struct inode *inode)\n{\n\tclear_inode_flag(F2FS_I(inode), FI_INLINE_DATA);\n\tclear_inode_flag(F2FS_I(inode), FI_DATA_EXIST);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_clear_inline_inode(struct inode *inode)\n{\n\tclear_inode_flag(F2FS_I(inode), FI_INLINE_DATA);\n\tclear_inode_flag(F2FS_I(inode), FI_DATA_EXIST);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat_dec_inline_inode",
          "args": [
            "dn->inode"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truncate_inline_data",
          "args": [
            "dn->inode_page"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inline.c",
          "lines": "53-57",
          "snippet": "static void truncate_inline_data(struct page *ipage)\n{\n\tf2fs_wait_on_page_writeback(ipage, NODE);\n\tmemset(inline_data_addr(ipage), 0, MAX_INLINE_DATA);\n}",
          "includes": [
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void truncate_inline_data(struct page *ipage)\n{\n\tf2fs_wait_on_page_writeback(ipage, NODE);\n\tmemset(inline_data_addr(ipage), 0, MAX_INLINE_DATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_inode_flag",
          "args": [
            "F2FS_I(dn->inode)",
            "FI_APPEND_WRITE"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "set_inode_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1173-1177",
          "snippet": "static inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "dn->inode"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dec_dirty_pages",
          "args": [
            "dn->inode"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "inode_dec_dirty_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "876-885",
          "snippet": "static inline void inode_dec_dirty_pages(struct inode *inode)\n{\n\tif (!S_ISDIR(inode->i_mode) && !S_ISREG(inode->i_mode))\n\t\treturn;\n\n\tatomic_dec(&F2FS_I(inode)->dirty_pages);\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tdec_page_count(F2FS_I_SB(inode), F2FS_DIRTY_DENTS);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void inode_dec_dirty_pages(struct inode *inode)\n{\n\tif (!S_ISDIR(inode->i_mode) && !S_ISREG(inode->i_mode))\n\t\treturn;\n\n\tatomic_dec(&F2FS_I(inode)->dirty_pages);\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tdec_page_count(F2FS_I_SB(inode), F2FS_DIRTY_DENTS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_wait_on_page_writeback",
          "args": [
            "page",
            "DATA"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_wait_on_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1321-1331",
          "snippet": "void f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_extent_cache",
          "args": [
            "dn"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "update_extent_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "294-373",
          "snippet": "void update_extent_cache(struct dnode_of_data *dn)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(dn->inode);\n\tpgoff_t fofs, start_fofs, end_fofs;\n\tblock_t start_blkaddr, end_blkaddr;\n\tint need_update = true;\n\n\tf2fs_bug_on(F2FS_I_SB(dn->inode), dn->data_blkaddr == NEW_ADDR);\n\n\t/* Update the page address in the parent node */\n\t__set_data_blkaddr(dn);\n\n\tif (is_inode_flag_set(fi, FI_NO_EXTENT))\n\t\treturn;\n\n\tfofs = start_bidx_of_node(ofs_of_node(dn->node_page), fi) +\n\t\t\t\t\t\t\tdn->ofs_in_node;\n\n\twrite_lock(&fi->ext.ext_lock);\n\n\tstart_fofs = fi->ext.fofs;\n\tend_fofs = fi->ext.fofs + fi->ext.len - 1;\n\tstart_blkaddr = fi->ext.blk_addr;\n\tend_blkaddr = fi->ext.blk_addr + fi->ext.len - 1;\n\n\t/* Drop and initialize the matched extent */\n\tif (fi->ext.len == 1 && fofs == start_fofs)\n\t\tfi->ext.len = 0;\n\n\t/* Initial extent */\n\tif (fi->ext.len == 0) {\n\t\tif (dn->data_blkaddr != NULL_ADDR) {\n\t\t\tfi->ext.fofs = fofs;\n\t\t\tfi->ext.blk_addr = dn->data_blkaddr;\n\t\t\tfi->ext.len = 1;\n\t\t}\n\t\tgoto end_update;\n\t}\n\n\t/* Front merge */\n\tif (fofs == start_fofs - 1 && dn->data_blkaddr == start_blkaddr - 1) {\n\t\tfi->ext.fofs--;\n\t\tfi->ext.blk_addr--;\n\t\tfi->ext.len++;\n\t\tgoto end_update;\n\t}\n\n\t/* Back merge */\n\tif (fofs == end_fofs + 1 && dn->data_blkaddr == end_blkaddr + 1) {\n\t\tfi->ext.len++;\n\t\tgoto end_update;\n\t}\n\n\t/* Split the existing extent */\n\tif (fi->ext.len > 1 &&\n\t\tfofs >= start_fofs && fofs <= end_fofs) {\n\t\tif ((end_fofs - fofs) < (fi->ext.len >> 1)) {\n\t\t\tfi->ext.len = fofs - start_fofs;\n\t\t} else {\n\t\t\tfi->ext.fofs = fofs + 1;\n\t\t\tfi->ext.blk_addr = start_blkaddr +\n\t\t\t\t\tfofs - start_fofs + 1;\n\t\t\tfi->ext.len -= fofs - start_fofs + 1;\n\t\t}\n\t} else {\n\t\tneed_update = false;\n\t}\n\n\t/* Finally, if the extent is very fragmented, let's drop the cache. */\n\tif (fi->ext.len < F2FS_MIN_EXTENT_LEN) {\n\t\tfi->ext.len = 0;\n\t\tset_inode_flag(fi, FI_NO_EXTENT);\n\t\tneed_update = true;\n\t}\nend_update:\n\twrite_unlock(&fi->ext.ext_lock);\n\tif (need_update)\n\t\tsync_inode_page(dn);\n\treturn;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid update_extent_cache(struct dnode_of_data *dn)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(dn->inode);\n\tpgoff_t fofs, start_fofs, end_fofs;\n\tblock_t start_blkaddr, end_blkaddr;\n\tint need_update = true;\n\n\tf2fs_bug_on(F2FS_I_SB(dn->inode), dn->data_blkaddr == NEW_ADDR);\n\n\t/* Update the page address in the parent node */\n\t__set_data_blkaddr(dn);\n\n\tif (is_inode_flag_set(fi, FI_NO_EXTENT))\n\t\treturn;\n\n\tfofs = start_bidx_of_node(ofs_of_node(dn->node_page), fi) +\n\t\t\t\t\t\t\tdn->ofs_in_node;\n\n\twrite_lock(&fi->ext.ext_lock);\n\n\tstart_fofs = fi->ext.fofs;\n\tend_fofs = fi->ext.fofs + fi->ext.len - 1;\n\tstart_blkaddr = fi->ext.blk_addr;\n\tend_blkaddr = fi->ext.blk_addr + fi->ext.len - 1;\n\n\t/* Drop and initialize the matched extent */\n\tif (fi->ext.len == 1 && fofs == start_fofs)\n\t\tfi->ext.len = 0;\n\n\t/* Initial extent */\n\tif (fi->ext.len == 0) {\n\t\tif (dn->data_blkaddr != NULL_ADDR) {\n\t\t\tfi->ext.fofs = fofs;\n\t\t\tfi->ext.blk_addr = dn->data_blkaddr;\n\t\t\tfi->ext.len = 1;\n\t\t}\n\t\tgoto end_update;\n\t}\n\n\t/* Front merge */\n\tif (fofs == start_fofs - 1 && dn->data_blkaddr == start_blkaddr - 1) {\n\t\tfi->ext.fofs--;\n\t\tfi->ext.blk_addr--;\n\t\tfi->ext.len++;\n\t\tgoto end_update;\n\t}\n\n\t/* Back merge */\n\tif (fofs == end_fofs + 1 && dn->data_blkaddr == end_blkaddr + 1) {\n\t\tfi->ext.len++;\n\t\tgoto end_update;\n\t}\n\n\t/* Split the existing extent */\n\tif (fi->ext.len > 1 &&\n\t\tfofs >= start_fofs && fofs <= end_fofs) {\n\t\tif ((end_fofs - fofs) < (fi->ext.len >> 1)) {\n\t\t\tfi->ext.len = fofs - start_fofs;\n\t\t} else {\n\t\t\tfi->ext.fofs = fofs + 1;\n\t\t\tfi->ext.blk_addr = start_blkaddr +\n\t\t\t\t\tfofs - start_fofs + 1;\n\t\t\tfi->ext.len -= fofs - start_fofs + 1;\n\t\t}\n\t} else {\n\t\tneed_update = false;\n\t}\n\n\t/* Finally, if the extent is very fragmented, let's drop the cache. */\n\tif (fi->ext.len < F2FS_MIN_EXTENT_LEN) {\n\t\tfi->ext.len = 0;\n\t\tset_inode_flag(fi, FI_NO_EXTENT);\n\t\tneed_update = true;\n\t}\nend_update:\n\twrite_unlock(&fi->ext.ext_lock);\n\tif (need_update)\n\t\tsync_inode_page(dn);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_data_page",
          "args": [
            "page",
            "dn",
            "&fio"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "write_data_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1234-1246",
          "snippet": "void write_data_page(struct page *page, struct dnode_of_data *dn,\n\t\t\t\tstruct f2fs_io_info *fio)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct f2fs_summary sum;\n\tstruct node_info ni;\n\n\tf2fs_bug_on(sbi, dn->data_blkaddr == NULL_ADDR);\n\tget_node_info(sbi, dn->nid, &ni);\n\tset_summary(&sum, dn->nid, dn->ofs_in_node, ni.version);\n\tdo_write_page(sbi, page, &sum, fio);\n\tdn->data_blkaddr = fio->blk_addr;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid write_data_page(struct page *page, struct dnode_of_data *dn,\n\t\t\t\tstruct f2fs_io_info *fio)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct f2fs_summary sum;\n\tstruct node_info ni;\n\n\tf2fs_bug_on(sbi, dn->data_blkaddr == NULL_ADDR);\n\tget_node_info(sbi, dn->nid, &ni);\n\tset_summary(&sum, dn->nid, dn->ofs_in_node, ni.version);\n\tdo_write_page(sbi, page, &sum, fio);\n\tdn->data_blkaddr = fio->blk_addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_writeback",
          "args": [
            "page"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_set_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "265-277",
          "snippet": "static void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))"
          ],
          "globals_used": [
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))\n\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_page_dirty_for_io",
          "args": [
            "page"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "dst_addr"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst_addr",
            "src_addr",
            "MAX_INLINE_DATA"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inline_data_addr",
          "args": [
            "dn->inode_page"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "inline_data_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1282-1286",
          "snippet": "static inline void *inline_data_addr(struct page *page)\n{\n\tstruct f2fs_inode *ri = F2FS_INODE(page);\n\treturn (void *)&(ri->i_addr[1]);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *inline_data_addr(struct page *page)\n{\n\tstruct f2fs_inode *ri = F2FS_INODE(page);\n\treturn (void *)&(ri->i_addr[1]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "page",
            "MAX_INLINE_DATA",
            "PAGE_CACHE_SIZE"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_reserve_block",
          "args": [
            "dn",
            "0"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_reserve_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/data.c",
          "lines": "235-249",
          "snippet": "int f2fs_reserve_block(struct dnode_of_data *dn, pgoff_t index)\n{\n\tbool need_put = dn->inode_page ? false : true;\n\tint err;\n\n\terr = get_dnode_of_data(dn, index, ALLOC_NODE);\n\tif (err)\n\t\treturn err;\n\n\tif (dn->data_blkaddr == NULL_ADDR)\n\t\terr = reserve_new_block(dn);\n\tif (err || need_put)\n\t\tf2fs_put_dnode(dn);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/prefetch.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_reserve_block(struct dnode_of_data *dn, pgoff_t index)\n{\n\tbool need_put = dn->inode_page ? false : true;\n\tint err;\n\n\terr = get_dnode_of_data(dn, index, ALLOC_NODE);\n\tif (err)\n\t\treturn err;\n\n\tif (dn->data_blkaddr == NULL_ADDR)\n\t\terr = reserve_new_block(dn);\n\tif (err || need_put)\n\t\tf2fs_put_dnode(dn);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_exist_data",
          "args": [
            "dn->inode"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_exist_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1262-1265",
          "snippet": "static inline int f2fs_exist_data(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_DATA_EXIST);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_exist_data(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_DATA_EXIST);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "F2FS_I_SB(dn->inode)",
            "page->index"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "dn->inode"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_convert_inline_page(struct dnode_of_data *dn, struct page *page)\n{\n\tvoid *src_addr, *dst_addr;\n\tstruct f2fs_io_info fio = {\n\t\t.type = DATA,\n\t\t.rw = WRITE_SYNC | REQ_PRIO,\n\t};\n\tint dirty, err;\n\n\tf2fs_bug_on(F2FS_I_SB(dn->inode), page->index);\n\n\tif (!f2fs_exist_data(dn->inode))\n\t\tgoto clear_out;\n\n\terr = f2fs_reserve_block(dn, 0);\n\tif (err)\n\t\treturn err;\n\n\tf2fs_wait_on_page_writeback(page, DATA);\n\n\tif (PageUptodate(page))\n\t\tgoto no_update;\n\n\tzero_user_segment(page, MAX_INLINE_DATA, PAGE_CACHE_SIZE);\n\n\t/* Copy the whole inline data block */\n\tsrc_addr = inline_data_addr(dn->inode_page);\n\tdst_addr = kmap_atomic(page);\n\tmemcpy(dst_addr, src_addr, MAX_INLINE_DATA);\n\tflush_dcache_page(page);\n\tkunmap_atomic(dst_addr);\n\tSetPageUptodate(page);\nno_update:\n\t/* clear dirty state */\n\tdirty = clear_page_dirty_for_io(page);\n\n\t/* write data page to try to make data consistent */\n\tset_page_writeback(page);\n\tfio.blk_addr = dn->data_blkaddr;\n\twrite_data_page(page, dn, &fio);\n\tupdate_extent_cache(dn);\n\tf2fs_wait_on_page_writeback(page, DATA);\n\tif (dirty)\n\t\tinode_dec_dirty_pages(dn->inode);\n\n\t/* this converted inline_data should be recovered. */\n\tset_inode_flag(F2FS_I(dn->inode), FI_APPEND_WRITE);\n\n\t/* clear inline data and flag after data writeback */\n\ttruncate_inline_data(dn->inode_page);\nclear_out:\n\tstat_dec_inline_inode(dn->inode);\n\tf2fs_clear_inline_inode(dn->inode);\n\tsync_inode_page(dn);\n\tf2fs_put_dnode(dn);\n\treturn 0;\n}"
  },
  {
    "function_name": "f2fs_read_inline_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inline.c",
    "lines": "59-83",
    "snippet": "int f2fs_read_inline_data(struct inode *inode, struct page *page)\n{\n\tstruct page *ipage;\n\n\tipage = get_node_page(F2FS_I_SB(inode), inode->i_ino);\n\tif (IS_ERR(ipage)) {\n\t\tunlock_page(page);\n\t\treturn PTR_ERR(ipage);\n\t}\n\n\tif (!f2fs_has_inline_data(inode)) {\n\t\tf2fs_put_page(ipage, 1);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (page->index)\n\t\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\telse\n\t\tread_inline_data(page, ipage);\n\n\tSetPageUptodate(page);\n\tf2fs_put_page(ipage, 1);\n\tunlock_page(page);\n\treturn 0;\n}",
    "includes": [
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "ipage",
            "1"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_inline_data",
          "args": [
            "page",
            "ipage"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_read_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inline.c",
          "lines": "59-83",
          "snippet": "int f2fs_read_inline_data(struct inode *inode, struct page *page)\n{\n\tstruct page *ipage;\n\n\tipage = get_node_page(F2FS_I_SB(inode), inode->i_ino);\n\tif (IS_ERR(ipage)) {\n\t\tunlock_page(page);\n\t\treturn PTR_ERR(ipage);\n\t}\n\n\tif (!f2fs_has_inline_data(inode)) {\n\t\tf2fs_put_page(ipage, 1);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (page->index)\n\t\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\telse\n\t\tread_inline_data(page, ipage);\n\n\tSetPageUptodate(page);\n\tf2fs_put_page(ipage, 1);\n\tunlock_page(page);\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "page",
            "0",
            "PAGE_CACHE_SIZE"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1251-1254",
          "snippet": "static inline int f2fs_has_inline_data(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DATA);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_has_inline_data(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_INLINE_DATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ipage"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ipage"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_node_page",
          "args": [
            "F2FS_I_SB(inode)",
            "inode->i_ino"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "get_node_page_ra",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1066-1114",
          "snippet": "struct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct page *get_node_page_ra(struct page *parent, int start)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_P_SB(parent);\n\tstruct blk_plug plug;\n\tstruct page *page;\n\tint err, i, end;\n\tnid_t nid;\n\n\t/* First, try getting the desired direct node. */\n\tnid = get_nid(parent, start, false);\n\tif (!nid)\n\t\treturn ERR_PTR(-ENOENT);\nrepeat:\n\tpage = grab_cache_page(NODE_MAPPING(sbi), nid);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_node_page(page, READ_SYNC);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\telse if (err == LOCKED_PAGE)\n\t\tgoto page_hit;\n\n\tblk_start_plug(&plug);\n\n\t/* Then, try readahead for siblings of the desired node */\n\tend = start + MAX_RA_NODE;\n\tend = min(end, NIDS_PER_BLOCK);\n\tfor (i = start + 1; i < end; i++) {\n\t\tnid = get_nid(parent, i, false);\n\t\tif (!nid)\n\t\t\tcontinue;\n\t\tra_node_page(sbi, nid);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != NODE_MAPPING(sbi))) {\n\t\tf2fs_put_page(page, 1);\n\t\tgoto repeat;\n\t}\npage_hit:\n\tif (unlikely(!PageUptodate(page))) {\n\t\tf2fs_put_page(page, 1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "inode"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_read_inline_data(struct inode *inode, struct page *page)\n{\n\tstruct page *ipage;\n\n\tipage = get_node_page(F2FS_I_SB(inode), inode->i_ino);\n\tif (IS_ERR(ipage)) {\n\t\tunlock_page(page);\n\t\treturn PTR_ERR(ipage);\n\t}\n\n\tif (!f2fs_has_inline_data(inode)) {\n\t\tf2fs_put_page(ipage, 1);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (page->index)\n\t\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\telse\n\t\tread_inline_data(page, ipage);\n\n\tSetPageUptodate(page);\n\tf2fs_put_page(ipage, 1);\n\tunlock_page(page);\n\treturn 0;\n}"
  },
  {
    "function_name": "truncate_inline_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inline.c",
    "lines": "53-57",
    "snippet": "static void truncate_inline_data(struct page *ipage)\n{\n\tf2fs_wait_on_page_writeback(ipage, NODE);\n\tmemset(inline_data_addr(ipage), 0, MAX_INLINE_DATA);\n}",
    "includes": [
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "inline_data_addr(ipage)",
            "0",
            "MAX_INLINE_DATA"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inline_data_addr",
          "args": [
            "ipage"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "inline_data_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1282-1286",
          "snippet": "static inline void *inline_data_addr(struct page *page)\n{\n\tstruct f2fs_inode *ri = F2FS_INODE(page);\n\treturn (void *)&(ri->i_addr[1]);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *inline_data_addr(struct page *page)\n{\n\tstruct f2fs_inode *ri = F2FS_INODE(page);\n\treturn (void *)&(ri->i_addr[1]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_wait_on_page_writeback",
          "args": [
            "ipage",
            "NODE"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_wait_on_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "1321-1331",
          "snippet": "void f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\tif (is_merged_page(sbi, page, type))\n\t\t\tf2fs_submit_merged_bio(sbi, type, WRITE);\n\t\twait_on_page_writeback(page);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic void truncate_inline_data(struct page *ipage)\n{\n\tf2fs_wait_on_page_writeback(ipage, NODE);\n\tmemset(inline_data_addr(ipage), 0, MAX_INLINE_DATA);\n}"
  },
  {
    "function_name": "read_inline_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inline.c",
    "lines": "33-51",
    "snippet": "void read_inline_data(struct page *page, struct page *ipage)\n{\n\tvoid *src_addr, *dst_addr;\n\n\tif (PageUptodate(page))\n\t\treturn;\n\n\tf2fs_bug_on(F2FS_P_SB(page), page->index);\n\n\tzero_user_segment(page, MAX_INLINE_DATA, PAGE_CACHE_SIZE);\n\n\t/* Copy the whole inline data block */\n\tsrc_addr = inline_data_addr(ipage);\n\tdst_addr = kmap_atomic(page);\n\tmemcpy(dst_addr, src_addr, MAX_INLINE_DATA);\n\tflush_dcache_page(page);\n\tkunmap_atomic(dst_addr);\n\tSetPageUptodate(page);\n}",
    "includes": [
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "dst_addr"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst_addr",
            "src_addr",
            "MAX_INLINE_DATA"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inline_data_addr",
          "args": [
            "ipage"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "inline_data_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1282-1286",
          "snippet": "static inline void *inline_data_addr(struct page *page)\n{\n\tstruct f2fs_inode *ri = F2FS_INODE(page);\n\treturn (void *)&(ri->i_addr[1]);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *inline_data_addr(struct page *page)\n{\n\tstruct f2fs_inode *ri = F2FS_INODE(page);\n\treturn (void *)&(ri->i_addr[1]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "page",
            "MAX_INLINE_DATA",
            "PAGE_CACHE_SIZE"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_bug_on",
          "args": [
            "F2FS_P_SB(page)",
            "page->index"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_P_SB",
          "args": [
            "page"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_P_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "655-658",
          "snippet": "static inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)\n{\n\treturn F2FS_M_SB(page->mapping);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)\n{\n\treturn F2FS_M_SB(page->mapping);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid read_inline_data(struct page *page, struct page *ipage)\n{\n\tvoid *src_addr, *dst_addr;\n\n\tif (PageUptodate(page))\n\t\treturn;\n\n\tf2fs_bug_on(F2FS_P_SB(page), page->index);\n\n\tzero_user_segment(page, MAX_INLINE_DATA, PAGE_CACHE_SIZE);\n\n\t/* Copy the whole inline data block */\n\tsrc_addr = inline_data_addr(ipage);\n\tdst_addr = kmap_atomic(page);\n\tmemcpy(dst_addr, src_addr, MAX_INLINE_DATA);\n\tflush_dcache_page(page);\n\tkunmap_atomic(dst_addr);\n\tSetPageUptodate(page);\n}"
  },
  {
    "function_name": "f2fs_may_inline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inline.c",
    "lines": "16-31",
    "snippet": "bool f2fs_may_inline(struct inode *inode)\n{\n\tif (!test_opt(F2FS_I_SB(inode), INLINE_DATA))\n\t\treturn false;\n\n\tif (f2fs_is_atomic_file(inode))\n\t\treturn false;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn false;\n\n\tif (i_size_read(inode) > MAX_INLINE_DATA)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_is_atomic_file",
          "args": [
            "inode"
          ],
          "line": 21
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_is_atomic_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1267-1270",
          "snippet": "static inline bool f2fs_is_atomic_file(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_ATOMIC_FILE);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline bool f2fs_is_atomic_file(struct inode *inode)\n{\n\treturn is_inode_flag_set(F2FS_I(inode), FI_ATOMIC_FILE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "F2FS_I_SB(inode)",
            "INLINE_DATA"
          ],
          "line": 18
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "inode"
          ],
          "line": 18
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nbool f2fs_may_inline(struct inode *inode)\n{\n\tif (!test_opt(F2FS_I_SB(inode), INLINE_DATA))\n\t\treturn false;\n\n\tif (f2fs_is_atomic_file(inode))\n\t\treturn false;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn false;\n\n\tif (i_size_read(inode) > MAX_INLINE_DATA)\n\t\treturn false;\n\n\treturn true;\n}"
  }
]