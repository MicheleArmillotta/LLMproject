[
  {
    "function_name": "check_message_signature",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "3822-3827",
    "snippet": "static int check_message_signature(struct ceph_connection *con, struct ceph_msg *msg)\n{\n       struct ceph_mds_session *s = con->private;\n       struct ceph_auth_handshake *auth = &s->s_auth;\n       return ceph_auth_check_message_signature(auth, msg);\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_auth_check_message_signature",
          "args": [
            "auth",
            "msg"
          ],
          "line": 3826
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int check_message_signature(struct ceph_connection *con, struct ceph_msg *msg)\n{\n       struct ceph_mds_session *s = con->private;\n       struct ceph_auth_handshake *auth = &s->s_auth;\n       return ceph_auth_check_message_signature(auth, msg);\n}"
  },
  {
    "function_name": "sign_message",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "3815-3820",
    "snippet": "static int sign_message(struct ceph_connection *con, struct ceph_msg *msg)\n{\n       struct ceph_mds_session *s = con->private;\n       struct ceph_auth_handshake *auth = &s->s_auth;\n       return ceph_auth_sign_message(auth, msg);\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_auth_sign_message",
          "args": [
            "auth",
            "msg"
          ],
          "line": 3819
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int sign_message(struct ceph_connection *con, struct ceph_msg *msg)\n{\n       struct ceph_mds_session *s = con->private;\n       struct ceph_auth_handshake *auth = &s->s_auth;\n       return ceph_auth_sign_message(auth, msg);\n}"
  },
  {
    "function_name": "mds_alloc_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "3794-3813",
    "snippet": "static struct ceph_msg *mds_alloc_msg(struct ceph_connection *con,\n\t\t\t\tstruct ceph_msg_header *hdr, int *skip)\n{\n\tstruct ceph_msg *msg;\n\tint type = (int) le16_to_cpu(hdr->type);\n\tint front_len = (int) le32_to_cpu(hdr->front_len);\n\n\tif (con->in_msg)\n\t\treturn con->in_msg;\n\n\t*skip = 0;\n\tmsg = ceph_msg_new(type, front_len, GFP_NOFS, false);\n\tif (!msg) {\n\t\tpr_err(\"unable to allocate msg type %d len %d\\n\",\n\t\t       type, front_len);\n\t\treturn NULL;\n\t}\n\n\treturn msg;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"unable to allocate msg type %d len %d\\n\"",
            "type",
            "front_len"
          ],
          "line": 3807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_msg_new",
          "args": [
            "type",
            "front_len",
            "GFP_NOFS",
            "false"
          ],
          "line": 3805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "hdr->front_len"
          ],
          "line": 3799
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "hdr->type"
          ],
          "line": 3798
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_msg *mds_alloc_msg(struct ceph_connection *con,\n\t\t\t\tstruct ceph_msg_header *hdr, int *skip)\n{\n\tstruct ceph_msg *msg;\n\tint type = (int) le16_to_cpu(hdr->type);\n\tint front_len = (int) le32_to_cpu(hdr->front_len);\n\n\tif (con->in_msg)\n\t\treturn con->in_msg;\n\n\t*skip = 0;\n\tmsg = ceph_msg_new(type, front_len, GFP_NOFS, false);\n\tif (!msg) {\n\t\tpr_err(\"unable to allocate msg type %d len %d\\n\",\n\t\t       type, front_len);\n\t\treturn NULL;\n\t}\n\n\treturn msg;\n}"
  },
  {
    "function_name": "invalidate_authorizer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "3783-3792",
    "snippet": "static int invalidate_authorizer(struct ceph_connection *con)\n{\n\tstruct ceph_mds_session *s = con->private;\n\tstruct ceph_mds_client *mdsc = s->s_mdsc;\n\tstruct ceph_auth_client *ac = mdsc->fsc->client->monc.auth;\n\n\tceph_auth_invalidate_authorizer(ac, CEPH_ENTITY_TYPE_MDS);\n\n\treturn ceph_monc_validate_auth(&mdsc->fsc->client->monc);\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_monc_validate_auth",
          "args": [
            "&mdsc->fsc->client->monc"
          ],
          "line": 3791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_auth_invalidate_authorizer",
          "args": [
            "ac",
            "CEPH_ENTITY_TYPE_MDS"
          ],
          "line": 3789
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int invalidate_authorizer(struct ceph_connection *con)\n{\n\tstruct ceph_mds_session *s = con->private;\n\tstruct ceph_mds_client *mdsc = s->s_mdsc;\n\tstruct ceph_auth_client *ac = mdsc->fsc->client->monc.auth;\n\n\tceph_auth_invalidate_authorizer(ac, CEPH_ENTITY_TYPE_MDS);\n\n\treturn ceph_monc_validate_auth(&mdsc->fsc->client->monc);\n}"
  },
  {
    "function_name": "verify_authorizer_reply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "3774-3781",
    "snippet": "static int verify_authorizer_reply(struct ceph_connection *con, int len)\n{\n\tstruct ceph_mds_session *s = con->private;\n\tstruct ceph_mds_client *mdsc = s->s_mdsc;\n\tstruct ceph_auth_client *ac = mdsc->fsc->client->monc.auth;\n\n\treturn ceph_auth_verify_authorizer_reply(ac, s->s_auth.authorizer, len);\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_auth_verify_authorizer_reply",
          "args": [
            "ac",
            "s->s_auth.authorizer",
            "len"
          ],
          "line": 3780
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int verify_authorizer_reply(struct ceph_connection *con, int len)\n{\n\tstruct ceph_mds_session *s = con->private;\n\tstruct ceph_mds_client *mdsc = s->s_mdsc;\n\tstruct ceph_auth_client *ac = mdsc->fsc->client->monc.auth;\n\n\treturn ceph_auth_verify_authorizer_reply(ac, s->s_auth.authorizer, len);\n}"
  },
  {
    "function_name": "get_authorizer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "3745-3771",
    "snippet": "static struct ceph_auth_handshake *get_authorizer(struct ceph_connection *con,\n\t\t\t\t\tint *proto, int force_new)\n{\n\tstruct ceph_mds_session *s = con->private;\n\tstruct ceph_mds_client *mdsc = s->s_mdsc;\n\tstruct ceph_auth_client *ac = mdsc->fsc->client->monc.auth;\n\tstruct ceph_auth_handshake *auth = &s->s_auth;\n\n\tif (force_new && auth->authorizer) {\n\t\tceph_auth_destroy_authorizer(ac, auth->authorizer);\n\t\tauth->authorizer = NULL;\n\t}\n\tif (!auth->authorizer) {\n\t\tint ret = ceph_auth_create_authorizer(ac, CEPH_ENTITY_TYPE_MDS,\n\t\t\t\t\t\t      auth);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t} else {\n\t\tint ret = ceph_auth_update_authorizer(ac, CEPH_ENTITY_TYPE_MDS,\n\t\t\t\t\t\t      auth);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\t*proto = ac->protocol;\n\n\treturn auth;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 3766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_auth_update_authorizer",
          "args": [
            "ac",
            "CEPH_ENTITY_TYPE_MDS",
            "auth"
          ],
          "line": 3763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 3761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_auth_create_authorizer",
          "args": [
            "ac",
            "CEPH_ENTITY_TYPE_MDS",
            "auth"
          ],
          "line": 3758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_auth_destroy_authorizer",
          "args": [
            "ac",
            "auth->authorizer"
          ],
          "line": 3754
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_auth_handshake *get_authorizer(struct ceph_connection *con,\n\t\t\t\t\tint *proto, int force_new)\n{\n\tstruct ceph_mds_session *s = con->private;\n\tstruct ceph_mds_client *mdsc = s->s_mdsc;\n\tstruct ceph_auth_client *ac = mdsc->fsc->client->monc.auth;\n\tstruct ceph_auth_handshake *auth = &s->s_auth;\n\n\tif (force_new && auth->authorizer) {\n\t\tceph_auth_destroy_authorizer(ac, auth->authorizer);\n\t\tauth->authorizer = NULL;\n\t}\n\tif (!auth->authorizer) {\n\t\tint ret = ceph_auth_create_authorizer(ac, CEPH_ENTITY_TYPE_MDS,\n\t\t\t\t\t\t      auth);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t} else {\n\t\tint ret = ceph_auth_update_authorizer(ac, CEPH_ENTITY_TYPE_MDS,\n\t\t\t\t\t\t      auth);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\t*proto = ac->protocol;\n\n\treturn auth;\n}"
  },
  {
    "function_name": "dispatch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "3693-3735",
    "snippet": "static void dispatch(struct ceph_connection *con, struct ceph_msg *msg)\n{\n\tstruct ceph_mds_session *s = con->private;\n\tstruct ceph_mds_client *mdsc = s->s_mdsc;\n\tint type = le16_to_cpu(msg->hdr.type);\n\n\tmutex_lock(&mdsc->mutex);\n\tif (__verify_registered_session(mdsc, s) < 0) {\n\t\tmutex_unlock(&mdsc->mutex);\n\t\tgoto out;\n\t}\n\tmutex_unlock(&mdsc->mutex);\n\n\tswitch (type) {\n\tcase CEPH_MSG_MDS_MAP:\n\t\tceph_mdsc_handle_map(mdsc, msg);\n\t\tbreak;\n\tcase CEPH_MSG_CLIENT_SESSION:\n\t\thandle_session(s, msg);\n\t\tbreak;\n\tcase CEPH_MSG_CLIENT_REPLY:\n\t\thandle_reply(s, msg);\n\t\tbreak;\n\tcase CEPH_MSG_CLIENT_REQUEST_FORWARD:\n\t\thandle_forward(mdsc, s, msg);\n\t\tbreak;\n\tcase CEPH_MSG_CLIENT_CAPS:\n\t\tceph_handle_caps(s, msg);\n\t\tbreak;\n\tcase CEPH_MSG_CLIENT_SNAP:\n\t\tceph_handle_snap(mdsc, s, msg);\n\t\tbreak;\n\tcase CEPH_MSG_CLIENT_LEASE:\n\t\thandle_lease(mdsc, s, msg);\n\t\tbreak;\n\n\tdefault:\n\t\tpr_err(\"received unknown message type %d %s\\n\", type,\n\t\t       ceph_msg_type_name(type));\n\t}\nout:\n\tceph_msg_put(msg);\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_msg_put",
          "args": [
            "msg"
          ],
          "line": 3734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"received unknown message type %d %s\\n\"",
            "type",
            "ceph_msg_type_name(type)"
          ],
          "line": 3730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_msg_type_name",
          "args": [
            "type"
          ],
          "line": 3731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_lease",
          "args": [
            "mdsc",
            "s",
            "msg"
          ],
          "line": 3726
        },
        "resolved": true,
        "details": {
          "function_name": "handle_lease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "3063-3166",
          "snippet": "static void handle_lease(struct ceph_mds_client *mdsc,\n\t\t\t struct ceph_mds_session *session,\n\t\t\t struct ceph_msg *msg)\n{\n\tstruct super_block *sb = mdsc->fsc->sb;\n\tstruct inode *inode;\n\tstruct dentry *parent, *dentry;\n\tstruct ceph_dentry_info *di;\n\tint mds = session->s_mds;\n\tstruct ceph_mds_lease *h = msg->front.iov_base;\n\tu32 seq;\n\tstruct ceph_vino vino;\n\tstruct qstr dname;\n\tint release = 0;\n\n\tdout(\"handle_lease from mds%d\\n\", mds);\n\n\t/* decode */\n\tif (msg->front.iov_len < sizeof(*h) + sizeof(u32))\n\t\tgoto bad;\n\tvino.ino = le64_to_cpu(h->ino);\n\tvino.snap = CEPH_NOSNAP;\n\tseq = le32_to_cpu(h->seq);\n\tdname.name = (void *)h + sizeof(*h) + sizeof(u32);\n\tdname.len = msg->front.iov_len - sizeof(*h) - sizeof(u32);\n\tif (dname.len != get_unaligned_le32(h+1))\n\t\tgoto bad;\n\n\t/* lookup inode */\n\tinode = ceph_find_inode(sb, vino);\n\tdout(\"handle_lease %s, ino %llx %p %.*s\\n\",\n\t     ceph_lease_op_name(h->action), vino.ino, inode,\n\t     dname.len, dname.name);\n\n\tmutex_lock(&session->s_mutex);\n\tsession->s_seq++;\n\n\tif (inode == NULL) {\n\t\tdout(\"handle_lease no inode %llx\\n\", vino.ino);\n\t\tgoto release;\n\t}\n\n\t/* dentry */\n\tparent = d_find_alias(inode);\n\tif (!parent) {\n\t\tdout(\"no parent dentry on inode %p\\n\", inode);\n\t\tWARN_ON(1);\n\t\tgoto release;  /* hrm... */\n\t}\n\tdname.hash = full_name_hash(dname.name, dname.len);\n\tdentry = d_lookup(parent, &dname);\n\tdput(parent);\n\tif (!dentry)\n\t\tgoto release;\n\n\tspin_lock(&dentry->d_lock);\n\tdi = ceph_dentry(dentry);\n\tswitch (h->action) {\n\tcase CEPH_MDS_LEASE_REVOKE:\n\t\tif (di->lease_session == session) {\n\t\t\tif (ceph_seq_cmp(di->lease_seq, seq) > 0)\n\t\t\t\th->seq = cpu_to_le32(di->lease_seq);\n\t\t\t__ceph_mdsc_drop_dentry_lease(dentry);\n\t\t}\n\t\trelease = 1;\n\t\tbreak;\n\n\tcase CEPH_MDS_LEASE_RENEW:\n\t\tif (di->lease_session == session &&\n\t\t    di->lease_gen == session->s_cap_gen &&\n\t\t    di->lease_renew_from &&\n\t\t    di->lease_renew_after == 0) {\n\t\t\tunsigned long duration =\n\t\t\t\tle32_to_cpu(h->duration_ms) * HZ / 1000;\n\n\t\t\tdi->lease_seq = seq;\n\t\t\tdentry->d_time = di->lease_renew_from + duration;\n\t\t\tdi->lease_renew_after = di->lease_renew_from +\n\t\t\t\t(duration >> 1);\n\t\t\tdi->lease_renew_from = 0;\n\t\t}\n\t\tbreak;\n\t}\n\tspin_unlock(&dentry->d_lock);\n\tdput(dentry);\n\n\tif (!release)\n\t\tgoto out;\n\nrelease:\n\t/* let's just reuse the same message */\n\th->action = CEPH_MDS_LEASE_REVOKE_ACK;\n\tceph_msg_get(msg);\n\tceph_con_send(&session->s_con, msg);\n\nout:\n\tiput(inode);\n\tmutex_unlock(&session->s_mutex);\n\treturn;\n\nbad:\n\tpr_err(\"corrupt lease message\\n\");\n\tceph_msg_dump(msg);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void handle_lease(struct ceph_mds_client *mdsc,\n\t\t\t struct ceph_mds_session *session,\n\t\t\t struct ceph_msg *msg)\n{\n\tstruct super_block *sb = mdsc->fsc->sb;\n\tstruct inode *inode;\n\tstruct dentry *parent, *dentry;\n\tstruct ceph_dentry_info *di;\n\tint mds = session->s_mds;\n\tstruct ceph_mds_lease *h = msg->front.iov_base;\n\tu32 seq;\n\tstruct ceph_vino vino;\n\tstruct qstr dname;\n\tint release = 0;\n\n\tdout(\"handle_lease from mds%d\\n\", mds);\n\n\t/* decode */\n\tif (msg->front.iov_len < sizeof(*h) + sizeof(u32))\n\t\tgoto bad;\n\tvino.ino = le64_to_cpu(h->ino);\n\tvino.snap = CEPH_NOSNAP;\n\tseq = le32_to_cpu(h->seq);\n\tdname.name = (void *)h + sizeof(*h) + sizeof(u32);\n\tdname.len = msg->front.iov_len - sizeof(*h) - sizeof(u32);\n\tif (dname.len != get_unaligned_le32(h+1))\n\t\tgoto bad;\n\n\t/* lookup inode */\n\tinode = ceph_find_inode(sb, vino);\n\tdout(\"handle_lease %s, ino %llx %p %.*s\\n\",\n\t     ceph_lease_op_name(h->action), vino.ino, inode,\n\t     dname.len, dname.name);\n\n\tmutex_lock(&session->s_mutex);\n\tsession->s_seq++;\n\n\tif (inode == NULL) {\n\t\tdout(\"handle_lease no inode %llx\\n\", vino.ino);\n\t\tgoto release;\n\t}\n\n\t/* dentry */\n\tparent = d_find_alias(inode);\n\tif (!parent) {\n\t\tdout(\"no parent dentry on inode %p\\n\", inode);\n\t\tWARN_ON(1);\n\t\tgoto release;  /* hrm... */\n\t}\n\tdname.hash = full_name_hash(dname.name, dname.len);\n\tdentry = d_lookup(parent, &dname);\n\tdput(parent);\n\tif (!dentry)\n\t\tgoto release;\n\n\tspin_lock(&dentry->d_lock);\n\tdi = ceph_dentry(dentry);\n\tswitch (h->action) {\n\tcase CEPH_MDS_LEASE_REVOKE:\n\t\tif (di->lease_session == session) {\n\t\t\tif (ceph_seq_cmp(di->lease_seq, seq) > 0)\n\t\t\t\th->seq = cpu_to_le32(di->lease_seq);\n\t\t\t__ceph_mdsc_drop_dentry_lease(dentry);\n\t\t}\n\t\trelease = 1;\n\t\tbreak;\n\n\tcase CEPH_MDS_LEASE_RENEW:\n\t\tif (di->lease_session == session &&\n\t\t    di->lease_gen == session->s_cap_gen &&\n\t\t    di->lease_renew_from &&\n\t\t    di->lease_renew_after == 0) {\n\t\t\tunsigned long duration =\n\t\t\t\tle32_to_cpu(h->duration_ms) * HZ / 1000;\n\n\t\t\tdi->lease_seq = seq;\n\t\t\tdentry->d_time = di->lease_renew_from + duration;\n\t\t\tdi->lease_renew_after = di->lease_renew_from +\n\t\t\t\t(duration >> 1);\n\t\t\tdi->lease_renew_from = 0;\n\t\t}\n\t\tbreak;\n\t}\n\tspin_unlock(&dentry->d_lock);\n\tdput(dentry);\n\n\tif (!release)\n\t\tgoto out;\n\nrelease:\n\t/* let's just reuse the same message */\n\th->action = CEPH_MDS_LEASE_REVOKE_ACK;\n\tceph_msg_get(msg);\n\tceph_con_send(&session->s_con, msg);\n\nout:\n\tiput(inode);\n\tmutex_unlock(&session->s_mutex);\n\treturn;\n\nbad:\n\tpr_err(\"corrupt lease message\\n\");\n\tceph_msg_dump(msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_handle_snap",
          "args": [
            "mdsc",
            "s",
            "msg"
          ],
          "line": 3723
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_handle_snap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
          "lines": "805-963",
          "snippet": "void ceph_handle_snap(struct ceph_mds_client *mdsc,\n\t\t      struct ceph_mds_session *session,\n\t\t      struct ceph_msg *msg)\n{\n\tstruct super_block *sb = mdsc->fsc->sb;\n\tint mds = session->s_mds;\n\tu64 split;\n\tint op;\n\tint trace_len;\n\tstruct ceph_snap_realm *realm = NULL;\n\tvoid *p = msg->front.iov_base;\n\tvoid *e = p + msg->front.iov_len;\n\tstruct ceph_mds_snap_head *h;\n\tint num_split_inos, num_split_realms;\n\t__le64 *split_inos = NULL, *split_realms = NULL;\n\tint i;\n\tint locked_rwsem = 0;\n\n\t/* decode */\n\tif (msg->front.iov_len < sizeof(*h))\n\t\tgoto bad;\n\th = p;\n\top = le32_to_cpu(h->op);\n\tsplit = le64_to_cpu(h->split);   /* non-zero if we are splitting an\n\t\t\t\t\t  * existing realm */\n\tnum_split_inos = le32_to_cpu(h->num_split_inos);\n\tnum_split_realms = le32_to_cpu(h->num_split_realms);\n\ttrace_len = le32_to_cpu(h->trace_len);\n\tp += sizeof(*h);\n\n\tdout(\"handle_snap from mds%d op %s split %llx tracelen %d\\n\", mds,\n\t     ceph_snap_op_name(op), split, trace_len);\n\n\tmutex_lock(&session->s_mutex);\n\tsession->s_seq++;\n\tmutex_unlock(&session->s_mutex);\n\n\tdown_write(&mdsc->snap_rwsem);\n\tlocked_rwsem = 1;\n\n\tif (op == CEPH_SNAP_OP_SPLIT) {\n\t\tstruct ceph_mds_snap_realm *ri;\n\n\t\t/*\n\t\t * A \"split\" breaks part of an existing realm off into\n\t\t * a new realm.  The MDS provides a list of inodes\n\t\t * (with caps) and child realms that belong to the new\n\t\t * child.\n\t\t */\n\t\tsplit_inos = p;\n\t\tp += sizeof(u64) * num_split_inos;\n\t\tsplit_realms = p;\n\t\tp += sizeof(u64) * num_split_realms;\n\t\tceph_decode_need(&p, e, sizeof(*ri), bad);\n\t\t/* we will peek at realm info here, but will _not_\n\t\t * advance p, as the realm update will occur below in\n\t\t * ceph_update_snap_trace. */\n\t\tri = p;\n\n\t\trealm = ceph_lookup_snap_realm(mdsc, split);\n\t\tif (!realm) {\n\t\t\trealm = ceph_create_snap_realm(mdsc, split);\n\t\t\tif (IS_ERR(realm))\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tdout(\"splitting snap_realm %llx %p\\n\", realm->ino, realm);\n\t\tfor (i = 0; i < num_split_inos; i++) {\n\t\t\tstruct ceph_vino vino = {\n\t\t\t\t.ino = le64_to_cpu(split_inos[i]),\n\t\t\t\t.snap = CEPH_NOSNAP,\n\t\t\t};\n\t\t\tstruct inode *inode = ceph_find_inode(sb, vino);\n\t\t\tstruct ceph_inode_info *ci;\n\t\t\tstruct ceph_snap_realm *oldrealm;\n\n\t\t\tif (!inode)\n\t\t\t\tcontinue;\n\t\t\tci = ceph_inode(inode);\n\n\t\t\tspin_lock(&ci->i_ceph_lock);\n\t\t\tif (!ci->i_snap_realm)\n\t\t\t\tgoto skip_inode;\n\t\t\t/*\n\t\t\t * If this inode belongs to a realm that was\n\t\t\t * created after our new realm, we experienced\n\t\t\t * a race (due to another split notifications\n\t\t\t * arriving from a different MDS).  So skip\n\t\t\t * this inode.\n\t\t\t */\n\t\t\tif (ci->i_snap_realm->created >\n\t\t\t    le64_to_cpu(ri->created)) {\n\t\t\t\tdout(\" leaving %p in newer realm %llx %p\\n\",\n\t\t\t\t     inode, ci->i_snap_realm->ino,\n\t\t\t\t     ci->i_snap_realm);\n\t\t\t\tgoto skip_inode;\n\t\t\t}\n\t\t\tdout(\" will move %p to split realm %llx %p\\n\",\n\t\t\t     inode, realm->ino, realm);\n\t\t\t/*\n\t\t\t * Move the inode to the new realm\n\t\t\t */\n\t\t\tspin_lock(&realm->inodes_with_caps_lock);\n\t\t\tlist_del_init(&ci->i_snap_realm_item);\n\t\t\tlist_add(&ci->i_snap_realm_item,\n\t\t\t\t &realm->inodes_with_caps);\n\t\t\toldrealm = ci->i_snap_realm;\n\t\t\tci->i_snap_realm = realm;\n\t\t\tspin_unlock(&realm->inodes_with_caps_lock);\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\n\t\t\tceph_get_snap_realm(mdsc, realm);\n\t\t\tceph_put_snap_realm(mdsc, oldrealm);\n\n\t\t\tiput(inode);\n\t\t\tcontinue;\n\nskip_inode:\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\tiput(inode);\n\t\t}\n\n\t\t/* we may have taken some of the old realm's children. */\n\t\tfor (i = 0; i < num_split_realms; i++) {\n\t\t\tstruct ceph_snap_realm *child =\n\t\t\t\t__lookup_snap_realm(mdsc,\n\t\t\t\t\t   le64_to_cpu(split_realms[i]));\n\t\t\tif (!child)\n\t\t\t\tcontinue;\n\t\t\tadjust_snap_realm_parent(mdsc, child, realm->ino);\n\t\t}\n\t}\n\n\t/*\n\t * update using the provided snap trace. if we are deleting a\n\t * snap, we can avoid queueing cap_snaps.\n\t */\n\tceph_update_snap_trace(mdsc, p, e,\n\t\t\t       op == CEPH_SNAP_OP_DESTROY, NULL);\n\n\tif (op == CEPH_SNAP_OP_SPLIT)\n\t\t/* we took a reference when we created the realm, above */\n\t\tceph_put_snap_realm(mdsc, realm);\n\n\t__cleanup_empty_realms(mdsc);\n\n\tup_write(&mdsc->snap_rwsem);\n\n\tflush_snaps(mdsc);\n\treturn;\n\nbad:\n\tpr_err(\"corrupt snap message from mds%d\\n\", mds);\n\tceph_msg_dump(msg);\nout:\n\tif (locked_rwsem)\n\t\tup_write(&mdsc->snap_rwsem);\n\treturn;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);\n\nvoid ceph_handle_snap(struct ceph_mds_client *mdsc,\n\t\t      struct ceph_mds_session *session,\n\t\t      struct ceph_msg *msg)\n{\n\tstruct super_block *sb = mdsc->fsc->sb;\n\tint mds = session->s_mds;\n\tu64 split;\n\tint op;\n\tint trace_len;\n\tstruct ceph_snap_realm *realm = NULL;\n\tvoid *p = msg->front.iov_base;\n\tvoid *e = p + msg->front.iov_len;\n\tstruct ceph_mds_snap_head *h;\n\tint num_split_inos, num_split_realms;\n\t__le64 *split_inos = NULL, *split_realms = NULL;\n\tint i;\n\tint locked_rwsem = 0;\n\n\t/* decode */\n\tif (msg->front.iov_len < sizeof(*h))\n\t\tgoto bad;\n\th = p;\n\top = le32_to_cpu(h->op);\n\tsplit = le64_to_cpu(h->split);   /* non-zero if we are splitting an\n\t\t\t\t\t  * existing realm */\n\tnum_split_inos = le32_to_cpu(h->num_split_inos);\n\tnum_split_realms = le32_to_cpu(h->num_split_realms);\n\ttrace_len = le32_to_cpu(h->trace_len);\n\tp += sizeof(*h);\n\n\tdout(\"handle_snap from mds%d op %s split %llx tracelen %d\\n\", mds,\n\t     ceph_snap_op_name(op), split, trace_len);\n\n\tmutex_lock(&session->s_mutex);\n\tsession->s_seq++;\n\tmutex_unlock(&session->s_mutex);\n\n\tdown_write(&mdsc->snap_rwsem);\n\tlocked_rwsem = 1;\n\n\tif (op == CEPH_SNAP_OP_SPLIT) {\n\t\tstruct ceph_mds_snap_realm *ri;\n\n\t\t/*\n\t\t * A \"split\" breaks part of an existing realm off into\n\t\t * a new realm.  The MDS provides a list of inodes\n\t\t * (with caps) and child realms that belong to the new\n\t\t * child.\n\t\t */\n\t\tsplit_inos = p;\n\t\tp += sizeof(u64) * num_split_inos;\n\t\tsplit_realms = p;\n\t\tp += sizeof(u64) * num_split_realms;\n\t\tceph_decode_need(&p, e, sizeof(*ri), bad);\n\t\t/* we will peek at realm info here, but will _not_\n\t\t * advance p, as the realm update will occur below in\n\t\t * ceph_update_snap_trace. */\n\t\tri = p;\n\n\t\trealm = ceph_lookup_snap_realm(mdsc, split);\n\t\tif (!realm) {\n\t\t\trealm = ceph_create_snap_realm(mdsc, split);\n\t\t\tif (IS_ERR(realm))\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tdout(\"splitting snap_realm %llx %p\\n\", realm->ino, realm);\n\t\tfor (i = 0; i < num_split_inos; i++) {\n\t\t\tstruct ceph_vino vino = {\n\t\t\t\t.ino = le64_to_cpu(split_inos[i]),\n\t\t\t\t.snap = CEPH_NOSNAP,\n\t\t\t};\n\t\t\tstruct inode *inode = ceph_find_inode(sb, vino);\n\t\t\tstruct ceph_inode_info *ci;\n\t\t\tstruct ceph_snap_realm *oldrealm;\n\n\t\t\tif (!inode)\n\t\t\t\tcontinue;\n\t\t\tci = ceph_inode(inode);\n\n\t\t\tspin_lock(&ci->i_ceph_lock);\n\t\t\tif (!ci->i_snap_realm)\n\t\t\t\tgoto skip_inode;\n\t\t\t/*\n\t\t\t * If this inode belongs to a realm that was\n\t\t\t * created after our new realm, we experienced\n\t\t\t * a race (due to another split notifications\n\t\t\t * arriving from a different MDS).  So skip\n\t\t\t * this inode.\n\t\t\t */\n\t\t\tif (ci->i_snap_realm->created >\n\t\t\t    le64_to_cpu(ri->created)) {\n\t\t\t\tdout(\" leaving %p in newer realm %llx %p\\n\",\n\t\t\t\t     inode, ci->i_snap_realm->ino,\n\t\t\t\t     ci->i_snap_realm);\n\t\t\t\tgoto skip_inode;\n\t\t\t}\n\t\t\tdout(\" will move %p to split realm %llx %p\\n\",\n\t\t\t     inode, realm->ino, realm);\n\t\t\t/*\n\t\t\t * Move the inode to the new realm\n\t\t\t */\n\t\t\tspin_lock(&realm->inodes_with_caps_lock);\n\t\t\tlist_del_init(&ci->i_snap_realm_item);\n\t\t\tlist_add(&ci->i_snap_realm_item,\n\t\t\t\t &realm->inodes_with_caps);\n\t\t\toldrealm = ci->i_snap_realm;\n\t\t\tci->i_snap_realm = realm;\n\t\t\tspin_unlock(&realm->inodes_with_caps_lock);\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\n\t\t\tceph_get_snap_realm(mdsc, realm);\n\t\t\tceph_put_snap_realm(mdsc, oldrealm);\n\n\t\t\tiput(inode);\n\t\t\tcontinue;\n\nskip_inode:\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\tiput(inode);\n\t\t}\n\n\t\t/* we may have taken some of the old realm's children. */\n\t\tfor (i = 0; i < num_split_realms; i++) {\n\t\t\tstruct ceph_snap_realm *child =\n\t\t\t\t__lookup_snap_realm(mdsc,\n\t\t\t\t\t   le64_to_cpu(split_realms[i]));\n\t\t\tif (!child)\n\t\t\t\tcontinue;\n\t\t\tadjust_snap_realm_parent(mdsc, child, realm->ino);\n\t\t}\n\t}\n\n\t/*\n\t * update using the provided snap trace. if we are deleting a\n\t * snap, we can avoid queueing cap_snaps.\n\t */\n\tceph_update_snap_trace(mdsc, p, e,\n\t\t\t       op == CEPH_SNAP_OP_DESTROY, NULL);\n\n\tif (op == CEPH_SNAP_OP_SPLIT)\n\t\t/* we took a reference when we created the realm, above */\n\t\tceph_put_snap_realm(mdsc, realm);\n\n\t__cleanup_empty_realms(mdsc);\n\n\tup_write(&mdsc->snap_rwsem);\n\n\tflush_snaps(mdsc);\n\treturn;\n\nbad:\n\tpr_err(\"corrupt snap message from mds%d\\n\", mds);\n\tceph_msg_dump(msg);\nout:\n\tif (locked_rwsem)\n\t\tup_write(&mdsc->snap_rwsem);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_handle_caps",
          "args": [
            "s",
            "msg"
          ],
          "line": 3720
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_handle_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "3053-3241",
          "snippet": "void ceph_handle_caps(struct ceph_mds_session *session,\n\t\t      struct ceph_msg *msg)\n{\n\tstruct ceph_mds_client *mdsc = session->s_mdsc;\n\tstruct super_block *sb = mdsc->fsc->sb;\n\tstruct inode *inode;\n\tstruct ceph_inode_info *ci;\n\tstruct ceph_cap *cap;\n\tstruct ceph_mds_caps *h;\n\tstruct ceph_mds_cap_peer *peer = NULL;\n\tstruct ceph_snap_realm *realm;\n\tint mds = session->s_mds;\n\tint op, issued;\n\tu32 seq, mseq;\n\tstruct ceph_vino vino;\n\tu64 cap_id;\n\tu64 size, max_size;\n\tu64 tid;\n\tu64 inline_version = 0;\n\tvoid *inline_data = NULL;\n\tu32  inline_len = 0;\n\tvoid *snaptrace;\n\tsize_t snaptrace_len;\n\tvoid *p, *end;\n\n\tdout(\"handle_caps from mds%d\\n\", mds);\n\n\t/* decode */\n\tend = msg->front.iov_base + msg->front.iov_len;\n\ttid = le64_to_cpu(msg->hdr.tid);\n\tif (msg->front.iov_len < sizeof(*h))\n\t\tgoto bad;\n\th = msg->front.iov_base;\n\top = le32_to_cpu(h->op);\n\tvino.ino = le64_to_cpu(h->ino);\n\tvino.snap = CEPH_NOSNAP;\n\tcap_id = le64_to_cpu(h->cap_id);\n\tseq = le32_to_cpu(h->seq);\n\tmseq = le32_to_cpu(h->migrate_seq);\n\tsize = le64_to_cpu(h->size);\n\tmax_size = le64_to_cpu(h->max_size);\n\n\tsnaptrace = h + 1;\n\tsnaptrace_len = le32_to_cpu(h->snap_trace_len);\n\tp = snaptrace + snaptrace_len;\n\n\tif (le16_to_cpu(msg->hdr.version) >= 2) {\n\t\tu32 flock_len;\n\t\tceph_decode_32_safe(&p, end, flock_len, bad);\n\t\tif (p + flock_len > end)\n\t\t\tgoto bad;\n\t\tp += flock_len;\n\t}\n\n\tif (le16_to_cpu(msg->hdr.version) >= 3) {\n\t\tif (op == CEPH_CAP_OP_IMPORT) {\n\t\t\tif (p + sizeof(*peer) > end)\n\t\t\t\tgoto bad;\n\t\t\tpeer = p;\n\t\t\tp += sizeof(*peer);\n\t\t} else if (op == CEPH_CAP_OP_EXPORT) {\n\t\t\t/* recorded in unused fields */\n\t\t\tpeer = (void *)&h->size;\n\t\t}\n\t}\n\n\tif (le16_to_cpu(msg->hdr.version) >= 4) {\n\t\tceph_decode_64_safe(&p, end, inline_version, bad);\n\t\tceph_decode_32_safe(&p, end, inline_len, bad);\n\t\tif (p + inline_len > end)\n\t\t\tgoto bad;\n\t\tinline_data = p;\n\t\tp += inline_len;\n\t}\n\n\t/* lookup ino */\n\tinode = ceph_find_inode(sb, vino);\n\tci = ceph_inode(inode);\n\tdout(\" op %s ino %llx.%llx inode %p\\n\", ceph_cap_op_name(op), vino.ino,\n\t     vino.snap, inode);\n\n\tmutex_lock(&session->s_mutex);\n\tsession->s_seq++;\n\tdout(\" mds%d seq %lld cap seq %u\\n\", session->s_mds, session->s_seq,\n\t     (unsigned)seq);\n\n\tif (op == CEPH_CAP_OP_IMPORT)\n\t\tceph_add_cap_releases(mdsc, session);\n\n\tif (!inode) {\n\t\tdout(\" i don't have ino %llx\\n\", vino.ino);\n\n\t\tif (op == CEPH_CAP_OP_IMPORT) {\n\t\t\tspin_lock(&session->s_cap_lock);\n\t\t\t__queue_cap_release(session, vino.ino, cap_id,\n\t\t\t\t\t    mseq, seq);\n\t\t\tspin_unlock(&session->s_cap_lock);\n\t\t}\n\t\tgoto flush_cap_releases;\n\t}\n\n\t/* these will work even if we don't have a cap yet */\n\tswitch (op) {\n\tcase CEPH_CAP_OP_FLUSHSNAP_ACK:\n\t\thandle_cap_flushsnap_ack(inode, tid, h, session);\n\t\tgoto done;\n\n\tcase CEPH_CAP_OP_EXPORT:\n\t\thandle_cap_export(inode, h, peer, session);\n\t\tgoto done_unlocked;\n\n\tcase CEPH_CAP_OP_IMPORT:\n\t\trealm = NULL;\n\t\tif (snaptrace_len) {\n\t\t\tdown_write(&mdsc->snap_rwsem);\n\t\t\tceph_update_snap_trace(mdsc, snaptrace,\n\t\t\t\t\t       snaptrace + snaptrace_len,\n\t\t\t\t\t       false, &realm);\n\t\t\tdowngrade_write(&mdsc->snap_rwsem);\n\t\t} else {\n\t\t\tdown_read(&mdsc->snap_rwsem);\n\t\t}\n\t\thandle_cap_import(mdsc, inode, h, peer, session,\n\t\t\t\t  &cap, &issued);\n\t\thandle_cap_grant(mdsc, inode, h,\n\t\t\t\t inline_version, inline_data, inline_len,\n\t\t\t\t msg->middle, session, cap, issued);\n\t\tif (realm)\n\t\t\tceph_put_snap_realm(mdsc, realm);\n\t\tgoto done_unlocked;\n\t}\n\n\t/* the rest require a cap */\n\tspin_lock(&ci->i_ceph_lock);\n\tcap = __get_cap_for_mds(ceph_inode(inode), mds);\n\tif (!cap) {\n\t\tdout(\" no cap on %p ino %llx.%llx from mds%d\\n\",\n\t\t     inode, ceph_ino(inode), ceph_snap(inode), mds);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tgoto flush_cap_releases;\n\t}\n\n\t/* note that each of these drops i_ceph_lock for us */\n\tswitch (op) {\n\tcase CEPH_CAP_OP_REVOKE:\n\tcase CEPH_CAP_OP_GRANT:\n\t\t__ceph_caps_issued(ci, &issued);\n\t\tissued |= __ceph_caps_dirty(ci);\n\t\thandle_cap_grant(mdsc, inode, h,\n\t\t\t\t inline_version, inline_data, inline_len,\n\t\t\t\t msg->middle, session, cap, issued);\n\t\tgoto done_unlocked;\n\n\tcase CEPH_CAP_OP_FLUSH_ACK:\n\t\thandle_cap_flush_ack(inode, tid, h, session, cap);\n\t\tbreak;\n\n\tcase CEPH_CAP_OP_TRUNC:\n\t\thandle_cap_trunc(inode, h, session);\n\t\tbreak;\n\n\tdefault:\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tpr_err(\"ceph_handle_caps: unknown cap op %d %s\\n\", op,\n\t\t       ceph_cap_op_name(op));\n\t}\n\n\tgoto done;\n\nflush_cap_releases:\n\t/*\n\t * send any full release message to try to move things\n\t * along for the mds (who clearly thinks we still have this\n\t * cap).\n\t */\n\tceph_add_cap_releases(mdsc, session);\n\tceph_send_cap_releases(mdsc, session);\n\ndone:\n\tmutex_unlock(&session->s_mutex);\ndone_unlocked:\n\tiput(inode);\n\treturn;\n\nbad:\n\tpr_err(\"ceph_handle_caps: corrupt message\\n\");\n\tceph_msg_dump(msg);\n\treturn;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_handle_caps(struct ceph_mds_session *session,\n\t\t      struct ceph_msg *msg)\n{\n\tstruct ceph_mds_client *mdsc = session->s_mdsc;\n\tstruct super_block *sb = mdsc->fsc->sb;\n\tstruct inode *inode;\n\tstruct ceph_inode_info *ci;\n\tstruct ceph_cap *cap;\n\tstruct ceph_mds_caps *h;\n\tstruct ceph_mds_cap_peer *peer = NULL;\n\tstruct ceph_snap_realm *realm;\n\tint mds = session->s_mds;\n\tint op, issued;\n\tu32 seq, mseq;\n\tstruct ceph_vino vino;\n\tu64 cap_id;\n\tu64 size, max_size;\n\tu64 tid;\n\tu64 inline_version = 0;\n\tvoid *inline_data = NULL;\n\tu32  inline_len = 0;\n\tvoid *snaptrace;\n\tsize_t snaptrace_len;\n\tvoid *p, *end;\n\n\tdout(\"handle_caps from mds%d\\n\", mds);\n\n\t/* decode */\n\tend = msg->front.iov_base + msg->front.iov_len;\n\ttid = le64_to_cpu(msg->hdr.tid);\n\tif (msg->front.iov_len < sizeof(*h))\n\t\tgoto bad;\n\th = msg->front.iov_base;\n\top = le32_to_cpu(h->op);\n\tvino.ino = le64_to_cpu(h->ino);\n\tvino.snap = CEPH_NOSNAP;\n\tcap_id = le64_to_cpu(h->cap_id);\n\tseq = le32_to_cpu(h->seq);\n\tmseq = le32_to_cpu(h->migrate_seq);\n\tsize = le64_to_cpu(h->size);\n\tmax_size = le64_to_cpu(h->max_size);\n\n\tsnaptrace = h + 1;\n\tsnaptrace_len = le32_to_cpu(h->snap_trace_len);\n\tp = snaptrace + snaptrace_len;\n\n\tif (le16_to_cpu(msg->hdr.version) >= 2) {\n\t\tu32 flock_len;\n\t\tceph_decode_32_safe(&p, end, flock_len, bad);\n\t\tif (p + flock_len > end)\n\t\t\tgoto bad;\n\t\tp += flock_len;\n\t}\n\n\tif (le16_to_cpu(msg->hdr.version) >= 3) {\n\t\tif (op == CEPH_CAP_OP_IMPORT) {\n\t\t\tif (p + sizeof(*peer) > end)\n\t\t\t\tgoto bad;\n\t\t\tpeer = p;\n\t\t\tp += sizeof(*peer);\n\t\t} else if (op == CEPH_CAP_OP_EXPORT) {\n\t\t\t/* recorded in unused fields */\n\t\t\tpeer = (void *)&h->size;\n\t\t}\n\t}\n\n\tif (le16_to_cpu(msg->hdr.version) >= 4) {\n\t\tceph_decode_64_safe(&p, end, inline_version, bad);\n\t\tceph_decode_32_safe(&p, end, inline_len, bad);\n\t\tif (p + inline_len > end)\n\t\t\tgoto bad;\n\t\tinline_data = p;\n\t\tp += inline_len;\n\t}\n\n\t/* lookup ino */\n\tinode = ceph_find_inode(sb, vino);\n\tci = ceph_inode(inode);\n\tdout(\" op %s ino %llx.%llx inode %p\\n\", ceph_cap_op_name(op), vino.ino,\n\t     vino.snap, inode);\n\n\tmutex_lock(&session->s_mutex);\n\tsession->s_seq++;\n\tdout(\" mds%d seq %lld cap seq %u\\n\", session->s_mds, session->s_seq,\n\t     (unsigned)seq);\n\n\tif (op == CEPH_CAP_OP_IMPORT)\n\t\tceph_add_cap_releases(mdsc, session);\n\n\tif (!inode) {\n\t\tdout(\" i don't have ino %llx\\n\", vino.ino);\n\n\t\tif (op == CEPH_CAP_OP_IMPORT) {\n\t\t\tspin_lock(&session->s_cap_lock);\n\t\t\t__queue_cap_release(session, vino.ino, cap_id,\n\t\t\t\t\t    mseq, seq);\n\t\t\tspin_unlock(&session->s_cap_lock);\n\t\t}\n\t\tgoto flush_cap_releases;\n\t}\n\n\t/* these will work even if we don't have a cap yet */\n\tswitch (op) {\n\tcase CEPH_CAP_OP_FLUSHSNAP_ACK:\n\t\thandle_cap_flushsnap_ack(inode, tid, h, session);\n\t\tgoto done;\n\n\tcase CEPH_CAP_OP_EXPORT:\n\t\thandle_cap_export(inode, h, peer, session);\n\t\tgoto done_unlocked;\n\n\tcase CEPH_CAP_OP_IMPORT:\n\t\trealm = NULL;\n\t\tif (snaptrace_len) {\n\t\t\tdown_write(&mdsc->snap_rwsem);\n\t\t\tceph_update_snap_trace(mdsc, snaptrace,\n\t\t\t\t\t       snaptrace + snaptrace_len,\n\t\t\t\t\t       false, &realm);\n\t\t\tdowngrade_write(&mdsc->snap_rwsem);\n\t\t} else {\n\t\t\tdown_read(&mdsc->snap_rwsem);\n\t\t}\n\t\thandle_cap_import(mdsc, inode, h, peer, session,\n\t\t\t\t  &cap, &issued);\n\t\thandle_cap_grant(mdsc, inode, h,\n\t\t\t\t inline_version, inline_data, inline_len,\n\t\t\t\t msg->middle, session, cap, issued);\n\t\tif (realm)\n\t\t\tceph_put_snap_realm(mdsc, realm);\n\t\tgoto done_unlocked;\n\t}\n\n\t/* the rest require a cap */\n\tspin_lock(&ci->i_ceph_lock);\n\tcap = __get_cap_for_mds(ceph_inode(inode), mds);\n\tif (!cap) {\n\t\tdout(\" no cap on %p ino %llx.%llx from mds%d\\n\",\n\t\t     inode, ceph_ino(inode), ceph_snap(inode), mds);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tgoto flush_cap_releases;\n\t}\n\n\t/* note that each of these drops i_ceph_lock for us */\n\tswitch (op) {\n\tcase CEPH_CAP_OP_REVOKE:\n\tcase CEPH_CAP_OP_GRANT:\n\t\t__ceph_caps_issued(ci, &issued);\n\t\tissued |= __ceph_caps_dirty(ci);\n\t\thandle_cap_grant(mdsc, inode, h,\n\t\t\t\t inline_version, inline_data, inline_len,\n\t\t\t\t msg->middle, session, cap, issued);\n\t\tgoto done_unlocked;\n\n\tcase CEPH_CAP_OP_FLUSH_ACK:\n\t\thandle_cap_flush_ack(inode, tid, h, session, cap);\n\t\tbreak;\n\n\tcase CEPH_CAP_OP_TRUNC:\n\t\thandle_cap_trunc(inode, h, session);\n\t\tbreak;\n\n\tdefault:\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tpr_err(\"ceph_handle_caps: unknown cap op %d %s\\n\", op,\n\t\t       ceph_cap_op_name(op));\n\t}\n\n\tgoto done;\n\nflush_cap_releases:\n\t/*\n\t * send any full release message to try to move things\n\t * along for the mds (who clearly thinks we still have this\n\t * cap).\n\t */\n\tceph_add_cap_releases(mdsc, session);\n\tceph_send_cap_releases(mdsc, session);\n\ndone:\n\tmutex_unlock(&session->s_mutex);\ndone_unlocked:\n\tiput(inode);\n\treturn;\n\nbad:\n\tpr_err(\"ceph_handle_caps: corrupt message\\n\");\n\tceph_msg_dump(msg);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_forward",
          "args": [
            "mdsc",
            "s",
            "msg"
          ],
          "line": 3717
        },
        "resolved": true,
        "details": {
          "function_name": "handle_forward",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "2488-2535",
          "snippet": "static void handle_forward(struct ceph_mds_client *mdsc,\n\t\t\t   struct ceph_mds_session *session,\n\t\t\t   struct ceph_msg *msg)\n{\n\tstruct ceph_mds_request *req;\n\tu64 tid = le64_to_cpu(msg->hdr.tid);\n\tu32 next_mds;\n\tu32 fwd_seq;\n\tint err = -EINVAL;\n\tvoid *p = msg->front.iov_base;\n\tvoid *end = p + msg->front.iov_len;\n\n\tceph_decode_need(&p, end, 2*sizeof(u32), bad);\n\tnext_mds = ceph_decode_32(&p);\n\tfwd_seq = ceph_decode_32(&p);\n\n\tmutex_lock(&mdsc->mutex);\n\treq = __lookup_request(mdsc, tid);\n\tif (!req) {\n\t\tdout(\"forward tid %llu to mds%d - req dne\\n\", tid, next_mds);\n\t\tgoto out;  /* dup reply? */\n\t}\n\n\tif (req->r_aborted) {\n\t\tdout(\"forward tid %llu aborted, unregistering\\n\", tid);\n\t\t__unregister_request(mdsc, req);\n\t} else if (fwd_seq <= req->r_num_fwd) {\n\t\tdout(\"forward tid %llu to mds%d - old seq %d <= %d\\n\",\n\t\t     tid, next_mds, req->r_num_fwd, fwd_seq);\n\t} else {\n\t\t/* resend. forward race not possible; mds would drop */\n\t\tdout(\"forward tid %llu to mds%d (we resend)\\n\", tid, next_mds);\n\t\tBUG_ON(req->r_err);\n\t\tBUG_ON(req->r_got_result);\n\t\treq->r_attempts = 0;\n\t\treq->r_num_fwd = fwd_seq;\n\t\treq->r_resend_mds = next_mds;\n\t\tput_request_session(req);\n\t\t__do_request(mdsc, req);\n\t}\n\tceph_mdsc_put_request(req);\nout:\n\tmutex_unlock(&mdsc->mutex);\n\treturn;\n\nbad:\n\tpr_err(\"mdsc_handle_forward decode error err=%d\\n\", err);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void handle_forward(struct ceph_mds_client *mdsc,\n\t\t\t   struct ceph_mds_session *session,\n\t\t\t   struct ceph_msg *msg)\n{\n\tstruct ceph_mds_request *req;\n\tu64 tid = le64_to_cpu(msg->hdr.tid);\n\tu32 next_mds;\n\tu32 fwd_seq;\n\tint err = -EINVAL;\n\tvoid *p = msg->front.iov_base;\n\tvoid *end = p + msg->front.iov_len;\n\n\tceph_decode_need(&p, end, 2*sizeof(u32), bad);\n\tnext_mds = ceph_decode_32(&p);\n\tfwd_seq = ceph_decode_32(&p);\n\n\tmutex_lock(&mdsc->mutex);\n\treq = __lookup_request(mdsc, tid);\n\tif (!req) {\n\t\tdout(\"forward tid %llu to mds%d - req dne\\n\", tid, next_mds);\n\t\tgoto out;  /* dup reply? */\n\t}\n\n\tif (req->r_aborted) {\n\t\tdout(\"forward tid %llu aborted, unregistering\\n\", tid);\n\t\t__unregister_request(mdsc, req);\n\t} else if (fwd_seq <= req->r_num_fwd) {\n\t\tdout(\"forward tid %llu to mds%d - old seq %d <= %d\\n\",\n\t\t     tid, next_mds, req->r_num_fwd, fwd_seq);\n\t} else {\n\t\t/* resend. forward race not possible; mds would drop */\n\t\tdout(\"forward tid %llu to mds%d (we resend)\\n\", tid, next_mds);\n\t\tBUG_ON(req->r_err);\n\t\tBUG_ON(req->r_got_result);\n\t\treq->r_attempts = 0;\n\t\treq->r_num_fwd = fwd_seq;\n\t\treq->r_resend_mds = next_mds;\n\t\tput_request_session(req);\n\t\t__do_request(mdsc, req);\n\t}\n\tceph_mdsc_put_request(req);\nout:\n\tmutex_unlock(&mdsc->mutex);\n\treturn;\n\nbad:\n\tpr_err(\"mdsc_handle_forward decode error err=%d\\n\", err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_reply",
          "args": [
            "s",
            "msg"
          ],
          "line": 3714
        },
        "resolved": true,
        "details": {
          "function_name": "handle_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "2310-2481",
          "snippet": "static void handle_reply(struct ceph_mds_session *session, struct ceph_msg *msg)\n{\n\tstruct ceph_mds_client *mdsc = session->s_mdsc;\n\tstruct ceph_mds_request *req;\n\tstruct ceph_mds_reply_head *head = msg->front.iov_base;\n\tstruct ceph_mds_reply_info_parsed *rinfo;  /* parsed reply info */\n\tstruct ceph_snap_realm *realm;\n\tu64 tid;\n\tint err, result;\n\tint mds = session->s_mds;\n\n\tif (msg->front.iov_len < sizeof(*head)) {\n\t\tpr_err(\"mdsc_handle_reply got corrupt (short) reply\\n\");\n\t\tceph_msg_dump(msg);\n\t\treturn;\n\t}\n\n\t/* get request, session */\n\ttid = le64_to_cpu(msg->hdr.tid);\n\tmutex_lock(&mdsc->mutex);\n\treq = __lookup_request(mdsc, tid);\n\tif (!req) {\n\t\tdout(\"handle_reply on unknown tid %llu\\n\", tid);\n\t\tmutex_unlock(&mdsc->mutex);\n\t\treturn;\n\t}\n\tdout(\"handle_reply %p\\n\", req);\n\n\t/* correct session? */\n\tif (req->r_session != session) {\n\t\tpr_err(\"mdsc_handle_reply got %llu on session mds%d\"\n\t\t       \" not mds%d\\n\", tid, session->s_mds,\n\t\t       req->r_session ? req->r_session->s_mds : -1);\n\t\tmutex_unlock(&mdsc->mutex);\n\t\tgoto out;\n\t}\n\n\t/* dup? */\n\tif ((req->r_got_unsafe && !head->safe) ||\n\t    (req->r_got_safe && head->safe)) {\n\t\tpr_warn(\"got a dup %s reply on %llu from mds%d\\n\",\n\t\t\t   head->safe ? \"safe\" : \"unsafe\", tid, mds);\n\t\tmutex_unlock(&mdsc->mutex);\n\t\tgoto out;\n\t}\n\tif (req->r_got_safe && !head->safe) {\n\t\tpr_warn(\"got unsafe after safe on %llu from mds%d\\n\",\n\t\t\t   tid, mds);\n\t\tmutex_unlock(&mdsc->mutex);\n\t\tgoto out;\n\t}\n\n\tresult = le32_to_cpu(head->result);\n\n\t/*\n\t * Handle an ESTALE\n\t * if we're not talking to the authority, send to them\n\t * if the authority has changed while we weren't looking,\n\t * send to new authority\n\t * Otherwise we just have to return an ESTALE\n\t */\n\tif (result == -ESTALE) {\n\t\tdout(\"got ESTALE on request %llu\", req->r_tid);\n\t\treq->r_resend_mds = -1;\n\t\tif (req->r_direct_mode != USE_AUTH_MDS) {\n\t\t\tdout(\"not using auth, setting for that now\");\n\t\t\treq->r_direct_mode = USE_AUTH_MDS;\n\t\t\t__do_request(mdsc, req);\n\t\t\tmutex_unlock(&mdsc->mutex);\n\t\t\tgoto out;\n\t\t} else  {\n\t\t\tint mds = __choose_mds(mdsc, req);\n\t\t\tif (mds >= 0 && mds != req->r_session->s_mds) {\n\t\t\t\tdout(\"but auth changed, so resending\");\n\t\t\t\t__do_request(mdsc, req);\n\t\t\t\tmutex_unlock(&mdsc->mutex);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tdout(\"have to return ESTALE on request %llu\", req->r_tid);\n\t}\n\n\n\tif (head->safe) {\n\t\treq->r_got_safe = true;\n\t\t__unregister_request(mdsc, req);\n\n\t\tif (req->r_got_unsafe) {\n\t\t\t/*\n\t\t\t * We already handled the unsafe response, now do the\n\t\t\t * cleanup.  No need to examine the response; the MDS\n\t\t\t * doesn't include any result info in the safe\n\t\t\t * response.  And even if it did, there is nothing\n\t\t\t * useful we could do with a revised return value.\n\t\t\t */\n\t\t\tdout(\"got safe reply %llu, mds%d\\n\", tid, mds);\n\t\t\tlist_del_init(&req->r_unsafe_item);\n\n\t\t\t/* last unsafe request during umount? */\n\t\t\tif (mdsc->stopping && !__get_oldest_req(mdsc))\n\t\t\t\tcomplete_all(&mdsc->safe_umount_waiters);\n\t\t\tmutex_unlock(&mdsc->mutex);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\treq->r_got_unsafe = true;\n\t\tlist_add_tail(&req->r_unsafe_item, &req->r_session->s_unsafe);\n\t}\n\n\tdout(\"handle_reply tid %lld result %d\\n\", tid, result);\n\trinfo = &req->r_reply_info;\n\terr = parse_reply_info(msg, rinfo, session->s_con.peer_features);\n\tmutex_unlock(&mdsc->mutex);\n\n\tmutex_lock(&session->s_mutex);\n\tif (err < 0) {\n\t\tpr_err(\"mdsc_handle_reply got corrupt reply mds%d(tid:%lld)\\n\", mds, tid);\n\t\tceph_msg_dump(msg);\n\t\tgoto out_err;\n\t}\n\n\t/* snap trace */\n\trealm = NULL;\n\tif (rinfo->snapblob_len) {\n\t\tdown_write(&mdsc->snap_rwsem);\n\t\tceph_update_snap_trace(mdsc, rinfo->snapblob,\n\t\t\t\trinfo->snapblob + rinfo->snapblob_len,\n\t\t\t\tle32_to_cpu(head->op) == CEPH_MDS_OP_RMSNAP,\n\t\t\t\t&realm);\n\t\tdowngrade_write(&mdsc->snap_rwsem);\n\t} else {\n\t\tdown_read(&mdsc->snap_rwsem);\n\t}\n\n\t/* insert trace into our cache */\n\tmutex_lock(&req->r_fill_mutex);\n\terr = ceph_fill_trace(mdsc->fsc->sb, req, req->r_session);\n\tif (err == 0) {\n\t\tif (result == 0 && (req->r_op == CEPH_MDS_OP_READDIR ||\n\t\t\t\t    req->r_op == CEPH_MDS_OP_LSSNAP))\n\t\t\tceph_readdir_prepopulate(req, req->r_session);\n\t\tceph_unreserve_caps(mdsc, &req->r_caps_reservation);\n\t}\n\tmutex_unlock(&req->r_fill_mutex);\n\n\tup_read(&mdsc->snap_rwsem);\n\tif (realm)\n\t\tceph_put_snap_realm(mdsc, realm);\nout_err:\n\tmutex_lock(&mdsc->mutex);\n\tif (!req->r_aborted) {\n\t\tif (err) {\n\t\t\treq->r_err = err;\n\t\t} else {\n\t\t\treq->r_reply = msg;\n\t\t\tceph_msg_get(msg);\n\t\t\treq->r_got_result = true;\n\t\t}\n\t} else {\n\t\tdout(\"reply arrived after request %lld was aborted\\n\", tid);\n\t}\n\tmutex_unlock(&mdsc->mutex);\n\n\tceph_add_cap_releases(mdsc, req->r_session);\n\tmutex_unlock(&session->s_mutex);\n\n\t/* kick calling process */\n\tcomplete_request(mdsc, req);\nout:\n\tceph_mdsc_put_request(req);\n\treturn;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);\n\nstatic void handle_reply(struct ceph_mds_session *session, struct ceph_msg *msg)\n{\n\tstruct ceph_mds_client *mdsc = session->s_mdsc;\n\tstruct ceph_mds_request *req;\n\tstruct ceph_mds_reply_head *head = msg->front.iov_base;\n\tstruct ceph_mds_reply_info_parsed *rinfo;  /* parsed reply info */\n\tstruct ceph_snap_realm *realm;\n\tu64 tid;\n\tint err, result;\n\tint mds = session->s_mds;\n\n\tif (msg->front.iov_len < sizeof(*head)) {\n\t\tpr_err(\"mdsc_handle_reply got corrupt (short) reply\\n\");\n\t\tceph_msg_dump(msg);\n\t\treturn;\n\t}\n\n\t/* get request, session */\n\ttid = le64_to_cpu(msg->hdr.tid);\n\tmutex_lock(&mdsc->mutex);\n\treq = __lookup_request(mdsc, tid);\n\tif (!req) {\n\t\tdout(\"handle_reply on unknown tid %llu\\n\", tid);\n\t\tmutex_unlock(&mdsc->mutex);\n\t\treturn;\n\t}\n\tdout(\"handle_reply %p\\n\", req);\n\n\t/* correct session? */\n\tif (req->r_session != session) {\n\t\tpr_err(\"mdsc_handle_reply got %llu on session mds%d\"\n\t\t       \" not mds%d\\n\", tid, session->s_mds,\n\t\t       req->r_session ? req->r_session->s_mds : -1);\n\t\tmutex_unlock(&mdsc->mutex);\n\t\tgoto out;\n\t}\n\n\t/* dup? */\n\tif ((req->r_got_unsafe && !head->safe) ||\n\t    (req->r_got_safe && head->safe)) {\n\t\tpr_warn(\"got a dup %s reply on %llu from mds%d\\n\",\n\t\t\t   head->safe ? \"safe\" : \"unsafe\", tid, mds);\n\t\tmutex_unlock(&mdsc->mutex);\n\t\tgoto out;\n\t}\n\tif (req->r_got_safe && !head->safe) {\n\t\tpr_warn(\"got unsafe after safe on %llu from mds%d\\n\",\n\t\t\t   tid, mds);\n\t\tmutex_unlock(&mdsc->mutex);\n\t\tgoto out;\n\t}\n\n\tresult = le32_to_cpu(head->result);\n\n\t/*\n\t * Handle an ESTALE\n\t * if we're not talking to the authority, send to them\n\t * if the authority has changed while we weren't looking,\n\t * send to new authority\n\t * Otherwise we just have to return an ESTALE\n\t */\n\tif (result == -ESTALE) {\n\t\tdout(\"got ESTALE on request %llu\", req->r_tid);\n\t\treq->r_resend_mds = -1;\n\t\tif (req->r_direct_mode != USE_AUTH_MDS) {\n\t\t\tdout(\"not using auth, setting for that now\");\n\t\t\treq->r_direct_mode = USE_AUTH_MDS;\n\t\t\t__do_request(mdsc, req);\n\t\t\tmutex_unlock(&mdsc->mutex);\n\t\t\tgoto out;\n\t\t} else  {\n\t\t\tint mds = __choose_mds(mdsc, req);\n\t\t\tif (mds >= 0 && mds != req->r_session->s_mds) {\n\t\t\t\tdout(\"but auth changed, so resending\");\n\t\t\t\t__do_request(mdsc, req);\n\t\t\t\tmutex_unlock(&mdsc->mutex);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tdout(\"have to return ESTALE on request %llu\", req->r_tid);\n\t}\n\n\n\tif (head->safe) {\n\t\treq->r_got_safe = true;\n\t\t__unregister_request(mdsc, req);\n\n\t\tif (req->r_got_unsafe) {\n\t\t\t/*\n\t\t\t * We already handled the unsafe response, now do the\n\t\t\t * cleanup.  No need to examine the response; the MDS\n\t\t\t * doesn't include any result info in the safe\n\t\t\t * response.  And even if it did, there is nothing\n\t\t\t * useful we could do with a revised return value.\n\t\t\t */\n\t\t\tdout(\"got safe reply %llu, mds%d\\n\", tid, mds);\n\t\t\tlist_del_init(&req->r_unsafe_item);\n\n\t\t\t/* last unsafe request during umount? */\n\t\t\tif (mdsc->stopping && !__get_oldest_req(mdsc))\n\t\t\t\tcomplete_all(&mdsc->safe_umount_waiters);\n\t\t\tmutex_unlock(&mdsc->mutex);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\treq->r_got_unsafe = true;\n\t\tlist_add_tail(&req->r_unsafe_item, &req->r_session->s_unsafe);\n\t}\n\n\tdout(\"handle_reply tid %lld result %d\\n\", tid, result);\n\trinfo = &req->r_reply_info;\n\terr = parse_reply_info(msg, rinfo, session->s_con.peer_features);\n\tmutex_unlock(&mdsc->mutex);\n\n\tmutex_lock(&session->s_mutex);\n\tif (err < 0) {\n\t\tpr_err(\"mdsc_handle_reply got corrupt reply mds%d(tid:%lld)\\n\", mds, tid);\n\t\tceph_msg_dump(msg);\n\t\tgoto out_err;\n\t}\n\n\t/* snap trace */\n\trealm = NULL;\n\tif (rinfo->snapblob_len) {\n\t\tdown_write(&mdsc->snap_rwsem);\n\t\tceph_update_snap_trace(mdsc, rinfo->snapblob,\n\t\t\t\trinfo->snapblob + rinfo->snapblob_len,\n\t\t\t\tle32_to_cpu(head->op) == CEPH_MDS_OP_RMSNAP,\n\t\t\t\t&realm);\n\t\tdowngrade_write(&mdsc->snap_rwsem);\n\t} else {\n\t\tdown_read(&mdsc->snap_rwsem);\n\t}\n\n\t/* insert trace into our cache */\n\tmutex_lock(&req->r_fill_mutex);\n\terr = ceph_fill_trace(mdsc->fsc->sb, req, req->r_session);\n\tif (err == 0) {\n\t\tif (result == 0 && (req->r_op == CEPH_MDS_OP_READDIR ||\n\t\t\t\t    req->r_op == CEPH_MDS_OP_LSSNAP))\n\t\t\tceph_readdir_prepopulate(req, req->r_session);\n\t\tceph_unreserve_caps(mdsc, &req->r_caps_reservation);\n\t}\n\tmutex_unlock(&req->r_fill_mutex);\n\n\tup_read(&mdsc->snap_rwsem);\n\tif (realm)\n\t\tceph_put_snap_realm(mdsc, realm);\nout_err:\n\tmutex_lock(&mdsc->mutex);\n\tif (!req->r_aborted) {\n\t\tif (err) {\n\t\t\treq->r_err = err;\n\t\t} else {\n\t\t\treq->r_reply = msg;\n\t\t\tceph_msg_get(msg);\n\t\t\treq->r_got_result = true;\n\t\t}\n\t} else {\n\t\tdout(\"reply arrived after request %lld was aborted\\n\", tid);\n\t}\n\tmutex_unlock(&mdsc->mutex);\n\n\tceph_add_cap_releases(mdsc, req->r_session);\n\tmutex_unlock(&session->s_mutex);\n\n\t/* kick calling process */\n\tcomplete_request(mdsc, req);\nout:\n\tceph_mdsc_put_request(req);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_session",
          "args": [
            "s",
            "msg"
          ],
          "line": 3711
        },
        "resolved": true,
        "details": {
          "function_name": "handle_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "2540-2644",
          "snippet": "static void handle_session(struct ceph_mds_session *session,\n\t\t\t   struct ceph_msg *msg)\n{\n\tstruct ceph_mds_client *mdsc = session->s_mdsc;\n\tu32 op;\n\tu64 seq;\n\tint mds = session->s_mds;\n\tstruct ceph_mds_session_head *h = msg->front.iov_base;\n\tint wake = 0;\n\n\t/* decode */\n\tif (msg->front.iov_len != sizeof(*h))\n\t\tgoto bad;\n\top = le32_to_cpu(h->op);\n\tseq = le64_to_cpu(h->seq);\n\n\tmutex_lock(&mdsc->mutex);\n\tif (op == CEPH_SESSION_CLOSE)\n\t\t__unregister_session(mdsc, session);\n\t/* FIXME: this ttl calculation is generous */\n\tsession->s_ttl = jiffies + HZ*mdsc->mdsmap->m_session_autoclose;\n\tmutex_unlock(&mdsc->mutex);\n\n\tmutex_lock(&session->s_mutex);\n\n\tdout(\"handle_session mds%d %s %p state %s seq %llu\\n\",\n\t     mds, ceph_session_op_name(op), session,\n\t     ceph_session_state_name(session->s_state), seq);\n\n\tif (session->s_state == CEPH_MDS_SESSION_HUNG) {\n\t\tsession->s_state = CEPH_MDS_SESSION_OPEN;\n\t\tpr_info(\"mds%d came back\\n\", session->s_mds);\n\t}\n\n\tswitch (op) {\n\tcase CEPH_SESSION_OPEN:\n\t\tif (session->s_state == CEPH_MDS_SESSION_RECONNECTING)\n\t\t\tpr_info(\"mds%d reconnect success\\n\", session->s_mds);\n\t\tsession->s_state = CEPH_MDS_SESSION_OPEN;\n\t\trenewed_caps(mdsc, session, 0);\n\t\twake = 1;\n\t\tif (mdsc->stopping)\n\t\t\t__close_session(mdsc, session);\n\t\tbreak;\n\n\tcase CEPH_SESSION_RENEWCAPS:\n\t\tif (session->s_renew_seq == seq)\n\t\t\trenewed_caps(mdsc, session, 1);\n\t\tbreak;\n\n\tcase CEPH_SESSION_CLOSE:\n\t\tif (session->s_state == CEPH_MDS_SESSION_RECONNECTING)\n\t\t\tpr_info(\"mds%d reconnect denied\\n\", session->s_mds);\n\t\tremove_session_caps(session);\n\t\twake = 2; /* for good measure */\n\t\twake_up_all(&mdsc->session_close_wq);\n\t\tbreak;\n\n\tcase CEPH_SESSION_STALE:\n\t\tpr_info(\"mds%d caps went stale, renewing\\n\",\n\t\t\tsession->s_mds);\n\t\tspin_lock(&session->s_gen_ttl_lock);\n\t\tsession->s_cap_gen++;\n\t\tsession->s_cap_ttl = jiffies - 1;\n\t\tspin_unlock(&session->s_gen_ttl_lock);\n\t\tsend_renew_caps(mdsc, session);\n\t\tbreak;\n\n\tcase CEPH_SESSION_RECALL_STATE:\n\t\ttrim_caps(mdsc, session, le32_to_cpu(h->max_caps));\n\t\tbreak;\n\n\tcase CEPH_SESSION_FLUSHMSG:\n\t\tsend_flushmsg_ack(mdsc, session, seq);\n\t\tbreak;\n\n\tcase CEPH_SESSION_FORCE_RO:\n\t\tdout(\"force_session_readonly %p\\n\", session);\n\t\tspin_lock(&session->s_cap_lock);\n\t\tsession->s_readonly = true;\n\t\tspin_unlock(&session->s_cap_lock);\n\t\twake_up_session_caps(session, 0);\n\t\tbreak;\n\n\tdefault:\n\t\tpr_err(\"mdsc_handle_session bad op %d mds%d\\n\", op, mds);\n\t\tWARN_ON(1);\n\t}\n\n\tmutex_unlock(&session->s_mutex);\n\tif (wake) {\n\t\tmutex_lock(&mdsc->mutex);\n\t\t__wake_requests(mdsc, &session->s_waiting);\n\t\tif (wake == 2)\n\t\t\tkick_requests(mdsc, mds);\n\t\tmutex_unlock(&mdsc->mutex);\n\t}\n\treturn;\n\nbad:\n\tpr_err(\"mdsc_handle_session corrupt message mds%d len %d\\n\", mds,\n\t       (int)msg->front.iov_len);\n\tceph_msg_dump(msg);\n\treturn;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void handle_session(struct ceph_mds_session *session,\n\t\t\t   struct ceph_msg *msg)\n{\n\tstruct ceph_mds_client *mdsc = session->s_mdsc;\n\tu32 op;\n\tu64 seq;\n\tint mds = session->s_mds;\n\tstruct ceph_mds_session_head *h = msg->front.iov_base;\n\tint wake = 0;\n\n\t/* decode */\n\tif (msg->front.iov_len != sizeof(*h))\n\t\tgoto bad;\n\top = le32_to_cpu(h->op);\n\tseq = le64_to_cpu(h->seq);\n\n\tmutex_lock(&mdsc->mutex);\n\tif (op == CEPH_SESSION_CLOSE)\n\t\t__unregister_session(mdsc, session);\n\t/* FIXME: this ttl calculation is generous */\n\tsession->s_ttl = jiffies + HZ*mdsc->mdsmap->m_session_autoclose;\n\tmutex_unlock(&mdsc->mutex);\n\n\tmutex_lock(&session->s_mutex);\n\n\tdout(\"handle_session mds%d %s %p state %s seq %llu\\n\",\n\t     mds, ceph_session_op_name(op), session,\n\t     ceph_session_state_name(session->s_state), seq);\n\n\tif (session->s_state == CEPH_MDS_SESSION_HUNG) {\n\t\tsession->s_state = CEPH_MDS_SESSION_OPEN;\n\t\tpr_info(\"mds%d came back\\n\", session->s_mds);\n\t}\n\n\tswitch (op) {\n\tcase CEPH_SESSION_OPEN:\n\t\tif (session->s_state == CEPH_MDS_SESSION_RECONNECTING)\n\t\t\tpr_info(\"mds%d reconnect success\\n\", session->s_mds);\n\t\tsession->s_state = CEPH_MDS_SESSION_OPEN;\n\t\trenewed_caps(mdsc, session, 0);\n\t\twake = 1;\n\t\tif (mdsc->stopping)\n\t\t\t__close_session(mdsc, session);\n\t\tbreak;\n\n\tcase CEPH_SESSION_RENEWCAPS:\n\t\tif (session->s_renew_seq == seq)\n\t\t\trenewed_caps(mdsc, session, 1);\n\t\tbreak;\n\n\tcase CEPH_SESSION_CLOSE:\n\t\tif (session->s_state == CEPH_MDS_SESSION_RECONNECTING)\n\t\t\tpr_info(\"mds%d reconnect denied\\n\", session->s_mds);\n\t\tremove_session_caps(session);\n\t\twake = 2; /* for good measure */\n\t\twake_up_all(&mdsc->session_close_wq);\n\t\tbreak;\n\n\tcase CEPH_SESSION_STALE:\n\t\tpr_info(\"mds%d caps went stale, renewing\\n\",\n\t\t\tsession->s_mds);\n\t\tspin_lock(&session->s_gen_ttl_lock);\n\t\tsession->s_cap_gen++;\n\t\tsession->s_cap_ttl = jiffies - 1;\n\t\tspin_unlock(&session->s_gen_ttl_lock);\n\t\tsend_renew_caps(mdsc, session);\n\t\tbreak;\n\n\tcase CEPH_SESSION_RECALL_STATE:\n\t\ttrim_caps(mdsc, session, le32_to_cpu(h->max_caps));\n\t\tbreak;\n\n\tcase CEPH_SESSION_FLUSHMSG:\n\t\tsend_flushmsg_ack(mdsc, session, seq);\n\t\tbreak;\n\n\tcase CEPH_SESSION_FORCE_RO:\n\t\tdout(\"force_session_readonly %p\\n\", session);\n\t\tspin_lock(&session->s_cap_lock);\n\t\tsession->s_readonly = true;\n\t\tspin_unlock(&session->s_cap_lock);\n\t\twake_up_session_caps(session, 0);\n\t\tbreak;\n\n\tdefault:\n\t\tpr_err(\"mdsc_handle_session bad op %d mds%d\\n\", op, mds);\n\t\tWARN_ON(1);\n\t}\n\n\tmutex_unlock(&session->s_mutex);\n\tif (wake) {\n\t\tmutex_lock(&mdsc->mutex);\n\t\t__wake_requests(mdsc, &session->s_waiting);\n\t\tif (wake == 2)\n\t\t\tkick_requests(mdsc, mds);\n\t\tmutex_unlock(&mdsc->mutex);\n\t}\n\treturn;\n\nbad:\n\tpr_err(\"mdsc_handle_session corrupt message mds%d len %d\\n\", mds,\n\t       (int)msg->front.iov_len);\n\tceph_msg_dump(msg);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_handle_map",
          "args": [
            "mdsc",
            "msg"
          ],
          "line": 3708
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_handle_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "3602-3658",
          "snippet": "void ceph_mdsc_handle_map(struct ceph_mds_client *mdsc, struct ceph_msg *msg)\n{\n\tu32 epoch;\n\tu32 maplen;\n\tvoid *p = msg->front.iov_base;\n\tvoid *end = p + msg->front.iov_len;\n\tstruct ceph_mdsmap *newmap, *oldmap;\n\tstruct ceph_fsid fsid;\n\tint err = -EINVAL;\n\n\tceph_decode_need(&p, end, sizeof(fsid)+2*sizeof(u32), bad);\n\tceph_decode_copy(&p, &fsid, sizeof(fsid));\n\tif (ceph_check_fsid(mdsc->fsc->client, &fsid) < 0)\n\t\treturn;\n\tepoch = ceph_decode_32(&p);\n\tmaplen = ceph_decode_32(&p);\n\tdout(\"handle_map epoch %u len %d\\n\", epoch, (int)maplen);\n\n\t/* do we need it? */\n\tceph_monc_got_mdsmap(&mdsc->fsc->client->monc, epoch);\n\tmutex_lock(&mdsc->mutex);\n\tif (mdsc->mdsmap && epoch <= mdsc->mdsmap->m_epoch) {\n\t\tdout(\"handle_map epoch %u <= our %u\\n\",\n\t\t     epoch, mdsc->mdsmap->m_epoch);\n\t\tmutex_unlock(&mdsc->mutex);\n\t\treturn;\n\t}\n\n\tnewmap = ceph_mdsmap_decode(&p, end);\n\tif (IS_ERR(newmap)) {\n\t\terr = PTR_ERR(newmap);\n\t\tgoto bad_unlock;\n\t}\n\n\t/* swap into place */\n\tif (mdsc->mdsmap) {\n\t\toldmap = mdsc->mdsmap;\n\t\tmdsc->mdsmap = newmap;\n\t\tcheck_new_map(mdsc, newmap, oldmap);\n\t\tceph_mdsmap_destroy(oldmap);\n\t} else {\n\t\tmdsc->mdsmap = newmap;  /* first mds map */\n\t}\n\tmdsc->fsc->sb->s_maxbytes = mdsc->mdsmap->m_max_file_size;\n\n\t__wake_requests(mdsc, &mdsc->waiting_for_map);\n\n\tmutex_unlock(&mdsc->mutex);\n\tschedule_delayed(mdsc);\n\treturn;\n\nbad_unlock:\n\tmutex_unlock(&mdsc->mutex);\nbad:\n\tpr_err(\"error decoding mdsmap %d\\n\", err);\n\treturn;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_mdsc_handle_map(struct ceph_mds_client *mdsc, struct ceph_msg *msg)\n{\n\tu32 epoch;\n\tu32 maplen;\n\tvoid *p = msg->front.iov_base;\n\tvoid *end = p + msg->front.iov_len;\n\tstruct ceph_mdsmap *newmap, *oldmap;\n\tstruct ceph_fsid fsid;\n\tint err = -EINVAL;\n\n\tceph_decode_need(&p, end, sizeof(fsid)+2*sizeof(u32), bad);\n\tceph_decode_copy(&p, &fsid, sizeof(fsid));\n\tif (ceph_check_fsid(mdsc->fsc->client, &fsid) < 0)\n\t\treturn;\n\tepoch = ceph_decode_32(&p);\n\tmaplen = ceph_decode_32(&p);\n\tdout(\"handle_map epoch %u len %d\\n\", epoch, (int)maplen);\n\n\t/* do we need it? */\n\tceph_monc_got_mdsmap(&mdsc->fsc->client->monc, epoch);\n\tmutex_lock(&mdsc->mutex);\n\tif (mdsc->mdsmap && epoch <= mdsc->mdsmap->m_epoch) {\n\t\tdout(\"handle_map epoch %u <= our %u\\n\",\n\t\t     epoch, mdsc->mdsmap->m_epoch);\n\t\tmutex_unlock(&mdsc->mutex);\n\t\treturn;\n\t}\n\n\tnewmap = ceph_mdsmap_decode(&p, end);\n\tif (IS_ERR(newmap)) {\n\t\terr = PTR_ERR(newmap);\n\t\tgoto bad_unlock;\n\t}\n\n\t/* swap into place */\n\tif (mdsc->mdsmap) {\n\t\toldmap = mdsc->mdsmap;\n\t\tmdsc->mdsmap = newmap;\n\t\tcheck_new_map(mdsc, newmap, oldmap);\n\t\tceph_mdsmap_destroy(oldmap);\n\t} else {\n\t\tmdsc->mdsmap = newmap;  /* first mds map */\n\t}\n\tmdsc->fsc->sb->s_maxbytes = mdsc->mdsmap->m_max_file_size;\n\n\t__wake_requests(mdsc, &mdsc->waiting_for_map);\n\n\tmutex_unlock(&mdsc->mutex);\n\tschedule_delayed(mdsc);\n\treturn;\n\nbad_unlock:\n\tmutex_unlock(&mdsc->mutex);\nbad:\n\tpr_err(\"error decoding mdsmap %d\\n\", err);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 3704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 3701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__verify_registered_session",
          "args": [
            "mdsc",
            "s"
          ],
          "line": 3700
        },
        "resolved": true,
        "details": {
          "function_name": "__verify_registered_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "411-418",
          "snippet": "static int __verify_registered_session(struct ceph_mds_client *mdsc,\n\t\t\t\t       struct ceph_mds_session *s)\n{\n\tif (s->s_mds >= mdsc->max_sessions ||\n\t    mdsc->sessions[s->s_mds] != s)\n\t\treturn -ENOENT;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __verify_registered_session(struct ceph_mds_client *mdsc,\n\t\t\t\t       struct ceph_mds_session *s)\n{\n\tif (s->s_mds >= mdsc->max_sessions ||\n\t    mdsc->sessions[s->s_mds] != s)\n\t\treturn -ENOENT;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 3699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "msg->hdr.type"
          ],
          "line": 3697
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void dispatch(struct ceph_connection *con, struct ceph_msg *msg)\n{\n\tstruct ceph_mds_session *s = con->private;\n\tstruct ceph_mds_client *mdsc = s->s_mdsc;\n\tint type = le16_to_cpu(msg->hdr.type);\n\n\tmutex_lock(&mdsc->mutex);\n\tif (__verify_registered_session(mdsc, s) < 0) {\n\t\tmutex_unlock(&mdsc->mutex);\n\t\tgoto out;\n\t}\n\tmutex_unlock(&mdsc->mutex);\n\n\tswitch (type) {\n\tcase CEPH_MSG_MDS_MAP:\n\t\tceph_mdsc_handle_map(mdsc, msg);\n\t\tbreak;\n\tcase CEPH_MSG_CLIENT_SESSION:\n\t\thandle_session(s, msg);\n\t\tbreak;\n\tcase CEPH_MSG_CLIENT_REPLY:\n\t\thandle_reply(s, msg);\n\t\tbreak;\n\tcase CEPH_MSG_CLIENT_REQUEST_FORWARD:\n\t\thandle_forward(mdsc, s, msg);\n\t\tbreak;\n\tcase CEPH_MSG_CLIENT_CAPS:\n\t\tceph_handle_caps(s, msg);\n\t\tbreak;\n\tcase CEPH_MSG_CLIENT_SNAP:\n\t\tceph_handle_snap(mdsc, s, msg);\n\t\tbreak;\n\tcase CEPH_MSG_CLIENT_LEASE:\n\t\thandle_lease(mdsc, s, msg);\n\t\tbreak;\n\n\tdefault:\n\t\tpr_err(\"received unknown message type %d %s\\n\", type,\n\t\t       ceph_msg_type_name(type));\n\t}\nout:\n\tceph_msg_put(msg);\n}"
  },
  {
    "function_name": "peer_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "3684-3691",
    "snippet": "static void peer_reset(struct ceph_connection *con)\n{\n\tstruct ceph_mds_session *s = con->private;\n\tstruct ceph_mds_client *mdsc = s->s_mdsc;\n\n\tpr_warn(\"mds%d closed our session\\n\", s->s_mds);\n\tsend_mds_reconnect(mdsc, s);\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_mds_reconnect",
          "args": [
            "mdsc",
            "s"
          ],
          "line": 3690
        },
        "resolved": true,
        "details": {
          "function_name": "send_mds_reconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "2820-2950",
          "snippet": "static void send_mds_reconnect(struct ceph_mds_client *mdsc,\n\t\t\t       struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *reply;\n\tstruct rb_node *p;\n\tint mds = session->s_mds;\n\tint err = -ENOMEM;\n\tint s_nr_caps;\n\tstruct ceph_pagelist *pagelist;\n\tstruct ceph_reconnect_state recon_state;\n\n\tpr_info(\"mds%d reconnect start\\n\", mds);\n\n\tpagelist = kmalloc(sizeof(*pagelist), GFP_NOFS);\n\tif (!pagelist)\n\t\tgoto fail_nopagelist;\n\tceph_pagelist_init(pagelist);\n\n\treply = ceph_msg_new(CEPH_MSG_CLIENT_RECONNECT, 0, GFP_NOFS, false);\n\tif (!reply)\n\t\tgoto fail_nomsg;\n\n\tmutex_lock(&session->s_mutex);\n\tsession->s_state = CEPH_MDS_SESSION_RECONNECTING;\n\tsession->s_seq = 0;\n\n\tdout(\"session %p state %s\\n\", session,\n\t     ceph_session_state_name(session->s_state));\n\n\tspin_lock(&session->s_gen_ttl_lock);\n\tsession->s_cap_gen++;\n\tspin_unlock(&session->s_gen_ttl_lock);\n\n\tspin_lock(&session->s_cap_lock);\n\t/* don't know if session is readonly */\n\tsession->s_readonly = 0;\n\t/*\n\t * notify __ceph_remove_cap() that we are composing cap reconnect.\n\t * If a cap get released before being added to the cap reconnect,\n\t * __ceph_remove_cap() should skip queuing cap release.\n\t */\n\tsession->s_cap_reconnect = 1;\n\t/* drop old cap expires; we're about to reestablish that state */\n\tdiscard_cap_releases(mdsc, session);\n\tspin_unlock(&session->s_cap_lock);\n\n\t/* trim unused caps to reduce MDS's cache rejoin time */\n\tshrink_dcache_parent(mdsc->fsc->sb->s_root);\n\n\tceph_con_close(&session->s_con);\n\tceph_con_open(&session->s_con,\n\t\t      CEPH_ENTITY_TYPE_MDS, mds,\n\t\t      ceph_mdsmap_get_addr(mdsc->mdsmap, mds));\n\n\t/* replay unsafe requests */\n\treplay_unsafe_requests(mdsc, session);\n\n\tdown_read(&mdsc->snap_rwsem);\n\n\t/* traverse this session's caps */\n\ts_nr_caps = session->s_nr_caps;\n\terr = ceph_pagelist_encode_32(pagelist, s_nr_caps);\n\tif (err)\n\t\tgoto fail;\n\n\trecon_state.nr_caps = 0;\n\trecon_state.pagelist = pagelist;\n\trecon_state.flock = session->s_con.peer_features & CEPH_FEATURE_FLOCK;\n\terr = iterate_session_caps(session, encode_caps_cb, &recon_state);\n\tif (err < 0)\n\t\tgoto fail;\n\n\tspin_lock(&session->s_cap_lock);\n\tsession->s_cap_reconnect = 0;\n\tspin_unlock(&session->s_cap_lock);\n\n\t/*\n\t * snaprealms.  we provide mds with the ino, seq (version), and\n\t * parent for all of our realms.  If the mds has any newer info,\n\t * it will tell us.\n\t */\n\tfor (p = rb_first(&mdsc->snap_realms); p; p = rb_next(p)) {\n\t\tstruct ceph_snap_realm *realm =\n\t\t\trb_entry(p, struct ceph_snap_realm, node);\n\t\tstruct ceph_mds_snaprealm_reconnect sr_rec;\n\n\t\tdout(\" adding snap realm %llx seq %lld parent %llx\\n\",\n\t\t     realm->ino, realm->seq, realm->parent_ino);\n\t\tsr_rec.ino = cpu_to_le64(realm->ino);\n\t\tsr_rec.seq = cpu_to_le64(realm->seq);\n\t\tsr_rec.parent = cpu_to_le64(realm->parent_ino);\n\t\terr = ceph_pagelist_append(pagelist, &sr_rec, sizeof(sr_rec));\n\t\tif (err)\n\t\t\tgoto fail;\n\t}\n\n\tif (recon_state.flock)\n\t\treply->hdr.version = cpu_to_le16(2);\n\n\t/* raced with cap release? */\n\tif (s_nr_caps != recon_state.nr_caps) {\n\t\tstruct page *page = list_first_entry(&pagelist->head,\n\t\t\t\t\t\t     struct page, lru);\n\t\t__le32 *addr = kmap_atomic(page);\n\t\t*addr = cpu_to_le32(recon_state.nr_caps);\n\t\tkunmap_atomic(addr);\n\t}\n\n\treply->hdr.data_len = cpu_to_le32(pagelist->length);\n\tceph_msg_data_add_pagelist(reply, pagelist);\n\tceph_con_send(&session->s_con, reply);\n\n\tmutex_unlock(&session->s_mutex);\n\n\tmutex_lock(&mdsc->mutex);\n\t__wake_requests(mdsc, &session->s_waiting);\n\tmutex_unlock(&mdsc->mutex);\n\n\tup_read(&mdsc->snap_rwsem);\n\treturn;\n\nfail:\n\tceph_msg_put(reply);\n\tup_read(&mdsc->snap_rwsem);\n\tmutex_unlock(&session->s_mutex);\nfail_nomsg:\n\tceph_pagelist_release(pagelist);\nfail_nopagelist:\n\tpr_err(\"error %d preparing reconnect for mds%d\\n\", err, mds);\n\treturn;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);\n\nstatic void send_mds_reconnect(struct ceph_mds_client *mdsc,\n\t\t\t       struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *reply;\n\tstruct rb_node *p;\n\tint mds = session->s_mds;\n\tint err = -ENOMEM;\n\tint s_nr_caps;\n\tstruct ceph_pagelist *pagelist;\n\tstruct ceph_reconnect_state recon_state;\n\n\tpr_info(\"mds%d reconnect start\\n\", mds);\n\n\tpagelist = kmalloc(sizeof(*pagelist), GFP_NOFS);\n\tif (!pagelist)\n\t\tgoto fail_nopagelist;\n\tceph_pagelist_init(pagelist);\n\n\treply = ceph_msg_new(CEPH_MSG_CLIENT_RECONNECT, 0, GFP_NOFS, false);\n\tif (!reply)\n\t\tgoto fail_nomsg;\n\n\tmutex_lock(&session->s_mutex);\n\tsession->s_state = CEPH_MDS_SESSION_RECONNECTING;\n\tsession->s_seq = 0;\n\n\tdout(\"session %p state %s\\n\", session,\n\t     ceph_session_state_name(session->s_state));\n\n\tspin_lock(&session->s_gen_ttl_lock);\n\tsession->s_cap_gen++;\n\tspin_unlock(&session->s_gen_ttl_lock);\n\n\tspin_lock(&session->s_cap_lock);\n\t/* don't know if session is readonly */\n\tsession->s_readonly = 0;\n\t/*\n\t * notify __ceph_remove_cap() that we are composing cap reconnect.\n\t * If a cap get released before being added to the cap reconnect,\n\t * __ceph_remove_cap() should skip queuing cap release.\n\t */\n\tsession->s_cap_reconnect = 1;\n\t/* drop old cap expires; we're about to reestablish that state */\n\tdiscard_cap_releases(mdsc, session);\n\tspin_unlock(&session->s_cap_lock);\n\n\t/* trim unused caps to reduce MDS's cache rejoin time */\n\tshrink_dcache_parent(mdsc->fsc->sb->s_root);\n\n\tceph_con_close(&session->s_con);\n\tceph_con_open(&session->s_con,\n\t\t      CEPH_ENTITY_TYPE_MDS, mds,\n\t\t      ceph_mdsmap_get_addr(mdsc->mdsmap, mds));\n\n\t/* replay unsafe requests */\n\treplay_unsafe_requests(mdsc, session);\n\n\tdown_read(&mdsc->snap_rwsem);\n\n\t/* traverse this session's caps */\n\ts_nr_caps = session->s_nr_caps;\n\terr = ceph_pagelist_encode_32(pagelist, s_nr_caps);\n\tif (err)\n\t\tgoto fail;\n\n\trecon_state.nr_caps = 0;\n\trecon_state.pagelist = pagelist;\n\trecon_state.flock = session->s_con.peer_features & CEPH_FEATURE_FLOCK;\n\terr = iterate_session_caps(session, encode_caps_cb, &recon_state);\n\tif (err < 0)\n\t\tgoto fail;\n\n\tspin_lock(&session->s_cap_lock);\n\tsession->s_cap_reconnect = 0;\n\tspin_unlock(&session->s_cap_lock);\n\n\t/*\n\t * snaprealms.  we provide mds with the ino, seq (version), and\n\t * parent for all of our realms.  If the mds has any newer info,\n\t * it will tell us.\n\t */\n\tfor (p = rb_first(&mdsc->snap_realms); p; p = rb_next(p)) {\n\t\tstruct ceph_snap_realm *realm =\n\t\t\trb_entry(p, struct ceph_snap_realm, node);\n\t\tstruct ceph_mds_snaprealm_reconnect sr_rec;\n\n\t\tdout(\" adding snap realm %llx seq %lld parent %llx\\n\",\n\t\t     realm->ino, realm->seq, realm->parent_ino);\n\t\tsr_rec.ino = cpu_to_le64(realm->ino);\n\t\tsr_rec.seq = cpu_to_le64(realm->seq);\n\t\tsr_rec.parent = cpu_to_le64(realm->parent_ino);\n\t\terr = ceph_pagelist_append(pagelist, &sr_rec, sizeof(sr_rec));\n\t\tif (err)\n\t\t\tgoto fail;\n\t}\n\n\tif (recon_state.flock)\n\t\treply->hdr.version = cpu_to_le16(2);\n\n\t/* raced with cap release? */\n\tif (s_nr_caps != recon_state.nr_caps) {\n\t\tstruct page *page = list_first_entry(&pagelist->head,\n\t\t\t\t\t\t     struct page, lru);\n\t\t__le32 *addr = kmap_atomic(page);\n\t\t*addr = cpu_to_le32(recon_state.nr_caps);\n\t\tkunmap_atomic(addr);\n\t}\n\n\treply->hdr.data_len = cpu_to_le32(pagelist->length);\n\tceph_msg_data_add_pagelist(reply, pagelist);\n\tceph_con_send(&session->s_con, reply);\n\n\tmutex_unlock(&session->s_mutex);\n\n\tmutex_lock(&mdsc->mutex);\n\t__wake_requests(mdsc, &session->s_waiting);\n\tmutex_unlock(&mdsc->mutex);\n\n\tup_read(&mdsc->snap_rwsem);\n\treturn;\n\nfail:\n\tceph_msg_put(reply);\n\tup_read(&mdsc->snap_rwsem);\n\tmutex_unlock(&session->s_mutex);\nfail_nomsg:\n\tceph_pagelist_release(pagelist);\nfail_nopagelist:\n\tpr_err(\"error %d preparing reconnect for mds%d\\n\", err, mds);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"mds%d closed our session\\n\"",
            "s->s_mds"
          ],
          "line": 3689
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void peer_reset(struct ceph_connection *con)\n{\n\tstruct ceph_mds_session *s = con->private;\n\tstruct ceph_mds_client *mdsc = s->s_mdsc;\n\n\tpr_warn(\"mds%d closed our session\\n\", s->s_mds);\n\tsend_mds_reconnect(mdsc, s);\n}"
  },
  {
    "function_name": "con_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "3672-3678",
    "snippet": "static void con_put(struct ceph_connection *con)\n{\n\tstruct ceph_mds_session *s = con->private;\n\n\tdout(\"mdsc con_put %p (%d)\\n\", s, atomic_read(&s->s_ref) - 1);\n\tceph_put_mds_session(s);\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_put_mds_session",
          "args": [
            "s"
          ],
          "line": 3677
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_put_mds_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "374-385",
          "snippet": "void ceph_put_mds_session(struct ceph_mds_session *s)\n{\n\tdout(\"mdsc put_session %p %d -> %d\\n\", s,\n\t     atomic_read(&s->s_ref), atomic_read(&s->s_ref)-1);\n\tif (atomic_dec_and_test(&s->s_ref)) {\n\t\tif (s->s_auth.authorizer)\n\t\t\tceph_auth_destroy_authorizer(\n\t\t\t\ts->s_mdsc->fsc->client->monc.auth,\n\t\t\t\ts->s_auth.authorizer);\n\t\tkfree(s);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_put_mds_session(struct ceph_mds_session *s)\n{\n\tdout(\"mdsc put_session %p %d -> %d\\n\", s,\n\t     atomic_read(&s->s_ref), atomic_read(&s->s_ref)-1);\n\tif (atomic_dec_and_test(&s->s_ref)) {\n\t\tif (s->s_auth.authorizer)\n\t\t\tceph_auth_destroy_authorizer(\n\t\t\t\ts->s_mdsc->fsc->client->monc.auth,\n\t\t\t\ts->s_auth.authorizer);\n\t\tkfree(s);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"mdsc con_put %p (%d)\\n\"",
            "s",
            "atomic_read(&s->s_ref) - 1"
          ],
          "line": 3676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&s->s_ref"
          ],
          "line": 3676
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void con_put(struct ceph_connection *con)\n{\n\tstruct ceph_mds_session *s = con->private;\n\n\tdout(\"mdsc con_put %p (%d)\\n\", s, atomic_read(&s->s_ref) - 1);\n\tceph_put_mds_session(s);\n}"
  },
  {
    "function_name": "con_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "3660-3670",
    "snippet": "static struct ceph_connection *con_get(struct ceph_connection *con)\n{\n\tstruct ceph_mds_session *s = con->private;\n\n\tif (get_session(s)) {\n\t\tdout(\"mdsc con_get %p ok (%d)\\n\", s, atomic_read(&s->s_ref));\n\t\treturn con;\n\t}\n\tdout(\"mdsc con_get %p FAIL\\n\", s);\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"mdsc con_get %p FAIL\\n\"",
            "s"
          ],
          "line": 3668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"mdsc con_get %p ok (%d)\\n\"",
            "s",
            "atomic_read(&s->s_ref)"
          ],
          "line": 3665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&s->s_ref"
          ],
          "line": 3665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_session",
          "args": [
            "s"
          ],
          "line": 3664
        },
        "resolved": true,
        "details": {
          "function_name": "get_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "362-372",
          "snippet": "static struct ceph_mds_session *get_session(struct ceph_mds_session *s)\n{\n\tif (atomic_inc_not_zero(&s->s_ref)) {\n\t\tdout(\"mdsc get_session %p %d -> %d\\n\", s,\n\t\t     atomic_read(&s->s_ref)-1, atomic_read(&s->s_ref));\n\t\treturn s;\n\t} else {\n\t\tdout(\"mdsc get_session %p 0 -- FAIL\", s);\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_mds_session *get_session(struct ceph_mds_session *s)\n{\n\tif (atomic_inc_not_zero(&s->s_ref)) {\n\t\tdout(\"mdsc get_session %p %d -> %d\\n\", s,\n\t\t     atomic_read(&s->s_ref)-1, atomic_read(&s->s_ref));\n\t\treturn s;\n\t} else {\n\t\tdout(\"mdsc get_session %p 0 -- FAIL\", s);\n\t\treturn NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_connection *con_get(struct ceph_connection *con)\n{\n\tstruct ceph_mds_session *s = con->private;\n\n\tif (get_session(s)) {\n\t\tdout(\"mdsc con_get %p ok (%d)\\n\", s, atomic_read(&s->s_ref));\n\t\treturn con;\n\t}\n\tdout(\"mdsc con_get %p FAIL\\n\", s);\n\treturn NULL;\n}"
  },
  {
    "function_name": "ceph_mdsc_handle_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "3602-3658",
    "snippet": "void ceph_mdsc_handle_map(struct ceph_mds_client *mdsc, struct ceph_msg *msg)\n{\n\tu32 epoch;\n\tu32 maplen;\n\tvoid *p = msg->front.iov_base;\n\tvoid *end = p + msg->front.iov_len;\n\tstruct ceph_mdsmap *newmap, *oldmap;\n\tstruct ceph_fsid fsid;\n\tint err = -EINVAL;\n\n\tceph_decode_need(&p, end, sizeof(fsid)+2*sizeof(u32), bad);\n\tceph_decode_copy(&p, &fsid, sizeof(fsid));\n\tif (ceph_check_fsid(mdsc->fsc->client, &fsid) < 0)\n\t\treturn;\n\tepoch = ceph_decode_32(&p);\n\tmaplen = ceph_decode_32(&p);\n\tdout(\"handle_map epoch %u len %d\\n\", epoch, (int)maplen);\n\n\t/* do we need it? */\n\tceph_monc_got_mdsmap(&mdsc->fsc->client->monc, epoch);\n\tmutex_lock(&mdsc->mutex);\n\tif (mdsc->mdsmap && epoch <= mdsc->mdsmap->m_epoch) {\n\t\tdout(\"handle_map epoch %u <= our %u\\n\",\n\t\t     epoch, mdsc->mdsmap->m_epoch);\n\t\tmutex_unlock(&mdsc->mutex);\n\t\treturn;\n\t}\n\n\tnewmap = ceph_mdsmap_decode(&p, end);\n\tif (IS_ERR(newmap)) {\n\t\terr = PTR_ERR(newmap);\n\t\tgoto bad_unlock;\n\t}\n\n\t/* swap into place */\n\tif (mdsc->mdsmap) {\n\t\toldmap = mdsc->mdsmap;\n\t\tmdsc->mdsmap = newmap;\n\t\tcheck_new_map(mdsc, newmap, oldmap);\n\t\tceph_mdsmap_destroy(oldmap);\n\t} else {\n\t\tmdsc->mdsmap = newmap;  /* first mds map */\n\t}\n\tmdsc->fsc->sb->s_maxbytes = mdsc->mdsmap->m_max_file_size;\n\n\t__wake_requests(mdsc, &mdsc->waiting_for_map);\n\n\tmutex_unlock(&mdsc->mutex);\n\tschedule_delayed(mdsc);\n\treturn;\n\nbad_unlock:\n\tmutex_unlock(&mdsc->mutex);\nbad:\n\tpr_err(\"error decoding mdsmap %d\\n\", err);\n\treturn;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"error decoding mdsmap %d\\n\"",
            "err"
          ],
          "line": 3656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 3654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_delayed",
          "args": [
            "mdsc"
          ],
          "line": 3650
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_delayed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "3272-3277",
          "snippet": "static void schedule_delayed(struct ceph_mds_client *mdsc)\n{\n\tint delay = 5;\n\tunsigned hz = round_jiffies_relative(HZ * delay);\n\tschedule_delayed_work(&mdsc->delayed_work, hz);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void schedule_delayed(struct ceph_mds_client *mdsc)\n{\n\tint delay = 5;\n\tunsigned hz = round_jiffies_relative(HZ * delay);\n\tschedule_delayed_work(&mdsc->delayed_work, hz);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 3649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__wake_requests",
          "args": [
            "mdsc",
            "&mdsc->waiting_for_map"
          ],
          "line": 3647
        },
        "resolved": true,
        "details": {
          "function_name": "__wake_requests",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "2155-2170",
          "snippet": "static void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head)\n{\n\tstruct ceph_mds_request *req;\n\tLIST_HEAD(tmp_list);\n\n\tlist_splice_init(head, &tmp_list);\n\n\twhile (!list_empty(&tmp_list)) {\n\t\treq = list_entry(tmp_list.next,\n\t\t\t\t struct ceph_mds_request, r_wait);\n\t\tlist_del_init(&req->r_wait);\n\t\tdout(\" wake request %p tid %llu\\n\", req, req->r_tid);\n\t\t__do_request(mdsc, req);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);\n\nstatic void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head)\n{\n\tstruct ceph_mds_request *req;\n\tLIST_HEAD(tmp_list);\n\n\tlist_splice_init(head, &tmp_list);\n\n\twhile (!list_empty(&tmp_list)) {\n\t\treq = list_entry(tmp_list.next,\n\t\t\t\t struct ceph_mds_request, r_wait);\n\t\tlist_del_init(&req->r_wait);\n\t\tdout(\" wake request %p tid %llu\\n\", req, req->r_tid);\n\t\t__do_request(mdsc, req);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_mdsmap_destroy",
          "args": [
            "oldmap"
          ],
          "line": 3641
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsmap_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mdsmap.c",
          "lines": "180-189",
          "snippet": "void ceph_mdsmap_destroy(struct ceph_mdsmap *m)\n{\n\tint i;\n\n\tfor (i = 0; i < m->m_max_mds; i++)\n\t\tkfree(m->m_info[i].export_targets);\n\tkfree(m->m_info);\n\tkfree(m->m_data_pg_pools);\n\tkfree(m);\n}",
          "includes": [
            "#include \"super.h\"",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/mdsmap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/random.h>",
            "#include <linux/err.h>",
            "#include <linux/bug.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"super.h\"\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/mdsmap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/err.h>\n#include <linux/bug.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_mdsmap_destroy(struct ceph_mdsmap *m)\n{\n\tint i;\n\n\tfor (i = 0; i < m->m_max_mds; i++)\n\t\tkfree(m->m_info[i].export_targets);\n\tkfree(m->m_info);\n\tkfree(m->m_data_pg_pools);\n\tkfree(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_new_map",
          "args": [
            "mdsc",
            "newmap",
            "oldmap"
          ],
          "line": 3640
        },
        "resolved": true,
        "details": {
          "function_name": "check_new_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "2959-3044",
          "snippet": "static void check_new_map(struct ceph_mds_client *mdsc,\n\t\t\t  struct ceph_mdsmap *newmap,\n\t\t\t  struct ceph_mdsmap *oldmap)\n{\n\tint i;\n\tint oldstate, newstate;\n\tstruct ceph_mds_session *s;\n\n\tdout(\"check_new_map new %u old %u\\n\",\n\t     newmap->m_epoch, oldmap->m_epoch);\n\n\tfor (i = 0; i < oldmap->m_max_mds && i < mdsc->max_sessions; i++) {\n\t\tif (mdsc->sessions[i] == NULL)\n\t\t\tcontinue;\n\t\ts = mdsc->sessions[i];\n\t\toldstate = ceph_mdsmap_get_state(oldmap, i);\n\t\tnewstate = ceph_mdsmap_get_state(newmap, i);\n\n\t\tdout(\"check_new_map mds%d state %s%s -> %s%s (session %s)\\n\",\n\t\t     i, ceph_mds_state_name(oldstate),\n\t\t     ceph_mdsmap_is_laggy(oldmap, i) ? \" (laggy)\" : \"\",\n\t\t     ceph_mds_state_name(newstate),\n\t\t     ceph_mdsmap_is_laggy(newmap, i) ? \" (laggy)\" : \"\",\n\t\t     ceph_session_state_name(s->s_state));\n\n\t\tif (i >= newmap->m_max_mds ||\n\t\t    memcmp(ceph_mdsmap_get_addr(oldmap, i),\n\t\t\t   ceph_mdsmap_get_addr(newmap, i),\n\t\t\t   sizeof(struct ceph_entity_addr))) {\n\t\t\tif (s->s_state == CEPH_MDS_SESSION_OPENING) {\n\t\t\t\t/* the session never opened, just close it\n\t\t\t\t * out now */\n\t\t\t\t__wake_requests(mdsc, &s->s_waiting);\n\t\t\t\t__unregister_session(mdsc, s);\n\t\t\t} else {\n\t\t\t\t/* just close it */\n\t\t\t\tmutex_unlock(&mdsc->mutex);\n\t\t\t\tmutex_lock(&s->s_mutex);\n\t\t\t\tmutex_lock(&mdsc->mutex);\n\t\t\t\tceph_con_close(&s->s_con);\n\t\t\t\tmutex_unlock(&s->s_mutex);\n\t\t\t\ts->s_state = CEPH_MDS_SESSION_RESTARTING;\n\t\t\t}\n\t\t} else if (oldstate == newstate) {\n\t\t\tcontinue;  /* nothing new with this mds */\n\t\t}\n\n\t\t/*\n\t\t * send reconnect?\n\t\t */\n\t\tif (s->s_state == CEPH_MDS_SESSION_RESTARTING &&\n\t\t    newstate >= CEPH_MDS_STATE_RECONNECT) {\n\t\t\tmutex_unlock(&mdsc->mutex);\n\t\t\tsend_mds_reconnect(mdsc, s);\n\t\t\tmutex_lock(&mdsc->mutex);\n\t\t}\n\n\t\t/*\n\t\t * kick request on any mds that has gone active.\n\t\t */\n\t\tif (oldstate < CEPH_MDS_STATE_ACTIVE &&\n\t\t    newstate >= CEPH_MDS_STATE_ACTIVE) {\n\t\t\tif (oldstate != CEPH_MDS_STATE_CREATING &&\n\t\t\t    oldstate != CEPH_MDS_STATE_STARTING)\n\t\t\t\tpr_info(\"mds%d recovery completed\\n\", s->s_mds);\n\t\t\tkick_requests(mdsc, i);\n\t\t\tceph_kick_flushing_caps(mdsc, s);\n\t\t\twake_up_session_caps(s, 1);\n\t\t}\n\t}\n\n\tfor (i = 0; i < newmap->m_max_mds && i < mdsc->max_sessions; i++) {\n\t\ts = mdsc->sessions[i];\n\t\tif (!s)\n\t\t\tcontinue;\n\t\tif (!ceph_mdsmap_is_laggy(newmap, i))\n\t\t\tcontinue;\n\t\tif (s->s_state == CEPH_MDS_SESSION_OPEN ||\n\t\t    s->s_state == CEPH_MDS_SESSION_HUNG ||\n\t\t    s->s_state == CEPH_MDS_SESSION_CLOSING) {\n\t\t\tdout(\" connecting to export targets of laggy mds%d\\n\",\n\t\t\t     i);\n\t\t\t__open_export_target_sessions(mdsc, s);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void check_new_map(struct ceph_mds_client *mdsc,\n\t\t\t  struct ceph_mdsmap *newmap,\n\t\t\t  struct ceph_mdsmap *oldmap)\n{\n\tint i;\n\tint oldstate, newstate;\n\tstruct ceph_mds_session *s;\n\n\tdout(\"check_new_map new %u old %u\\n\",\n\t     newmap->m_epoch, oldmap->m_epoch);\n\n\tfor (i = 0; i < oldmap->m_max_mds && i < mdsc->max_sessions; i++) {\n\t\tif (mdsc->sessions[i] == NULL)\n\t\t\tcontinue;\n\t\ts = mdsc->sessions[i];\n\t\toldstate = ceph_mdsmap_get_state(oldmap, i);\n\t\tnewstate = ceph_mdsmap_get_state(newmap, i);\n\n\t\tdout(\"check_new_map mds%d state %s%s -> %s%s (session %s)\\n\",\n\t\t     i, ceph_mds_state_name(oldstate),\n\t\t     ceph_mdsmap_is_laggy(oldmap, i) ? \" (laggy)\" : \"\",\n\t\t     ceph_mds_state_name(newstate),\n\t\t     ceph_mdsmap_is_laggy(newmap, i) ? \" (laggy)\" : \"\",\n\t\t     ceph_session_state_name(s->s_state));\n\n\t\tif (i >= newmap->m_max_mds ||\n\t\t    memcmp(ceph_mdsmap_get_addr(oldmap, i),\n\t\t\t   ceph_mdsmap_get_addr(newmap, i),\n\t\t\t   sizeof(struct ceph_entity_addr))) {\n\t\t\tif (s->s_state == CEPH_MDS_SESSION_OPENING) {\n\t\t\t\t/* the session never opened, just close it\n\t\t\t\t * out now */\n\t\t\t\t__wake_requests(mdsc, &s->s_waiting);\n\t\t\t\t__unregister_session(mdsc, s);\n\t\t\t} else {\n\t\t\t\t/* just close it */\n\t\t\t\tmutex_unlock(&mdsc->mutex);\n\t\t\t\tmutex_lock(&s->s_mutex);\n\t\t\t\tmutex_lock(&mdsc->mutex);\n\t\t\t\tceph_con_close(&s->s_con);\n\t\t\t\tmutex_unlock(&s->s_mutex);\n\t\t\t\ts->s_state = CEPH_MDS_SESSION_RESTARTING;\n\t\t\t}\n\t\t} else if (oldstate == newstate) {\n\t\t\tcontinue;  /* nothing new with this mds */\n\t\t}\n\n\t\t/*\n\t\t * send reconnect?\n\t\t */\n\t\tif (s->s_state == CEPH_MDS_SESSION_RESTARTING &&\n\t\t    newstate >= CEPH_MDS_STATE_RECONNECT) {\n\t\t\tmutex_unlock(&mdsc->mutex);\n\t\t\tsend_mds_reconnect(mdsc, s);\n\t\t\tmutex_lock(&mdsc->mutex);\n\t\t}\n\n\t\t/*\n\t\t * kick request on any mds that has gone active.\n\t\t */\n\t\tif (oldstate < CEPH_MDS_STATE_ACTIVE &&\n\t\t    newstate >= CEPH_MDS_STATE_ACTIVE) {\n\t\t\tif (oldstate != CEPH_MDS_STATE_CREATING &&\n\t\t\t    oldstate != CEPH_MDS_STATE_STARTING)\n\t\t\t\tpr_info(\"mds%d recovery completed\\n\", s->s_mds);\n\t\t\tkick_requests(mdsc, i);\n\t\t\tceph_kick_flushing_caps(mdsc, s);\n\t\t\twake_up_session_caps(s, 1);\n\t\t}\n\t}\n\n\tfor (i = 0; i < newmap->m_max_mds && i < mdsc->max_sessions; i++) {\n\t\ts = mdsc->sessions[i];\n\t\tif (!s)\n\t\t\tcontinue;\n\t\tif (!ceph_mdsmap_is_laggy(newmap, i))\n\t\t\tcontinue;\n\t\tif (s->s_state == CEPH_MDS_SESSION_OPEN ||\n\t\t    s->s_state == CEPH_MDS_SESSION_HUNG ||\n\t\t    s->s_state == CEPH_MDS_SESSION_CLOSING) {\n\t\t\tdout(\" connecting to export targets of laggy mds%d\\n\",\n\t\t\t     i);\n\t\t\t__open_export_target_sessions(mdsc, s);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "newmap"
          ],
          "line": 3632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "newmap"
          ],
          "line": 3631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mdsmap_decode",
          "args": [
            "&p",
            "end"
          ],
          "line": 3630
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsmap_decode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mdsmap.c",
          "lines": "51-178",
          "snippet": "struct ceph_mdsmap *ceph_mdsmap_decode(void **p, void *end)\n{\n\tstruct ceph_mdsmap *m;\n\tconst void *start = *p;\n\tint i, j, n;\n\tint err = -EINVAL;\n\tu16 version;\n\n\tm = kzalloc(sizeof(*m), GFP_NOFS);\n\tif (m == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tceph_decode_16_safe(p, end, version, bad);\n\tif (version > 3) {\n\t\tpr_warn(\"got mdsmap version %d > 3, failing\", version);\n\t\tgoto bad;\n\t}\n\n\tceph_decode_need(p, end, 8*sizeof(u32) + sizeof(u64), bad);\n\tm->m_epoch = ceph_decode_32(p);\n\tm->m_client_epoch = ceph_decode_32(p);\n\tm->m_last_failure = ceph_decode_32(p);\n\tm->m_root = ceph_decode_32(p);\n\tm->m_session_timeout = ceph_decode_32(p);\n\tm->m_session_autoclose = ceph_decode_32(p);\n\tm->m_max_file_size = ceph_decode_64(p);\n\tm->m_max_mds = ceph_decode_32(p);\n\n\tm->m_info = kcalloc(m->m_max_mds, sizeof(*m->m_info), GFP_NOFS);\n\tif (m->m_info == NULL)\n\t\tgoto badmem;\n\n\t/* pick out active nodes from mds_info (state > 0) */\n\tn = ceph_decode_32(p);\n\tfor (i = 0; i < n; i++) {\n\t\tu64 global_id;\n\t\tu32 namelen;\n\t\ts32 mds, inc, state;\n\t\tu64 state_seq;\n\t\tu8 infoversion;\n\t\tstruct ceph_entity_addr addr;\n\t\tu32 num_export_targets;\n\t\tvoid *pexport_targets = NULL;\n\t\tstruct ceph_timespec laggy_since;\n\t\tstruct ceph_mds_info *info;\n\n\t\tceph_decode_need(p, end, sizeof(u64)*2 + 1 + sizeof(u32), bad);\n\t\tglobal_id = ceph_decode_64(p);\n\t\tinfoversion = ceph_decode_8(p);\n\t\t*p += sizeof(u64);\n\t\tnamelen = ceph_decode_32(p);  /* skip mds name */\n\t\t*p += namelen;\n\n\t\tceph_decode_need(p, end,\n\t\t\t\t 4*sizeof(u32) + sizeof(u64) +\n\t\t\t\t sizeof(addr) + sizeof(struct ceph_timespec),\n\t\t\t\t bad);\n\t\tmds = ceph_decode_32(p);\n\t\tinc = ceph_decode_32(p);\n\t\tstate = ceph_decode_32(p);\n\t\tstate_seq = ceph_decode_64(p);\n\t\tceph_decode_copy(p, &addr, sizeof(addr));\n\t\tceph_decode_addr(&addr);\n\t\tceph_decode_copy(p, &laggy_since, sizeof(laggy_since));\n\t\t*p += sizeof(u32);\n\t\tceph_decode_32_safe(p, end, namelen, bad);\n\t\t*p += namelen;\n\t\tif (infoversion >= 2) {\n\t\t\tceph_decode_32_safe(p, end, num_export_targets, bad);\n\t\t\tpexport_targets = *p;\n\t\t\t*p += num_export_targets * sizeof(u32);\n\t\t} else {\n\t\t\tnum_export_targets = 0;\n\t\t}\n\n\t\tdout(\"mdsmap_decode %d/%d %lld mds%d.%d %s %s\\n\",\n\t\t     i+1, n, global_id, mds, inc,\n\t\t     ceph_pr_addr(&addr.in_addr),\n\t\t     ceph_mds_state_name(state));\n\n\t\tif (mds < 0 || mds >= m->m_max_mds || state <= 0)\n\t\t\tcontinue;\n\n\t\tinfo = &m->m_info[mds];\n\t\tinfo->global_id = global_id;\n\t\tinfo->state = state;\n\t\tinfo->addr = addr;\n\t\tinfo->laggy = (laggy_since.tv_sec != 0 ||\n\t\t\t       laggy_since.tv_nsec != 0);\n\t\tinfo->num_export_targets = num_export_targets;\n\t\tif (num_export_targets) {\n\t\t\tinfo->export_targets = kcalloc(num_export_targets,\n\t\t\t\t\t\t       sizeof(u32), GFP_NOFS);\n\t\t\tif (info->export_targets == NULL)\n\t\t\t\tgoto badmem;\n\t\t\tfor (j = 0; j < num_export_targets; j++)\n\t\t\t\tinfo->export_targets[j] =\n\t\t\t\t       ceph_decode_32(&pexport_targets);\n\t\t} else {\n\t\t\tinfo->export_targets = NULL;\n\t\t}\n\t}\n\n\t/* pg_pools */\n\tceph_decode_32_safe(p, end, n, bad);\n\tm->m_num_data_pg_pools = n;\n\tm->m_data_pg_pools = kcalloc(n, sizeof(u64), GFP_NOFS);\n\tif (!m->m_data_pg_pools)\n\t\tgoto badmem;\n\tceph_decode_need(p, end, sizeof(u64)*(n+1), bad);\n\tfor (i = 0; i < n; i++)\n\t\tm->m_data_pg_pools[i] = ceph_decode_64(p);\n\tm->m_cas_pg_pool = ceph_decode_64(p);\n\n\t/* ok, we don't care about the rest. */\n\tdout(\"mdsmap_decode success epoch %u\\n\", m->m_epoch);\n\treturn m;\n\nbadmem:\n\terr = -ENOMEM;\nbad:\n\tpr_err(\"corrupt mdsmap\\n\");\n\tprint_hex_dump(KERN_DEBUG, \"mdsmap: \",\n\t\t       DUMP_PREFIX_OFFSET, 16, 1,\n\t\t       start, end - start, true);\n\tceph_mdsmap_destroy(m);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"super.h\"",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/mdsmap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/random.h>",
            "#include <linux/err.h>",
            "#include <linux/bug.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"super.h\"\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/mdsmap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/err.h>\n#include <linux/bug.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct ceph_mdsmap *ceph_mdsmap_decode(void **p, void *end)\n{\n\tstruct ceph_mdsmap *m;\n\tconst void *start = *p;\n\tint i, j, n;\n\tint err = -EINVAL;\n\tu16 version;\n\n\tm = kzalloc(sizeof(*m), GFP_NOFS);\n\tif (m == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tceph_decode_16_safe(p, end, version, bad);\n\tif (version > 3) {\n\t\tpr_warn(\"got mdsmap version %d > 3, failing\", version);\n\t\tgoto bad;\n\t}\n\n\tceph_decode_need(p, end, 8*sizeof(u32) + sizeof(u64), bad);\n\tm->m_epoch = ceph_decode_32(p);\n\tm->m_client_epoch = ceph_decode_32(p);\n\tm->m_last_failure = ceph_decode_32(p);\n\tm->m_root = ceph_decode_32(p);\n\tm->m_session_timeout = ceph_decode_32(p);\n\tm->m_session_autoclose = ceph_decode_32(p);\n\tm->m_max_file_size = ceph_decode_64(p);\n\tm->m_max_mds = ceph_decode_32(p);\n\n\tm->m_info = kcalloc(m->m_max_mds, sizeof(*m->m_info), GFP_NOFS);\n\tif (m->m_info == NULL)\n\t\tgoto badmem;\n\n\t/* pick out active nodes from mds_info (state > 0) */\n\tn = ceph_decode_32(p);\n\tfor (i = 0; i < n; i++) {\n\t\tu64 global_id;\n\t\tu32 namelen;\n\t\ts32 mds, inc, state;\n\t\tu64 state_seq;\n\t\tu8 infoversion;\n\t\tstruct ceph_entity_addr addr;\n\t\tu32 num_export_targets;\n\t\tvoid *pexport_targets = NULL;\n\t\tstruct ceph_timespec laggy_since;\n\t\tstruct ceph_mds_info *info;\n\n\t\tceph_decode_need(p, end, sizeof(u64)*2 + 1 + sizeof(u32), bad);\n\t\tglobal_id = ceph_decode_64(p);\n\t\tinfoversion = ceph_decode_8(p);\n\t\t*p += sizeof(u64);\n\t\tnamelen = ceph_decode_32(p);  /* skip mds name */\n\t\t*p += namelen;\n\n\t\tceph_decode_need(p, end,\n\t\t\t\t 4*sizeof(u32) + sizeof(u64) +\n\t\t\t\t sizeof(addr) + sizeof(struct ceph_timespec),\n\t\t\t\t bad);\n\t\tmds = ceph_decode_32(p);\n\t\tinc = ceph_decode_32(p);\n\t\tstate = ceph_decode_32(p);\n\t\tstate_seq = ceph_decode_64(p);\n\t\tceph_decode_copy(p, &addr, sizeof(addr));\n\t\tceph_decode_addr(&addr);\n\t\tceph_decode_copy(p, &laggy_since, sizeof(laggy_since));\n\t\t*p += sizeof(u32);\n\t\tceph_decode_32_safe(p, end, namelen, bad);\n\t\t*p += namelen;\n\t\tif (infoversion >= 2) {\n\t\t\tceph_decode_32_safe(p, end, num_export_targets, bad);\n\t\t\tpexport_targets = *p;\n\t\t\t*p += num_export_targets * sizeof(u32);\n\t\t} else {\n\t\t\tnum_export_targets = 0;\n\t\t}\n\n\t\tdout(\"mdsmap_decode %d/%d %lld mds%d.%d %s %s\\n\",\n\t\t     i+1, n, global_id, mds, inc,\n\t\t     ceph_pr_addr(&addr.in_addr),\n\t\t     ceph_mds_state_name(state));\n\n\t\tif (mds < 0 || mds >= m->m_max_mds || state <= 0)\n\t\t\tcontinue;\n\n\t\tinfo = &m->m_info[mds];\n\t\tinfo->global_id = global_id;\n\t\tinfo->state = state;\n\t\tinfo->addr = addr;\n\t\tinfo->laggy = (laggy_since.tv_sec != 0 ||\n\t\t\t       laggy_since.tv_nsec != 0);\n\t\tinfo->num_export_targets = num_export_targets;\n\t\tif (num_export_targets) {\n\t\t\tinfo->export_targets = kcalloc(num_export_targets,\n\t\t\t\t\t\t       sizeof(u32), GFP_NOFS);\n\t\t\tif (info->export_targets == NULL)\n\t\t\t\tgoto badmem;\n\t\t\tfor (j = 0; j < num_export_targets; j++)\n\t\t\t\tinfo->export_targets[j] =\n\t\t\t\t       ceph_decode_32(&pexport_targets);\n\t\t} else {\n\t\t\tinfo->export_targets = NULL;\n\t\t}\n\t}\n\n\t/* pg_pools */\n\tceph_decode_32_safe(p, end, n, bad);\n\tm->m_num_data_pg_pools = n;\n\tm->m_data_pg_pools = kcalloc(n, sizeof(u64), GFP_NOFS);\n\tif (!m->m_data_pg_pools)\n\t\tgoto badmem;\n\tceph_decode_need(p, end, sizeof(u64)*(n+1), bad);\n\tfor (i = 0; i < n; i++)\n\t\tm->m_data_pg_pools[i] = ceph_decode_64(p);\n\tm->m_cas_pg_pool = ceph_decode_64(p);\n\n\t/* ok, we don't care about the rest. */\n\tdout(\"mdsmap_decode success epoch %u\\n\", m->m_epoch);\n\treturn m;\n\nbadmem:\n\terr = -ENOMEM;\nbad:\n\tpr_err(\"corrupt mdsmap\\n\");\n\tprint_hex_dump(KERN_DEBUG, \"mdsmap: \",\n\t\t       DUMP_PREFIX_OFFSET, 16, 1,\n\t\t       start, end - start, true);\n\tceph_mdsmap_destroy(m);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 3626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"handle_map epoch %u <= our %u\\n\"",
            "epoch",
            "mdsc->mdsmap->m_epoch"
          ],
          "line": 3624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 3622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_monc_got_mdsmap",
          "args": [
            "&mdsc->fsc->client->monc",
            "epoch"
          ],
          "line": 3621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"handle_map epoch %u len %d\\n\"",
            "epoch",
            "(int)maplen"
          ],
          "line": 3618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_32",
          "args": [
            "&p"
          ],
          "line": 3617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_32",
          "args": [
            "&p"
          ],
          "line": 3616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_check_fsid",
          "args": [
            "mdsc->fsc->client",
            "&fsid"
          ],
          "line": 3614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_copy",
          "args": [
            "&p",
            "&fsid",
            "sizeof(fsid)"
          ],
          "line": 3613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_need",
          "args": [
            "&p",
            "end",
            "sizeof(fsid)+2*sizeof(u32)",
            "bad"
          ],
          "line": 3612
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_mdsc_handle_map(struct ceph_mds_client *mdsc, struct ceph_msg *msg)\n{\n\tu32 epoch;\n\tu32 maplen;\n\tvoid *p = msg->front.iov_base;\n\tvoid *end = p + msg->front.iov_len;\n\tstruct ceph_mdsmap *newmap, *oldmap;\n\tstruct ceph_fsid fsid;\n\tint err = -EINVAL;\n\n\tceph_decode_need(&p, end, sizeof(fsid)+2*sizeof(u32), bad);\n\tceph_decode_copy(&p, &fsid, sizeof(fsid));\n\tif (ceph_check_fsid(mdsc->fsc->client, &fsid) < 0)\n\t\treturn;\n\tepoch = ceph_decode_32(&p);\n\tmaplen = ceph_decode_32(&p);\n\tdout(\"handle_map epoch %u len %d\\n\", epoch, (int)maplen);\n\n\t/* do we need it? */\n\tceph_monc_got_mdsmap(&mdsc->fsc->client->monc, epoch);\n\tmutex_lock(&mdsc->mutex);\n\tif (mdsc->mdsmap && epoch <= mdsc->mdsmap->m_epoch) {\n\t\tdout(\"handle_map epoch %u <= our %u\\n\",\n\t\t     epoch, mdsc->mdsmap->m_epoch);\n\t\tmutex_unlock(&mdsc->mutex);\n\t\treturn;\n\t}\n\n\tnewmap = ceph_mdsmap_decode(&p, end);\n\tif (IS_ERR(newmap)) {\n\t\terr = PTR_ERR(newmap);\n\t\tgoto bad_unlock;\n\t}\n\n\t/* swap into place */\n\tif (mdsc->mdsmap) {\n\t\toldmap = mdsc->mdsmap;\n\t\tmdsc->mdsmap = newmap;\n\t\tcheck_new_map(mdsc, newmap, oldmap);\n\t\tceph_mdsmap_destroy(oldmap);\n\t} else {\n\t\tmdsc->mdsmap = newmap;  /* first mds map */\n\t}\n\tmdsc->fsc->sb->s_maxbytes = mdsc->mdsmap->m_max_file_size;\n\n\t__wake_requests(mdsc, &mdsc->waiting_for_map);\n\n\tmutex_unlock(&mdsc->mutex);\n\tschedule_delayed(mdsc);\n\treturn;\n\nbad_unlock:\n\tmutex_unlock(&mdsc->mutex);\nbad:\n\tpr_err(\"error decoding mdsmap %d\\n\", err);\n\treturn;\n}"
  },
  {
    "function_name": "ceph_mdsc_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "3583-3596",
    "snippet": "void ceph_mdsc_destroy(struct ceph_fs_client *fsc)\n{\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\n\tdout(\"mdsc_destroy %p\\n\", mdsc);\n\tceph_mdsc_stop(mdsc);\n\n\t/* flush out any connection work with references to us */\n\tceph_msgr_flush();\n\n\tfsc->mdsc = NULL;\n\tkfree(mdsc);\n\tdout(\"mdsc_destroy %p done\\n\", mdsc);\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"mdsc_destroy %p done\\n\"",
            "mdsc"
          ],
          "line": 3595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "mdsc"
          ],
          "line": 3594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_msgr_flush",
          "args": [],
          "line": 3591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_stop",
          "args": [
            "mdsc"
          ],
          "line": 3588
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "3573-3581",
          "snippet": "static void ceph_mdsc_stop(struct ceph_mds_client *mdsc)\n{\n\tdout(\"stop\\n\");\n\tcancel_delayed_work_sync(&mdsc->delayed_work); /* cancel timer */\n\tif (mdsc->mdsmap)\n\t\tceph_mdsmap_destroy(mdsc->mdsmap);\n\tkfree(mdsc->sessions);\n\tceph_caps_finalize(mdsc);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void ceph_mdsc_stop(struct ceph_mds_client *mdsc)\n{\n\tdout(\"stop\\n\");\n\tcancel_delayed_work_sync(&mdsc->delayed_work); /* cancel timer */\n\tif (mdsc->mdsmap)\n\t\tceph_mdsmap_destroy(mdsc->mdsmap);\n\tkfree(mdsc->sessions);\n\tceph_caps_finalize(mdsc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"mdsc_destroy %p\\n\"",
            "mdsc"
          ],
          "line": 3587
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_mdsc_destroy(struct ceph_fs_client *fsc)\n{\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\n\tdout(\"mdsc_destroy %p\\n\", mdsc);\n\tceph_mdsc_stop(mdsc);\n\n\t/* flush out any connection work with references to us */\n\tceph_msgr_flush();\n\n\tfsc->mdsc = NULL;\n\tkfree(mdsc);\n\tdout(\"mdsc_destroy %p done\\n\", mdsc);\n}"
  },
  {
    "function_name": "ceph_mdsc_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "3573-3581",
    "snippet": "static void ceph_mdsc_stop(struct ceph_mds_client *mdsc)\n{\n\tdout(\"stop\\n\");\n\tcancel_delayed_work_sync(&mdsc->delayed_work); /* cancel timer */\n\tif (mdsc->mdsmap)\n\t\tceph_mdsmap_destroy(mdsc->mdsmap);\n\tkfree(mdsc->sessions);\n\tceph_caps_finalize(mdsc);\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_caps_finalize",
          "args": [
            "mdsc"
          ],
          "line": 3580
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_caps_finalize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "124-141",
          "snippet": "void ceph_caps_finalize(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_cap *cap;\n\n\tspin_lock(&mdsc->caps_list_lock);\n\twhile (!list_empty(&mdsc->caps_list)) {\n\t\tcap = list_first_entry(&mdsc->caps_list,\n\t\t\t\t       struct ceph_cap, caps_item);\n\t\tlist_del(&cap->caps_item);\n\t\tkmem_cache_free(ceph_cap_cachep, cap);\n\t}\n\tmdsc->caps_total_count = 0;\n\tmdsc->caps_avail_count = 0;\n\tmdsc->caps_use_count = 0;\n\tmdsc->caps_reserve_count = 0;\n\tmdsc->caps_min_count = 0;\n\tspin_unlock(&mdsc->caps_list_lock);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_caps_finalize(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_cap *cap;\n\n\tspin_lock(&mdsc->caps_list_lock);\n\twhile (!list_empty(&mdsc->caps_list)) {\n\t\tcap = list_first_entry(&mdsc->caps_list,\n\t\t\t\t       struct ceph_cap, caps_item);\n\t\tlist_del(&cap->caps_item);\n\t\tkmem_cache_free(ceph_cap_cachep, cap);\n\t}\n\tmdsc->caps_total_count = 0;\n\tmdsc->caps_avail_count = 0;\n\tmdsc->caps_use_count = 0;\n\tmdsc->caps_reserve_count = 0;\n\tmdsc->caps_min_count = 0;\n\tspin_unlock(&mdsc->caps_list_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "mdsc->sessions"
          ],
          "line": 3579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mdsmap_destroy",
          "args": [
            "mdsc->mdsmap"
          ],
          "line": 3578
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsmap_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mdsmap.c",
          "lines": "180-189",
          "snippet": "void ceph_mdsmap_destroy(struct ceph_mdsmap *m)\n{\n\tint i;\n\n\tfor (i = 0; i < m->m_max_mds; i++)\n\t\tkfree(m->m_info[i].export_targets);\n\tkfree(m->m_info);\n\tkfree(m->m_data_pg_pools);\n\tkfree(m);\n}",
          "includes": [
            "#include \"super.h\"",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/mdsmap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/random.h>",
            "#include <linux/err.h>",
            "#include <linux/bug.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"super.h\"\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/mdsmap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/err.h>\n#include <linux/bug.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_mdsmap_destroy(struct ceph_mdsmap *m)\n{\n\tint i;\n\n\tfor (i = 0; i < m->m_max_mds; i++)\n\t\tkfree(m->m_info[i].export_targets);\n\tkfree(m->m_info);\n\tkfree(m->m_data_pg_pools);\n\tkfree(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cancel_delayed_work_sync",
          "args": [
            "&mdsc->delayed_work"
          ],
          "line": 3576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"stop\\n\""
          ],
          "line": 3575
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void ceph_mdsc_stop(struct ceph_mds_client *mdsc)\n{\n\tdout(\"stop\\n\");\n\tcancel_delayed_work_sync(&mdsc->delayed_work); /* cancel timer */\n\tif (mdsc->mdsmap)\n\t\tceph_mdsmap_destroy(mdsc->mdsmap);\n\tkfree(mdsc->sessions);\n\tceph_caps_finalize(mdsc);\n}"
  },
  {
    "function_name": "ceph_mdsc_close_sessions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "3521-3571",
    "snippet": "void ceph_mdsc_close_sessions(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_mds_session *session;\n\tint i;\n\tstruct ceph_fs_client *fsc = mdsc->fsc;\n\tunsigned long timeout = fsc->client->options->mount_timeout * HZ;\n\n\tdout(\"close_sessions\\n\");\n\n\t/* close sessions */\n\tmutex_lock(&mdsc->mutex);\n\tfor (i = 0; i < mdsc->max_sessions; i++) {\n\t\tsession = __ceph_lookup_mds_session(mdsc, i);\n\t\tif (!session)\n\t\t\tcontinue;\n\t\tmutex_unlock(&mdsc->mutex);\n\t\tmutex_lock(&session->s_mutex);\n\t\t__close_session(mdsc, session);\n\t\tmutex_unlock(&session->s_mutex);\n\t\tceph_put_mds_session(session);\n\t\tmutex_lock(&mdsc->mutex);\n\t}\n\tmutex_unlock(&mdsc->mutex);\n\n\tdout(\"waiting for sessions to close\\n\");\n\twait_event_timeout(mdsc->session_close_wq, done_closing_sessions(mdsc),\n\t\t\t   timeout);\n\n\t/* tear down remaining sessions */\n\tmutex_lock(&mdsc->mutex);\n\tfor (i = 0; i < mdsc->max_sessions; i++) {\n\t\tif (mdsc->sessions[i]) {\n\t\t\tsession = get_session(mdsc->sessions[i]);\n\t\t\t__unregister_session(mdsc, session);\n\t\t\tmutex_unlock(&mdsc->mutex);\n\t\t\tmutex_lock(&session->s_mutex);\n\t\t\tremove_session_caps(session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tceph_put_mds_session(session);\n\t\t\tmutex_lock(&mdsc->mutex);\n\t\t}\n\t}\n\tWARN_ON(!list_empty(&mdsc->cap_delay_list));\n\tmutex_unlock(&mdsc->mutex);\n\n\tceph_cleanup_empty_realms(mdsc);\n\n\tcancel_delayed_work_sync(&mdsc->delayed_work); /* cancel timer */\n\n\tdout(\"stopped\\n\");\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"stopped\\n\""
          ],
          "line": 3570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cancel_delayed_work_sync",
          "args": [
            "&mdsc->delayed_work"
          ],
          "line": 3568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_cleanup_empty_realms",
          "args": [
            "mdsc"
          ],
          "line": 3566
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_cleanup_empty_realms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
          "lines": "245-250",
          "snippet": "void ceph_cleanup_empty_realms(struct ceph_mds_client *mdsc)\n{\n\tdown_write(&mdsc->snap_rwsem);\n\t__cleanup_empty_realms(mdsc);\n\tup_write(&mdsc->snap_rwsem);\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_cleanup_empty_realms(struct ceph_mds_client *mdsc)\n{\n\tdown_write(&mdsc->snap_rwsem);\n\t__cleanup_empty_realms(mdsc);\n\tup_write(&mdsc->snap_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 3564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!list_empty(&mdsc->cap_delay_list)"
          ],
          "line": 3563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&mdsc->cap_delay_list"
          ],
          "line": 3563
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 3560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_put_mds_session",
          "args": [
            "session"
          ],
          "line": 3559
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_put_mds_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "374-385",
          "snippet": "void ceph_put_mds_session(struct ceph_mds_session *s)\n{\n\tdout(\"mdsc put_session %p %d -> %d\\n\", s,\n\t     atomic_read(&s->s_ref), atomic_read(&s->s_ref)-1);\n\tif (atomic_dec_and_test(&s->s_ref)) {\n\t\tif (s->s_auth.authorizer)\n\t\t\tceph_auth_destroy_authorizer(\n\t\t\t\ts->s_mdsc->fsc->client->monc.auth,\n\t\t\t\ts->s_auth.authorizer);\n\t\tkfree(s);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_put_mds_session(struct ceph_mds_session *s)\n{\n\tdout(\"mdsc put_session %p %d -> %d\\n\", s,\n\t     atomic_read(&s->s_ref), atomic_read(&s->s_ref)-1);\n\tif (atomic_dec_and_test(&s->s_ref)) {\n\t\tif (s->s_auth.authorizer)\n\t\t\tceph_auth_destroy_authorizer(\n\t\t\t\ts->s_mdsc->fsc->client->monc.auth,\n\t\t\t\ts->s_auth.authorizer);\n\t\tkfree(s);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&session->s_mutex"
          ],
          "line": 3558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_session_caps",
          "args": [
            "session"
          ],
          "line": 3557
        },
        "resolved": true,
        "details": {
          "function_name": "remove_session_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1141-1179",
          "snippet": "static void remove_session_caps(struct ceph_mds_session *session)\n{\n\tdout(\"remove_session_caps on %p\\n\", session);\n\titerate_session_caps(session, remove_session_caps_cb, NULL);\n\n\tspin_lock(&session->s_cap_lock);\n\tif (session->s_nr_caps > 0) {\n\t\tstruct super_block *sb = session->s_mdsc->fsc->sb;\n\t\tstruct inode *inode;\n\t\tstruct ceph_cap *cap, *prev = NULL;\n\t\tstruct ceph_vino vino;\n\t\t/*\n\t\t * iterate_session_caps() skips inodes that are being\n\t\t * deleted, we need to wait until deletions are complete.\n\t\t * __wait_on_freeing_inode() is designed for the job,\n\t\t * but it is not exported, so use lookup inode function\n\t\t * to access it.\n\t\t */\n\t\twhile (!list_empty(&session->s_caps)) {\n\t\t\tcap = list_entry(session->s_caps.next,\n\t\t\t\t\t struct ceph_cap, session_caps);\n\t\t\tif (cap == prev)\n\t\t\t\tbreak;\n\t\t\tprev = cap;\n\t\t\tvino = cap->ci->i_vino;\n\t\t\tspin_unlock(&session->s_cap_lock);\n\n\t\t\tinode = ceph_find_inode(sb, vino);\n\t\t\tiput(inode);\n\n\t\t\tspin_lock(&session->s_cap_lock);\n\t\t}\n\t}\n\tspin_unlock(&session->s_cap_lock);\n\n\tBUG_ON(session->s_nr_caps > 0);\n\tBUG_ON(!list_empty(&session->s_cap_flushing));\n\tcleanup_cap_releases(session);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void remove_session_caps(struct ceph_mds_session *session)\n{\n\tdout(\"remove_session_caps on %p\\n\", session);\n\titerate_session_caps(session, remove_session_caps_cb, NULL);\n\n\tspin_lock(&session->s_cap_lock);\n\tif (session->s_nr_caps > 0) {\n\t\tstruct super_block *sb = session->s_mdsc->fsc->sb;\n\t\tstruct inode *inode;\n\t\tstruct ceph_cap *cap, *prev = NULL;\n\t\tstruct ceph_vino vino;\n\t\t/*\n\t\t * iterate_session_caps() skips inodes that are being\n\t\t * deleted, we need to wait until deletions are complete.\n\t\t * __wait_on_freeing_inode() is designed for the job,\n\t\t * but it is not exported, so use lookup inode function\n\t\t * to access it.\n\t\t */\n\t\twhile (!list_empty(&session->s_caps)) {\n\t\t\tcap = list_entry(session->s_caps.next,\n\t\t\t\t\t struct ceph_cap, session_caps);\n\t\t\tif (cap == prev)\n\t\t\t\tbreak;\n\t\t\tprev = cap;\n\t\t\tvino = cap->ci->i_vino;\n\t\t\tspin_unlock(&session->s_cap_lock);\n\n\t\t\tinode = ceph_find_inode(sb, vino);\n\t\t\tiput(inode);\n\n\t\t\tspin_lock(&session->s_cap_lock);\n\t\t}\n\t}\n\tspin_unlock(&session->s_cap_lock);\n\n\tBUG_ON(session->s_nr_caps > 0);\n\tBUG_ON(!list_empty(&session->s_cap_flushing));\n\tcleanup_cap_releases(session);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&session->s_mutex"
          ],
          "line": 3556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 3555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__unregister_session",
          "args": [
            "mdsc",
            "session"
          ],
          "line": 3554
        },
        "resolved": true,
        "details": {
          "function_name": "__unregister_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "499-508",
          "snippet": "static void __unregister_session(struct ceph_mds_client *mdsc,\n\t\t\t       struct ceph_mds_session *s)\n{\n\tdout(\"__unregister_session mds%d %p\\n\", s->s_mds, s);\n\tBUG_ON(mdsc->sessions[s->s_mds] != s);\n\tmdsc->sessions[s->s_mds] = NULL;\n\tceph_con_close(&s->s_con);\n\tceph_put_mds_session(s);\n\tatomic_dec(&mdsc->num_sessions);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __unregister_session(struct ceph_mds_client *mdsc,\n\t\t\t       struct ceph_mds_session *s)\n{\n\tdout(\"__unregister_session mds%d %p\\n\", s->s_mds, s);\n\tBUG_ON(mdsc->sessions[s->s_mds] != s);\n\tmdsc->sessions[s->s_mds] = NULL;\n\tceph_con_close(&s->s_con);\n\tceph_put_mds_session(s);\n\tatomic_dec(&mdsc->num_sessions);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_session",
          "args": [
            "mdsc->sessions[i]"
          ],
          "line": 3553
        },
        "resolved": true,
        "details": {
          "function_name": "get_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "362-372",
          "snippet": "static struct ceph_mds_session *get_session(struct ceph_mds_session *s)\n{\n\tif (atomic_inc_not_zero(&s->s_ref)) {\n\t\tdout(\"mdsc get_session %p %d -> %d\\n\", s,\n\t\t     atomic_read(&s->s_ref)-1, atomic_read(&s->s_ref));\n\t\treturn s;\n\t} else {\n\t\tdout(\"mdsc get_session %p 0 -- FAIL\", s);\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_mds_session *get_session(struct ceph_mds_session *s)\n{\n\tif (atomic_inc_not_zero(&s->s_ref)) {\n\t\tdout(\"mdsc get_session %p %d -> %d\\n\", s,\n\t\t     atomic_read(&s->s_ref)-1, atomic_read(&s->s_ref));\n\t\treturn s;\n\t} else {\n\t\tdout(\"mdsc get_session %p 0 -- FAIL\", s);\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 3550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event_timeout",
          "args": [
            "mdsc->session_close_wq",
            "done_closing_sessions(mdsc)",
            "timeout"
          ],
          "line": 3546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "done_closing_sessions",
          "args": [
            "mdsc"
          ],
          "line": 3546
        },
        "resolved": true,
        "details": {
          "function_name": "done_closing_sessions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "3511-3516",
          "snippet": "static bool done_closing_sessions(struct ceph_mds_client *mdsc)\n{\n\tif (mdsc->fsc->mount_state == CEPH_MOUNT_SHUTDOWN)\n\t\treturn true;\n\treturn atomic_read(&mdsc->num_sessions) == 0;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic bool done_closing_sessions(struct ceph_mds_client *mdsc)\n{\n\tif (mdsc->fsc->mount_state == CEPH_MOUNT_SHUTDOWN)\n\t\treturn true;\n\treturn atomic_read(&mdsc->num_sessions) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"waiting for sessions to close\\n\""
          ],
          "line": 3545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 3543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 3541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&session->s_mutex"
          ],
          "line": 3539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__close_session",
          "args": [
            "mdsc",
            "session"
          ],
          "line": 3538
        },
        "resolved": true,
        "details": {
          "function_name": "__close_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1316-1323",
          "snippet": "static int __close_session(struct ceph_mds_client *mdsc,\n\t\t\t struct ceph_mds_session *session)\n{\n\tif (session->s_state >= CEPH_MDS_SESSION_CLOSING)\n\t\treturn 0;\n\tsession->s_state = CEPH_MDS_SESSION_CLOSING;\n\treturn request_close_session(mdsc, session);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __close_session(struct ceph_mds_client *mdsc,\n\t\t\t struct ceph_mds_session *session)\n{\n\tif (session->s_state >= CEPH_MDS_SESSION_CLOSING)\n\t\treturn 0;\n\tsession->s_state = CEPH_MDS_SESSION_CLOSING;\n\treturn request_close_session(mdsc, session);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&session->s_mutex"
          ],
          "line": 3537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 3536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ceph_lookup_mds_session",
          "args": [
            "mdsc",
            "i"
          ],
          "line": 3533
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_lookup_mds_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "390-402",
          "snippet": "struct ceph_mds_session *__ceph_lookup_mds_session(struct ceph_mds_client *mdsc,\n\t\t\t\t\t\t   int mds)\n{\n\tstruct ceph_mds_session *session;\n\n\tif (mds >= mdsc->max_sessions || mdsc->sessions[mds] == NULL)\n\t\treturn NULL;\n\tsession = mdsc->sessions[mds];\n\tdout(\"lookup_mds_session %p %d\\n\", session,\n\t     atomic_read(&session->s_ref));\n\tget_session(session);\n\treturn session;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct ceph_mds_session *__ceph_lookup_mds_session(struct ceph_mds_client *mdsc,\n\t\t\t\t\t\t   int mds)\n{\n\tstruct ceph_mds_session *session;\n\n\tif (mds >= mdsc->max_sessions || mdsc->sessions[mds] == NULL)\n\t\treturn NULL;\n\tsession = mdsc->sessions[mds];\n\tdout(\"lookup_mds_session %p %d\\n\", session,\n\t     atomic_read(&session->s_ref));\n\tget_session(session);\n\treturn session;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 3531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"close_sessions\\n\""
          ],
          "line": 3528
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_mdsc_close_sessions(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_mds_session *session;\n\tint i;\n\tstruct ceph_fs_client *fsc = mdsc->fsc;\n\tunsigned long timeout = fsc->client->options->mount_timeout * HZ;\n\n\tdout(\"close_sessions\\n\");\n\n\t/* close sessions */\n\tmutex_lock(&mdsc->mutex);\n\tfor (i = 0; i < mdsc->max_sessions; i++) {\n\t\tsession = __ceph_lookup_mds_session(mdsc, i);\n\t\tif (!session)\n\t\t\tcontinue;\n\t\tmutex_unlock(&mdsc->mutex);\n\t\tmutex_lock(&session->s_mutex);\n\t\t__close_session(mdsc, session);\n\t\tmutex_unlock(&session->s_mutex);\n\t\tceph_put_mds_session(session);\n\t\tmutex_lock(&mdsc->mutex);\n\t}\n\tmutex_unlock(&mdsc->mutex);\n\n\tdout(\"waiting for sessions to close\\n\");\n\twait_event_timeout(mdsc->session_close_wq, done_closing_sessions(mdsc),\n\t\t\t   timeout);\n\n\t/* tear down remaining sessions */\n\tmutex_lock(&mdsc->mutex);\n\tfor (i = 0; i < mdsc->max_sessions; i++) {\n\t\tif (mdsc->sessions[i]) {\n\t\t\tsession = get_session(mdsc->sessions[i]);\n\t\t\t__unregister_session(mdsc, session);\n\t\t\tmutex_unlock(&mdsc->mutex);\n\t\t\tmutex_lock(&session->s_mutex);\n\t\t\tremove_session_caps(session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tceph_put_mds_session(session);\n\t\t\tmutex_lock(&mdsc->mutex);\n\t\t}\n\t}\n\tWARN_ON(!list_empty(&mdsc->cap_delay_list));\n\tmutex_unlock(&mdsc->mutex);\n\n\tceph_cleanup_empty_realms(mdsc);\n\n\tcancel_delayed_work_sync(&mdsc->delayed_work); /* cancel timer */\n\n\tdout(\"stopped\\n\");\n}"
  },
  {
    "function_name": "done_closing_sessions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "3511-3516",
    "snippet": "static bool done_closing_sessions(struct ceph_mds_client *mdsc)\n{\n\tif (mdsc->fsc->mount_state == CEPH_MOUNT_SHUTDOWN)\n\t\treturn true;\n\treturn atomic_read(&mdsc->num_sessions) == 0;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&mdsc->num_sessions"
          ],
          "line": 3515
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic bool done_closing_sessions(struct ceph_mds_client *mdsc)\n{\n\tif (mdsc->fsc->mount_state == CEPH_MOUNT_SHUTDOWN)\n\t\treturn true;\n\treturn atomic_read(&mdsc->num_sessions) == 0;\n}"
  },
  {
    "function_name": "ceph_mdsc_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "3485-3506",
    "snippet": "void ceph_mdsc_sync(struct ceph_mds_client *mdsc)\n{\n\tu64 want_tid, want_flush;\n\n\tif (mdsc->fsc->mount_state == CEPH_MOUNT_SHUTDOWN)\n\t\treturn;\n\n\tdout(\"sync\\n\");\n\tmutex_lock(&mdsc->mutex);\n\twant_tid = mdsc->last_tid;\n\tmutex_unlock(&mdsc->mutex);\n\n\tceph_flush_dirty_caps(mdsc);\n\tspin_lock(&mdsc->cap_dirty_lock);\n\twant_flush = mdsc->cap_flush_seq;\n\tspin_unlock(&mdsc->cap_dirty_lock);\n\n\tdout(\"sync want tid %lld flush_seq %lld\\n\", want_tid, want_flush);\n\n\twait_unsafe_requests(mdsc, want_tid);\n\twait_caps_flush(mdsc, want_flush);\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_caps_flush",
          "args": [
            "mdsc",
            "want_flush"
          ],
          "line": 3505
        },
        "resolved": true,
        "details": {
          "function_name": "wait_caps_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1488-1532",
          "snippet": "static void wait_caps_flush(struct ceph_mds_client *mdsc, u64 want_flush_seq)\n{\n\tint mds;\n\n\tdout(\"check_cap_flush want %lld\\n\", want_flush_seq);\n\tmutex_lock(&mdsc->mutex);\n\tfor (mds = 0; mds < mdsc->max_sessions; mds++) {\n\t\tstruct ceph_mds_session *session = mdsc->sessions[mds];\n\t\tstruct inode *inode = NULL;\n\n\t\tif (!session)\n\t\t\tcontinue;\n\t\tget_session(session);\n\t\tmutex_unlock(&mdsc->mutex);\n\n\t\tmutex_lock(&session->s_mutex);\n\t\tif (!list_empty(&session->s_cap_flushing)) {\n\t\t\tstruct ceph_inode_info *ci =\n\t\t\t\tlist_entry(session->s_cap_flushing.next,\n\t\t\t\t\t   struct ceph_inode_info,\n\t\t\t\t\t   i_flushing_item);\n\n\t\t\tif (!check_cap_flush(&ci->vfs_inode, want_flush_seq)) {\n\t\t\t\tdout(\"check_cap_flush still flushing %p \"\n\t\t\t\t     \"seq %lld <= %lld to mds%d\\n\",\n\t\t\t\t     &ci->vfs_inode, ci->i_cap_flush_seq,\n\t\t\t\t     want_flush_seq, session->s_mds);\n\t\t\t\tinode = igrab(&ci->vfs_inode);\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&session->s_mutex);\n\t\tceph_put_mds_session(session);\n\n\t\tif (inode) {\n\t\t\twait_event(mdsc->cap_flushing_wq,\n\t\t\t\t   check_cap_flush(inode, want_flush_seq));\n\t\t\tiput(inode);\n\t\t}\n\n\t\tmutex_lock(&mdsc->mutex);\n\t}\n\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"check_cap_flush ok, flushed thru %lld\\n\", want_flush_seq);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void wait_caps_flush(struct ceph_mds_client *mdsc, u64 want_flush_seq)\n{\n\tint mds;\n\n\tdout(\"check_cap_flush want %lld\\n\", want_flush_seq);\n\tmutex_lock(&mdsc->mutex);\n\tfor (mds = 0; mds < mdsc->max_sessions; mds++) {\n\t\tstruct ceph_mds_session *session = mdsc->sessions[mds];\n\t\tstruct inode *inode = NULL;\n\n\t\tif (!session)\n\t\t\tcontinue;\n\t\tget_session(session);\n\t\tmutex_unlock(&mdsc->mutex);\n\n\t\tmutex_lock(&session->s_mutex);\n\t\tif (!list_empty(&session->s_cap_flushing)) {\n\t\t\tstruct ceph_inode_info *ci =\n\t\t\t\tlist_entry(session->s_cap_flushing.next,\n\t\t\t\t\t   struct ceph_inode_info,\n\t\t\t\t\t   i_flushing_item);\n\n\t\t\tif (!check_cap_flush(&ci->vfs_inode, want_flush_seq)) {\n\t\t\t\tdout(\"check_cap_flush still flushing %p \"\n\t\t\t\t     \"seq %lld <= %lld to mds%d\\n\",\n\t\t\t\t     &ci->vfs_inode, ci->i_cap_flush_seq,\n\t\t\t\t     want_flush_seq, session->s_mds);\n\t\t\t\tinode = igrab(&ci->vfs_inode);\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&session->s_mutex);\n\t\tceph_put_mds_session(session);\n\n\t\tif (inode) {\n\t\t\twait_event(mdsc->cap_flushing_wq,\n\t\t\t\t   check_cap_flush(inode, want_flush_seq));\n\t\t\tiput(inode);\n\t\t}\n\n\t\tmutex_lock(&mdsc->mutex);\n\t}\n\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"check_cap_flush ok, flushed thru %lld\\n\", want_flush_seq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_unsafe_requests",
          "args": [
            "mdsc",
            "want_tid"
          ],
          "line": 3504
        },
        "resolved": true,
        "details": {
          "function_name": "wait_unsafe_requests",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "3443-3483",
          "snippet": "static void wait_unsafe_requests(struct ceph_mds_client *mdsc, u64 want_tid)\n{\n\tstruct ceph_mds_request *req = NULL, *nextreq;\n\tstruct rb_node *n;\n\n\tmutex_lock(&mdsc->mutex);\n\tdout(\"wait_unsafe_requests want %lld\\n\", want_tid);\nrestart:\n\treq = __get_oldest_req(mdsc);\n\twhile (req && req->r_tid <= want_tid) {\n\t\t/* find next request */\n\t\tn = rb_next(&req->r_node);\n\t\tif (n)\n\t\t\tnextreq = rb_entry(n, struct ceph_mds_request, r_node);\n\t\telse\n\t\t\tnextreq = NULL;\n\t\tif ((req->r_op & CEPH_MDS_OP_WRITE)) {\n\t\t\t/* write op */\n\t\t\tceph_mdsc_get_request(req);\n\t\t\tif (nextreq)\n\t\t\t\tceph_mdsc_get_request(nextreq);\n\t\t\tmutex_unlock(&mdsc->mutex);\n\t\t\tdout(\"wait_unsafe_requests  wait on %llu (want %llu)\\n\",\n\t\t\t     req->r_tid, want_tid);\n\t\t\twait_for_completion(&req->r_safe_completion);\n\t\t\tmutex_lock(&mdsc->mutex);\n\t\t\tceph_mdsc_put_request(req);\n\t\t\tif (!nextreq)\n\t\t\t\tbreak;  /* next dne before, so we're done! */\n\t\t\tif (RB_EMPTY_NODE(&nextreq->r_node)) {\n\t\t\t\t/* next request was removed from tree */\n\t\t\t\tceph_mdsc_put_request(nextreq);\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t\tceph_mdsc_put_request(nextreq);  /* won't go away */\n\t\t}\n\t\treq = nextreq;\n\t}\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"wait_unsafe_requests done\\n\");\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void wait_unsafe_requests(struct ceph_mds_client *mdsc, u64 want_tid)\n{\n\tstruct ceph_mds_request *req = NULL, *nextreq;\n\tstruct rb_node *n;\n\n\tmutex_lock(&mdsc->mutex);\n\tdout(\"wait_unsafe_requests want %lld\\n\", want_tid);\nrestart:\n\treq = __get_oldest_req(mdsc);\n\twhile (req && req->r_tid <= want_tid) {\n\t\t/* find next request */\n\t\tn = rb_next(&req->r_node);\n\t\tif (n)\n\t\t\tnextreq = rb_entry(n, struct ceph_mds_request, r_node);\n\t\telse\n\t\t\tnextreq = NULL;\n\t\tif ((req->r_op & CEPH_MDS_OP_WRITE)) {\n\t\t\t/* write op */\n\t\t\tceph_mdsc_get_request(req);\n\t\t\tif (nextreq)\n\t\t\t\tceph_mdsc_get_request(nextreq);\n\t\t\tmutex_unlock(&mdsc->mutex);\n\t\t\tdout(\"wait_unsafe_requests  wait on %llu (want %llu)\\n\",\n\t\t\t     req->r_tid, want_tid);\n\t\t\twait_for_completion(&req->r_safe_completion);\n\t\t\tmutex_lock(&mdsc->mutex);\n\t\t\tceph_mdsc_put_request(req);\n\t\t\tif (!nextreq)\n\t\t\t\tbreak;  /* next dne before, so we're done! */\n\t\t\tif (RB_EMPTY_NODE(&nextreq->r_node)) {\n\t\t\t\t/* next request was removed from tree */\n\t\t\t\tceph_mdsc_put_request(nextreq);\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t\tceph_mdsc_put_request(nextreq);  /* won't go away */\n\t\t}\n\t\treq = nextreq;\n\t}\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"wait_unsafe_requests done\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"sync want tid %lld flush_seq %lld\\n\"",
            "want_tid",
            "want_flush"
          ],
          "line": 3502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mdsc->cap_dirty_lock"
          ],
          "line": 3500
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mdsc->cap_dirty_lock"
          ],
          "line": 3498
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_flush_dirty_caps",
          "args": [
            "mdsc"
          ],
          "line": 3497
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_flush_dirty_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "3273-3293",
          "snippet": "void ceph_flush_dirty_caps(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_inode_info *ci;\n\tstruct inode *inode;\n\n\tdout(\"flush_dirty_caps\\n\");\n\tspin_lock(&mdsc->cap_dirty_lock);\n\twhile (!list_empty(&mdsc->cap_dirty)) {\n\t\tci = list_first_entry(&mdsc->cap_dirty, struct ceph_inode_info,\n\t\t\t\t      i_dirty_item);\n\t\tinode = &ci->vfs_inode;\n\t\tihold(inode);\n\t\tdout(\"flush_dirty_caps %p\\n\", inode);\n\t\tspin_unlock(&mdsc->cap_dirty_lock);\n\t\tceph_check_caps(ci, CHECK_CAPS_NODELAY|CHECK_CAPS_FLUSH, NULL);\n\t\tiput(inode);\n\t\tspin_lock(&mdsc->cap_dirty_lock);\n\t}\n\tspin_unlock(&mdsc->cap_dirty_lock);\n\tdout(\"flush_dirty_caps done\\n\");\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_flush_dirty_caps(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_inode_info *ci;\n\tstruct inode *inode;\n\n\tdout(\"flush_dirty_caps\\n\");\n\tspin_lock(&mdsc->cap_dirty_lock);\n\twhile (!list_empty(&mdsc->cap_dirty)) {\n\t\tci = list_first_entry(&mdsc->cap_dirty, struct ceph_inode_info,\n\t\t\t\t      i_dirty_item);\n\t\tinode = &ci->vfs_inode;\n\t\tihold(inode);\n\t\tdout(\"flush_dirty_caps %p\\n\", inode);\n\t\tspin_unlock(&mdsc->cap_dirty_lock);\n\t\tceph_check_caps(ci, CHECK_CAPS_NODELAY|CHECK_CAPS_FLUSH, NULL);\n\t\tiput(inode);\n\t\tspin_lock(&mdsc->cap_dirty_lock);\n\t}\n\tspin_unlock(&mdsc->cap_dirty_lock);\n\tdout(\"flush_dirty_caps done\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 3495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 3493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"sync\\n\""
          ],
          "line": 3492
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_mdsc_sync(struct ceph_mds_client *mdsc)\n{\n\tu64 want_tid, want_flush;\n\n\tif (mdsc->fsc->mount_state == CEPH_MOUNT_SHUTDOWN)\n\t\treturn;\n\n\tdout(\"sync\\n\");\n\tmutex_lock(&mdsc->mutex);\n\twant_tid = mdsc->last_tid;\n\tmutex_unlock(&mdsc->mutex);\n\n\tceph_flush_dirty_caps(mdsc);\n\tspin_lock(&mdsc->cap_dirty_lock);\n\twant_flush = mdsc->cap_flush_seq;\n\tspin_unlock(&mdsc->cap_dirty_lock);\n\n\tdout(\"sync want tid %lld flush_seq %lld\\n\", want_tid, want_flush);\n\n\twait_unsafe_requests(mdsc, want_tid);\n\twait_caps_flush(mdsc, want_flush);\n}"
  },
  {
    "function_name": "wait_unsafe_requests",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "3443-3483",
    "snippet": "static void wait_unsafe_requests(struct ceph_mds_client *mdsc, u64 want_tid)\n{\n\tstruct ceph_mds_request *req = NULL, *nextreq;\n\tstruct rb_node *n;\n\n\tmutex_lock(&mdsc->mutex);\n\tdout(\"wait_unsafe_requests want %lld\\n\", want_tid);\nrestart:\n\treq = __get_oldest_req(mdsc);\n\twhile (req && req->r_tid <= want_tid) {\n\t\t/* find next request */\n\t\tn = rb_next(&req->r_node);\n\t\tif (n)\n\t\t\tnextreq = rb_entry(n, struct ceph_mds_request, r_node);\n\t\telse\n\t\t\tnextreq = NULL;\n\t\tif ((req->r_op & CEPH_MDS_OP_WRITE)) {\n\t\t\t/* write op */\n\t\t\tceph_mdsc_get_request(req);\n\t\t\tif (nextreq)\n\t\t\t\tceph_mdsc_get_request(nextreq);\n\t\t\tmutex_unlock(&mdsc->mutex);\n\t\t\tdout(\"wait_unsafe_requests  wait on %llu (want %llu)\\n\",\n\t\t\t     req->r_tid, want_tid);\n\t\t\twait_for_completion(&req->r_safe_completion);\n\t\t\tmutex_lock(&mdsc->mutex);\n\t\t\tceph_mdsc_put_request(req);\n\t\t\tif (!nextreq)\n\t\t\t\tbreak;  /* next dne before, so we're done! */\n\t\t\tif (RB_EMPTY_NODE(&nextreq->r_node)) {\n\t\t\t\t/* next request was removed from tree */\n\t\t\t\tceph_mdsc_put_request(nextreq);\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t\tceph_mdsc_put_request(nextreq);  /* won't go away */\n\t\t}\n\t\treq = nextreq;\n\t}\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"wait_unsafe_requests done\\n\");\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"wait_unsafe_requests done\\n\""
          ],
          "line": 3482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 3481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_put_request",
          "args": [
            "nextreq"
          ],
          "line": 3477
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_put_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.h",
          "lines": "377-380",
          "snippet": "static inline void ceph_mdsc_put_request(struct ceph_mds_request *req)\n{\n\tkref_put(&req->r_kref, ceph_mdsc_release_request);\n}",
          "includes": [
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mdsmap.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/kref.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/auth.h>\n#include <linux/ceph/mdsmap.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/types.h>\n#include <linux/spinlock.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/kref.h>\n#include <linux/completion.h>\n\nstatic inline void ceph_mdsc_put_request(struct ceph_mds_request *req)\n{\n\tkref_put(&req->r_kref, ceph_mdsc_release_request);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_NODE",
          "args": [
            "&nextreq->r_node"
          ],
          "line": 3472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 3468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&req->r_safe_completion"
          ],
          "line": 3467
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_wait_for_completion_rpc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "1116-1122",
          "snippet": "static int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nstatic int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"wait_unsafe_requests  wait on %llu (want %llu)\\n\"",
            "req->r_tid",
            "want_tid"
          ],
          "line": 3465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 3464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_get_request",
          "args": [
            "nextreq"
          ],
          "line": 3463
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_get_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.h",
          "lines": "372-375",
          "snippet": "static inline void ceph_mdsc_get_request(struct ceph_mds_request *req)\n{\n\tkref_get(&req->r_kref);\n}",
          "includes": [
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mdsmap.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/kref.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/auth.h>\n#include <linux/ceph/mdsmap.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/types.h>\n#include <linux/spinlock.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/kref.h>\n#include <linux/completion.h>\n\nstatic inline void ceph_mdsc_get_request(struct ceph_mds_request *req)\n{\n\tkref_get(&req->r_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structceph_mds_request",
            "r_node"
          ],
          "line": 3456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "&req->r_node"
          ],
          "line": 3454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_oldest_req",
          "args": [
            "mdsc"
          ],
          "line": 3451
        },
        "resolved": true,
        "details": {
          "function_name": "__get_oldest_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1672-1678",
          "snippet": "static struct ceph_mds_request *__get_oldest_req(struct ceph_mds_client *mdsc)\n{\n\tif (RB_EMPTY_ROOT(&mdsc->request_tree))\n\t\treturn NULL;\n\treturn rb_entry(rb_first(&mdsc->request_tree),\n\t\t\tstruct ceph_mds_request, r_node);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_mds_request *__get_oldest_req(struct ceph_mds_client *mdsc)\n{\n\tif (RB_EMPTY_ROOT(&mdsc->request_tree))\n\t\treturn NULL;\n\treturn rb_entry(rb_first(&mdsc->request_tree),\n\t\t\tstruct ceph_mds_request, r_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"wait_unsafe_requests want %lld\\n\"",
            "want_tid"
          ],
          "line": 3449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 3448
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void wait_unsafe_requests(struct ceph_mds_client *mdsc, u64 want_tid)\n{\n\tstruct ceph_mds_request *req = NULL, *nextreq;\n\tstruct rb_node *n;\n\n\tmutex_lock(&mdsc->mutex);\n\tdout(\"wait_unsafe_requests want %lld\\n\", want_tid);\nrestart:\n\treq = __get_oldest_req(mdsc);\n\twhile (req && req->r_tid <= want_tid) {\n\t\t/* find next request */\n\t\tn = rb_next(&req->r_node);\n\t\tif (n)\n\t\t\tnextreq = rb_entry(n, struct ceph_mds_request, r_node);\n\t\telse\n\t\t\tnextreq = NULL;\n\t\tif ((req->r_op & CEPH_MDS_OP_WRITE)) {\n\t\t\t/* write op */\n\t\t\tceph_mdsc_get_request(req);\n\t\t\tif (nextreq)\n\t\t\t\tceph_mdsc_get_request(nextreq);\n\t\t\tmutex_unlock(&mdsc->mutex);\n\t\t\tdout(\"wait_unsafe_requests  wait on %llu (want %llu)\\n\",\n\t\t\t     req->r_tid, want_tid);\n\t\t\twait_for_completion(&req->r_safe_completion);\n\t\t\tmutex_lock(&mdsc->mutex);\n\t\t\tceph_mdsc_put_request(req);\n\t\t\tif (!nextreq)\n\t\t\t\tbreak;  /* next dne before, so we're done! */\n\t\t\tif (RB_EMPTY_NODE(&nextreq->r_node)) {\n\t\t\t\t/* next request was removed from tree */\n\t\t\t\tceph_mdsc_put_request(nextreq);\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t\tceph_mdsc_put_request(nextreq);  /* won't go away */\n\t\t}\n\t\treq = nextreq;\n\t}\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"wait_unsafe_requests done\\n\");\n}"
  },
  {
    "function_name": "ceph_mdsc_pre_umount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "3424-3438",
    "snippet": "void ceph_mdsc_pre_umount(struct ceph_mds_client *mdsc)\n{\n\tdout(\"pre_umount\\n\");\n\tmdsc->stopping = 1;\n\n\tdrop_leases(mdsc);\n\tceph_flush_dirty_caps(mdsc);\n\twait_requests(mdsc);\n\n\t/*\n\t * wait for reply handlers to drop their request refs and\n\t * their inode/dcache refs\n\t */\n\tceph_msgr_flush();\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_msgr_flush",
          "args": [],
          "line": 3437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_requests",
          "args": [
            "mdsc"
          ],
          "line": 3431
        },
        "resolved": true,
        "details": {
          "function_name": "wait_requests",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "3395-3418",
          "snippet": "static void wait_requests(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_mds_request *req;\n\tstruct ceph_fs_client *fsc = mdsc->fsc;\n\n\tmutex_lock(&mdsc->mutex);\n\tif (__get_oldest_req(mdsc)) {\n\t\tmutex_unlock(&mdsc->mutex);\n\n\t\tdout(\"wait_requests waiting for requests\\n\");\n\t\twait_for_completion_timeout(&mdsc->safe_umount_waiters,\n\t\t\t\t    fsc->client->options->mount_timeout * HZ);\n\n\t\t/* tear down remaining requests */\n\t\tmutex_lock(&mdsc->mutex);\n\t\twhile ((req = __get_oldest_req(mdsc))) {\n\t\t\tdout(\"wait_requests timed out on tid %llu\\n\",\n\t\t\t     req->r_tid);\n\t\t\t__unregister_request(mdsc, req);\n\t\t}\n\t}\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"wait_requests done\\n\");\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void wait_requests(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_mds_request *req;\n\tstruct ceph_fs_client *fsc = mdsc->fsc;\n\n\tmutex_lock(&mdsc->mutex);\n\tif (__get_oldest_req(mdsc)) {\n\t\tmutex_unlock(&mdsc->mutex);\n\n\t\tdout(\"wait_requests waiting for requests\\n\");\n\t\twait_for_completion_timeout(&mdsc->safe_umount_waiters,\n\t\t\t\t    fsc->client->options->mount_timeout * HZ);\n\n\t\t/* tear down remaining requests */\n\t\tmutex_lock(&mdsc->mutex);\n\t\twhile ((req = __get_oldest_req(mdsc))) {\n\t\t\tdout(\"wait_requests timed out on tid %llu\\n\",\n\t\t\t     req->r_tid);\n\t\t\t__unregister_request(mdsc, req);\n\t\t}\n\t}\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"wait_requests done\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_flush_dirty_caps",
          "args": [
            "mdsc"
          ],
          "line": 3430
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_flush_dirty_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "3273-3293",
          "snippet": "void ceph_flush_dirty_caps(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_inode_info *ci;\n\tstruct inode *inode;\n\n\tdout(\"flush_dirty_caps\\n\");\n\tspin_lock(&mdsc->cap_dirty_lock);\n\twhile (!list_empty(&mdsc->cap_dirty)) {\n\t\tci = list_first_entry(&mdsc->cap_dirty, struct ceph_inode_info,\n\t\t\t\t      i_dirty_item);\n\t\tinode = &ci->vfs_inode;\n\t\tihold(inode);\n\t\tdout(\"flush_dirty_caps %p\\n\", inode);\n\t\tspin_unlock(&mdsc->cap_dirty_lock);\n\t\tceph_check_caps(ci, CHECK_CAPS_NODELAY|CHECK_CAPS_FLUSH, NULL);\n\t\tiput(inode);\n\t\tspin_lock(&mdsc->cap_dirty_lock);\n\t}\n\tspin_unlock(&mdsc->cap_dirty_lock);\n\tdout(\"flush_dirty_caps done\\n\");\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_flush_dirty_caps(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_inode_info *ci;\n\tstruct inode *inode;\n\n\tdout(\"flush_dirty_caps\\n\");\n\tspin_lock(&mdsc->cap_dirty_lock);\n\twhile (!list_empty(&mdsc->cap_dirty)) {\n\t\tci = list_first_entry(&mdsc->cap_dirty, struct ceph_inode_info,\n\t\t\t\t      i_dirty_item);\n\t\tinode = &ci->vfs_inode;\n\t\tihold(inode);\n\t\tdout(\"flush_dirty_caps %p\\n\", inode);\n\t\tspin_unlock(&mdsc->cap_dirty_lock);\n\t\tceph_check_caps(ci, CHECK_CAPS_NODELAY|CHECK_CAPS_FLUSH, NULL);\n\t\tiput(inode);\n\t\tspin_lock(&mdsc->cap_dirty_lock);\n\t}\n\tspin_unlock(&mdsc->cap_dirty_lock);\n\tdout(\"flush_dirty_caps done\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_leases",
          "args": [
            "mdsc"
          ],
          "line": 3429
        },
        "resolved": true,
        "details": {
          "function_name": "drop_leases",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "3248-3265",
          "snippet": "static void drop_leases(struct ceph_mds_client *mdsc)\n{\n\tint i;\n\n\tdout(\"drop_leases\\n\");\n\tmutex_lock(&mdsc->mutex);\n\tfor (i = 0; i < mdsc->max_sessions; i++) {\n\t\tstruct ceph_mds_session *s = __ceph_lookup_mds_session(mdsc, i);\n\t\tif (!s)\n\t\t\tcontinue;\n\t\tmutex_unlock(&mdsc->mutex);\n\t\tmutex_lock(&s->s_mutex);\n\t\tmutex_unlock(&s->s_mutex);\n\t\tceph_put_mds_session(s);\n\t\tmutex_lock(&mdsc->mutex);\n\t}\n\tmutex_unlock(&mdsc->mutex);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void drop_leases(struct ceph_mds_client *mdsc)\n{\n\tint i;\n\n\tdout(\"drop_leases\\n\");\n\tmutex_lock(&mdsc->mutex);\n\tfor (i = 0; i < mdsc->max_sessions; i++) {\n\t\tstruct ceph_mds_session *s = __ceph_lookup_mds_session(mdsc, i);\n\t\tif (!s)\n\t\t\tcontinue;\n\t\tmutex_unlock(&mdsc->mutex);\n\t\tmutex_lock(&s->s_mutex);\n\t\tmutex_unlock(&s->s_mutex);\n\t\tceph_put_mds_session(s);\n\t\tmutex_lock(&mdsc->mutex);\n\t}\n\tmutex_unlock(&mdsc->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"pre_umount\\n\""
          ],
          "line": 3426
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_mdsc_pre_umount(struct ceph_mds_client *mdsc)\n{\n\tdout(\"pre_umount\\n\");\n\tmdsc->stopping = 1;\n\n\tdrop_leases(mdsc);\n\tceph_flush_dirty_caps(mdsc);\n\twait_requests(mdsc);\n\n\t/*\n\t * wait for reply handlers to drop their request refs and\n\t * their inode/dcache refs\n\t */\n\tceph_msgr_flush();\n}"
  },
  {
    "function_name": "wait_requests",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "3395-3418",
    "snippet": "static void wait_requests(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_mds_request *req;\n\tstruct ceph_fs_client *fsc = mdsc->fsc;\n\n\tmutex_lock(&mdsc->mutex);\n\tif (__get_oldest_req(mdsc)) {\n\t\tmutex_unlock(&mdsc->mutex);\n\n\t\tdout(\"wait_requests waiting for requests\\n\");\n\t\twait_for_completion_timeout(&mdsc->safe_umount_waiters,\n\t\t\t\t    fsc->client->options->mount_timeout * HZ);\n\n\t\t/* tear down remaining requests */\n\t\tmutex_lock(&mdsc->mutex);\n\t\twhile ((req = __get_oldest_req(mdsc))) {\n\t\t\tdout(\"wait_requests timed out on tid %llu\\n\",\n\t\t\t     req->r_tid);\n\t\t\t__unregister_request(mdsc, req);\n\t\t}\n\t}\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"wait_requests done\\n\");\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"wait_requests done\\n\""
          ],
          "line": 3417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 3416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__unregister_request",
          "args": [
            "mdsc",
            "req"
          ],
          "line": 3413
        },
        "resolved": true,
        "details": {
          "function_name": "__unregister_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "643-664",
          "snippet": "static void __unregister_request(struct ceph_mds_client *mdsc,\n\t\t\t\t struct ceph_mds_request *req)\n{\n\tdout(\"__unregister_request %p tid %lld\\n\", req, req->r_tid);\n\trb_erase(&req->r_node, &mdsc->request_tree);\n\tRB_CLEAR_NODE(&req->r_node);\n\n\tif (req->r_unsafe_dir) {\n\t\tstruct ceph_inode_info *ci = ceph_inode(req->r_unsafe_dir);\n\n\t\tspin_lock(&ci->i_unsafe_lock);\n\t\tlist_del_init(&req->r_unsafe_dir_item);\n\t\tspin_unlock(&ci->i_unsafe_lock);\n\n\t\tiput(req->r_unsafe_dir);\n\t\treq->r_unsafe_dir = NULL;\n\t}\n\n\tcomplete_all(&req->r_safe_completion);\n\n\tceph_mdsc_put_request(req);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __unregister_request(struct ceph_mds_client *mdsc,\n\t\t\t\t struct ceph_mds_request *req)\n{\n\tdout(\"__unregister_request %p tid %lld\\n\", req, req->r_tid);\n\trb_erase(&req->r_node, &mdsc->request_tree);\n\tRB_CLEAR_NODE(&req->r_node);\n\n\tif (req->r_unsafe_dir) {\n\t\tstruct ceph_inode_info *ci = ceph_inode(req->r_unsafe_dir);\n\n\t\tspin_lock(&ci->i_unsafe_lock);\n\t\tlist_del_init(&req->r_unsafe_dir_item);\n\t\tspin_unlock(&ci->i_unsafe_lock);\n\n\t\tiput(req->r_unsafe_dir);\n\t\treq->r_unsafe_dir = NULL;\n\t}\n\n\tcomplete_all(&req->r_safe_completion);\n\n\tceph_mdsc_put_request(req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"wait_requests timed out on tid %llu\\n\"",
            "req->r_tid"
          ],
          "line": 3411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_oldest_req",
          "args": [
            "mdsc"
          ],
          "line": 3410
        },
        "resolved": true,
        "details": {
          "function_name": "__get_oldest_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1672-1678",
          "snippet": "static struct ceph_mds_request *__get_oldest_req(struct ceph_mds_client *mdsc)\n{\n\tif (RB_EMPTY_ROOT(&mdsc->request_tree))\n\t\treturn NULL;\n\treturn rb_entry(rb_first(&mdsc->request_tree),\n\t\t\tstruct ceph_mds_request, r_node);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_mds_request *__get_oldest_req(struct ceph_mds_client *mdsc)\n{\n\tif (RB_EMPTY_ROOT(&mdsc->request_tree))\n\t\treturn NULL;\n\treturn rb_entry(rb_first(&mdsc->request_tree),\n\t\t\tstruct ceph_mds_request, r_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 3409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_completion_timeout",
          "args": [
            "&mdsc->safe_umount_waiters",
            "fsc->client->options->mount_timeout * HZ"
          ],
          "line": 3405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"wait_requests waiting for requests\\n\""
          ],
          "line": 3404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 3402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 3400
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void wait_requests(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_mds_request *req;\n\tstruct ceph_fs_client *fsc = mdsc->fsc;\n\n\tmutex_lock(&mdsc->mutex);\n\tif (__get_oldest_req(mdsc)) {\n\t\tmutex_unlock(&mdsc->mutex);\n\n\t\tdout(\"wait_requests waiting for requests\\n\");\n\t\twait_for_completion_timeout(&mdsc->safe_umount_waiters,\n\t\t\t\t    fsc->client->options->mount_timeout * HZ);\n\n\t\t/* tear down remaining requests */\n\t\tmutex_lock(&mdsc->mutex);\n\t\twhile ((req = __get_oldest_req(mdsc))) {\n\t\t\tdout(\"wait_requests timed out on tid %llu\\n\",\n\t\t\t     req->r_tid);\n\t\t\t__unregister_request(mdsc, req);\n\t\t}\n\t}\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"wait_requests done\\n\");\n}"
  },
  {
    "function_name": "ceph_mdsc_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "3340-3389",
    "snippet": "int ceph_mdsc_init(struct ceph_fs_client *fsc)\n\n{\n\tstruct ceph_mds_client *mdsc;\n\n\tmdsc = kzalloc(sizeof(struct ceph_mds_client), GFP_NOFS);\n\tif (!mdsc)\n\t\treturn -ENOMEM;\n\tmdsc->fsc = fsc;\n\tfsc->mdsc = mdsc;\n\tmutex_init(&mdsc->mutex);\n\tmdsc->mdsmap = kzalloc(sizeof(*mdsc->mdsmap), GFP_NOFS);\n\tif (mdsc->mdsmap == NULL) {\n\t\tkfree(mdsc);\n\t\treturn -ENOMEM;\n\t}\n\n\tinit_completion(&mdsc->safe_umount_waiters);\n\tinit_waitqueue_head(&mdsc->session_close_wq);\n\tINIT_LIST_HEAD(&mdsc->waiting_for_map);\n\tmdsc->sessions = NULL;\n\tatomic_set(&mdsc->num_sessions, 0);\n\tmdsc->max_sessions = 0;\n\tmdsc->stopping = 0;\n\tinit_rwsem(&mdsc->snap_rwsem);\n\tmdsc->snap_realms = RB_ROOT;\n\tINIT_LIST_HEAD(&mdsc->snap_empty);\n\tspin_lock_init(&mdsc->snap_empty_lock);\n\tmdsc->last_tid = 0;\n\tmdsc->request_tree = RB_ROOT;\n\tINIT_DELAYED_WORK(&mdsc->delayed_work, delayed_work);\n\tmdsc->last_renew_caps = jiffies;\n\tINIT_LIST_HEAD(&mdsc->cap_delay_list);\n\tspin_lock_init(&mdsc->cap_delay_lock);\n\tINIT_LIST_HEAD(&mdsc->snap_flush_list);\n\tspin_lock_init(&mdsc->snap_flush_lock);\n\tmdsc->cap_flush_seq = 0;\n\tINIT_LIST_HEAD(&mdsc->cap_dirty);\n\tINIT_LIST_HEAD(&mdsc->cap_dirty_migrating);\n\tmdsc->num_cap_flushing = 0;\n\tspin_lock_init(&mdsc->cap_dirty_lock);\n\tinit_waitqueue_head(&mdsc->cap_flushing_wq);\n\tspin_lock_init(&mdsc->dentry_lru_lock);\n\tINIT_LIST_HEAD(&mdsc->dentry_lru);\n\n\tceph_caps_init(mdsc);\n\tceph_adjust_min_caps(mdsc, fsc->min_caps);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_adjust_min_caps",
          "args": [
            "mdsc",
            "fsc->min_caps"
          ],
          "line": 3386
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_adjust_min_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "143-149",
          "snippet": "void ceph_adjust_min_caps(struct ceph_mds_client *mdsc, int delta)\n{\n\tspin_lock(&mdsc->caps_list_lock);\n\tmdsc->caps_min_count += delta;\n\tBUG_ON(mdsc->caps_min_count < 0);\n\tspin_unlock(&mdsc->caps_list_lock);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_adjust_min_caps(struct ceph_mds_client *mdsc, int delta)\n{\n\tspin_lock(&mdsc->caps_list_lock);\n\tmdsc->caps_min_count += delta;\n\tBUG_ON(mdsc->caps_min_count < 0);\n\tspin_unlock(&mdsc->caps_list_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_caps_init",
          "args": [
            "mdsc"
          ],
          "line": 3385
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_caps_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "118-122",
          "snippet": "void ceph_caps_init(struct ceph_mds_client *mdsc)\n{\n\tINIT_LIST_HEAD(&mdsc->caps_list);\n\tspin_lock_init(&mdsc->caps_list_lock);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_caps_init(struct ceph_mds_client *mdsc)\n{\n\tINIT_LIST_HEAD(&mdsc->caps_list);\n\tspin_lock_init(&mdsc->caps_list_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&mdsc->dentry_lru"
          ],
          "line": 3383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&mdsc->dentry_lru_lock"
          ],
          "line": 3382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&mdsc->cap_flushing_wq"
          ],
          "line": 3381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&mdsc->cap_dirty_lock"
          ],
          "line": 3380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&mdsc->cap_dirty_migrating"
          ],
          "line": 3378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&mdsc->cap_dirty"
          ],
          "line": 3377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&mdsc->snap_flush_lock"
          ],
          "line": 3375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&mdsc->snap_flush_list"
          ],
          "line": 3374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&mdsc->cap_delay_lock"
          ],
          "line": 3373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&mdsc->cap_delay_list"
          ],
          "line": 3372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_DELAYED_WORK",
          "args": [
            "&mdsc->delayed_work",
            "delayed_work"
          ],
          "line": 3370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&mdsc->snap_empty_lock"
          ],
          "line": 3367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&mdsc->snap_empty"
          ],
          "line": 3366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&mdsc->snap_rwsem"
          ],
          "line": 3364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&mdsc->num_sessions",
            "0"
          ],
          "line": 3361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&mdsc->waiting_for_map"
          ],
          "line": 3359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&mdsc->session_close_wq"
          ],
          "line": 3358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&mdsc->safe_umount_waiters"
          ],
          "line": 3357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "mdsc"
          ],
          "line": 3353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*mdsc->mdsmap)",
            "GFP_NOFS"
          ],
          "line": 3351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 3350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct ceph_mds_client)",
            "GFP_NOFS"
          ],
          "line": 3345
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_mdsc_init(struct ceph_fs_client *fsc)\n\n{\n\tstruct ceph_mds_client *mdsc;\n\n\tmdsc = kzalloc(sizeof(struct ceph_mds_client), GFP_NOFS);\n\tif (!mdsc)\n\t\treturn -ENOMEM;\n\tmdsc->fsc = fsc;\n\tfsc->mdsc = mdsc;\n\tmutex_init(&mdsc->mutex);\n\tmdsc->mdsmap = kzalloc(sizeof(*mdsc->mdsmap), GFP_NOFS);\n\tif (mdsc->mdsmap == NULL) {\n\t\tkfree(mdsc);\n\t\treturn -ENOMEM;\n\t}\n\n\tinit_completion(&mdsc->safe_umount_waiters);\n\tinit_waitqueue_head(&mdsc->session_close_wq);\n\tINIT_LIST_HEAD(&mdsc->waiting_for_map);\n\tmdsc->sessions = NULL;\n\tatomic_set(&mdsc->num_sessions, 0);\n\tmdsc->max_sessions = 0;\n\tmdsc->stopping = 0;\n\tinit_rwsem(&mdsc->snap_rwsem);\n\tmdsc->snap_realms = RB_ROOT;\n\tINIT_LIST_HEAD(&mdsc->snap_empty);\n\tspin_lock_init(&mdsc->snap_empty_lock);\n\tmdsc->last_tid = 0;\n\tmdsc->request_tree = RB_ROOT;\n\tINIT_DELAYED_WORK(&mdsc->delayed_work, delayed_work);\n\tmdsc->last_renew_caps = jiffies;\n\tINIT_LIST_HEAD(&mdsc->cap_delay_list);\n\tspin_lock_init(&mdsc->cap_delay_lock);\n\tINIT_LIST_HEAD(&mdsc->snap_flush_list);\n\tspin_lock_init(&mdsc->snap_flush_lock);\n\tmdsc->cap_flush_seq = 0;\n\tINIT_LIST_HEAD(&mdsc->cap_dirty);\n\tINIT_LIST_HEAD(&mdsc->cap_dirty_migrating);\n\tmdsc->num_cap_flushing = 0;\n\tspin_lock_init(&mdsc->cap_dirty_lock);\n\tinit_waitqueue_head(&mdsc->cap_flushing_wq);\n\tspin_lock_init(&mdsc->dentry_lru_lock);\n\tINIT_LIST_HEAD(&mdsc->dentry_lru);\n\n\tceph_caps_init(mdsc);\n\tceph_adjust_min_caps(mdsc, fsc->min_caps);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "delayed_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "3279-3338",
    "snippet": "static void delayed_work(struct work_struct *work)\n{\n\tint i;\n\tstruct ceph_mds_client *mdsc =\n\t\tcontainer_of(work, struct ceph_mds_client, delayed_work.work);\n\tint renew_interval;\n\tint renew_caps;\n\n\tdout(\"mdsc delayed_work\\n\");\n\tceph_check_delayed_caps(mdsc);\n\n\tmutex_lock(&mdsc->mutex);\n\trenew_interval = mdsc->mdsmap->m_session_timeout >> 2;\n\trenew_caps = time_after_eq(jiffies, HZ*renew_interval +\n\t\t\t\t   mdsc->last_renew_caps);\n\tif (renew_caps)\n\t\tmdsc->last_renew_caps = jiffies;\n\n\tfor (i = 0; i < mdsc->max_sessions; i++) {\n\t\tstruct ceph_mds_session *s = __ceph_lookup_mds_session(mdsc, i);\n\t\tif (s == NULL)\n\t\t\tcontinue;\n\t\tif (s->s_state == CEPH_MDS_SESSION_CLOSING) {\n\t\t\tdout(\"resending session close request for mds%d\\n\",\n\t\t\t     s->s_mds);\n\t\t\trequest_close_session(mdsc, s);\n\t\t\tceph_put_mds_session(s);\n\t\t\tcontinue;\n\t\t}\n\t\tif (s->s_ttl && time_after(jiffies, s->s_ttl)) {\n\t\t\tif (s->s_state == CEPH_MDS_SESSION_OPEN) {\n\t\t\t\ts->s_state = CEPH_MDS_SESSION_HUNG;\n\t\t\t\tpr_info(\"mds%d hung\\n\", s->s_mds);\n\t\t\t}\n\t\t}\n\t\tif (s->s_state < CEPH_MDS_SESSION_OPEN) {\n\t\t\t/* this mds is failed or recovering, just wait */\n\t\t\tceph_put_mds_session(s);\n\t\t\tcontinue;\n\t\t}\n\t\tmutex_unlock(&mdsc->mutex);\n\n\t\tmutex_lock(&s->s_mutex);\n\t\tif (renew_caps)\n\t\t\tsend_renew_caps(mdsc, s);\n\t\telse\n\t\t\tceph_con_keepalive(&s->s_con);\n\t\tceph_add_cap_releases(mdsc, s);\n\t\tif (s->s_state == CEPH_MDS_SESSION_OPEN ||\n\t\t    s->s_state == CEPH_MDS_SESSION_HUNG)\n\t\t\tceph_send_cap_releases(mdsc, s);\n\t\tmutex_unlock(&s->s_mutex);\n\t\tceph_put_mds_session(s);\n\n\t\tmutex_lock(&mdsc->mutex);\n\t}\n\tmutex_unlock(&mdsc->mutex);\n\n\tschedule_delayed(mdsc);\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_delayed",
          "args": [
            "mdsc"
          ],
          "line": 3337
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_delayed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "3272-3277",
          "snippet": "static void schedule_delayed(struct ceph_mds_client *mdsc)\n{\n\tint delay = 5;\n\tunsigned hz = round_jiffies_relative(HZ * delay);\n\tschedule_delayed_work(&mdsc->delayed_work, hz);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void schedule_delayed(struct ceph_mds_client *mdsc)\n{\n\tint delay = 5;\n\tunsigned hz = round_jiffies_relative(HZ * delay);\n\tschedule_delayed_work(&mdsc->delayed_work, hz);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 3335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 3333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_put_mds_session",
          "args": [
            "s"
          ],
          "line": 3331
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_put_mds_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "374-385",
          "snippet": "void ceph_put_mds_session(struct ceph_mds_session *s)\n{\n\tdout(\"mdsc put_session %p %d -> %d\\n\", s,\n\t     atomic_read(&s->s_ref), atomic_read(&s->s_ref)-1);\n\tif (atomic_dec_and_test(&s->s_ref)) {\n\t\tif (s->s_auth.authorizer)\n\t\t\tceph_auth_destroy_authorizer(\n\t\t\t\ts->s_mdsc->fsc->client->monc.auth,\n\t\t\t\ts->s_auth.authorizer);\n\t\tkfree(s);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_put_mds_session(struct ceph_mds_session *s)\n{\n\tdout(\"mdsc put_session %p %d -> %d\\n\", s,\n\t     atomic_read(&s->s_ref), atomic_read(&s->s_ref)-1);\n\tif (atomic_dec_and_test(&s->s_ref)) {\n\t\tif (s->s_auth.authorizer)\n\t\t\tceph_auth_destroy_authorizer(\n\t\t\t\ts->s_mdsc->fsc->client->monc.auth,\n\t\t\t\ts->s_auth.authorizer);\n\t\tkfree(s);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&s->s_mutex"
          ],
          "line": 3330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_send_cap_releases",
          "args": [
            "mdsc",
            "s"
          ],
          "line": 3329
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_send_cap_releases",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1537-1555",
          "snippet": "void ceph_send_cap_releases(struct ceph_mds_client *mdsc,\n\t\t\t    struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *msg;\n\n\tdout(\"send_cap_releases mds%d\\n\", session->s_mds);\n\tspin_lock(&session->s_cap_lock);\n\twhile (!list_empty(&session->s_cap_releases_done)) {\n\t\tmsg = list_first_entry(&session->s_cap_releases_done,\n\t\t\t\t struct ceph_msg, list_head);\n\t\tlist_del_init(&msg->list_head);\n\t\tspin_unlock(&session->s_cap_lock);\n\t\tmsg->hdr.front_len = cpu_to_le32(msg->front.iov_len);\n\t\tdout(\"send_cap_releases mds%d %p\\n\", session->s_mds, msg);\n\t\tceph_con_send(&session->s_con, msg);\n\t\tspin_lock(&session->s_cap_lock);\n\t}\n\tspin_unlock(&session->s_cap_lock);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_send_cap_releases(struct ceph_mds_client *mdsc,\n\t\t\t    struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *msg;\n\n\tdout(\"send_cap_releases mds%d\\n\", session->s_mds);\n\tspin_lock(&session->s_cap_lock);\n\twhile (!list_empty(&session->s_cap_releases_done)) {\n\t\tmsg = list_first_entry(&session->s_cap_releases_done,\n\t\t\t\t struct ceph_msg, list_head);\n\t\tlist_del_init(&msg->list_head);\n\t\tspin_unlock(&session->s_cap_lock);\n\t\tmsg->hdr.front_len = cpu_to_le32(msg->front.iov_len);\n\t\tdout(\"send_cap_releases mds%d %p\\n\", session->s_mds, msg);\n\t\tceph_con_send(&session->s_con, msg);\n\t\tspin_lock(&session->s_cap_lock);\n\t}\n\tspin_unlock(&session->s_cap_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_add_cap_releases",
          "args": [
            "mdsc",
            "s"
          ],
          "line": 3326
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_add_cap_releases",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1412-1468",
          "snippet": "int ceph_add_cap_releases(struct ceph_mds_client *mdsc,\n\t\t\t  struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *msg, *partial = NULL;\n\tstruct ceph_mds_cap_release *head;\n\tint err = -ENOMEM;\n\tint extra = mdsc->fsc->mount_options->cap_release_safety;\n\tint num;\n\n\tdout(\"add_cap_releases %p mds%d extra %d\\n\", session, session->s_mds,\n\t     extra);\n\n\tspin_lock(&session->s_cap_lock);\n\n\tif (!list_empty(&session->s_cap_releases)) {\n\t\tmsg = list_first_entry(&session->s_cap_releases,\n\t\t\t\t       struct ceph_msg,\n\t\t\t\t list_head);\n\t\thead = msg->front.iov_base;\n\t\tnum = le32_to_cpu(head->num);\n\t\tif (num) {\n\t\t\tdout(\" partial %p with (%d/%d)\\n\", msg, num,\n\t\t\t     (int)CEPH_CAPS_PER_RELEASE);\n\t\t\textra += CEPH_CAPS_PER_RELEASE - num;\n\t\t\tpartial = msg;\n\t\t}\n\t}\n\twhile (session->s_num_cap_releases < session->s_nr_caps + extra) {\n\t\tspin_unlock(&session->s_cap_lock);\n\t\tmsg = ceph_msg_new(CEPH_MSG_CLIENT_CAPRELEASE, PAGE_CACHE_SIZE,\n\t\t\t\t   GFP_NOFS, false);\n\t\tif (!msg)\n\t\t\tgoto out_unlocked;\n\t\tdout(\"add_cap_releases %p msg %p now %d\\n\", session, msg,\n\t\t     (int)msg->front.iov_len);\n\t\thead = msg->front.iov_base;\n\t\thead->num = cpu_to_le32(0);\n\t\tmsg->front.iov_len = sizeof(*head);\n\t\tspin_lock(&session->s_cap_lock);\n\t\tlist_add(&msg->list_head, &session->s_cap_releases);\n\t\tsession->s_num_cap_releases += CEPH_CAPS_PER_RELEASE;\n\t}\n\n\tif (partial) {\n\t\thead = partial->front.iov_base;\n\t\tnum = le32_to_cpu(head->num);\n\t\tdout(\" queueing partial %p with %d/%d\\n\", partial, num,\n\t\t     (int)CEPH_CAPS_PER_RELEASE);\n\t\tlist_move_tail(&partial->list_head,\n\t\t\t       &session->s_cap_releases_done);\n\t\tsession->s_num_cap_releases -= CEPH_CAPS_PER_RELEASE - num;\n\t}\n\terr = 0;\n\tspin_unlock(&session->s_cap_lock);\nout_unlocked:\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);\n\nint ceph_add_cap_releases(struct ceph_mds_client *mdsc,\n\t\t\t  struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *msg, *partial = NULL;\n\tstruct ceph_mds_cap_release *head;\n\tint err = -ENOMEM;\n\tint extra = mdsc->fsc->mount_options->cap_release_safety;\n\tint num;\n\n\tdout(\"add_cap_releases %p mds%d extra %d\\n\", session, session->s_mds,\n\t     extra);\n\n\tspin_lock(&session->s_cap_lock);\n\n\tif (!list_empty(&session->s_cap_releases)) {\n\t\tmsg = list_first_entry(&session->s_cap_releases,\n\t\t\t\t       struct ceph_msg,\n\t\t\t\t list_head);\n\t\thead = msg->front.iov_base;\n\t\tnum = le32_to_cpu(head->num);\n\t\tif (num) {\n\t\t\tdout(\" partial %p with (%d/%d)\\n\", msg, num,\n\t\t\t     (int)CEPH_CAPS_PER_RELEASE);\n\t\t\textra += CEPH_CAPS_PER_RELEASE - num;\n\t\t\tpartial = msg;\n\t\t}\n\t}\n\twhile (session->s_num_cap_releases < session->s_nr_caps + extra) {\n\t\tspin_unlock(&session->s_cap_lock);\n\t\tmsg = ceph_msg_new(CEPH_MSG_CLIENT_CAPRELEASE, PAGE_CACHE_SIZE,\n\t\t\t\t   GFP_NOFS, false);\n\t\tif (!msg)\n\t\t\tgoto out_unlocked;\n\t\tdout(\"add_cap_releases %p msg %p now %d\\n\", session, msg,\n\t\t     (int)msg->front.iov_len);\n\t\thead = msg->front.iov_base;\n\t\thead->num = cpu_to_le32(0);\n\t\tmsg->front.iov_len = sizeof(*head);\n\t\tspin_lock(&session->s_cap_lock);\n\t\tlist_add(&msg->list_head, &session->s_cap_releases);\n\t\tsession->s_num_cap_releases += CEPH_CAPS_PER_RELEASE;\n\t}\n\n\tif (partial) {\n\t\thead = partial->front.iov_base;\n\t\tnum = le32_to_cpu(head->num);\n\t\tdout(\" queueing partial %p with %d/%d\\n\", partial, num,\n\t\t     (int)CEPH_CAPS_PER_RELEASE);\n\t\tlist_move_tail(&partial->list_head,\n\t\t\t       &session->s_cap_releases_done);\n\t\tsession->s_num_cap_releases -= CEPH_CAPS_PER_RELEASE - num;\n\t}\n\terr = 0;\n\tspin_unlock(&session->s_cap_lock);\nout_unlocked:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_con_keepalive",
          "args": [
            "&s->s_con"
          ],
          "line": 3325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_renew_caps",
          "args": [
            "mdsc",
            "s"
          ],
          "line": 3323
        },
        "resolved": true,
        "details": {
          "function_name": "send_renew_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1216-1244",
          "snippet": "static int send_renew_caps(struct ceph_mds_client *mdsc,\n\t\t\t   struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *msg;\n\tint state;\n\n\tif (time_after_eq(jiffies, session->s_cap_ttl) &&\n\t    time_after_eq(session->s_cap_ttl, session->s_renew_requested))\n\t\tpr_info(\"mds%d caps stale\\n\", session->s_mds);\n\tsession->s_renew_requested = jiffies;\n\n\t/* do not try to renew caps until a recovering mds has reconnected\n\t * with its clients. */\n\tstate = ceph_mdsmap_get_state(mdsc->mdsmap, session->s_mds);\n\tif (state < CEPH_MDS_STATE_RECONNECT) {\n\t\tdout(\"send_renew_caps ignoring mds%d (%s)\\n\",\n\t\t     session->s_mds, ceph_mds_state_name(state));\n\t\treturn 0;\n\t}\n\n\tdout(\"send_renew_caps to mds%d (%s)\\n\", session->s_mds,\n\t\tceph_mds_state_name(state));\n\tmsg = create_session_msg(CEPH_SESSION_REQUEST_RENEWCAPS,\n\t\t\t\t ++session->s_renew_seq);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\tceph_con_send(&session->s_con, msg);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int send_renew_caps(struct ceph_mds_client *mdsc,\n\t\t\t   struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *msg;\n\tint state;\n\n\tif (time_after_eq(jiffies, session->s_cap_ttl) &&\n\t    time_after_eq(session->s_cap_ttl, session->s_renew_requested))\n\t\tpr_info(\"mds%d caps stale\\n\", session->s_mds);\n\tsession->s_renew_requested = jiffies;\n\n\t/* do not try to renew caps until a recovering mds has reconnected\n\t * with its clients. */\n\tstate = ceph_mdsmap_get_state(mdsc->mdsmap, session->s_mds);\n\tif (state < CEPH_MDS_STATE_RECONNECT) {\n\t\tdout(\"send_renew_caps ignoring mds%d (%s)\\n\",\n\t\t     session->s_mds, ceph_mds_state_name(state));\n\t\treturn 0;\n\t}\n\n\tdout(\"send_renew_caps to mds%d (%s)\\n\", session->s_mds,\n\t\tceph_mds_state_name(state));\n\tmsg = create_session_msg(CEPH_SESSION_REQUEST_RENEWCAPS,\n\t\t\t\t ++session->s_renew_seq);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\tceph_con_send(&session->s_con, msg);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&s->s_mutex"
          ],
          "line": 3321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 3319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"mds%d hung\\n\"",
            "s->s_mds"
          ],
          "line": 3311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "jiffies",
            "s->s_ttl"
          ],
          "line": 3308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request_close_session",
          "args": [
            "mdsc",
            "s"
          ],
          "line": 3304
        },
        "resolved": true,
        "details": {
          "function_name": "request_close_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1298-1311",
          "snippet": "static int request_close_session(struct ceph_mds_client *mdsc,\n\t\t\t\t struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *msg;\n\n\tdout(\"request_close_session mds%d state %s seq %lld\\n\",\n\t     session->s_mds, ceph_session_state_name(session->s_state),\n\t     session->s_seq);\n\tmsg = create_session_msg(CEPH_SESSION_REQUEST_CLOSE, session->s_seq);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\tceph_con_send(&session->s_con, msg);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int request_close_session(struct ceph_mds_client *mdsc,\n\t\t\t\t struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *msg;\n\n\tdout(\"request_close_session mds%d state %s seq %lld\\n\",\n\t     session->s_mds, ceph_session_state_name(session->s_state),\n\t     session->s_seq);\n\tmsg = create_session_msg(CEPH_SESSION_REQUEST_CLOSE, session->s_seq);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\tceph_con_send(&session->s_con, msg);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"resending session close request for mds%d\\n\"",
            "s->s_mds"
          ],
          "line": 3302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ceph_lookup_mds_session",
          "args": [
            "mdsc",
            "i"
          ],
          "line": 3298
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_lookup_mds_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "390-402",
          "snippet": "struct ceph_mds_session *__ceph_lookup_mds_session(struct ceph_mds_client *mdsc,\n\t\t\t\t\t\t   int mds)\n{\n\tstruct ceph_mds_session *session;\n\n\tif (mds >= mdsc->max_sessions || mdsc->sessions[mds] == NULL)\n\t\treturn NULL;\n\tsession = mdsc->sessions[mds];\n\tdout(\"lookup_mds_session %p %d\\n\", session,\n\t     atomic_read(&session->s_ref));\n\tget_session(session);\n\treturn session;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct ceph_mds_session *__ceph_lookup_mds_session(struct ceph_mds_client *mdsc,\n\t\t\t\t\t\t   int mds)\n{\n\tstruct ceph_mds_session *session;\n\n\tif (mds >= mdsc->max_sessions || mdsc->sessions[mds] == NULL)\n\t\treturn NULL;\n\tsession = mdsc->sessions[mds];\n\tdout(\"lookup_mds_session %p %d\\n\", session,\n\t     atomic_read(&session->s_ref));\n\tget_session(session);\n\treturn session;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_after_eq",
          "args": [
            "jiffies",
            "HZ*renew_interval +\n\t\t\t\t   mdsc->last_renew_caps"
          ],
          "line": 3292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 3290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_check_delayed_caps",
          "args": [
            "mdsc"
          ],
          "line": 3288
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_check_delayed_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "3246-3268",
          "snippet": "void ceph_check_delayed_caps(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_inode_info *ci;\n\tint flags = CHECK_CAPS_NODELAY;\n\n\tdout(\"check_delayed_caps\\n\");\n\twhile (1) {\n\t\tspin_lock(&mdsc->cap_delay_lock);\n\t\tif (list_empty(&mdsc->cap_delay_list))\n\t\t\tbreak;\n\t\tci = list_first_entry(&mdsc->cap_delay_list,\n\t\t\t\t      struct ceph_inode_info,\n\t\t\t\t      i_cap_delay_list);\n\t\tif ((ci->i_ceph_flags & CEPH_I_FLUSH) == 0 &&\n\t\t    time_before(jiffies, ci->i_hold_caps_max))\n\t\t\tbreak;\n\t\tlist_del_init(&ci->i_cap_delay_list);\n\t\tspin_unlock(&mdsc->cap_delay_lock);\n\t\tdout(\"check_delayed_caps on %p\\n\", &ci->vfs_inode);\n\t\tceph_check_caps(ci, flags, NULL);\n\t}\n\tspin_unlock(&mdsc->cap_delay_lock);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_check_delayed_caps(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_inode_info *ci;\n\tint flags = CHECK_CAPS_NODELAY;\n\n\tdout(\"check_delayed_caps\\n\");\n\twhile (1) {\n\t\tspin_lock(&mdsc->cap_delay_lock);\n\t\tif (list_empty(&mdsc->cap_delay_list))\n\t\t\tbreak;\n\t\tci = list_first_entry(&mdsc->cap_delay_list,\n\t\t\t\t      struct ceph_inode_info,\n\t\t\t\t      i_cap_delay_list);\n\t\tif ((ci->i_ceph_flags & CEPH_I_FLUSH) == 0 &&\n\t\t    time_before(jiffies, ci->i_hold_caps_max))\n\t\t\tbreak;\n\t\tlist_del_init(&ci->i_cap_delay_list);\n\t\tspin_unlock(&mdsc->cap_delay_lock);\n\t\tdout(\"check_delayed_caps on %p\\n\", &ci->vfs_inode);\n\t\tceph_check_caps(ci, flags, NULL);\n\t}\n\tspin_unlock(&mdsc->cap_delay_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"mdsc delayed_work\\n\""
          ],
          "line": 3287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structceph_mds_client",
            "delayed_work.work"
          ],
          "line": 3283
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void delayed_work(struct work_struct *work)\n{\n\tint i;\n\tstruct ceph_mds_client *mdsc =\n\t\tcontainer_of(work, struct ceph_mds_client, delayed_work.work);\n\tint renew_interval;\n\tint renew_caps;\n\n\tdout(\"mdsc delayed_work\\n\");\n\tceph_check_delayed_caps(mdsc);\n\n\tmutex_lock(&mdsc->mutex);\n\trenew_interval = mdsc->mdsmap->m_session_timeout >> 2;\n\trenew_caps = time_after_eq(jiffies, HZ*renew_interval +\n\t\t\t\t   mdsc->last_renew_caps);\n\tif (renew_caps)\n\t\tmdsc->last_renew_caps = jiffies;\n\n\tfor (i = 0; i < mdsc->max_sessions; i++) {\n\t\tstruct ceph_mds_session *s = __ceph_lookup_mds_session(mdsc, i);\n\t\tif (s == NULL)\n\t\t\tcontinue;\n\t\tif (s->s_state == CEPH_MDS_SESSION_CLOSING) {\n\t\t\tdout(\"resending session close request for mds%d\\n\",\n\t\t\t     s->s_mds);\n\t\t\trequest_close_session(mdsc, s);\n\t\t\tceph_put_mds_session(s);\n\t\t\tcontinue;\n\t\t}\n\t\tif (s->s_ttl && time_after(jiffies, s->s_ttl)) {\n\t\t\tif (s->s_state == CEPH_MDS_SESSION_OPEN) {\n\t\t\t\ts->s_state = CEPH_MDS_SESSION_HUNG;\n\t\t\t\tpr_info(\"mds%d hung\\n\", s->s_mds);\n\t\t\t}\n\t\t}\n\t\tif (s->s_state < CEPH_MDS_SESSION_OPEN) {\n\t\t\t/* this mds is failed or recovering, just wait */\n\t\t\tceph_put_mds_session(s);\n\t\t\tcontinue;\n\t\t}\n\t\tmutex_unlock(&mdsc->mutex);\n\n\t\tmutex_lock(&s->s_mutex);\n\t\tif (renew_caps)\n\t\t\tsend_renew_caps(mdsc, s);\n\t\telse\n\t\t\tceph_con_keepalive(&s->s_con);\n\t\tceph_add_cap_releases(mdsc, s);\n\t\tif (s->s_state == CEPH_MDS_SESSION_OPEN ||\n\t\t    s->s_state == CEPH_MDS_SESSION_HUNG)\n\t\t\tceph_send_cap_releases(mdsc, s);\n\t\tmutex_unlock(&s->s_mutex);\n\t\tceph_put_mds_session(s);\n\n\t\tmutex_lock(&mdsc->mutex);\n\t}\n\tmutex_unlock(&mdsc->mutex);\n\n\tschedule_delayed(mdsc);\n}"
  },
  {
    "function_name": "schedule_delayed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "3272-3277",
    "snippet": "static void schedule_delayed(struct ceph_mds_client *mdsc)\n{\n\tint delay = 5;\n\tunsigned hz = round_jiffies_relative(HZ * delay);\n\tschedule_delayed_work(&mdsc->delayed_work, hz);\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_delayed_work",
          "args": [
            "&mdsc->delayed_work",
            "hz"
          ],
          "line": 3276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_jiffies_relative",
          "args": [
            "HZ * delay"
          ],
          "line": 3275
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void schedule_delayed(struct ceph_mds_client *mdsc)\n{\n\tint delay = 5;\n\tunsigned hz = round_jiffies_relative(HZ * delay);\n\tschedule_delayed_work(&mdsc->delayed_work, hz);\n}"
  },
  {
    "function_name": "drop_leases",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "3248-3265",
    "snippet": "static void drop_leases(struct ceph_mds_client *mdsc)\n{\n\tint i;\n\n\tdout(\"drop_leases\\n\");\n\tmutex_lock(&mdsc->mutex);\n\tfor (i = 0; i < mdsc->max_sessions; i++) {\n\t\tstruct ceph_mds_session *s = __ceph_lookup_mds_session(mdsc, i);\n\t\tif (!s)\n\t\t\tcontinue;\n\t\tmutex_unlock(&mdsc->mutex);\n\t\tmutex_lock(&s->s_mutex);\n\t\tmutex_unlock(&s->s_mutex);\n\t\tceph_put_mds_session(s);\n\t\tmutex_lock(&mdsc->mutex);\n\t}\n\tmutex_unlock(&mdsc->mutex);\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 3264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 3262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_put_mds_session",
          "args": [
            "s"
          ],
          "line": 3261
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_put_mds_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "374-385",
          "snippet": "void ceph_put_mds_session(struct ceph_mds_session *s)\n{\n\tdout(\"mdsc put_session %p %d -> %d\\n\", s,\n\t     atomic_read(&s->s_ref), atomic_read(&s->s_ref)-1);\n\tif (atomic_dec_and_test(&s->s_ref)) {\n\t\tif (s->s_auth.authorizer)\n\t\t\tceph_auth_destroy_authorizer(\n\t\t\t\ts->s_mdsc->fsc->client->monc.auth,\n\t\t\t\ts->s_auth.authorizer);\n\t\tkfree(s);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_put_mds_session(struct ceph_mds_session *s)\n{\n\tdout(\"mdsc put_session %p %d -> %d\\n\", s,\n\t     atomic_read(&s->s_ref), atomic_read(&s->s_ref)-1);\n\tif (atomic_dec_and_test(&s->s_ref)) {\n\t\tif (s->s_auth.authorizer)\n\t\t\tceph_auth_destroy_authorizer(\n\t\t\t\ts->s_mdsc->fsc->client->monc.auth,\n\t\t\t\ts->s_auth.authorizer);\n\t\tkfree(s);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&s->s_mutex"
          ],
          "line": 3260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&s->s_mutex"
          ],
          "line": 3259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 3258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ceph_lookup_mds_session",
          "args": [
            "mdsc",
            "i"
          ],
          "line": 3255
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_lookup_mds_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "390-402",
          "snippet": "struct ceph_mds_session *__ceph_lookup_mds_session(struct ceph_mds_client *mdsc,\n\t\t\t\t\t\t   int mds)\n{\n\tstruct ceph_mds_session *session;\n\n\tif (mds >= mdsc->max_sessions || mdsc->sessions[mds] == NULL)\n\t\treturn NULL;\n\tsession = mdsc->sessions[mds];\n\tdout(\"lookup_mds_session %p %d\\n\", session,\n\t     atomic_read(&session->s_ref));\n\tget_session(session);\n\treturn session;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct ceph_mds_session *__ceph_lookup_mds_session(struct ceph_mds_client *mdsc,\n\t\t\t\t\t\t   int mds)\n{\n\tstruct ceph_mds_session *session;\n\n\tif (mds >= mdsc->max_sessions || mdsc->sessions[mds] == NULL)\n\t\treturn NULL;\n\tsession = mdsc->sessions[mds];\n\tdout(\"lookup_mds_session %p %d\\n\", session,\n\t     atomic_read(&session->s_ref));\n\tget_session(session);\n\treturn session;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 3253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"drop_leases\\n\""
          ],
          "line": 3252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void drop_leases(struct ceph_mds_client *mdsc)\n{\n\tint i;\n\n\tdout(\"drop_leases\\n\");\n\tmutex_lock(&mdsc->mutex);\n\tfor (i = 0; i < mdsc->max_sessions; i++) {\n\t\tstruct ceph_mds_session *s = __ceph_lookup_mds_session(mdsc, i);\n\t\tif (!s)\n\t\t\tcontinue;\n\t\tmutex_unlock(&mdsc->mutex);\n\t\tmutex_lock(&s->s_mutex);\n\t\tmutex_unlock(&s->s_mutex);\n\t\tceph_put_mds_session(s);\n\t\tmutex_lock(&mdsc->mutex);\n\t}\n\tmutex_unlock(&mdsc->mutex);\n}"
  },
  {
    "function_name": "ceph_mdsc_lease_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "3208-3243",
    "snippet": "void ceph_mdsc_lease_release(struct ceph_mds_client *mdsc, struct inode *inode,\n\t\t\t     struct dentry *dentry)\n{\n\tstruct ceph_dentry_info *di;\n\tstruct ceph_mds_session *session;\n\tu32 seq;\n\n\tBUG_ON(inode == NULL);\n\tBUG_ON(dentry == NULL);\n\n\t/* is dentry lease valid? */\n\tspin_lock(&dentry->d_lock);\n\tdi = ceph_dentry(dentry);\n\tif (!di || !di->lease_session ||\n\t    di->lease_session->s_mds < 0 ||\n\t    di->lease_gen != di->lease_session->s_cap_gen ||\n\t    !time_before(jiffies, dentry->d_time)) {\n\t\tdout(\"lease_release inode %p dentry %p -- \"\n\t\t     \"no lease\\n\",\n\t\t     inode, dentry);\n\t\tspin_unlock(&dentry->d_lock);\n\t\treturn;\n\t}\n\n\t/* we do have a lease on this dentry; note mds and seq */\n\tsession = ceph_get_mds_session(di->lease_session);\n\tseq = di->lease_seq;\n\t__ceph_mdsc_drop_dentry_lease(dentry);\n\tspin_unlock(&dentry->d_lock);\n\n\tdout(\"lease_release inode %p dentry %p to mds%d\\n\",\n\t     inode, dentry, session->s_mds);\n\tceph_mdsc_lease_send_msg(session, inode, dentry,\n\t\t\t\t CEPH_MDS_LEASE_RELEASE, seq);\n\tceph_put_mds_session(session);\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_put_mds_session",
          "args": [
            "session"
          ],
          "line": 3242
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_put_mds_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "374-385",
          "snippet": "void ceph_put_mds_session(struct ceph_mds_session *s)\n{\n\tdout(\"mdsc put_session %p %d -> %d\\n\", s,\n\t     atomic_read(&s->s_ref), atomic_read(&s->s_ref)-1);\n\tif (atomic_dec_and_test(&s->s_ref)) {\n\t\tif (s->s_auth.authorizer)\n\t\t\tceph_auth_destroy_authorizer(\n\t\t\t\ts->s_mdsc->fsc->client->monc.auth,\n\t\t\t\ts->s_auth.authorizer);\n\t\tkfree(s);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_put_mds_session(struct ceph_mds_session *s)\n{\n\tdout(\"mdsc put_session %p %d -> %d\\n\", s,\n\t     atomic_read(&s->s_ref), atomic_read(&s->s_ref)-1);\n\tif (atomic_dec_and_test(&s->s_ref)) {\n\t\tif (s->s_auth.authorizer)\n\t\t\tceph_auth_destroy_authorizer(\n\t\t\t\ts->s_mdsc->fsc->client->monc.auth,\n\t\t\t\ts->s_auth.authorizer);\n\t\tkfree(s);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_lease_send_msg",
          "args": [
            "session",
            "inode",
            "dentry",
            "CEPH_MDS_LEASE_RELEASE",
            "seq"
          ],
          "line": 3240
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_lease_send_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "3168-3202",
          "snippet": "void ceph_mdsc_lease_send_msg(struct ceph_mds_session *session,\n\t\t\t      struct inode *inode,\n\t\t\t      struct dentry *dentry, char action,\n\t\t\t      u32 seq)\n{\n\tstruct ceph_msg *msg;\n\tstruct ceph_mds_lease *lease;\n\tint len = sizeof(*lease) + sizeof(u32);\n\tint dnamelen = 0;\n\n\tdout(\"lease_send_msg inode %p dentry %p %s to mds%d\\n\",\n\t     inode, dentry, ceph_lease_op_name(action), session->s_mds);\n\tdnamelen = dentry->d_name.len;\n\tlen += dnamelen;\n\n\tmsg = ceph_msg_new(CEPH_MSG_CLIENT_LEASE, len, GFP_NOFS, false);\n\tif (!msg)\n\t\treturn;\n\tlease = msg->front.iov_base;\n\tlease->action = action;\n\tlease->ino = cpu_to_le64(ceph_vino(inode).ino);\n\tlease->first = lease->last = cpu_to_le64(ceph_vino(inode).snap);\n\tlease->seq = cpu_to_le32(seq);\n\tput_unaligned_le32(dnamelen, lease + 1);\n\tmemcpy((void *)(lease + 1) + 4, dentry->d_name.name, dnamelen);\n\n\t/*\n\t * if this is a preemptive lease RELEASE, no need to\n\t * flush request stream, since the actual request will\n\t * soon follow.\n\t */\n\tmsg->more_to_follow = (action == CEPH_MDS_LEASE_RELEASE);\n\n\tceph_con_send(&session->s_con, msg);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_mdsc_lease_send_msg(struct ceph_mds_session *session,\n\t\t\t      struct inode *inode,\n\t\t\t      struct dentry *dentry, char action,\n\t\t\t      u32 seq)\n{\n\tstruct ceph_msg *msg;\n\tstruct ceph_mds_lease *lease;\n\tint len = sizeof(*lease) + sizeof(u32);\n\tint dnamelen = 0;\n\n\tdout(\"lease_send_msg inode %p dentry %p %s to mds%d\\n\",\n\t     inode, dentry, ceph_lease_op_name(action), session->s_mds);\n\tdnamelen = dentry->d_name.len;\n\tlen += dnamelen;\n\n\tmsg = ceph_msg_new(CEPH_MSG_CLIENT_LEASE, len, GFP_NOFS, false);\n\tif (!msg)\n\t\treturn;\n\tlease = msg->front.iov_base;\n\tlease->action = action;\n\tlease->ino = cpu_to_le64(ceph_vino(inode).ino);\n\tlease->first = lease->last = cpu_to_le64(ceph_vino(inode).snap);\n\tlease->seq = cpu_to_le32(seq);\n\tput_unaligned_le32(dnamelen, lease + 1);\n\tmemcpy((void *)(lease + 1) + 4, dentry->d_name.name, dnamelen);\n\n\t/*\n\t * if this is a preemptive lease RELEASE, no need to\n\t * flush request stream, since the actual request will\n\t * soon follow.\n\t */\n\tmsg->more_to_follow = (action == CEPH_MDS_LEASE_RELEASE);\n\n\tceph_con_send(&session->s_con, msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"lease_release inode %p dentry %p to mds%d\\n\"",
            "inode",
            "dentry",
            "session->s_mds"
          ],
          "line": 3238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 3236
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_mdsc_drop_dentry_lease",
          "args": [
            "dentry"
          ],
          "line": 3235
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_mdsc_drop_dentry_lease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "3055-3061",
          "snippet": "void __ceph_mdsc_drop_dentry_lease(struct dentry *dentry)\n{\n\tstruct ceph_dentry_info *di = ceph_dentry(dentry);\n\n\tceph_put_mds_session(di->lease_session);\n\tdi->lease_session = NULL;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid __ceph_mdsc_drop_dentry_lease(struct dentry *dentry)\n{\n\tstruct ceph_dentry_info *di = ceph_dentry(dentry);\n\n\tceph_put_mds_session(di->lease_session);\n\tdi->lease_session = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_get_mds_session",
          "args": [
            "di->lease_session"
          ],
          "line": 3233
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_get_mds_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.h",
          "lines": "338-343",
          "snippet": "static inline struct ceph_mds_session *\nceph_get_mds_session(struct ceph_mds_session *s)\n{\n\tatomic_inc(&s->s_ref);\n\treturn s;\n}",
          "includes": [
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mdsmap.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/kref.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/auth.h>\n#include <linux/ceph/mdsmap.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/types.h>\n#include <linux/spinlock.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/kref.h>\n#include <linux/completion.h>\n\nstatic inline struct ceph_mds_session *\nceph_get_mds_session(struct ceph_mds_session *s)\n{\n\tatomic_inc(&s->s_ref);\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"lease_release inode %p dentry %p -- \"\n\t\t     \"no lease\\n\"",
            "inode",
            "dentry"
          ],
          "line": 3225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "jiffies",
            "dentry->d_time"
          ],
          "line": 3224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_dentry",
          "args": [
            "dentry"
          ],
          "line": 3220
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "508-511",
          "snippet": "static inline struct ceph_dentry_info *ceph_dentry(struct dentry *dentry)\n{\n\treturn (struct ceph_dentry_info *)dentry->d_fsdata;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_dentry_info *ceph_dentry(struct dentry *dentry)\n{\n\treturn (struct ceph_dentry_info *)dentry->d_fsdata;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 3219
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "dentry == NULL"
          ],
          "line": 3216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "inode == NULL"
          ],
          "line": 3215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_mdsc_lease_release(struct ceph_mds_client *mdsc, struct inode *inode,\n\t\t\t     struct dentry *dentry)\n{\n\tstruct ceph_dentry_info *di;\n\tstruct ceph_mds_session *session;\n\tu32 seq;\n\n\tBUG_ON(inode == NULL);\n\tBUG_ON(dentry == NULL);\n\n\t/* is dentry lease valid? */\n\tspin_lock(&dentry->d_lock);\n\tdi = ceph_dentry(dentry);\n\tif (!di || !di->lease_session ||\n\t    di->lease_session->s_mds < 0 ||\n\t    di->lease_gen != di->lease_session->s_cap_gen ||\n\t    !time_before(jiffies, dentry->d_time)) {\n\t\tdout(\"lease_release inode %p dentry %p -- \"\n\t\t     \"no lease\\n\",\n\t\t     inode, dentry);\n\t\tspin_unlock(&dentry->d_lock);\n\t\treturn;\n\t}\n\n\t/* we do have a lease on this dentry; note mds and seq */\n\tsession = ceph_get_mds_session(di->lease_session);\n\tseq = di->lease_seq;\n\t__ceph_mdsc_drop_dentry_lease(dentry);\n\tspin_unlock(&dentry->d_lock);\n\n\tdout(\"lease_release inode %p dentry %p to mds%d\\n\",\n\t     inode, dentry, session->s_mds);\n\tceph_mdsc_lease_send_msg(session, inode, dentry,\n\t\t\t\t CEPH_MDS_LEASE_RELEASE, seq);\n\tceph_put_mds_session(session);\n}"
  },
  {
    "function_name": "ceph_mdsc_lease_send_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "3168-3202",
    "snippet": "void ceph_mdsc_lease_send_msg(struct ceph_mds_session *session,\n\t\t\t      struct inode *inode,\n\t\t\t      struct dentry *dentry, char action,\n\t\t\t      u32 seq)\n{\n\tstruct ceph_msg *msg;\n\tstruct ceph_mds_lease *lease;\n\tint len = sizeof(*lease) + sizeof(u32);\n\tint dnamelen = 0;\n\n\tdout(\"lease_send_msg inode %p dentry %p %s to mds%d\\n\",\n\t     inode, dentry, ceph_lease_op_name(action), session->s_mds);\n\tdnamelen = dentry->d_name.len;\n\tlen += dnamelen;\n\n\tmsg = ceph_msg_new(CEPH_MSG_CLIENT_LEASE, len, GFP_NOFS, false);\n\tif (!msg)\n\t\treturn;\n\tlease = msg->front.iov_base;\n\tlease->action = action;\n\tlease->ino = cpu_to_le64(ceph_vino(inode).ino);\n\tlease->first = lease->last = cpu_to_le64(ceph_vino(inode).snap);\n\tlease->seq = cpu_to_le32(seq);\n\tput_unaligned_le32(dnamelen, lease + 1);\n\tmemcpy((void *)(lease + 1) + 4, dentry->d_name.name, dnamelen);\n\n\t/*\n\t * if this is a preemptive lease RELEASE, no need to\n\t * flush request stream, since the actual request will\n\t * soon follow.\n\t */\n\tmsg->more_to_follow = (action == CEPH_MDS_LEASE_RELEASE);\n\n\tceph_con_send(&session->s_con, msg);\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_con_send",
          "args": [
            "&session->s_con",
            "msg"
          ],
          "line": 3201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(void *)(lease + 1) + 4",
            "dentry->d_name.name",
            "dnamelen"
          ],
          "line": 3192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_unaligned_le32",
          "args": [
            "dnamelen",
            "lease + 1"
          ],
          "line": 3191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "seq"
          ],
          "line": 3190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "ceph_vino(inode).snap"
          ],
          "line": 3189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vino",
          "args": [
            "inode"
          ],
          "line": 3189
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_vino_to_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "382-389",
          "snippet": "static inline ino_t ceph_vino_to_ino(struct ceph_vino vino)\n{\n#if BITS_PER_LONG == 32\n\treturn ceph_ino_to_ino32(vino.ino);\n#else\n\treturn (ino_t)vino.ino;\n#endif\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline ino_t ceph_vino_to_ino(struct ceph_vino vino)\n{\n#if BITS_PER_LONG == 32\n\treturn ceph_ino_to_ino32(vino.ino);\n#else\n\treturn (ino_t)vino.ino;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "ceph_vino(inode).ino"
          ],
          "line": 3188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_msg_new",
          "args": [
            "CEPH_MSG_CLIENT_LEASE",
            "len",
            "GFP_NOFS",
            "false"
          ],
          "line": 3183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"lease_send_msg inode %p dentry %p %s to mds%d\\n\"",
            "inode",
            "dentry",
            "ceph_lease_op_name(action)",
            "session->s_mds"
          ],
          "line": 3178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_lease_op_name",
          "args": [
            "action"
          ],
          "line": 3179
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_lease_op_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/strings.c",
          "lines": "104-113",
          "snippet": "const char *ceph_lease_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_MDS_LEASE_REVOKE: return \"revoke\";\n\tcase CEPH_MDS_LEASE_RELEASE: return \"release\";\n\tcase CEPH_MDS_LEASE_RENEW: return \"renew\";\n\tcase CEPH_MDS_LEASE_REVOKE_ACK: return \"revoke_ack\";\n\t}\n\treturn \"???\";\n}",
          "includes": [
            "#include <linux/ceph/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/types.h>\n#include <linux/module.h>\n\nconst char *ceph_lease_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_MDS_LEASE_REVOKE: return \"revoke\";\n\tcase CEPH_MDS_LEASE_RELEASE: return \"release\";\n\tcase CEPH_MDS_LEASE_RENEW: return \"renew\";\n\tcase CEPH_MDS_LEASE_REVOKE_ACK: return \"revoke_ack\";\n\t}\n\treturn \"???\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_mdsc_lease_send_msg(struct ceph_mds_session *session,\n\t\t\t      struct inode *inode,\n\t\t\t      struct dentry *dentry, char action,\n\t\t\t      u32 seq)\n{\n\tstruct ceph_msg *msg;\n\tstruct ceph_mds_lease *lease;\n\tint len = sizeof(*lease) + sizeof(u32);\n\tint dnamelen = 0;\n\n\tdout(\"lease_send_msg inode %p dentry %p %s to mds%d\\n\",\n\t     inode, dentry, ceph_lease_op_name(action), session->s_mds);\n\tdnamelen = dentry->d_name.len;\n\tlen += dnamelen;\n\n\tmsg = ceph_msg_new(CEPH_MSG_CLIENT_LEASE, len, GFP_NOFS, false);\n\tif (!msg)\n\t\treturn;\n\tlease = msg->front.iov_base;\n\tlease->action = action;\n\tlease->ino = cpu_to_le64(ceph_vino(inode).ino);\n\tlease->first = lease->last = cpu_to_le64(ceph_vino(inode).snap);\n\tlease->seq = cpu_to_le32(seq);\n\tput_unaligned_le32(dnamelen, lease + 1);\n\tmemcpy((void *)(lease + 1) + 4, dentry->d_name.name, dnamelen);\n\n\t/*\n\t * if this is a preemptive lease RELEASE, no need to\n\t * flush request stream, since the actual request will\n\t * soon follow.\n\t */\n\tmsg->more_to_follow = (action == CEPH_MDS_LEASE_RELEASE);\n\n\tceph_con_send(&session->s_con, msg);\n}"
  },
  {
    "function_name": "handle_lease",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "3063-3166",
    "snippet": "static void handle_lease(struct ceph_mds_client *mdsc,\n\t\t\t struct ceph_mds_session *session,\n\t\t\t struct ceph_msg *msg)\n{\n\tstruct super_block *sb = mdsc->fsc->sb;\n\tstruct inode *inode;\n\tstruct dentry *parent, *dentry;\n\tstruct ceph_dentry_info *di;\n\tint mds = session->s_mds;\n\tstruct ceph_mds_lease *h = msg->front.iov_base;\n\tu32 seq;\n\tstruct ceph_vino vino;\n\tstruct qstr dname;\n\tint release = 0;\n\n\tdout(\"handle_lease from mds%d\\n\", mds);\n\n\t/* decode */\n\tif (msg->front.iov_len < sizeof(*h) + sizeof(u32))\n\t\tgoto bad;\n\tvino.ino = le64_to_cpu(h->ino);\n\tvino.snap = CEPH_NOSNAP;\n\tseq = le32_to_cpu(h->seq);\n\tdname.name = (void *)h + sizeof(*h) + sizeof(u32);\n\tdname.len = msg->front.iov_len - sizeof(*h) - sizeof(u32);\n\tif (dname.len != get_unaligned_le32(h+1))\n\t\tgoto bad;\n\n\t/* lookup inode */\n\tinode = ceph_find_inode(sb, vino);\n\tdout(\"handle_lease %s, ino %llx %p %.*s\\n\",\n\t     ceph_lease_op_name(h->action), vino.ino, inode,\n\t     dname.len, dname.name);\n\n\tmutex_lock(&session->s_mutex);\n\tsession->s_seq++;\n\n\tif (inode == NULL) {\n\t\tdout(\"handle_lease no inode %llx\\n\", vino.ino);\n\t\tgoto release;\n\t}\n\n\t/* dentry */\n\tparent = d_find_alias(inode);\n\tif (!parent) {\n\t\tdout(\"no parent dentry on inode %p\\n\", inode);\n\t\tWARN_ON(1);\n\t\tgoto release;  /* hrm... */\n\t}\n\tdname.hash = full_name_hash(dname.name, dname.len);\n\tdentry = d_lookup(parent, &dname);\n\tdput(parent);\n\tif (!dentry)\n\t\tgoto release;\n\n\tspin_lock(&dentry->d_lock);\n\tdi = ceph_dentry(dentry);\n\tswitch (h->action) {\n\tcase CEPH_MDS_LEASE_REVOKE:\n\t\tif (di->lease_session == session) {\n\t\t\tif (ceph_seq_cmp(di->lease_seq, seq) > 0)\n\t\t\t\th->seq = cpu_to_le32(di->lease_seq);\n\t\t\t__ceph_mdsc_drop_dentry_lease(dentry);\n\t\t}\n\t\trelease = 1;\n\t\tbreak;\n\n\tcase CEPH_MDS_LEASE_RENEW:\n\t\tif (di->lease_session == session &&\n\t\t    di->lease_gen == session->s_cap_gen &&\n\t\t    di->lease_renew_from &&\n\t\t    di->lease_renew_after == 0) {\n\t\t\tunsigned long duration =\n\t\t\t\tle32_to_cpu(h->duration_ms) * HZ / 1000;\n\n\t\t\tdi->lease_seq = seq;\n\t\t\tdentry->d_time = di->lease_renew_from + duration;\n\t\t\tdi->lease_renew_after = di->lease_renew_from +\n\t\t\t\t(duration >> 1);\n\t\t\tdi->lease_renew_from = 0;\n\t\t}\n\t\tbreak;\n\t}\n\tspin_unlock(&dentry->d_lock);\n\tdput(dentry);\n\n\tif (!release)\n\t\tgoto out;\n\nrelease:\n\t/* let's just reuse the same message */\n\th->action = CEPH_MDS_LEASE_REVOKE_ACK;\n\tceph_msg_get(msg);\n\tceph_con_send(&session->s_con, msg);\n\nout:\n\tiput(inode);\n\tmutex_unlock(&session->s_mutex);\n\treturn;\n\nbad:\n\tpr_err(\"corrupt lease message\\n\");\n\tceph_msg_dump(msg);\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_msg_dump",
          "args": [
            "msg"
          ],
          "line": 3165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"corrupt lease message\\n\""
          ],
          "line": 3164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&session->s_mutex"
          ],
          "line": 3160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 3159
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_con_send",
          "args": [
            "&session->s_con",
            "msg"
          ],
          "line": 3156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_msg_get",
          "args": [
            "msg"
          ],
          "line": 3155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 3147
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 3146
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "h->duration_ms"
          ],
          "line": 3136
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_mdsc_drop_dentry_lease",
          "args": [
            "dentry"
          ],
          "line": 3125
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_mdsc_drop_dentry_lease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "3055-3061",
          "snippet": "void __ceph_mdsc_drop_dentry_lease(struct dentry *dentry)\n{\n\tstruct ceph_dentry_info *di = ceph_dentry(dentry);\n\n\tceph_put_mds_session(di->lease_session);\n\tdi->lease_session = NULL;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid __ceph_mdsc_drop_dentry_lease(struct dentry *dentry)\n{\n\tstruct ceph_dentry_info *di = ceph_dentry(dentry);\n\n\tceph_put_mds_session(di->lease_session);\n\tdi->lease_session = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "di->lease_seq"
          ],
          "line": 3124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_seq_cmp",
          "args": [
            "di->lease_seq",
            "seq"
          ],
          "line": 3123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_dentry",
          "args": [
            "dentry"
          ],
          "line": 3119
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "508-511",
          "snippet": "static inline struct ceph_dentry_info *ceph_dentry(struct dentry *dentry)\n{\n\treturn (struct ceph_dentry_info *)dentry->d_fsdata;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_dentry_info *ceph_dentry(struct dentry *dentry)\n{\n\treturn (struct ceph_dentry_info *)dentry->d_fsdata;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 3118
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_lookup",
          "args": [
            "parent",
            "&dname"
          ],
          "line": 3113
        },
        "resolved": true,
        "details": {
          "function_name": "d_hash_and_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2312-2326",
          "snippet": "struct dentry *d_hash_and_lookup(struct dentry *dir, struct qstr *name)\n{\n\t/*\n\t * Check for a fs-specific hash function. Note that we must\n\t * calculate the standard hash first, as the d_op->d_hash()\n\t * routine may choose to leave the hash value unchanged.\n\t */\n\tname->hash = full_name_hash(name->name, name->len);\n\tif (dir->d_flags & DCACHE_OP_HASH) {\n\t\tint err = dir->d_op->d_hash(dir, name);\n\t\tif (unlikely(err < 0))\n\t\t\treturn ERR_PTR(err);\n\t}\n\treturn d_lookup(dir, name);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_hash_and_lookup(struct dentry *dir, struct qstr *name)\n{\n\t/*\n\t * Check for a fs-specific hash function. Note that we must\n\t * calculate the standard hash first, as the d_op->d_hash()\n\t * routine may choose to leave the hash value unchanged.\n\t */\n\tname->hash = full_name_hash(name->name, name->len);\n\tif (dir->d_flags & DCACHE_OP_HASH) {\n\t\tint err = dir->d_op->d_hash(dir, name);\n\t\tif (unlikely(err < 0))\n\t\t\treturn ERR_PTR(err);\n\t}\n\treturn d_lookup(dir, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "full_name_hash",
          "args": [
            "dname.name",
            "dname.len"
          ],
          "line": 3112
        },
        "resolved": true,
        "details": {
          "function_name": "full_name_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "1737-1743",
          "snippet": "unsigned int full_name_hash(const unsigned char *name, unsigned int len)\n{\n\tunsigned long hash = init_name_hash();\n\twhile (len--)\n\t\thash = partial_name_hash(*name++, hash);\n\treturn end_name_hash(hash);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nunsigned int full_name_hash(const unsigned char *name, unsigned int len)\n{\n\tunsigned long hash = init_name_hash();\n\twhile (len--)\n\t\thash = partial_name_hash(*name++, hash);\n\treturn end_name_hash(hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 3109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"no parent dentry on inode %p\\n\"",
            "inode"
          ],
          "line": 3108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_find_alias",
          "args": [
            "inode"
          ],
          "line": 3106
        },
        "resolved": true,
        "details": {
          "function_name": "d_find_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "865-875",
          "snippet": "struct dentry *d_find_alias(struct inode *inode)\n{\n\tstruct dentry *de = NULL;\n\n\tif (!hlist_empty(&inode->i_dentry)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tde = __d_find_alias(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\treturn de;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_find_alias(struct inode *inode)\n{\n\tstruct dentry *de = NULL;\n\n\tif (!hlist_empty(&inode->i_dentry)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tde = __d_find_alias(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\treturn de;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"handle_lease no inode %llx\\n\"",
            "vino.ino"
          ],
          "line": 3101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&session->s_mutex"
          ],
          "line": 3097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"handle_lease %s, ino %llx %p %.*s\\n\"",
            "ceph_lease_op_name(h->action)",
            "vino.ino",
            "inode",
            "dname.len",
            "dname.name"
          ],
          "line": 3093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_lease_op_name",
          "args": [
            "h->action"
          ],
          "line": 3094
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_lease_op_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/strings.c",
          "lines": "104-113",
          "snippet": "const char *ceph_lease_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_MDS_LEASE_REVOKE: return \"revoke\";\n\tcase CEPH_MDS_LEASE_RELEASE: return \"release\";\n\tcase CEPH_MDS_LEASE_RENEW: return \"renew\";\n\tcase CEPH_MDS_LEASE_REVOKE_ACK: return \"revoke_ack\";\n\t}\n\treturn \"???\";\n}",
          "includes": [
            "#include <linux/ceph/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/types.h>\n#include <linux/module.h>\n\nconst char *ceph_lease_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_MDS_LEASE_REVOKE: return \"revoke\";\n\tcase CEPH_MDS_LEASE_RELEASE: return \"release\";\n\tcase CEPH_MDS_LEASE_RENEW: return \"renew\";\n\tcase CEPH_MDS_LEASE_REVOKE_ACK: return \"revoke_ack\";\n\t}\n\treturn \"???\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_find_inode",
          "args": [
            "sb",
            "vino"
          ],
          "line": 3092
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_find_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "429-434",
          "snippet": "static inline struct inode *ceph_find_inode(struct super_block *sb,\n\t\t\t\t\t    struct ceph_vino vino)\n{\n\tino_t t = ceph_vino_to_ino(vino);\n\treturn ilookup5(sb, t, ceph_ino_compare, &vino);\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct inode *ceph_find_inode(struct super_block *sb,\n\t\t\t\t\t    struct ceph_vino vino)\n{\n\tino_t t = ceph_vino_to_ino(vino);\n\treturn ilookup5(sb, t, ceph_ino_compare, &vino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_unaligned_le32",
          "args": [
            "h+1"
          ],
          "line": 3088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "h->ino"
          ],
          "line": 3083
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"handle_lease from mds%d\\n\"",
            "mds"
          ],
          "line": 3078
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void handle_lease(struct ceph_mds_client *mdsc,\n\t\t\t struct ceph_mds_session *session,\n\t\t\t struct ceph_msg *msg)\n{\n\tstruct super_block *sb = mdsc->fsc->sb;\n\tstruct inode *inode;\n\tstruct dentry *parent, *dentry;\n\tstruct ceph_dentry_info *di;\n\tint mds = session->s_mds;\n\tstruct ceph_mds_lease *h = msg->front.iov_base;\n\tu32 seq;\n\tstruct ceph_vino vino;\n\tstruct qstr dname;\n\tint release = 0;\n\n\tdout(\"handle_lease from mds%d\\n\", mds);\n\n\t/* decode */\n\tif (msg->front.iov_len < sizeof(*h) + sizeof(u32))\n\t\tgoto bad;\n\tvino.ino = le64_to_cpu(h->ino);\n\tvino.snap = CEPH_NOSNAP;\n\tseq = le32_to_cpu(h->seq);\n\tdname.name = (void *)h + sizeof(*h) + sizeof(u32);\n\tdname.len = msg->front.iov_len - sizeof(*h) - sizeof(u32);\n\tif (dname.len != get_unaligned_le32(h+1))\n\t\tgoto bad;\n\n\t/* lookup inode */\n\tinode = ceph_find_inode(sb, vino);\n\tdout(\"handle_lease %s, ino %llx %p %.*s\\n\",\n\t     ceph_lease_op_name(h->action), vino.ino, inode,\n\t     dname.len, dname.name);\n\n\tmutex_lock(&session->s_mutex);\n\tsession->s_seq++;\n\n\tif (inode == NULL) {\n\t\tdout(\"handle_lease no inode %llx\\n\", vino.ino);\n\t\tgoto release;\n\t}\n\n\t/* dentry */\n\tparent = d_find_alias(inode);\n\tif (!parent) {\n\t\tdout(\"no parent dentry on inode %p\\n\", inode);\n\t\tWARN_ON(1);\n\t\tgoto release;  /* hrm... */\n\t}\n\tdname.hash = full_name_hash(dname.name, dname.len);\n\tdentry = d_lookup(parent, &dname);\n\tdput(parent);\n\tif (!dentry)\n\t\tgoto release;\n\n\tspin_lock(&dentry->d_lock);\n\tdi = ceph_dentry(dentry);\n\tswitch (h->action) {\n\tcase CEPH_MDS_LEASE_REVOKE:\n\t\tif (di->lease_session == session) {\n\t\t\tif (ceph_seq_cmp(di->lease_seq, seq) > 0)\n\t\t\t\th->seq = cpu_to_le32(di->lease_seq);\n\t\t\t__ceph_mdsc_drop_dentry_lease(dentry);\n\t\t}\n\t\trelease = 1;\n\t\tbreak;\n\n\tcase CEPH_MDS_LEASE_RENEW:\n\t\tif (di->lease_session == session &&\n\t\t    di->lease_gen == session->s_cap_gen &&\n\t\t    di->lease_renew_from &&\n\t\t    di->lease_renew_after == 0) {\n\t\t\tunsigned long duration =\n\t\t\t\tle32_to_cpu(h->duration_ms) * HZ / 1000;\n\n\t\t\tdi->lease_seq = seq;\n\t\t\tdentry->d_time = di->lease_renew_from + duration;\n\t\t\tdi->lease_renew_after = di->lease_renew_from +\n\t\t\t\t(duration >> 1);\n\t\t\tdi->lease_renew_from = 0;\n\t\t}\n\t\tbreak;\n\t}\n\tspin_unlock(&dentry->d_lock);\n\tdput(dentry);\n\n\tif (!release)\n\t\tgoto out;\n\nrelease:\n\t/* let's just reuse the same message */\n\th->action = CEPH_MDS_LEASE_REVOKE_ACK;\n\tceph_msg_get(msg);\n\tceph_con_send(&session->s_con, msg);\n\nout:\n\tiput(inode);\n\tmutex_unlock(&session->s_mutex);\n\treturn;\n\nbad:\n\tpr_err(\"corrupt lease message\\n\");\n\tceph_msg_dump(msg);\n}"
  },
  {
    "function_name": "__ceph_mdsc_drop_dentry_lease",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "3055-3061",
    "snippet": "void __ceph_mdsc_drop_dentry_lease(struct dentry *dentry)\n{\n\tstruct ceph_dentry_info *di = ceph_dentry(dentry);\n\n\tceph_put_mds_session(di->lease_session);\n\tdi->lease_session = NULL;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_put_mds_session",
          "args": [
            "di->lease_session"
          ],
          "line": 3059
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_put_mds_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "374-385",
          "snippet": "void ceph_put_mds_session(struct ceph_mds_session *s)\n{\n\tdout(\"mdsc put_session %p %d -> %d\\n\", s,\n\t     atomic_read(&s->s_ref), atomic_read(&s->s_ref)-1);\n\tif (atomic_dec_and_test(&s->s_ref)) {\n\t\tif (s->s_auth.authorizer)\n\t\t\tceph_auth_destroy_authorizer(\n\t\t\t\ts->s_mdsc->fsc->client->monc.auth,\n\t\t\t\ts->s_auth.authorizer);\n\t\tkfree(s);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_put_mds_session(struct ceph_mds_session *s)\n{\n\tdout(\"mdsc put_session %p %d -> %d\\n\", s,\n\t     atomic_read(&s->s_ref), atomic_read(&s->s_ref)-1);\n\tif (atomic_dec_and_test(&s->s_ref)) {\n\t\tif (s->s_auth.authorizer)\n\t\t\tceph_auth_destroy_authorizer(\n\t\t\t\ts->s_mdsc->fsc->client->monc.auth,\n\t\t\t\ts->s_auth.authorizer);\n\t\tkfree(s);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_dentry",
          "args": [
            "dentry"
          ],
          "line": 3057
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "508-511",
          "snippet": "static inline struct ceph_dentry_info *ceph_dentry(struct dentry *dentry)\n{\n\treturn (struct ceph_dentry_info *)dentry->d_fsdata;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_dentry_info *ceph_dentry(struct dentry *dentry)\n{\n\treturn (struct ceph_dentry_info *)dentry->d_fsdata;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid __ceph_mdsc_drop_dentry_lease(struct dentry *dentry)\n{\n\tstruct ceph_dentry_info *di = ceph_dentry(dentry);\n\n\tceph_put_mds_session(di->lease_session);\n\tdi->lease_session = NULL;\n}"
  },
  {
    "function_name": "check_new_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "2959-3044",
    "snippet": "static void check_new_map(struct ceph_mds_client *mdsc,\n\t\t\t  struct ceph_mdsmap *newmap,\n\t\t\t  struct ceph_mdsmap *oldmap)\n{\n\tint i;\n\tint oldstate, newstate;\n\tstruct ceph_mds_session *s;\n\n\tdout(\"check_new_map new %u old %u\\n\",\n\t     newmap->m_epoch, oldmap->m_epoch);\n\n\tfor (i = 0; i < oldmap->m_max_mds && i < mdsc->max_sessions; i++) {\n\t\tif (mdsc->sessions[i] == NULL)\n\t\t\tcontinue;\n\t\ts = mdsc->sessions[i];\n\t\toldstate = ceph_mdsmap_get_state(oldmap, i);\n\t\tnewstate = ceph_mdsmap_get_state(newmap, i);\n\n\t\tdout(\"check_new_map mds%d state %s%s -> %s%s (session %s)\\n\",\n\t\t     i, ceph_mds_state_name(oldstate),\n\t\t     ceph_mdsmap_is_laggy(oldmap, i) ? \" (laggy)\" : \"\",\n\t\t     ceph_mds_state_name(newstate),\n\t\t     ceph_mdsmap_is_laggy(newmap, i) ? \" (laggy)\" : \"\",\n\t\t     ceph_session_state_name(s->s_state));\n\n\t\tif (i >= newmap->m_max_mds ||\n\t\t    memcmp(ceph_mdsmap_get_addr(oldmap, i),\n\t\t\t   ceph_mdsmap_get_addr(newmap, i),\n\t\t\t   sizeof(struct ceph_entity_addr))) {\n\t\t\tif (s->s_state == CEPH_MDS_SESSION_OPENING) {\n\t\t\t\t/* the session never opened, just close it\n\t\t\t\t * out now */\n\t\t\t\t__wake_requests(mdsc, &s->s_waiting);\n\t\t\t\t__unregister_session(mdsc, s);\n\t\t\t} else {\n\t\t\t\t/* just close it */\n\t\t\t\tmutex_unlock(&mdsc->mutex);\n\t\t\t\tmutex_lock(&s->s_mutex);\n\t\t\t\tmutex_lock(&mdsc->mutex);\n\t\t\t\tceph_con_close(&s->s_con);\n\t\t\t\tmutex_unlock(&s->s_mutex);\n\t\t\t\ts->s_state = CEPH_MDS_SESSION_RESTARTING;\n\t\t\t}\n\t\t} else if (oldstate == newstate) {\n\t\t\tcontinue;  /* nothing new with this mds */\n\t\t}\n\n\t\t/*\n\t\t * send reconnect?\n\t\t */\n\t\tif (s->s_state == CEPH_MDS_SESSION_RESTARTING &&\n\t\t    newstate >= CEPH_MDS_STATE_RECONNECT) {\n\t\t\tmutex_unlock(&mdsc->mutex);\n\t\t\tsend_mds_reconnect(mdsc, s);\n\t\t\tmutex_lock(&mdsc->mutex);\n\t\t}\n\n\t\t/*\n\t\t * kick request on any mds that has gone active.\n\t\t */\n\t\tif (oldstate < CEPH_MDS_STATE_ACTIVE &&\n\t\t    newstate >= CEPH_MDS_STATE_ACTIVE) {\n\t\t\tif (oldstate != CEPH_MDS_STATE_CREATING &&\n\t\t\t    oldstate != CEPH_MDS_STATE_STARTING)\n\t\t\t\tpr_info(\"mds%d recovery completed\\n\", s->s_mds);\n\t\t\tkick_requests(mdsc, i);\n\t\t\tceph_kick_flushing_caps(mdsc, s);\n\t\t\twake_up_session_caps(s, 1);\n\t\t}\n\t}\n\n\tfor (i = 0; i < newmap->m_max_mds && i < mdsc->max_sessions; i++) {\n\t\ts = mdsc->sessions[i];\n\t\tif (!s)\n\t\t\tcontinue;\n\t\tif (!ceph_mdsmap_is_laggy(newmap, i))\n\t\t\tcontinue;\n\t\tif (s->s_state == CEPH_MDS_SESSION_OPEN ||\n\t\t    s->s_state == CEPH_MDS_SESSION_HUNG ||\n\t\t    s->s_state == CEPH_MDS_SESSION_CLOSING) {\n\t\t\tdout(\" connecting to export targets of laggy mds%d\\n\",\n\t\t\t     i);\n\t\t\t__open_export_target_sessions(mdsc, s);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__open_export_target_sessions",
          "args": [
            "mdsc",
            "s"
          ],
          "line": 3041
        },
        "resolved": true,
        "details": {
          "function_name": "__open_export_target_sessions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "968-987",
          "snippet": "static void __open_export_target_sessions(struct ceph_mds_client *mdsc,\n\t\t\t\t\t  struct ceph_mds_session *session)\n{\n\tstruct ceph_mds_info *mi;\n\tstruct ceph_mds_session *ts;\n\tint i, mds = session->s_mds;\n\n\tif (mds >= mdsc->mdsmap->m_max_mds)\n\t\treturn;\n\n\tmi = &mdsc->mdsmap->m_info[mds];\n\tdout(\"open_export_target_sessions for mds%d (%d targets)\\n\",\n\t     session->s_mds, mi->num_export_targets);\n\n\tfor (i = 0; i < mi->num_export_targets; i++) {\n\t\tts = __open_export_target_session(mdsc, mi->export_targets[i]);\n\t\tif (!IS_ERR(ts))\n\t\t\tceph_put_mds_session(ts);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __open_export_target_sessions(struct ceph_mds_client *mdsc,\n\t\t\t\t\t  struct ceph_mds_session *session)\n{\n\tstruct ceph_mds_info *mi;\n\tstruct ceph_mds_session *ts;\n\tint i, mds = session->s_mds;\n\n\tif (mds >= mdsc->mdsmap->m_max_mds)\n\t\treturn;\n\n\tmi = &mdsc->mdsmap->m_info[mds];\n\tdout(\"open_export_target_sessions for mds%d (%d targets)\\n\",\n\t     session->s_mds, mi->num_export_targets);\n\n\tfor (i = 0; i < mi->num_export_targets; i++) {\n\t\tts = __open_export_target_session(mdsc, mi->export_targets[i]);\n\t\tif (!IS_ERR(ts))\n\t\t\tceph_put_mds_session(ts);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" connecting to export targets of laggy mds%d\\n\"",
            "i"
          ],
          "line": 3039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mdsmap_is_laggy",
          "args": [
            "newmap",
            "i"
          ],
          "line": 3034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_session_caps",
          "args": [
            "s",
            "1"
          ],
          "line": 3026
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_session_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1202-1208",
          "snippet": "static void wake_up_session_caps(struct ceph_mds_session *session,\n\t\t\t\t int reconnect)\n{\n\tdout(\"wake_up_session_caps %p mds%d\\n\", session, session->s_mds);\n\titerate_session_caps(session, wake_up_session_cb,\n\t\t\t     (void *)(unsigned long)reconnect);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void wake_up_session_caps(struct ceph_mds_session *session,\n\t\t\t\t int reconnect)\n{\n\tdout(\"wake_up_session_caps %p mds%d\\n\", session, session->s_mds);\n\titerate_session_caps(session, wake_up_session_cb,\n\t\t\t     (void *)(unsigned long)reconnect);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_kick_flushing_caps",
          "args": [
            "mdsc",
            "s"
          ],
          "line": 3025
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_kick_flushing_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "1969-2003",
          "snippet": "void ceph_kick_flushing_caps(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_mds_session *session)\n{\n\tstruct ceph_inode_info *ci;\n\n\tkick_flushing_capsnaps(mdsc, session);\n\n\tdout(\"kick_flushing_caps mds%d\\n\", session->s_mds);\n\tlist_for_each_entry(ci, &session->s_cap_flushing, i_flushing_item) {\n\t\tstruct inode *inode = &ci->vfs_inode;\n\t\tstruct ceph_cap *cap;\n\t\tint delayed = 0;\n\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tcap = ci->i_auth_cap;\n\t\tif (cap && cap->session == session) {\n\t\t\tdout(\"kick_flushing_caps %p cap %p %s\\n\", inode,\n\t\t\t     cap, ceph_cap_string(ci->i_flushing_caps));\n\t\t\tdelayed = __send_cap(mdsc, cap, CEPH_CAP_OP_FLUSH,\n\t\t\t\t\t     __ceph_caps_used(ci),\n\t\t\t\t\t     __ceph_caps_wanted(ci),\n\t\t\t\t\t     cap->issued | cap->implemented,\n\t\t\t\t\t     ci->i_flushing_caps, NULL);\n\t\t\tif (delayed) {\n\t\t\t\tspin_lock(&ci->i_ceph_lock);\n\t\t\t\t__cap_delay_requeue(mdsc, ci);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t}\n\t\t} else {\n\t\t\tpr_err(\"%p auth cap %p not mds%d ???\\n\", inode,\n\t\t\t       cap, session->s_mds);\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_kick_flushing_caps(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_mds_session *session)\n{\n\tstruct ceph_inode_info *ci;\n\n\tkick_flushing_capsnaps(mdsc, session);\n\n\tdout(\"kick_flushing_caps mds%d\\n\", session->s_mds);\n\tlist_for_each_entry(ci, &session->s_cap_flushing, i_flushing_item) {\n\t\tstruct inode *inode = &ci->vfs_inode;\n\t\tstruct ceph_cap *cap;\n\t\tint delayed = 0;\n\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tcap = ci->i_auth_cap;\n\t\tif (cap && cap->session == session) {\n\t\t\tdout(\"kick_flushing_caps %p cap %p %s\\n\", inode,\n\t\t\t     cap, ceph_cap_string(ci->i_flushing_caps));\n\t\t\tdelayed = __send_cap(mdsc, cap, CEPH_CAP_OP_FLUSH,\n\t\t\t\t\t     __ceph_caps_used(ci),\n\t\t\t\t\t     __ceph_caps_wanted(ci),\n\t\t\t\t\t     cap->issued | cap->implemented,\n\t\t\t\t\t     ci->i_flushing_caps, NULL);\n\t\t\tif (delayed) {\n\t\t\t\tspin_lock(&ci->i_ceph_lock);\n\t\t\t\t__cap_delay_requeue(mdsc, ci);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t}\n\t\t} else {\n\t\t\tpr_err(\"%p auth cap %p not mds%d ???\\n\", inode,\n\t\t\t       cap, session->s_mds);\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kick_requests",
          "args": [
            "mdsc",
            "i"
          ],
          "line": 3024
        },
        "resolved": true,
        "details": {
          "function_name": "kick_requests",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "2176-2196",
          "snippet": "static void kick_requests(struct ceph_mds_client *mdsc, int mds)\n{\n\tstruct ceph_mds_request *req;\n\tstruct rb_node *p = rb_first(&mdsc->request_tree);\n\n\tdout(\"kick_requests mds%d\\n\", mds);\n\twhile (p) {\n\t\treq = rb_entry(p, struct ceph_mds_request, r_node);\n\t\tp = rb_next(p);\n\t\tif (req->r_got_unsafe)\n\t\t\tcontinue;\n\t\tif (req->r_attempts > 0)\n\t\t\tcontinue; /* only new requests */\n\t\tif (req->r_session &&\n\t\t    req->r_session->s_mds == mds) {\n\t\t\tdout(\" kicking tid %llu\\n\", req->r_tid);\n\t\t\tlist_del_init(&req->r_wait);\n\t\t\t__do_request(mdsc, req);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void kick_requests(struct ceph_mds_client *mdsc, int mds)\n{\n\tstruct ceph_mds_request *req;\n\tstruct rb_node *p = rb_first(&mdsc->request_tree);\n\n\tdout(\"kick_requests mds%d\\n\", mds);\n\twhile (p) {\n\t\treq = rb_entry(p, struct ceph_mds_request, r_node);\n\t\tp = rb_next(p);\n\t\tif (req->r_got_unsafe)\n\t\t\tcontinue;\n\t\tif (req->r_attempts > 0)\n\t\t\tcontinue; /* only new requests */\n\t\tif (req->r_session &&\n\t\t    req->r_session->s_mds == mds) {\n\t\t\tdout(\" kicking tid %llu\\n\", req->r_tid);\n\t\t\tlist_del_init(&req->r_wait);\n\t\t\t__do_request(mdsc, req);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"mds%d recovery completed\\n\"",
            "s->s_mds"
          ],
          "line": 3023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 3013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_mds_reconnect",
          "args": [
            "mdsc",
            "s"
          ],
          "line": 3012
        },
        "resolved": true,
        "details": {
          "function_name": "send_mds_reconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "2820-2950",
          "snippet": "static void send_mds_reconnect(struct ceph_mds_client *mdsc,\n\t\t\t       struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *reply;\n\tstruct rb_node *p;\n\tint mds = session->s_mds;\n\tint err = -ENOMEM;\n\tint s_nr_caps;\n\tstruct ceph_pagelist *pagelist;\n\tstruct ceph_reconnect_state recon_state;\n\n\tpr_info(\"mds%d reconnect start\\n\", mds);\n\n\tpagelist = kmalloc(sizeof(*pagelist), GFP_NOFS);\n\tif (!pagelist)\n\t\tgoto fail_nopagelist;\n\tceph_pagelist_init(pagelist);\n\n\treply = ceph_msg_new(CEPH_MSG_CLIENT_RECONNECT, 0, GFP_NOFS, false);\n\tif (!reply)\n\t\tgoto fail_nomsg;\n\n\tmutex_lock(&session->s_mutex);\n\tsession->s_state = CEPH_MDS_SESSION_RECONNECTING;\n\tsession->s_seq = 0;\n\n\tdout(\"session %p state %s\\n\", session,\n\t     ceph_session_state_name(session->s_state));\n\n\tspin_lock(&session->s_gen_ttl_lock);\n\tsession->s_cap_gen++;\n\tspin_unlock(&session->s_gen_ttl_lock);\n\n\tspin_lock(&session->s_cap_lock);\n\t/* don't know if session is readonly */\n\tsession->s_readonly = 0;\n\t/*\n\t * notify __ceph_remove_cap() that we are composing cap reconnect.\n\t * If a cap get released before being added to the cap reconnect,\n\t * __ceph_remove_cap() should skip queuing cap release.\n\t */\n\tsession->s_cap_reconnect = 1;\n\t/* drop old cap expires; we're about to reestablish that state */\n\tdiscard_cap_releases(mdsc, session);\n\tspin_unlock(&session->s_cap_lock);\n\n\t/* trim unused caps to reduce MDS's cache rejoin time */\n\tshrink_dcache_parent(mdsc->fsc->sb->s_root);\n\n\tceph_con_close(&session->s_con);\n\tceph_con_open(&session->s_con,\n\t\t      CEPH_ENTITY_TYPE_MDS, mds,\n\t\t      ceph_mdsmap_get_addr(mdsc->mdsmap, mds));\n\n\t/* replay unsafe requests */\n\treplay_unsafe_requests(mdsc, session);\n\n\tdown_read(&mdsc->snap_rwsem);\n\n\t/* traverse this session's caps */\n\ts_nr_caps = session->s_nr_caps;\n\terr = ceph_pagelist_encode_32(pagelist, s_nr_caps);\n\tif (err)\n\t\tgoto fail;\n\n\trecon_state.nr_caps = 0;\n\trecon_state.pagelist = pagelist;\n\trecon_state.flock = session->s_con.peer_features & CEPH_FEATURE_FLOCK;\n\terr = iterate_session_caps(session, encode_caps_cb, &recon_state);\n\tif (err < 0)\n\t\tgoto fail;\n\n\tspin_lock(&session->s_cap_lock);\n\tsession->s_cap_reconnect = 0;\n\tspin_unlock(&session->s_cap_lock);\n\n\t/*\n\t * snaprealms.  we provide mds with the ino, seq (version), and\n\t * parent for all of our realms.  If the mds has any newer info,\n\t * it will tell us.\n\t */\n\tfor (p = rb_first(&mdsc->snap_realms); p; p = rb_next(p)) {\n\t\tstruct ceph_snap_realm *realm =\n\t\t\trb_entry(p, struct ceph_snap_realm, node);\n\t\tstruct ceph_mds_snaprealm_reconnect sr_rec;\n\n\t\tdout(\" adding snap realm %llx seq %lld parent %llx\\n\",\n\t\t     realm->ino, realm->seq, realm->parent_ino);\n\t\tsr_rec.ino = cpu_to_le64(realm->ino);\n\t\tsr_rec.seq = cpu_to_le64(realm->seq);\n\t\tsr_rec.parent = cpu_to_le64(realm->parent_ino);\n\t\terr = ceph_pagelist_append(pagelist, &sr_rec, sizeof(sr_rec));\n\t\tif (err)\n\t\t\tgoto fail;\n\t}\n\n\tif (recon_state.flock)\n\t\treply->hdr.version = cpu_to_le16(2);\n\n\t/* raced with cap release? */\n\tif (s_nr_caps != recon_state.nr_caps) {\n\t\tstruct page *page = list_first_entry(&pagelist->head,\n\t\t\t\t\t\t     struct page, lru);\n\t\t__le32 *addr = kmap_atomic(page);\n\t\t*addr = cpu_to_le32(recon_state.nr_caps);\n\t\tkunmap_atomic(addr);\n\t}\n\n\treply->hdr.data_len = cpu_to_le32(pagelist->length);\n\tceph_msg_data_add_pagelist(reply, pagelist);\n\tceph_con_send(&session->s_con, reply);\n\n\tmutex_unlock(&session->s_mutex);\n\n\tmutex_lock(&mdsc->mutex);\n\t__wake_requests(mdsc, &session->s_waiting);\n\tmutex_unlock(&mdsc->mutex);\n\n\tup_read(&mdsc->snap_rwsem);\n\treturn;\n\nfail:\n\tceph_msg_put(reply);\n\tup_read(&mdsc->snap_rwsem);\n\tmutex_unlock(&session->s_mutex);\nfail_nomsg:\n\tceph_pagelist_release(pagelist);\nfail_nopagelist:\n\tpr_err(\"error %d preparing reconnect for mds%d\\n\", err, mds);\n\treturn;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);\n\nstatic void send_mds_reconnect(struct ceph_mds_client *mdsc,\n\t\t\t       struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *reply;\n\tstruct rb_node *p;\n\tint mds = session->s_mds;\n\tint err = -ENOMEM;\n\tint s_nr_caps;\n\tstruct ceph_pagelist *pagelist;\n\tstruct ceph_reconnect_state recon_state;\n\n\tpr_info(\"mds%d reconnect start\\n\", mds);\n\n\tpagelist = kmalloc(sizeof(*pagelist), GFP_NOFS);\n\tif (!pagelist)\n\t\tgoto fail_nopagelist;\n\tceph_pagelist_init(pagelist);\n\n\treply = ceph_msg_new(CEPH_MSG_CLIENT_RECONNECT, 0, GFP_NOFS, false);\n\tif (!reply)\n\t\tgoto fail_nomsg;\n\n\tmutex_lock(&session->s_mutex);\n\tsession->s_state = CEPH_MDS_SESSION_RECONNECTING;\n\tsession->s_seq = 0;\n\n\tdout(\"session %p state %s\\n\", session,\n\t     ceph_session_state_name(session->s_state));\n\n\tspin_lock(&session->s_gen_ttl_lock);\n\tsession->s_cap_gen++;\n\tspin_unlock(&session->s_gen_ttl_lock);\n\n\tspin_lock(&session->s_cap_lock);\n\t/* don't know if session is readonly */\n\tsession->s_readonly = 0;\n\t/*\n\t * notify __ceph_remove_cap() that we are composing cap reconnect.\n\t * If a cap get released before being added to the cap reconnect,\n\t * __ceph_remove_cap() should skip queuing cap release.\n\t */\n\tsession->s_cap_reconnect = 1;\n\t/* drop old cap expires; we're about to reestablish that state */\n\tdiscard_cap_releases(mdsc, session);\n\tspin_unlock(&session->s_cap_lock);\n\n\t/* trim unused caps to reduce MDS's cache rejoin time */\n\tshrink_dcache_parent(mdsc->fsc->sb->s_root);\n\n\tceph_con_close(&session->s_con);\n\tceph_con_open(&session->s_con,\n\t\t      CEPH_ENTITY_TYPE_MDS, mds,\n\t\t      ceph_mdsmap_get_addr(mdsc->mdsmap, mds));\n\n\t/* replay unsafe requests */\n\treplay_unsafe_requests(mdsc, session);\n\n\tdown_read(&mdsc->snap_rwsem);\n\n\t/* traverse this session's caps */\n\ts_nr_caps = session->s_nr_caps;\n\terr = ceph_pagelist_encode_32(pagelist, s_nr_caps);\n\tif (err)\n\t\tgoto fail;\n\n\trecon_state.nr_caps = 0;\n\trecon_state.pagelist = pagelist;\n\trecon_state.flock = session->s_con.peer_features & CEPH_FEATURE_FLOCK;\n\terr = iterate_session_caps(session, encode_caps_cb, &recon_state);\n\tif (err < 0)\n\t\tgoto fail;\n\n\tspin_lock(&session->s_cap_lock);\n\tsession->s_cap_reconnect = 0;\n\tspin_unlock(&session->s_cap_lock);\n\n\t/*\n\t * snaprealms.  we provide mds with the ino, seq (version), and\n\t * parent for all of our realms.  If the mds has any newer info,\n\t * it will tell us.\n\t */\n\tfor (p = rb_first(&mdsc->snap_realms); p; p = rb_next(p)) {\n\t\tstruct ceph_snap_realm *realm =\n\t\t\trb_entry(p, struct ceph_snap_realm, node);\n\t\tstruct ceph_mds_snaprealm_reconnect sr_rec;\n\n\t\tdout(\" adding snap realm %llx seq %lld parent %llx\\n\",\n\t\t     realm->ino, realm->seq, realm->parent_ino);\n\t\tsr_rec.ino = cpu_to_le64(realm->ino);\n\t\tsr_rec.seq = cpu_to_le64(realm->seq);\n\t\tsr_rec.parent = cpu_to_le64(realm->parent_ino);\n\t\terr = ceph_pagelist_append(pagelist, &sr_rec, sizeof(sr_rec));\n\t\tif (err)\n\t\t\tgoto fail;\n\t}\n\n\tif (recon_state.flock)\n\t\treply->hdr.version = cpu_to_le16(2);\n\n\t/* raced with cap release? */\n\tif (s_nr_caps != recon_state.nr_caps) {\n\t\tstruct page *page = list_first_entry(&pagelist->head,\n\t\t\t\t\t\t     struct page, lru);\n\t\t__le32 *addr = kmap_atomic(page);\n\t\t*addr = cpu_to_le32(recon_state.nr_caps);\n\t\tkunmap_atomic(addr);\n\t}\n\n\treply->hdr.data_len = cpu_to_le32(pagelist->length);\n\tceph_msg_data_add_pagelist(reply, pagelist);\n\tceph_con_send(&session->s_con, reply);\n\n\tmutex_unlock(&session->s_mutex);\n\n\tmutex_lock(&mdsc->mutex);\n\t__wake_requests(mdsc, &session->s_waiting);\n\tmutex_unlock(&mdsc->mutex);\n\n\tup_read(&mdsc->snap_rwsem);\n\treturn;\n\nfail:\n\tceph_msg_put(reply);\n\tup_read(&mdsc->snap_rwsem);\n\tmutex_unlock(&session->s_mutex);\nfail_nomsg:\n\tceph_pagelist_release(pagelist);\nfail_nopagelist:\n\tpr_err(\"error %d preparing reconnect for mds%d\\n\", err, mds);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 3011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&s->s_mutex"
          ],
          "line": 2999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_con_close",
          "args": [
            "&s->s_con"
          ],
          "line": 2998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 2997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&s->s_mutex"
          ],
          "line": 2996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 2995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__unregister_session",
          "args": [
            "mdsc",
            "s"
          ],
          "line": 2992
        },
        "resolved": true,
        "details": {
          "function_name": "__unregister_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "499-508",
          "snippet": "static void __unregister_session(struct ceph_mds_client *mdsc,\n\t\t\t       struct ceph_mds_session *s)\n{\n\tdout(\"__unregister_session mds%d %p\\n\", s->s_mds, s);\n\tBUG_ON(mdsc->sessions[s->s_mds] != s);\n\tmdsc->sessions[s->s_mds] = NULL;\n\tceph_con_close(&s->s_con);\n\tceph_put_mds_session(s);\n\tatomic_dec(&mdsc->num_sessions);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __unregister_session(struct ceph_mds_client *mdsc,\n\t\t\t       struct ceph_mds_session *s)\n{\n\tdout(\"__unregister_session mds%d %p\\n\", s->s_mds, s);\n\tBUG_ON(mdsc->sessions[s->s_mds] != s);\n\tmdsc->sessions[s->s_mds] = NULL;\n\tceph_con_close(&s->s_con);\n\tceph_put_mds_session(s);\n\tatomic_dec(&mdsc->num_sessions);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__wake_requests",
          "args": [
            "mdsc",
            "&s->s_waiting"
          ],
          "line": 2991
        },
        "resolved": true,
        "details": {
          "function_name": "__wake_requests",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "2155-2170",
          "snippet": "static void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head)\n{\n\tstruct ceph_mds_request *req;\n\tLIST_HEAD(tmp_list);\n\n\tlist_splice_init(head, &tmp_list);\n\n\twhile (!list_empty(&tmp_list)) {\n\t\treq = list_entry(tmp_list.next,\n\t\t\t\t struct ceph_mds_request, r_wait);\n\t\tlist_del_init(&req->r_wait);\n\t\tdout(\" wake request %p tid %llu\\n\", req, req->r_tid);\n\t\t__do_request(mdsc, req);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);\n\nstatic void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head)\n{\n\tstruct ceph_mds_request *req;\n\tLIST_HEAD(tmp_list);\n\n\tlist_splice_init(head, &tmp_list);\n\n\twhile (!list_empty(&tmp_list)) {\n\t\treq = list_entry(tmp_list.next,\n\t\t\t\t struct ceph_mds_request, r_wait);\n\t\tlist_del_init(&req->r_wait);\n\t\tdout(\" wake request %p tid %llu\\n\", req, req->r_tid);\n\t\t__do_request(mdsc, req);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "ceph_mdsmap_get_addr(oldmap, i)",
            "ceph_mdsmap_get_addr(newmap, i)",
            "sizeof(struct ceph_entity_addr)"
          ],
          "line": 2985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mdsmap_get_addr",
          "args": [
            "newmap",
            "i"
          ],
          "line": 2986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mdsmap_get_addr",
          "args": [
            "oldmap",
            "i"
          ],
          "line": 2985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"check_new_map mds%d state %s%s -> %s%s (session %s)\\n\"",
            "i",
            "ceph_mds_state_name(oldstate)",
            "ceph_mdsmap_is_laggy(oldmap, i) ? \" (laggy)\" : \"\"",
            "ceph_mds_state_name(newstate)",
            "ceph_mdsmap_is_laggy(newmap, i) ? \" (laggy)\" : \"\"",
            "ceph_session_state_name(s->s_state)"
          ],
          "line": 2977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_session_state_name",
          "args": [
            "s->s_state"
          ],
          "line": 2982
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_session_state_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "348-360",
          "snippet": "const char *ceph_session_state_name(int s)\n{\n\tswitch (s) {\n\tcase CEPH_MDS_SESSION_NEW: return \"new\";\n\tcase CEPH_MDS_SESSION_OPENING: return \"opening\";\n\tcase CEPH_MDS_SESSION_OPEN: return \"open\";\n\tcase CEPH_MDS_SESSION_HUNG: return \"hung\";\n\tcase CEPH_MDS_SESSION_CLOSING: return \"closing\";\n\tcase CEPH_MDS_SESSION_RESTARTING: return \"restarting\";\n\tcase CEPH_MDS_SESSION_RECONNECTING: return \"reconnecting\";\n\tdefault: return \"???\";\n\t}\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nconst char *ceph_session_state_name(int s)\n{\n\tswitch (s) {\n\tcase CEPH_MDS_SESSION_NEW: return \"new\";\n\tcase CEPH_MDS_SESSION_OPENING: return \"opening\";\n\tcase CEPH_MDS_SESSION_OPEN: return \"open\";\n\tcase CEPH_MDS_SESSION_HUNG: return \"hung\";\n\tcase CEPH_MDS_SESSION_CLOSING: return \"closing\";\n\tcase CEPH_MDS_SESSION_RESTARTING: return \"restarting\";\n\tcase CEPH_MDS_SESSION_RECONNECTING: return \"reconnecting\";\n\tdefault: return \"???\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_mdsmap_is_laggy",
          "args": [
            "newmap",
            "i"
          ],
          "line": 2981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mds_state_name",
          "args": [
            "newstate"
          ],
          "line": 2980
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mds_state_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/strings.c",
          "lines": "8-31",
          "snippet": "const char *ceph_mds_state_name(int s)\n{\n\tswitch (s) {\n\t\t/* down and out */\n\tcase CEPH_MDS_STATE_DNE:        return \"down:dne\";\n\tcase CEPH_MDS_STATE_STOPPED:    return \"down:stopped\";\n\t\t/* up and out */\n\tcase CEPH_MDS_STATE_BOOT:       return \"up:boot\";\n\tcase CEPH_MDS_STATE_STANDBY:    return \"up:standby\";\n\tcase CEPH_MDS_STATE_STANDBY_REPLAY:    return \"up:standby-replay\";\n\tcase CEPH_MDS_STATE_REPLAYONCE: return \"up:oneshot-replay\";\n\tcase CEPH_MDS_STATE_CREATING:   return \"up:creating\";\n\tcase CEPH_MDS_STATE_STARTING:   return \"up:starting\";\n\t\t/* up and in */\n\tcase CEPH_MDS_STATE_REPLAY:     return \"up:replay\";\n\tcase CEPH_MDS_STATE_RESOLVE:    return \"up:resolve\";\n\tcase CEPH_MDS_STATE_RECONNECT:  return \"up:reconnect\";\n\tcase CEPH_MDS_STATE_REJOIN:     return \"up:rejoin\";\n\tcase CEPH_MDS_STATE_CLIENTREPLAY: return \"up:clientreplay\";\n\tcase CEPH_MDS_STATE_ACTIVE:     return \"up:active\";\n\tcase CEPH_MDS_STATE_STOPPING:   return \"up:stopping\";\n\t}\n\treturn \"???\";\n}",
          "includes": [
            "#include <linux/ceph/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/types.h>\n#include <linux/module.h>\n\nconst char *ceph_mds_state_name(int s)\n{\n\tswitch (s) {\n\t\t/* down and out */\n\tcase CEPH_MDS_STATE_DNE:        return \"down:dne\";\n\tcase CEPH_MDS_STATE_STOPPED:    return \"down:stopped\";\n\t\t/* up and out */\n\tcase CEPH_MDS_STATE_BOOT:       return \"up:boot\";\n\tcase CEPH_MDS_STATE_STANDBY:    return \"up:standby\";\n\tcase CEPH_MDS_STATE_STANDBY_REPLAY:    return \"up:standby-replay\";\n\tcase CEPH_MDS_STATE_REPLAYONCE: return \"up:oneshot-replay\";\n\tcase CEPH_MDS_STATE_CREATING:   return \"up:creating\";\n\tcase CEPH_MDS_STATE_STARTING:   return \"up:starting\";\n\t\t/* up and in */\n\tcase CEPH_MDS_STATE_REPLAY:     return \"up:replay\";\n\tcase CEPH_MDS_STATE_RESOLVE:    return \"up:resolve\";\n\tcase CEPH_MDS_STATE_RECONNECT:  return \"up:reconnect\";\n\tcase CEPH_MDS_STATE_REJOIN:     return \"up:rejoin\";\n\tcase CEPH_MDS_STATE_CLIENTREPLAY: return \"up:clientreplay\";\n\tcase CEPH_MDS_STATE_ACTIVE:     return \"up:active\";\n\tcase CEPH_MDS_STATE_STOPPING:   return \"up:stopping\";\n\t}\n\treturn \"???\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_mdsmap_is_laggy",
          "args": [
            "oldmap",
            "i"
          ],
          "line": 2979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mdsmap_get_state",
          "args": [
            "newmap",
            "i"
          ],
          "line": 2975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mdsmap_get_state",
          "args": [
            "oldmap",
            "i"
          ],
          "line": 2974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"check_new_map new %u old %u\\n\"",
            "newmap->m_epoch",
            "oldmap->m_epoch"
          ],
          "line": 2967
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void check_new_map(struct ceph_mds_client *mdsc,\n\t\t\t  struct ceph_mdsmap *newmap,\n\t\t\t  struct ceph_mdsmap *oldmap)\n{\n\tint i;\n\tint oldstate, newstate;\n\tstruct ceph_mds_session *s;\n\n\tdout(\"check_new_map new %u old %u\\n\",\n\t     newmap->m_epoch, oldmap->m_epoch);\n\n\tfor (i = 0; i < oldmap->m_max_mds && i < mdsc->max_sessions; i++) {\n\t\tif (mdsc->sessions[i] == NULL)\n\t\t\tcontinue;\n\t\ts = mdsc->sessions[i];\n\t\toldstate = ceph_mdsmap_get_state(oldmap, i);\n\t\tnewstate = ceph_mdsmap_get_state(newmap, i);\n\n\t\tdout(\"check_new_map mds%d state %s%s -> %s%s (session %s)\\n\",\n\t\t     i, ceph_mds_state_name(oldstate),\n\t\t     ceph_mdsmap_is_laggy(oldmap, i) ? \" (laggy)\" : \"\",\n\t\t     ceph_mds_state_name(newstate),\n\t\t     ceph_mdsmap_is_laggy(newmap, i) ? \" (laggy)\" : \"\",\n\t\t     ceph_session_state_name(s->s_state));\n\n\t\tif (i >= newmap->m_max_mds ||\n\t\t    memcmp(ceph_mdsmap_get_addr(oldmap, i),\n\t\t\t   ceph_mdsmap_get_addr(newmap, i),\n\t\t\t   sizeof(struct ceph_entity_addr))) {\n\t\t\tif (s->s_state == CEPH_MDS_SESSION_OPENING) {\n\t\t\t\t/* the session never opened, just close it\n\t\t\t\t * out now */\n\t\t\t\t__wake_requests(mdsc, &s->s_waiting);\n\t\t\t\t__unregister_session(mdsc, s);\n\t\t\t} else {\n\t\t\t\t/* just close it */\n\t\t\t\tmutex_unlock(&mdsc->mutex);\n\t\t\t\tmutex_lock(&s->s_mutex);\n\t\t\t\tmutex_lock(&mdsc->mutex);\n\t\t\t\tceph_con_close(&s->s_con);\n\t\t\t\tmutex_unlock(&s->s_mutex);\n\t\t\t\ts->s_state = CEPH_MDS_SESSION_RESTARTING;\n\t\t\t}\n\t\t} else if (oldstate == newstate) {\n\t\t\tcontinue;  /* nothing new with this mds */\n\t\t}\n\n\t\t/*\n\t\t * send reconnect?\n\t\t */\n\t\tif (s->s_state == CEPH_MDS_SESSION_RESTARTING &&\n\t\t    newstate >= CEPH_MDS_STATE_RECONNECT) {\n\t\t\tmutex_unlock(&mdsc->mutex);\n\t\t\tsend_mds_reconnect(mdsc, s);\n\t\t\tmutex_lock(&mdsc->mutex);\n\t\t}\n\n\t\t/*\n\t\t * kick request on any mds that has gone active.\n\t\t */\n\t\tif (oldstate < CEPH_MDS_STATE_ACTIVE &&\n\t\t    newstate >= CEPH_MDS_STATE_ACTIVE) {\n\t\t\tif (oldstate != CEPH_MDS_STATE_CREATING &&\n\t\t\t    oldstate != CEPH_MDS_STATE_STARTING)\n\t\t\t\tpr_info(\"mds%d recovery completed\\n\", s->s_mds);\n\t\t\tkick_requests(mdsc, i);\n\t\t\tceph_kick_flushing_caps(mdsc, s);\n\t\t\twake_up_session_caps(s, 1);\n\t\t}\n\t}\n\n\tfor (i = 0; i < newmap->m_max_mds && i < mdsc->max_sessions; i++) {\n\t\ts = mdsc->sessions[i];\n\t\tif (!s)\n\t\t\tcontinue;\n\t\tif (!ceph_mdsmap_is_laggy(newmap, i))\n\t\t\tcontinue;\n\t\tif (s->s_state == CEPH_MDS_SESSION_OPEN ||\n\t\t    s->s_state == CEPH_MDS_SESSION_HUNG ||\n\t\t    s->s_state == CEPH_MDS_SESSION_CLOSING) {\n\t\t\tdout(\" connecting to export targets of laggy mds%d\\n\",\n\t\t\t     i);\n\t\t\t__open_export_target_sessions(mdsc, s);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "send_mds_reconnect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "2820-2950",
    "snippet": "static void send_mds_reconnect(struct ceph_mds_client *mdsc,\n\t\t\t       struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *reply;\n\tstruct rb_node *p;\n\tint mds = session->s_mds;\n\tint err = -ENOMEM;\n\tint s_nr_caps;\n\tstruct ceph_pagelist *pagelist;\n\tstruct ceph_reconnect_state recon_state;\n\n\tpr_info(\"mds%d reconnect start\\n\", mds);\n\n\tpagelist = kmalloc(sizeof(*pagelist), GFP_NOFS);\n\tif (!pagelist)\n\t\tgoto fail_nopagelist;\n\tceph_pagelist_init(pagelist);\n\n\treply = ceph_msg_new(CEPH_MSG_CLIENT_RECONNECT, 0, GFP_NOFS, false);\n\tif (!reply)\n\t\tgoto fail_nomsg;\n\n\tmutex_lock(&session->s_mutex);\n\tsession->s_state = CEPH_MDS_SESSION_RECONNECTING;\n\tsession->s_seq = 0;\n\n\tdout(\"session %p state %s\\n\", session,\n\t     ceph_session_state_name(session->s_state));\n\n\tspin_lock(&session->s_gen_ttl_lock);\n\tsession->s_cap_gen++;\n\tspin_unlock(&session->s_gen_ttl_lock);\n\n\tspin_lock(&session->s_cap_lock);\n\t/* don't know if session is readonly */\n\tsession->s_readonly = 0;\n\t/*\n\t * notify __ceph_remove_cap() that we are composing cap reconnect.\n\t * If a cap get released before being added to the cap reconnect,\n\t * __ceph_remove_cap() should skip queuing cap release.\n\t */\n\tsession->s_cap_reconnect = 1;\n\t/* drop old cap expires; we're about to reestablish that state */\n\tdiscard_cap_releases(mdsc, session);\n\tspin_unlock(&session->s_cap_lock);\n\n\t/* trim unused caps to reduce MDS's cache rejoin time */\n\tshrink_dcache_parent(mdsc->fsc->sb->s_root);\n\n\tceph_con_close(&session->s_con);\n\tceph_con_open(&session->s_con,\n\t\t      CEPH_ENTITY_TYPE_MDS, mds,\n\t\t      ceph_mdsmap_get_addr(mdsc->mdsmap, mds));\n\n\t/* replay unsafe requests */\n\treplay_unsafe_requests(mdsc, session);\n\n\tdown_read(&mdsc->snap_rwsem);\n\n\t/* traverse this session's caps */\n\ts_nr_caps = session->s_nr_caps;\n\terr = ceph_pagelist_encode_32(pagelist, s_nr_caps);\n\tif (err)\n\t\tgoto fail;\n\n\trecon_state.nr_caps = 0;\n\trecon_state.pagelist = pagelist;\n\trecon_state.flock = session->s_con.peer_features & CEPH_FEATURE_FLOCK;\n\terr = iterate_session_caps(session, encode_caps_cb, &recon_state);\n\tif (err < 0)\n\t\tgoto fail;\n\n\tspin_lock(&session->s_cap_lock);\n\tsession->s_cap_reconnect = 0;\n\tspin_unlock(&session->s_cap_lock);\n\n\t/*\n\t * snaprealms.  we provide mds with the ino, seq (version), and\n\t * parent for all of our realms.  If the mds has any newer info,\n\t * it will tell us.\n\t */\n\tfor (p = rb_first(&mdsc->snap_realms); p; p = rb_next(p)) {\n\t\tstruct ceph_snap_realm *realm =\n\t\t\trb_entry(p, struct ceph_snap_realm, node);\n\t\tstruct ceph_mds_snaprealm_reconnect sr_rec;\n\n\t\tdout(\" adding snap realm %llx seq %lld parent %llx\\n\",\n\t\t     realm->ino, realm->seq, realm->parent_ino);\n\t\tsr_rec.ino = cpu_to_le64(realm->ino);\n\t\tsr_rec.seq = cpu_to_le64(realm->seq);\n\t\tsr_rec.parent = cpu_to_le64(realm->parent_ino);\n\t\terr = ceph_pagelist_append(pagelist, &sr_rec, sizeof(sr_rec));\n\t\tif (err)\n\t\t\tgoto fail;\n\t}\n\n\tif (recon_state.flock)\n\t\treply->hdr.version = cpu_to_le16(2);\n\n\t/* raced with cap release? */\n\tif (s_nr_caps != recon_state.nr_caps) {\n\t\tstruct page *page = list_first_entry(&pagelist->head,\n\t\t\t\t\t\t     struct page, lru);\n\t\t__le32 *addr = kmap_atomic(page);\n\t\t*addr = cpu_to_le32(recon_state.nr_caps);\n\t\tkunmap_atomic(addr);\n\t}\n\n\treply->hdr.data_len = cpu_to_le32(pagelist->length);\n\tceph_msg_data_add_pagelist(reply, pagelist);\n\tceph_con_send(&session->s_con, reply);\n\n\tmutex_unlock(&session->s_mutex);\n\n\tmutex_lock(&mdsc->mutex);\n\t__wake_requests(mdsc, &session->s_waiting);\n\tmutex_unlock(&mdsc->mutex);\n\n\tup_read(&mdsc->snap_rwsem);\n\treturn;\n\nfail:\n\tceph_msg_put(reply);\n\tup_read(&mdsc->snap_rwsem);\n\tmutex_unlock(&session->s_mutex);\nfail_nomsg:\n\tceph_pagelist_release(pagelist);\nfail_nopagelist:\n\tpr_err(\"error %d preparing reconnect for mds%d\\n\", err, mds);\n\treturn;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"error %d preparing reconnect for mds%d\\n\"",
            "err",
            "mds"
          ],
          "line": 2948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_pagelist_release",
          "args": [
            "pagelist"
          ],
          "line": 2946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&session->s_mutex"
          ],
          "line": 2944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mdsc->snap_rwsem"
          ],
          "line": 2943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_msg_put",
          "args": [
            "reply"
          ],
          "line": 2942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mdsc->snap_rwsem"
          ],
          "line": 2938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 2936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__wake_requests",
          "args": [
            "mdsc",
            "&session->s_waiting"
          ],
          "line": 2935
        },
        "resolved": true,
        "details": {
          "function_name": "__wake_requests",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "2155-2170",
          "snippet": "static void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head)\n{\n\tstruct ceph_mds_request *req;\n\tLIST_HEAD(tmp_list);\n\n\tlist_splice_init(head, &tmp_list);\n\n\twhile (!list_empty(&tmp_list)) {\n\t\treq = list_entry(tmp_list.next,\n\t\t\t\t struct ceph_mds_request, r_wait);\n\t\tlist_del_init(&req->r_wait);\n\t\tdout(\" wake request %p tid %llu\\n\", req, req->r_tid);\n\t\t__do_request(mdsc, req);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);\n\nstatic void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head)\n{\n\tstruct ceph_mds_request *req;\n\tLIST_HEAD(tmp_list);\n\n\tlist_splice_init(head, &tmp_list);\n\n\twhile (!list_empty(&tmp_list)) {\n\t\treq = list_entry(tmp_list.next,\n\t\t\t\t struct ceph_mds_request, r_wait);\n\t\tlist_del_init(&req->r_wait);\n\t\tdout(\" wake request %p tid %llu\\n\", req, req->r_tid);\n\t\t__do_request(mdsc, req);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 2934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&session->s_mutex"
          ],
          "line": 2932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_con_send",
          "args": [
            "&session->s_con",
            "reply"
          ],
          "line": 2930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_msg_data_add_pagelist",
          "args": [
            "reply",
            "pagelist"
          ],
          "line": 2929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "pagelist->length"
          ],
          "line": 2928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "addr"
          ],
          "line": 2925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "recon_state.nr_caps"
          ],
          "line": 2924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 2923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&pagelist->head",
            "structpage",
            "lru"
          ],
          "line": 2921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "2"
          ],
          "line": 2917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_pagelist_append",
          "args": [
            "pagelist",
            "&sr_rec",
            "sizeof(sr_rec)"
          ],
          "line": 2911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "realm->parent_ino"
          ],
          "line": 2910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "realm->seq"
          ],
          "line": 2909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "realm->ino"
          ],
          "line": 2908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" adding snap realm %llx seq %lld parent %llx\\n\"",
            "realm->ino",
            "realm->seq",
            "realm->parent_ino"
          ],
          "line": 2906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "p",
            "structceph_snap_realm",
            "node"
          ],
          "line": 2903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "p"
          ],
          "line": 2901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&mdsc->snap_realms"
          ],
          "line": 2901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&session->s_cap_lock"
          ],
          "line": 2894
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&session->s_cap_lock"
          ],
          "line": 2892
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterate_session_caps",
          "args": [
            "session",
            "encode_caps_cb",
            "&recon_state"
          ],
          "line": 2888
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_session_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1030-1089",
          "snippet": "static int iterate_session_caps(struct ceph_mds_session *session,\n\t\t\t\t int (*cb)(struct inode *, struct ceph_cap *,\n\t\t\t\t\t    void *), void *arg)\n{\n\tstruct list_head *p;\n\tstruct ceph_cap *cap;\n\tstruct inode *inode, *last_inode = NULL;\n\tstruct ceph_cap *old_cap = NULL;\n\tint ret;\n\n\tdout(\"iterate_session_caps %p mds%d\\n\", session, session->s_mds);\n\tspin_lock(&session->s_cap_lock);\n\tp = session->s_caps.next;\n\twhile (p != &session->s_caps) {\n\t\tcap = list_entry(p, struct ceph_cap, session_caps);\n\t\tinode = igrab(&cap->ci->vfs_inode);\n\t\tif (!inode) {\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tsession->s_cap_iterator = cap;\n\t\tspin_unlock(&session->s_cap_lock);\n\n\t\tif (last_inode) {\n\t\t\tiput(last_inode);\n\t\t\tlast_inode = NULL;\n\t\t}\n\t\tif (old_cap) {\n\t\t\tceph_put_cap(session->s_mdsc, old_cap);\n\t\t\told_cap = NULL;\n\t\t}\n\n\t\tret = cb(inode, cap, arg);\n\t\tlast_inode = inode;\n\n\t\tspin_lock(&session->s_cap_lock);\n\t\tp = p->next;\n\t\tif (cap->ci == NULL) {\n\t\t\tdout(\"iterate_session_caps  finishing cap %p removal\\n\",\n\t\t\t     cap);\n\t\t\tBUG_ON(cap->session != session);\n\t\t\tlist_del_init(&cap->session_caps);\n\t\t\tsession->s_nr_caps--;\n\t\t\tcap->session = NULL;\n\t\t\told_cap = cap;  /* put_cap it w/o locks held */\n\t\t}\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tsession->s_cap_iterator = NULL;\n\tspin_unlock(&session->s_cap_lock);\n\n\tiput(last_inode);\n\tif (old_cap)\n\t\tceph_put_cap(session->s_mdsc, old_cap);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int iterate_session_caps(struct ceph_mds_session *session,\n\t\t\t\t int (*cb)(struct inode *, struct ceph_cap *,\n\t\t\t\t\t    void *), void *arg)\n{\n\tstruct list_head *p;\n\tstruct ceph_cap *cap;\n\tstruct inode *inode, *last_inode = NULL;\n\tstruct ceph_cap *old_cap = NULL;\n\tint ret;\n\n\tdout(\"iterate_session_caps %p mds%d\\n\", session, session->s_mds);\n\tspin_lock(&session->s_cap_lock);\n\tp = session->s_caps.next;\n\twhile (p != &session->s_caps) {\n\t\tcap = list_entry(p, struct ceph_cap, session_caps);\n\t\tinode = igrab(&cap->ci->vfs_inode);\n\t\tif (!inode) {\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tsession->s_cap_iterator = cap;\n\t\tspin_unlock(&session->s_cap_lock);\n\n\t\tif (last_inode) {\n\t\t\tiput(last_inode);\n\t\t\tlast_inode = NULL;\n\t\t}\n\t\tif (old_cap) {\n\t\t\tceph_put_cap(session->s_mdsc, old_cap);\n\t\t\told_cap = NULL;\n\t\t}\n\n\t\tret = cb(inode, cap, arg);\n\t\tlast_inode = inode;\n\n\t\tspin_lock(&session->s_cap_lock);\n\t\tp = p->next;\n\t\tif (cap->ci == NULL) {\n\t\t\tdout(\"iterate_session_caps  finishing cap %p removal\\n\",\n\t\t\t     cap);\n\t\t\tBUG_ON(cap->session != session);\n\t\t\tlist_del_init(&cap->session_caps);\n\t\t\tsession->s_nr_caps--;\n\t\t\tcap->session = NULL;\n\t\t\told_cap = cap;  /* put_cap it w/o locks held */\n\t\t}\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tsession->s_cap_iterator = NULL;\n\tspin_unlock(&session->s_cap_lock);\n\n\tiput(last_inode);\n\tif (old_cap)\n\t\tceph_put_cap(session->s_mdsc, old_cap);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_pagelist_encode_32",
          "args": [
            "pagelist",
            "s_nr_caps"
          ],
          "line": 2881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&mdsc->snap_rwsem"
          ],
          "line": 2877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replay_unsafe_requests",
          "args": [
            "mdsc",
            "session"
          ],
          "line": 2875
        },
        "resolved": true,
        "details": {
          "function_name": "replay_unsafe_requests",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "2650-2690",
          "snippet": "static void replay_unsafe_requests(struct ceph_mds_client *mdsc,\n\t\t\t\t   struct ceph_mds_session *session)\n{\n\tstruct ceph_mds_request *req, *nreq;\n\tstruct rb_node *p;\n\tint err;\n\n\tdout(\"replay_unsafe_requests mds%d\\n\", session->s_mds);\n\n\tmutex_lock(&mdsc->mutex);\n\tlist_for_each_entry_safe(req, nreq, &session->s_unsafe, r_unsafe_item) {\n\t\terr = __prepare_send_request(mdsc, req, session->s_mds);\n\t\tif (!err) {\n\t\t\tceph_msg_get(req->r_request);\n\t\t\tceph_con_send(&session->s_con, req->r_request);\n\t\t}\n\t}\n\n\t/*\n\t * also re-send old requests when MDS enters reconnect stage. So that MDS\n\t * can process completed request in clientreplay stage.\n\t */\n\tp = rb_first(&mdsc->request_tree);\n\twhile (p) {\n\t\treq = rb_entry(p, struct ceph_mds_request, r_node);\n\t\tp = rb_next(p);\n\t\tif (req->r_got_unsafe)\n\t\t\tcontinue;\n\t\tif (req->r_attempts == 0)\n\t\t\tcontinue; /* only old requests */\n\t\tif (req->r_session &&\n\t\t    req->r_session->s_mds == session->s_mds) {\n\t\t\terr = __prepare_send_request(mdsc, req, session->s_mds);\n\t\t\tif (!err) {\n\t\t\t\tceph_msg_get(req->r_request);\n\t\t\t\tceph_con_send(&session->s_con, req->r_request);\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&mdsc->mutex);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void replay_unsafe_requests(struct ceph_mds_client *mdsc,\n\t\t\t\t   struct ceph_mds_session *session)\n{\n\tstruct ceph_mds_request *req, *nreq;\n\tstruct rb_node *p;\n\tint err;\n\n\tdout(\"replay_unsafe_requests mds%d\\n\", session->s_mds);\n\n\tmutex_lock(&mdsc->mutex);\n\tlist_for_each_entry_safe(req, nreq, &session->s_unsafe, r_unsafe_item) {\n\t\terr = __prepare_send_request(mdsc, req, session->s_mds);\n\t\tif (!err) {\n\t\t\tceph_msg_get(req->r_request);\n\t\t\tceph_con_send(&session->s_con, req->r_request);\n\t\t}\n\t}\n\n\t/*\n\t * also re-send old requests when MDS enters reconnect stage. So that MDS\n\t * can process completed request in clientreplay stage.\n\t */\n\tp = rb_first(&mdsc->request_tree);\n\twhile (p) {\n\t\treq = rb_entry(p, struct ceph_mds_request, r_node);\n\t\tp = rb_next(p);\n\t\tif (req->r_got_unsafe)\n\t\t\tcontinue;\n\t\tif (req->r_attempts == 0)\n\t\t\tcontinue; /* only old requests */\n\t\tif (req->r_session &&\n\t\t    req->r_session->s_mds == session->s_mds) {\n\t\t\terr = __prepare_send_request(mdsc, req, session->s_mds);\n\t\t\tif (!err) {\n\t\t\t\tceph_msg_get(req->r_request);\n\t\t\t\tceph_con_send(&session->s_con, req->r_request);\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&mdsc->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_con_open",
          "args": [
            "&session->s_con",
            "CEPH_ENTITY_TYPE_MDS",
            "mds",
            "ceph_mdsmap_get_addr(mdsc->mdsmap, mds)"
          ],
          "line": 2870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mdsmap_get_addr",
          "args": [
            "mdsc->mdsmap",
            "mds"
          ],
          "line": 2872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_con_close",
          "args": [
            "&session->s_con"
          ],
          "line": 2869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shrink_dcache_parent",
          "args": [
            "mdsc->fsc->sb->s_root"
          ],
          "line": 2867
        },
        "resolved": true,
        "details": {
          "function_name": "shrink_dcache_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1361-1377",
          "snippet": "void shrink_dcache_parent(struct dentry *parent)\n{\n\tfor (;;) {\n\t\tstruct select_data data;\n\n\t\tINIT_LIST_HEAD(&data.dispose);\n\t\tdata.start = parent;\n\t\tdata.found = 0;\n\n\t\td_walk(parent, &data, select_collect, NULL);\n\t\tif (!data.found)\n\t\t\tbreak;\n\n\t\tshrink_dentry_list(&data.dispose);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid shrink_dcache_parent(struct dentry *parent)\n{\n\tfor (;;) {\n\t\tstruct select_data data;\n\n\t\tINIT_LIST_HEAD(&data.dispose);\n\t\tdata.start = parent;\n\t\tdata.found = 0;\n\n\t\td_walk(parent, &data, select_collect, NULL);\n\t\tif (!data.found)\n\t\t\tbreak;\n\n\t\tshrink_dentry_list(&data.dispose);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "discard_cap_releases",
          "args": [
            "mdsc",
            "session"
          ],
          "line": 2863
        },
        "resolved": true,
        "details": {
          "function_name": "discard_cap_releases",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1557-1594",
          "snippet": "static void discard_cap_releases(struct ceph_mds_client *mdsc,\n\t\t\t\t struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *msg;\n\tstruct ceph_mds_cap_release *head;\n\tunsigned num;\n\n\tdout(\"discard_cap_releases mds%d\\n\", session->s_mds);\n\n\tif (!list_empty(&session->s_cap_releases)) {\n\t\t/* zero out the in-progress message */\n\t\tmsg = list_first_entry(&session->s_cap_releases,\n\t\t\t\t\tstruct ceph_msg, list_head);\n\t\thead = msg->front.iov_base;\n\t\tnum = le32_to_cpu(head->num);\n\t\tdout(\"discard_cap_releases mds%d %p %u\\n\",\n\t\t     session->s_mds, msg, num);\n\t\thead->num = cpu_to_le32(0);\n\t\tmsg->front.iov_len = sizeof(*head);\n\t\tsession->s_num_cap_releases += num;\n\t}\n\n\t/* requeue completed messages */\n\twhile (!list_empty(&session->s_cap_releases_done)) {\n\t\tmsg = list_first_entry(&session->s_cap_releases_done,\n\t\t\t\t struct ceph_msg, list_head);\n\t\tlist_del_init(&msg->list_head);\n\n\t\thead = msg->front.iov_base;\n\t\tnum = le32_to_cpu(head->num);\n\t\tdout(\"discard_cap_releases mds%d %p %u\\n\", session->s_mds, msg,\n\t\t     num);\n\t\tsession->s_num_cap_releases += num;\n\t\thead->num = cpu_to_le32(0);\n\t\tmsg->front.iov_len = sizeof(*head);\n\t\tlist_add(&msg->list_head, &session->s_cap_releases);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);\n\nstatic void discard_cap_releases(struct ceph_mds_client *mdsc,\n\t\t\t\t struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *msg;\n\tstruct ceph_mds_cap_release *head;\n\tunsigned num;\n\n\tdout(\"discard_cap_releases mds%d\\n\", session->s_mds);\n\n\tif (!list_empty(&session->s_cap_releases)) {\n\t\t/* zero out the in-progress message */\n\t\tmsg = list_first_entry(&session->s_cap_releases,\n\t\t\t\t\tstruct ceph_msg, list_head);\n\t\thead = msg->front.iov_base;\n\t\tnum = le32_to_cpu(head->num);\n\t\tdout(\"discard_cap_releases mds%d %p %u\\n\",\n\t\t     session->s_mds, msg, num);\n\t\thead->num = cpu_to_le32(0);\n\t\tmsg->front.iov_len = sizeof(*head);\n\t\tsession->s_num_cap_releases += num;\n\t}\n\n\t/* requeue completed messages */\n\twhile (!list_empty(&session->s_cap_releases_done)) {\n\t\tmsg = list_first_entry(&session->s_cap_releases_done,\n\t\t\t\t struct ceph_msg, list_head);\n\t\tlist_del_init(&msg->list_head);\n\n\t\thead = msg->front.iov_base;\n\t\tnum = le32_to_cpu(head->num);\n\t\tdout(\"discard_cap_releases mds%d %p %u\\n\", session->s_mds, msg,\n\t\t     num);\n\t\tsession->s_num_cap_releases += num;\n\t\thead->num = cpu_to_le32(0);\n\t\tmsg->front.iov_len = sizeof(*head);\n\t\tlist_add(&msg->list_head, &session->s_cap_releases);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"session %p state %s\\n\"",
            "session",
            "ceph_session_state_name(session->s_state)"
          ],
          "line": 2846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_session_state_name",
          "args": [
            "session->s_state"
          ],
          "line": 2847
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_session_state_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "348-360",
          "snippet": "const char *ceph_session_state_name(int s)\n{\n\tswitch (s) {\n\tcase CEPH_MDS_SESSION_NEW: return \"new\";\n\tcase CEPH_MDS_SESSION_OPENING: return \"opening\";\n\tcase CEPH_MDS_SESSION_OPEN: return \"open\";\n\tcase CEPH_MDS_SESSION_HUNG: return \"hung\";\n\tcase CEPH_MDS_SESSION_CLOSING: return \"closing\";\n\tcase CEPH_MDS_SESSION_RESTARTING: return \"restarting\";\n\tcase CEPH_MDS_SESSION_RECONNECTING: return \"reconnecting\";\n\tdefault: return \"???\";\n\t}\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nconst char *ceph_session_state_name(int s)\n{\n\tswitch (s) {\n\tcase CEPH_MDS_SESSION_NEW: return \"new\";\n\tcase CEPH_MDS_SESSION_OPENING: return \"opening\";\n\tcase CEPH_MDS_SESSION_OPEN: return \"open\";\n\tcase CEPH_MDS_SESSION_HUNG: return \"hung\";\n\tcase CEPH_MDS_SESSION_CLOSING: return \"closing\";\n\tcase CEPH_MDS_SESSION_RESTARTING: return \"restarting\";\n\tcase CEPH_MDS_SESSION_RECONNECTING: return \"reconnecting\";\n\tdefault: return \"???\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&session->s_mutex"
          ],
          "line": 2842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_msg_new",
          "args": [
            "CEPH_MSG_CLIENT_RECONNECT",
            "0",
            "GFP_NOFS",
            "false"
          ],
          "line": 2838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_pagelist_init",
          "args": [
            "pagelist"
          ],
          "line": 2836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*pagelist)",
            "GFP_NOFS"
          ],
          "line": 2833
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"mds%d reconnect start\\n\"",
            "mds"
          ],
          "line": 2831
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);\n\nstatic void send_mds_reconnect(struct ceph_mds_client *mdsc,\n\t\t\t       struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *reply;\n\tstruct rb_node *p;\n\tint mds = session->s_mds;\n\tint err = -ENOMEM;\n\tint s_nr_caps;\n\tstruct ceph_pagelist *pagelist;\n\tstruct ceph_reconnect_state recon_state;\n\n\tpr_info(\"mds%d reconnect start\\n\", mds);\n\n\tpagelist = kmalloc(sizeof(*pagelist), GFP_NOFS);\n\tif (!pagelist)\n\t\tgoto fail_nopagelist;\n\tceph_pagelist_init(pagelist);\n\n\treply = ceph_msg_new(CEPH_MSG_CLIENT_RECONNECT, 0, GFP_NOFS, false);\n\tif (!reply)\n\t\tgoto fail_nomsg;\n\n\tmutex_lock(&session->s_mutex);\n\tsession->s_state = CEPH_MDS_SESSION_RECONNECTING;\n\tsession->s_seq = 0;\n\n\tdout(\"session %p state %s\\n\", session,\n\t     ceph_session_state_name(session->s_state));\n\n\tspin_lock(&session->s_gen_ttl_lock);\n\tsession->s_cap_gen++;\n\tspin_unlock(&session->s_gen_ttl_lock);\n\n\tspin_lock(&session->s_cap_lock);\n\t/* don't know if session is readonly */\n\tsession->s_readonly = 0;\n\t/*\n\t * notify __ceph_remove_cap() that we are composing cap reconnect.\n\t * If a cap get released before being added to the cap reconnect,\n\t * __ceph_remove_cap() should skip queuing cap release.\n\t */\n\tsession->s_cap_reconnect = 1;\n\t/* drop old cap expires; we're about to reestablish that state */\n\tdiscard_cap_releases(mdsc, session);\n\tspin_unlock(&session->s_cap_lock);\n\n\t/* trim unused caps to reduce MDS's cache rejoin time */\n\tshrink_dcache_parent(mdsc->fsc->sb->s_root);\n\n\tceph_con_close(&session->s_con);\n\tceph_con_open(&session->s_con,\n\t\t      CEPH_ENTITY_TYPE_MDS, mds,\n\t\t      ceph_mdsmap_get_addr(mdsc->mdsmap, mds));\n\n\t/* replay unsafe requests */\n\treplay_unsafe_requests(mdsc, session);\n\n\tdown_read(&mdsc->snap_rwsem);\n\n\t/* traverse this session's caps */\n\ts_nr_caps = session->s_nr_caps;\n\terr = ceph_pagelist_encode_32(pagelist, s_nr_caps);\n\tif (err)\n\t\tgoto fail;\n\n\trecon_state.nr_caps = 0;\n\trecon_state.pagelist = pagelist;\n\trecon_state.flock = session->s_con.peer_features & CEPH_FEATURE_FLOCK;\n\terr = iterate_session_caps(session, encode_caps_cb, &recon_state);\n\tif (err < 0)\n\t\tgoto fail;\n\n\tspin_lock(&session->s_cap_lock);\n\tsession->s_cap_reconnect = 0;\n\tspin_unlock(&session->s_cap_lock);\n\n\t/*\n\t * snaprealms.  we provide mds with the ino, seq (version), and\n\t * parent for all of our realms.  If the mds has any newer info,\n\t * it will tell us.\n\t */\n\tfor (p = rb_first(&mdsc->snap_realms); p; p = rb_next(p)) {\n\t\tstruct ceph_snap_realm *realm =\n\t\t\trb_entry(p, struct ceph_snap_realm, node);\n\t\tstruct ceph_mds_snaprealm_reconnect sr_rec;\n\n\t\tdout(\" adding snap realm %llx seq %lld parent %llx\\n\",\n\t\t     realm->ino, realm->seq, realm->parent_ino);\n\t\tsr_rec.ino = cpu_to_le64(realm->ino);\n\t\tsr_rec.seq = cpu_to_le64(realm->seq);\n\t\tsr_rec.parent = cpu_to_le64(realm->parent_ino);\n\t\terr = ceph_pagelist_append(pagelist, &sr_rec, sizeof(sr_rec));\n\t\tif (err)\n\t\t\tgoto fail;\n\t}\n\n\tif (recon_state.flock)\n\t\treply->hdr.version = cpu_to_le16(2);\n\n\t/* raced with cap release? */\n\tif (s_nr_caps != recon_state.nr_caps) {\n\t\tstruct page *page = list_first_entry(&pagelist->head,\n\t\t\t\t\t\t     struct page, lru);\n\t\t__le32 *addr = kmap_atomic(page);\n\t\t*addr = cpu_to_le32(recon_state.nr_caps);\n\t\tkunmap_atomic(addr);\n\t}\n\n\treply->hdr.data_len = cpu_to_le32(pagelist->length);\n\tceph_msg_data_add_pagelist(reply, pagelist);\n\tceph_con_send(&session->s_con, reply);\n\n\tmutex_unlock(&session->s_mutex);\n\n\tmutex_lock(&mdsc->mutex);\n\t__wake_requests(mdsc, &session->s_waiting);\n\tmutex_unlock(&mdsc->mutex);\n\n\tup_read(&mdsc->snap_rwsem);\n\treturn;\n\nfail:\n\tceph_msg_put(reply);\n\tup_read(&mdsc->snap_rwsem);\n\tmutex_unlock(&session->s_mutex);\nfail_nomsg:\n\tceph_pagelist_release(pagelist);\nfail_nopagelist:\n\tpr_err(\"error %d preparing reconnect for mds%d\\n\", err, mds);\n\treturn;\n}"
  },
  {
    "function_name": "encode_caps_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "2695-2805",
    "snippet": "static int encode_caps_cb(struct inode *inode, struct ceph_cap *cap,\n\t\t\t  void *arg)\n{\n\tunion {\n\t\tstruct ceph_mds_cap_reconnect v2;\n\t\tstruct ceph_mds_cap_reconnect_v1 v1;\n\t} rec;\n\tsize_t reclen;\n\tstruct ceph_inode_info *ci;\n\tstruct ceph_reconnect_state *recon_state = arg;\n\tstruct ceph_pagelist *pagelist = recon_state->pagelist;\n\tchar *path;\n\tint pathlen, err;\n\tu64 pathbase;\n\tstruct dentry *dentry;\n\n\tci = cap->ci;\n\n\tdout(\" adding %p ino %llx.%llx cap %p %lld %s\\n\",\n\t     inode, ceph_vinop(inode), cap, cap->cap_id,\n\t     ceph_cap_string(cap->issued));\n\terr = ceph_pagelist_encode_64(pagelist, ceph_ino(inode));\n\tif (err)\n\t\treturn err;\n\n\tdentry = d_find_alias(inode);\n\tif (dentry) {\n\t\tpath = ceph_mdsc_build_path(dentry, &pathlen, &pathbase, 0);\n\t\tif (IS_ERR(path)) {\n\t\t\terr = PTR_ERR(path);\n\t\t\tgoto out_dput;\n\t\t}\n\t} else {\n\t\tpath = NULL;\n\t\tpathlen = 0;\n\t}\n\terr = ceph_pagelist_encode_string(pagelist, path, pathlen);\n\tif (err)\n\t\tgoto out_free;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tcap->seq = 0;        /* reset cap seq */\n\tcap->issue_seq = 0;  /* and issue_seq */\n\tcap->mseq = 0;       /* and migrate_seq */\n\tcap->cap_gen = cap->session->s_cap_gen;\n\n\tif (recon_state->flock) {\n\t\trec.v2.cap_id = cpu_to_le64(cap->cap_id);\n\t\trec.v2.wanted = cpu_to_le32(__ceph_caps_wanted(ci));\n\t\trec.v2.issued = cpu_to_le32(cap->issued);\n\t\trec.v2.snaprealm = cpu_to_le64(ci->i_snap_realm->ino);\n\t\trec.v2.pathbase = cpu_to_le64(pathbase);\n\t\trec.v2.flock_len = 0;\n\t\treclen = sizeof(rec.v2);\n\t} else {\n\t\trec.v1.cap_id = cpu_to_le64(cap->cap_id);\n\t\trec.v1.wanted = cpu_to_le32(__ceph_caps_wanted(ci));\n\t\trec.v1.issued = cpu_to_le32(cap->issued);\n\t\trec.v1.size = cpu_to_le64(inode->i_size);\n\t\tceph_encode_timespec(&rec.v1.mtime, &inode->i_mtime);\n\t\tceph_encode_timespec(&rec.v1.atime, &inode->i_atime);\n\t\trec.v1.snaprealm = cpu_to_le64(ci->i_snap_realm->ino);\n\t\trec.v1.pathbase = cpu_to_le64(pathbase);\n\t\treclen = sizeof(rec.v1);\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (recon_state->flock) {\n\t\tint num_fcntl_locks, num_flock_locks;\n\t\tstruct ceph_filelock *flocks;\n\nencode_again:\n\t\tceph_count_locks(inode, &num_fcntl_locks, &num_flock_locks);\n\t\tflocks = kmalloc((num_fcntl_locks+num_flock_locks) *\n\t\t\t\t sizeof(struct ceph_filelock), GFP_NOFS);\n\t\tif (!flocks) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_free;\n\t\t}\n\t\terr = ceph_encode_locks_to_buffer(inode, flocks,\n\t\t\t\t\t\t  num_fcntl_locks,\n\t\t\t\t\t\t  num_flock_locks);\n\t\tif (err) {\n\t\t\tkfree(flocks);\n\t\t\tif (err == -ENOSPC)\n\t\t\t\tgoto encode_again;\n\t\t\tgoto out_free;\n\t\t}\n\t\t/*\n\t\t * number of encoded locks is stable, so copy to pagelist\n\t\t */\n\t\trec.v2.flock_len = cpu_to_le32(2*sizeof(u32) +\n\t\t\t\t    (num_fcntl_locks+num_flock_locks) *\n\t\t\t\t    sizeof(struct ceph_filelock));\n\t\terr = ceph_pagelist_append(pagelist, &rec, reclen);\n\t\tif (!err)\n\t\t\terr = ceph_locks_to_pagelist(flocks, pagelist,\n\t\t\t\t\t\t     num_fcntl_locks,\n\t\t\t\t\t\t     num_flock_locks);\n\t\tkfree(flocks);\n\t} else {\n\t\terr = ceph_pagelist_append(pagelist, &rec, reclen);\n\t}\n\n\trecon_state->nr_caps++;\nout_free:\n\tkfree(path);\nout_dput:\n\tdput(dentry);\n\treturn err;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 2803
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "path"
          ],
          "line": 2801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_pagelist_append",
          "args": [
            "pagelist",
            "&rec",
            "reclen"
          ],
          "line": 2796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "flocks"
          ],
          "line": 2794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_locks_to_pagelist",
          "args": [
            "flocks",
            "pagelist",
            "num_fcntl_locks",
            "num_flock_locks"
          ],
          "line": 2791
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_locks_to_pagelist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/locks.c",
          "lines": "323-350",
          "snippet": "int ceph_locks_to_pagelist(struct ceph_filelock *flocks,\n\t\t\t   struct ceph_pagelist *pagelist,\n\t\t\t   int num_fcntl_locks, int num_flock_locks)\n{\n\tint err = 0;\n\t__le32 nlocks;\n\n\tnlocks = cpu_to_le32(num_fcntl_locks);\n\terr = ceph_pagelist_append(pagelist, &nlocks, sizeof(nlocks));\n\tif (err)\n\t\tgoto out_fail;\n\n\terr = ceph_pagelist_append(pagelist, flocks,\n\t\t\t\t   num_fcntl_locks * sizeof(*flocks));\n\tif (err)\n\t\tgoto out_fail;\n\n\tnlocks = cpu_to_le32(num_flock_locks);\n\terr = ceph_pagelist_append(pagelist, &nlocks, sizeof(nlocks));\n\tif (err)\n\t\tgoto out_fail;\n\n\terr = ceph_pagelist_append(pagelist,\n\t\t\t\t   &flocks[num_fcntl_locks],\n\t\t\t\t   num_flock_locks * sizeof(*flocks));\nout_fail:\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/pagelist.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/namei.h>",
            "#include <linux/file.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/pagelist.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_locks_to_pagelist(struct ceph_filelock *flocks,\n\t\t\t   struct ceph_pagelist *pagelist,\n\t\t\t   int num_fcntl_locks, int num_flock_locks)\n{\n\tint err = 0;\n\t__le32 nlocks;\n\n\tnlocks = cpu_to_le32(num_fcntl_locks);\n\terr = ceph_pagelist_append(pagelist, &nlocks, sizeof(nlocks));\n\tif (err)\n\t\tgoto out_fail;\n\n\terr = ceph_pagelist_append(pagelist, flocks,\n\t\t\t\t   num_fcntl_locks * sizeof(*flocks));\n\tif (err)\n\t\tgoto out_fail;\n\n\tnlocks = cpu_to_le32(num_flock_locks);\n\terr = ceph_pagelist_append(pagelist, &nlocks, sizeof(nlocks));\n\tif (err)\n\t\tgoto out_fail;\n\n\terr = ceph_pagelist_append(pagelist,\n\t\t\t\t   &flocks[num_fcntl_locks],\n\t\t\t\t   num_flock_locks * sizeof(*flocks));\nout_fail:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_pagelist_append",
          "args": [
            "pagelist",
            "&rec",
            "reclen"
          ],
          "line": 2789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "2*sizeof(u32) +\n\t\t\t\t    (num_fcntl_locks+num_flock_locks) *\n\t\t\t\t    sizeof(struct ceph_filelock)"
          ],
          "line": 2786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "flocks"
          ],
          "line": 2778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_encode_locks_to_buffer",
          "args": [
            "inode",
            "flocks",
            "num_fcntl_locks",
            "num_flock_locks"
          ],
          "line": 2774
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_encode_locks_to_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/locks.c",
          "lines": "272-315",
          "snippet": "int ceph_encode_locks_to_buffer(struct inode *inode,\n\t\t\t\tstruct ceph_filelock *flocks,\n\t\t\t\tint num_fcntl_locks, int num_flock_locks)\n{\n\tstruct file_lock *lock;\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tint err = 0;\n\tint seen_fcntl = 0;\n\tint seen_flock = 0;\n\tint l = 0;\n\n\tdout(\"encoding %d flock and %d fcntl locks\", num_flock_locks,\n\t     num_fcntl_locks);\n\n\tif (!ctx)\n\t\treturn 0;\n\n\tspin_lock(&ctx->flc_lock);\n\tlist_for_each_entry(lock, &ctx->flc_flock, fl_list) {\n\t\t++seen_fcntl;\n\t\tif (seen_fcntl > num_fcntl_locks) {\n\t\t\terr = -ENOSPC;\n\t\t\tgoto fail;\n\t\t}\n\t\terr = lock_to_ceph_filelock(lock, &flocks[l]);\n\t\tif (err)\n\t\t\tgoto fail;\n\t\t++l;\n\t}\n\tlist_for_each_entry(lock, &ctx->flc_flock, fl_list) {\n\t\t++seen_flock;\n\t\tif (seen_flock > num_flock_locks) {\n\t\t\terr = -ENOSPC;\n\t\t\tgoto fail;\n\t\t}\n\t\terr = lock_to_ceph_filelock(lock, &flocks[l]);\n\t\tif (err)\n\t\t\tgoto fail;\n\t\t++l;\n\t}\nfail:\n\tspin_unlock(&ctx->flc_lock);\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/pagelist.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/namei.h>",
            "#include <linux/file.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/pagelist.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_encode_locks_to_buffer(struct inode *inode,\n\t\t\t\tstruct ceph_filelock *flocks,\n\t\t\t\tint num_fcntl_locks, int num_flock_locks)\n{\n\tstruct file_lock *lock;\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\tint err = 0;\n\tint seen_fcntl = 0;\n\tint seen_flock = 0;\n\tint l = 0;\n\n\tdout(\"encoding %d flock and %d fcntl locks\", num_flock_locks,\n\t     num_fcntl_locks);\n\n\tif (!ctx)\n\t\treturn 0;\n\n\tspin_lock(&ctx->flc_lock);\n\tlist_for_each_entry(lock, &ctx->flc_flock, fl_list) {\n\t\t++seen_fcntl;\n\t\tif (seen_fcntl > num_fcntl_locks) {\n\t\t\terr = -ENOSPC;\n\t\t\tgoto fail;\n\t\t}\n\t\terr = lock_to_ceph_filelock(lock, &flocks[l]);\n\t\tif (err)\n\t\t\tgoto fail;\n\t\t++l;\n\t}\n\tlist_for_each_entry(lock, &ctx->flc_flock, fl_list) {\n\t\t++seen_flock;\n\t\tif (seen_flock > num_flock_locks) {\n\t\t\terr = -ENOSPC;\n\t\t\tgoto fail;\n\t\t}\n\t\terr = lock_to_ceph_filelock(lock, &flocks[l]);\n\t\tif (err)\n\t\t\tgoto fail;\n\t\t++l;\n\t}\nfail:\n\tspin_unlock(&ctx->flc_lock);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "(num_fcntl_locks+num_flock_locks) *\n\t\t\t\t sizeof(struct ceph_filelock)",
            "GFP_NOFS"
          ],
          "line": 2768
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_count_locks",
          "args": [
            "inode",
            "&num_fcntl_locks",
            "&num_flock_locks"
          ],
          "line": 2767
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_count_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/locks.c",
          "lines": "246-265",
          "snippet": "void ceph_count_locks(struct inode *inode, int *fcntl_count, int *flock_count)\n{\n\tstruct file_lock *lock;\n\tstruct file_lock_context *ctx;\n\n\t*fcntl_count = 0;\n\t*flock_count = 0;\n\n\tctx = inode->i_flctx;\n\tif (ctx) {\n\t\tspin_lock(&ctx->flc_lock);\n\t\tlist_for_each_entry(lock, &ctx->flc_posix, fl_list)\n\t\t\t++(*fcntl_count);\n\t\tlist_for_each_entry(lock, &ctx->flc_flock, fl_list)\n\t\t\t++(*flock_count);\n\t\tspin_unlock(&ctx->flc_lock);\n\t}\n\tdout(\"counted %d flock locks and %d fcntl locks\",\n\t     *flock_count, *fcntl_count);\n}",
          "includes": [
            "#include <linux/ceph/pagelist.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/namei.h>",
            "#include <linux/file.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/pagelist.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_count_locks(struct inode *inode, int *fcntl_count, int *flock_count)\n{\n\tstruct file_lock *lock;\n\tstruct file_lock_context *ctx;\n\n\t*fcntl_count = 0;\n\t*flock_count = 0;\n\n\tctx = inode->i_flctx;\n\tif (ctx) {\n\t\tspin_lock(&ctx->flc_lock);\n\t\tlist_for_each_entry(lock, &ctx->flc_posix, fl_list)\n\t\t\t++(*fcntl_count);\n\t\tlist_for_each_entry(lock, &ctx->flc_flock, fl_list)\n\t\t\t++(*flock_count);\n\t\tspin_unlock(&ctx->flc_lock);\n\t}\n\tdout(\"counted %d flock locks and %d fcntl locks\",\n\t     *flock_count, *fcntl_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 2760
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "pathbase"
          ],
          "line": 2757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "ci->i_snap_realm->ino"
          ],
          "line": 2756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_encode_timespec",
          "args": [
            "&rec.v1.atime",
            "&inode->i_atime"
          ],
          "line": 2755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_encode_timespec",
          "args": [
            "&rec.v1.mtime",
            "&inode->i_mtime"
          ],
          "line": 2754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "inode->i_size"
          ],
          "line": 2753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "cap->issued"
          ],
          "line": 2752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "__ceph_caps_wanted(ci)"
          ],
          "line": 2751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ceph_caps_wanted",
          "args": [
            "ci"
          ],
          "line": 2751
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_caps_wanted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "566-572",
          "snippet": "static inline int __ceph_caps_wanted(struct ceph_inode_info *ci)\n{\n\tint w = __ceph_caps_file_wanted(ci) | __ceph_caps_used(ci);\n\tif (w & CEPH_CAP_FILE_BUFFER)\n\t\tw |= CEPH_CAP_FILE_EXCL;  /* we want EXCL if dirty data */\n\treturn w;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline int __ceph_caps_wanted(struct ceph_inode_info *ci)\n{\n\tint w = __ceph_caps_file_wanted(ci) | __ceph_caps_used(ci);\n\tif (w & CEPH_CAP_FILE_BUFFER)\n\t\tw |= CEPH_CAP_FILE_EXCL;  /* we want EXCL if dirty data */\n\treturn w;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "cap->cap_id"
          ],
          "line": 2750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "pathbase"
          ],
          "line": 2746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "ci->i_snap_realm->ino"
          ],
          "line": 2745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "cap->issued"
          ],
          "line": 2744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "__ceph_caps_wanted(ci)"
          ],
          "line": 2743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "cap->cap_id"
          ],
          "line": 2742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 2735
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_pagelist_encode_string",
          "args": [
            "pagelist",
            "path",
            "pathlen"
          ],
          "line": 2731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "path"
          ],
          "line": 2724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "path"
          ],
          "line": 2723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_build_path",
          "args": [
            "dentry",
            "&pathlen",
            "&pathbase",
            "0"
          ],
          "line": 2722
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_build_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1699-1778",
          "snippet": "char *ceph_mdsc_build_path(struct dentry *dentry, int *plen, u64 *base,\n\t\t\t   int stop_on_nosnap)\n{\n\tstruct dentry *temp;\n\tchar *path;\n\tint len, pos;\n\tunsigned seq;\n\n\tif (dentry == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\nretry:\n\tlen = 0;\n\tseq = read_seqbegin(&rename_lock);\n\trcu_read_lock();\n\tfor (temp = dentry; !IS_ROOT(temp);) {\n\t\tstruct inode *inode = temp->d_inode;\n\t\tif (inode && ceph_snap(inode) == CEPH_SNAPDIR)\n\t\t\tlen++;  /* slash only */\n\t\telse if (stop_on_nosnap && inode &&\n\t\t\t ceph_snap(inode) == CEPH_NOSNAP)\n\t\t\tbreak;\n\t\telse\n\t\t\tlen += 1 + temp->d_name.len;\n\t\ttemp = temp->d_parent;\n\t}\n\trcu_read_unlock();\n\tif (len)\n\t\tlen--;  /* no leading '/' */\n\n\tpath = kmalloc(len+1, GFP_NOFS);\n\tif (path == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tpos = len;\n\tpath[pos] = 0;\t/* trailing null */\n\trcu_read_lock();\n\tfor (temp = dentry; !IS_ROOT(temp) && pos != 0; ) {\n\t\tstruct inode *inode;\n\n\t\tspin_lock(&temp->d_lock);\n\t\tinode = temp->d_inode;\n\t\tif (inode && ceph_snap(inode) == CEPH_SNAPDIR) {\n\t\t\tdout(\"build_path path+%d: %p SNAPDIR\\n\",\n\t\t\t     pos, temp);\n\t\t} else if (stop_on_nosnap && inode &&\n\t\t\t   ceph_snap(inode) == CEPH_NOSNAP) {\n\t\t\tspin_unlock(&temp->d_lock);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tpos -= temp->d_name.len;\n\t\t\tif (pos < 0) {\n\t\t\t\tspin_unlock(&temp->d_lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrncpy(path + pos, temp->d_name.name,\n\t\t\t\ttemp->d_name.len);\n\t\t}\n\t\tspin_unlock(&temp->d_lock);\n\t\tif (pos)\n\t\t\tpath[--pos] = '/';\n\t\ttemp = temp->d_parent;\n\t}\n\trcu_read_unlock();\n\tif (pos != 0 || read_seqretry(&rename_lock, seq)) {\n\t\tpr_err(\"build_path did not end path lookup where \"\n\t\t       \"expected, namelen is %d, pos is %d\\n\", len, pos);\n\t\t/* presumably this is only possible if racing with a\n\t\t   rename of one of the parent directories (we can not\n\t\t   lock the dentries above us to prevent this, but\n\t\t   retrying should be harmless) */\n\t\tkfree(path);\n\t\tgoto retry;\n\t}\n\n\t*base = ceph_ino(temp->d_inode);\n\t*plen = len;\n\tdout(\"build_path on %p %d built %llx '%.*s'\\n\",\n\t     dentry, d_count(dentry), *base, len, path);\n\treturn path;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nchar *ceph_mdsc_build_path(struct dentry *dentry, int *plen, u64 *base,\n\t\t\t   int stop_on_nosnap)\n{\n\tstruct dentry *temp;\n\tchar *path;\n\tint len, pos;\n\tunsigned seq;\n\n\tif (dentry == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\nretry:\n\tlen = 0;\n\tseq = read_seqbegin(&rename_lock);\n\trcu_read_lock();\n\tfor (temp = dentry; !IS_ROOT(temp);) {\n\t\tstruct inode *inode = temp->d_inode;\n\t\tif (inode && ceph_snap(inode) == CEPH_SNAPDIR)\n\t\t\tlen++;  /* slash only */\n\t\telse if (stop_on_nosnap && inode &&\n\t\t\t ceph_snap(inode) == CEPH_NOSNAP)\n\t\t\tbreak;\n\t\telse\n\t\t\tlen += 1 + temp->d_name.len;\n\t\ttemp = temp->d_parent;\n\t}\n\trcu_read_unlock();\n\tif (len)\n\t\tlen--;  /* no leading '/' */\n\n\tpath = kmalloc(len+1, GFP_NOFS);\n\tif (path == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tpos = len;\n\tpath[pos] = 0;\t/* trailing null */\n\trcu_read_lock();\n\tfor (temp = dentry; !IS_ROOT(temp) && pos != 0; ) {\n\t\tstruct inode *inode;\n\n\t\tspin_lock(&temp->d_lock);\n\t\tinode = temp->d_inode;\n\t\tif (inode && ceph_snap(inode) == CEPH_SNAPDIR) {\n\t\t\tdout(\"build_path path+%d: %p SNAPDIR\\n\",\n\t\t\t     pos, temp);\n\t\t} else if (stop_on_nosnap && inode &&\n\t\t\t   ceph_snap(inode) == CEPH_NOSNAP) {\n\t\t\tspin_unlock(&temp->d_lock);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tpos -= temp->d_name.len;\n\t\t\tif (pos < 0) {\n\t\t\t\tspin_unlock(&temp->d_lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrncpy(path + pos, temp->d_name.name,\n\t\t\t\ttemp->d_name.len);\n\t\t}\n\t\tspin_unlock(&temp->d_lock);\n\t\tif (pos)\n\t\t\tpath[--pos] = '/';\n\t\ttemp = temp->d_parent;\n\t}\n\trcu_read_unlock();\n\tif (pos != 0 || read_seqretry(&rename_lock, seq)) {\n\t\tpr_err(\"build_path did not end path lookup where \"\n\t\t       \"expected, namelen is %d, pos is %d\\n\", len, pos);\n\t\t/* presumably this is only possible if racing with a\n\t\t   rename of one of the parent directories (we can not\n\t\t   lock the dentries above us to prevent this, but\n\t\t   retrying should be harmless) */\n\t\tkfree(path);\n\t\tgoto retry;\n\t}\n\n\t*base = ceph_ino(temp->d_inode);\n\t*plen = len;\n\tdout(\"build_path on %p %d built %llx '%.*s'\\n\",\n\t     dentry, d_count(dentry), *base, len, path);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_find_alias",
          "args": [
            "inode"
          ],
          "line": 2720
        },
        "resolved": true,
        "details": {
          "function_name": "d_find_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "865-875",
          "snippet": "struct dentry *d_find_alias(struct inode *inode)\n{\n\tstruct dentry *de = NULL;\n\n\tif (!hlist_empty(&inode->i_dentry)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tde = __d_find_alias(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\treturn de;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_find_alias(struct inode *inode)\n{\n\tstruct dentry *de = NULL;\n\n\tif (!hlist_empty(&inode->i_dentry)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tde = __d_find_alias(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\treturn de;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_pagelist_encode_64",
          "args": [
            "pagelist",
            "ceph_ino(inode)"
          ],
          "line": 2716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_ino",
          "args": [
            "inode"
          ],
          "line": 2716
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "412-415",
          "snippet": "static inline u64 ceph_ino(struct inode *inode)\n{\n\treturn ceph_inode(inode)->i_vino.ino;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline u64 ceph_ino(struct inode *inode)\n{\n\treturn ceph_inode(inode)->i_vino.ino;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" adding %p ino %llx.%llx cap %p %lld %s\\n\"",
            "inode",
            "ceph_vinop(inode)",
            "cap",
            "cap->cap_id",
            "ceph_cap_string(cap->issued)"
          ],
          "line": 2713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_cap_string",
          "args": [
            "cap->issued"
          ],
          "line": 2715
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_cap_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "71-116",
          "snippet": "const char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [
            "#define MAX_CAP_STR 20"
          ],
          "globals_used": [
            "static char cap_str[MAX_CAP_STR][40];",
            "static DEFINE_SPINLOCK(cap_str_lock);",
            "static int last_cap_str;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\n#define MAX_CAP_STR 20\n\nstatic char cap_str[MAX_CAP_STR][40];\nstatic DEFINE_SPINLOCK(cap_str_lock);\nstatic int last_cap_str;\n\nconst char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_vinop",
          "args": [
            "inode"
          ],
          "line": 2714
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int encode_caps_cb(struct inode *inode, struct ceph_cap *cap,\n\t\t\t  void *arg)\n{\n\tunion {\n\t\tstruct ceph_mds_cap_reconnect v2;\n\t\tstruct ceph_mds_cap_reconnect_v1 v1;\n\t} rec;\n\tsize_t reclen;\n\tstruct ceph_inode_info *ci;\n\tstruct ceph_reconnect_state *recon_state = arg;\n\tstruct ceph_pagelist *pagelist = recon_state->pagelist;\n\tchar *path;\n\tint pathlen, err;\n\tu64 pathbase;\n\tstruct dentry *dentry;\n\n\tci = cap->ci;\n\n\tdout(\" adding %p ino %llx.%llx cap %p %lld %s\\n\",\n\t     inode, ceph_vinop(inode), cap, cap->cap_id,\n\t     ceph_cap_string(cap->issued));\n\terr = ceph_pagelist_encode_64(pagelist, ceph_ino(inode));\n\tif (err)\n\t\treturn err;\n\n\tdentry = d_find_alias(inode);\n\tif (dentry) {\n\t\tpath = ceph_mdsc_build_path(dentry, &pathlen, &pathbase, 0);\n\t\tif (IS_ERR(path)) {\n\t\t\terr = PTR_ERR(path);\n\t\t\tgoto out_dput;\n\t\t}\n\t} else {\n\t\tpath = NULL;\n\t\tpathlen = 0;\n\t}\n\terr = ceph_pagelist_encode_string(pagelist, path, pathlen);\n\tif (err)\n\t\tgoto out_free;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tcap->seq = 0;        /* reset cap seq */\n\tcap->issue_seq = 0;  /* and issue_seq */\n\tcap->mseq = 0;       /* and migrate_seq */\n\tcap->cap_gen = cap->session->s_cap_gen;\n\n\tif (recon_state->flock) {\n\t\trec.v2.cap_id = cpu_to_le64(cap->cap_id);\n\t\trec.v2.wanted = cpu_to_le32(__ceph_caps_wanted(ci));\n\t\trec.v2.issued = cpu_to_le32(cap->issued);\n\t\trec.v2.snaprealm = cpu_to_le64(ci->i_snap_realm->ino);\n\t\trec.v2.pathbase = cpu_to_le64(pathbase);\n\t\trec.v2.flock_len = 0;\n\t\treclen = sizeof(rec.v2);\n\t} else {\n\t\trec.v1.cap_id = cpu_to_le64(cap->cap_id);\n\t\trec.v1.wanted = cpu_to_le32(__ceph_caps_wanted(ci));\n\t\trec.v1.issued = cpu_to_le32(cap->issued);\n\t\trec.v1.size = cpu_to_le64(inode->i_size);\n\t\tceph_encode_timespec(&rec.v1.mtime, &inode->i_mtime);\n\t\tceph_encode_timespec(&rec.v1.atime, &inode->i_atime);\n\t\trec.v1.snaprealm = cpu_to_le64(ci->i_snap_realm->ino);\n\t\trec.v1.pathbase = cpu_to_le64(pathbase);\n\t\treclen = sizeof(rec.v1);\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (recon_state->flock) {\n\t\tint num_fcntl_locks, num_flock_locks;\n\t\tstruct ceph_filelock *flocks;\n\nencode_again:\n\t\tceph_count_locks(inode, &num_fcntl_locks, &num_flock_locks);\n\t\tflocks = kmalloc((num_fcntl_locks+num_flock_locks) *\n\t\t\t\t sizeof(struct ceph_filelock), GFP_NOFS);\n\t\tif (!flocks) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_free;\n\t\t}\n\t\terr = ceph_encode_locks_to_buffer(inode, flocks,\n\t\t\t\t\t\t  num_fcntl_locks,\n\t\t\t\t\t\t  num_flock_locks);\n\t\tif (err) {\n\t\t\tkfree(flocks);\n\t\t\tif (err == -ENOSPC)\n\t\t\t\tgoto encode_again;\n\t\t\tgoto out_free;\n\t\t}\n\t\t/*\n\t\t * number of encoded locks is stable, so copy to pagelist\n\t\t */\n\t\trec.v2.flock_len = cpu_to_le32(2*sizeof(u32) +\n\t\t\t\t    (num_fcntl_locks+num_flock_locks) *\n\t\t\t\t    sizeof(struct ceph_filelock));\n\t\terr = ceph_pagelist_append(pagelist, &rec, reclen);\n\t\tif (!err)\n\t\t\terr = ceph_locks_to_pagelist(flocks, pagelist,\n\t\t\t\t\t\t     num_fcntl_locks,\n\t\t\t\t\t\t     num_flock_locks);\n\t\tkfree(flocks);\n\t} else {\n\t\terr = ceph_pagelist_append(pagelist, &rec, reclen);\n\t}\n\n\trecon_state->nr_caps++;\nout_free:\n\tkfree(path);\nout_dput:\n\tdput(dentry);\n\treturn err;\n}"
  },
  {
    "function_name": "replay_unsafe_requests",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "2650-2690",
    "snippet": "static void replay_unsafe_requests(struct ceph_mds_client *mdsc,\n\t\t\t\t   struct ceph_mds_session *session)\n{\n\tstruct ceph_mds_request *req, *nreq;\n\tstruct rb_node *p;\n\tint err;\n\n\tdout(\"replay_unsafe_requests mds%d\\n\", session->s_mds);\n\n\tmutex_lock(&mdsc->mutex);\n\tlist_for_each_entry_safe(req, nreq, &session->s_unsafe, r_unsafe_item) {\n\t\terr = __prepare_send_request(mdsc, req, session->s_mds);\n\t\tif (!err) {\n\t\t\tceph_msg_get(req->r_request);\n\t\t\tceph_con_send(&session->s_con, req->r_request);\n\t\t}\n\t}\n\n\t/*\n\t * also re-send old requests when MDS enters reconnect stage. So that MDS\n\t * can process completed request in clientreplay stage.\n\t */\n\tp = rb_first(&mdsc->request_tree);\n\twhile (p) {\n\t\treq = rb_entry(p, struct ceph_mds_request, r_node);\n\t\tp = rb_next(p);\n\t\tif (req->r_got_unsafe)\n\t\t\tcontinue;\n\t\tif (req->r_attempts == 0)\n\t\t\tcontinue; /* only old requests */\n\t\tif (req->r_session &&\n\t\t    req->r_session->s_mds == session->s_mds) {\n\t\t\terr = __prepare_send_request(mdsc, req, session->s_mds);\n\t\t\tif (!err) {\n\t\t\t\tceph_msg_get(req->r_request);\n\t\t\t\tceph_con_send(&session->s_con, req->r_request);\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&mdsc->mutex);\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 2689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_con_send",
          "args": [
            "&session->s_con",
            "req->r_request"
          ],
          "line": 2685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_msg_get",
          "args": [
            "req->r_request"
          ],
          "line": 2684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__prepare_send_request",
          "args": [
            "mdsc",
            "req",
            "session->s_mds"
          ],
          "line": 2682
        },
        "resolved": true,
        "details": {
          "function_name": "__prepare_send_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1990-2072",
          "snippet": "static int __prepare_send_request(struct ceph_mds_client *mdsc,\n\t\t\t\t  struct ceph_mds_request *req,\n\t\t\t\t  int mds)\n{\n\tstruct ceph_mds_request_head *rhead;\n\tstruct ceph_msg *msg;\n\tint flags = 0;\n\n\treq->r_attempts++;\n\tif (req->r_inode) {\n\t\tstruct ceph_cap *cap =\n\t\t\tceph_get_cap_for_mds(ceph_inode(req->r_inode), mds);\n\n\t\tif (cap)\n\t\t\treq->r_sent_on_mseq = cap->mseq;\n\t\telse\n\t\t\treq->r_sent_on_mseq = -1;\n\t}\n\tdout(\"prepare_send_request %p tid %lld %s (attempt %d)\\n\", req,\n\t     req->r_tid, ceph_mds_op_name(req->r_op), req->r_attempts);\n\n\tif (req->r_got_unsafe) {\n\t\tvoid *p;\n\t\t/*\n\t\t * Replay.  Do not regenerate message (and rebuild\n\t\t * paths, etc.); just use the original message.\n\t\t * Rebuilding paths will break for renames because\n\t\t * d_move mangles the src name.\n\t\t */\n\t\tmsg = req->r_request;\n\t\trhead = msg->front.iov_base;\n\n\t\tflags = le32_to_cpu(rhead->flags);\n\t\tflags |= CEPH_MDS_FLAG_REPLAY;\n\t\trhead->flags = cpu_to_le32(flags);\n\n\t\tif (req->r_target_inode)\n\t\t\trhead->ino = cpu_to_le64(ceph_ino(req->r_target_inode));\n\n\t\trhead->num_retry = req->r_attempts - 1;\n\n\t\t/* remove cap/dentry releases from message */\n\t\trhead->num_releases = 0;\n\n\t\t/* time stamp */\n\t\tp = msg->front.iov_base + req->r_request_release_offset;\n\t\t{\n\t\t\tstruct ceph_timespec ts;\n\t\t\tceph_encode_timespec(&ts, &req->r_stamp);\n\t\t\tceph_encode_copy(&p, &ts, sizeof(ts));\n\t\t}\n\n\t\tmsg->front.iov_len = p - msg->front.iov_base;\n\t\tmsg->hdr.front_len = cpu_to_le32(msg->front.iov_len);\n\t\treturn 0;\n\t}\n\n\tif (req->r_request) {\n\t\tceph_msg_put(req->r_request);\n\t\treq->r_request = NULL;\n\t}\n\tmsg = create_request_message(mdsc, req, mds);\n\tif (IS_ERR(msg)) {\n\t\treq->r_err = PTR_ERR(msg);\n\t\tcomplete_request(mdsc, req);\n\t\treturn PTR_ERR(msg);\n\t}\n\treq->r_request = msg;\n\n\trhead = msg->front.iov_base;\n\trhead->oldest_client_tid = cpu_to_le64(__get_oldest_tid(mdsc));\n\tif (req->r_got_unsafe)\n\t\tflags |= CEPH_MDS_FLAG_REPLAY;\n\tif (req->r_locked_dir)\n\t\tflags |= CEPH_MDS_FLAG_WANT_DENTRY;\n\trhead->flags = cpu_to_le32(flags);\n\trhead->num_fwd = req->r_num_fwd;\n\trhead->num_retry = req->r_attempts - 1;\n\trhead->ino = 0;\n\n\tdout(\" r_locked_dir = %p\\n\", req->r_locked_dir);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __prepare_send_request(struct ceph_mds_client *mdsc,\n\t\t\t\t  struct ceph_mds_request *req,\n\t\t\t\t  int mds)\n{\n\tstruct ceph_mds_request_head *rhead;\n\tstruct ceph_msg *msg;\n\tint flags = 0;\n\n\treq->r_attempts++;\n\tif (req->r_inode) {\n\t\tstruct ceph_cap *cap =\n\t\t\tceph_get_cap_for_mds(ceph_inode(req->r_inode), mds);\n\n\t\tif (cap)\n\t\t\treq->r_sent_on_mseq = cap->mseq;\n\t\telse\n\t\t\treq->r_sent_on_mseq = -1;\n\t}\n\tdout(\"prepare_send_request %p tid %lld %s (attempt %d)\\n\", req,\n\t     req->r_tid, ceph_mds_op_name(req->r_op), req->r_attempts);\n\n\tif (req->r_got_unsafe) {\n\t\tvoid *p;\n\t\t/*\n\t\t * Replay.  Do not regenerate message (and rebuild\n\t\t * paths, etc.); just use the original message.\n\t\t * Rebuilding paths will break for renames because\n\t\t * d_move mangles the src name.\n\t\t */\n\t\tmsg = req->r_request;\n\t\trhead = msg->front.iov_base;\n\n\t\tflags = le32_to_cpu(rhead->flags);\n\t\tflags |= CEPH_MDS_FLAG_REPLAY;\n\t\trhead->flags = cpu_to_le32(flags);\n\n\t\tif (req->r_target_inode)\n\t\t\trhead->ino = cpu_to_le64(ceph_ino(req->r_target_inode));\n\n\t\trhead->num_retry = req->r_attempts - 1;\n\n\t\t/* remove cap/dentry releases from message */\n\t\trhead->num_releases = 0;\n\n\t\t/* time stamp */\n\t\tp = msg->front.iov_base + req->r_request_release_offset;\n\t\t{\n\t\t\tstruct ceph_timespec ts;\n\t\t\tceph_encode_timespec(&ts, &req->r_stamp);\n\t\t\tceph_encode_copy(&p, &ts, sizeof(ts));\n\t\t}\n\n\t\tmsg->front.iov_len = p - msg->front.iov_base;\n\t\tmsg->hdr.front_len = cpu_to_le32(msg->front.iov_len);\n\t\treturn 0;\n\t}\n\n\tif (req->r_request) {\n\t\tceph_msg_put(req->r_request);\n\t\treq->r_request = NULL;\n\t}\n\tmsg = create_request_message(mdsc, req, mds);\n\tif (IS_ERR(msg)) {\n\t\treq->r_err = PTR_ERR(msg);\n\t\tcomplete_request(mdsc, req);\n\t\treturn PTR_ERR(msg);\n\t}\n\treq->r_request = msg;\n\n\trhead = msg->front.iov_base;\n\trhead->oldest_client_tid = cpu_to_le64(__get_oldest_tid(mdsc));\n\tif (req->r_got_unsafe)\n\t\tflags |= CEPH_MDS_FLAG_REPLAY;\n\tif (req->r_locked_dir)\n\t\tflags |= CEPH_MDS_FLAG_WANT_DENTRY;\n\trhead->flags = cpu_to_le32(flags);\n\trhead->num_fwd = req->r_num_fwd;\n\trhead->num_retry = req->r_attempts - 1;\n\trhead->ino = 0;\n\n\tdout(\" r_locked_dir = %p\\n\", req->r_locked_dir);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "p"
          ],
          "line": 2675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "p",
            "structceph_mds_request",
            "r_node"
          ],
          "line": 2674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&mdsc->request_tree"
          ],
          "line": 2672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_con_send",
          "args": [
            "&session->s_con",
            "req->r_request"
          ],
          "line": 2664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_msg_get",
          "args": [
            "req->r_request"
          ],
          "line": 2663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "req",
            "nreq",
            "&session->s_unsafe",
            "r_unsafe_item"
          ],
          "line": 2660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 2659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"replay_unsafe_requests mds%d\\n\"",
            "session->s_mds"
          ],
          "line": 2657
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void replay_unsafe_requests(struct ceph_mds_client *mdsc,\n\t\t\t\t   struct ceph_mds_session *session)\n{\n\tstruct ceph_mds_request *req, *nreq;\n\tstruct rb_node *p;\n\tint err;\n\n\tdout(\"replay_unsafe_requests mds%d\\n\", session->s_mds);\n\n\tmutex_lock(&mdsc->mutex);\n\tlist_for_each_entry_safe(req, nreq, &session->s_unsafe, r_unsafe_item) {\n\t\terr = __prepare_send_request(mdsc, req, session->s_mds);\n\t\tif (!err) {\n\t\t\tceph_msg_get(req->r_request);\n\t\t\tceph_con_send(&session->s_con, req->r_request);\n\t\t}\n\t}\n\n\t/*\n\t * also re-send old requests when MDS enters reconnect stage. So that MDS\n\t * can process completed request in clientreplay stage.\n\t */\n\tp = rb_first(&mdsc->request_tree);\n\twhile (p) {\n\t\treq = rb_entry(p, struct ceph_mds_request, r_node);\n\t\tp = rb_next(p);\n\t\tif (req->r_got_unsafe)\n\t\t\tcontinue;\n\t\tif (req->r_attempts == 0)\n\t\t\tcontinue; /* only old requests */\n\t\tif (req->r_session &&\n\t\t    req->r_session->s_mds == session->s_mds) {\n\t\t\terr = __prepare_send_request(mdsc, req, session->s_mds);\n\t\t\tif (!err) {\n\t\t\t\tceph_msg_get(req->r_request);\n\t\t\t\tceph_con_send(&session->s_con, req->r_request);\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&mdsc->mutex);\n}"
  },
  {
    "function_name": "handle_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "2540-2644",
    "snippet": "static void handle_session(struct ceph_mds_session *session,\n\t\t\t   struct ceph_msg *msg)\n{\n\tstruct ceph_mds_client *mdsc = session->s_mdsc;\n\tu32 op;\n\tu64 seq;\n\tint mds = session->s_mds;\n\tstruct ceph_mds_session_head *h = msg->front.iov_base;\n\tint wake = 0;\n\n\t/* decode */\n\tif (msg->front.iov_len != sizeof(*h))\n\t\tgoto bad;\n\top = le32_to_cpu(h->op);\n\tseq = le64_to_cpu(h->seq);\n\n\tmutex_lock(&mdsc->mutex);\n\tif (op == CEPH_SESSION_CLOSE)\n\t\t__unregister_session(mdsc, session);\n\t/* FIXME: this ttl calculation is generous */\n\tsession->s_ttl = jiffies + HZ*mdsc->mdsmap->m_session_autoclose;\n\tmutex_unlock(&mdsc->mutex);\n\n\tmutex_lock(&session->s_mutex);\n\n\tdout(\"handle_session mds%d %s %p state %s seq %llu\\n\",\n\t     mds, ceph_session_op_name(op), session,\n\t     ceph_session_state_name(session->s_state), seq);\n\n\tif (session->s_state == CEPH_MDS_SESSION_HUNG) {\n\t\tsession->s_state = CEPH_MDS_SESSION_OPEN;\n\t\tpr_info(\"mds%d came back\\n\", session->s_mds);\n\t}\n\n\tswitch (op) {\n\tcase CEPH_SESSION_OPEN:\n\t\tif (session->s_state == CEPH_MDS_SESSION_RECONNECTING)\n\t\t\tpr_info(\"mds%d reconnect success\\n\", session->s_mds);\n\t\tsession->s_state = CEPH_MDS_SESSION_OPEN;\n\t\trenewed_caps(mdsc, session, 0);\n\t\twake = 1;\n\t\tif (mdsc->stopping)\n\t\t\t__close_session(mdsc, session);\n\t\tbreak;\n\n\tcase CEPH_SESSION_RENEWCAPS:\n\t\tif (session->s_renew_seq == seq)\n\t\t\trenewed_caps(mdsc, session, 1);\n\t\tbreak;\n\n\tcase CEPH_SESSION_CLOSE:\n\t\tif (session->s_state == CEPH_MDS_SESSION_RECONNECTING)\n\t\t\tpr_info(\"mds%d reconnect denied\\n\", session->s_mds);\n\t\tremove_session_caps(session);\n\t\twake = 2; /* for good measure */\n\t\twake_up_all(&mdsc->session_close_wq);\n\t\tbreak;\n\n\tcase CEPH_SESSION_STALE:\n\t\tpr_info(\"mds%d caps went stale, renewing\\n\",\n\t\t\tsession->s_mds);\n\t\tspin_lock(&session->s_gen_ttl_lock);\n\t\tsession->s_cap_gen++;\n\t\tsession->s_cap_ttl = jiffies - 1;\n\t\tspin_unlock(&session->s_gen_ttl_lock);\n\t\tsend_renew_caps(mdsc, session);\n\t\tbreak;\n\n\tcase CEPH_SESSION_RECALL_STATE:\n\t\ttrim_caps(mdsc, session, le32_to_cpu(h->max_caps));\n\t\tbreak;\n\n\tcase CEPH_SESSION_FLUSHMSG:\n\t\tsend_flushmsg_ack(mdsc, session, seq);\n\t\tbreak;\n\n\tcase CEPH_SESSION_FORCE_RO:\n\t\tdout(\"force_session_readonly %p\\n\", session);\n\t\tspin_lock(&session->s_cap_lock);\n\t\tsession->s_readonly = true;\n\t\tspin_unlock(&session->s_cap_lock);\n\t\twake_up_session_caps(session, 0);\n\t\tbreak;\n\n\tdefault:\n\t\tpr_err(\"mdsc_handle_session bad op %d mds%d\\n\", op, mds);\n\t\tWARN_ON(1);\n\t}\n\n\tmutex_unlock(&session->s_mutex);\n\tif (wake) {\n\t\tmutex_lock(&mdsc->mutex);\n\t\t__wake_requests(mdsc, &session->s_waiting);\n\t\tif (wake == 2)\n\t\t\tkick_requests(mdsc, mds);\n\t\tmutex_unlock(&mdsc->mutex);\n\t}\n\treturn;\n\nbad:\n\tpr_err(\"mdsc_handle_session corrupt message mds%d len %d\\n\", mds,\n\t       (int)msg->front.iov_len);\n\tceph_msg_dump(msg);\n\treturn;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_msg_dump",
          "args": [
            "msg"
          ],
          "line": 2642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"mdsc_handle_session corrupt message mds%d len %d\\n\"",
            "mds",
            "(int)msg->front.iov_len"
          ],
          "line": 2640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 2635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kick_requests",
          "args": [
            "mdsc",
            "mds"
          ],
          "line": 2634
        },
        "resolved": true,
        "details": {
          "function_name": "kick_requests",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "2176-2196",
          "snippet": "static void kick_requests(struct ceph_mds_client *mdsc, int mds)\n{\n\tstruct ceph_mds_request *req;\n\tstruct rb_node *p = rb_first(&mdsc->request_tree);\n\n\tdout(\"kick_requests mds%d\\n\", mds);\n\twhile (p) {\n\t\treq = rb_entry(p, struct ceph_mds_request, r_node);\n\t\tp = rb_next(p);\n\t\tif (req->r_got_unsafe)\n\t\t\tcontinue;\n\t\tif (req->r_attempts > 0)\n\t\t\tcontinue; /* only new requests */\n\t\tif (req->r_session &&\n\t\t    req->r_session->s_mds == mds) {\n\t\t\tdout(\" kicking tid %llu\\n\", req->r_tid);\n\t\t\tlist_del_init(&req->r_wait);\n\t\t\t__do_request(mdsc, req);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void kick_requests(struct ceph_mds_client *mdsc, int mds)\n{\n\tstruct ceph_mds_request *req;\n\tstruct rb_node *p = rb_first(&mdsc->request_tree);\n\n\tdout(\"kick_requests mds%d\\n\", mds);\n\twhile (p) {\n\t\treq = rb_entry(p, struct ceph_mds_request, r_node);\n\t\tp = rb_next(p);\n\t\tif (req->r_got_unsafe)\n\t\t\tcontinue;\n\t\tif (req->r_attempts > 0)\n\t\t\tcontinue; /* only new requests */\n\t\tif (req->r_session &&\n\t\t    req->r_session->s_mds == mds) {\n\t\t\tdout(\" kicking tid %llu\\n\", req->r_tid);\n\t\t\tlist_del_init(&req->r_wait);\n\t\t\t__do_request(mdsc, req);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__wake_requests",
          "args": [
            "mdsc",
            "&session->s_waiting"
          ],
          "line": 2632
        },
        "resolved": true,
        "details": {
          "function_name": "__wake_requests",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "2155-2170",
          "snippet": "static void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head)\n{\n\tstruct ceph_mds_request *req;\n\tLIST_HEAD(tmp_list);\n\n\tlist_splice_init(head, &tmp_list);\n\n\twhile (!list_empty(&tmp_list)) {\n\t\treq = list_entry(tmp_list.next,\n\t\t\t\t struct ceph_mds_request, r_wait);\n\t\tlist_del_init(&req->r_wait);\n\t\tdout(\" wake request %p tid %llu\\n\", req, req->r_tid);\n\t\t__do_request(mdsc, req);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);\n\nstatic void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head)\n{\n\tstruct ceph_mds_request *req;\n\tLIST_HEAD(tmp_list);\n\n\tlist_splice_init(head, &tmp_list);\n\n\twhile (!list_empty(&tmp_list)) {\n\t\treq = list_entry(tmp_list.next,\n\t\t\t\t struct ceph_mds_request, r_wait);\n\t\tlist_del_init(&req->r_wait);\n\t\tdout(\" wake request %p tid %llu\\n\", req, req->r_tid);\n\t\t__do_request(mdsc, req);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 2631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&session->s_mutex"
          ],
          "line": 2629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 2626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"mdsc_handle_session bad op %d mds%d\\n\"",
            "op",
            "mds"
          ],
          "line": 2625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_session_caps",
          "args": [
            "session",
            "0"
          ],
          "line": 2621
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_session_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1202-1208",
          "snippet": "static void wake_up_session_caps(struct ceph_mds_session *session,\n\t\t\t\t int reconnect)\n{\n\tdout(\"wake_up_session_caps %p mds%d\\n\", session, session->s_mds);\n\titerate_session_caps(session, wake_up_session_cb,\n\t\t\t     (void *)(unsigned long)reconnect);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void wake_up_session_caps(struct ceph_mds_session *session,\n\t\t\t\t int reconnect)\n{\n\tdout(\"wake_up_session_caps %p mds%d\\n\", session, session->s_mds);\n\titerate_session_caps(session, wake_up_session_cb,\n\t\t\t     (void *)(unsigned long)reconnect);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&session->s_cap_lock"
          ],
          "line": 2620
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&session->s_cap_lock"
          ],
          "line": 2618
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"force_session_readonly %p\\n\"",
            "session"
          ],
          "line": 2617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_flushmsg_ack",
          "args": [
            "mdsc",
            "session",
            "seq"
          ],
          "line": 2613
        },
        "resolved": true,
        "details": {
          "function_name": "send_flushmsg_ack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1246-1258",
          "snippet": "static int send_flushmsg_ack(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_mds_session *session, u64 seq)\n{\n\tstruct ceph_msg *msg;\n\n\tdout(\"send_flushmsg_ack to mds%d (%s)s seq %lld\\n\",\n\t     session->s_mds, ceph_session_state_name(session->s_state), seq);\n\tmsg = create_session_msg(CEPH_SESSION_FLUSHMSG_ACK, seq);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\tceph_con_send(&session->s_con, msg);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int send_flushmsg_ack(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_mds_session *session, u64 seq)\n{\n\tstruct ceph_msg *msg;\n\n\tdout(\"send_flushmsg_ack to mds%d (%s)s seq %lld\\n\",\n\t     session->s_mds, ceph_session_state_name(session->s_state), seq);\n\tmsg = create_session_msg(CEPH_SESSION_FLUSHMSG_ACK, seq);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\tceph_con_send(&session->s_con, msg);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trim_caps",
          "args": [
            "mdsc",
            "session",
            "le32_to_cpu(h->max_caps)"
          ],
          "line": 2609
        },
        "resolved": true,
        "details": {
          "function_name": "trim_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1383-1403",
          "snippet": "static int trim_caps(struct ceph_mds_client *mdsc,\n\t\t     struct ceph_mds_session *session,\n\t\t     int max_caps)\n{\n\tint trim_caps = session->s_nr_caps - max_caps;\n\n\tdout(\"trim_caps mds%d start: %d / %d, trim %d\\n\",\n\t     session->s_mds, session->s_nr_caps, max_caps, trim_caps);\n\tif (trim_caps > 0) {\n\t\tsession->s_trim_caps = trim_caps;\n\t\titerate_session_caps(session, trim_caps_cb, session);\n\t\tdout(\"trim_caps mds%d done: %d / %d, trimmed %d\\n\",\n\t\t     session->s_mds, session->s_nr_caps, max_caps,\n\t\t\ttrim_caps - session->s_trim_caps);\n\t\tsession->s_trim_caps = 0;\n\t}\n\n\tceph_add_cap_releases(mdsc, session);\n\tceph_send_cap_releases(mdsc, session);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int trim_caps(struct ceph_mds_client *mdsc,\n\t\t     struct ceph_mds_session *session,\n\t\t     int max_caps)\n{\n\tint trim_caps = session->s_nr_caps - max_caps;\n\n\tdout(\"trim_caps mds%d start: %d / %d, trim %d\\n\",\n\t     session->s_mds, session->s_nr_caps, max_caps, trim_caps);\n\tif (trim_caps > 0) {\n\t\tsession->s_trim_caps = trim_caps;\n\t\titerate_session_caps(session, trim_caps_cb, session);\n\t\tdout(\"trim_caps mds%d done: %d / %d, trimmed %d\\n\",\n\t\t     session->s_mds, session->s_nr_caps, max_caps,\n\t\t\ttrim_caps - session->s_trim_caps);\n\t\tsession->s_trim_caps = 0;\n\t}\n\n\tceph_add_cap_releases(mdsc, session);\n\tceph_send_cap_releases(mdsc, session);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "h->max_caps"
          ],
          "line": 2609
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_renew_caps",
          "args": [
            "mdsc",
            "session"
          ],
          "line": 2605
        },
        "resolved": true,
        "details": {
          "function_name": "send_renew_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1216-1244",
          "snippet": "static int send_renew_caps(struct ceph_mds_client *mdsc,\n\t\t\t   struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *msg;\n\tint state;\n\n\tif (time_after_eq(jiffies, session->s_cap_ttl) &&\n\t    time_after_eq(session->s_cap_ttl, session->s_renew_requested))\n\t\tpr_info(\"mds%d caps stale\\n\", session->s_mds);\n\tsession->s_renew_requested = jiffies;\n\n\t/* do not try to renew caps until a recovering mds has reconnected\n\t * with its clients. */\n\tstate = ceph_mdsmap_get_state(mdsc->mdsmap, session->s_mds);\n\tif (state < CEPH_MDS_STATE_RECONNECT) {\n\t\tdout(\"send_renew_caps ignoring mds%d (%s)\\n\",\n\t\t     session->s_mds, ceph_mds_state_name(state));\n\t\treturn 0;\n\t}\n\n\tdout(\"send_renew_caps to mds%d (%s)\\n\", session->s_mds,\n\t\tceph_mds_state_name(state));\n\tmsg = create_session_msg(CEPH_SESSION_REQUEST_RENEWCAPS,\n\t\t\t\t ++session->s_renew_seq);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\tceph_con_send(&session->s_con, msg);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int send_renew_caps(struct ceph_mds_client *mdsc,\n\t\t\t   struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *msg;\n\tint state;\n\n\tif (time_after_eq(jiffies, session->s_cap_ttl) &&\n\t    time_after_eq(session->s_cap_ttl, session->s_renew_requested))\n\t\tpr_info(\"mds%d caps stale\\n\", session->s_mds);\n\tsession->s_renew_requested = jiffies;\n\n\t/* do not try to renew caps until a recovering mds has reconnected\n\t * with its clients. */\n\tstate = ceph_mdsmap_get_state(mdsc->mdsmap, session->s_mds);\n\tif (state < CEPH_MDS_STATE_RECONNECT) {\n\t\tdout(\"send_renew_caps ignoring mds%d (%s)\\n\",\n\t\t     session->s_mds, ceph_mds_state_name(state));\n\t\treturn 0;\n\t}\n\n\tdout(\"send_renew_caps to mds%d (%s)\\n\", session->s_mds,\n\t\tceph_mds_state_name(state));\n\tmsg = create_session_msg(CEPH_SESSION_REQUEST_RENEWCAPS,\n\t\t\t\t ++session->s_renew_seq);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\tceph_con_send(&session->s_con, msg);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"mds%d caps went stale, renewing\\n\"",
            "session->s_mds"
          ],
          "line": 2599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&mdsc->session_close_wq"
          ],
          "line": 2595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_session_caps",
          "args": [
            "session"
          ],
          "line": 2593
        },
        "resolved": true,
        "details": {
          "function_name": "remove_session_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1141-1179",
          "snippet": "static void remove_session_caps(struct ceph_mds_session *session)\n{\n\tdout(\"remove_session_caps on %p\\n\", session);\n\titerate_session_caps(session, remove_session_caps_cb, NULL);\n\n\tspin_lock(&session->s_cap_lock);\n\tif (session->s_nr_caps > 0) {\n\t\tstruct super_block *sb = session->s_mdsc->fsc->sb;\n\t\tstruct inode *inode;\n\t\tstruct ceph_cap *cap, *prev = NULL;\n\t\tstruct ceph_vino vino;\n\t\t/*\n\t\t * iterate_session_caps() skips inodes that are being\n\t\t * deleted, we need to wait until deletions are complete.\n\t\t * __wait_on_freeing_inode() is designed for the job,\n\t\t * but it is not exported, so use lookup inode function\n\t\t * to access it.\n\t\t */\n\t\twhile (!list_empty(&session->s_caps)) {\n\t\t\tcap = list_entry(session->s_caps.next,\n\t\t\t\t\t struct ceph_cap, session_caps);\n\t\t\tif (cap == prev)\n\t\t\t\tbreak;\n\t\t\tprev = cap;\n\t\t\tvino = cap->ci->i_vino;\n\t\t\tspin_unlock(&session->s_cap_lock);\n\n\t\t\tinode = ceph_find_inode(sb, vino);\n\t\t\tiput(inode);\n\n\t\t\tspin_lock(&session->s_cap_lock);\n\t\t}\n\t}\n\tspin_unlock(&session->s_cap_lock);\n\n\tBUG_ON(session->s_nr_caps > 0);\n\tBUG_ON(!list_empty(&session->s_cap_flushing));\n\tcleanup_cap_releases(session);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void remove_session_caps(struct ceph_mds_session *session)\n{\n\tdout(\"remove_session_caps on %p\\n\", session);\n\titerate_session_caps(session, remove_session_caps_cb, NULL);\n\n\tspin_lock(&session->s_cap_lock);\n\tif (session->s_nr_caps > 0) {\n\t\tstruct super_block *sb = session->s_mdsc->fsc->sb;\n\t\tstruct inode *inode;\n\t\tstruct ceph_cap *cap, *prev = NULL;\n\t\tstruct ceph_vino vino;\n\t\t/*\n\t\t * iterate_session_caps() skips inodes that are being\n\t\t * deleted, we need to wait until deletions are complete.\n\t\t * __wait_on_freeing_inode() is designed for the job,\n\t\t * but it is not exported, so use lookup inode function\n\t\t * to access it.\n\t\t */\n\t\twhile (!list_empty(&session->s_caps)) {\n\t\t\tcap = list_entry(session->s_caps.next,\n\t\t\t\t\t struct ceph_cap, session_caps);\n\t\t\tif (cap == prev)\n\t\t\t\tbreak;\n\t\t\tprev = cap;\n\t\t\tvino = cap->ci->i_vino;\n\t\t\tspin_unlock(&session->s_cap_lock);\n\n\t\t\tinode = ceph_find_inode(sb, vino);\n\t\t\tiput(inode);\n\n\t\t\tspin_lock(&session->s_cap_lock);\n\t\t}\n\t}\n\tspin_unlock(&session->s_cap_lock);\n\n\tBUG_ON(session->s_nr_caps > 0);\n\tBUG_ON(!list_empty(&session->s_cap_flushing));\n\tcleanup_cap_releases(session);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"mds%d reconnect denied\\n\"",
            "session->s_mds"
          ],
          "line": 2592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "renewed_caps",
          "args": [
            "mdsc",
            "session",
            "1"
          ],
          "line": 2587
        },
        "resolved": true,
        "details": {
          "function_name": "renewed_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1266-1293",
          "snippet": "static void renewed_caps(struct ceph_mds_client *mdsc,\n\t\t\t struct ceph_mds_session *session, int is_renew)\n{\n\tint was_stale;\n\tint wake = 0;\n\n\tspin_lock(&session->s_cap_lock);\n\twas_stale = is_renew && time_after_eq(jiffies, session->s_cap_ttl);\n\n\tsession->s_cap_ttl = session->s_renew_requested +\n\t\tmdsc->mdsmap->m_session_timeout*HZ;\n\n\tif (was_stale) {\n\t\tif (time_before(jiffies, session->s_cap_ttl)) {\n\t\t\tpr_info(\"mds%d caps renewed\\n\", session->s_mds);\n\t\t\twake = 1;\n\t\t} else {\n\t\t\tpr_info(\"mds%d caps still stale\\n\", session->s_mds);\n\t\t}\n\t}\n\tdout(\"renewed_caps mds%d ttl now %lu, was %s, now %s\\n\",\n\t     session->s_mds, session->s_cap_ttl, was_stale ? \"stale\" : \"fresh\",\n\t     time_before(jiffies, session->s_cap_ttl) ? \"stale\" : \"fresh\");\n\tspin_unlock(&session->s_cap_lock);\n\n\tif (wake)\n\t\twake_up_session_caps(session, 0);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void renewed_caps(struct ceph_mds_client *mdsc,\n\t\t\t struct ceph_mds_session *session, int is_renew)\n{\n\tint was_stale;\n\tint wake = 0;\n\n\tspin_lock(&session->s_cap_lock);\n\twas_stale = is_renew && time_after_eq(jiffies, session->s_cap_ttl);\n\n\tsession->s_cap_ttl = session->s_renew_requested +\n\t\tmdsc->mdsmap->m_session_timeout*HZ;\n\n\tif (was_stale) {\n\t\tif (time_before(jiffies, session->s_cap_ttl)) {\n\t\t\tpr_info(\"mds%d caps renewed\\n\", session->s_mds);\n\t\t\twake = 1;\n\t\t} else {\n\t\t\tpr_info(\"mds%d caps still stale\\n\", session->s_mds);\n\t\t}\n\t}\n\tdout(\"renewed_caps mds%d ttl now %lu, was %s, now %s\\n\",\n\t     session->s_mds, session->s_cap_ttl, was_stale ? \"stale\" : \"fresh\",\n\t     time_before(jiffies, session->s_cap_ttl) ? \"stale\" : \"fresh\");\n\tspin_unlock(&session->s_cap_lock);\n\n\tif (wake)\n\t\twake_up_session_caps(session, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__close_session",
          "args": [
            "mdsc",
            "session"
          ],
          "line": 2582
        },
        "resolved": true,
        "details": {
          "function_name": "__close_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1316-1323",
          "snippet": "static int __close_session(struct ceph_mds_client *mdsc,\n\t\t\t struct ceph_mds_session *session)\n{\n\tif (session->s_state >= CEPH_MDS_SESSION_CLOSING)\n\t\treturn 0;\n\tsession->s_state = CEPH_MDS_SESSION_CLOSING;\n\treturn request_close_session(mdsc, session);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __close_session(struct ceph_mds_client *mdsc,\n\t\t\t struct ceph_mds_session *session)\n{\n\tif (session->s_state >= CEPH_MDS_SESSION_CLOSING)\n\t\treturn 0;\n\tsession->s_state = CEPH_MDS_SESSION_CLOSING;\n\treturn request_close_session(mdsc, session);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"mds%d reconnect success\\n\"",
            "session->s_mds"
          ],
          "line": 2577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"mds%d came back\\n\"",
            "session->s_mds"
          ],
          "line": 2571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"handle_session mds%d %s %p state %s seq %llu\\n\"",
            "mds",
            "ceph_session_op_name(op)",
            "session",
            "ceph_session_state_name(session->s_state)",
            "seq"
          ],
          "line": 2565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_session_state_name",
          "args": [
            "session->s_state"
          ],
          "line": 2567
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_session_state_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "348-360",
          "snippet": "const char *ceph_session_state_name(int s)\n{\n\tswitch (s) {\n\tcase CEPH_MDS_SESSION_NEW: return \"new\";\n\tcase CEPH_MDS_SESSION_OPENING: return \"opening\";\n\tcase CEPH_MDS_SESSION_OPEN: return \"open\";\n\tcase CEPH_MDS_SESSION_HUNG: return \"hung\";\n\tcase CEPH_MDS_SESSION_CLOSING: return \"closing\";\n\tcase CEPH_MDS_SESSION_RESTARTING: return \"restarting\";\n\tcase CEPH_MDS_SESSION_RECONNECTING: return \"reconnecting\";\n\tdefault: return \"???\";\n\t}\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nconst char *ceph_session_state_name(int s)\n{\n\tswitch (s) {\n\tcase CEPH_MDS_SESSION_NEW: return \"new\";\n\tcase CEPH_MDS_SESSION_OPENING: return \"opening\";\n\tcase CEPH_MDS_SESSION_OPEN: return \"open\";\n\tcase CEPH_MDS_SESSION_HUNG: return \"hung\";\n\tcase CEPH_MDS_SESSION_CLOSING: return \"closing\";\n\tcase CEPH_MDS_SESSION_RESTARTING: return \"restarting\";\n\tcase CEPH_MDS_SESSION_RECONNECTING: return \"reconnecting\";\n\tdefault: return \"???\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_session_op_name",
          "args": [
            "op"
          ],
          "line": 2566
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_session_op_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/strings.c",
          "lines": "33-48",
          "snippet": "const char *ceph_session_op_name(int op)\n{\n\tswitch (op) {\n\tcase CEPH_SESSION_REQUEST_OPEN: return \"request_open\";\n\tcase CEPH_SESSION_OPEN: return \"open\";\n\tcase CEPH_SESSION_REQUEST_CLOSE: return \"request_close\";\n\tcase CEPH_SESSION_CLOSE: return \"close\";\n\tcase CEPH_SESSION_REQUEST_RENEWCAPS: return \"request_renewcaps\";\n\tcase CEPH_SESSION_RENEWCAPS: return \"renewcaps\";\n\tcase CEPH_SESSION_STALE: return \"stale\";\n\tcase CEPH_SESSION_RECALL_STATE: return \"recall_state\";\n\tcase CEPH_SESSION_FLUSHMSG: return \"flushmsg\";\n\tcase CEPH_SESSION_FLUSHMSG_ACK: return \"flushmsg_ack\";\n\t}\n\treturn \"???\";\n}",
          "includes": [
            "#include <linux/ceph/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/types.h>\n#include <linux/module.h>\n\nconst char *ceph_session_op_name(int op)\n{\n\tswitch (op) {\n\tcase CEPH_SESSION_REQUEST_OPEN: return \"request_open\";\n\tcase CEPH_SESSION_OPEN: return \"open\";\n\tcase CEPH_SESSION_REQUEST_CLOSE: return \"request_close\";\n\tcase CEPH_SESSION_CLOSE: return \"close\";\n\tcase CEPH_SESSION_REQUEST_RENEWCAPS: return \"request_renewcaps\";\n\tcase CEPH_SESSION_RENEWCAPS: return \"renewcaps\";\n\tcase CEPH_SESSION_STALE: return \"stale\";\n\tcase CEPH_SESSION_RECALL_STATE: return \"recall_state\";\n\tcase CEPH_SESSION_FLUSHMSG: return \"flushmsg\";\n\tcase CEPH_SESSION_FLUSHMSG_ACK: return \"flushmsg_ack\";\n\t}\n\treturn \"???\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&session->s_mutex"
          ],
          "line": 2563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 2561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__unregister_session",
          "args": [
            "mdsc",
            "session"
          ],
          "line": 2558
        },
        "resolved": true,
        "details": {
          "function_name": "__unregister_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "499-508",
          "snippet": "static void __unregister_session(struct ceph_mds_client *mdsc,\n\t\t\t       struct ceph_mds_session *s)\n{\n\tdout(\"__unregister_session mds%d %p\\n\", s->s_mds, s);\n\tBUG_ON(mdsc->sessions[s->s_mds] != s);\n\tmdsc->sessions[s->s_mds] = NULL;\n\tceph_con_close(&s->s_con);\n\tceph_put_mds_session(s);\n\tatomic_dec(&mdsc->num_sessions);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __unregister_session(struct ceph_mds_client *mdsc,\n\t\t\t       struct ceph_mds_session *s)\n{\n\tdout(\"__unregister_session mds%d %p\\n\", s->s_mds, s);\n\tBUG_ON(mdsc->sessions[s->s_mds] != s);\n\tmdsc->sessions[s->s_mds] = NULL;\n\tceph_con_close(&s->s_con);\n\tceph_put_mds_session(s);\n\tatomic_dec(&mdsc->num_sessions);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 2556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "h->seq"
          ],
          "line": 2554
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void handle_session(struct ceph_mds_session *session,\n\t\t\t   struct ceph_msg *msg)\n{\n\tstruct ceph_mds_client *mdsc = session->s_mdsc;\n\tu32 op;\n\tu64 seq;\n\tint mds = session->s_mds;\n\tstruct ceph_mds_session_head *h = msg->front.iov_base;\n\tint wake = 0;\n\n\t/* decode */\n\tif (msg->front.iov_len != sizeof(*h))\n\t\tgoto bad;\n\top = le32_to_cpu(h->op);\n\tseq = le64_to_cpu(h->seq);\n\n\tmutex_lock(&mdsc->mutex);\n\tif (op == CEPH_SESSION_CLOSE)\n\t\t__unregister_session(mdsc, session);\n\t/* FIXME: this ttl calculation is generous */\n\tsession->s_ttl = jiffies + HZ*mdsc->mdsmap->m_session_autoclose;\n\tmutex_unlock(&mdsc->mutex);\n\n\tmutex_lock(&session->s_mutex);\n\n\tdout(\"handle_session mds%d %s %p state %s seq %llu\\n\",\n\t     mds, ceph_session_op_name(op), session,\n\t     ceph_session_state_name(session->s_state), seq);\n\n\tif (session->s_state == CEPH_MDS_SESSION_HUNG) {\n\t\tsession->s_state = CEPH_MDS_SESSION_OPEN;\n\t\tpr_info(\"mds%d came back\\n\", session->s_mds);\n\t}\n\n\tswitch (op) {\n\tcase CEPH_SESSION_OPEN:\n\t\tif (session->s_state == CEPH_MDS_SESSION_RECONNECTING)\n\t\t\tpr_info(\"mds%d reconnect success\\n\", session->s_mds);\n\t\tsession->s_state = CEPH_MDS_SESSION_OPEN;\n\t\trenewed_caps(mdsc, session, 0);\n\t\twake = 1;\n\t\tif (mdsc->stopping)\n\t\t\t__close_session(mdsc, session);\n\t\tbreak;\n\n\tcase CEPH_SESSION_RENEWCAPS:\n\t\tif (session->s_renew_seq == seq)\n\t\t\trenewed_caps(mdsc, session, 1);\n\t\tbreak;\n\n\tcase CEPH_SESSION_CLOSE:\n\t\tif (session->s_state == CEPH_MDS_SESSION_RECONNECTING)\n\t\t\tpr_info(\"mds%d reconnect denied\\n\", session->s_mds);\n\t\tremove_session_caps(session);\n\t\twake = 2; /* for good measure */\n\t\twake_up_all(&mdsc->session_close_wq);\n\t\tbreak;\n\n\tcase CEPH_SESSION_STALE:\n\t\tpr_info(\"mds%d caps went stale, renewing\\n\",\n\t\t\tsession->s_mds);\n\t\tspin_lock(&session->s_gen_ttl_lock);\n\t\tsession->s_cap_gen++;\n\t\tsession->s_cap_ttl = jiffies - 1;\n\t\tspin_unlock(&session->s_gen_ttl_lock);\n\t\tsend_renew_caps(mdsc, session);\n\t\tbreak;\n\n\tcase CEPH_SESSION_RECALL_STATE:\n\t\ttrim_caps(mdsc, session, le32_to_cpu(h->max_caps));\n\t\tbreak;\n\n\tcase CEPH_SESSION_FLUSHMSG:\n\t\tsend_flushmsg_ack(mdsc, session, seq);\n\t\tbreak;\n\n\tcase CEPH_SESSION_FORCE_RO:\n\t\tdout(\"force_session_readonly %p\\n\", session);\n\t\tspin_lock(&session->s_cap_lock);\n\t\tsession->s_readonly = true;\n\t\tspin_unlock(&session->s_cap_lock);\n\t\twake_up_session_caps(session, 0);\n\t\tbreak;\n\n\tdefault:\n\t\tpr_err(\"mdsc_handle_session bad op %d mds%d\\n\", op, mds);\n\t\tWARN_ON(1);\n\t}\n\n\tmutex_unlock(&session->s_mutex);\n\tif (wake) {\n\t\tmutex_lock(&mdsc->mutex);\n\t\t__wake_requests(mdsc, &session->s_waiting);\n\t\tif (wake == 2)\n\t\t\tkick_requests(mdsc, mds);\n\t\tmutex_unlock(&mdsc->mutex);\n\t}\n\treturn;\n\nbad:\n\tpr_err(\"mdsc_handle_session corrupt message mds%d len %d\\n\", mds,\n\t       (int)msg->front.iov_len);\n\tceph_msg_dump(msg);\n\treturn;\n}"
  },
  {
    "function_name": "handle_forward",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "2488-2535",
    "snippet": "static void handle_forward(struct ceph_mds_client *mdsc,\n\t\t\t   struct ceph_mds_session *session,\n\t\t\t   struct ceph_msg *msg)\n{\n\tstruct ceph_mds_request *req;\n\tu64 tid = le64_to_cpu(msg->hdr.tid);\n\tu32 next_mds;\n\tu32 fwd_seq;\n\tint err = -EINVAL;\n\tvoid *p = msg->front.iov_base;\n\tvoid *end = p + msg->front.iov_len;\n\n\tceph_decode_need(&p, end, 2*sizeof(u32), bad);\n\tnext_mds = ceph_decode_32(&p);\n\tfwd_seq = ceph_decode_32(&p);\n\n\tmutex_lock(&mdsc->mutex);\n\treq = __lookup_request(mdsc, tid);\n\tif (!req) {\n\t\tdout(\"forward tid %llu to mds%d - req dne\\n\", tid, next_mds);\n\t\tgoto out;  /* dup reply? */\n\t}\n\n\tif (req->r_aborted) {\n\t\tdout(\"forward tid %llu aborted, unregistering\\n\", tid);\n\t\t__unregister_request(mdsc, req);\n\t} else if (fwd_seq <= req->r_num_fwd) {\n\t\tdout(\"forward tid %llu to mds%d - old seq %d <= %d\\n\",\n\t\t     tid, next_mds, req->r_num_fwd, fwd_seq);\n\t} else {\n\t\t/* resend. forward race not possible; mds would drop */\n\t\tdout(\"forward tid %llu to mds%d (we resend)\\n\", tid, next_mds);\n\t\tBUG_ON(req->r_err);\n\t\tBUG_ON(req->r_got_result);\n\t\treq->r_attempts = 0;\n\t\treq->r_num_fwd = fwd_seq;\n\t\treq->r_resend_mds = next_mds;\n\t\tput_request_session(req);\n\t\t__do_request(mdsc, req);\n\t}\n\tceph_mdsc_put_request(req);\nout:\n\tmutex_unlock(&mdsc->mutex);\n\treturn;\n\nbad:\n\tpr_err(\"mdsc_handle_forward decode error err=%d\\n\", err);\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"mdsc_handle_forward decode error err=%d\\n\"",
            "err"
          ],
          "line": 2534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 2530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_put_request",
          "args": [
            "req"
          ],
          "line": 2528
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_put_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.h",
          "lines": "377-380",
          "snippet": "static inline void ceph_mdsc_put_request(struct ceph_mds_request *req)\n{\n\tkref_put(&req->r_kref, ceph_mdsc_release_request);\n}",
          "includes": [
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mdsmap.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/kref.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/auth.h>\n#include <linux/ceph/mdsmap.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/types.h>\n#include <linux/spinlock.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/kref.h>\n#include <linux/completion.h>\n\nstatic inline void ceph_mdsc_put_request(struct ceph_mds_request *req)\n{\n\tkref_put(&req->r_kref, ceph_mdsc_release_request);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__do_request",
          "args": [
            "mdsc",
            "req"
          ],
          "line": 2526
        },
        "resolved": true,
        "details": {
          "function_name": "__do_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "2077-2150",
          "snippet": "static int __do_request(struct ceph_mds_client *mdsc,\n\t\t\tstruct ceph_mds_request *req)\n{\n\tstruct ceph_mds_session *session = NULL;\n\tint mds = -1;\n\tint err = -EAGAIN;\n\n\tif (req->r_err || req->r_got_result) {\n\t\tif (req->r_aborted)\n\t\t\t__unregister_request(mdsc, req);\n\t\tgoto out;\n\t}\n\n\tif (req->r_timeout &&\n\t    time_after_eq(jiffies, req->r_started + req->r_timeout)) {\n\t\tdout(\"do_request timed out\\n\");\n\t\terr = -EIO;\n\t\tgoto finish;\n\t}\n\n\tput_request_session(req);\n\n\tmds = __choose_mds(mdsc, req);\n\tif (mds < 0 ||\n\t    ceph_mdsmap_get_state(mdsc->mdsmap, mds) < CEPH_MDS_STATE_ACTIVE) {\n\t\tdout(\"do_request no mds or not active, waiting for map\\n\");\n\t\tlist_add(&req->r_wait, &mdsc->waiting_for_map);\n\t\tgoto out;\n\t}\n\n\t/* get, open session */\n\tsession = __ceph_lookup_mds_session(mdsc, mds);\n\tif (!session) {\n\t\tsession = register_session(mdsc, mds);\n\t\tif (IS_ERR(session)) {\n\t\t\terr = PTR_ERR(session);\n\t\t\tgoto finish;\n\t\t}\n\t}\n\treq->r_session = get_session(session);\n\n\tdout(\"do_request mds%d session %p state %s\\n\", mds, session,\n\t     ceph_session_state_name(session->s_state));\n\tif (session->s_state != CEPH_MDS_SESSION_OPEN &&\n\t    session->s_state != CEPH_MDS_SESSION_HUNG) {\n\t\tif (session->s_state == CEPH_MDS_SESSION_NEW ||\n\t\t    session->s_state == CEPH_MDS_SESSION_CLOSING)\n\t\t\t__open_session(mdsc, session);\n\t\tlist_add(&req->r_wait, &session->s_waiting);\n\t\tgoto out_session;\n\t}\n\n\t/* send request */\n\treq->r_resend_mds = -1;   /* forget any previous mds hint */\n\n\tif (req->r_request_started == 0)   /* note request start time */\n\t\treq->r_request_started = jiffies;\n\n\terr = __prepare_send_request(mdsc, req, mds);\n\tif (!err) {\n\t\tceph_msg_get(req->r_request);\n\t\tceph_con_send(&session->s_con, req->r_request);\n\t}\n\nout_session:\n\tceph_put_mds_session(session);\nout:\n\treturn err;\n\nfinish:\n\treq->r_err = err;\n\tcomplete_request(mdsc, req);\n\tgoto out;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __do_request(struct ceph_mds_client *mdsc,\n\t\t\tstruct ceph_mds_request *req)\n{\n\tstruct ceph_mds_session *session = NULL;\n\tint mds = -1;\n\tint err = -EAGAIN;\n\n\tif (req->r_err || req->r_got_result) {\n\t\tif (req->r_aborted)\n\t\t\t__unregister_request(mdsc, req);\n\t\tgoto out;\n\t}\n\n\tif (req->r_timeout &&\n\t    time_after_eq(jiffies, req->r_started + req->r_timeout)) {\n\t\tdout(\"do_request timed out\\n\");\n\t\terr = -EIO;\n\t\tgoto finish;\n\t}\n\n\tput_request_session(req);\n\n\tmds = __choose_mds(mdsc, req);\n\tif (mds < 0 ||\n\t    ceph_mdsmap_get_state(mdsc->mdsmap, mds) < CEPH_MDS_STATE_ACTIVE) {\n\t\tdout(\"do_request no mds or not active, waiting for map\\n\");\n\t\tlist_add(&req->r_wait, &mdsc->waiting_for_map);\n\t\tgoto out;\n\t}\n\n\t/* get, open session */\n\tsession = __ceph_lookup_mds_session(mdsc, mds);\n\tif (!session) {\n\t\tsession = register_session(mdsc, mds);\n\t\tif (IS_ERR(session)) {\n\t\t\terr = PTR_ERR(session);\n\t\t\tgoto finish;\n\t\t}\n\t}\n\treq->r_session = get_session(session);\n\n\tdout(\"do_request mds%d session %p state %s\\n\", mds, session,\n\t     ceph_session_state_name(session->s_state));\n\tif (session->s_state != CEPH_MDS_SESSION_OPEN &&\n\t    session->s_state != CEPH_MDS_SESSION_HUNG) {\n\t\tif (session->s_state == CEPH_MDS_SESSION_NEW ||\n\t\t    session->s_state == CEPH_MDS_SESSION_CLOSING)\n\t\t\t__open_session(mdsc, session);\n\t\tlist_add(&req->r_wait, &session->s_waiting);\n\t\tgoto out_session;\n\t}\n\n\t/* send request */\n\treq->r_resend_mds = -1;   /* forget any previous mds hint */\n\n\tif (req->r_request_started == 0)   /* note request start time */\n\t\treq->r_request_started = jiffies;\n\n\terr = __prepare_send_request(mdsc, req, mds);\n\tif (!err) {\n\t\tceph_msg_get(req->r_request);\n\t\tceph_con_send(&session->s_con, req->r_request);\n\t}\n\nout_session:\n\tceph_put_mds_session(session);\nout:\n\treturn err;\n\nfinish:\n\treq->r_err = err;\n\tcomplete_request(mdsc, req);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_request_session",
          "args": [
            "req"
          ],
          "line": 2525
        },
        "resolved": true,
        "details": {
          "function_name": "put_request_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "515-521",
          "snippet": "static void put_request_session(struct ceph_mds_request *req)\n{\n\tif (req->r_session) {\n\t\tceph_put_mds_session(req->r_session);\n\t\treq->r_session = NULL;\n\t}\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void put_request_session(struct ceph_mds_request *req)\n{\n\tif (req->r_session) {\n\t\tceph_put_mds_session(req->r_session);\n\t\treq->r_session = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "req->r_got_result"
          ],
          "line": 2521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "req->r_err"
          ],
          "line": 2520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"forward tid %llu to mds%d (we resend)\\n\"",
            "tid",
            "next_mds"
          ],
          "line": 2519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"forward tid %llu to mds%d - old seq %d <= %d\\n\"",
            "tid",
            "next_mds",
            "req->r_num_fwd",
            "fwd_seq"
          ],
          "line": 2515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__unregister_request",
          "args": [
            "mdsc",
            "req"
          ],
          "line": 2513
        },
        "resolved": true,
        "details": {
          "function_name": "__unregister_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "643-664",
          "snippet": "static void __unregister_request(struct ceph_mds_client *mdsc,\n\t\t\t\t struct ceph_mds_request *req)\n{\n\tdout(\"__unregister_request %p tid %lld\\n\", req, req->r_tid);\n\trb_erase(&req->r_node, &mdsc->request_tree);\n\tRB_CLEAR_NODE(&req->r_node);\n\n\tif (req->r_unsafe_dir) {\n\t\tstruct ceph_inode_info *ci = ceph_inode(req->r_unsafe_dir);\n\n\t\tspin_lock(&ci->i_unsafe_lock);\n\t\tlist_del_init(&req->r_unsafe_dir_item);\n\t\tspin_unlock(&ci->i_unsafe_lock);\n\n\t\tiput(req->r_unsafe_dir);\n\t\treq->r_unsafe_dir = NULL;\n\t}\n\n\tcomplete_all(&req->r_safe_completion);\n\n\tceph_mdsc_put_request(req);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __unregister_request(struct ceph_mds_client *mdsc,\n\t\t\t\t struct ceph_mds_request *req)\n{\n\tdout(\"__unregister_request %p tid %lld\\n\", req, req->r_tid);\n\trb_erase(&req->r_node, &mdsc->request_tree);\n\tRB_CLEAR_NODE(&req->r_node);\n\n\tif (req->r_unsafe_dir) {\n\t\tstruct ceph_inode_info *ci = ceph_inode(req->r_unsafe_dir);\n\n\t\tspin_lock(&ci->i_unsafe_lock);\n\t\tlist_del_init(&req->r_unsafe_dir_item);\n\t\tspin_unlock(&ci->i_unsafe_lock);\n\n\t\tiput(req->r_unsafe_dir);\n\t\treq->r_unsafe_dir = NULL;\n\t}\n\n\tcomplete_all(&req->r_safe_completion);\n\n\tceph_mdsc_put_request(req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"forward tid %llu aborted, unregistering\\n\"",
            "tid"
          ],
          "line": 2512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"forward tid %llu to mds%d - req dne\\n\"",
            "tid",
            "next_mds"
          ],
          "line": 2507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__lookup_request",
          "args": [
            "mdsc",
            "tid"
          ],
          "line": 2505
        },
        "resolved": true,
        "details": {
          "function_name": "__lookup_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "569-587",
          "snippet": "static struct ceph_mds_request *__lookup_request(struct ceph_mds_client *mdsc,\n\t\t\t\t\t     u64 tid)\n{\n\tstruct ceph_mds_request *req;\n\tstruct rb_node *n = mdsc->request_tree.rb_node;\n\n\twhile (n) {\n\t\treq = rb_entry(n, struct ceph_mds_request, r_node);\n\t\tif (tid < req->r_tid)\n\t\t\tn = n->rb_left;\n\t\telse if (tid > req->r_tid)\n\t\t\tn = n->rb_right;\n\t\telse {\n\t\t\tceph_mdsc_get_request(req);\n\t\t\treturn req;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_mds_request *__lookup_request(struct ceph_mds_client *mdsc,\n\t\t\t\t\t     u64 tid)\n{\n\tstruct ceph_mds_request *req;\n\tstruct rb_node *n = mdsc->request_tree.rb_node;\n\n\twhile (n) {\n\t\treq = rb_entry(n, struct ceph_mds_request, r_node);\n\t\tif (tid < req->r_tid)\n\t\t\tn = n->rb_left;\n\t\telse if (tid > req->r_tid)\n\t\t\tn = n->rb_right;\n\t\telse {\n\t\t\tceph_mdsc_get_request(req);\n\t\t\treturn req;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 2504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_32",
          "args": [
            "&p"
          ],
          "line": 2502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_32",
          "args": [
            "&p"
          ],
          "line": 2501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_need",
          "args": [
            "&p",
            "end",
            "2*sizeof(u32)",
            "bad"
          ],
          "line": 2500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "msg->hdr.tid"
          ],
          "line": 2493
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void handle_forward(struct ceph_mds_client *mdsc,\n\t\t\t   struct ceph_mds_session *session,\n\t\t\t   struct ceph_msg *msg)\n{\n\tstruct ceph_mds_request *req;\n\tu64 tid = le64_to_cpu(msg->hdr.tid);\n\tu32 next_mds;\n\tu32 fwd_seq;\n\tint err = -EINVAL;\n\tvoid *p = msg->front.iov_base;\n\tvoid *end = p + msg->front.iov_len;\n\n\tceph_decode_need(&p, end, 2*sizeof(u32), bad);\n\tnext_mds = ceph_decode_32(&p);\n\tfwd_seq = ceph_decode_32(&p);\n\n\tmutex_lock(&mdsc->mutex);\n\treq = __lookup_request(mdsc, tid);\n\tif (!req) {\n\t\tdout(\"forward tid %llu to mds%d - req dne\\n\", tid, next_mds);\n\t\tgoto out;  /* dup reply? */\n\t}\n\n\tif (req->r_aborted) {\n\t\tdout(\"forward tid %llu aborted, unregistering\\n\", tid);\n\t\t__unregister_request(mdsc, req);\n\t} else if (fwd_seq <= req->r_num_fwd) {\n\t\tdout(\"forward tid %llu to mds%d - old seq %d <= %d\\n\",\n\t\t     tid, next_mds, req->r_num_fwd, fwd_seq);\n\t} else {\n\t\t/* resend. forward race not possible; mds would drop */\n\t\tdout(\"forward tid %llu to mds%d (we resend)\\n\", tid, next_mds);\n\t\tBUG_ON(req->r_err);\n\t\tBUG_ON(req->r_got_result);\n\t\treq->r_attempts = 0;\n\t\treq->r_num_fwd = fwd_seq;\n\t\treq->r_resend_mds = next_mds;\n\t\tput_request_session(req);\n\t\t__do_request(mdsc, req);\n\t}\n\tceph_mdsc_put_request(req);\nout:\n\tmutex_unlock(&mdsc->mutex);\n\treturn;\n\nbad:\n\tpr_err(\"mdsc_handle_forward decode error err=%d\\n\", err);\n}"
  },
  {
    "function_name": "handle_reply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "2310-2481",
    "snippet": "static void handle_reply(struct ceph_mds_session *session, struct ceph_msg *msg)\n{\n\tstruct ceph_mds_client *mdsc = session->s_mdsc;\n\tstruct ceph_mds_request *req;\n\tstruct ceph_mds_reply_head *head = msg->front.iov_base;\n\tstruct ceph_mds_reply_info_parsed *rinfo;  /* parsed reply info */\n\tstruct ceph_snap_realm *realm;\n\tu64 tid;\n\tint err, result;\n\tint mds = session->s_mds;\n\n\tif (msg->front.iov_len < sizeof(*head)) {\n\t\tpr_err(\"mdsc_handle_reply got corrupt (short) reply\\n\");\n\t\tceph_msg_dump(msg);\n\t\treturn;\n\t}\n\n\t/* get request, session */\n\ttid = le64_to_cpu(msg->hdr.tid);\n\tmutex_lock(&mdsc->mutex);\n\treq = __lookup_request(mdsc, tid);\n\tif (!req) {\n\t\tdout(\"handle_reply on unknown tid %llu\\n\", tid);\n\t\tmutex_unlock(&mdsc->mutex);\n\t\treturn;\n\t}\n\tdout(\"handle_reply %p\\n\", req);\n\n\t/* correct session? */\n\tif (req->r_session != session) {\n\t\tpr_err(\"mdsc_handle_reply got %llu on session mds%d\"\n\t\t       \" not mds%d\\n\", tid, session->s_mds,\n\t\t       req->r_session ? req->r_session->s_mds : -1);\n\t\tmutex_unlock(&mdsc->mutex);\n\t\tgoto out;\n\t}\n\n\t/* dup? */\n\tif ((req->r_got_unsafe && !head->safe) ||\n\t    (req->r_got_safe && head->safe)) {\n\t\tpr_warn(\"got a dup %s reply on %llu from mds%d\\n\",\n\t\t\t   head->safe ? \"safe\" : \"unsafe\", tid, mds);\n\t\tmutex_unlock(&mdsc->mutex);\n\t\tgoto out;\n\t}\n\tif (req->r_got_safe && !head->safe) {\n\t\tpr_warn(\"got unsafe after safe on %llu from mds%d\\n\",\n\t\t\t   tid, mds);\n\t\tmutex_unlock(&mdsc->mutex);\n\t\tgoto out;\n\t}\n\n\tresult = le32_to_cpu(head->result);\n\n\t/*\n\t * Handle an ESTALE\n\t * if we're not talking to the authority, send to them\n\t * if the authority has changed while we weren't looking,\n\t * send to new authority\n\t * Otherwise we just have to return an ESTALE\n\t */\n\tif (result == -ESTALE) {\n\t\tdout(\"got ESTALE on request %llu\", req->r_tid);\n\t\treq->r_resend_mds = -1;\n\t\tif (req->r_direct_mode != USE_AUTH_MDS) {\n\t\t\tdout(\"not using auth, setting for that now\");\n\t\t\treq->r_direct_mode = USE_AUTH_MDS;\n\t\t\t__do_request(mdsc, req);\n\t\t\tmutex_unlock(&mdsc->mutex);\n\t\t\tgoto out;\n\t\t} else  {\n\t\t\tint mds = __choose_mds(mdsc, req);\n\t\t\tif (mds >= 0 && mds != req->r_session->s_mds) {\n\t\t\t\tdout(\"but auth changed, so resending\");\n\t\t\t\t__do_request(mdsc, req);\n\t\t\t\tmutex_unlock(&mdsc->mutex);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tdout(\"have to return ESTALE on request %llu\", req->r_tid);\n\t}\n\n\n\tif (head->safe) {\n\t\treq->r_got_safe = true;\n\t\t__unregister_request(mdsc, req);\n\n\t\tif (req->r_got_unsafe) {\n\t\t\t/*\n\t\t\t * We already handled the unsafe response, now do the\n\t\t\t * cleanup.  No need to examine the response; the MDS\n\t\t\t * doesn't include any result info in the safe\n\t\t\t * response.  And even if it did, there is nothing\n\t\t\t * useful we could do with a revised return value.\n\t\t\t */\n\t\t\tdout(\"got safe reply %llu, mds%d\\n\", tid, mds);\n\t\t\tlist_del_init(&req->r_unsafe_item);\n\n\t\t\t/* last unsafe request during umount? */\n\t\t\tif (mdsc->stopping && !__get_oldest_req(mdsc))\n\t\t\t\tcomplete_all(&mdsc->safe_umount_waiters);\n\t\t\tmutex_unlock(&mdsc->mutex);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\treq->r_got_unsafe = true;\n\t\tlist_add_tail(&req->r_unsafe_item, &req->r_session->s_unsafe);\n\t}\n\n\tdout(\"handle_reply tid %lld result %d\\n\", tid, result);\n\trinfo = &req->r_reply_info;\n\terr = parse_reply_info(msg, rinfo, session->s_con.peer_features);\n\tmutex_unlock(&mdsc->mutex);\n\n\tmutex_lock(&session->s_mutex);\n\tif (err < 0) {\n\t\tpr_err(\"mdsc_handle_reply got corrupt reply mds%d(tid:%lld)\\n\", mds, tid);\n\t\tceph_msg_dump(msg);\n\t\tgoto out_err;\n\t}\n\n\t/* snap trace */\n\trealm = NULL;\n\tif (rinfo->snapblob_len) {\n\t\tdown_write(&mdsc->snap_rwsem);\n\t\tceph_update_snap_trace(mdsc, rinfo->snapblob,\n\t\t\t\trinfo->snapblob + rinfo->snapblob_len,\n\t\t\t\tle32_to_cpu(head->op) == CEPH_MDS_OP_RMSNAP,\n\t\t\t\t&realm);\n\t\tdowngrade_write(&mdsc->snap_rwsem);\n\t} else {\n\t\tdown_read(&mdsc->snap_rwsem);\n\t}\n\n\t/* insert trace into our cache */\n\tmutex_lock(&req->r_fill_mutex);\n\terr = ceph_fill_trace(mdsc->fsc->sb, req, req->r_session);\n\tif (err == 0) {\n\t\tif (result == 0 && (req->r_op == CEPH_MDS_OP_READDIR ||\n\t\t\t\t    req->r_op == CEPH_MDS_OP_LSSNAP))\n\t\t\tceph_readdir_prepopulate(req, req->r_session);\n\t\tceph_unreserve_caps(mdsc, &req->r_caps_reservation);\n\t}\n\tmutex_unlock(&req->r_fill_mutex);\n\n\tup_read(&mdsc->snap_rwsem);\n\tif (realm)\n\t\tceph_put_snap_realm(mdsc, realm);\nout_err:\n\tmutex_lock(&mdsc->mutex);\n\tif (!req->r_aborted) {\n\t\tif (err) {\n\t\t\treq->r_err = err;\n\t\t} else {\n\t\t\treq->r_reply = msg;\n\t\t\tceph_msg_get(msg);\n\t\t\treq->r_got_result = true;\n\t\t}\n\t} else {\n\t\tdout(\"reply arrived after request %lld was aborted\\n\", tid);\n\t}\n\tmutex_unlock(&mdsc->mutex);\n\n\tceph_add_cap_releases(mdsc, req->r_session);\n\tmutex_unlock(&session->s_mutex);\n\n\t/* kick calling process */\n\tcomplete_request(mdsc, req);\nout:\n\tceph_mdsc_put_request(req);\n\treturn;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_mdsc_put_request",
          "args": [
            "req"
          ],
          "line": 2479
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_put_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.h",
          "lines": "377-380",
          "snippet": "static inline void ceph_mdsc_put_request(struct ceph_mds_request *req)\n{\n\tkref_put(&req->r_kref, ceph_mdsc_release_request);\n}",
          "includes": [
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mdsmap.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/kref.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/auth.h>\n#include <linux/ceph/mdsmap.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/types.h>\n#include <linux/spinlock.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/kref.h>\n#include <linux/completion.h>\n\nstatic inline void ceph_mdsc_put_request(struct ceph_mds_request *req)\n{\n\tkref_put(&req->r_kref, ceph_mdsc_release_request);\n}"
        }
      },
      {
        "call_info": {
          "callee": "complete_request",
          "args": [
            "mdsc",
            "req"
          ],
          "line": 2477
        },
        "resolved": true,
        "details": {
          "function_name": "complete_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1978-1985",
          "snippet": "static void complete_request(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_mds_request *req)\n{\n\tif (req->r_callback)\n\t\treq->r_callback(mdsc, req);\n\telse\n\t\tcomplete_all(&req->r_completion);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void complete_request(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_mds_request *req)\n{\n\tif (req->r_callback)\n\t\treq->r_callback(mdsc, req);\n\telse\n\t\tcomplete_all(&req->r_completion);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&session->s_mutex"
          ],
          "line": 2474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_add_cap_releases",
          "args": [
            "mdsc",
            "req->r_session"
          ],
          "line": 2473
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_add_cap_releases",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1412-1468",
          "snippet": "int ceph_add_cap_releases(struct ceph_mds_client *mdsc,\n\t\t\t  struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *msg, *partial = NULL;\n\tstruct ceph_mds_cap_release *head;\n\tint err = -ENOMEM;\n\tint extra = mdsc->fsc->mount_options->cap_release_safety;\n\tint num;\n\n\tdout(\"add_cap_releases %p mds%d extra %d\\n\", session, session->s_mds,\n\t     extra);\n\n\tspin_lock(&session->s_cap_lock);\n\n\tif (!list_empty(&session->s_cap_releases)) {\n\t\tmsg = list_first_entry(&session->s_cap_releases,\n\t\t\t\t       struct ceph_msg,\n\t\t\t\t list_head);\n\t\thead = msg->front.iov_base;\n\t\tnum = le32_to_cpu(head->num);\n\t\tif (num) {\n\t\t\tdout(\" partial %p with (%d/%d)\\n\", msg, num,\n\t\t\t     (int)CEPH_CAPS_PER_RELEASE);\n\t\t\textra += CEPH_CAPS_PER_RELEASE - num;\n\t\t\tpartial = msg;\n\t\t}\n\t}\n\twhile (session->s_num_cap_releases < session->s_nr_caps + extra) {\n\t\tspin_unlock(&session->s_cap_lock);\n\t\tmsg = ceph_msg_new(CEPH_MSG_CLIENT_CAPRELEASE, PAGE_CACHE_SIZE,\n\t\t\t\t   GFP_NOFS, false);\n\t\tif (!msg)\n\t\t\tgoto out_unlocked;\n\t\tdout(\"add_cap_releases %p msg %p now %d\\n\", session, msg,\n\t\t     (int)msg->front.iov_len);\n\t\thead = msg->front.iov_base;\n\t\thead->num = cpu_to_le32(0);\n\t\tmsg->front.iov_len = sizeof(*head);\n\t\tspin_lock(&session->s_cap_lock);\n\t\tlist_add(&msg->list_head, &session->s_cap_releases);\n\t\tsession->s_num_cap_releases += CEPH_CAPS_PER_RELEASE;\n\t}\n\n\tif (partial) {\n\t\thead = partial->front.iov_base;\n\t\tnum = le32_to_cpu(head->num);\n\t\tdout(\" queueing partial %p with %d/%d\\n\", partial, num,\n\t\t     (int)CEPH_CAPS_PER_RELEASE);\n\t\tlist_move_tail(&partial->list_head,\n\t\t\t       &session->s_cap_releases_done);\n\t\tsession->s_num_cap_releases -= CEPH_CAPS_PER_RELEASE - num;\n\t}\n\terr = 0;\n\tspin_unlock(&session->s_cap_lock);\nout_unlocked:\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);\n\nint ceph_add_cap_releases(struct ceph_mds_client *mdsc,\n\t\t\t  struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *msg, *partial = NULL;\n\tstruct ceph_mds_cap_release *head;\n\tint err = -ENOMEM;\n\tint extra = mdsc->fsc->mount_options->cap_release_safety;\n\tint num;\n\n\tdout(\"add_cap_releases %p mds%d extra %d\\n\", session, session->s_mds,\n\t     extra);\n\n\tspin_lock(&session->s_cap_lock);\n\n\tif (!list_empty(&session->s_cap_releases)) {\n\t\tmsg = list_first_entry(&session->s_cap_releases,\n\t\t\t\t       struct ceph_msg,\n\t\t\t\t list_head);\n\t\thead = msg->front.iov_base;\n\t\tnum = le32_to_cpu(head->num);\n\t\tif (num) {\n\t\t\tdout(\" partial %p with (%d/%d)\\n\", msg, num,\n\t\t\t     (int)CEPH_CAPS_PER_RELEASE);\n\t\t\textra += CEPH_CAPS_PER_RELEASE - num;\n\t\t\tpartial = msg;\n\t\t}\n\t}\n\twhile (session->s_num_cap_releases < session->s_nr_caps + extra) {\n\t\tspin_unlock(&session->s_cap_lock);\n\t\tmsg = ceph_msg_new(CEPH_MSG_CLIENT_CAPRELEASE, PAGE_CACHE_SIZE,\n\t\t\t\t   GFP_NOFS, false);\n\t\tif (!msg)\n\t\t\tgoto out_unlocked;\n\t\tdout(\"add_cap_releases %p msg %p now %d\\n\", session, msg,\n\t\t     (int)msg->front.iov_len);\n\t\thead = msg->front.iov_base;\n\t\thead->num = cpu_to_le32(0);\n\t\tmsg->front.iov_len = sizeof(*head);\n\t\tspin_lock(&session->s_cap_lock);\n\t\tlist_add(&msg->list_head, &session->s_cap_releases);\n\t\tsession->s_num_cap_releases += CEPH_CAPS_PER_RELEASE;\n\t}\n\n\tif (partial) {\n\t\thead = partial->front.iov_base;\n\t\tnum = le32_to_cpu(head->num);\n\t\tdout(\" queueing partial %p with %d/%d\\n\", partial, num,\n\t\t     (int)CEPH_CAPS_PER_RELEASE);\n\t\tlist_move_tail(&partial->list_head,\n\t\t\t       &session->s_cap_releases_done);\n\t\tsession->s_num_cap_releases -= CEPH_CAPS_PER_RELEASE - num;\n\t}\n\terr = 0;\n\tspin_unlock(&session->s_cap_lock);\nout_unlocked:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 2471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"reply arrived after request %lld was aborted\\n\"",
            "tid"
          ],
          "line": 2469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_msg_get",
          "args": [
            "msg"
          ],
          "line": 2465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 2459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_put_snap_realm",
          "args": [
            "mdsc",
            "realm"
          ],
          "line": 2457
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_put_snap_realm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
          "lines": "204-220",
          "snippet": "void ceph_put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t struct ceph_snap_realm *realm)\n{\n\tdout(\"put_snap_realm %llx %p %d -> %d\\n\", realm->ino, realm,\n\t     atomic_read(&realm->nref), atomic_read(&realm->nref)-1);\n\tif (!atomic_dec_and_test(&realm->nref))\n\t\treturn;\n\n\tif (down_write_trylock(&mdsc->snap_rwsem)) {\n\t\t__destroy_snap_realm(mdsc, realm);\n\t\tup_write(&mdsc->snap_rwsem);\n\t} else {\n\t\tspin_lock(&mdsc->snap_empty_lock);\n\t\tlist_add(&realm->empty_item, &mdsc->snap_empty);\n\t\tspin_unlock(&mdsc->snap_empty_lock);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);\n\nvoid ceph_put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t struct ceph_snap_realm *realm)\n{\n\tdout(\"put_snap_realm %llx %p %d -> %d\\n\", realm->ino, realm,\n\t     atomic_read(&realm->nref), atomic_read(&realm->nref)-1);\n\tif (!atomic_dec_and_test(&realm->nref))\n\t\treturn;\n\n\tif (down_write_trylock(&mdsc->snap_rwsem)) {\n\t\t__destroy_snap_realm(mdsc, realm);\n\t\tup_write(&mdsc->snap_rwsem);\n\t} else {\n\t\tspin_lock(&mdsc->snap_empty_lock);\n\t\tlist_add(&realm->empty_item, &mdsc->snap_empty);\n\t\tspin_unlock(&mdsc->snap_empty_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mdsc->snap_rwsem"
          ],
          "line": 2455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&req->r_fill_mutex"
          ],
          "line": 2453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_unreserve_caps",
          "args": [
            "mdsc",
            "&req->r_caps_reservation"
          ],
          "line": 2451
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_unreserve_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "203-222",
          "snippet": "int ceph_unreserve_caps(struct ceph_mds_client *mdsc,\n\t\t\tstruct ceph_cap_reservation *ctx)\n{\n\tdout(\"unreserve caps ctx=%p count=%d\\n\", ctx, ctx->count);\n\tif (ctx->count) {\n\t\tspin_lock(&mdsc->caps_list_lock);\n\t\tBUG_ON(mdsc->caps_reserve_count < ctx->count);\n\t\tmdsc->caps_reserve_count -= ctx->count;\n\t\tmdsc->caps_avail_count += ctx->count;\n\t\tctx->count = 0;\n\t\tdout(\"unreserve caps %d = %d used + %d resv + %d avail\\n\",\n\t\t     mdsc->caps_total_count, mdsc->caps_use_count,\n\t\t     mdsc->caps_reserve_count, mdsc->caps_avail_count);\n\t\tBUG_ON(mdsc->caps_total_count != mdsc->caps_use_count +\n\t\t\t\t\t\t mdsc->caps_reserve_count +\n\t\t\t\t\t\t mdsc->caps_avail_count);\n\t\tspin_unlock(&mdsc->caps_list_lock);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_unreserve_caps(struct ceph_mds_client *mdsc,\n\t\t\tstruct ceph_cap_reservation *ctx)\n{\n\tdout(\"unreserve caps ctx=%p count=%d\\n\", ctx, ctx->count);\n\tif (ctx->count) {\n\t\tspin_lock(&mdsc->caps_list_lock);\n\t\tBUG_ON(mdsc->caps_reserve_count < ctx->count);\n\t\tmdsc->caps_reserve_count -= ctx->count;\n\t\tmdsc->caps_avail_count += ctx->count;\n\t\tctx->count = 0;\n\t\tdout(\"unreserve caps %d = %d used + %d resv + %d avail\\n\",\n\t\t     mdsc->caps_total_count, mdsc->caps_use_count,\n\t\t     mdsc->caps_reserve_count, mdsc->caps_avail_count);\n\t\tBUG_ON(mdsc->caps_total_count != mdsc->caps_use_count +\n\t\t\t\t\t\t mdsc->caps_reserve_count +\n\t\t\t\t\t\t mdsc->caps_avail_count);\n\t\tspin_unlock(&mdsc->caps_list_lock);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_readdir_prepopulate",
          "args": [
            "req",
            "req->r_session"
          ],
          "line": 2450
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_readdir_prepopulate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "1336-1480",
          "snippet": "int ceph_readdir_prepopulate(struct ceph_mds_request *req,\n\t\t\t     struct ceph_mds_session *session)\n{\n\tstruct dentry *parent = req->r_dentry;\n\tstruct ceph_mds_reply_info_parsed *rinfo = &req->r_reply_info;\n\tstruct qstr dname;\n\tstruct dentry *dn;\n\tstruct inode *in;\n\tint err = 0, ret, i;\n\tstruct inode *snapdir = NULL;\n\tstruct ceph_mds_request_head *rhead = req->r_request->front.iov_base;\n\tstruct ceph_dentry_info *di;\n\tu64 r_readdir_offset = req->r_readdir_offset;\n\tu32 frag = le32_to_cpu(rhead->args.readdir.frag);\n\n\tif (rinfo->dir_dir &&\n\t    le32_to_cpu(rinfo->dir_dir->frag) != frag) {\n\t\tdout(\"readdir_prepopulate got new frag %x -> %x\\n\",\n\t\t     frag, le32_to_cpu(rinfo->dir_dir->frag));\n\t\tfrag = le32_to_cpu(rinfo->dir_dir->frag);\n\t\tif (ceph_frag_is_leftmost(frag))\n\t\t\tr_readdir_offset = 2;\n\t\telse\n\t\t\tr_readdir_offset = 0;\n\t}\n\n\tif (req->r_aborted)\n\t\treturn readdir_prepopulate_inodes_only(req, session);\n\n\tif (le32_to_cpu(rinfo->head->op) == CEPH_MDS_OP_LSSNAP) {\n\t\tsnapdir = ceph_get_snapdir(parent->d_inode);\n\t\tparent = d_find_alias(snapdir);\n\t\tdout(\"readdir_prepopulate %d items under SNAPDIR dn %p\\n\",\n\t\t     rinfo->dir_nr, parent);\n\t} else {\n\t\tdout(\"readdir_prepopulate %d items under dn %p\\n\",\n\t\t     rinfo->dir_nr, parent);\n\t\tif (rinfo->dir_dir)\n\t\t\tceph_fill_dirfrag(parent->d_inode, rinfo->dir_dir);\n\t}\n\n\t/* FIXME: release caps/leases if error occurs */\n\tfor (i = 0; i < rinfo->dir_nr; i++) {\n\t\tstruct ceph_vino vino;\n\n\t\tdname.name = rinfo->dir_dname[i];\n\t\tdname.len = rinfo->dir_dname_len[i];\n\t\tdname.hash = full_name_hash(dname.name, dname.len);\n\n\t\tvino.ino = le64_to_cpu(rinfo->dir_in[i].in->ino);\n\t\tvino.snap = le64_to_cpu(rinfo->dir_in[i].in->snapid);\n\nretry_lookup:\n\t\tdn = d_lookup(parent, &dname);\n\t\tdout(\"d_lookup on parent=%p name=%.*s got %p\\n\",\n\t\t     parent, dname.len, dname.name, dn);\n\n\t\tif (!dn) {\n\t\t\tdn = d_alloc(parent, &dname);\n\t\t\tdout(\"d_alloc %p '%.*s' = %p\\n\", parent,\n\t\t\t     dname.len, dname.name, dn);\n\t\t\tif (dn == NULL) {\n\t\t\t\tdout(\"d_alloc badness\\n\");\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = ceph_init_dentry(dn);\n\t\t\tif (ret < 0) {\n\t\t\t\tdput(dn);\n\t\t\t\terr = ret;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else if (dn->d_inode &&\n\t\t\t   (ceph_ino(dn->d_inode) != vino.ino ||\n\t\t\t    ceph_snap(dn->d_inode) != vino.snap)) {\n\t\t\tdout(\" dn %p points to wrong inode %p\\n\",\n\t\t\t     dn, dn->d_inode);\n\t\t\td_delete(dn);\n\t\t\tdput(dn);\n\t\t\tgoto retry_lookup;\n\t\t} else {\n\t\t\t/* reorder parent's d_subdirs */\n\t\t\tspin_lock(&parent->d_lock);\n\t\t\tspin_lock_nested(&dn->d_lock, DENTRY_D_LOCK_NESTED);\n\t\t\tlist_move(&dn->d_child, &parent->d_subdirs);\n\t\t\tspin_unlock(&dn->d_lock);\n\t\t\tspin_unlock(&parent->d_lock);\n\t\t}\n\n\t\t/* inode */\n\t\tif (dn->d_inode) {\n\t\t\tin = dn->d_inode;\n\t\t} else {\n\t\t\tin = ceph_get_inode(parent->d_sb, vino);\n\t\t\tif (IS_ERR(in)) {\n\t\t\t\tdout(\"new_inode badness\\n\");\n\t\t\t\td_drop(dn);\n\t\t\t\tdput(dn);\n\t\t\t\terr = PTR_ERR(in);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (fill_inode(in, NULL, &rinfo->dir_in[i], NULL, session,\n\t\t\t       req->r_request_started, -1,\n\t\t\t       &req->r_caps_reservation) < 0) {\n\t\t\tpr_err(\"fill_inode badness on %p\\n\", in);\n\t\t\tif (!dn->d_inode)\n\t\t\t\tiput(in);\n\t\t\td_drop(dn);\n\t\t\tgoto next_item;\n\t\t}\n\n\t\tif (!dn->d_inode) {\n\t\t\tstruct dentry *realdn = splice_dentry(dn, in, NULL);\n\t\t\tif (IS_ERR(realdn)) {\n\t\t\t\terr = PTR_ERR(realdn);\n\t\t\t\td_drop(dn);\n\t\t\t\tdn = NULL;\n\t\t\t\tgoto next_item;\n\t\t\t}\n\t\t\tdn = realdn;\n\t\t}\n\n\t\tdi = dn->d_fsdata;\n\t\tdi->offset = ceph_make_fpos(frag, i + r_readdir_offset);\n\n\t\tupdate_dentry_lease(dn, rinfo->dir_dlease[i],\n\t\t\t\t    req->r_session,\n\t\t\t\t    req->r_request_started);\nnext_item:\n\t\tif (dn)\n\t\t\tdput(dn);\n\t}\n\tif (err == 0)\n\t\treq->r_did_prepopulate = true;\n\nout:\n\tif (snapdir) {\n\t\tiput(snapdir);\n\t\tdput(parent);\n\t}\n\tdout(\"readdir_prepopulate done\\n\");\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_readdir_prepopulate(struct ceph_mds_request *req,\n\t\t\t     struct ceph_mds_session *session)\n{\n\tstruct dentry *parent = req->r_dentry;\n\tstruct ceph_mds_reply_info_parsed *rinfo = &req->r_reply_info;\n\tstruct qstr dname;\n\tstruct dentry *dn;\n\tstruct inode *in;\n\tint err = 0, ret, i;\n\tstruct inode *snapdir = NULL;\n\tstruct ceph_mds_request_head *rhead = req->r_request->front.iov_base;\n\tstruct ceph_dentry_info *di;\n\tu64 r_readdir_offset = req->r_readdir_offset;\n\tu32 frag = le32_to_cpu(rhead->args.readdir.frag);\n\n\tif (rinfo->dir_dir &&\n\t    le32_to_cpu(rinfo->dir_dir->frag) != frag) {\n\t\tdout(\"readdir_prepopulate got new frag %x -> %x\\n\",\n\t\t     frag, le32_to_cpu(rinfo->dir_dir->frag));\n\t\tfrag = le32_to_cpu(rinfo->dir_dir->frag);\n\t\tif (ceph_frag_is_leftmost(frag))\n\t\t\tr_readdir_offset = 2;\n\t\telse\n\t\t\tr_readdir_offset = 0;\n\t}\n\n\tif (req->r_aborted)\n\t\treturn readdir_prepopulate_inodes_only(req, session);\n\n\tif (le32_to_cpu(rinfo->head->op) == CEPH_MDS_OP_LSSNAP) {\n\t\tsnapdir = ceph_get_snapdir(parent->d_inode);\n\t\tparent = d_find_alias(snapdir);\n\t\tdout(\"readdir_prepopulate %d items under SNAPDIR dn %p\\n\",\n\t\t     rinfo->dir_nr, parent);\n\t} else {\n\t\tdout(\"readdir_prepopulate %d items under dn %p\\n\",\n\t\t     rinfo->dir_nr, parent);\n\t\tif (rinfo->dir_dir)\n\t\t\tceph_fill_dirfrag(parent->d_inode, rinfo->dir_dir);\n\t}\n\n\t/* FIXME: release caps/leases if error occurs */\n\tfor (i = 0; i < rinfo->dir_nr; i++) {\n\t\tstruct ceph_vino vino;\n\n\t\tdname.name = rinfo->dir_dname[i];\n\t\tdname.len = rinfo->dir_dname_len[i];\n\t\tdname.hash = full_name_hash(dname.name, dname.len);\n\n\t\tvino.ino = le64_to_cpu(rinfo->dir_in[i].in->ino);\n\t\tvino.snap = le64_to_cpu(rinfo->dir_in[i].in->snapid);\n\nretry_lookup:\n\t\tdn = d_lookup(parent, &dname);\n\t\tdout(\"d_lookup on parent=%p name=%.*s got %p\\n\",\n\t\t     parent, dname.len, dname.name, dn);\n\n\t\tif (!dn) {\n\t\t\tdn = d_alloc(parent, &dname);\n\t\t\tdout(\"d_alloc %p '%.*s' = %p\\n\", parent,\n\t\t\t     dname.len, dname.name, dn);\n\t\t\tif (dn == NULL) {\n\t\t\t\tdout(\"d_alloc badness\\n\");\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = ceph_init_dentry(dn);\n\t\t\tif (ret < 0) {\n\t\t\t\tdput(dn);\n\t\t\t\terr = ret;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else if (dn->d_inode &&\n\t\t\t   (ceph_ino(dn->d_inode) != vino.ino ||\n\t\t\t    ceph_snap(dn->d_inode) != vino.snap)) {\n\t\t\tdout(\" dn %p points to wrong inode %p\\n\",\n\t\t\t     dn, dn->d_inode);\n\t\t\td_delete(dn);\n\t\t\tdput(dn);\n\t\t\tgoto retry_lookup;\n\t\t} else {\n\t\t\t/* reorder parent's d_subdirs */\n\t\t\tspin_lock(&parent->d_lock);\n\t\t\tspin_lock_nested(&dn->d_lock, DENTRY_D_LOCK_NESTED);\n\t\t\tlist_move(&dn->d_child, &parent->d_subdirs);\n\t\t\tspin_unlock(&dn->d_lock);\n\t\t\tspin_unlock(&parent->d_lock);\n\t\t}\n\n\t\t/* inode */\n\t\tif (dn->d_inode) {\n\t\t\tin = dn->d_inode;\n\t\t} else {\n\t\t\tin = ceph_get_inode(parent->d_sb, vino);\n\t\t\tif (IS_ERR(in)) {\n\t\t\t\tdout(\"new_inode badness\\n\");\n\t\t\t\td_drop(dn);\n\t\t\t\tdput(dn);\n\t\t\t\terr = PTR_ERR(in);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (fill_inode(in, NULL, &rinfo->dir_in[i], NULL, session,\n\t\t\t       req->r_request_started, -1,\n\t\t\t       &req->r_caps_reservation) < 0) {\n\t\t\tpr_err(\"fill_inode badness on %p\\n\", in);\n\t\t\tif (!dn->d_inode)\n\t\t\t\tiput(in);\n\t\t\td_drop(dn);\n\t\t\tgoto next_item;\n\t\t}\n\n\t\tif (!dn->d_inode) {\n\t\t\tstruct dentry *realdn = splice_dentry(dn, in, NULL);\n\t\t\tif (IS_ERR(realdn)) {\n\t\t\t\terr = PTR_ERR(realdn);\n\t\t\t\td_drop(dn);\n\t\t\t\tdn = NULL;\n\t\t\t\tgoto next_item;\n\t\t\t}\n\t\t\tdn = realdn;\n\t\t}\n\n\t\tdi = dn->d_fsdata;\n\t\tdi->offset = ceph_make_fpos(frag, i + r_readdir_offset);\n\n\t\tupdate_dentry_lease(dn, rinfo->dir_dlease[i],\n\t\t\t\t    req->r_session,\n\t\t\t\t    req->r_request_started);\nnext_item:\n\t\tif (dn)\n\t\t\tdput(dn);\n\t}\n\tif (err == 0)\n\t\treq->r_did_prepopulate = true;\n\nout:\n\tif (snapdir) {\n\t\tiput(snapdir);\n\t\tdput(parent);\n\t}\n\tdout(\"readdir_prepopulate done\\n\");\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_fill_trace",
          "args": [
            "mdsc->fsc->sb",
            "req",
            "req->r_session"
          ],
          "line": 2446
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_fill_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "1026-1298",
          "snippet": "int ceph_fill_trace(struct super_block *sb, struct ceph_mds_request *req,\n\t\t    struct ceph_mds_session *session)\n{\n\tstruct ceph_mds_reply_info_parsed *rinfo = &req->r_reply_info;\n\tstruct inode *in = NULL;\n\tstruct ceph_vino vino;\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(sb);\n\tint err = 0;\n\n\tdout(\"fill_trace %p is_dentry %d is_target %d\\n\", req,\n\t     rinfo->head->is_dentry, rinfo->head->is_target);\n\n#if 0\n\t/*\n\t * Debugging hook:\n\t *\n\t * If we resend completed ops to a recovering mds, we get no\n\t * trace.  Since that is very rare, pretend this is the case\n\t * to ensure the 'no trace' handlers in the callers behave.\n\t *\n\t * Fill in inodes unconditionally to avoid breaking cap\n\t * invariants.\n\t */\n\tif (rinfo->head->op & CEPH_MDS_OP_WRITE) {\n\t\tpr_info(\"fill_trace faking empty trace on %lld %s\\n\",\n\t\t\treq->r_tid, ceph_mds_op_name(rinfo->head->op));\n\t\tif (rinfo->head->is_dentry) {\n\t\t\trinfo->head->is_dentry = 0;\n\t\t\terr = fill_inode(req->r_locked_dir,\n\t\t\t\t\t &rinfo->diri, rinfo->dirfrag,\n\t\t\t\t\t session, req->r_request_started, -1);\n\t\t}\n\t\tif (rinfo->head->is_target) {\n\t\t\trinfo->head->is_target = 0;\n\t\t\tininfo = rinfo->targeti.in;\n\t\t\tvino.ino = le64_to_cpu(ininfo->ino);\n\t\t\tvino.snap = le64_to_cpu(ininfo->snapid);\n\t\t\tin = ceph_get_inode(sb, vino);\n\t\t\terr = fill_inode(in, &rinfo->targeti, NULL,\n\t\t\t\t\t session, req->r_request_started,\n\t\t\t\t\t req->r_fmode);\n\t\t\tiput(in);\n\t\t}\n\t}\n#endif\n\n\tif (!rinfo->head->is_target && !rinfo->head->is_dentry) {\n\t\tdout(\"fill_trace reply is empty!\\n\");\n\t\tif (rinfo->head->result == 0 && req->r_locked_dir)\n\t\t\tceph_invalidate_dir_request(req);\n\t\treturn 0;\n\t}\n\n\tif (rinfo->head->is_dentry) {\n\t\tstruct inode *dir = req->r_locked_dir;\n\n\t\tif (dir) {\n\t\t\terr = fill_inode(dir, NULL,\n\t\t\t\t\t &rinfo->diri, rinfo->dirfrag,\n\t\t\t\t\t session, req->r_request_started, -1,\n\t\t\t\t\t &req->r_caps_reservation);\n\t\t\tif (err < 0)\n\t\t\t\tgoto done;\n\t\t} else {\n\t\t\tWARN_ON_ONCE(1);\n\t\t}\n\n\t\tif (dir && req->r_op == CEPH_MDS_OP_LOOKUPNAME) {\n\t\t\tstruct qstr dname;\n\t\t\tstruct dentry *dn, *parent;\n\n\t\t\tBUG_ON(!rinfo->head->is_target);\n\t\t\tBUG_ON(req->r_dentry);\n\n\t\t\tparent = d_find_any_alias(dir);\n\t\t\tBUG_ON(!parent);\n\n\t\t\tdname.name = rinfo->dname;\n\t\t\tdname.len = rinfo->dname_len;\n\t\t\tdname.hash = full_name_hash(dname.name, dname.len);\n\t\t\tvino.ino = le64_to_cpu(rinfo->targeti.in->ino);\n\t\t\tvino.snap = le64_to_cpu(rinfo->targeti.in->snapid);\nretry_lookup:\n\t\t\tdn = d_lookup(parent, &dname);\n\t\t\tdout(\"d_lookup on parent=%p name=%.*s got %p\\n\",\n\t\t\t     parent, dname.len, dname.name, dn);\n\n\t\t\tif (!dn) {\n\t\t\t\tdn = d_alloc(parent, &dname);\n\t\t\t\tdout(\"d_alloc %p '%.*s' = %p\\n\", parent,\n\t\t\t\t     dname.len, dname.name, dn);\n\t\t\t\tif (dn == NULL) {\n\t\t\t\t\tdput(parent);\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\terr = ceph_init_dentry(dn);\n\t\t\t\tif (err < 0) {\n\t\t\t\t\tdput(dn);\n\t\t\t\t\tdput(parent);\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t} else if (dn->d_inode &&\n\t\t\t\t   (ceph_ino(dn->d_inode) != vino.ino ||\n\t\t\t\t    ceph_snap(dn->d_inode) != vino.snap)) {\n\t\t\t\tdout(\" dn %p points to wrong inode %p\\n\",\n\t\t\t\t     dn, dn->d_inode);\n\t\t\t\td_delete(dn);\n\t\t\t\tdput(dn);\n\t\t\t\tgoto retry_lookup;\n\t\t\t}\n\n\t\t\treq->r_dentry = dn;\n\t\t\tdput(parent);\n\t\t}\n\t}\n\n\tif (rinfo->head->is_target) {\n\t\tvino.ino = le64_to_cpu(rinfo->targeti.in->ino);\n\t\tvino.snap = le64_to_cpu(rinfo->targeti.in->snapid);\n\n\t\tin = ceph_get_inode(sb, vino);\n\t\tif (IS_ERR(in)) {\n\t\t\terr = PTR_ERR(in);\n\t\t\tgoto done;\n\t\t}\n\t\treq->r_target_inode = in;\n\n\t\terr = fill_inode(in, req->r_locked_page, &rinfo->targeti, NULL,\n\t\t\t\tsession, req->r_request_started,\n\t\t\t\t(!req->r_aborted && rinfo->head->result == 0) ?\n\t\t\t\treq->r_fmode : -1,\n\t\t\t\t&req->r_caps_reservation);\n\t\tif (err < 0) {\n\t\t\tpr_err(\"fill_inode badness %p %llx.%llx\\n\",\n\t\t\t\tin, ceph_vinop(in));\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/*\n\t * ignore null lease/binding on snapdir ENOENT, or else we\n\t * will have trouble splicing in the virtual snapdir later\n\t */\n\tif (rinfo->head->is_dentry && !req->r_aborted &&\n\t    req->r_locked_dir &&\n\t    (rinfo->head->is_target || strncmp(req->r_dentry->d_name.name,\n\t\t\t\t\t       fsc->mount_options->snapdir_name,\n\t\t\t\t\t       req->r_dentry->d_name.len))) {\n\t\t/*\n\t\t * lookup link rename   : null -> possibly existing inode\n\t\t * mknod symlink mkdir  : null -> new inode\n\t\t * unlink               : linked -> null\n\t\t */\n\t\tstruct inode *dir = req->r_locked_dir;\n\t\tstruct dentry *dn = req->r_dentry;\n\t\tbool have_dir_cap, have_lease;\n\n\t\tBUG_ON(!dn);\n\t\tBUG_ON(!dir);\n\t\tBUG_ON(dn->d_parent->d_inode != dir);\n\t\tBUG_ON(ceph_ino(dir) !=\n\t\t       le64_to_cpu(rinfo->diri.in->ino));\n\t\tBUG_ON(ceph_snap(dir) !=\n\t\t       le64_to_cpu(rinfo->diri.in->snapid));\n\n\t\t/* do we have a lease on the whole dir? */\n\t\thave_dir_cap =\n\t\t\t(le32_to_cpu(rinfo->diri.in->cap.caps) &\n\t\t\t CEPH_CAP_FILE_SHARED);\n\n\t\t/* do we have a dn lease? */\n\t\thave_lease = have_dir_cap ||\n\t\t\tle32_to_cpu(rinfo->dlease->duration_ms);\n\t\tif (!have_lease)\n\t\t\tdout(\"fill_trace  no dentry lease or dir cap\\n\");\n\n\t\t/* rename? */\n\t\tif (req->r_old_dentry && req->r_op == CEPH_MDS_OP_RENAME) {\n\t\t\tstruct inode *olddir = req->r_old_dentry_dir;\n\t\t\tBUG_ON(!olddir);\n\n\t\t\tdout(\" src %p '%pd' dst %p '%pd'\\n\",\n\t\t\t     req->r_old_dentry,\n\t\t\t     req->r_old_dentry,\n\t\t\t     dn, dn);\n\t\t\tdout(\"fill_trace doing d_move %p -> %p\\n\",\n\t\t\t     req->r_old_dentry, dn);\n\n\t\t\td_move(req->r_old_dentry, dn);\n\t\t\tdout(\" src %p '%pd' dst %p '%pd'\\n\",\n\t\t\t     req->r_old_dentry,\n\t\t\t     req->r_old_dentry,\n\t\t\t     dn, dn);\n\n\t\t\t/* ensure target dentry is invalidated, despite\n\t\t\t   rehashing bug in vfs_rename_dir */\n\t\t\tceph_invalidate_dentry_lease(dn);\n\n\t\t\t/* d_move screws up sibling dentries' offsets */\n\t\t\tceph_dir_clear_ordered(dir);\n\t\t\tceph_dir_clear_ordered(olddir);\n\n\t\t\tdout(\"dn %p gets new offset %lld\\n\", req->r_old_dentry,\n\t\t\t     ceph_dentry(req->r_old_dentry)->offset);\n\n\t\t\tdn = req->r_old_dentry;  /* use old_dentry */\n\t\t}\n\n\t\t/* null dentry? */\n\t\tif (!rinfo->head->is_target) {\n\t\t\tdout(\"fill_trace null dentry\\n\");\n\t\t\tif (dn->d_inode) {\n\t\t\t\tceph_dir_clear_ordered(dir);\n\t\t\t\tdout(\"d_delete %p\\n\", dn);\n\t\t\t\td_delete(dn);\n\t\t\t} else {\n\t\t\t\tdout(\"d_instantiate %p NULL\\n\", dn);\n\t\t\t\td_instantiate(dn, NULL);\n\t\t\t\tif (have_lease && d_unhashed(dn))\n\t\t\t\t\td_rehash(dn);\n\t\t\t\tupdate_dentry_lease(dn, rinfo->dlease,\n\t\t\t\t\t\t    session,\n\t\t\t\t\t\t    req->r_request_started);\n\t\t\t}\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* attach proper inode */\n\t\tif (!dn->d_inode) {\n\t\t\tceph_dir_clear_ordered(dir);\n\t\t\tihold(in);\n\t\t\tdn = splice_dentry(dn, in, &have_lease);\n\t\t\tif (IS_ERR(dn)) {\n\t\t\t\terr = PTR_ERR(dn);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\treq->r_dentry = dn;  /* may have spliced */\n\t\t} else if (dn->d_inode && dn->d_inode != in) {\n\t\t\tdout(\" %p links to %p %llx.%llx, not %llx.%llx\\n\",\n\t\t\t     dn, dn->d_inode, ceph_vinop(dn->d_inode),\n\t\t\t     ceph_vinop(in));\n\t\t\thave_lease = false;\n\t\t}\n\n\t\tif (have_lease)\n\t\t\tupdate_dentry_lease(dn, rinfo->dlease, session,\n\t\t\t\t\t    req->r_request_started);\n\t\tdout(\" final dn %p\\n\", dn);\n\t} else if (!req->r_aborted &&\n\t\t   (req->r_op == CEPH_MDS_OP_LOOKUPSNAP ||\n\t\t    req->r_op == CEPH_MDS_OP_MKSNAP)) {\n\t\tstruct dentry *dn = req->r_dentry;\n\t\tstruct inode *dir = req->r_locked_dir;\n\n\t\t/* fill out a snapdir LOOKUPSNAP dentry */\n\t\tBUG_ON(!dn);\n\t\tBUG_ON(!dir);\n\t\tBUG_ON(ceph_snap(dir) != CEPH_SNAPDIR);\n\t\tdout(\" linking snapped dir %p to dn %p\\n\", in, dn);\n\t\tceph_dir_clear_ordered(dir);\n\t\tihold(in);\n\t\tdn = splice_dentry(dn, in, NULL);\n\t\tif (IS_ERR(dn)) {\n\t\t\terr = PTR_ERR(dn);\n\t\t\tgoto done;\n\t\t}\n\t\treq->r_dentry = dn;  /* may have spliced */\n\t}\ndone:\n\tdout(\"fill_trace done err=%d\\n\", err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_fill_trace(struct super_block *sb, struct ceph_mds_request *req,\n\t\t    struct ceph_mds_session *session)\n{\n\tstruct ceph_mds_reply_info_parsed *rinfo = &req->r_reply_info;\n\tstruct inode *in = NULL;\n\tstruct ceph_vino vino;\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(sb);\n\tint err = 0;\n\n\tdout(\"fill_trace %p is_dentry %d is_target %d\\n\", req,\n\t     rinfo->head->is_dentry, rinfo->head->is_target);\n\n#if 0\n\t/*\n\t * Debugging hook:\n\t *\n\t * If we resend completed ops to a recovering mds, we get no\n\t * trace.  Since that is very rare, pretend this is the case\n\t * to ensure the 'no trace' handlers in the callers behave.\n\t *\n\t * Fill in inodes unconditionally to avoid breaking cap\n\t * invariants.\n\t */\n\tif (rinfo->head->op & CEPH_MDS_OP_WRITE) {\n\t\tpr_info(\"fill_trace faking empty trace on %lld %s\\n\",\n\t\t\treq->r_tid, ceph_mds_op_name(rinfo->head->op));\n\t\tif (rinfo->head->is_dentry) {\n\t\t\trinfo->head->is_dentry = 0;\n\t\t\terr = fill_inode(req->r_locked_dir,\n\t\t\t\t\t &rinfo->diri, rinfo->dirfrag,\n\t\t\t\t\t session, req->r_request_started, -1);\n\t\t}\n\t\tif (rinfo->head->is_target) {\n\t\t\trinfo->head->is_target = 0;\n\t\t\tininfo = rinfo->targeti.in;\n\t\t\tvino.ino = le64_to_cpu(ininfo->ino);\n\t\t\tvino.snap = le64_to_cpu(ininfo->snapid);\n\t\t\tin = ceph_get_inode(sb, vino);\n\t\t\terr = fill_inode(in, &rinfo->targeti, NULL,\n\t\t\t\t\t session, req->r_request_started,\n\t\t\t\t\t req->r_fmode);\n\t\t\tiput(in);\n\t\t}\n\t}\n#endif\n\n\tif (!rinfo->head->is_target && !rinfo->head->is_dentry) {\n\t\tdout(\"fill_trace reply is empty!\\n\");\n\t\tif (rinfo->head->result == 0 && req->r_locked_dir)\n\t\t\tceph_invalidate_dir_request(req);\n\t\treturn 0;\n\t}\n\n\tif (rinfo->head->is_dentry) {\n\t\tstruct inode *dir = req->r_locked_dir;\n\n\t\tif (dir) {\n\t\t\terr = fill_inode(dir, NULL,\n\t\t\t\t\t &rinfo->diri, rinfo->dirfrag,\n\t\t\t\t\t session, req->r_request_started, -1,\n\t\t\t\t\t &req->r_caps_reservation);\n\t\t\tif (err < 0)\n\t\t\t\tgoto done;\n\t\t} else {\n\t\t\tWARN_ON_ONCE(1);\n\t\t}\n\n\t\tif (dir && req->r_op == CEPH_MDS_OP_LOOKUPNAME) {\n\t\t\tstruct qstr dname;\n\t\t\tstruct dentry *dn, *parent;\n\n\t\t\tBUG_ON(!rinfo->head->is_target);\n\t\t\tBUG_ON(req->r_dentry);\n\n\t\t\tparent = d_find_any_alias(dir);\n\t\t\tBUG_ON(!parent);\n\n\t\t\tdname.name = rinfo->dname;\n\t\t\tdname.len = rinfo->dname_len;\n\t\t\tdname.hash = full_name_hash(dname.name, dname.len);\n\t\t\tvino.ino = le64_to_cpu(rinfo->targeti.in->ino);\n\t\t\tvino.snap = le64_to_cpu(rinfo->targeti.in->snapid);\nretry_lookup:\n\t\t\tdn = d_lookup(parent, &dname);\n\t\t\tdout(\"d_lookup on parent=%p name=%.*s got %p\\n\",\n\t\t\t     parent, dname.len, dname.name, dn);\n\n\t\t\tif (!dn) {\n\t\t\t\tdn = d_alloc(parent, &dname);\n\t\t\t\tdout(\"d_alloc %p '%.*s' = %p\\n\", parent,\n\t\t\t\t     dname.len, dname.name, dn);\n\t\t\t\tif (dn == NULL) {\n\t\t\t\t\tdput(parent);\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\terr = ceph_init_dentry(dn);\n\t\t\t\tif (err < 0) {\n\t\t\t\t\tdput(dn);\n\t\t\t\t\tdput(parent);\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t} else if (dn->d_inode &&\n\t\t\t\t   (ceph_ino(dn->d_inode) != vino.ino ||\n\t\t\t\t    ceph_snap(dn->d_inode) != vino.snap)) {\n\t\t\t\tdout(\" dn %p points to wrong inode %p\\n\",\n\t\t\t\t     dn, dn->d_inode);\n\t\t\t\td_delete(dn);\n\t\t\t\tdput(dn);\n\t\t\t\tgoto retry_lookup;\n\t\t\t}\n\n\t\t\treq->r_dentry = dn;\n\t\t\tdput(parent);\n\t\t}\n\t}\n\n\tif (rinfo->head->is_target) {\n\t\tvino.ino = le64_to_cpu(rinfo->targeti.in->ino);\n\t\tvino.snap = le64_to_cpu(rinfo->targeti.in->snapid);\n\n\t\tin = ceph_get_inode(sb, vino);\n\t\tif (IS_ERR(in)) {\n\t\t\terr = PTR_ERR(in);\n\t\t\tgoto done;\n\t\t}\n\t\treq->r_target_inode = in;\n\n\t\terr = fill_inode(in, req->r_locked_page, &rinfo->targeti, NULL,\n\t\t\t\tsession, req->r_request_started,\n\t\t\t\t(!req->r_aborted && rinfo->head->result == 0) ?\n\t\t\t\treq->r_fmode : -1,\n\t\t\t\t&req->r_caps_reservation);\n\t\tif (err < 0) {\n\t\t\tpr_err(\"fill_inode badness %p %llx.%llx\\n\",\n\t\t\t\tin, ceph_vinop(in));\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/*\n\t * ignore null lease/binding on snapdir ENOENT, or else we\n\t * will have trouble splicing in the virtual snapdir later\n\t */\n\tif (rinfo->head->is_dentry && !req->r_aborted &&\n\t    req->r_locked_dir &&\n\t    (rinfo->head->is_target || strncmp(req->r_dentry->d_name.name,\n\t\t\t\t\t       fsc->mount_options->snapdir_name,\n\t\t\t\t\t       req->r_dentry->d_name.len))) {\n\t\t/*\n\t\t * lookup link rename   : null -> possibly existing inode\n\t\t * mknod symlink mkdir  : null -> new inode\n\t\t * unlink               : linked -> null\n\t\t */\n\t\tstruct inode *dir = req->r_locked_dir;\n\t\tstruct dentry *dn = req->r_dentry;\n\t\tbool have_dir_cap, have_lease;\n\n\t\tBUG_ON(!dn);\n\t\tBUG_ON(!dir);\n\t\tBUG_ON(dn->d_parent->d_inode != dir);\n\t\tBUG_ON(ceph_ino(dir) !=\n\t\t       le64_to_cpu(rinfo->diri.in->ino));\n\t\tBUG_ON(ceph_snap(dir) !=\n\t\t       le64_to_cpu(rinfo->diri.in->snapid));\n\n\t\t/* do we have a lease on the whole dir? */\n\t\thave_dir_cap =\n\t\t\t(le32_to_cpu(rinfo->diri.in->cap.caps) &\n\t\t\t CEPH_CAP_FILE_SHARED);\n\n\t\t/* do we have a dn lease? */\n\t\thave_lease = have_dir_cap ||\n\t\t\tle32_to_cpu(rinfo->dlease->duration_ms);\n\t\tif (!have_lease)\n\t\t\tdout(\"fill_trace  no dentry lease or dir cap\\n\");\n\n\t\t/* rename? */\n\t\tif (req->r_old_dentry && req->r_op == CEPH_MDS_OP_RENAME) {\n\t\t\tstruct inode *olddir = req->r_old_dentry_dir;\n\t\t\tBUG_ON(!olddir);\n\n\t\t\tdout(\" src %p '%pd' dst %p '%pd'\\n\",\n\t\t\t     req->r_old_dentry,\n\t\t\t     req->r_old_dentry,\n\t\t\t     dn, dn);\n\t\t\tdout(\"fill_trace doing d_move %p -> %p\\n\",\n\t\t\t     req->r_old_dentry, dn);\n\n\t\t\td_move(req->r_old_dentry, dn);\n\t\t\tdout(\" src %p '%pd' dst %p '%pd'\\n\",\n\t\t\t     req->r_old_dentry,\n\t\t\t     req->r_old_dentry,\n\t\t\t     dn, dn);\n\n\t\t\t/* ensure target dentry is invalidated, despite\n\t\t\t   rehashing bug in vfs_rename_dir */\n\t\t\tceph_invalidate_dentry_lease(dn);\n\n\t\t\t/* d_move screws up sibling dentries' offsets */\n\t\t\tceph_dir_clear_ordered(dir);\n\t\t\tceph_dir_clear_ordered(olddir);\n\n\t\t\tdout(\"dn %p gets new offset %lld\\n\", req->r_old_dentry,\n\t\t\t     ceph_dentry(req->r_old_dentry)->offset);\n\n\t\t\tdn = req->r_old_dentry;  /* use old_dentry */\n\t\t}\n\n\t\t/* null dentry? */\n\t\tif (!rinfo->head->is_target) {\n\t\t\tdout(\"fill_trace null dentry\\n\");\n\t\t\tif (dn->d_inode) {\n\t\t\t\tceph_dir_clear_ordered(dir);\n\t\t\t\tdout(\"d_delete %p\\n\", dn);\n\t\t\t\td_delete(dn);\n\t\t\t} else {\n\t\t\t\tdout(\"d_instantiate %p NULL\\n\", dn);\n\t\t\t\td_instantiate(dn, NULL);\n\t\t\t\tif (have_lease && d_unhashed(dn))\n\t\t\t\t\td_rehash(dn);\n\t\t\t\tupdate_dentry_lease(dn, rinfo->dlease,\n\t\t\t\t\t\t    session,\n\t\t\t\t\t\t    req->r_request_started);\n\t\t\t}\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* attach proper inode */\n\t\tif (!dn->d_inode) {\n\t\t\tceph_dir_clear_ordered(dir);\n\t\t\tihold(in);\n\t\t\tdn = splice_dentry(dn, in, &have_lease);\n\t\t\tif (IS_ERR(dn)) {\n\t\t\t\terr = PTR_ERR(dn);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\treq->r_dentry = dn;  /* may have spliced */\n\t\t} else if (dn->d_inode && dn->d_inode != in) {\n\t\t\tdout(\" %p links to %p %llx.%llx, not %llx.%llx\\n\",\n\t\t\t     dn, dn->d_inode, ceph_vinop(dn->d_inode),\n\t\t\t     ceph_vinop(in));\n\t\t\thave_lease = false;\n\t\t}\n\n\t\tif (have_lease)\n\t\t\tupdate_dentry_lease(dn, rinfo->dlease, session,\n\t\t\t\t\t    req->r_request_started);\n\t\tdout(\" final dn %p\\n\", dn);\n\t} else if (!req->r_aborted &&\n\t\t   (req->r_op == CEPH_MDS_OP_LOOKUPSNAP ||\n\t\t    req->r_op == CEPH_MDS_OP_MKSNAP)) {\n\t\tstruct dentry *dn = req->r_dentry;\n\t\tstruct inode *dir = req->r_locked_dir;\n\n\t\t/* fill out a snapdir LOOKUPSNAP dentry */\n\t\tBUG_ON(!dn);\n\t\tBUG_ON(!dir);\n\t\tBUG_ON(ceph_snap(dir) != CEPH_SNAPDIR);\n\t\tdout(\" linking snapped dir %p to dn %p\\n\", in, dn);\n\t\tceph_dir_clear_ordered(dir);\n\t\tihold(in);\n\t\tdn = splice_dentry(dn, in, NULL);\n\t\tif (IS_ERR(dn)) {\n\t\t\terr = PTR_ERR(dn);\n\t\t\tgoto done;\n\t\t}\n\t\treq->r_dentry = dn;  /* may have spliced */\n\t}\ndone:\n\tdout(\"fill_trace done err=%d\\n\", err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&req->r_fill_mutex"
          ],
          "line": 2445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&mdsc->snap_rwsem"
          ],
          "line": 2441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "downgrade_write",
          "args": [
            "&mdsc->snap_rwsem"
          ],
          "line": 2439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_update_snap_trace",
          "args": [
            "mdsc",
            "rinfo->snapblob",
            "rinfo->snapblob + rinfo->snapblob_len",
            "le32_to_cpu(head->op) == CEPH_MDS_OP_RMSNAP",
            "&realm"
          ],
          "line": 2435
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_update_snap_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
          "lines": "640-755",
          "snippet": "int ceph_update_snap_trace(struct ceph_mds_client *mdsc,\n\t\t\t   void *p, void *e, bool deletion,\n\t\t\t   struct ceph_snap_realm **realm_ret)\n{\n\tstruct ceph_mds_snap_realm *ri;    /* encoded */\n\t__le64 *snaps;                     /* encoded */\n\t__le64 *prior_parent_snaps;        /* encoded */\n\tstruct ceph_snap_realm *realm = NULL;\n\tstruct ceph_snap_realm *first_realm = NULL;\n\tint invalidate = 0;\n\tint err = -ENOMEM;\n\tLIST_HEAD(dirty_realms);\n\n\tdout(\"update_snap_trace deletion=%d\\n\", deletion);\nmore:\n\tceph_decode_need(&p, e, sizeof(*ri), bad);\n\tri = p;\n\tp += sizeof(*ri);\n\tceph_decode_need(&p, e, sizeof(u64)*(le32_to_cpu(ri->num_snaps) +\n\t\t\t    le32_to_cpu(ri->num_prior_parent_snaps)), bad);\n\tsnaps = p;\n\tp += sizeof(u64) * le32_to_cpu(ri->num_snaps);\n\tprior_parent_snaps = p;\n\tp += sizeof(u64) * le32_to_cpu(ri->num_prior_parent_snaps);\n\n\trealm = ceph_lookup_snap_realm(mdsc, le64_to_cpu(ri->ino));\n\tif (!realm) {\n\t\trealm = ceph_create_snap_realm(mdsc, le64_to_cpu(ri->ino));\n\t\tif (IS_ERR(realm)) {\n\t\t\terr = PTR_ERR(realm);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t/* ensure the parent is correct */\n\terr = adjust_snap_realm_parent(mdsc, realm, le64_to_cpu(ri->parent));\n\tif (err < 0)\n\t\tgoto fail;\n\tinvalidate += err;\n\n\tif (le64_to_cpu(ri->seq) > realm->seq) {\n\t\tdout(\"update_snap_trace updating %llx %p %lld -> %lld\\n\",\n\t\t     realm->ino, realm, realm->seq, le64_to_cpu(ri->seq));\n\t\t/* update realm parameters, snap lists */\n\t\trealm->seq = le64_to_cpu(ri->seq);\n\t\trealm->created = le64_to_cpu(ri->created);\n\t\trealm->parent_since = le64_to_cpu(ri->parent_since);\n\n\t\trealm->num_snaps = le32_to_cpu(ri->num_snaps);\n\t\terr = dup_array(&realm->snaps, snaps, realm->num_snaps);\n\t\tif (err < 0)\n\t\t\tgoto fail;\n\n\t\trealm->num_prior_parent_snaps =\n\t\t\tle32_to_cpu(ri->num_prior_parent_snaps);\n\t\terr = dup_array(&realm->prior_parent_snaps, prior_parent_snaps,\n\t\t\t\trealm->num_prior_parent_snaps);\n\t\tif (err < 0)\n\t\t\tgoto fail;\n\n\t\t/* queue realm for cap_snap creation */\n\t\tlist_add(&realm->dirty_item, &dirty_realms);\n\n\t\tinvalidate = 1;\n\t} else if (!realm->cached_context) {\n\t\tdout(\"update_snap_trace %llx %p seq %lld new\\n\",\n\t\t     realm->ino, realm, realm->seq);\n\t\tinvalidate = 1;\n\t} else {\n\t\tdout(\"update_snap_trace %llx %p seq %lld unchanged\\n\",\n\t\t     realm->ino, realm, realm->seq);\n\t}\n\n\tdout(\"done with %llx %p, invalidated=%d, %p %p\\n\", realm->ino,\n\t     realm, invalidate, p, e);\n\n\t/* invalidate when we reach the _end_ (root) of the trace */\n\tif (invalidate && p >= e)\n\t\trebuild_snap_realms(realm);\n\n\tif (!first_realm)\n\t\tfirst_realm = realm;\n\telse\n\t\tceph_put_snap_realm(mdsc, realm);\n\n\tif (p < e)\n\t\tgoto more;\n\n\t/*\n\t * queue cap snaps _after_ we've built the new snap contexts,\n\t * so that i_head_snapc can be set appropriately.\n\t */\n\twhile (!list_empty(&dirty_realms)) {\n\t\trealm = list_first_entry(&dirty_realms, struct ceph_snap_realm,\n\t\t\t\t\t dirty_item);\n\t\tqueue_realm_cap_snaps(realm);\n\t}\n\n\tif (realm_ret)\n\t\t*realm_ret = first_realm;\n\telse\n\t\tceph_put_snap_realm(mdsc, first_realm);\n\n\t__cleanup_empty_realms(mdsc);\n\treturn 0;\n\nbad:\n\terr = -EINVAL;\nfail:\n\tif (realm && !IS_ERR(realm))\n\t\tceph_put_snap_realm(mdsc, realm);\n\tif (first_realm)\n\t\tceph_put_snap_realm(mdsc, first_realm);\n\tpr_err(\"update_snap_trace error %d\\n\", err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);\n\nint ceph_update_snap_trace(struct ceph_mds_client *mdsc,\n\t\t\t   void *p, void *e, bool deletion,\n\t\t\t   struct ceph_snap_realm **realm_ret)\n{\n\tstruct ceph_mds_snap_realm *ri;    /* encoded */\n\t__le64 *snaps;                     /* encoded */\n\t__le64 *prior_parent_snaps;        /* encoded */\n\tstruct ceph_snap_realm *realm = NULL;\n\tstruct ceph_snap_realm *first_realm = NULL;\n\tint invalidate = 0;\n\tint err = -ENOMEM;\n\tLIST_HEAD(dirty_realms);\n\n\tdout(\"update_snap_trace deletion=%d\\n\", deletion);\nmore:\n\tceph_decode_need(&p, e, sizeof(*ri), bad);\n\tri = p;\n\tp += sizeof(*ri);\n\tceph_decode_need(&p, e, sizeof(u64)*(le32_to_cpu(ri->num_snaps) +\n\t\t\t    le32_to_cpu(ri->num_prior_parent_snaps)), bad);\n\tsnaps = p;\n\tp += sizeof(u64) * le32_to_cpu(ri->num_snaps);\n\tprior_parent_snaps = p;\n\tp += sizeof(u64) * le32_to_cpu(ri->num_prior_parent_snaps);\n\n\trealm = ceph_lookup_snap_realm(mdsc, le64_to_cpu(ri->ino));\n\tif (!realm) {\n\t\trealm = ceph_create_snap_realm(mdsc, le64_to_cpu(ri->ino));\n\t\tif (IS_ERR(realm)) {\n\t\t\terr = PTR_ERR(realm);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t/* ensure the parent is correct */\n\terr = adjust_snap_realm_parent(mdsc, realm, le64_to_cpu(ri->parent));\n\tif (err < 0)\n\t\tgoto fail;\n\tinvalidate += err;\n\n\tif (le64_to_cpu(ri->seq) > realm->seq) {\n\t\tdout(\"update_snap_trace updating %llx %p %lld -> %lld\\n\",\n\t\t     realm->ino, realm, realm->seq, le64_to_cpu(ri->seq));\n\t\t/* update realm parameters, snap lists */\n\t\trealm->seq = le64_to_cpu(ri->seq);\n\t\trealm->created = le64_to_cpu(ri->created);\n\t\trealm->parent_since = le64_to_cpu(ri->parent_since);\n\n\t\trealm->num_snaps = le32_to_cpu(ri->num_snaps);\n\t\terr = dup_array(&realm->snaps, snaps, realm->num_snaps);\n\t\tif (err < 0)\n\t\t\tgoto fail;\n\n\t\trealm->num_prior_parent_snaps =\n\t\t\tle32_to_cpu(ri->num_prior_parent_snaps);\n\t\terr = dup_array(&realm->prior_parent_snaps, prior_parent_snaps,\n\t\t\t\trealm->num_prior_parent_snaps);\n\t\tif (err < 0)\n\t\t\tgoto fail;\n\n\t\t/* queue realm for cap_snap creation */\n\t\tlist_add(&realm->dirty_item, &dirty_realms);\n\n\t\tinvalidate = 1;\n\t} else if (!realm->cached_context) {\n\t\tdout(\"update_snap_trace %llx %p seq %lld new\\n\",\n\t\t     realm->ino, realm, realm->seq);\n\t\tinvalidate = 1;\n\t} else {\n\t\tdout(\"update_snap_trace %llx %p seq %lld unchanged\\n\",\n\t\t     realm->ino, realm, realm->seq);\n\t}\n\n\tdout(\"done with %llx %p, invalidated=%d, %p %p\\n\", realm->ino,\n\t     realm, invalidate, p, e);\n\n\t/* invalidate when we reach the _end_ (root) of the trace */\n\tif (invalidate && p >= e)\n\t\trebuild_snap_realms(realm);\n\n\tif (!first_realm)\n\t\tfirst_realm = realm;\n\telse\n\t\tceph_put_snap_realm(mdsc, realm);\n\n\tif (p < e)\n\t\tgoto more;\n\n\t/*\n\t * queue cap snaps _after_ we've built the new snap contexts,\n\t * so that i_head_snapc can be set appropriately.\n\t */\n\twhile (!list_empty(&dirty_realms)) {\n\t\trealm = list_first_entry(&dirty_realms, struct ceph_snap_realm,\n\t\t\t\t\t dirty_item);\n\t\tqueue_realm_cap_snaps(realm);\n\t}\n\n\tif (realm_ret)\n\t\t*realm_ret = first_realm;\n\telse\n\t\tceph_put_snap_realm(mdsc, first_realm);\n\n\t__cleanup_empty_realms(mdsc);\n\treturn 0;\n\nbad:\n\terr = -EINVAL;\nfail:\n\tif (realm && !IS_ERR(realm))\n\t\tceph_put_snap_realm(mdsc, realm);\n\tif (first_realm)\n\t\tceph_put_snap_realm(mdsc, first_realm);\n\tpr_err(\"update_snap_trace error %d\\n\", err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "head->op"
          ],
          "line": 2437
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&mdsc->snap_rwsem"
          ],
          "line": 2434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_msg_dump",
          "args": [
            "msg"
          ],
          "line": 2427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"mdsc_handle_reply got corrupt reply mds%d(tid:%lld)\\n\"",
            "mds",
            "tid"
          ],
          "line": 2426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&session->s_mutex"
          ],
          "line": 2424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 2422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_reply_info",
          "args": [
            "msg",
            "rinfo",
            "session->s_con.peer_features"
          ],
          "line": 2421
        },
        "resolved": true,
        "details": {
          "function_name": "parse_reply_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "290-335",
          "snippet": "static int parse_reply_info(struct ceph_msg *msg,\n\t\t\t    struct ceph_mds_reply_info_parsed *info,\n\t\t\t    u64 features)\n{\n\tvoid *p, *end;\n\tu32 len;\n\tint err;\n\n\tinfo->head = msg->front.iov_base;\n\tp = msg->front.iov_base + sizeof(struct ceph_mds_reply_head);\n\tend = p + msg->front.iov_len - sizeof(struct ceph_mds_reply_head);\n\n\t/* trace */\n\tceph_decode_32_safe(&p, end, len, bad);\n\tif (len > 0) {\n\t\tceph_decode_need(&p, end, len, bad);\n\t\terr = parse_reply_info_trace(&p, p+len, info, features);\n\t\tif (err < 0)\n\t\t\tgoto out_bad;\n\t}\n\n\t/* extra */\n\tceph_decode_32_safe(&p, end, len, bad);\n\tif (len > 0) {\n\t\tceph_decode_need(&p, end, len, bad);\n\t\terr = parse_reply_info_extra(&p, p+len, info, features);\n\t\tif (err < 0)\n\t\t\tgoto out_bad;\n\t}\n\n\t/* snap blob */\n\tceph_decode_32_safe(&p, end, len, bad);\n\tinfo->snapblob_len = len;\n\tinfo->snapblob = p;\n\tp += len;\n\n\tif (p != end)\n\t\tgoto bad;\n\treturn 0;\n\nbad:\n\terr = -EIO;\nout_bad:\n\tpr_err(\"mds parse_reply err %d\\n\", err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);\n\nstatic int parse_reply_info(struct ceph_msg *msg,\n\t\t\t    struct ceph_mds_reply_info_parsed *info,\n\t\t\t    u64 features)\n{\n\tvoid *p, *end;\n\tu32 len;\n\tint err;\n\n\tinfo->head = msg->front.iov_base;\n\tp = msg->front.iov_base + sizeof(struct ceph_mds_reply_head);\n\tend = p + msg->front.iov_len - sizeof(struct ceph_mds_reply_head);\n\n\t/* trace */\n\tceph_decode_32_safe(&p, end, len, bad);\n\tif (len > 0) {\n\t\tceph_decode_need(&p, end, len, bad);\n\t\terr = parse_reply_info_trace(&p, p+len, info, features);\n\t\tif (err < 0)\n\t\t\tgoto out_bad;\n\t}\n\n\t/* extra */\n\tceph_decode_32_safe(&p, end, len, bad);\n\tif (len > 0) {\n\t\tceph_decode_need(&p, end, len, bad);\n\t\terr = parse_reply_info_extra(&p, p+len, info, features);\n\t\tif (err < 0)\n\t\t\tgoto out_bad;\n\t}\n\n\t/* snap blob */\n\tceph_decode_32_safe(&p, end, len, bad);\n\tinfo->snapblob_len = len;\n\tinfo->snapblob = p;\n\tp += len;\n\n\tif (p != end)\n\t\tgoto bad;\n\treturn 0;\n\nbad:\n\terr = -EIO;\nout_bad:\n\tpr_err(\"mds parse_reply err %d\\n\", err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"handle_reply tid %lld result %d\\n\"",
            "tid",
            "result"
          ],
          "line": 2419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&req->r_unsafe_item",
            "&req->r_session->s_unsafe"
          ],
          "line": 2416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 2411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "complete_all",
          "args": [
            "&mdsc->safe_umount_waiters"
          ],
          "line": 2410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_oldest_req",
          "args": [
            "mdsc"
          ],
          "line": 2409
        },
        "resolved": true,
        "details": {
          "function_name": "__get_oldest_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1672-1678",
          "snippet": "static struct ceph_mds_request *__get_oldest_req(struct ceph_mds_client *mdsc)\n{\n\tif (RB_EMPTY_ROOT(&mdsc->request_tree))\n\t\treturn NULL;\n\treturn rb_entry(rb_first(&mdsc->request_tree),\n\t\t\tstruct ceph_mds_request, r_node);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_mds_request *__get_oldest_req(struct ceph_mds_client *mdsc)\n{\n\tif (RB_EMPTY_ROOT(&mdsc->request_tree))\n\t\treturn NULL;\n\treturn rb_entry(rb_first(&mdsc->request_tree),\n\t\t\tstruct ceph_mds_request, r_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&req->r_unsafe_item"
          ],
          "line": 2406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"got safe reply %llu, mds%d\\n\"",
            "tid",
            "mds"
          ],
          "line": 2405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__unregister_request",
          "args": [
            "mdsc",
            "req"
          ],
          "line": 2395
        },
        "resolved": true,
        "details": {
          "function_name": "__unregister_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "643-664",
          "snippet": "static void __unregister_request(struct ceph_mds_client *mdsc,\n\t\t\t\t struct ceph_mds_request *req)\n{\n\tdout(\"__unregister_request %p tid %lld\\n\", req, req->r_tid);\n\trb_erase(&req->r_node, &mdsc->request_tree);\n\tRB_CLEAR_NODE(&req->r_node);\n\n\tif (req->r_unsafe_dir) {\n\t\tstruct ceph_inode_info *ci = ceph_inode(req->r_unsafe_dir);\n\n\t\tspin_lock(&ci->i_unsafe_lock);\n\t\tlist_del_init(&req->r_unsafe_dir_item);\n\t\tspin_unlock(&ci->i_unsafe_lock);\n\n\t\tiput(req->r_unsafe_dir);\n\t\treq->r_unsafe_dir = NULL;\n\t}\n\n\tcomplete_all(&req->r_safe_completion);\n\n\tceph_mdsc_put_request(req);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __unregister_request(struct ceph_mds_client *mdsc,\n\t\t\t\t struct ceph_mds_request *req)\n{\n\tdout(\"__unregister_request %p tid %lld\\n\", req, req->r_tid);\n\trb_erase(&req->r_node, &mdsc->request_tree);\n\tRB_CLEAR_NODE(&req->r_node);\n\n\tif (req->r_unsafe_dir) {\n\t\tstruct ceph_inode_info *ci = ceph_inode(req->r_unsafe_dir);\n\n\t\tspin_lock(&ci->i_unsafe_lock);\n\t\tlist_del_init(&req->r_unsafe_dir_item);\n\t\tspin_unlock(&ci->i_unsafe_lock);\n\n\t\tiput(req->r_unsafe_dir);\n\t\treq->r_unsafe_dir = NULL;\n\t}\n\n\tcomplete_all(&req->r_safe_completion);\n\n\tceph_mdsc_put_request(req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"have to return ESTALE on request %llu\"",
            "req->r_tid"
          ],
          "line": 2389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 2385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__do_request",
          "args": [
            "mdsc",
            "req"
          ],
          "line": 2384
        },
        "resolved": true,
        "details": {
          "function_name": "__do_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "2077-2150",
          "snippet": "static int __do_request(struct ceph_mds_client *mdsc,\n\t\t\tstruct ceph_mds_request *req)\n{\n\tstruct ceph_mds_session *session = NULL;\n\tint mds = -1;\n\tint err = -EAGAIN;\n\n\tif (req->r_err || req->r_got_result) {\n\t\tif (req->r_aborted)\n\t\t\t__unregister_request(mdsc, req);\n\t\tgoto out;\n\t}\n\n\tif (req->r_timeout &&\n\t    time_after_eq(jiffies, req->r_started + req->r_timeout)) {\n\t\tdout(\"do_request timed out\\n\");\n\t\terr = -EIO;\n\t\tgoto finish;\n\t}\n\n\tput_request_session(req);\n\n\tmds = __choose_mds(mdsc, req);\n\tif (mds < 0 ||\n\t    ceph_mdsmap_get_state(mdsc->mdsmap, mds) < CEPH_MDS_STATE_ACTIVE) {\n\t\tdout(\"do_request no mds or not active, waiting for map\\n\");\n\t\tlist_add(&req->r_wait, &mdsc->waiting_for_map);\n\t\tgoto out;\n\t}\n\n\t/* get, open session */\n\tsession = __ceph_lookup_mds_session(mdsc, mds);\n\tif (!session) {\n\t\tsession = register_session(mdsc, mds);\n\t\tif (IS_ERR(session)) {\n\t\t\terr = PTR_ERR(session);\n\t\t\tgoto finish;\n\t\t}\n\t}\n\treq->r_session = get_session(session);\n\n\tdout(\"do_request mds%d session %p state %s\\n\", mds, session,\n\t     ceph_session_state_name(session->s_state));\n\tif (session->s_state != CEPH_MDS_SESSION_OPEN &&\n\t    session->s_state != CEPH_MDS_SESSION_HUNG) {\n\t\tif (session->s_state == CEPH_MDS_SESSION_NEW ||\n\t\t    session->s_state == CEPH_MDS_SESSION_CLOSING)\n\t\t\t__open_session(mdsc, session);\n\t\tlist_add(&req->r_wait, &session->s_waiting);\n\t\tgoto out_session;\n\t}\n\n\t/* send request */\n\treq->r_resend_mds = -1;   /* forget any previous mds hint */\n\n\tif (req->r_request_started == 0)   /* note request start time */\n\t\treq->r_request_started = jiffies;\n\n\terr = __prepare_send_request(mdsc, req, mds);\n\tif (!err) {\n\t\tceph_msg_get(req->r_request);\n\t\tceph_con_send(&session->s_con, req->r_request);\n\t}\n\nout_session:\n\tceph_put_mds_session(session);\nout:\n\treturn err;\n\nfinish:\n\treq->r_err = err;\n\tcomplete_request(mdsc, req);\n\tgoto out;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __do_request(struct ceph_mds_client *mdsc,\n\t\t\tstruct ceph_mds_request *req)\n{\n\tstruct ceph_mds_session *session = NULL;\n\tint mds = -1;\n\tint err = -EAGAIN;\n\n\tif (req->r_err || req->r_got_result) {\n\t\tif (req->r_aborted)\n\t\t\t__unregister_request(mdsc, req);\n\t\tgoto out;\n\t}\n\n\tif (req->r_timeout &&\n\t    time_after_eq(jiffies, req->r_started + req->r_timeout)) {\n\t\tdout(\"do_request timed out\\n\");\n\t\terr = -EIO;\n\t\tgoto finish;\n\t}\n\n\tput_request_session(req);\n\n\tmds = __choose_mds(mdsc, req);\n\tif (mds < 0 ||\n\t    ceph_mdsmap_get_state(mdsc->mdsmap, mds) < CEPH_MDS_STATE_ACTIVE) {\n\t\tdout(\"do_request no mds or not active, waiting for map\\n\");\n\t\tlist_add(&req->r_wait, &mdsc->waiting_for_map);\n\t\tgoto out;\n\t}\n\n\t/* get, open session */\n\tsession = __ceph_lookup_mds_session(mdsc, mds);\n\tif (!session) {\n\t\tsession = register_session(mdsc, mds);\n\t\tif (IS_ERR(session)) {\n\t\t\terr = PTR_ERR(session);\n\t\t\tgoto finish;\n\t\t}\n\t}\n\treq->r_session = get_session(session);\n\n\tdout(\"do_request mds%d session %p state %s\\n\", mds, session,\n\t     ceph_session_state_name(session->s_state));\n\tif (session->s_state != CEPH_MDS_SESSION_OPEN &&\n\t    session->s_state != CEPH_MDS_SESSION_HUNG) {\n\t\tif (session->s_state == CEPH_MDS_SESSION_NEW ||\n\t\t    session->s_state == CEPH_MDS_SESSION_CLOSING)\n\t\t\t__open_session(mdsc, session);\n\t\tlist_add(&req->r_wait, &session->s_waiting);\n\t\tgoto out_session;\n\t}\n\n\t/* send request */\n\treq->r_resend_mds = -1;   /* forget any previous mds hint */\n\n\tif (req->r_request_started == 0)   /* note request start time */\n\t\treq->r_request_started = jiffies;\n\n\terr = __prepare_send_request(mdsc, req, mds);\n\tif (!err) {\n\t\tceph_msg_get(req->r_request);\n\t\tceph_con_send(&session->s_con, req->r_request);\n\t}\n\nout_session:\n\tceph_put_mds_session(session);\nout:\n\treturn err;\n\nfinish:\n\treq->r_err = err;\n\tcomplete_request(mdsc, req);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"but auth changed, so resending\""
          ],
          "line": 2383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__choose_mds",
          "args": [
            "mdsc",
            "req"
          ],
          "line": 2381
        },
        "resolved": true,
        "details": {
          "function_name": "__choose_mds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "687-809",
          "snippet": "static int __choose_mds(struct ceph_mds_client *mdsc,\n\t\t\tstruct ceph_mds_request *req)\n{\n\tstruct inode *inode;\n\tstruct ceph_inode_info *ci;\n\tstruct ceph_cap *cap;\n\tint mode = req->r_direct_mode;\n\tint mds = -1;\n\tu32 hash = req->r_direct_hash;\n\tbool is_hash = req->r_direct_is_hash;\n\n\t/*\n\t * is there a specific mds we should try?  ignore hint if we have\n\t * no session and the mds is not up (active or recovering).\n\t */\n\tif (req->r_resend_mds >= 0 &&\n\t    (__have_session(mdsc, req->r_resend_mds) ||\n\t     ceph_mdsmap_get_state(mdsc->mdsmap, req->r_resend_mds) > 0)) {\n\t\tdout(\"choose_mds using resend_mds mds%d\\n\",\n\t\t     req->r_resend_mds);\n\t\treturn req->r_resend_mds;\n\t}\n\n\tif (mode == USE_RANDOM_MDS)\n\t\tgoto random;\n\n\tinode = NULL;\n\tif (req->r_inode) {\n\t\tinode = req->r_inode;\n\t} else if (req->r_dentry) {\n\t\t/* ignore race with rename; old or new d_parent is okay */\n\t\tstruct dentry *parent = req->r_dentry->d_parent;\n\t\tstruct inode *dir = parent->d_inode;\n\n\t\tif (dir->i_sb != mdsc->fsc->sb) {\n\t\t\t/* not this fs! */\n\t\t\tinode = req->r_dentry->d_inode;\n\t\t} else if (ceph_snap(dir) != CEPH_NOSNAP) {\n\t\t\t/* direct snapped/virtual snapdir requests\n\t\t\t * based on parent dir inode */\n\t\t\tstruct dentry *dn = get_nonsnap_parent(parent);\n\t\t\tinode = dn->d_inode;\n\t\t\tdout(\"__choose_mds using nonsnap parent %p\\n\", inode);\n\t\t} else {\n\t\t\t/* dentry target */\n\t\t\tinode = req->r_dentry->d_inode;\n\t\t\tif (!inode || mode == USE_AUTH_MDS) {\n\t\t\t\t/* dir + name */\n\t\t\t\tinode = dir;\n\t\t\t\thash = ceph_dentry_hash(dir, req->r_dentry);\n\t\t\t\tis_hash = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tdout(\"__choose_mds %p is_hash=%d (%d) mode %d\\n\", inode, (int)is_hash,\n\t     (int)hash, mode);\n\tif (!inode)\n\t\tgoto random;\n\tci = ceph_inode(inode);\n\n\tif (is_hash && S_ISDIR(inode->i_mode)) {\n\t\tstruct ceph_inode_frag frag;\n\t\tint found;\n\n\t\tceph_choose_frag(ci, hash, &frag, &found);\n\t\tif (found) {\n\t\t\tif (mode == USE_ANY_MDS && frag.ndist > 0) {\n\t\t\t\tu8 r;\n\n\t\t\t\t/* choose a random replica */\n\t\t\t\tget_random_bytes(&r, 1);\n\t\t\t\tr %= frag.ndist;\n\t\t\t\tmds = frag.dist[r];\n\t\t\t\tdout(\"choose_mds %p %llx.%llx \"\n\t\t\t\t     \"frag %u mds%d (%d/%d)\\n\",\n\t\t\t\t     inode, ceph_vinop(inode),\n\t\t\t\t     frag.frag, mds,\n\t\t\t\t     (int)r, frag.ndist);\n\t\t\t\tif (ceph_mdsmap_get_state(mdsc->mdsmap, mds) >=\n\t\t\t\t    CEPH_MDS_STATE_ACTIVE)\n\t\t\t\t\treturn mds;\n\t\t\t}\n\n\t\t\t/* since this file/dir wasn't known to be\n\t\t\t * replicated, then we want to look for the\n\t\t\t * authoritative mds. */\n\t\t\tmode = USE_AUTH_MDS;\n\t\t\tif (frag.mds >= 0) {\n\t\t\t\t/* choose auth mds */\n\t\t\t\tmds = frag.mds;\n\t\t\t\tdout(\"choose_mds %p %llx.%llx \"\n\t\t\t\t     \"frag %u mds%d (auth)\\n\",\n\t\t\t\t     inode, ceph_vinop(inode), frag.frag, mds);\n\t\t\t\tif (ceph_mdsmap_get_state(mdsc->mdsmap, mds) >=\n\t\t\t\t    CEPH_MDS_STATE_ACTIVE)\n\t\t\t\t\treturn mds;\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_lock(&ci->i_ceph_lock);\n\tcap = NULL;\n\tif (mode == USE_AUTH_MDS)\n\t\tcap = ci->i_auth_cap;\n\tif (!cap && !RB_EMPTY_ROOT(&ci->i_caps))\n\t\tcap = rb_entry(rb_first(&ci->i_caps), struct ceph_cap, ci_node);\n\tif (!cap) {\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tgoto random;\n\t}\n\tmds = cap->session->s_mds;\n\tdout(\"choose_mds %p %llx.%llx mds%d (%scap %p)\\n\",\n\t     inode, ceph_vinop(inode), mds,\n\t     cap == ci->i_auth_cap ? \"auth \" : \"\", cap);\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn mds;\n\nrandom:\n\tmds = ceph_mdsmap_get_random_mds(mdsc->mdsmap);\n\tdout(\"choose_mds chose random mds%d\\n\", mds);\n\treturn mds;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __choose_mds(struct ceph_mds_client *mdsc,\n\t\t\tstruct ceph_mds_request *req)\n{\n\tstruct inode *inode;\n\tstruct ceph_inode_info *ci;\n\tstruct ceph_cap *cap;\n\tint mode = req->r_direct_mode;\n\tint mds = -1;\n\tu32 hash = req->r_direct_hash;\n\tbool is_hash = req->r_direct_is_hash;\n\n\t/*\n\t * is there a specific mds we should try?  ignore hint if we have\n\t * no session and the mds is not up (active or recovering).\n\t */\n\tif (req->r_resend_mds >= 0 &&\n\t    (__have_session(mdsc, req->r_resend_mds) ||\n\t     ceph_mdsmap_get_state(mdsc->mdsmap, req->r_resend_mds) > 0)) {\n\t\tdout(\"choose_mds using resend_mds mds%d\\n\",\n\t\t     req->r_resend_mds);\n\t\treturn req->r_resend_mds;\n\t}\n\n\tif (mode == USE_RANDOM_MDS)\n\t\tgoto random;\n\n\tinode = NULL;\n\tif (req->r_inode) {\n\t\tinode = req->r_inode;\n\t} else if (req->r_dentry) {\n\t\t/* ignore race with rename; old or new d_parent is okay */\n\t\tstruct dentry *parent = req->r_dentry->d_parent;\n\t\tstruct inode *dir = parent->d_inode;\n\n\t\tif (dir->i_sb != mdsc->fsc->sb) {\n\t\t\t/* not this fs! */\n\t\t\tinode = req->r_dentry->d_inode;\n\t\t} else if (ceph_snap(dir) != CEPH_NOSNAP) {\n\t\t\t/* direct snapped/virtual snapdir requests\n\t\t\t * based on parent dir inode */\n\t\t\tstruct dentry *dn = get_nonsnap_parent(parent);\n\t\t\tinode = dn->d_inode;\n\t\t\tdout(\"__choose_mds using nonsnap parent %p\\n\", inode);\n\t\t} else {\n\t\t\t/* dentry target */\n\t\t\tinode = req->r_dentry->d_inode;\n\t\t\tif (!inode || mode == USE_AUTH_MDS) {\n\t\t\t\t/* dir + name */\n\t\t\t\tinode = dir;\n\t\t\t\thash = ceph_dentry_hash(dir, req->r_dentry);\n\t\t\t\tis_hash = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tdout(\"__choose_mds %p is_hash=%d (%d) mode %d\\n\", inode, (int)is_hash,\n\t     (int)hash, mode);\n\tif (!inode)\n\t\tgoto random;\n\tci = ceph_inode(inode);\n\n\tif (is_hash && S_ISDIR(inode->i_mode)) {\n\t\tstruct ceph_inode_frag frag;\n\t\tint found;\n\n\t\tceph_choose_frag(ci, hash, &frag, &found);\n\t\tif (found) {\n\t\t\tif (mode == USE_ANY_MDS && frag.ndist > 0) {\n\t\t\t\tu8 r;\n\n\t\t\t\t/* choose a random replica */\n\t\t\t\tget_random_bytes(&r, 1);\n\t\t\t\tr %= frag.ndist;\n\t\t\t\tmds = frag.dist[r];\n\t\t\t\tdout(\"choose_mds %p %llx.%llx \"\n\t\t\t\t     \"frag %u mds%d (%d/%d)\\n\",\n\t\t\t\t     inode, ceph_vinop(inode),\n\t\t\t\t     frag.frag, mds,\n\t\t\t\t     (int)r, frag.ndist);\n\t\t\t\tif (ceph_mdsmap_get_state(mdsc->mdsmap, mds) >=\n\t\t\t\t    CEPH_MDS_STATE_ACTIVE)\n\t\t\t\t\treturn mds;\n\t\t\t}\n\n\t\t\t/* since this file/dir wasn't known to be\n\t\t\t * replicated, then we want to look for the\n\t\t\t * authoritative mds. */\n\t\t\tmode = USE_AUTH_MDS;\n\t\t\tif (frag.mds >= 0) {\n\t\t\t\t/* choose auth mds */\n\t\t\t\tmds = frag.mds;\n\t\t\t\tdout(\"choose_mds %p %llx.%llx \"\n\t\t\t\t     \"frag %u mds%d (auth)\\n\",\n\t\t\t\t     inode, ceph_vinop(inode), frag.frag, mds);\n\t\t\t\tif (ceph_mdsmap_get_state(mdsc->mdsmap, mds) >=\n\t\t\t\t    CEPH_MDS_STATE_ACTIVE)\n\t\t\t\t\treturn mds;\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_lock(&ci->i_ceph_lock);\n\tcap = NULL;\n\tif (mode == USE_AUTH_MDS)\n\t\tcap = ci->i_auth_cap;\n\tif (!cap && !RB_EMPTY_ROOT(&ci->i_caps))\n\t\tcap = rb_entry(rb_first(&ci->i_caps), struct ceph_cap, ci_node);\n\tif (!cap) {\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tgoto random;\n\t}\n\tmds = cap->session->s_mds;\n\tdout(\"choose_mds %p %llx.%llx mds%d (%scap %p)\\n\",\n\t     inode, ceph_vinop(inode), mds,\n\t     cap == ci->i_auth_cap ? \"auth \" : \"\", cap);\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn mds;\n\nrandom:\n\tmds = ceph_mdsmap_get_random_mds(mdsc->mdsmap);\n\tdout(\"choose_mds chose random mds%d\\n\", mds);\n\treturn mds;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 2378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"not using auth, setting for that now\""
          ],
          "line": 2375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"got ESTALE on request %llu\"",
            "req->r_tid"
          ],
          "line": 2372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 2358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"got unsafe after safe on %llu from mds%d\\n\"",
            "tid",
            "mds"
          ],
          "line": 2356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 2352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"got a dup %s reply on %llu from mds%d\\n\"",
            "head->safe ? \"safe\" : \"unsafe\"",
            "tid",
            "mds"
          ],
          "line": 2350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 2343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"mdsc_handle_reply got %llu on session mds%d\"\n\t\t       \" not mds%d\\n\"",
            "tid",
            "session->s_mds",
            "req->r_session ? req->r_session->s_mds : -1"
          ],
          "line": 2340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"handle_reply %p\\n\"",
            "req"
          ],
          "line": 2336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 2333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"handle_reply on unknown tid %llu\\n\"",
            "tid"
          ],
          "line": 2332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__lookup_request",
          "args": [
            "mdsc",
            "tid"
          ],
          "line": 2330
        },
        "resolved": true,
        "details": {
          "function_name": "__lookup_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "569-587",
          "snippet": "static struct ceph_mds_request *__lookup_request(struct ceph_mds_client *mdsc,\n\t\t\t\t\t     u64 tid)\n{\n\tstruct ceph_mds_request *req;\n\tstruct rb_node *n = mdsc->request_tree.rb_node;\n\n\twhile (n) {\n\t\treq = rb_entry(n, struct ceph_mds_request, r_node);\n\t\tif (tid < req->r_tid)\n\t\t\tn = n->rb_left;\n\t\telse if (tid > req->r_tid)\n\t\t\tn = n->rb_right;\n\t\telse {\n\t\t\tceph_mdsc_get_request(req);\n\t\t\treturn req;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_mds_request *__lookup_request(struct ceph_mds_client *mdsc,\n\t\t\t\t\t     u64 tid)\n{\n\tstruct ceph_mds_request *req;\n\tstruct rb_node *n = mdsc->request_tree.rb_node;\n\n\twhile (n) {\n\t\treq = rb_entry(n, struct ceph_mds_request, r_node);\n\t\tif (tid < req->r_tid)\n\t\t\tn = n->rb_left;\n\t\telse if (tid > req->r_tid)\n\t\t\tn = n->rb_right;\n\t\telse {\n\t\t\tceph_mdsc_get_request(req);\n\t\t\treturn req;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 2329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "msg->hdr.tid"
          ],
          "line": 2328
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_msg_dump",
          "args": [
            "msg"
          ],
          "line": 2323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"mdsc_handle_reply got corrupt (short) reply\\n\""
          ],
          "line": 2322
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);\n\nstatic void handle_reply(struct ceph_mds_session *session, struct ceph_msg *msg)\n{\n\tstruct ceph_mds_client *mdsc = session->s_mdsc;\n\tstruct ceph_mds_request *req;\n\tstruct ceph_mds_reply_head *head = msg->front.iov_base;\n\tstruct ceph_mds_reply_info_parsed *rinfo;  /* parsed reply info */\n\tstruct ceph_snap_realm *realm;\n\tu64 tid;\n\tint err, result;\n\tint mds = session->s_mds;\n\n\tif (msg->front.iov_len < sizeof(*head)) {\n\t\tpr_err(\"mdsc_handle_reply got corrupt (short) reply\\n\");\n\t\tceph_msg_dump(msg);\n\t\treturn;\n\t}\n\n\t/* get request, session */\n\ttid = le64_to_cpu(msg->hdr.tid);\n\tmutex_lock(&mdsc->mutex);\n\treq = __lookup_request(mdsc, tid);\n\tif (!req) {\n\t\tdout(\"handle_reply on unknown tid %llu\\n\", tid);\n\t\tmutex_unlock(&mdsc->mutex);\n\t\treturn;\n\t}\n\tdout(\"handle_reply %p\\n\", req);\n\n\t/* correct session? */\n\tif (req->r_session != session) {\n\t\tpr_err(\"mdsc_handle_reply got %llu on session mds%d\"\n\t\t       \" not mds%d\\n\", tid, session->s_mds,\n\t\t       req->r_session ? req->r_session->s_mds : -1);\n\t\tmutex_unlock(&mdsc->mutex);\n\t\tgoto out;\n\t}\n\n\t/* dup? */\n\tif ((req->r_got_unsafe && !head->safe) ||\n\t    (req->r_got_safe && head->safe)) {\n\t\tpr_warn(\"got a dup %s reply on %llu from mds%d\\n\",\n\t\t\t   head->safe ? \"safe\" : \"unsafe\", tid, mds);\n\t\tmutex_unlock(&mdsc->mutex);\n\t\tgoto out;\n\t}\n\tif (req->r_got_safe && !head->safe) {\n\t\tpr_warn(\"got unsafe after safe on %llu from mds%d\\n\",\n\t\t\t   tid, mds);\n\t\tmutex_unlock(&mdsc->mutex);\n\t\tgoto out;\n\t}\n\n\tresult = le32_to_cpu(head->result);\n\n\t/*\n\t * Handle an ESTALE\n\t * if we're not talking to the authority, send to them\n\t * if the authority has changed while we weren't looking,\n\t * send to new authority\n\t * Otherwise we just have to return an ESTALE\n\t */\n\tif (result == -ESTALE) {\n\t\tdout(\"got ESTALE on request %llu\", req->r_tid);\n\t\treq->r_resend_mds = -1;\n\t\tif (req->r_direct_mode != USE_AUTH_MDS) {\n\t\t\tdout(\"not using auth, setting for that now\");\n\t\t\treq->r_direct_mode = USE_AUTH_MDS;\n\t\t\t__do_request(mdsc, req);\n\t\t\tmutex_unlock(&mdsc->mutex);\n\t\t\tgoto out;\n\t\t} else  {\n\t\t\tint mds = __choose_mds(mdsc, req);\n\t\t\tif (mds >= 0 && mds != req->r_session->s_mds) {\n\t\t\t\tdout(\"but auth changed, so resending\");\n\t\t\t\t__do_request(mdsc, req);\n\t\t\t\tmutex_unlock(&mdsc->mutex);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tdout(\"have to return ESTALE on request %llu\", req->r_tid);\n\t}\n\n\n\tif (head->safe) {\n\t\treq->r_got_safe = true;\n\t\t__unregister_request(mdsc, req);\n\n\t\tif (req->r_got_unsafe) {\n\t\t\t/*\n\t\t\t * We already handled the unsafe response, now do the\n\t\t\t * cleanup.  No need to examine the response; the MDS\n\t\t\t * doesn't include any result info in the safe\n\t\t\t * response.  And even if it did, there is nothing\n\t\t\t * useful we could do with a revised return value.\n\t\t\t */\n\t\t\tdout(\"got safe reply %llu, mds%d\\n\", tid, mds);\n\t\t\tlist_del_init(&req->r_unsafe_item);\n\n\t\t\t/* last unsafe request during umount? */\n\t\t\tif (mdsc->stopping && !__get_oldest_req(mdsc))\n\t\t\t\tcomplete_all(&mdsc->safe_umount_waiters);\n\t\t\tmutex_unlock(&mdsc->mutex);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\treq->r_got_unsafe = true;\n\t\tlist_add_tail(&req->r_unsafe_item, &req->r_session->s_unsafe);\n\t}\n\n\tdout(\"handle_reply tid %lld result %d\\n\", tid, result);\n\trinfo = &req->r_reply_info;\n\terr = parse_reply_info(msg, rinfo, session->s_con.peer_features);\n\tmutex_unlock(&mdsc->mutex);\n\n\tmutex_lock(&session->s_mutex);\n\tif (err < 0) {\n\t\tpr_err(\"mdsc_handle_reply got corrupt reply mds%d(tid:%lld)\\n\", mds, tid);\n\t\tceph_msg_dump(msg);\n\t\tgoto out_err;\n\t}\n\n\t/* snap trace */\n\trealm = NULL;\n\tif (rinfo->snapblob_len) {\n\t\tdown_write(&mdsc->snap_rwsem);\n\t\tceph_update_snap_trace(mdsc, rinfo->snapblob,\n\t\t\t\trinfo->snapblob + rinfo->snapblob_len,\n\t\t\t\tle32_to_cpu(head->op) == CEPH_MDS_OP_RMSNAP,\n\t\t\t\t&realm);\n\t\tdowngrade_write(&mdsc->snap_rwsem);\n\t} else {\n\t\tdown_read(&mdsc->snap_rwsem);\n\t}\n\n\t/* insert trace into our cache */\n\tmutex_lock(&req->r_fill_mutex);\n\terr = ceph_fill_trace(mdsc->fsc->sb, req, req->r_session);\n\tif (err == 0) {\n\t\tif (result == 0 && (req->r_op == CEPH_MDS_OP_READDIR ||\n\t\t\t\t    req->r_op == CEPH_MDS_OP_LSSNAP))\n\t\t\tceph_readdir_prepopulate(req, req->r_session);\n\t\tceph_unreserve_caps(mdsc, &req->r_caps_reservation);\n\t}\n\tmutex_unlock(&req->r_fill_mutex);\n\n\tup_read(&mdsc->snap_rwsem);\n\tif (realm)\n\t\tceph_put_snap_realm(mdsc, realm);\nout_err:\n\tmutex_lock(&mdsc->mutex);\n\tif (!req->r_aborted) {\n\t\tif (err) {\n\t\t\treq->r_err = err;\n\t\t} else {\n\t\t\treq->r_reply = msg;\n\t\t\tceph_msg_get(msg);\n\t\t\treq->r_got_result = true;\n\t\t}\n\t} else {\n\t\tdout(\"reply arrived after request %lld was aborted\\n\", tid);\n\t}\n\tmutex_unlock(&mdsc->mutex);\n\n\tceph_add_cap_releases(mdsc, req->r_session);\n\tmutex_unlock(&session->s_mutex);\n\n\t/* kick calling process */\n\tcomplete_request(mdsc, req);\nout:\n\tceph_mdsc_put_request(req);\n\treturn;\n}"
  },
  {
    "function_name": "ceph_invalidate_dir_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "2290-2301",
    "snippet": "void ceph_invalidate_dir_request(struct ceph_mds_request *req)\n{\n\tstruct inode *inode = req->r_locked_dir;\n\n\tdout(\"invalidate_dir_request %p (complete, lease(s))\\n\", inode);\n\n\tceph_dir_clear_complete(inode);\n\tif (req->r_dentry)\n\t\tceph_invalidate_dentry_lease(req->r_dentry);\n\tif (req->r_old_dentry)\n\t\tceph_invalidate_dentry_lease(req->r_old_dentry);\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_invalidate_dentry_lease",
          "args": [
            "req->r_old_dentry"
          ],
          "line": 2300
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_invalidate_dentry_lease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/dir.c",
          "lines": "988-994",
          "snippet": "void ceph_invalidate_dentry_lease(struct dentry *dentry)\n{\n\tspin_lock(&dentry->d_lock);\n\tdentry->d_time = jiffies;\n\tceph_dentry(dentry)->lease_shared_gen = 0;\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/fs_struct.h>\n#include <linux/spinlock.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_invalidate_dentry_lease(struct dentry *dentry)\n{\n\tspin_lock(&dentry->d_lock);\n\tdentry->d_time = jiffies;\n\tceph_dentry(dentry)->lease_shared_gen = 0;\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_dir_clear_complete",
          "args": [
            "inode"
          ],
          "line": 2296
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_dir_clear_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "472-475",
          "snippet": "static inline void ceph_dir_clear_complete(struct inode *inode)\n{\n\t__ceph_dir_clear_complete(ceph_inode(inode));\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline void ceph_dir_clear_complete(struct inode *inode)\n{\n\t__ceph_dir_clear_complete(ceph_inode(inode));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"invalidate_dir_request %p (complete, lease(s))\\n\"",
            "inode"
          ],
          "line": 2294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_invalidate_dir_request(struct ceph_mds_request *req)\n{\n\tstruct inode *inode = req->r_locked_dir;\n\n\tdout(\"invalidate_dir_request %p (complete, lease(s))\\n\", inode);\n\n\tceph_dir_clear_complete(inode);\n\tif (req->r_dentry)\n\t\tceph_invalidate_dentry_lease(req->r_dentry);\n\tif (req->r_old_dentry)\n\t\tceph_invalidate_dentry_lease(req->r_old_dentry);\n}"
  },
  {
    "function_name": "ceph_mdsc_do_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "2212-2284",
    "snippet": "int ceph_mdsc_do_request(struct ceph_mds_client *mdsc,\n\t\t\t struct inode *dir,\n\t\t\t struct ceph_mds_request *req)\n{\n\tint err;\n\n\tdout(\"do_request on %p\\n\", req);\n\n\t/* take CAP_PIN refs for r_inode, r_locked_dir, r_old_dentry */\n\tif (req->r_inode)\n\t\tceph_get_cap_refs(ceph_inode(req->r_inode), CEPH_CAP_PIN);\n\tif (req->r_locked_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_locked_dir), CEPH_CAP_PIN);\n\tif (req->r_old_dentry_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_old_dentry_dir),\n\t\t\t\t  CEPH_CAP_PIN);\n\n\t/* issue */\n\tmutex_lock(&mdsc->mutex);\n\t__register_request(mdsc, req, dir);\n\t__do_request(mdsc, req);\n\n\tif (req->r_err) {\n\t\terr = req->r_err;\n\t\t__unregister_request(mdsc, req);\n\t\tdout(\"do_request early error %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\t/* wait */\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request waiting\\n\");\n\tif (req->r_timeout) {\n\t\terr = (long)wait_for_completion_killable_timeout(\n\t\t\t&req->r_completion, req->r_timeout);\n\t\tif (err == 0)\n\t\t\terr = -EIO;\n\t} else if (req->r_wait_for_completion) {\n\t\terr = req->r_wait_for_completion(mdsc, req);\n\t} else {\n\t\terr = wait_for_completion_killable(&req->r_completion);\n\t}\n\tdout(\"do_request waited, got %d\\n\", err);\n\tmutex_lock(&mdsc->mutex);\n\n\t/* only abort if we didn't race with a real reply */\n\tif (req->r_got_result) {\n\t\terr = le32_to_cpu(req->r_reply_info.head->result);\n\t} else if (err < 0) {\n\t\tdout(\"aborted request %lld with %d\\n\", req->r_tid, err);\n\n\t\t/*\n\t\t * ensure we aren't running concurrently with\n\t\t * ceph_fill_trace or ceph_readdir_prepopulate, which\n\t\t * rely on locks (dir mutex) held by our caller.\n\t\t */\n\t\tmutex_lock(&req->r_fill_mutex);\n\t\treq->r_err = err;\n\t\treq->r_aborted = true;\n\t\tmutex_unlock(&req->r_fill_mutex);\n\n\t\tif (req->r_locked_dir &&\n\t\t    (req->r_op & CEPH_MDS_OP_WRITE))\n\t\t\tceph_invalidate_dir_request(req);\n\t} else {\n\t\terr = req->r_err;\n\t}\n\nout:\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request %p done, result %d\\n\", req, err);\n\treturn err;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"do_request %p done, result %d\\n\"",
            "req",
            "err"
          ],
          "line": 2282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 2281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_invalidate_dir_request",
          "args": [
            "req"
          ],
          "line": 2275
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_invalidate_dir_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "2290-2301",
          "snippet": "void ceph_invalidate_dir_request(struct ceph_mds_request *req)\n{\n\tstruct inode *inode = req->r_locked_dir;\n\n\tdout(\"invalidate_dir_request %p (complete, lease(s))\\n\", inode);\n\n\tceph_dir_clear_complete(inode);\n\tif (req->r_dentry)\n\t\tceph_invalidate_dentry_lease(req->r_dentry);\n\tif (req->r_old_dentry)\n\t\tceph_invalidate_dentry_lease(req->r_old_dentry);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_invalidate_dir_request(struct ceph_mds_request *req)\n{\n\tstruct inode *inode = req->r_locked_dir;\n\n\tdout(\"invalidate_dir_request %p (complete, lease(s))\\n\", inode);\n\n\tceph_dir_clear_complete(inode);\n\tif (req->r_dentry)\n\t\tceph_invalidate_dentry_lease(req->r_dentry);\n\tif (req->r_old_dentry)\n\t\tceph_invalidate_dentry_lease(req->r_old_dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&req->r_fill_mutex"
          ],
          "line": 2271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&req->r_fill_mutex"
          ],
          "line": 2268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"aborted request %lld with %d\\n\"",
            "req->r_tid",
            "err"
          ],
          "line": 2261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "req->r_reply_info.head->result"
          ],
          "line": 2259
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 2255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"do_request waited, got %d\\n\"",
            "err"
          ],
          "line": 2254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_completion_killable",
          "args": [
            "&req->r_completion"
          ],
          "line": 2252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req->r_wait_for_completion",
          "args": [
            "mdsc",
            "req"
          ],
          "line": 2250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_completion_killable_timeout",
          "args": [
            "&req->r_completion",
            "req->r_timeout"
          ],
          "line": 2245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"do_request waiting\\n\""
          ],
          "line": 2243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 2242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"do_request early error %d\\n\"",
            "err"
          ],
          "line": 2237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__unregister_request",
          "args": [
            "mdsc",
            "req"
          ],
          "line": 2236
        },
        "resolved": true,
        "details": {
          "function_name": "__unregister_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "643-664",
          "snippet": "static void __unregister_request(struct ceph_mds_client *mdsc,\n\t\t\t\t struct ceph_mds_request *req)\n{\n\tdout(\"__unregister_request %p tid %lld\\n\", req, req->r_tid);\n\trb_erase(&req->r_node, &mdsc->request_tree);\n\tRB_CLEAR_NODE(&req->r_node);\n\n\tif (req->r_unsafe_dir) {\n\t\tstruct ceph_inode_info *ci = ceph_inode(req->r_unsafe_dir);\n\n\t\tspin_lock(&ci->i_unsafe_lock);\n\t\tlist_del_init(&req->r_unsafe_dir_item);\n\t\tspin_unlock(&ci->i_unsafe_lock);\n\n\t\tiput(req->r_unsafe_dir);\n\t\treq->r_unsafe_dir = NULL;\n\t}\n\n\tcomplete_all(&req->r_safe_completion);\n\n\tceph_mdsc_put_request(req);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __unregister_request(struct ceph_mds_client *mdsc,\n\t\t\t\t struct ceph_mds_request *req)\n{\n\tdout(\"__unregister_request %p tid %lld\\n\", req, req->r_tid);\n\trb_erase(&req->r_node, &mdsc->request_tree);\n\tRB_CLEAR_NODE(&req->r_node);\n\n\tif (req->r_unsafe_dir) {\n\t\tstruct ceph_inode_info *ci = ceph_inode(req->r_unsafe_dir);\n\n\t\tspin_lock(&ci->i_unsafe_lock);\n\t\tlist_del_init(&req->r_unsafe_dir_item);\n\t\tspin_unlock(&ci->i_unsafe_lock);\n\n\t\tiput(req->r_unsafe_dir);\n\t\treq->r_unsafe_dir = NULL;\n\t}\n\n\tcomplete_all(&req->r_safe_completion);\n\n\tceph_mdsc_put_request(req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__do_request",
          "args": [
            "mdsc",
            "req"
          ],
          "line": 2232
        },
        "resolved": true,
        "details": {
          "function_name": "__do_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "2077-2150",
          "snippet": "static int __do_request(struct ceph_mds_client *mdsc,\n\t\t\tstruct ceph_mds_request *req)\n{\n\tstruct ceph_mds_session *session = NULL;\n\tint mds = -1;\n\tint err = -EAGAIN;\n\n\tif (req->r_err || req->r_got_result) {\n\t\tif (req->r_aborted)\n\t\t\t__unregister_request(mdsc, req);\n\t\tgoto out;\n\t}\n\n\tif (req->r_timeout &&\n\t    time_after_eq(jiffies, req->r_started + req->r_timeout)) {\n\t\tdout(\"do_request timed out\\n\");\n\t\terr = -EIO;\n\t\tgoto finish;\n\t}\n\n\tput_request_session(req);\n\n\tmds = __choose_mds(mdsc, req);\n\tif (mds < 0 ||\n\t    ceph_mdsmap_get_state(mdsc->mdsmap, mds) < CEPH_MDS_STATE_ACTIVE) {\n\t\tdout(\"do_request no mds or not active, waiting for map\\n\");\n\t\tlist_add(&req->r_wait, &mdsc->waiting_for_map);\n\t\tgoto out;\n\t}\n\n\t/* get, open session */\n\tsession = __ceph_lookup_mds_session(mdsc, mds);\n\tif (!session) {\n\t\tsession = register_session(mdsc, mds);\n\t\tif (IS_ERR(session)) {\n\t\t\terr = PTR_ERR(session);\n\t\t\tgoto finish;\n\t\t}\n\t}\n\treq->r_session = get_session(session);\n\n\tdout(\"do_request mds%d session %p state %s\\n\", mds, session,\n\t     ceph_session_state_name(session->s_state));\n\tif (session->s_state != CEPH_MDS_SESSION_OPEN &&\n\t    session->s_state != CEPH_MDS_SESSION_HUNG) {\n\t\tif (session->s_state == CEPH_MDS_SESSION_NEW ||\n\t\t    session->s_state == CEPH_MDS_SESSION_CLOSING)\n\t\t\t__open_session(mdsc, session);\n\t\tlist_add(&req->r_wait, &session->s_waiting);\n\t\tgoto out_session;\n\t}\n\n\t/* send request */\n\treq->r_resend_mds = -1;   /* forget any previous mds hint */\n\n\tif (req->r_request_started == 0)   /* note request start time */\n\t\treq->r_request_started = jiffies;\n\n\terr = __prepare_send_request(mdsc, req, mds);\n\tif (!err) {\n\t\tceph_msg_get(req->r_request);\n\t\tceph_con_send(&session->s_con, req->r_request);\n\t}\n\nout_session:\n\tceph_put_mds_session(session);\nout:\n\treturn err;\n\nfinish:\n\treq->r_err = err;\n\tcomplete_request(mdsc, req);\n\tgoto out;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __do_request(struct ceph_mds_client *mdsc,\n\t\t\tstruct ceph_mds_request *req)\n{\n\tstruct ceph_mds_session *session = NULL;\n\tint mds = -1;\n\tint err = -EAGAIN;\n\n\tif (req->r_err || req->r_got_result) {\n\t\tif (req->r_aborted)\n\t\t\t__unregister_request(mdsc, req);\n\t\tgoto out;\n\t}\n\n\tif (req->r_timeout &&\n\t    time_after_eq(jiffies, req->r_started + req->r_timeout)) {\n\t\tdout(\"do_request timed out\\n\");\n\t\terr = -EIO;\n\t\tgoto finish;\n\t}\n\n\tput_request_session(req);\n\n\tmds = __choose_mds(mdsc, req);\n\tif (mds < 0 ||\n\t    ceph_mdsmap_get_state(mdsc->mdsmap, mds) < CEPH_MDS_STATE_ACTIVE) {\n\t\tdout(\"do_request no mds or not active, waiting for map\\n\");\n\t\tlist_add(&req->r_wait, &mdsc->waiting_for_map);\n\t\tgoto out;\n\t}\n\n\t/* get, open session */\n\tsession = __ceph_lookup_mds_session(mdsc, mds);\n\tif (!session) {\n\t\tsession = register_session(mdsc, mds);\n\t\tif (IS_ERR(session)) {\n\t\t\terr = PTR_ERR(session);\n\t\t\tgoto finish;\n\t\t}\n\t}\n\treq->r_session = get_session(session);\n\n\tdout(\"do_request mds%d session %p state %s\\n\", mds, session,\n\t     ceph_session_state_name(session->s_state));\n\tif (session->s_state != CEPH_MDS_SESSION_OPEN &&\n\t    session->s_state != CEPH_MDS_SESSION_HUNG) {\n\t\tif (session->s_state == CEPH_MDS_SESSION_NEW ||\n\t\t    session->s_state == CEPH_MDS_SESSION_CLOSING)\n\t\t\t__open_session(mdsc, session);\n\t\tlist_add(&req->r_wait, &session->s_waiting);\n\t\tgoto out_session;\n\t}\n\n\t/* send request */\n\treq->r_resend_mds = -1;   /* forget any previous mds hint */\n\n\tif (req->r_request_started == 0)   /* note request start time */\n\t\treq->r_request_started = jiffies;\n\n\terr = __prepare_send_request(mdsc, req, mds);\n\tif (!err) {\n\t\tceph_msg_get(req->r_request);\n\t\tceph_con_send(&session->s_con, req->r_request);\n\t}\n\nout_session:\n\tceph_put_mds_session(session);\nout:\n\treturn err;\n\nfinish:\n\treq->r_err = err;\n\tcomplete_request(mdsc, req);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__register_request",
          "args": [
            "mdsc",
            "req",
            "dir"
          ],
          "line": 2231
        },
        "resolved": true,
        "details": {
          "function_name": "__register_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "617-641",
          "snippet": "static void __register_request(struct ceph_mds_client *mdsc,\n\t\t\t       struct ceph_mds_request *req,\n\t\t\t       struct inode *dir)\n{\n\treq->r_tid = ++mdsc->last_tid;\n\tif (req->r_num_caps)\n\t\tceph_reserve_caps(mdsc, &req->r_caps_reservation,\n\t\t\t\t  req->r_num_caps);\n\tdout(\"__register_request %p tid %lld\\n\", req, req->r_tid);\n\tceph_mdsc_get_request(req);\n\t__insert_request(mdsc, req);\n\n\treq->r_uid = current_fsuid();\n\treq->r_gid = current_fsgid();\n\n\tif (dir) {\n\t\tstruct ceph_inode_info *ci = ceph_inode(dir);\n\n\t\tihold(dir);\n\t\tspin_lock(&ci->i_unsafe_lock);\n\t\treq->r_unsafe_dir = dir;\n\t\tlist_add_tail(&req->r_unsafe_dir_item, &ci->i_unsafe_dirops);\n\t\tspin_unlock(&ci->i_unsafe_lock);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __register_request(struct ceph_mds_client *mdsc,\n\t\t\t       struct ceph_mds_request *req,\n\t\t\t       struct inode *dir)\n{\n\treq->r_tid = ++mdsc->last_tid;\n\tif (req->r_num_caps)\n\t\tceph_reserve_caps(mdsc, &req->r_caps_reservation,\n\t\t\t\t  req->r_num_caps);\n\tdout(\"__register_request %p tid %lld\\n\", req, req->r_tid);\n\tceph_mdsc_get_request(req);\n\t__insert_request(mdsc, req);\n\n\treq->r_uid = current_fsuid();\n\treq->r_gid = current_fsgid();\n\n\tif (dir) {\n\t\tstruct ceph_inode_info *ci = ceph_inode(dir);\n\n\t\tihold(dir);\n\t\tspin_lock(&ci->i_unsafe_lock);\n\t\treq->r_unsafe_dir = dir;\n\t\tlist_add_tail(&req->r_unsafe_dir_item, &ci->i_unsafe_dirops);\n\t\tspin_unlock(&ci->i_unsafe_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 2230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_get_cap_refs",
          "args": [
            "ceph_inode(req->r_old_dentry_dir)",
            "CEPH_CAP_PIN"
          ],
          "line": 2226
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_get_cap_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "2258-2263",
          "snippet": "void ceph_get_cap_refs(struct ceph_inode_info *ci, int caps)\n{\n\tspin_lock(&ci->i_ceph_lock);\n\t__take_cap_refs(ci, caps);\n\tspin_unlock(&ci->i_ceph_lock);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_get_cap_refs(struct ceph_inode_info *ci, int caps)\n{\n\tspin_lock(&ci->i_ceph_lock);\n\t__take_cap_refs(ci, caps);\n\tspin_unlock(&ci->i_ceph_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "req->r_old_dentry_dir"
          ],
          "line": 2226
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"do_request on %p\\n\"",
            "req"
          ],
          "line": 2218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);\n\nint ceph_mdsc_do_request(struct ceph_mds_client *mdsc,\n\t\t\t struct inode *dir,\n\t\t\t struct ceph_mds_request *req)\n{\n\tint err;\n\n\tdout(\"do_request on %p\\n\", req);\n\n\t/* take CAP_PIN refs for r_inode, r_locked_dir, r_old_dentry */\n\tif (req->r_inode)\n\t\tceph_get_cap_refs(ceph_inode(req->r_inode), CEPH_CAP_PIN);\n\tif (req->r_locked_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_locked_dir), CEPH_CAP_PIN);\n\tif (req->r_old_dentry_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_old_dentry_dir),\n\t\t\t\t  CEPH_CAP_PIN);\n\n\t/* issue */\n\tmutex_lock(&mdsc->mutex);\n\t__register_request(mdsc, req, dir);\n\t__do_request(mdsc, req);\n\n\tif (req->r_err) {\n\t\terr = req->r_err;\n\t\t__unregister_request(mdsc, req);\n\t\tdout(\"do_request early error %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\t/* wait */\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request waiting\\n\");\n\tif (req->r_timeout) {\n\t\terr = (long)wait_for_completion_killable_timeout(\n\t\t\t&req->r_completion, req->r_timeout);\n\t\tif (err == 0)\n\t\t\terr = -EIO;\n\t} else if (req->r_wait_for_completion) {\n\t\terr = req->r_wait_for_completion(mdsc, req);\n\t} else {\n\t\terr = wait_for_completion_killable(&req->r_completion);\n\t}\n\tdout(\"do_request waited, got %d\\n\", err);\n\tmutex_lock(&mdsc->mutex);\n\n\t/* only abort if we didn't race with a real reply */\n\tif (req->r_got_result) {\n\t\terr = le32_to_cpu(req->r_reply_info.head->result);\n\t} else if (err < 0) {\n\t\tdout(\"aborted request %lld with %d\\n\", req->r_tid, err);\n\n\t\t/*\n\t\t * ensure we aren't running concurrently with\n\t\t * ceph_fill_trace or ceph_readdir_prepopulate, which\n\t\t * rely on locks (dir mutex) held by our caller.\n\t\t */\n\t\tmutex_lock(&req->r_fill_mutex);\n\t\treq->r_err = err;\n\t\treq->r_aborted = true;\n\t\tmutex_unlock(&req->r_fill_mutex);\n\n\t\tif (req->r_locked_dir &&\n\t\t    (req->r_op & CEPH_MDS_OP_WRITE))\n\t\t\tceph_invalidate_dir_request(req);\n\t} else {\n\t\terr = req->r_err;\n\t}\n\nout:\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request %p done, result %d\\n\", req, err);\n\treturn err;\n}"
  },
  {
    "function_name": "ceph_mdsc_submit_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "2198-2206",
    "snippet": "void ceph_mdsc_submit_request(struct ceph_mds_client *mdsc,\n\t\t\t      struct ceph_mds_request *req)\n{\n\tdout(\"submit_request on %p\\n\", req);\n\tmutex_lock(&mdsc->mutex);\n\t__register_request(mdsc, req, NULL);\n\t__do_request(mdsc, req);\n\tmutex_unlock(&mdsc->mutex);\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 2205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__do_request",
          "args": [
            "mdsc",
            "req"
          ],
          "line": 2204
        },
        "resolved": true,
        "details": {
          "function_name": "__do_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "2077-2150",
          "snippet": "static int __do_request(struct ceph_mds_client *mdsc,\n\t\t\tstruct ceph_mds_request *req)\n{\n\tstruct ceph_mds_session *session = NULL;\n\tint mds = -1;\n\tint err = -EAGAIN;\n\n\tif (req->r_err || req->r_got_result) {\n\t\tif (req->r_aborted)\n\t\t\t__unregister_request(mdsc, req);\n\t\tgoto out;\n\t}\n\n\tif (req->r_timeout &&\n\t    time_after_eq(jiffies, req->r_started + req->r_timeout)) {\n\t\tdout(\"do_request timed out\\n\");\n\t\terr = -EIO;\n\t\tgoto finish;\n\t}\n\n\tput_request_session(req);\n\n\tmds = __choose_mds(mdsc, req);\n\tif (mds < 0 ||\n\t    ceph_mdsmap_get_state(mdsc->mdsmap, mds) < CEPH_MDS_STATE_ACTIVE) {\n\t\tdout(\"do_request no mds or not active, waiting for map\\n\");\n\t\tlist_add(&req->r_wait, &mdsc->waiting_for_map);\n\t\tgoto out;\n\t}\n\n\t/* get, open session */\n\tsession = __ceph_lookup_mds_session(mdsc, mds);\n\tif (!session) {\n\t\tsession = register_session(mdsc, mds);\n\t\tif (IS_ERR(session)) {\n\t\t\terr = PTR_ERR(session);\n\t\t\tgoto finish;\n\t\t}\n\t}\n\treq->r_session = get_session(session);\n\n\tdout(\"do_request mds%d session %p state %s\\n\", mds, session,\n\t     ceph_session_state_name(session->s_state));\n\tif (session->s_state != CEPH_MDS_SESSION_OPEN &&\n\t    session->s_state != CEPH_MDS_SESSION_HUNG) {\n\t\tif (session->s_state == CEPH_MDS_SESSION_NEW ||\n\t\t    session->s_state == CEPH_MDS_SESSION_CLOSING)\n\t\t\t__open_session(mdsc, session);\n\t\tlist_add(&req->r_wait, &session->s_waiting);\n\t\tgoto out_session;\n\t}\n\n\t/* send request */\n\treq->r_resend_mds = -1;   /* forget any previous mds hint */\n\n\tif (req->r_request_started == 0)   /* note request start time */\n\t\treq->r_request_started = jiffies;\n\n\terr = __prepare_send_request(mdsc, req, mds);\n\tif (!err) {\n\t\tceph_msg_get(req->r_request);\n\t\tceph_con_send(&session->s_con, req->r_request);\n\t}\n\nout_session:\n\tceph_put_mds_session(session);\nout:\n\treturn err;\n\nfinish:\n\treq->r_err = err;\n\tcomplete_request(mdsc, req);\n\tgoto out;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __do_request(struct ceph_mds_client *mdsc,\n\t\t\tstruct ceph_mds_request *req)\n{\n\tstruct ceph_mds_session *session = NULL;\n\tint mds = -1;\n\tint err = -EAGAIN;\n\n\tif (req->r_err || req->r_got_result) {\n\t\tif (req->r_aborted)\n\t\t\t__unregister_request(mdsc, req);\n\t\tgoto out;\n\t}\n\n\tif (req->r_timeout &&\n\t    time_after_eq(jiffies, req->r_started + req->r_timeout)) {\n\t\tdout(\"do_request timed out\\n\");\n\t\terr = -EIO;\n\t\tgoto finish;\n\t}\n\n\tput_request_session(req);\n\n\tmds = __choose_mds(mdsc, req);\n\tif (mds < 0 ||\n\t    ceph_mdsmap_get_state(mdsc->mdsmap, mds) < CEPH_MDS_STATE_ACTIVE) {\n\t\tdout(\"do_request no mds or not active, waiting for map\\n\");\n\t\tlist_add(&req->r_wait, &mdsc->waiting_for_map);\n\t\tgoto out;\n\t}\n\n\t/* get, open session */\n\tsession = __ceph_lookup_mds_session(mdsc, mds);\n\tif (!session) {\n\t\tsession = register_session(mdsc, mds);\n\t\tif (IS_ERR(session)) {\n\t\t\terr = PTR_ERR(session);\n\t\t\tgoto finish;\n\t\t}\n\t}\n\treq->r_session = get_session(session);\n\n\tdout(\"do_request mds%d session %p state %s\\n\", mds, session,\n\t     ceph_session_state_name(session->s_state));\n\tif (session->s_state != CEPH_MDS_SESSION_OPEN &&\n\t    session->s_state != CEPH_MDS_SESSION_HUNG) {\n\t\tif (session->s_state == CEPH_MDS_SESSION_NEW ||\n\t\t    session->s_state == CEPH_MDS_SESSION_CLOSING)\n\t\t\t__open_session(mdsc, session);\n\t\tlist_add(&req->r_wait, &session->s_waiting);\n\t\tgoto out_session;\n\t}\n\n\t/* send request */\n\treq->r_resend_mds = -1;   /* forget any previous mds hint */\n\n\tif (req->r_request_started == 0)   /* note request start time */\n\t\treq->r_request_started = jiffies;\n\n\terr = __prepare_send_request(mdsc, req, mds);\n\tif (!err) {\n\t\tceph_msg_get(req->r_request);\n\t\tceph_con_send(&session->s_con, req->r_request);\n\t}\n\nout_session:\n\tceph_put_mds_session(session);\nout:\n\treturn err;\n\nfinish:\n\treq->r_err = err;\n\tcomplete_request(mdsc, req);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__register_request",
          "args": [
            "mdsc",
            "req",
            "NULL"
          ],
          "line": 2203
        },
        "resolved": true,
        "details": {
          "function_name": "__register_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "617-641",
          "snippet": "static void __register_request(struct ceph_mds_client *mdsc,\n\t\t\t       struct ceph_mds_request *req,\n\t\t\t       struct inode *dir)\n{\n\treq->r_tid = ++mdsc->last_tid;\n\tif (req->r_num_caps)\n\t\tceph_reserve_caps(mdsc, &req->r_caps_reservation,\n\t\t\t\t  req->r_num_caps);\n\tdout(\"__register_request %p tid %lld\\n\", req, req->r_tid);\n\tceph_mdsc_get_request(req);\n\t__insert_request(mdsc, req);\n\n\treq->r_uid = current_fsuid();\n\treq->r_gid = current_fsgid();\n\n\tif (dir) {\n\t\tstruct ceph_inode_info *ci = ceph_inode(dir);\n\n\t\tihold(dir);\n\t\tspin_lock(&ci->i_unsafe_lock);\n\t\treq->r_unsafe_dir = dir;\n\t\tlist_add_tail(&req->r_unsafe_dir_item, &ci->i_unsafe_dirops);\n\t\tspin_unlock(&ci->i_unsafe_lock);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __register_request(struct ceph_mds_client *mdsc,\n\t\t\t       struct ceph_mds_request *req,\n\t\t\t       struct inode *dir)\n{\n\treq->r_tid = ++mdsc->last_tid;\n\tif (req->r_num_caps)\n\t\tceph_reserve_caps(mdsc, &req->r_caps_reservation,\n\t\t\t\t  req->r_num_caps);\n\tdout(\"__register_request %p tid %lld\\n\", req, req->r_tid);\n\tceph_mdsc_get_request(req);\n\t__insert_request(mdsc, req);\n\n\treq->r_uid = current_fsuid();\n\treq->r_gid = current_fsgid();\n\n\tif (dir) {\n\t\tstruct ceph_inode_info *ci = ceph_inode(dir);\n\n\t\tihold(dir);\n\t\tspin_lock(&ci->i_unsafe_lock);\n\t\treq->r_unsafe_dir = dir;\n\t\tlist_add_tail(&req->r_unsafe_dir_item, &ci->i_unsafe_dirops);\n\t\tspin_unlock(&ci->i_unsafe_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 2202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"submit_request on %p\\n\"",
            "req"
          ],
          "line": 2201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_mdsc_submit_request(struct ceph_mds_client *mdsc,\n\t\t\t      struct ceph_mds_request *req)\n{\n\tdout(\"submit_request on %p\\n\", req);\n\tmutex_lock(&mdsc->mutex);\n\t__register_request(mdsc, req, NULL);\n\t__do_request(mdsc, req);\n\tmutex_unlock(&mdsc->mutex);\n}"
  },
  {
    "function_name": "kick_requests",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "2176-2196",
    "snippet": "static void kick_requests(struct ceph_mds_client *mdsc, int mds)\n{\n\tstruct ceph_mds_request *req;\n\tstruct rb_node *p = rb_first(&mdsc->request_tree);\n\n\tdout(\"kick_requests mds%d\\n\", mds);\n\twhile (p) {\n\t\treq = rb_entry(p, struct ceph_mds_request, r_node);\n\t\tp = rb_next(p);\n\t\tif (req->r_got_unsafe)\n\t\t\tcontinue;\n\t\tif (req->r_attempts > 0)\n\t\t\tcontinue; /* only new requests */\n\t\tif (req->r_session &&\n\t\t    req->r_session->s_mds == mds) {\n\t\t\tdout(\" kicking tid %llu\\n\", req->r_tid);\n\t\t\tlist_del_init(&req->r_wait);\n\t\t\t__do_request(mdsc, req);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__do_request",
          "args": [
            "mdsc",
            "req"
          ],
          "line": 2193
        },
        "resolved": true,
        "details": {
          "function_name": "__do_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "2077-2150",
          "snippet": "static int __do_request(struct ceph_mds_client *mdsc,\n\t\t\tstruct ceph_mds_request *req)\n{\n\tstruct ceph_mds_session *session = NULL;\n\tint mds = -1;\n\tint err = -EAGAIN;\n\n\tif (req->r_err || req->r_got_result) {\n\t\tif (req->r_aborted)\n\t\t\t__unregister_request(mdsc, req);\n\t\tgoto out;\n\t}\n\n\tif (req->r_timeout &&\n\t    time_after_eq(jiffies, req->r_started + req->r_timeout)) {\n\t\tdout(\"do_request timed out\\n\");\n\t\terr = -EIO;\n\t\tgoto finish;\n\t}\n\n\tput_request_session(req);\n\n\tmds = __choose_mds(mdsc, req);\n\tif (mds < 0 ||\n\t    ceph_mdsmap_get_state(mdsc->mdsmap, mds) < CEPH_MDS_STATE_ACTIVE) {\n\t\tdout(\"do_request no mds or not active, waiting for map\\n\");\n\t\tlist_add(&req->r_wait, &mdsc->waiting_for_map);\n\t\tgoto out;\n\t}\n\n\t/* get, open session */\n\tsession = __ceph_lookup_mds_session(mdsc, mds);\n\tif (!session) {\n\t\tsession = register_session(mdsc, mds);\n\t\tif (IS_ERR(session)) {\n\t\t\terr = PTR_ERR(session);\n\t\t\tgoto finish;\n\t\t}\n\t}\n\treq->r_session = get_session(session);\n\n\tdout(\"do_request mds%d session %p state %s\\n\", mds, session,\n\t     ceph_session_state_name(session->s_state));\n\tif (session->s_state != CEPH_MDS_SESSION_OPEN &&\n\t    session->s_state != CEPH_MDS_SESSION_HUNG) {\n\t\tif (session->s_state == CEPH_MDS_SESSION_NEW ||\n\t\t    session->s_state == CEPH_MDS_SESSION_CLOSING)\n\t\t\t__open_session(mdsc, session);\n\t\tlist_add(&req->r_wait, &session->s_waiting);\n\t\tgoto out_session;\n\t}\n\n\t/* send request */\n\treq->r_resend_mds = -1;   /* forget any previous mds hint */\n\n\tif (req->r_request_started == 0)   /* note request start time */\n\t\treq->r_request_started = jiffies;\n\n\terr = __prepare_send_request(mdsc, req, mds);\n\tif (!err) {\n\t\tceph_msg_get(req->r_request);\n\t\tceph_con_send(&session->s_con, req->r_request);\n\t}\n\nout_session:\n\tceph_put_mds_session(session);\nout:\n\treturn err;\n\nfinish:\n\treq->r_err = err;\n\tcomplete_request(mdsc, req);\n\tgoto out;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __do_request(struct ceph_mds_client *mdsc,\n\t\t\tstruct ceph_mds_request *req)\n{\n\tstruct ceph_mds_session *session = NULL;\n\tint mds = -1;\n\tint err = -EAGAIN;\n\n\tif (req->r_err || req->r_got_result) {\n\t\tif (req->r_aborted)\n\t\t\t__unregister_request(mdsc, req);\n\t\tgoto out;\n\t}\n\n\tif (req->r_timeout &&\n\t    time_after_eq(jiffies, req->r_started + req->r_timeout)) {\n\t\tdout(\"do_request timed out\\n\");\n\t\terr = -EIO;\n\t\tgoto finish;\n\t}\n\n\tput_request_session(req);\n\n\tmds = __choose_mds(mdsc, req);\n\tif (mds < 0 ||\n\t    ceph_mdsmap_get_state(mdsc->mdsmap, mds) < CEPH_MDS_STATE_ACTIVE) {\n\t\tdout(\"do_request no mds or not active, waiting for map\\n\");\n\t\tlist_add(&req->r_wait, &mdsc->waiting_for_map);\n\t\tgoto out;\n\t}\n\n\t/* get, open session */\n\tsession = __ceph_lookup_mds_session(mdsc, mds);\n\tif (!session) {\n\t\tsession = register_session(mdsc, mds);\n\t\tif (IS_ERR(session)) {\n\t\t\terr = PTR_ERR(session);\n\t\t\tgoto finish;\n\t\t}\n\t}\n\treq->r_session = get_session(session);\n\n\tdout(\"do_request mds%d session %p state %s\\n\", mds, session,\n\t     ceph_session_state_name(session->s_state));\n\tif (session->s_state != CEPH_MDS_SESSION_OPEN &&\n\t    session->s_state != CEPH_MDS_SESSION_HUNG) {\n\t\tif (session->s_state == CEPH_MDS_SESSION_NEW ||\n\t\t    session->s_state == CEPH_MDS_SESSION_CLOSING)\n\t\t\t__open_session(mdsc, session);\n\t\tlist_add(&req->r_wait, &session->s_waiting);\n\t\tgoto out_session;\n\t}\n\n\t/* send request */\n\treq->r_resend_mds = -1;   /* forget any previous mds hint */\n\n\tif (req->r_request_started == 0)   /* note request start time */\n\t\treq->r_request_started = jiffies;\n\n\terr = __prepare_send_request(mdsc, req, mds);\n\tif (!err) {\n\t\tceph_msg_get(req->r_request);\n\t\tceph_con_send(&session->s_con, req->r_request);\n\t}\n\nout_session:\n\tceph_put_mds_session(session);\nout:\n\treturn err;\n\nfinish:\n\treq->r_err = err;\n\tcomplete_request(mdsc, req);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&req->r_wait"
          ],
          "line": 2192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" kicking tid %llu\\n\"",
            "req->r_tid"
          ],
          "line": 2191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "p"
          ],
          "line": 2184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "p",
            "structceph_mds_request",
            "r_node"
          ],
          "line": 2183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"kick_requests mds%d\\n\"",
            "mds"
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&mdsc->request_tree"
          ],
          "line": 2179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void kick_requests(struct ceph_mds_client *mdsc, int mds)\n{\n\tstruct ceph_mds_request *req;\n\tstruct rb_node *p = rb_first(&mdsc->request_tree);\n\n\tdout(\"kick_requests mds%d\\n\", mds);\n\twhile (p) {\n\t\treq = rb_entry(p, struct ceph_mds_request, r_node);\n\t\tp = rb_next(p);\n\t\tif (req->r_got_unsafe)\n\t\t\tcontinue;\n\t\tif (req->r_attempts > 0)\n\t\t\tcontinue; /* only new requests */\n\t\tif (req->r_session &&\n\t\t    req->r_session->s_mds == mds) {\n\t\t\tdout(\" kicking tid %llu\\n\", req->r_tid);\n\t\t\tlist_del_init(&req->r_wait);\n\t\t\t__do_request(mdsc, req);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "__wake_requests",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "2155-2170",
    "snippet": "static void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head)\n{\n\tstruct ceph_mds_request *req;\n\tLIST_HEAD(tmp_list);\n\n\tlist_splice_init(head, &tmp_list);\n\n\twhile (!list_empty(&tmp_list)) {\n\t\treq = list_entry(tmp_list.next,\n\t\t\t\t struct ceph_mds_request, r_wait);\n\t\tlist_del_init(&req->r_wait);\n\t\tdout(\" wake request %p tid %llu\\n\", req, req->r_tid);\n\t\t__do_request(mdsc, req);\n\t}\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__do_request",
          "args": [
            "mdsc",
            "req"
          ],
          "line": 2168
        },
        "resolved": true,
        "details": {
          "function_name": "__do_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "2077-2150",
          "snippet": "static int __do_request(struct ceph_mds_client *mdsc,\n\t\t\tstruct ceph_mds_request *req)\n{\n\tstruct ceph_mds_session *session = NULL;\n\tint mds = -1;\n\tint err = -EAGAIN;\n\n\tif (req->r_err || req->r_got_result) {\n\t\tif (req->r_aborted)\n\t\t\t__unregister_request(mdsc, req);\n\t\tgoto out;\n\t}\n\n\tif (req->r_timeout &&\n\t    time_after_eq(jiffies, req->r_started + req->r_timeout)) {\n\t\tdout(\"do_request timed out\\n\");\n\t\terr = -EIO;\n\t\tgoto finish;\n\t}\n\n\tput_request_session(req);\n\n\tmds = __choose_mds(mdsc, req);\n\tif (mds < 0 ||\n\t    ceph_mdsmap_get_state(mdsc->mdsmap, mds) < CEPH_MDS_STATE_ACTIVE) {\n\t\tdout(\"do_request no mds or not active, waiting for map\\n\");\n\t\tlist_add(&req->r_wait, &mdsc->waiting_for_map);\n\t\tgoto out;\n\t}\n\n\t/* get, open session */\n\tsession = __ceph_lookup_mds_session(mdsc, mds);\n\tif (!session) {\n\t\tsession = register_session(mdsc, mds);\n\t\tif (IS_ERR(session)) {\n\t\t\terr = PTR_ERR(session);\n\t\t\tgoto finish;\n\t\t}\n\t}\n\treq->r_session = get_session(session);\n\n\tdout(\"do_request mds%d session %p state %s\\n\", mds, session,\n\t     ceph_session_state_name(session->s_state));\n\tif (session->s_state != CEPH_MDS_SESSION_OPEN &&\n\t    session->s_state != CEPH_MDS_SESSION_HUNG) {\n\t\tif (session->s_state == CEPH_MDS_SESSION_NEW ||\n\t\t    session->s_state == CEPH_MDS_SESSION_CLOSING)\n\t\t\t__open_session(mdsc, session);\n\t\tlist_add(&req->r_wait, &session->s_waiting);\n\t\tgoto out_session;\n\t}\n\n\t/* send request */\n\treq->r_resend_mds = -1;   /* forget any previous mds hint */\n\n\tif (req->r_request_started == 0)   /* note request start time */\n\t\treq->r_request_started = jiffies;\n\n\terr = __prepare_send_request(mdsc, req, mds);\n\tif (!err) {\n\t\tceph_msg_get(req->r_request);\n\t\tceph_con_send(&session->s_con, req->r_request);\n\t}\n\nout_session:\n\tceph_put_mds_session(session);\nout:\n\treturn err;\n\nfinish:\n\treq->r_err = err;\n\tcomplete_request(mdsc, req);\n\tgoto out;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __do_request(struct ceph_mds_client *mdsc,\n\t\t\tstruct ceph_mds_request *req)\n{\n\tstruct ceph_mds_session *session = NULL;\n\tint mds = -1;\n\tint err = -EAGAIN;\n\n\tif (req->r_err || req->r_got_result) {\n\t\tif (req->r_aborted)\n\t\t\t__unregister_request(mdsc, req);\n\t\tgoto out;\n\t}\n\n\tif (req->r_timeout &&\n\t    time_after_eq(jiffies, req->r_started + req->r_timeout)) {\n\t\tdout(\"do_request timed out\\n\");\n\t\terr = -EIO;\n\t\tgoto finish;\n\t}\n\n\tput_request_session(req);\n\n\tmds = __choose_mds(mdsc, req);\n\tif (mds < 0 ||\n\t    ceph_mdsmap_get_state(mdsc->mdsmap, mds) < CEPH_MDS_STATE_ACTIVE) {\n\t\tdout(\"do_request no mds or not active, waiting for map\\n\");\n\t\tlist_add(&req->r_wait, &mdsc->waiting_for_map);\n\t\tgoto out;\n\t}\n\n\t/* get, open session */\n\tsession = __ceph_lookup_mds_session(mdsc, mds);\n\tif (!session) {\n\t\tsession = register_session(mdsc, mds);\n\t\tif (IS_ERR(session)) {\n\t\t\terr = PTR_ERR(session);\n\t\t\tgoto finish;\n\t\t}\n\t}\n\treq->r_session = get_session(session);\n\n\tdout(\"do_request mds%d session %p state %s\\n\", mds, session,\n\t     ceph_session_state_name(session->s_state));\n\tif (session->s_state != CEPH_MDS_SESSION_OPEN &&\n\t    session->s_state != CEPH_MDS_SESSION_HUNG) {\n\t\tif (session->s_state == CEPH_MDS_SESSION_NEW ||\n\t\t    session->s_state == CEPH_MDS_SESSION_CLOSING)\n\t\t\t__open_session(mdsc, session);\n\t\tlist_add(&req->r_wait, &session->s_waiting);\n\t\tgoto out_session;\n\t}\n\n\t/* send request */\n\treq->r_resend_mds = -1;   /* forget any previous mds hint */\n\n\tif (req->r_request_started == 0)   /* note request start time */\n\t\treq->r_request_started = jiffies;\n\n\terr = __prepare_send_request(mdsc, req, mds);\n\tif (!err) {\n\t\tceph_msg_get(req->r_request);\n\t\tceph_con_send(&session->s_con, req->r_request);\n\t}\n\nout_session:\n\tceph_put_mds_session(session);\nout:\n\treturn err;\n\nfinish:\n\treq->r_err = err;\n\tcomplete_request(mdsc, req);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" wake request %p tid %llu\\n\"",
            "req",
            "req->r_tid"
          ],
          "line": 2167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&req->r_wait"
          ],
          "line": 2166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "tmp_list.next",
            "structceph_mds_request",
            "r_wait"
          ],
          "line": 2164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&tmp_list"
          ],
          "line": 2163
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_splice_init",
          "args": [
            "head",
            "&tmp_list"
          ],
          "line": 2161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "tmp_list"
          ],
          "line": 2159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);\n\nstatic void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head)\n{\n\tstruct ceph_mds_request *req;\n\tLIST_HEAD(tmp_list);\n\n\tlist_splice_init(head, &tmp_list);\n\n\twhile (!list_empty(&tmp_list)) {\n\t\treq = list_entry(tmp_list.next,\n\t\t\t\t struct ceph_mds_request, r_wait);\n\t\tlist_del_init(&req->r_wait);\n\t\tdout(\" wake request %p tid %llu\\n\", req, req->r_tid);\n\t\t__do_request(mdsc, req);\n\t}\n}"
  },
  {
    "function_name": "__do_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "2077-2150",
    "snippet": "static int __do_request(struct ceph_mds_client *mdsc,\n\t\t\tstruct ceph_mds_request *req)\n{\n\tstruct ceph_mds_session *session = NULL;\n\tint mds = -1;\n\tint err = -EAGAIN;\n\n\tif (req->r_err || req->r_got_result) {\n\t\tif (req->r_aborted)\n\t\t\t__unregister_request(mdsc, req);\n\t\tgoto out;\n\t}\n\n\tif (req->r_timeout &&\n\t    time_after_eq(jiffies, req->r_started + req->r_timeout)) {\n\t\tdout(\"do_request timed out\\n\");\n\t\terr = -EIO;\n\t\tgoto finish;\n\t}\n\n\tput_request_session(req);\n\n\tmds = __choose_mds(mdsc, req);\n\tif (mds < 0 ||\n\t    ceph_mdsmap_get_state(mdsc->mdsmap, mds) < CEPH_MDS_STATE_ACTIVE) {\n\t\tdout(\"do_request no mds or not active, waiting for map\\n\");\n\t\tlist_add(&req->r_wait, &mdsc->waiting_for_map);\n\t\tgoto out;\n\t}\n\n\t/* get, open session */\n\tsession = __ceph_lookup_mds_session(mdsc, mds);\n\tif (!session) {\n\t\tsession = register_session(mdsc, mds);\n\t\tif (IS_ERR(session)) {\n\t\t\terr = PTR_ERR(session);\n\t\t\tgoto finish;\n\t\t}\n\t}\n\treq->r_session = get_session(session);\n\n\tdout(\"do_request mds%d session %p state %s\\n\", mds, session,\n\t     ceph_session_state_name(session->s_state));\n\tif (session->s_state != CEPH_MDS_SESSION_OPEN &&\n\t    session->s_state != CEPH_MDS_SESSION_HUNG) {\n\t\tif (session->s_state == CEPH_MDS_SESSION_NEW ||\n\t\t    session->s_state == CEPH_MDS_SESSION_CLOSING)\n\t\t\t__open_session(mdsc, session);\n\t\tlist_add(&req->r_wait, &session->s_waiting);\n\t\tgoto out_session;\n\t}\n\n\t/* send request */\n\treq->r_resend_mds = -1;   /* forget any previous mds hint */\n\n\tif (req->r_request_started == 0)   /* note request start time */\n\t\treq->r_request_started = jiffies;\n\n\terr = __prepare_send_request(mdsc, req, mds);\n\tif (!err) {\n\t\tceph_msg_get(req->r_request);\n\t\tceph_con_send(&session->s_con, req->r_request);\n\t}\n\nout_session:\n\tceph_put_mds_session(session);\nout:\n\treturn err;\n\nfinish:\n\treq->r_err = err;\n\tcomplete_request(mdsc, req);\n\tgoto out;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete_request",
          "args": [
            "mdsc",
            "req"
          ],
          "line": 2148
        },
        "resolved": true,
        "details": {
          "function_name": "complete_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1978-1985",
          "snippet": "static void complete_request(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_mds_request *req)\n{\n\tif (req->r_callback)\n\t\treq->r_callback(mdsc, req);\n\telse\n\t\tcomplete_all(&req->r_completion);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void complete_request(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_mds_request *req)\n{\n\tif (req->r_callback)\n\t\treq->r_callback(mdsc, req);\n\telse\n\t\tcomplete_all(&req->r_completion);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_put_mds_session",
          "args": [
            "session"
          ],
          "line": 2142
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_put_mds_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "374-385",
          "snippet": "void ceph_put_mds_session(struct ceph_mds_session *s)\n{\n\tdout(\"mdsc put_session %p %d -> %d\\n\", s,\n\t     atomic_read(&s->s_ref), atomic_read(&s->s_ref)-1);\n\tif (atomic_dec_and_test(&s->s_ref)) {\n\t\tif (s->s_auth.authorizer)\n\t\t\tceph_auth_destroy_authorizer(\n\t\t\t\ts->s_mdsc->fsc->client->monc.auth,\n\t\t\t\ts->s_auth.authorizer);\n\t\tkfree(s);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_put_mds_session(struct ceph_mds_session *s)\n{\n\tdout(\"mdsc put_session %p %d -> %d\\n\", s,\n\t     atomic_read(&s->s_ref), atomic_read(&s->s_ref)-1);\n\tif (atomic_dec_and_test(&s->s_ref)) {\n\t\tif (s->s_auth.authorizer)\n\t\t\tceph_auth_destroy_authorizer(\n\t\t\t\ts->s_mdsc->fsc->client->monc.auth,\n\t\t\t\ts->s_auth.authorizer);\n\t\tkfree(s);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_con_send",
          "args": [
            "&session->s_con",
            "req->r_request"
          ],
          "line": 2138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_msg_get",
          "args": [
            "req->r_request"
          ],
          "line": 2137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__prepare_send_request",
          "args": [
            "mdsc",
            "req",
            "mds"
          ],
          "line": 2135
        },
        "resolved": true,
        "details": {
          "function_name": "__prepare_send_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1990-2072",
          "snippet": "static int __prepare_send_request(struct ceph_mds_client *mdsc,\n\t\t\t\t  struct ceph_mds_request *req,\n\t\t\t\t  int mds)\n{\n\tstruct ceph_mds_request_head *rhead;\n\tstruct ceph_msg *msg;\n\tint flags = 0;\n\n\treq->r_attempts++;\n\tif (req->r_inode) {\n\t\tstruct ceph_cap *cap =\n\t\t\tceph_get_cap_for_mds(ceph_inode(req->r_inode), mds);\n\n\t\tif (cap)\n\t\t\treq->r_sent_on_mseq = cap->mseq;\n\t\telse\n\t\t\treq->r_sent_on_mseq = -1;\n\t}\n\tdout(\"prepare_send_request %p tid %lld %s (attempt %d)\\n\", req,\n\t     req->r_tid, ceph_mds_op_name(req->r_op), req->r_attempts);\n\n\tif (req->r_got_unsafe) {\n\t\tvoid *p;\n\t\t/*\n\t\t * Replay.  Do not regenerate message (and rebuild\n\t\t * paths, etc.); just use the original message.\n\t\t * Rebuilding paths will break for renames because\n\t\t * d_move mangles the src name.\n\t\t */\n\t\tmsg = req->r_request;\n\t\trhead = msg->front.iov_base;\n\n\t\tflags = le32_to_cpu(rhead->flags);\n\t\tflags |= CEPH_MDS_FLAG_REPLAY;\n\t\trhead->flags = cpu_to_le32(flags);\n\n\t\tif (req->r_target_inode)\n\t\t\trhead->ino = cpu_to_le64(ceph_ino(req->r_target_inode));\n\n\t\trhead->num_retry = req->r_attempts - 1;\n\n\t\t/* remove cap/dentry releases from message */\n\t\trhead->num_releases = 0;\n\n\t\t/* time stamp */\n\t\tp = msg->front.iov_base + req->r_request_release_offset;\n\t\t{\n\t\t\tstruct ceph_timespec ts;\n\t\t\tceph_encode_timespec(&ts, &req->r_stamp);\n\t\t\tceph_encode_copy(&p, &ts, sizeof(ts));\n\t\t}\n\n\t\tmsg->front.iov_len = p - msg->front.iov_base;\n\t\tmsg->hdr.front_len = cpu_to_le32(msg->front.iov_len);\n\t\treturn 0;\n\t}\n\n\tif (req->r_request) {\n\t\tceph_msg_put(req->r_request);\n\t\treq->r_request = NULL;\n\t}\n\tmsg = create_request_message(mdsc, req, mds);\n\tif (IS_ERR(msg)) {\n\t\treq->r_err = PTR_ERR(msg);\n\t\tcomplete_request(mdsc, req);\n\t\treturn PTR_ERR(msg);\n\t}\n\treq->r_request = msg;\n\n\trhead = msg->front.iov_base;\n\trhead->oldest_client_tid = cpu_to_le64(__get_oldest_tid(mdsc));\n\tif (req->r_got_unsafe)\n\t\tflags |= CEPH_MDS_FLAG_REPLAY;\n\tif (req->r_locked_dir)\n\t\tflags |= CEPH_MDS_FLAG_WANT_DENTRY;\n\trhead->flags = cpu_to_le32(flags);\n\trhead->num_fwd = req->r_num_fwd;\n\trhead->num_retry = req->r_attempts - 1;\n\trhead->ino = 0;\n\n\tdout(\" r_locked_dir = %p\\n\", req->r_locked_dir);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __prepare_send_request(struct ceph_mds_client *mdsc,\n\t\t\t\t  struct ceph_mds_request *req,\n\t\t\t\t  int mds)\n{\n\tstruct ceph_mds_request_head *rhead;\n\tstruct ceph_msg *msg;\n\tint flags = 0;\n\n\treq->r_attempts++;\n\tif (req->r_inode) {\n\t\tstruct ceph_cap *cap =\n\t\t\tceph_get_cap_for_mds(ceph_inode(req->r_inode), mds);\n\n\t\tif (cap)\n\t\t\treq->r_sent_on_mseq = cap->mseq;\n\t\telse\n\t\t\treq->r_sent_on_mseq = -1;\n\t}\n\tdout(\"prepare_send_request %p tid %lld %s (attempt %d)\\n\", req,\n\t     req->r_tid, ceph_mds_op_name(req->r_op), req->r_attempts);\n\n\tif (req->r_got_unsafe) {\n\t\tvoid *p;\n\t\t/*\n\t\t * Replay.  Do not regenerate message (and rebuild\n\t\t * paths, etc.); just use the original message.\n\t\t * Rebuilding paths will break for renames because\n\t\t * d_move mangles the src name.\n\t\t */\n\t\tmsg = req->r_request;\n\t\trhead = msg->front.iov_base;\n\n\t\tflags = le32_to_cpu(rhead->flags);\n\t\tflags |= CEPH_MDS_FLAG_REPLAY;\n\t\trhead->flags = cpu_to_le32(flags);\n\n\t\tif (req->r_target_inode)\n\t\t\trhead->ino = cpu_to_le64(ceph_ino(req->r_target_inode));\n\n\t\trhead->num_retry = req->r_attempts - 1;\n\n\t\t/* remove cap/dentry releases from message */\n\t\trhead->num_releases = 0;\n\n\t\t/* time stamp */\n\t\tp = msg->front.iov_base + req->r_request_release_offset;\n\t\t{\n\t\t\tstruct ceph_timespec ts;\n\t\t\tceph_encode_timespec(&ts, &req->r_stamp);\n\t\t\tceph_encode_copy(&p, &ts, sizeof(ts));\n\t\t}\n\n\t\tmsg->front.iov_len = p - msg->front.iov_base;\n\t\tmsg->hdr.front_len = cpu_to_le32(msg->front.iov_len);\n\t\treturn 0;\n\t}\n\n\tif (req->r_request) {\n\t\tceph_msg_put(req->r_request);\n\t\treq->r_request = NULL;\n\t}\n\tmsg = create_request_message(mdsc, req, mds);\n\tif (IS_ERR(msg)) {\n\t\treq->r_err = PTR_ERR(msg);\n\t\tcomplete_request(mdsc, req);\n\t\treturn PTR_ERR(msg);\n\t}\n\treq->r_request = msg;\n\n\trhead = msg->front.iov_base;\n\trhead->oldest_client_tid = cpu_to_le64(__get_oldest_tid(mdsc));\n\tif (req->r_got_unsafe)\n\t\tflags |= CEPH_MDS_FLAG_REPLAY;\n\tif (req->r_locked_dir)\n\t\tflags |= CEPH_MDS_FLAG_WANT_DENTRY;\n\trhead->flags = cpu_to_le32(flags);\n\trhead->num_fwd = req->r_num_fwd;\n\trhead->num_retry = req->r_attempts - 1;\n\trhead->ino = 0;\n\n\tdout(\" r_locked_dir = %p\\n\", req->r_locked_dir);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&req->r_wait",
            "&session->s_waiting"
          ],
          "line": 2125
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__open_session",
          "args": [
            "mdsc",
            "session"
          ],
          "line": 2124
        },
        "resolved": true,
        "details": {
          "function_name": "__open_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "909-929",
          "snippet": "static int __open_session(struct ceph_mds_client *mdsc,\n\t\t\t  struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *msg;\n\tint mstate;\n\tint mds = session->s_mds;\n\n\t/* wait for mds to go active? */\n\tmstate = ceph_mdsmap_get_state(mdsc->mdsmap, mds);\n\tdout(\"open_session to mds%d (%s)\\n\", mds,\n\t     ceph_mds_state_name(mstate));\n\tsession->s_state = CEPH_MDS_SESSION_OPENING;\n\tsession->s_renew_requested = jiffies;\n\n\t/* send connect message */\n\tmsg = create_session_open_msg(mdsc, session->s_seq);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\tceph_con_send(&session->s_con, msg);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __open_session(struct ceph_mds_client *mdsc,\n\t\t\t  struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *msg;\n\tint mstate;\n\tint mds = session->s_mds;\n\n\t/* wait for mds to go active? */\n\tmstate = ceph_mdsmap_get_state(mdsc->mdsmap, mds);\n\tdout(\"open_session to mds%d (%s)\\n\", mds,\n\t     ceph_mds_state_name(mstate));\n\tsession->s_state = CEPH_MDS_SESSION_OPENING;\n\tsession->s_renew_requested = jiffies;\n\n\t/* send connect message */\n\tmsg = create_session_open_msg(mdsc, session->s_seq);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\tceph_con_send(&session->s_con, msg);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"do_request mds%d session %p state %s\\n\"",
            "mds",
            "session",
            "ceph_session_state_name(session->s_state)"
          ],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_session_state_name",
          "args": [
            "session->s_state"
          ],
          "line": 2119
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_session_state_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "348-360",
          "snippet": "const char *ceph_session_state_name(int s)\n{\n\tswitch (s) {\n\tcase CEPH_MDS_SESSION_NEW: return \"new\";\n\tcase CEPH_MDS_SESSION_OPENING: return \"opening\";\n\tcase CEPH_MDS_SESSION_OPEN: return \"open\";\n\tcase CEPH_MDS_SESSION_HUNG: return \"hung\";\n\tcase CEPH_MDS_SESSION_CLOSING: return \"closing\";\n\tcase CEPH_MDS_SESSION_RESTARTING: return \"restarting\";\n\tcase CEPH_MDS_SESSION_RECONNECTING: return \"reconnecting\";\n\tdefault: return \"???\";\n\t}\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nconst char *ceph_session_state_name(int s)\n{\n\tswitch (s) {\n\tcase CEPH_MDS_SESSION_NEW: return \"new\";\n\tcase CEPH_MDS_SESSION_OPENING: return \"opening\";\n\tcase CEPH_MDS_SESSION_OPEN: return \"open\";\n\tcase CEPH_MDS_SESSION_HUNG: return \"hung\";\n\tcase CEPH_MDS_SESSION_CLOSING: return \"closing\";\n\tcase CEPH_MDS_SESSION_RESTARTING: return \"restarting\";\n\tcase CEPH_MDS_SESSION_RECONNECTING: return \"reconnecting\";\n\tdefault: return \"???\";\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_session",
          "args": [
            "session"
          ],
          "line": 2116
        },
        "resolved": true,
        "details": {
          "function_name": "get_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "362-372",
          "snippet": "static struct ceph_mds_session *get_session(struct ceph_mds_session *s)\n{\n\tif (atomic_inc_not_zero(&s->s_ref)) {\n\t\tdout(\"mdsc get_session %p %d -> %d\\n\", s,\n\t\t     atomic_read(&s->s_ref)-1, atomic_read(&s->s_ref));\n\t\treturn s;\n\t} else {\n\t\tdout(\"mdsc get_session %p 0 -- FAIL\", s);\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_mds_session *get_session(struct ceph_mds_session *s)\n{\n\tif (atomic_inc_not_zero(&s->s_ref)) {\n\t\tdout(\"mdsc get_session %p %d -> %d\\n\", s,\n\t\t     atomic_read(&s->s_ref)-1, atomic_read(&s->s_ref));\n\t\treturn s;\n\t} else {\n\t\tdout(\"mdsc get_session %p 0 -- FAIL\", s);\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "session"
          ],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "session"
          ],
          "line": 2111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_session",
          "args": [
            "mdsc",
            "mds"
          ],
          "line": 2110
        },
        "resolved": true,
        "details": {
          "function_name": "__unregister_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "499-508",
          "snippet": "static void __unregister_session(struct ceph_mds_client *mdsc,\n\t\t\t       struct ceph_mds_session *s)\n{\n\tdout(\"__unregister_session mds%d %p\\n\", s->s_mds, s);\n\tBUG_ON(mdsc->sessions[s->s_mds] != s);\n\tmdsc->sessions[s->s_mds] = NULL;\n\tceph_con_close(&s->s_con);\n\tceph_put_mds_session(s);\n\tatomic_dec(&mdsc->num_sessions);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __unregister_session(struct ceph_mds_client *mdsc,\n\t\t\t       struct ceph_mds_session *s)\n{\n\tdout(\"__unregister_session mds%d %p\\n\", s->s_mds, s);\n\tBUG_ON(mdsc->sessions[s->s_mds] != s);\n\tmdsc->sessions[s->s_mds] = NULL;\n\tceph_con_close(&s->s_con);\n\tceph_put_mds_session(s);\n\tatomic_dec(&mdsc->num_sessions);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_lookup_mds_session",
          "args": [
            "mdsc",
            "mds"
          ],
          "line": 2108
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_lookup_mds_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "390-402",
          "snippet": "struct ceph_mds_session *__ceph_lookup_mds_session(struct ceph_mds_client *mdsc,\n\t\t\t\t\t\t   int mds)\n{\n\tstruct ceph_mds_session *session;\n\n\tif (mds >= mdsc->max_sessions || mdsc->sessions[mds] == NULL)\n\t\treturn NULL;\n\tsession = mdsc->sessions[mds];\n\tdout(\"lookup_mds_session %p %d\\n\", session,\n\t     atomic_read(&session->s_ref));\n\tget_session(session);\n\treturn session;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct ceph_mds_session *__ceph_lookup_mds_session(struct ceph_mds_client *mdsc,\n\t\t\t\t\t\t   int mds)\n{\n\tstruct ceph_mds_session *session;\n\n\tif (mds >= mdsc->max_sessions || mdsc->sessions[mds] == NULL)\n\t\treturn NULL;\n\tsession = mdsc->sessions[mds];\n\tdout(\"lookup_mds_session %p %d\\n\", session,\n\t     atomic_read(&session->s_ref));\n\tget_session(session);\n\treturn session;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"do_request no mds or not active, waiting for map\\n\""
          ],
          "line": 2102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mdsmap_get_state",
          "args": [
            "mdsc->mdsmap",
            "mds"
          ],
          "line": 2101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__choose_mds",
          "args": [
            "mdsc",
            "req"
          ],
          "line": 2099
        },
        "resolved": true,
        "details": {
          "function_name": "__choose_mds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "687-809",
          "snippet": "static int __choose_mds(struct ceph_mds_client *mdsc,\n\t\t\tstruct ceph_mds_request *req)\n{\n\tstruct inode *inode;\n\tstruct ceph_inode_info *ci;\n\tstruct ceph_cap *cap;\n\tint mode = req->r_direct_mode;\n\tint mds = -1;\n\tu32 hash = req->r_direct_hash;\n\tbool is_hash = req->r_direct_is_hash;\n\n\t/*\n\t * is there a specific mds we should try?  ignore hint if we have\n\t * no session and the mds is not up (active or recovering).\n\t */\n\tif (req->r_resend_mds >= 0 &&\n\t    (__have_session(mdsc, req->r_resend_mds) ||\n\t     ceph_mdsmap_get_state(mdsc->mdsmap, req->r_resend_mds) > 0)) {\n\t\tdout(\"choose_mds using resend_mds mds%d\\n\",\n\t\t     req->r_resend_mds);\n\t\treturn req->r_resend_mds;\n\t}\n\n\tif (mode == USE_RANDOM_MDS)\n\t\tgoto random;\n\n\tinode = NULL;\n\tif (req->r_inode) {\n\t\tinode = req->r_inode;\n\t} else if (req->r_dentry) {\n\t\t/* ignore race with rename; old or new d_parent is okay */\n\t\tstruct dentry *parent = req->r_dentry->d_parent;\n\t\tstruct inode *dir = parent->d_inode;\n\n\t\tif (dir->i_sb != mdsc->fsc->sb) {\n\t\t\t/* not this fs! */\n\t\t\tinode = req->r_dentry->d_inode;\n\t\t} else if (ceph_snap(dir) != CEPH_NOSNAP) {\n\t\t\t/* direct snapped/virtual snapdir requests\n\t\t\t * based on parent dir inode */\n\t\t\tstruct dentry *dn = get_nonsnap_parent(parent);\n\t\t\tinode = dn->d_inode;\n\t\t\tdout(\"__choose_mds using nonsnap parent %p\\n\", inode);\n\t\t} else {\n\t\t\t/* dentry target */\n\t\t\tinode = req->r_dentry->d_inode;\n\t\t\tif (!inode || mode == USE_AUTH_MDS) {\n\t\t\t\t/* dir + name */\n\t\t\t\tinode = dir;\n\t\t\t\thash = ceph_dentry_hash(dir, req->r_dentry);\n\t\t\t\tis_hash = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tdout(\"__choose_mds %p is_hash=%d (%d) mode %d\\n\", inode, (int)is_hash,\n\t     (int)hash, mode);\n\tif (!inode)\n\t\tgoto random;\n\tci = ceph_inode(inode);\n\n\tif (is_hash && S_ISDIR(inode->i_mode)) {\n\t\tstruct ceph_inode_frag frag;\n\t\tint found;\n\n\t\tceph_choose_frag(ci, hash, &frag, &found);\n\t\tif (found) {\n\t\t\tif (mode == USE_ANY_MDS && frag.ndist > 0) {\n\t\t\t\tu8 r;\n\n\t\t\t\t/* choose a random replica */\n\t\t\t\tget_random_bytes(&r, 1);\n\t\t\t\tr %= frag.ndist;\n\t\t\t\tmds = frag.dist[r];\n\t\t\t\tdout(\"choose_mds %p %llx.%llx \"\n\t\t\t\t     \"frag %u mds%d (%d/%d)\\n\",\n\t\t\t\t     inode, ceph_vinop(inode),\n\t\t\t\t     frag.frag, mds,\n\t\t\t\t     (int)r, frag.ndist);\n\t\t\t\tif (ceph_mdsmap_get_state(mdsc->mdsmap, mds) >=\n\t\t\t\t    CEPH_MDS_STATE_ACTIVE)\n\t\t\t\t\treturn mds;\n\t\t\t}\n\n\t\t\t/* since this file/dir wasn't known to be\n\t\t\t * replicated, then we want to look for the\n\t\t\t * authoritative mds. */\n\t\t\tmode = USE_AUTH_MDS;\n\t\t\tif (frag.mds >= 0) {\n\t\t\t\t/* choose auth mds */\n\t\t\t\tmds = frag.mds;\n\t\t\t\tdout(\"choose_mds %p %llx.%llx \"\n\t\t\t\t     \"frag %u mds%d (auth)\\n\",\n\t\t\t\t     inode, ceph_vinop(inode), frag.frag, mds);\n\t\t\t\tif (ceph_mdsmap_get_state(mdsc->mdsmap, mds) >=\n\t\t\t\t    CEPH_MDS_STATE_ACTIVE)\n\t\t\t\t\treturn mds;\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_lock(&ci->i_ceph_lock);\n\tcap = NULL;\n\tif (mode == USE_AUTH_MDS)\n\t\tcap = ci->i_auth_cap;\n\tif (!cap && !RB_EMPTY_ROOT(&ci->i_caps))\n\t\tcap = rb_entry(rb_first(&ci->i_caps), struct ceph_cap, ci_node);\n\tif (!cap) {\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tgoto random;\n\t}\n\tmds = cap->session->s_mds;\n\tdout(\"choose_mds %p %llx.%llx mds%d (%scap %p)\\n\",\n\t     inode, ceph_vinop(inode), mds,\n\t     cap == ci->i_auth_cap ? \"auth \" : \"\", cap);\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn mds;\n\nrandom:\n\tmds = ceph_mdsmap_get_random_mds(mdsc->mdsmap);\n\tdout(\"choose_mds chose random mds%d\\n\", mds);\n\treturn mds;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __choose_mds(struct ceph_mds_client *mdsc,\n\t\t\tstruct ceph_mds_request *req)\n{\n\tstruct inode *inode;\n\tstruct ceph_inode_info *ci;\n\tstruct ceph_cap *cap;\n\tint mode = req->r_direct_mode;\n\tint mds = -1;\n\tu32 hash = req->r_direct_hash;\n\tbool is_hash = req->r_direct_is_hash;\n\n\t/*\n\t * is there a specific mds we should try?  ignore hint if we have\n\t * no session and the mds is not up (active or recovering).\n\t */\n\tif (req->r_resend_mds >= 0 &&\n\t    (__have_session(mdsc, req->r_resend_mds) ||\n\t     ceph_mdsmap_get_state(mdsc->mdsmap, req->r_resend_mds) > 0)) {\n\t\tdout(\"choose_mds using resend_mds mds%d\\n\",\n\t\t     req->r_resend_mds);\n\t\treturn req->r_resend_mds;\n\t}\n\n\tif (mode == USE_RANDOM_MDS)\n\t\tgoto random;\n\n\tinode = NULL;\n\tif (req->r_inode) {\n\t\tinode = req->r_inode;\n\t} else if (req->r_dentry) {\n\t\t/* ignore race with rename; old or new d_parent is okay */\n\t\tstruct dentry *parent = req->r_dentry->d_parent;\n\t\tstruct inode *dir = parent->d_inode;\n\n\t\tif (dir->i_sb != mdsc->fsc->sb) {\n\t\t\t/* not this fs! */\n\t\t\tinode = req->r_dentry->d_inode;\n\t\t} else if (ceph_snap(dir) != CEPH_NOSNAP) {\n\t\t\t/* direct snapped/virtual snapdir requests\n\t\t\t * based on parent dir inode */\n\t\t\tstruct dentry *dn = get_nonsnap_parent(parent);\n\t\t\tinode = dn->d_inode;\n\t\t\tdout(\"__choose_mds using nonsnap parent %p\\n\", inode);\n\t\t} else {\n\t\t\t/* dentry target */\n\t\t\tinode = req->r_dentry->d_inode;\n\t\t\tif (!inode || mode == USE_AUTH_MDS) {\n\t\t\t\t/* dir + name */\n\t\t\t\tinode = dir;\n\t\t\t\thash = ceph_dentry_hash(dir, req->r_dentry);\n\t\t\t\tis_hash = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tdout(\"__choose_mds %p is_hash=%d (%d) mode %d\\n\", inode, (int)is_hash,\n\t     (int)hash, mode);\n\tif (!inode)\n\t\tgoto random;\n\tci = ceph_inode(inode);\n\n\tif (is_hash && S_ISDIR(inode->i_mode)) {\n\t\tstruct ceph_inode_frag frag;\n\t\tint found;\n\n\t\tceph_choose_frag(ci, hash, &frag, &found);\n\t\tif (found) {\n\t\t\tif (mode == USE_ANY_MDS && frag.ndist > 0) {\n\t\t\t\tu8 r;\n\n\t\t\t\t/* choose a random replica */\n\t\t\t\tget_random_bytes(&r, 1);\n\t\t\t\tr %= frag.ndist;\n\t\t\t\tmds = frag.dist[r];\n\t\t\t\tdout(\"choose_mds %p %llx.%llx \"\n\t\t\t\t     \"frag %u mds%d (%d/%d)\\n\",\n\t\t\t\t     inode, ceph_vinop(inode),\n\t\t\t\t     frag.frag, mds,\n\t\t\t\t     (int)r, frag.ndist);\n\t\t\t\tif (ceph_mdsmap_get_state(mdsc->mdsmap, mds) >=\n\t\t\t\t    CEPH_MDS_STATE_ACTIVE)\n\t\t\t\t\treturn mds;\n\t\t\t}\n\n\t\t\t/* since this file/dir wasn't known to be\n\t\t\t * replicated, then we want to look for the\n\t\t\t * authoritative mds. */\n\t\t\tmode = USE_AUTH_MDS;\n\t\t\tif (frag.mds >= 0) {\n\t\t\t\t/* choose auth mds */\n\t\t\t\tmds = frag.mds;\n\t\t\t\tdout(\"choose_mds %p %llx.%llx \"\n\t\t\t\t     \"frag %u mds%d (auth)\\n\",\n\t\t\t\t     inode, ceph_vinop(inode), frag.frag, mds);\n\t\t\t\tif (ceph_mdsmap_get_state(mdsc->mdsmap, mds) >=\n\t\t\t\t    CEPH_MDS_STATE_ACTIVE)\n\t\t\t\t\treturn mds;\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_lock(&ci->i_ceph_lock);\n\tcap = NULL;\n\tif (mode == USE_AUTH_MDS)\n\t\tcap = ci->i_auth_cap;\n\tif (!cap && !RB_EMPTY_ROOT(&ci->i_caps))\n\t\tcap = rb_entry(rb_first(&ci->i_caps), struct ceph_cap, ci_node);\n\tif (!cap) {\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tgoto random;\n\t}\n\tmds = cap->session->s_mds;\n\tdout(\"choose_mds %p %llx.%llx mds%d (%scap %p)\\n\",\n\t     inode, ceph_vinop(inode), mds,\n\t     cap == ci->i_auth_cap ? \"auth \" : \"\", cap);\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn mds;\n\nrandom:\n\tmds = ceph_mdsmap_get_random_mds(mdsc->mdsmap);\n\tdout(\"choose_mds chose random mds%d\\n\", mds);\n\treturn mds;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_request_session",
          "args": [
            "req"
          ],
          "line": 2097
        },
        "resolved": true,
        "details": {
          "function_name": "put_request_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "515-521",
          "snippet": "static void put_request_session(struct ceph_mds_request *req)\n{\n\tif (req->r_session) {\n\t\tceph_put_mds_session(req->r_session);\n\t\treq->r_session = NULL;\n\t}\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void put_request_session(struct ceph_mds_request *req)\n{\n\tif (req->r_session) {\n\t\tceph_put_mds_session(req->r_session);\n\t\treq->r_session = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"do_request timed out\\n\""
          ],
          "line": 2092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after_eq",
          "args": [
            "jiffies",
            "req->r_started + req->r_timeout"
          ],
          "line": 2091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__unregister_request",
          "args": [
            "mdsc",
            "req"
          ],
          "line": 2086
        },
        "resolved": true,
        "details": {
          "function_name": "__unregister_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "643-664",
          "snippet": "static void __unregister_request(struct ceph_mds_client *mdsc,\n\t\t\t\t struct ceph_mds_request *req)\n{\n\tdout(\"__unregister_request %p tid %lld\\n\", req, req->r_tid);\n\trb_erase(&req->r_node, &mdsc->request_tree);\n\tRB_CLEAR_NODE(&req->r_node);\n\n\tif (req->r_unsafe_dir) {\n\t\tstruct ceph_inode_info *ci = ceph_inode(req->r_unsafe_dir);\n\n\t\tspin_lock(&ci->i_unsafe_lock);\n\t\tlist_del_init(&req->r_unsafe_dir_item);\n\t\tspin_unlock(&ci->i_unsafe_lock);\n\n\t\tiput(req->r_unsafe_dir);\n\t\treq->r_unsafe_dir = NULL;\n\t}\n\n\tcomplete_all(&req->r_safe_completion);\n\n\tceph_mdsc_put_request(req);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __unregister_request(struct ceph_mds_client *mdsc,\n\t\t\t\t struct ceph_mds_request *req)\n{\n\tdout(\"__unregister_request %p tid %lld\\n\", req, req->r_tid);\n\trb_erase(&req->r_node, &mdsc->request_tree);\n\tRB_CLEAR_NODE(&req->r_node);\n\n\tif (req->r_unsafe_dir) {\n\t\tstruct ceph_inode_info *ci = ceph_inode(req->r_unsafe_dir);\n\n\t\tspin_lock(&ci->i_unsafe_lock);\n\t\tlist_del_init(&req->r_unsafe_dir_item);\n\t\tspin_unlock(&ci->i_unsafe_lock);\n\n\t\tiput(req->r_unsafe_dir);\n\t\treq->r_unsafe_dir = NULL;\n\t}\n\n\tcomplete_all(&req->r_safe_completion);\n\n\tceph_mdsc_put_request(req);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __do_request(struct ceph_mds_client *mdsc,\n\t\t\tstruct ceph_mds_request *req)\n{\n\tstruct ceph_mds_session *session = NULL;\n\tint mds = -1;\n\tint err = -EAGAIN;\n\n\tif (req->r_err || req->r_got_result) {\n\t\tif (req->r_aborted)\n\t\t\t__unregister_request(mdsc, req);\n\t\tgoto out;\n\t}\n\n\tif (req->r_timeout &&\n\t    time_after_eq(jiffies, req->r_started + req->r_timeout)) {\n\t\tdout(\"do_request timed out\\n\");\n\t\terr = -EIO;\n\t\tgoto finish;\n\t}\n\n\tput_request_session(req);\n\n\tmds = __choose_mds(mdsc, req);\n\tif (mds < 0 ||\n\t    ceph_mdsmap_get_state(mdsc->mdsmap, mds) < CEPH_MDS_STATE_ACTIVE) {\n\t\tdout(\"do_request no mds or not active, waiting for map\\n\");\n\t\tlist_add(&req->r_wait, &mdsc->waiting_for_map);\n\t\tgoto out;\n\t}\n\n\t/* get, open session */\n\tsession = __ceph_lookup_mds_session(mdsc, mds);\n\tif (!session) {\n\t\tsession = register_session(mdsc, mds);\n\t\tif (IS_ERR(session)) {\n\t\t\terr = PTR_ERR(session);\n\t\t\tgoto finish;\n\t\t}\n\t}\n\treq->r_session = get_session(session);\n\n\tdout(\"do_request mds%d session %p state %s\\n\", mds, session,\n\t     ceph_session_state_name(session->s_state));\n\tif (session->s_state != CEPH_MDS_SESSION_OPEN &&\n\t    session->s_state != CEPH_MDS_SESSION_HUNG) {\n\t\tif (session->s_state == CEPH_MDS_SESSION_NEW ||\n\t\t    session->s_state == CEPH_MDS_SESSION_CLOSING)\n\t\t\t__open_session(mdsc, session);\n\t\tlist_add(&req->r_wait, &session->s_waiting);\n\t\tgoto out_session;\n\t}\n\n\t/* send request */\n\treq->r_resend_mds = -1;   /* forget any previous mds hint */\n\n\tif (req->r_request_started == 0)   /* note request start time */\n\t\treq->r_request_started = jiffies;\n\n\terr = __prepare_send_request(mdsc, req, mds);\n\tif (!err) {\n\t\tceph_msg_get(req->r_request);\n\t\tceph_con_send(&session->s_con, req->r_request);\n\t}\n\nout_session:\n\tceph_put_mds_session(session);\nout:\n\treturn err;\n\nfinish:\n\treq->r_err = err;\n\tcomplete_request(mdsc, req);\n\tgoto out;\n}"
  },
  {
    "function_name": "__prepare_send_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "1990-2072",
    "snippet": "static int __prepare_send_request(struct ceph_mds_client *mdsc,\n\t\t\t\t  struct ceph_mds_request *req,\n\t\t\t\t  int mds)\n{\n\tstruct ceph_mds_request_head *rhead;\n\tstruct ceph_msg *msg;\n\tint flags = 0;\n\n\treq->r_attempts++;\n\tif (req->r_inode) {\n\t\tstruct ceph_cap *cap =\n\t\t\tceph_get_cap_for_mds(ceph_inode(req->r_inode), mds);\n\n\t\tif (cap)\n\t\t\treq->r_sent_on_mseq = cap->mseq;\n\t\telse\n\t\t\treq->r_sent_on_mseq = -1;\n\t}\n\tdout(\"prepare_send_request %p tid %lld %s (attempt %d)\\n\", req,\n\t     req->r_tid, ceph_mds_op_name(req->r_op), req->r_attempts);\n\n\tif (req->r_got_unsafe) {\n\t\tvoid *p;\n\t\t/*\n\t\t * Replay.  Do not regenerate message (and rebuild\n\t\t * paths, etc.); just use the original message.\n\t\t * Rebuilding paths will break for renames because\n\t\t * d_move mangles the src name.\n\t\t */\n\t\tmsg = req->r_request;\n\t\trhead = msg->front.iov_base;\n\n\t\tflags = le32_to_cpu(rhead->flags);\n\t\tflags |= CEPH_MDS_FLAG_REPLAY;\n\t\trhead->flags = cpu_to_le32(flags);\n\n\t\tif (req->r_target_inode)\n\t\t\trhead->ino = cpu_to_le64(ceph_ino(req->r_target_inode));\n\n\t\trhead->num_retry = req->r_attempts - 1;\n\n\t\t/* remove cap/dentry releases from message */\n\t\trhead->num_releases = 0;\n\n\t\t/* time stamp */\n\t\tp = msg->front.iov_base + req->r_request_release_offset;\n\t\t{\n\t\t\tstruct ceph_timespec ts;\n\t\t\tceph_encode_timespec(&ts, &req->r_stamp);\n\t\t\tceph_encode_copy(&p, &ts, sizeof(ts));\n\t\t}\n\n\t\tmsg->front.iov_len = p - msg->front.iov_base;\n\t\tmsg->hdr.front_len = cpu_to_le32(msg->front.iov_len);\n\t\treturn 0;\n\t}\n\n\tif (req->r_request) {\n\t\tceph_msg_put(req->r_request);\n\t\treq->r_request = NULL;\n\t}\n\tmsg = create_request_message(mdsc, req, mds);\n\tif (IS_ERR(msg)) {\n\t\treq->r_err = PTR_ERR(msg);\n\t\tcomplete_request(mdsc, req);\n\t\treturn PTR_ERR(msg);\n\t}\n\treq->r_request = msg;\n\n\trhead = msg->front.iov_base;\n\trhead->oldest_client_tid = cpu_to_le64(__get_oldest_tid(mdsc));\n\tif (req->r_got_unsafe)\n\t\tflags |= CEPH_MDS_FLAG_REPLAY;\n\tif (req->r_locked_dir)\n\t\tflags |= CEPH_MDS_FLAG_WANT_DENTRY;\n\trhead->flags = cpu_to_le32(flags);\n\trhead->num_fwd = req->r_num_fwd;\n\trhead->num_retry = req->r_attempts - 1;\n\trhead->ino = 0;\n\n\tdout(\" r_locked_dir = %p\\n\", req->r_locked_dir);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" r_locked_dir = %p\\n\"",
            "req->r_locked_dir"
          ],
          "line": 2070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "flags"
          ],
          "line": 2065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "__get_oldest_tid(mdsc)"
          ],
          "line": 2060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_oldest_tid",
          "args": [
            "mdsc"
          ],
          "line": 2060
        },
        "resolved": true,
        "details": {
          "function_name": "__get_oldest_tid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1680-1687",
          "snippet": "static u64 __get_oldest_tid(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_mds_request *req = __get_oldest_req(mdsc);\n\n\tif (req)\n\t\treturn req->r_tid;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic u64 __get_oldest_tid(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_mds_request *req = __get_oldest_req(mdsc);\n\n\tif (req)\n\t\treturn req->r_tid;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "msg"
          ],
          "line": 2055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "complete_request",
          "args": [
            "mdsc",
            "req"
          ],
          "line": 2054
        },
        "resolved": true,
        "details": {
          "function_name": "complete_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1978-1985",
          "snippet": "static void complete_request(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_mds_request *req)\n{\n\tif (req->r_callback)\n\t\treq->r_callback(mdsc, req);\n\telse\n\t\tcomplete_all(&req->r_completion);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void complete_request(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_mds_request *req)\n{\n\tif (req->r_callback)\n\t\treq->r_callback(mdsc, req);\n\telse\n\t\tcomplete_all(&req->r_completion);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "msg"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "msg"
          ],
          "line": 2052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_request_message",
          "args": [
            "mdsc",
            "req",
            "mds"
          ],
          "line": 2051
        },
        "resolved": true,
        "details": {
          "function_name": "create_request_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1854-1972",
          "snippet": "static struct ceph_msg *create_request_message(struct ceph_mds_client *mdsc,\n\t\t\t\t\t       struct ceph_mds_request *req,\n\t\t\t\t\t       int mds)\n{\n\tstruct ceph_msg *msg;\n\tstruct ceph_mds_request_head *head;\n\tconst char *path1 = NULL;\n\tconst char *path2 = NULL;\n\tu64 ino1 = 0, ino2 = 0;\n\tint pathlen1 = 0, pathlen2 = 0;\n\tint freepath1 = 0, freepath2 = 0;\n\tint len;\n\tu16 releases;\n\tvoid *p, *end;\n\tint ret;\n\n\tret = set_request_path_attr(req->r_inode, req->r_dentry,\n\t\t\t      req->r_path1, req->r_ino1.ino,\n\t\t\t      &path1, &pathlen1, &ino1, &freepath1);\n\tif (ret < 0) {\n\t\tmsg = ERR_PTR(ret);\n\t\tgoto out;\n\t}\n\n\tret = set_request_path_attr(NULL, req->r_old_dentry,\n\t\t\t      req->r_path2, req->r_ino2.ino,\n\t\t\t      &path2, &pathlen2, &ino2, &freepath2);\n\tif (ret < 0) {\n\t\tmsg = ERR_PTR(ret);\n\t\tgoto out_free1;\n\t}\n\n\tlen = sizeof(*head) +\n\t\tpathlen1 + pathlen2 + 2*(1 + sizeof(u32) + sizeof(u64)) +\n\t\tsizeof(struct timespec);\n\n\t/* calculate (max) length for cap releases */\n\tlen += sizeof(struct ceph_mds_request_release) *\n\t\t(!!req->r_inode_drop + !!req->r_dentry_drop +\n\t\t !!req->r_old_inode_drop + !!req->r_old_dentry_drop);\n\tif (req->r_dentry_drop)\n\t\tlen += req->r_dentry->d_name.len;\n\tif (req->r_old_dentry_drop)\n\t\tlen += req->r_old_dentry->d_name.len;\n\n\tmsg = ceph_msg_new(CEPH_MSG_CLIENT_REQUEST, len, GFP_NOFS, false);\n\tif (!msg) {\n\t\tmsg = ERR_PTR(-ENOMEM);\n\t\tgoto out_free2;\n\t}\n\n\tmsg->hdr.version = cpu_to_le16(2);\n\tmsg->hdr.tid = cpu_to_le64(req->r_tid);\n\n\thead = msg->front.iov_base;\n\tp = msg->front.iov_base + sizeof(*head);\n\tend = msg->front.iov_base + msg->front.iov_len;\n\n\thead->mdsmap_epoch = cpu_to_le32(mdsc->mdsmap->m_epoch);\n\thead->op = cpu_to_le32(req->r_op);\n\thead->caller_uid = cpu_to_le32(from_kuid(&init_user_ns, req->r_uid));\n\thead->caller_gid = cpu_to_le32(from_kgid(&init_user_ns, req->r_gid));\n\thead->args = req->r_args;\n\n\tceph_encode_filepath(&p, end, ino1, path1);\n\tceph_encode_filepath(&p, end, ino2, path2);\n\n\t/* make note of release offset, in case we need to replay */\n\treq->r_request_release_offset = p - msg->front.iov_base;\n\n\t/* cap releases */\n\treleases = 0;\n\tif (req->r_inode_drop)\n\t\treleases += ceph_encode_inode_release(&p,\n\t\t      req->r_inode ? req->r_inode : req->r_dentry->d_inode,\n\t\t      mds, req->r_inode_drop, req->r_inode_unless, 0);\n\tif (req->r_dentry_drop)\n\t\treleases += ceph_encode_dentry_release(&p, req->r_dentry,\n\t\t       mds, req->r_dentry_drop, req->r_dentry_unless);\n\tif (req->r_old_dentry_drop)\n\t\treleases += ceph_encode_dentry_release(&p, req->r_old_dentry,\n\t\t       mds, req->r_old_dentry_drop, req->r_old_dentry_unless);\n\tif (req->r_old_inode_drop)\n\t\treleases += ceph_encode_inode_release(&p,\n\t\t      req->r_old_dentry->d_inode,\n\t\t      mds, req->r_old_inode_drop, req->r_old_inode_unless, 0);\n\thead->num_releases = cpu_to_le16(releases);\n\n\t/* time stamp */\n\t{\n\t\tstruct ceph_timespec ts;\n\t\tceph_encode_timespec(&ts, &req->r_stamp);\n\t\tceph_encode_copy(&p, &ts, sizeof(ts));\n\t}\n\n\tBUG_ON(p > end);\n\tmsg->front.iov_len = p - msg->front.iov_base;\n\tmsg->hdr.front_len = cpu_to_le32(msg->front.iov_len);\n\n\tif (req->r_pagelist) {\n\t\tstruct ceph_pagelist *pagelist = req->r_pagelist;\n\t\tatomic_inc(&pagelist->refcnt);\n\t\tceph_msg_data_add_pagelist(msg, pagelist);\n\t\tmsg->hdr.data_len = cpu_to_le32(pagelist->length);\n\t} else {\n\t\tmsg->hdr.data_len = 0;\n\t}\n\n\tmsg->hdr.data_off = cpu_to_le16(0);\n\nout_free2:\n\tif (freepath2)\n\t\tkfree((char *)path2);\nout_free1:\n\tif (freepath1)\n\t\tkfree((char *)path1);\nout:\n\treturn msg;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);\n\nstatic struct ceph_msg *create_request_message(struct ceph_mds_client *mdsc,\n\t\t\t\t\t       struct ceph_mds_request *req,\n\t\t\t\t\t       int mds)\n{\n\tstruct ceph_msg *msg;\n\tstruct ceph_mds_request_head *head;\n\tconst char *path1 = NULL;\n\tconst char *path2 = NULL;\n\tu64 ino1 = 0, ino2 = 0;\n\tint pathlen1 = 0, pathlen2 = 0;\n\tint freepath1 = 0, freepath2 = 0;\n\tint len;\n\tu16 releases;\n\tvoid *p, *end;\n\tint ret;\n\n\tret = set_request_path_attr(req->r_inode, req->r_dentry,\n\t\t\t      req->r_path1, req->r_ino1.ino,\n\t\t\t      &path1, &pathlen1, &ino1, &freepath1);\n\tif (ret < 0) {\n\t\tmsg = ERR_PTR(ret);\n\t\tgoto out;\n\t}\n\n\tret = set_request_path_attr(NULL, req->r_old_dentry,\n\t\t\t      req->r_path2, req->r_ino2.ino,\n\t\t\t      &path2, &pathlen2, &ino2, &freepath2);\n\tif (ret < 0) {\n\t\tmsg = ERR_PTR(ret);\n\t\tgoto out_free1;\n\t}\n\n\tlen = sizeof(*head) +\n\t\tpathlen1 + pathlen2 + 2*(1 + sizeof(u32) + sizeof(u64)) +\n\t\tsizeof(struct timespec);\n\n\t/* calculate (max) length for cap releases */\n\tlen += sizeof(struct ceph_mds_request_release) *\n\t\t(!!req->r_inode_drop + !!req->r_dentry_drop +\n\t\t !!req->r_old_inode_drop + !!req->r_old_dentry_drop);\n\tif (req->r_dentry_drop)\n\t\tlen += req->r_dentry->d_name.len;\n\tif (req->r_old_dentry_drop)\n\t\tlen += req->r_old_dentry->d_name.len;\n\n\tmsg = ceph_msg_new(CEPH_MSG_CLIENT_REQUEST, len, GFP_NOFS, false);\n\tif (!msg) {\n\t\tmsg = ERR_PTR(-ENOMEM);\n\t\tgoto out_free2;\n\t}\n\n\tmsg->hdr.version = cpu_to_le16(2);\n\tmsg->hdr.tid = cpu_to_le64(req->r_tid);\n\n\thead = msg->front.iov_base;\n\tp = msg->front.iov_base + sizeof(*head);\n\tend = msg->front.iov_base + msg->front.iov_len;\n\n\thead->mdsmap_epoch = cpu_to_le32(mdsc->mdsmap->m_epoch);\n\thead->op = cpu_to_le32(req->r_op);\n\thead->caller_uid = cpu_to_le32(from_kuid(&init_user_ns, req->r_uid));\n\thead->caller_gid = cpu_to_le32(from_kgid(&init_user_ns, req->r_gid));\n\thead->args = req->r_args;\n\n\tceph_encode_filepath(&p, end, ino1, path1);\n\tceph_encode_filepath(&p, end, ino2, path2);\n\n\t/* make note of release offset, in case we need to replay */\n\treq->r_request_release_offset = p - msg->front.iov_base;\n\n\t/* cap releases */\n\treleases = 0;\n\tif (req->r_inode_drop)\n\t\treleases += ceph_encode_inode_release(&p,\n\t\t      req->r_inode ? req->r_inode : req->r_dentry->d_inode,\n\t\t      mds, req->r_inode_drop, req->r_inode_unless, 0);\n\tif (req->r_dentry_drop)\n\t\treleases += ceph_encode_dentry_release(&p, req->r_dentry,\n\t\t       mds, req->r_dentry_drop, req->r_dentry_unless);\n\tif (req->r_old_dentry_drop)\n\t\treleases += ceph_encode_dentry_release(&p, req->r_old_dentry,\n\t\t       mds, req->r_old_dentry_drop, req->r_old_dentry_unless);\n\tif (req->r_old_inode_drop)\n\t\treleases += ceph_encode_inode_release(&p,\n\t\t      req->r_old_dentry->d_inode,\n\t\t      mds, req->r_old_inode_drop, req->r_old_inode_unless, 0);\n\thead->num_releases = cpu_to_le16(releases);\n\n\t/* time stamp */\n\t{\n\t\tstruct ceph_timespec ts;\n\t\tceph_encode_timespec(&ts, &req->r_stamp);\n\t\tceph_encode_copy(&p, &ts, sizeof(ts));\n\t}\n\n\tBUG_ON(p > end);\n\tmsg->front.iov_len = p - msg->front.iov_base;\n\tmsg->hdr.front_len = cpu_to_le32(msg->front.iov_len);\n\n\tif (req->r_pagelist) {\n\t\tstruct ceph_pagelist *pagelist = req->r_pagelist;\n\t\tatomic_inc(&pagelist->refcnt);\n\t\tceph_msg_data_add_pagelist(msg, pagelist);\n\t\tmsg->hdr.data_len = cpu_to_le32(pagelist->length);\n\t} else {\n\t\tmsg->hdr.data_len = 0;\n\t}\n\n\tmsg->hdr.data_off = cpu_to_le16(0);\n\nout_free2:\n\tif (freepath2)\n\t\tkfree((char *)path2);\nout_free1:\n\tif (freepath1)\n\t\tkfree((char *)path1);\nout:\n\treturn msg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_msg_put",
          "args": [
            "req->r_request"
          ],
          "line": 2048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "msg->front.iov_len"
          ],
          "line": 2043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_encode_copy",
          "args": [
            "&p",
            "&ts",
            "sizeof(ts)"
          ],
          "line": 2039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_encode_timespec",
          "args": [
            "&ts",
            "&req->r_stamp"
          ],
          "line": 2038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "ceph_ino(req->r_target_inode)"
          ],
          "line": 2027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_ino",
          "args": [
            "req->r_target_inode"
          ],
          "line": 2027
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "412-415",
          "snippet": "static inline u64 ceph_ino(struct inode *inode)\n{\n\treturn ceph_inode(inode)->i_vino.ino;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline u64 ceph_ino(struct inode *inode)\n{\n\treturn ceph_inode(inode)->i_vino.ino;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "flags"
          ],
          "line": 2024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rhead->flags"
          ],
          "line": 2022
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"prepare_send_request %p tid %lld %s (attempt %d)\\n\"",
            "req",
            "req->r_tid",
            "ceph_mds_op_name(req->r_op)",
            "req->r_attempts"
          ],
          "line": 2008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mds_op_name",
          "args": [
            "req->r_op"
          ],
          "line": 2009
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mds_op_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/strings.c",
          "lines": "50-82",
          "snippet": "const char *ceph_mds_op_name(int op)\n{\n\tswitch (op) {\n\tcase CEPH_MDS_OP_LOOKUP:  return \"lookup\";\n\tcase CEPH_MDS_OP_LOOKUPHASH:  return \"lookuphash\";\n\tcase CEPH_MDS_OP_LOOKUPPARENT:  return \"lookupparent\";\n\tcase CEPH_MDS_OP_LOOKUPINO:  return \"lookupino\";\n\tcase CEPH_MDS_OP_LOOKUPNAME:  return \"lookupname\";\n\tcase CEPH_MDS_OP_GETATTR:  return \"getattr\";\n\tcase CEPH_MDS_OP_SETXATTR: return \"setxattr\";\n\tcase CEPH_MDS_OP_SETATTR: return \"setattr\";\n\tcase CEPH_MDS_OP_RMXATTR: return \"rmxattr\";\n\tcase CEPH_MDS_OP_SETLAYOUT: return \"setlayou\";\n\tcase CEPH_MDS_OP_SETDIRLAYOUT: return \"setdirlayout\";\n\tcase CEPH_MDS_OP_READDIR: return \"readdir\";\n\tcase CEPH_MDS_OP_MKNOD: return \"mknod\";\n\tcase CEPH_MDS_OP_LINK: return \"link\";\n\tcase CEPH_MDS_OP_UNLINK: return \"unlink\";\n\tcase CEPH_MDS_OP_RENAME: return \"rename\";\n\tcase CEPH_MDS_OP_MKDIR: return \"mkdir\";\n\tcase CEPH_MDS_OP_RMDIR: return \"rmdir\";\n\tcase CEPH_MDS_OP_SYMLINK: return \"symlink\";\n\tcase CEPH_MDS_OP_CREATE: return \"create\";\n\tcase CEPH_MDS_OP_OPEN: return \"open\";\n\tcase CEPH_MDS_OP_LOOKUPSNAP: return \"lookupsnap\";\n\tcase CEPH_MDS_OP_LSSNAP: return \"lssnap\";\n\tcase CEPH_MDS_OP_MKSNAP: return \"mksnap\";\n\tcase CEPH_MDS_OP_RMSNAP: return \"rmsnap\";\n\tcase CEPH_MDS_OP_SETFILELOCK: return \"setfilelock\";\n\tcase CEPH_MDS_OP_GETFILELOCK: return \"getfilelock\";\n\t}\n\treturn \"???\";\n}",
          "includes": [
            "#include <linux/ceph/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/types.h>\n#include <linux/module.h>\n\nconst char *ceph_mds_op_name(int op)\n{\n\tswitch (op) {\n\tcase CEPH_MDS_OP_LOOKUP:  return \"lookup\";\n\tcase CEPH_MDS_OP_LOOKUPHASH:  return \"lookuphash\";\n\tcase CEPH_MDS_OP_LOOKUPPARENT:  return \"lookupparent\";\n\tcase CEPH_MDS_OP_LOOKUPINO:  return \"lookupino\";\n\tcase CEPH_MDS_OP_LOOKUPNAME:  return \"lookupname\";\n\tcase CEPH_MDS_OP_GETATTR:  return \"getattr\";\n\tcase CEPH_MDS_OP_SETXATTR: return \"setxattr\";\n\tcase CEPH_MDS_OP_SETATTR: return \"setattr\";\n\tcase CEPH_MDS_OP_RMXATTR: return \"rmxattr\";\n\tcase CEPH_MDS_OP_SETLAYOUT: return \"setlayou\";\n\tcase CEPH_MDS_OP_SETDIRLAYOUT: return \"setdirlayout\";\n\tcase CEPH_MDS_OP_READDIR: return \"readdir\";\n\tcase CEPH_MDS_OP_MKNOD: return \"mknod\";\n\tcase CEPH_MDS_OP_LINK: return \"link\";\n\tcase CEPH_MDS_OP_UNLINK: return \"unlink\";\n\tcase CEPH_MDS_OP_RENAME: return \"rename\";\n\tcase CEPH_MDS_OP_MKDIR: return \"mkdir\";\n\tcase CEPH_MDS_OP_RMDIR: return \"rmdir\";\n\tcase CEPH_MDS_OP_SYMLINK: return \"symlink\";\n\tcase CEPH_MDS_OP_CREATE: return \"create\";\n\tcase CEPH_MDS_OP_OPEN: return \"open\";\n\tcase CEPH_MDS_OP_LOOKUPSNAP: return \"lookupsnap\";\n\tcase CEPH_MDS_OP_LSSNAP: return \"lssnap\";\n\tcase CEPH_MDS_OP_MKSNAP: return \"mksnap\";\n\tcase CEPH_MDS_OP_RMSNAP: return \"rmsnap\";\n\tcase CEPH_MDS_OP_SETFILELOCK: return \"setfilelock\";\n\tcase CEPH_MDS_OP_GETFILELOCK: return \"getfilelock\";\n\t}\n\treturn \"???\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_get_cap_for_mds",
          "args": [
            "ceph_inode(req->r_inode)",
            "mds"
          ],
          "line": 2001
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_get_cap_for_mds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "327-335",
          "snippet": "struct ceph_cap *ceph_get_cap_for_mds(struct ceph_inode_info *ci, int mds)\n{\n\tstruct ceph_cap *cap;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tcap = __get_cap_for_mds(ci, mds);\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn cap;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct ceph_cap *ceph_get_cap_for_mds(struct ceph_inode_info *ci, int mds)\n{\n\tstruct ceph_cap *cap;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tcap = __get_cap_for_mds(ci, mds);\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn cap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "req->r_inode"
          ],
          "line": 2001
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __prepare_send_request(struct ceph_mds_client *mdsc,\n\t\t\t\t  struct ceph_mds_request *req,\n\t\t\t\t  int mds)\n{\n\tstruct ceph_mds_request_head *rhead;\n\tstruct ceph_msg *msg;\n\tint flags = 0;\n\n\treq->r_attempts++;\n\tif (req->r_inode) {\n\t\tstruct ceph_cap *cap =\n\t\t\tceph_get_cap_for_mds(ceph_inode(req->r_inode), mds);\n\n\t\tif (cap)\n\t\t\treq->r_sent_on_mseq = cap->mseq;\n\t\telse\n\t\t\treq->r_sent_on_mseq = -1;\n\t}\n\tdout(\"prepare_send_request %p tid %lld %s (attempt %d)\\n\", req,\n\t     req->r_tid, ceph_mds_op_name(req->r_op), req->r_attempts);\n\n\tif (req->r_got_unsafe) {\n\t\tvoid *p;\n\t\t/*\n\t\t * Replay.  Do not regenerate message (and rebuild\n\t\t * paths, etc.); just use the original message.\n\t\t * Rebuilding paths will break for renames because\n\t\t * d_move mangles the src name.\n\t\t */\n\t\tmsg = req->r_request;\n\t\trhead = msg->front.iov_base;\n\n\t\tflags = le32_to_cpu(rhead->flags);\n\t\tflags |= CEPH_MDS_FLAG_REPLAY;\n\t\trhead->flags = cpu_to_le32(flags);\n\n\t\tif (req->r_target_inode)\n\t\t\trhead->ino = cpu_to_le64(ceph_ino(req->r_target_inode));\n\n\t\trhead->num_retry = req->r_attempts - 1;\n\n\t\t/* remove cap/dentry releases from message */\n\t\trhead->num_releases = 0;\n\n\t\t/* time stamp */\n\t\tp = msg->front.iov_base + req->r_request_release_offset;\n\t\t{\n\t\t\tstruct ceph_timespec ts;\n\t\t\tceph_encode_timespec(&ts, &req->r_stamp);\n\t\t\tceph_encode_copy(&p, &ts, sizeof(ts));\n\t\t}\n\n\t\tmsg->front.iov_len = p - msg->front.iov_base;\n\t\tmsg->hdr.front_len = cpu_to_le32(msg->front.iov_len);\n\t\treturn 0;\n\t}\n\n\tif (req->r_request) {\n\t\tceph_msg_put(req->r_request);\n\t\treq->r_request = NULL;\n\t}\n\tmsg = create_request_message(mdsc, req, mds);\n\tif (IS_ERR(msg)) {\n\t\treq->r_err = PTR_ERR(msg);\n\t\tcomplete_request(mdsc, req);\n\t\treturn PTR_ERR(msg);\n\t}\n\treq->r_request = msg;\n\n\trhead = msg->front.iov_base;\n\trhead->oldest_client_tid = cpu_to_le64(__get_oldest_tid(mdsc));\n\tif (req->r_got_unsafe)\n\t\tflags |= CEPH_MDS_FLAG_REPLAY;\n\tif (req->r_locked_dir)\n\t\tflags |= CEPH_MDS_FLAG_WANT_DENTRY;\n\trhead->flags = cpu_to_le32(flags);\n\trhead->num_fwd = req->r_num_fwd;\n\trhead->num_retry = req->r_attempts - 1;\n\trhead->ino = 0;\n\n\tdout(\" r_locked_dir = %p\\n\", req->r_locked_dir);\n\treturn 0;\n}"
  },
  {
    "function_name": "complete_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "1978-1985",
    "snippet": "static void complete_request(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_mds_request *req)\n{\n\tif (req->r_callback)\n\t\treq->r_callback(mdsc, req);\n\telse\n\t\tcomplete_all(&req->r_completion);\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete_all",
          "args": [
            "&req->r_completion"
          ],
          "line": 1984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req->r_callback",
          "args": [
            "mdsc",
            "req"
          ],
          "line": 1982
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void complete_request(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_mds_request *req)\n{\n\tif (req->r_callback)\n\t\treq->r_callback(mdsc, req);\n\telse\n\t\tcomplete_all(&req->r_completion);\n}"
  },
  {
    "function_name": "create_request_message",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "1854-1972",
    "snippet": "static struct ceph_msg *create_request_message(struct ceph_mds_client *mdsc,\n\t\t\t\t\t       struct ceph_mds_request *req,\n\t\t\t\t\t       int mds)\n{\n\tstruct ceph_msg *msg;\n\tstruct ceph_mds_request_head *head;\n\tconst char *path1 = NULL;\n\tconst char *path2 = NULL;\n\tu64 ino1 = 0, ino2 = 0;\n\tint pathlen1 = 0, pathlen2 = 0;\n\tint freepath1 = 0, freepath2 = 0;\n\tint len;\n\tu16 releases;\n\tvoid *p, *end;\n\tint ret;\n\n\tret = set_request_path_attr(req->r_inode, req->r_dentry,\n\t\t\t      req->r_path1, req->r_ino1.ino,\n\t\t\t      &path1, &pathlen1, &ino1, &freepath1);\n\tif (ret < 0) {\n\t\tmsg = ERR_PTR(ret);\n\t\tgoto out;\n\t}\n\n\tret = set_request_path_attr(NULL, req->r_old_dentry,\n\t\t\t      req->r_path2, req->r_ino2.ino,\n\t\t\t      &path2, &pathlen2, &ino2, &freepath2);\n\tif (ret < 0) {\n\t\tmsg = ERR_PTR(ret);\n\t\tgoto out_free1;\n\t}\n\n\tlen = sizeof(*head) +\n\t\tpathlen1 + pathlen2 + 2*(1 + sizeof(u32) + sizeof(u64)) +\n\t\tsizeof(struct timespec);\n\n\t/* calculate (max) length for cap releases */\n\tlen += sizeof(struct ceph_mds_request_release) *\n\t\t(!!req->r_inode_drop + !!req->r_dentry_drop +\n\t\t !!req->r_old_inode_drop + !!req->r_old_dentry_drop);\n\tif (req->r_dentry_drop)\n\t\tlen += req->r_dentry->d_name.len;\n\tif (req->r_old_dentry_drop)\n\t\tlen += req->r_old_dentry->d_name.len;\n\n\tmsg = ceph_msg_new(CEPH_MSG_CLIENT_REQUEST, len, GFP_NOFS, false);\n\tif (!msg) {\n\t\tmsg = ERR_PTR(-ENOMEM);\n\t\tgoto out_free2;\n\t}\n\n\tmsg->hdr.version = cpu_to_le16(2);\n\tmsg->hdr.tid = cpu_to_le64(req->r_tid);\n\n\thead = msg->front.iov_base;\n\tp = msg->front.iov_base + sizeof(*head);\n\tend = msg->front.iov_base + msg->front.iov_len;\n\n\thead->mdsmap_epoch = cpu_to_le32(mdsc->mdsmap->m_epoch);\n\thead->op = cpu_to_le32(req->r_op);\n\thead->caller_uid = cpu_to_le32(from_kuid(&init_user_ns, req->r_uid));\n\thead->caller_gid = cpu_to_le32(from_kgid(&init_user_ns, req->r_gid));\n\thead->args = req->r_args;\n\n\tceph_encode_filepath(&p, end, ino1, path1);\n\tceph_encode_filepath(&p, end, ino2, path2);\n\n\t/* make note of release offset, in case we need to replay */\n\treq->r_request_release_offset = p - msg->front.iov_base;\n\n\t/* cap releases */\n\treleases = 0;\n\tif (req->r_inode_drop)\n\t\treleases += ceph_encode_inode_release(&p,\n\t\t      req->r_inode ? req->r_inode : req->r_dentry->d_inode,\n\t\t      mds, req->r_inode_drop, req->r_inode_unless, 0);\n\tif (req->r_dentry_drop)\n\t\treleases += ceph_encode_dentry_release(&p, req->r_dentry,\n\t\t       mds, req->r_dentry_drop, req->r_dentry_unless);\n\tif (req->r_old_dentry_drop)\n\t\treleases += ceph_encode_dentry_release(&p, req->r_old_dentry,\n\t\t       mds, req->r_old_dentry_drop, req->r_old_dentry_unless);\n\tif (req->r_old_inode_drop)\n\t\treleases += ceph_encode_inode_release(&p,\n\t\t      req->r_old_dentry->d_inode,\n\t\t      mds, req->r_old_inode_drop, req->r_old_inode_unless, 0);\n\thead->num_releases = cpu_to_le16(releases);\n\n\t/* time stamp */\n\t{\n\t\tstruct ceph_timespec ts;\n\t\tceph_encode_timespec(&ts, &req->r_stamp);\n\t\tceph_encode_copy(&p, &ts, sizeof(ts));\n\t}\n\n\tBUG_ON(p > end);\n\tmsg->front.iov_len = p - msg->front.iov_base;\n\tmsg->hdr.front_len = cpu_to_le32(msg->front.iov_len);\n\n\tif (req->r_pagelist) {\n\t\tstruct ceph_pagelist *pagelist = req->r_pagelist;\n\t\tatomic_inc(&pagelist->refcnt);\n\t\tceph_msg_data_add_pagelist(msg, pagelist);\n\t\tmsg->hdr.data_len = cpu_to_le32(pagelist->length);\n\t} else {\n\t\tmsg->hdr.data_len = 0;\n\t}\n\n\tmsg->hdr.data_off = cpu_to_le16(0);\n\nout_free2:\n\tif (freepath2)\n\t\tkfree((char *)path2);\nout_free1:\n\tif (freepath1)\n\t\tkfree((char *)path1);\nout:\n\treturn msg;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "(char *)path1"
          ],
          "line": 1969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "(char *)path2"
          ],
          "line": 1966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "0"
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "pagelist->length"
          ],
          "line": 1957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_msg_data_add_pagelist",
          "args": [
            "msg",
            "pagelist"
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&pagelist->refcnt"
          ],
          "line": 1955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "msg->front.iov_len"
          ],
          "line": 1951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "p > end"
          ],
          "line": 1949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_encode_copy",
          "args": [
            "&p",
            "&ts",
            "sizeof(ts)"
          ],
          "line": 1946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_encode_timespec",
          "args": [
            "&ts",
            "&req->r_stamp"
          ],
          "line": 1945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "releases"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_encode_inode_release",
          "args": [
            "&p",
            "req->r_old_dentry->d_inode",
            "mds",
            "req->r_old_inode_drop",
            "req->r_old_inode_unless",
            "0"
          ],
          "line": 1937
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_encode_inode_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "3325-3389",
          "snippet": "int ceph_encode_inode_release(void **p, struct inode *inode,\n\t\t\t      int mds, int drop, int unless, int force)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_cap *cap;\n\tstruct ceph_mds_request_release *rel = *p;\n\tint used, dirty;\n\tint ret = 0;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tused = __ceph_caps_used(ci);\n\tdirty = __ceph_caps_dirty(ci);\n\n\tdout(\"encode_inode_release %p mds%d used|dirty %s drop %s unless %s\\n\",\n\t     inode, mds, ceph_cap_string(used|dirty), ceph_cap_string(drop),\n\t     ceph_cap_string(unless));\n\n\t/* only drop unused, clean caps */\n\tdrop &= ~(used | dirty);\n\n\tcap = __get_cap_for_mds(ci, mds);\n\tif (cap && __cap_is_valid(cap)) {\n\t\tif (force ||\n\t\t    ((cap->issued & drop) &&\n\t\t     (cap->issued & unless) == 0)) {\n\t\t\tif ((cap->issued & drop) &&\n\t\t\t    (cap->issued & unless) == 0) {\n\t\t\t\tint wanted = __ceph_caps_wanted(ci);\n\t\t\t\tif ((ci->i_ceph_flags & CEPH_I_NODELAY) == 0)\n\t\t\t\t\twanted |= cap->mds_wanted;\n\t\t\t\tdout(\"encode_inode_release %p cap %p \"\n\t\t\t\t     \"%s -> %s, wanted %s -> %s\\n\", inode, cap,\n\t\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t\t     ceph_cap_string(cap->issued & ~drop),\n\t\t\t\t     ceph_cap_string(cap->mds_wanted),\n\t\t\t\t     ceph_cap_string(wanted));\n\n\t\t\t\tcap->issued &= ~drop;\n\t\t\t\tcap->implemented &= ~drop;\n\t\t\t\tcap->mds_wanted = wanted;\n\t\t\t} else {\n\t\t\t\tdout(\"encode_inode_release %p cap %p %s\"\n\t\t\t\t     \" (force)\\n\", inode, cap,\n\t\t\t\t     ceph_cap_string(cap->issued));\n\t\t\t}\n\n\t\t\trel->ino = cpu_to_le64(ceph_ino(inode));\n\t\t\trel->cap_id = cpu_to_le64(cap->cap_id);\n\t\t\trel->seq = cpu_to_le32(cap->seq);\n\t\t\trel->issue_seq = cpu_to_le32(cap->issue_seq);\n\t\t\trel->mseq = cpu_to_le32(cap->mseq);\n\t\t\trel->caps = cpu_to_le32(cap->implemented);\n\t\t\trel->wanted = cpu_to_le32(cap->mds_wanted);\n\t\t\trel->dname_len = 0;\n\t\t\trel->dname_seq = 0;\n\t\t\t*p += sizeof(*rel);\n\t\t\tret = 1;\n\t\t} else {\n\t\t\tdout(\"encode_inode_release %p cap %p %s\\n\",\n\t\t\t     inode, cap, ceph_cap_string(cap->issued));\n\t\t}\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_encode_inode_release(void **p, struct inode *inode,\n\t\t\t      int mds, int drop, int unless, int force)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_cap *cap;\n\tstruct ceph_mds_request_release *rel = *p;\n\tint used, dirty;\n\tint ret = 0;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tused = __ceph_caps_used(ci);\n\tdirty = __ceph_caps_dirty(ci);\n\n\tdout(\"encode_inode_release %p mds%d used|dirty %s drop %s unless %s\\n\",\n\t     inode, mds, ceph_cap_string(used|dirty), ceph_cap_string(drop),\n\t     ceph_cap_string(unless));\n\n\t/* only drop unused, clean caps */\n\tdrop &= ~(used | dirty);\n\n\tcap = __get_cap_for_mds(ci, mds);\n\tif (cap && __cap_is_valid(cap)) {\n\t\tif (force ||\n\t\t    ((cap->issued & drop) &&\n\t\t     (cap->issued & unless) == 0)) {\n\t\t\tif ((cap->issued & drop) &&\n\t\t\t    (cap->issued & unless) == 0) {\n\t\t\t\tint wanted = __ceph_caps_wanted(ci);\n\t\t\t\tif ((ci->i_ceph_flags & CEPH_I_NODELAY) == 0)\n\t\t\t\t\twanted |= cap->mds_wanted;\n\t\t\t\tdout(\"encode_inode_release %p cap %p \"\n\t\t\t\t     \"%s -> %s, wanted %s -> %s\\n\", inode, cap,\n\t\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t\t     ceph_cap_string(cap->issued & ~drop),\n\t\t\t\t     ceph_cap_string(cap->mds_wanted),\n\t\t\t\t     ceph_cap_string(wanted));\n\n\t\t\t\tcap->issued &= ~drop;\n\t\t\t\tcap->implemented &= ~drop;\n\t\t\t\tcap->mds_wanted = wanted;\n\t\t\t} else {\n\t\t\t\tdout(\"encode_inode_release %p cap %p %s\"\n\t\t\t\t     \" (force)\\n\", inode, cap,\n\t\t\t\t     ceph_cap_string(cap->issued));\n\t\t\t}\n\n\t\t\trel->ino = cpu_to_le64(ceph_ino(inode));\n\t\t\trel->cap_id = cpu_to_le64(cap->cap_id);\n\t\t\trel->seq = cpu_to_le32(cap->seq);\n\t\t\trel->issue_seq = cpu_to_le32(cap->issue_seq);\n\t\t\trel->mseq = cpu_to_le32(cap->mseq);\n\t\t\trel->caps = cpu_to_le32(cap->implemented);\n\t\t\trel->wanted = cpu_to_le32(cap->mds_wanted);\n\t\t\trel->dname_len = 0;\n\t\t\trel->dname_seq = 0;\n\t\t\t*p += sizeof(*rel);\n\t\t\tret = 1;\n\t\t} else {\n\t\t\tdout(\"encode_inode_release %p cap %p %s\\n\",\n\t\t\t     inode, cap, ceph_cap_string(cap->issued));\n\t\t}\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_encode_dentry_release",
          "args": [
            "&p",
            "req->r_old_dentry",
            "mds",
            "req->r_old_dentry_drop",
            "req->r_old_dentry_unless"
          ],
          "line": 1934
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_encode_dentry_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "3391-3425",
          "snippet": "int ceph_encode_dentry_release(void **p, struct dentry *dentry,\n\t\t\t       int mds, int drop, int unless)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct ceph_mds_request_release *rel = *p;\n\tstruct ceph_dentry_info *di = ceph_dentry(dentry);\n\tint force = 0;\n\tint ret;\n\n\t/*\n\t * force an record for the directory caps if we have a dentry lease.\n\t * this is racy (can't take i_ceph_lock and d_lock together), but it\n\t * doesn't have to be perfect; the mds will revoke anything we don't\n\t * release.\n\t */\n\tspin_lock(&dentry->d_lock);\n\tif (di->lease_session && di->lease_session->s_mds == mds)\n\t\tforce = 1;\n\tspin_unlock(&dentry->d_lock);\n\n\tret = ceph_encode_inode_release(p, dir, mds, drop, unless, force);\n\n\tspin_lock(&dentry->d_lock);\n\tif (ret && di->lease_session && di->lease_session->s_mds == mds) {\n\t\tdout(\"encode_dentry_release %p mds%d seq %d\\n\",\n\t\t     dentry, mds, (int)di->lease_seq);\n\t\trel->dname_len = cpu_to_le32(dentry->d_name.len);\n\t\tmemcpy(*p, dentry->d_name.name, dentry->d_name.len);\n\t\t*p += dentry->d_name.len;\n\t\trel->dname_seq = cpu_to_le32(di->lease_seq);\n\t\t__ceph_mdsc_drop_dentry_lease(dentry);\n\t}\n\tspin_unlock(&dentry->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_encode_dentry_release(void **p, struct dentry *dentry,\n\t\t\t       int mds, int drop, int unless)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct ceph_mds_request_release *rel = *p;\n\tstruct ceph_dentry_info *di = ceph_dentry(dentry);\n\tint force = 0;\n\tint ret;\n\n\t/*\n\t * force an record for the directory caps if we have a dentry lease.\n\t * this is racy (can't take i_ceph_lock and d_lock together), but it\n\t * doesn't have to be perfect; the mds will revoke anything we don't\n\t * release.\n\t */\n\tspin_lock(&dentry->d_lock);\n\tif (di->lease_session && di->lease_session->s_mds == mds)\n\t\tforce = 1;\n\tspin_unlock(&dentry->d_lock);\n\n\tret = ceph_encode_inode_release(p, dir, mds, drop, unless, force);\n\n\tspin_lock(&dentry->d_lock);\n\tif (ret && di->lease_session && di->lease_session->s_mds == mds) {\n\t\tdout(\"encode_dentry_release %p mds%d seq %d\\n\",\n\t\t     dentry, mds, (int)di->lease_seq);\n\t\trel->dname_len = cpu_to_le32(dentry->d_name.len);\n\t\tmemcpy(*p, dentry->d_name.name, dentry->d_name.len);\n\t\t*p += dentry->d_name.len;\n\t\trel->dname_seq = cpu_to_le32(di->lease_seq);\n\t\t__ceph_mdsc_drop_dentry_lease(dentry);\n\t}\n\tspin_unlock(&dentry->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_encode_filepath",
          "args": [
            "&p",
            "end",
            "ino2",
            "path2"
          ],
          "line": 1919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_encode_filepath",
          "args": [
            "&p",
            "end",
            "ino1",
            "path1"
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "from_kgid(&init_user_ns, req->r_gid)"
          ],
          "line": 1915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "req->r_gid"
          ],
          "line": 1915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "from_kuid(&init_user_ns, req->r_uid)"
          ],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "req->r_uid"
          ],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "req->r_op"
          ],
          "line": 1913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "mdsc->mdsmap->m_epoch"
          ],
          "line": 1912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "req->r_tid"
          ],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "2"
          ],
          "line": 1905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 1901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_msg_new",
          "args": [
            "CEPH_MSG_CLIENT_REQUEST",
            "len",
            "GFP_NOFS",
            "false"
          ],
          "line": 1899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 1882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_request_path_attr",
          "args": [
            "NULL",
            "req->r_old_dentry",
            "req->r_path2",
            "req->r_ino2.ino",
            "&path2",
            "&pathlen2",
            "&ino2",
            "&freepath2"
          ],
          "line": 1878
        },
        "resolved": true,
        "details": {
          "function_name": "set_request_path_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1826-1849",
          "snippet": "static int set_request_path_attr(struct inode *rinode, struct dentry *rdentry,\n\t\t\t\t  const char *rpath, u64 rino,\n\t\t\t\t  const char **ppath, int *pathlen,\n\t\t\t\t  u64 *ino, int *freepath)\n{\n\tint r = 0;\n\n\tif (rinode) {\n\t\tr = build_inode_path(rinode, ppath, pathlen, ino, freepath);\n\t\tdout(\" inode %p %llx.%llx\\n\", rinode, ceph_ino(rinode),\n\t\t     ceph_snap(rinode));\n\t} else if (rdentry) {\n\t\tr = build_dentry_path(rdentry, ppath, pathlen, ino, freepath);\n\t\tdout(\" dentry %p %llx/%.*s\\n\", rdentry, *ino, *pathlen,\n\t\t     *ppath);\n\t} else if (rpath || rino) {\n\t\t*ino = rino;\n\t\t*ppath = rpath;\n\t\t*pathlen = rpath ? strlen(rpath) : 0;\n\t\tdout(\" path %.*s\\n\", *pathlen, rpath);\n\t}\n\n\treturn r;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int set_request_path_attr(struct inode *rinode, struct dentry *rdentry,\n\t\t\t\t  const char *rpath, u64 rino,\n\t\t\t\t  const char **ppath, int *pathlen,\n\t\t\t\t  u64 *ino, int *freepath)\n{\n\tint r = 0;\n\n\tif (rinode) {\n\t\tr = build_inode_path(rinode, ppath, pathlen, ino, freepath);\n\t\tdout(\" inode %p %llx.%llx\\n\", rinode, ceph_ino(rinode),\n\t\t     ceph_snap(rinode));\n\t} else if (rdentry) {\n\t\tr = build_dentry_path(rdentry, ppath, pathlen, ino, freepath);\n\t\tdout(\" dentry %p %llx/%.*s\\n\", rdentry, *ino, *pathlen,\n\t\t     *ppath);\n\t} else if (rpath || rino) {\n\t\t*ino = rino;\n\t\t*ppath = rpath;\n\t\t*pathlen = rpath ? strlen(rpath) : 0;\n\t\tdout(\" path %.*s\\n\", *pathlen, rpath);\n\t}\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 1874
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);\n\nstatic struct ceph_msg *create_request_message(struct ceph_mds_client *mdsc,\n\t\t\t\t\t       struct ceph_mds_request *req,\n\t\t\t\t\t       int mds)\n{\n\tstruct ceph_msg *msg;\n\tstruct ceph_mds_request_head *head;\n\tconst char *path1 = NULL;\n\tconst char *path2 = NULL;\n\tu64 ino1 = 0, ino2 = 0;\n\tint pathlen1 = 0, pathlen2 = 0;\n\tint freepath1 = 0, freepath2 = 0;\n\tint len;\n\tu16 releases;\n\tvoid *p, *end;\n\tint ret;\n\n\tret = set_request_path_attr(req->r_inode, req->r_dentry,\n\t\t\t      req->r_path1, req->r_ino1.ino,\n\t\t\t      &path1, &pathlen1, &ino1, &freepath1);\n\tif (ret < 0) {\n\t\tmsg = ERR_PTR(ret);\n\t\tgoto out;\n\t}\n\n\tret = set_request_path_attr(NULL, req->r_old_dentry,\n\t\t\t      req->r_path2, req->r_ino2.ino,\n\t\t\t      &path2, &pathlen2, &ino2, &freepath2);\n\tif (ret < 0) {\n\t\tmsg = ERR_PTR(ret);\n\t\tgoto out_free1;\n\t}\n\n\tlen = sizeof(*head) +\n\t\tpathlen1 + pathlen2 + 2*(1 + sizeof(u32) + sizeof(u64)) +\n\t\tsizeof(struct timespec);\n\n\t/* calculate (max) length for cap releases */\n\tlen += sizeof(struct ceph_mds_request_release) *\n\t\t(!!req->r_inode_drop + !!req->r_dentry_drop +\n\t\t !!req->r_old_inode_drop + !!req->r_old_dentry_drop);\n\tif (req->r_dentry_drop)\n\t\tlen += req->r_dentry->d_name.len;\n\tif (req->r_old_dentry_drop)\n\t\tlen += req->r_old_dentry->d_name.len;\n\n\tmsg = ceph_msg_new(CEPH_MSG_CLIENT_REQUEST, len, GFP_NOFS, false);\n\tif (!msg) {\n\t\tmsg = ERR_PTR(-ENOMEM);\n\t\tgoto out_free2;\n\t}\n\n\tmsg->hdr.version = cpu_to_le16(2);\n\tmsg->hdr.tid = cpu_to_le64(req->r_tid);\n\n\thead = msg->front.iov_base;\n\tp = msg->front.iov_base + sizeof(*head);\n\tend = msg->front.iov_base + msg->front.iov_len;\n\n\thead->mdsmap_epoch = cpu_to_le32(mdsc->mdsmap->m_epoch);\n\thead->op = cpu_to_le32(req->r_op);\n\thead->caller_uid = cpu_to_le32(from_kuid(&init_user_ns, req->r_uid));\n\thead->caller_gid = cpu_to_le32(from_kgid(&init_user_ns, req->r_gid));\n\thead->args = req->r_args;\n\n\tceph_encode_filepath(&p, end, ino1, path1);\n\tceph_encode_filepath(&p, end, ino2, path2);\n\n\t/* make note of release offset, in case we need to replay */\n\treq->r_request_release_offset = p - msg->front.iov_base;\n\n\t/* cap releases */\n\treleases = 0;\n\tif (req->r_inode_drop)\n\t\treleases += ceph_encode_inode_release(&p,\n\t\t      req->r_inode ? req->r_inode : req->r_dentry->d_inode,\n\t\t      mds, req->r_inode_drop, req->r_inode_unless, 0);\n\tif (req->r_dentry_drop)\n\t\treleases += ceph_encode_dentry_release(&p, req->r_dentry,\n\t\t       mds, req->r_dentry_drop, req->r_dentry_unless);\n\tif (req->r_old_dentry_drop)\n\t\treleases += ceph_encode_dentry_release(&p, req->r_old_dentry,\n\t\t       mds, req->r_old_dentry_drop, req->r_old_dentry_unless);\n\tif (req->r_old_inode_drop)\n\t\treleases += ceph_encode_inode_release(&p,\n\t\t      req->r_old_dentry->d_inode,\n\t\t      mds, req->r_old_inode_drop, req->r_old_inode_unless, 0);\n\thead->num_releases = cpu_to_le16(releases);\n\n\t/* time stamp */\n\t{\n\t\tstruct ceph_timespec ts;\n\t\tceph_encode_timespec(&ts, &req->r_stamp);\n\t\tceph_encode_copy(&p, &ts, sizeof(ts));\n\t}\n\n\tBUG_ON(p > end);\n\tmsg->front.iov_len = p - msg->front.iov_base;\n\tmsg->hdr.front_len = cpu_to_le32(msg->front.iov_len);\n\n\tif (req->r_pagelist) {\n\t\tstruct ceph_pagelist *pagelist = req->r_pagelist;\n\t\tatomic_inc(&pagelist->refcnt);\n\t\tceph_msg_data_add_pagelist(msg, pagelist);\n\t\tmsg->hdr.data_len = cpu_to_le32(pagelist->length);\n\t} else {\n\t\tmsg->hdr.data_len = 0;\n\t}\n\n\tmsg->hdr.data_off = cpu_to_le16(0);\n\nout_free2:\n\tif (freepath2)\n\t\tkfree((char *)path2);\nout_free1:\n\tif (freepath1)\n\t\tkfree((char *)path1);\nout:\n\treturn msg;\n}"
  },
  {
    "function_name": "set_request_path_attr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "1826-1849",
    "snippet": "static int set_request_path_attr(struct inode *rinode, struct dentry *rdentry,\n\t\t\t\t  const char *rpath, u64 rino,\n\t\t\t\t  const char **ppath, int *pathlen,\n\t\t\t\t  u64 *ino, int *freepath)\n{\n\tint r = 0;\n\n\tif (rinode) {\n\t\tr = build_inode_path(rinode, ppath, pathlen, ino, freepath);\n\t\tdout(\" inode %p %llx.%llx\\n\", rinode, ceph_ino(rinode),\n\t\t     ceph_snap(rinode));\n\t} else if (rdentry) {\n\t\tr = build_dentry_path(rdentry, ppath, pathlen, ino, freepath);\n\t\tdout(\" dentry %p %llx/%.*s\\n\", rdentry, *ino, *pathlen,\n\t\t     *ppath);\n\t} else if (rpath || rino) {\n\t\t*ino = rino;\n\t\t*ppath = rpath;\n\t\t*pathlen = rpath ? strlen(rpath) : 0;\n\t\tdout(\" path %.*s\\n\", *pathlen, rpath);\n\t}\n\n\treturn r;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" path %.*s\\n\"",
            "*pathlen",
            "rpath"
          ],
          "line": 1845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "rpath"
          ],
          "line": 1844
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" dentry %p %llx/%.*s\\n\"",
            "rdentry",
            "*ino",
            "*pathlen",
            "*ppath"
          ],
          "line": 1839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_dentry_path",
          "args": [
            "rdentry",
            "ppath",
            "pathlen",
            "ino",
            "freepath"
          ],
          "line": 1838
        },
        "resolved": true,
        "details": {
          "function_name": "build_dentry_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1780-1798",
          "snippet": "static int build_dentry_path(struct dentry *dentry,\n\t\t\t     const char **ppath, int *ppathlen, u64 *pino,\n\t\t\t     int *pfreepath)\n{\n\tchar *path;\n\n\tif (ceph_snap(dentry->d_parent->d_inode) == CEPH_NOSNAP) {\n\t\t*pino = ceph_ino(dentry->d_parent->d_inode);\n\t\t*ppath = dentry->d_name.name;\n\t\t*ppathlen = dentry->d_name.len;\n\t\treturn 0;\n\t}\n\tpath = ceph_mdsc_build_path(dentry, ppathlen, pino, 1);\n\tif (IS_ERR(path))\n\t\treturn PTR_ERR(path);\n\t*ppath = path;\n\t*pfreepath = 1;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int build_dentry_path(struct dentry *dentry,\n\t\t\t     const char **ppath, int *ppathlen, u64 *pino,\n\t\t\t     int *pfreepath)\n{\n\tchar *path;\n\n\tif (ceph_snap(dentry->d_parent->d_inode) == CEPH_NOSNAP) {\n\t\t*pino = ceph_ino(dentry->d_parent->d_inode);\n\t\t*ppath = dentry->d_name.name;\n\t\t*ppathlen = dentry->d_name.len;\n\t\treturn 0;\n\t}\n\tpath = ceph_mdsc_build_path(dentry, ppathlen, pino, 1);\n\tif (IS_ERR(path))\n\t\treturn PTR_ERR(path);\n\t*ppath = path;\n\t*pfreepath = 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" inode %p %llx.%llx\\n\"",
            "rinode",
            "ceph_ino(rinode)",
            "ceph_snap(rinode)"
          ],
          "line": 1835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_snap",
          "args": [
            "rinode"
          ],
          "line": 1836
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_snap_op_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/strings.c",
          "lines": "115-124",
          "snippet": "const char *ceph_snap_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_SNAP_OP_UPDATE: return \"update\";\n\tcase CEPH_SNAP_OP_CREATE: return \"create\";\n\tcase CEPH_SNAP_OP_DESTROY: return \"destroy\";\n\tcase CEPH_SNAP_OP_SPLIT: return \"split\";\n\t}\n\treturn \"???\";\n}",
          "includes": [
            "#include <linux/ceph/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/types.h>\n#include <linux/module.h>\n\nconst char *ceph_snap_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_SNAP_OP_UPDATE: return \"update\";\n\tcase CEPH_SNAP_OP_CREATE: return \"create\";\n\tcase CEPH_SNAP_OP_DESTROY: return \"destroy\";\n\tcase CEPH_SNAP_OP_SPLIT: return \"split\";\n\t}\n\treturn \"???\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_ino",
          "args": [
            "rinode"
          ],
          "line": 1835
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "412-415",
          "snippet": "static inline u64 ceph_ino(struct inode *inode)\n{\n\treturn ceph_inode(inode)->i_vino.ino;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline u64 ceph_ino(struct inode *inode)\n{\n\treturn ceph_inode(inode)->i_vino.ino;\n}"
        }
      },
      {
        "call_info": {
          "callee": "build_inode_path",
          "args": [
            "rinode",
            "ppath",
            "pathlen",
            "ino",
            "freepath"
          ],
          "line": 1834
        },
        "resolved": true,
        "details": {
          "function_name": "build_inode_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1800-1820",
          "snippet": "static int build_inode_path(struct inode *inode,\n\t\t\t    const char **ppath, int *ppathlen, u64 *pino,\n\t\t\t    int *pfreepath)\n{\n\tstruct dentry *dentry;\n\tchar *path;\n\n\tif (ceph_snap(inode) == CEPH_NOSNAP) {\n\t\t*pino = ceph_ino(inode);\n\t\t*ppathlen = 0;\n\t\treturn 0;\n\t}\n\tdentry = d_find_alias(inode);\n\tpath = ceph_mdsc_build_path(dentry, ppathlen, pino, 1);\n\tdput(dentry);\n\tif (IS_ERR(path))\n\t\treturn PTR_ERR(path);\n\t*ppath = path;\n\t*pfreepath = 1;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int build_inode_path(struct inode *inode,\n\t\t\t    const char **ppath, int *ppathlen, u64 *pino,\n\t\t\t    int *pfreepath)\n{\n\tstruct dentry *dentry;\n\tchar *path;\n\n\tif (ceph_snap(inode) == CEPH_NOSNAP) {\n\t\t*pino = ceph_ino(inode);\n\t\t*ppathlen = 0;\n\t\treturn 0;\n\t}\n\tdentry = d_find_alias(inode);\n\tpath = ceph_mdsc_build_path(dentry, ppathlen, pino, 1);\n\tdput(dentry);\n\tif (IS_ERR(path))\n\t\treturn PTR_ERR(path);\n\t*ppath = path;\n\t*pfreepath = 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int set_request_path_attr(struct inode *rinode, struct dentry *rdentry,\n\t\t\t\t  const char *rpath, u64 rino,\n\t\t\t\t  const char **ppath, int *pathlen,\n\t\t\t\t  u64 *ino, int *freepath)\n{\n\tint r = 0;\n\n\tif (rinode) {\n\t\tr = build_inode_path(rinode, ppath, pathlen, ino, freepath);\n\t\tdout(\" inode %p %llx.%llx\\n\", rinode, ceph_ino(rinode),\n\t\t     ceph_snap(rinode));\n\t} else if (rdentry) {\n\t\tr = build_dentry_path(rdentry, ppath, pathlen, ino, freepath);\n\t\tdout(\" dentry %p %llx/%.*s\\n\", rdentry, *ino, *pathlen,\n\t\t     *ppath);\n\t} else if (rpath || rino) {\n\t\t*ino = rino;\n\t\t*ppath = rpath;\n\t\t*pathlen = rpath ? strlen(rpath) : 0;\n\t\tdout(\" path %.*s\\n\", *pathlen, rpath);\n\t}\n\n\treturn r;\n}"
  },
  {
    "function_name": "build_inode_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "1800-1820",
    "snippet": "static int build_inode_path(struct inode *inode,\n\t\t\t    const char **ppath, int *ppathlen, u64 *pino,\n\t\t\t    int *pfreepath)\n{\n\tstruct dentry *dentry;\n\tchar *path;\n\n\tif (ceph_snap(inode) == CEPH_NOSNAP) {\n\t\t*pino = ceph_ino(inode);\n\t\t*ppathlen = 0;\n\t\treturn 0;\n\t}\n\tdentry = d_find_alias(inode);\n\tpath = ceph_mdsc_build_path(dentry, ppathlen, pino, 1);\n\tdput(dentry);\n\tif (IS_ERR(path))\n\t\treturn PTR_ERR(path);\n\t*ppath = path;\n\t*pfreepath = 1;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "path"
          ],
          "line": 1816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "path"
          ],
          "line": 1815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 1814
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_build_path",
          "args": [
            "dentry",
            "ppathlen",
            "pino",
            "1"
          ],
          "line": 1813
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_build_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1699-1778",
          "snippet": "char *ceph_mdsc_build_path(struct dentry *dentry, int *plen, u64 *base,\n\t\t\t   int stop_on_nosnap)\n{\n\tstruct dentry *temp;\n\tchar *path;\n\tint len, pos;\n\tunsigned seq;\n\n\tif (dentry == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\nretry:\n\tlen = 0;\n\tseq = read_seqbegin(&rename_lock);\n\trcu_read_lock();\n\tfor (temp = dentry; !IS_ROOT(temp);) {\n\t\tstruct inode *inode = temp->d_inode;\n\t\tif (inode && ceph_snap(inode) == CEPH_SNAPDIR)\n\t\t\tlen++;  /* slash only */\n\t\telse if (stop_on_nosnap && inode &&\n\t\t\t ceph_snap(inode) == CEPH_NOSNAP)\n\t\t\tbreak;\n\t\telse\n\t\t\tlen += 1 + temp->d_name.len;\n\t\ttemp = temp->d_parent;\n\t}\n\trcu_read_unlock();\n\tif (len)\n\t\tlen--;  /* no leading '/' */\n\n\tpath = kmalloc(len+1, GFP_NOFS);\n\tif (path == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tpos = len;\n\tpath[pos] = 0;\t/* trailing null */\n\trcu_read_lock();\n\tfor (temp = dentry; !IS_ROOT(temp) && pos != 0; ) {\n\t\tstruct inode *inode;\n\n\t\tspin_lock(&temp->d_lock);\n\t\tinode = temp->d_inode;\n\t\tif (inode && ceph_snap(inode) == CEPH_SNAPDIR) {\n\t\t\tdout(\"build_path path+%d: %p SNAPDIR\\n\",\n\t\t\t     pos, temp);\n\t\t} else if (stop_on_nosnap && inode &&\n\t\t\t   ceph_snap(inode) == CEPH_NOSNAP) {\n\t\t\tspin_unlock(&temp->d_lock);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tpos -= temp->d_name.len;\n\t\t\tif (pos < 0) {\n\t\t\t\tspin_unlock(&temp->d_lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrncpy(path + pos, temp->d_name.name,\n\t\t\t\ttemp->d_name.len);\n\t\t}\n\t\tspin_unlock(&temp->d_lock);\n\t\tif (pos)\n\t\t\tpath[--pos] = '/';\n\t\ttemp = temp->d_parent;\n\t}\n\trcu_read_unlock();\n\tif (pos != 0 || read_seqretry(&rename_lock, seq)) {\n\t\tpr_err(\"build_path did not end path lookup where \"\n\t\t       \"expected, namelen is %d, pos is %d\\n\", len, pos);\n\t\t/* presumably this is only possible if racing with a\n\t\t   rename of one of the parent directories (we can not\n\t\t   lock the dentries above us to prevent this, but\n\t\t   retrying should be harmless) */\n\t\tkfree(path);\n\t\tgoto retry;\n\t}\n\n\t*base = ceph_ino(temp->d_inode);\n\t*plen = len;\n\tdout(\"build_path on %p %d built %llx '%.*s'\\n\",\n\t     dentry, d_count(dentry), *base, len, path);\n\treturn path;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nchar *ceph_mdsc_build_path(struct dentry *dentry, int *plen, u64 *base,\n\t\t\t   int stop_on_nosnap)\n{\n\tstruct dentry *temp;\n\tchar *path;\n\tint len, pos;\n\tunsigned seq;\n\n\tif (dentry == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\nretry:\n\tlen = 0;\n\tseq = read_seqbegin(&rename_lock);\n\trcu_read_lock();\n\tfor (temp = dentry; !IS_ROOT(temp);) {\n\t\tstruct inode *inode = temp->d_inode;\n\t\tif (inode && ceph_snap(inode) == CEPH_SNAPDIR)\n\t\t\tlen++;  /* slash only */\n\t\telse if (stop_on_nosnap && inode &&\n\t\t\t ceph_snap(inode) == CEPH_NOSNAP)\n\t\t\tbreak;\n\t\telse\n\t\t\tlen += 1 + temp->d_name.len;\n\t\ttemp = temp->d_parent;\n\t}\n\trcu_read_unlock();\n\tif (len)\n\t\tlen--;  /* no leading '/' */\n\n\tpath = kmalloc(len+1, GFP_NOFS);\n\tif (path == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tpos = len;\n\tpath[pos] = 0;\t/* trailing null */\n\trcu_read_lock();\n\tfor (temp = dentry; !IS_ROOT(temp) && pos != 0; ) {\n\t\tstruct inode *inode;\n\n\t\tspin_lock(&temp->d_lock);\n\t\tinode = temp->d_inode;\n\t\tif (inode && ceph_snap(inode) == CEPH_SNAPDIR) {\n\t\t\tdout(\"build_path path+%d: %p SNAPDIR\\n\",\n\t\t\t     pos, temp);\n\t\t} else if (stop_on_nosnap && inode &&\n\t\t\t   ceph_snap(inode) == CEPH_NOSNAP) {\n\t\t\tspin_unlock(&temp->d_lock);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tpos -= temp->d_name.len;\n\t\t\tif (pos < 0) {\n\t\t\t\tspin_unlock(&temp->d_lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrncpy(path + pos, temp->d_name.name,\n\t\t\t\ttemp->d_name.len);\n\t\t}\n\t\tspin_unlock(&temp->d_lock);\n\t\tif (pos)\n\t\t\tpath[--pos] = '/';\n\t\ttemp = temp->d_parent;\n\t}\n\trcu_read_unlock();\n\tif (pos != 0 || read_seqretry(&rename_lock, seq)) {\n\t\tpr_err(\"build_path did not end path lookup where \"\n\t\t       \"expected, namelen is %d, pos is %d\\n\", len, pos);\n\t\t/* presumably this is only possible if racing with a\n\t\t   rename of one of the parent directories (we can not\n\t\t   lock the dentries above us to prevent this, but\n\t\t   retrying should be harmless) */\n\t\tkfree(path);\n\t\tgoto retry;\n\t}\n\n\t*base = ceph_ino(temp->d_inode);\n\t*plen = len;\n\tdout(\"build_path on %p %d built %llx '%.*s'\\n\",\n\t     dentry, d_count(dentry), *base, len, path);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_find_alias",
          "args": [
            "inode"
          ],
          "line": 1812
        },
        "resolved": true,
        "details": {
          "function_name": "d_find_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "865-875",
          "snippet": "struct dentry *d_find_alias(struct inode *inode)\n{\n\tstruct dentry *de = NULL;\n\n\tif (!hlist_empty(&inode->i_dentry)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tde = __d_find_alias(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\treturn de;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_find_alias(struct inode *inode)\n{\n\tstruct dentry *de = NULL;\n\n\tif (!hlist_empty(&inode->i_dentry)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tde = __d_find_alias(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\treturn de;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_ino",
          "args": [
            "inode"
          ],
          "line": 1808
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "412-415",
          "snippet": "static inline u64 ceph_ino(struct inode *inode)\n{\n\treturn ceph_inode(inode)->i_vino.ino;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline u64 ceph_ino(struct inode *inode)\n{\n\treturn ceph_inode(inode)->i_vino.ino;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_snap",
          "args": [
            "inode"
          ],
          "line": 1807
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_snap_op_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/strings.c",
          "lines": "115-124",
          "snippet": "const char *ceph_snap_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_SNAP_OP_UPDATE: return \"update\";\n\tcase CEPH_SNAP_OP_CREATE: return \"create\";\n\tcase CEPH_SNAP_OP_DESTROY: return \"destroy\";\n\tcase CEPH_SNAP_OP_SPLIT: return \"split\";\n\t}\n\treturn \"???\";\n}",
          "includes": [
            "#include <linux/ceph/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/types.h>\n#include <linux/module.h>\n\nconst char *ceph_snap_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_SNAP_OP_UPDATE: return \"update\";\n\tcase CEPH_SNAP_OP_CREATE: return \"create\";\n\tcase CEPH_SNAP_OP_DESTROY: return \"destroy\";\n\tcase CEPH_SNAP_OP_SPLIT: return \"split\";\n\t}\n\treturn \"???\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int build_inode_path(struct inode *inode,\n\t\t\t    const char **ppath, int *ppathlen, u64 *pino,\n\t\t\t    int *pfreepath)\n{\n\tstruct dentry *dentry;\n\tchar *path;\n\n\tif (ceph_snap(inode) == CEPH_NOSNAP) {\n\t\t*pino = ceph_ino(inode);\n\t\t*ppathlen = 0;\n\t\treturn 0;\n\t}\n\tdentry = d_find_alias(inode);\n\tpath = ceph_mdsc_build_path(dentry, ppathlen, pino, 1);\n\tdput(dentry);\n\tif (IS_ERR(path))\n\t\treturn PTR_ERR(path);\n\t*ppath = path;\n\t*pfreepath = 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "build_dentry_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "1780-1798",
    "snippet": "static int build_dentry_path(struct dentry *dentry,\n\t\t\t     const char **ppath, int *ppathlen, u64 *pino,\n\t\t\t     int *pfreepath)\n{\n\tchar *path;\n\n\tif (ceph_snap(dentry->d_parent->d_inode) == CEPH_NOSNAP) {\n\t\t*pino = ceph_ino(dentry->d_parent->d_inode);\n\t\t*ppath = dentry->d_name.name;\n\t\t*ppathlen = dentry->d_name.len;\n\t\treturn 0;\n\t}\n\tpath = ceph_mdsc_build_path(dentry, ppathlen, pino, 1);\n\tif (IS_ERR(path))\n\t\treturn PTR_ERR(path);\n\t*ppath = path;\n\t*pfreepath = 1;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "path"
          ],
          "line": 1794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "path"
          ],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_build_path",
          "args": [
            "dentry",
            "ppathlen",
            "pino",
            "1"
          ],
          "line": 1792
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_build_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1699-1778",
          "snippet": "char *ceph_mdsc_build_path(struct dentry *dentry, int *plen, u64 *base,\n\t\t\t   int stop_on_nosnap)\n{\n\tstruct dentry *temp;\n\tchar *path;\n\tint len, pos;\n\tunsigned seq;\n\n\tif (dentry == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\nretry:\n\tlen = 0;\n\tseq = read_seqbegin(&rename_lock);\n\trcu_read_lock();\n\tfor (temp = dentry; !IS_ROOT(temp);) {\n\t\tstruct inode *inode = temp->d_inode;\n\t\tif (inode && ceph_snap(inode) == CEPH_SNAPDIR)\n\t\t\tlen++;  /* slash only */\n\t\telse if (stop_on_nosnap && inode &&\n\t\t\t ceph_snap(inode) == CEPH_NOSNAP)\n\t\t\tbreak;\n\t\telse\n\t\t\tlen += 1 + temp->d_name.len;\n\t\ttemp = temp->d_parent;\n\t}\n\trcu_read_unlock();\n\tif (len)\n\t\tlen--;  /* no leading '/' */\n\n\tpath = kmalloc(len+1, GFP_NOFS);\n\tif (path == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tpos = len;\n\tpath[pos] = 0;\t/* trailing null */\n\trcu_read_lock();\n\tfor (temp = dentry; !IS_ROOT(temp) && pos != 0; ) {\n\t\tstruct inode *inode;\n\n\t\tspin_lock(&temp->d_lock);\n\t\tinode = temp->d_inode;\n\t\tif (inode && ceph_snap(inode) == CEPH_SNAPDIR) {\n\t\t\tdout(\"build_path path+%d: %p SNAPDIR\\n\",\n\t\t\t     pos, temp);\n\t\t} else if (stop_on_nosnap && inode &&\n\t\t\t   ceph_snap(inode) == CEPH_NOSNAP) {\n\t\t\tspin_unlock(&temp->d_lock);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tpos -= temp->d_name.len;\n\t\t\tif (pos < 0) {\n\t\t\t\tspin_unlock(&temp->d_lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrncpy(path + pos, temp->d_name.name,\n\t\t\t\ttemp->d_name.len);\n\t\t}\n\t\tspin_unlock(&temp->d_lock);\n\t\tif (pos)\n\t\t\tpath[--pos] = '/';\n\t\ttemp = temp->d_parent;\n\t}\n\trcu_read_unlock();\n\tif (pos != 0 || read_seqretry(&rename_lock, seq)) {\n\t\tpr_err(\"build_path did not end path lookup where \"\n\t\t       \"expected, namelen is %d, pos is %d\\n\", len, pos);\n\t\t/* presumably this is only possible if racing with a\n\t\t   rename of one of the parent directories (we can not\n\t\t   lock the dentries above us to prevent this, but\n\t\t   retrying should be harmless) */\n\t\tkfree(path);\n\t\tgoto retry;\n\t}\n\n\t*base = ceph_ino(temp->d_inode);\n\t*plen = len;\n\tdout(\"build_path on %p %d built %llx '%.*s'\\n\",\n\t     dentry, d_count(dentry), *base, len, path);\n\treturn path;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nchar *ceph_mdsc_build_path(struct dentry *dentry, int *plen, u64 *base,\n\t\t\t   int stop_on_nosnap)\n{\n\tstruct dentry *temp;\n\tchar *path;\n\tint len, pos;\n\tunsigned seq;\n\n\tif (dentry == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\nretry:\n\tlen = 0;\n\tseq = read_seqbegin(&rename_lock);\n\trcu_read_lock();\n\tfor (temp = dentry; !IS_ROOT(temp);) {\n\t\tstruct inode *inode = temp->d_inode;\n\t\tif (inode && ceph_snap(inode) == CEPH_SNAPDIR)\n\t\t\tlen++;  /* slash only */\n\t\telse if (stop_on_nosnap && inode &&\n\t\t\t ceph_snap(inode) == CEPH_NOSNAP)\n\t\t\tbreak;\n\t\telse\n\t\t\tlen += 1 + temp->d_name.len;\n\t\ttemp = temp->d_parent;\n\t}\n\trcu_read_unlock();\n\tif (len)\n\t\tlen--;  /* no leading '/' */\n\n\tpath = kmalloc(len+1, GFP_NOFS);\n\tif (path == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tpos = len;\n\tpath[pos] = 0;\t/* trailing null */\n\trcu_read_lock();\n\tfor (temp = dentry; !IS_ROOT(temp) && pos != 0; ) {\n\t\tstruct inode *inode;\n\n\t\tspin_lock(&temp->d_lock);\n\t\tinode = temp->d_inode;\n\t\tif (inode && ceph_snap(inode) == CEPH_SNAPDIR) {\n\t\t\tdout(\"build_path path+%d: %p SNAPDIR\\n\",\n\t\t\t     pos, temp);\n\t\t} else if (stop_on_nosnap && inode &&\n\t\t\t   ceph_snap(inode) == CEPH_NOSNAP) {\n\t\t\tspin_unlock(&temp->d_lock);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tpos -= temp->d_name.len;\n\t\t\tif (pos < 0) {\n\t\t\t\tspin_unlock(&temp->d_lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrncpy(path + pos, temp->d_name.name,\n\t\t\t\ttemp->d_name.len);\n\t\t}\n\t\tspin_unlock(&temp->d_lock);\n\t\tif (pos)\n\t\t\tpath[--pos] = '/';\n\t\ttemp = temp->d_parent;\n\t}\n\trcu_read_unlock();\n\tif (pos != 0 || read_seqretry(&rename_lock, seq)) {\n\t\tpr_err(\"build_path did not end path lookup where \"\n\t\t       \"expected, namelen is %d, pos is %d\\n\", len, pos);\n\t\t/* presumably this is only possible if racing with a\n\t\t   rename of one of the parent directories (we can not\n\t\t   lock the dentries above us to prevent this, but\n\t\t   retrying should be harmless) */\n\t\tkfree(path);\n\t\tgoto retry;\n\t}\n\n\t*base = ceph_ino(temp->d_inode);\n\t*plen = len;\n\tdout(\"build_path on %p %d built %llx '%.*s'\\n\",\n\t     dentry, d_count(dentry), *base, len, path);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_ino",
          "args": [
            "dentry->d_parent->d_inode"
          ],
          "line": 1787
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "412-415",
          "snippet": "static inline u64 ceph_ino(struct inode *inode)\n{\n\treturn ceph_inode(inode)->i_vino.ino;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline u64 ceph_ino(struct inode *inode)\n{\n\treturn ceph_inode(inode)->i_vino.ino;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_snap",
          "args": [
            "dentry->d_parent->d_inode"
          ],
          "line": 1786
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_snap_op_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/strings.c",
          "lines": "115-124",
          "snippet": "const char *ceph_snap_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_SNAP_OP_UPDATE: return \"update\";\n\tcase CEPH_SNAP_OP_CREATE: return \"create\";\n\tcase CEPH_SNAP_OP_DESTROY: return \"destroy\";\n\tcase CEPH_SNAP_OP_SPLIT: return \"split\";\n\t}\n\treturn \"???\";\n}",
          "includes": [
            "#include <linux/ceph/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/types.h>\n#include <linux/module.h>\n\nconst char *ceph_snap_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_SNAP_OP_UPDATE: return \"update\";\n\tcase CEPH_SNAP_OP_CREATE: return \"create\";\n\tcase CEPH_SNAP_OP_DESTROY: return \"destroy\";\n\tcase CEPH_SNAP_OP_SPLIT: return \"split\";\n\t}\n\treturn \"???\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int build_dentry_path(struct dentry *dentry,\n\t\t\t     const char **ppath, int *ppathlen, u64 *pino,\n\t\t\t     int *pfreepath)\n{\n\tchar *path;\n\n\tif (ceph_snap(dentry->d_parent->d_inode) == CEPH_NOSNAP) {\n\t\t*pino = ceph_ino(dentry->d_parent->d_inode);\n\t\t*ppath = dentry->d_name.name;\n\t\t*ppathlen = dentry->d_name.len;\n\t\treturn 0;\n\t}\n\tpath = ceph_mdsc_build_path(dentry, ppathlen, pino, 1);\n\tif (IS_ERR(path))\n\t\treturn PTR_ERR(path);\n\t*ppath = path;\n\t*pfreepath = 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "ceph_mdsc_build_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "1699-1778",
    "snippet": "char *ceph_mdsc_build_path(struct dentry *dentry, int *plen, u64 *base,\n\t\t\t   int stop_on_nosnap)\n{\n\tstruct dentry *temp;\n\tchar *path;\n\tint len, pos;\n\tunsigned seq;\n\n\tif (dentry == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\nretry:\n\tlen = 0;\n\tseq = read_seqbegin(&rename_lock);\n\trcu_read_lock();\n\tfor (temp = dentry; !IS_ROOT(temp);) {\n\t\tstruct inode *inode = temp->d_inode;\n\t\tif (inode && ceph_snap(inode) == CEPH_SNAPDIR)\n\t\t\tlen++;  /* slash only */\n\t\telse if (stop_on_nosnap && inode &&\n\t\t\t ceph_snap(inode) == CEPH_NOSNAP)\n\t\t\tbreak;\n\t\telse\n\t\t\tlen += 1 + temp->d_name.len;\n\t\ttemp = temp->d_parent;\n\t}\n\trcu_read_unlock();\n\tif (len)\n\t\tlen--;  /* no leading '/' */\n\n\tpath = kmalloc(len+1, GFP_NOFS);\n\tif (path == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tpos = len;\n\tpath[pos] = 0;\t/* trailing null */\n\trcu_read_lock();\n\tfor (temp = dentry; !IS_ROOT(temp) && pos != 0; ) {\n\t\tstruct inode *inode;\n\n\t\tspin_lock(&temp->d_lock);\n\t\tinode = temp->d_inode;\n\t\tif (inode && ceph_snap(inode) == CEPH_SNAPDIR) {\n\t\t\tdout(\"build_path path+%d: %p SNAPDIR\\n\",\n\t\t\t     pos, temp);\n\t\t} else if (stop_on_nosnap && inode &&\n\t\t\t   ceph_snap(inode) == CEPH_NOSNAP) {\n\t\t\tspin_unlock(&temp->d_lock);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tpos -= temp->d_name.len;\n\t\t\tif (pos < 0) {\n\t\t\t\tspin_unlock(&temp->d_lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrncpy(path + pos, temp->d_name.name,\n\t\t\t\ttemp->d_name.len);\n\t\t}\n\t\tspin_unlock(&temp->d_lock);\n\t\tif (pos)\n\t\t\tpath[--pos] = '/';\n\t\ttemp = temp->d_parent;\n\t}\n\trcu_read_unlock();\n\tif (pos != 0 || read_seqretry(&rename_lock, seq)) {\n\t\tpr_err(\"build_path did not end path lookup where \"\n\t\t       \"expected, namelen is %d, pos is %d\\n\", len, pos);\n\t\t/* presumably this is only possible if racing with a\n\t\t   rename of one of the parent directories (we can not\n\t\t   lock the dentries above us to prevent this, but\n\t\t   retrying should be harmless) */\n\t\tkfree(path);\n\t\tgoto retry;\n\t}\n\n\t*base = ceph_ino(temp->d_inode);\n\t*plen = len;\n\tdout(\"build_path on %p %d built %llx '%.*s'\\n\",\n\t     dentry, d_count(dentry), *base, len, path);\n\treturn path;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"build_path on %p %d built %llx '%.*s'\\n\"",
            "dentry",
            "d_count(dentry)",
            "*base",
            "len",
            "path"
          ],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_count",
          "args": [
            "dentry"
          ],
          "line": 1776
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_destroy_seqid_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "464-468",
          "snippet": "static void\nnfs4_destroy_seqid_counter(struct nfs_seqid_counter *sc)\n{\n\trpc_destroy_wait_queue(&sc->wait);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void\nnfs4_destroy_seqid_counter(struct nfs_seqid_counter *sc)\n{\n\trpc_destroy_wait_queue(&sc->wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_ino",
          "args": [
            "temp->d_inode"
          ],
          "line": 1773
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "412-415",
          "snippet": "static inline u64 ceph_ino(struct inode *inode)\n{\n\treturn ceph_inode(inode)->i_vino.ino;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline u64 ceph_ino(struct inode *inode)\n{\n\treturn ceph_inode(inode)->i_vino.ino;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "path"
          ],
          "line": 1769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"build_path did not end path lookup where \"\n\t\t       \"expected, namelen is %d, pos is %d\\n\"",
            "len",
            "pos"
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqretry",
          "args": [
            "&rename_lock",
            "seq"
          ],
          "line": 1762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&temp->d_lock"
          ],
          "line": 1756
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "path + pos",
            "temp->d_name.name",
            "temp->d_name.len"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_snap",
          "args": [
            "inode"
          ],
          "line": 1744
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_snap_op_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/strings.c",
          "lines": "115-124",
          "snippet": "const char *ceph_snap_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_SNAP_OP_UPDATE: return \"update\";\n\tcase CEPH_SNAP_OP_CREATE: return \"create\";\n\tcase CEPH_SNAP_OP_DESTROY: return \"destroy\";\n\tcase CEPH_SNAP_OP_SPLIT: return \"split\";\n\t}\n\treturn \"???\";\n}",
          "includes": [
            "#include <linux/ceph/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/types.h>\n#include <linux/module.h>\n\nconst char *ceph_snap_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_SNAP_OP_UPDATE: return \"update\";\n\tcase CEPH_SNAP_OP_CREATE: return \"create\";\n\tcase CEPH_SNAP_OP_DESTROY: return \"destroy\";\n\tcase CEPH_SNAP_OP_SPLIT: return \"split\";\n\t}\n\treturn \"???\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"build_path path+%d: %p SNAPDIR\\n\"",
            "pos",
            "temp"
          ],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&temp->d_lock"
          ],
          "line": 1738
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "temp"
          ],
          "line": 1735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "len+1",
            "GFP_NOFS"
          ],
          "line": 1729
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "temp"
          ],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqbegin",
          "args": [
            "&rename_lock"
          ],
          "line": 1712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nchar *ceph_mdsc_build_path(struct dentry *dentry, int *plen, u64 *base,\n\t\t\t   int stop_on_nosnap)\n{\n\tstruct dentry *temp;\n\tchar *path;\n\tint len, pos;\n\tunsigned seq;\n\n\tif (dentry == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\nretry:\n\tlen = 0;\n\tseq = read_seqbegin(&rename_lock);\n\trcu_read_lock();\n\tfor (temp = dentry; !IS_ROOT(temp);) {\n\t\tstruct inode *inode = temp->d_inode;\n\t\tif (inode && ceph_snap(inode) == CEPH_SNAPDIR)\n\t\t\tlen++;  /* slash only */\n\t\telse if (stop_on_nosnap && inode &&\n\t\t\t ceph_snap(inode) == CEPH_NOSNAP)\n\t\t\tbreak;\n\t\telse\n\t\t\tlen += 1 + temp->d_name.len;\n\t\ttemp = temp->d_parent;\n\t}\n\trcu_read_unlock();\n\tif (len)\n\t\tlen--;  /* no leading '/' */\n\n\tpath = kmalloc(len+1, GFP_NOFS);\n\tif (path == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tpos = len;\n\tpath[pos] = 0;\t/* trailing null */\n\trcu_read_lock();\n\tfor (temp = dentry; !IS_ROOT(temp) && pos != 0; ) {\n\t\tstruct inode *inode;\n\n\t\tspin_lock(&temp->d_lock);\n\t\tinode = temp->d_inode;\n\t\tif (inode && ceph_snap(inode) == CEPH_SNAPDIR) {\n\t\t\tdout(\"build_path path+%d: %p SNAPDIR\\n\",\n\t\t\t     pos, temp);\n\t\t} else if (stop_on_nosnap && inode &&\n\t\t\t   ceph_snap(inode) == CEPH_NOSNAP) {\n\t\t\tspin_unlock(&temp->d_lock);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tpos -= temp->d_name.len;\n\t\t\tif (pos < 0) {\n\t\t\t\tspin_unlock(&temp->d_lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrncpy(path + pos, temp->d_name.name,\n\t\t\t\ttemp->d_name.len);\n\t\t}\n\t\tspin_unlock(&temp->d_lock);\n\t\tif (pos)\n\t\t\tpath[--pos] = '/';\n\t\ttemp = temp->d_parent;\n\t}\n\trcu_read_unlock();\n\tif (pos != 0 || read_seqretry(&rename_lock, seq)) {\n\t\tpr_err(\"build_path did not end path lookup where \"\n\t\t       \"expected, namelen is %d, pos is %d\\n\", len, pos);\n\t\t/* presumably this is only possible if racing with a\n\t\t   rename of one of the parent directories (we can not\n\t\t   lock the dentries above us to prevent this, but\n\t\t   retrying should be harmless) */\n\t\tkfree(path);\n\t\tgoto retry;\n\t}\n\n\t*base = ceph_ino(temp->d_inode);\n\t*plen = len;\n\tdout(\"build_path on %p %d built %llx '%.*s'\\n\",\n\t     dentry, d_count(dentry), *base, len, path);\n\treturn path;\n}"
  },
  {
    "function_name": "__get_oldest_tid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "1680-1687",
    "snippet": "static u64 __get_oldest_tid(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_mds_request *req = __get_oldest_req(mdsc);\n\n\tif (req)\n\t\treturn req->r_tid;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__get_oldest_req",
          "args": [
            "mdsc"
          ],
          "line": 1682
        },
        "resolved": true,
        "details": {
          "function_name": "__get_oldest_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1672-1678",
          "snippet": "static struct ceph_mds_request *__get_oldest_req(struct ceph_mds_client *mdsc)\n{\n\tif (RB_EMPTY_ROOT(&mdsc->request_tree))\n\t\treturn NULL;\n\treturn rb_entry(rb_first(&mdsc->request_tree),\n\t\t\tstruct ceph_mds_request, r_node);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_mds_request *__get_oldest_req(struct ceph_mds_client *mdsc)\n{\n\tif (RB_EMPTY_ROOT(&mdsc->request_tree))\n\t\treturn NULL;\n\treturn rb_entry(rb_first(&mdsc->request_tree),\n\t\t\tstruct ceph_mds_request, r_node);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic u64 __get_oldest_tid(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_mds_request *req = __get_oldest_req(mdsc);\n\n\tif (req)\n\t\treturn req->r_tid;\n\treturn 0;\n}"
  },
  {
    "function_name": "__get_oldest_req",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "1672-1678",
    "snippet": "static struct ceph_mds_request *__get_oldest_req(struct ceph_mds_client *mdsc)\n{\n\tif (RB_EMPTY_ROOT(&mdsc->request_tree))\n\t\treturn NULL;\n\treturn rb_entry(rb_first(&mdsc->request_tree),\n\t\t\tstruct ceph_mds_request, r_node);\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "rb_first(&mdsc->request_tree)",
            "structceph_mds_request",
            "r_node"
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&mdsc->request_tree"
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_ROOT",
          "args": [
            "&mdsc->request_tree"
          ],
          "line": 1674
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_mds_request *__get_oldest_req(struct ceph_mds_client *mdsc)\n{\n\tif (RB_EMPTY_ROOT(&mdsc->request_tree))\n\t\treturn NULL;\n\treturn rb_entry(rb_first(&mdsc->request_tree),\n\t\t\tstruct ceph_mds_request, r_node);\n}"
  },
  {
    "function_name": "ceph_mdsc_create_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "1640-1665",
    "snippet": "struct ceph_mds_request *\nceph_mdsc_create_request(struct ceph_mds_client *mdsc, int op, int mode)\n{\n\tstruct ceph_mds_request *req = kzalloc(sizeof(*req), GFP_NOFS);\n\n\tif (!req)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&req->r_fill_mutex);\n\treq->r_mdsc = mdsc;\n\treq->r_started = jiffies;\n\treq->r_resend_mds = -1;\n\tINIT_LIST_HEAD(&req->r_unsafe_dir_item);\n\treq->r_fmode = -1;\n\tkref_init(&req->r_kref);\n\tINIT_LIST_HEAD(&req->r_wait);\n\tinit_completion(&req->r_completion);\n\tinit_completion(&req->r_safe_completion);\n\tINIT_LIST_HEAD(&req->r_unsafe_item);\n\n\treq->r_stamp = CURRENT_TIME;\n\n\treq->r_op = op;\n\treq->r_direct_mode = mode;\n\treturn req;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&req->r_unsafe_item"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&req->r_safe_completion"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&req->r_completion"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&req->r_wait"
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_init",
          "args": [
            "&req->r_kref"
          ],
          "line": 1654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&req->r_unsafe_dir_item"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&req->r_fill_mutex"
          ],
          "line": 1648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*req)",
            "GFP_NOFS"
          ],
          "line": 1643
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct ceph_mds_request *\nceph_mdsc_create_request(struct ceph_mds_client *mdsc, int op, int mode)\n{\n\tstruct ceph_mds_request *req = kzalloc(sizeof(*req), GFP_NOFS);\n\n\tif (!req)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&req->r_fill_mutex);\n\treq->r_mdsc = mdsc;\n\treq->r_started = jiffies;\n\treq->r_resend_mds = -1;\n\tINIT_LIST_HEAD(&req->r_unsafe_dir_item);\n\treq->r_fmode = -1;\n\tkref_init(&req->r_kref);\n\tINIT_LIST_HEAD(&req->r_wait);\n\tinit_completion(&req->r_completion);\n\tinit_completion(&req->r_safe_completion);\n\tINIT_LIST_HEAD(&req->r_unsafe_item);\n\n\treq->r_stamp = CURRENT_TIME;\n\n\treq->r_op = op;\n\treq->r_direct_mode = mode;\n\treturn req;\n}"
  },
  {
    "function_name": "ceph_alloc_readdir_reply_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "1600-1635",
    "snippet": "int ceph_alloc_readdir_reply_buffer(struct ceph_mds_request *req,\n\t\t\t\t    struct inode *dir)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(dir);\n\tstruct ceph_mds_reply_info_parsed *rinfo = &req->r_reply_info;\n\tstruct ceph_mount_options *opt = req->r_mdsc->fsc->mount_options;\n\tsize_t size = sizeof(*rinfo->dir_in) + sizeof(*rinfo->dir_dname_len) +\n\t\t      sizeof(*rinfo->dir_dname) + sizeof(*rinfo->dir_dlease);\n\tint order, num_entries;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tnum_entries = ci->i_files + ci->i_subdirs;\n\tspin_unlock(&ci->i_ceph_lock);\n\tnum_entries = max(num_entries, 1);\n\tnum_entries = min(num_entries, opt->max_readdir);\n\n\torder = get_order(size * num_entries);\n\twhile (order >= 0) {\n\t\trinfo->dir_in = (void*)__get_free_pages(GFP_NOFS | __GFP_NOWARN,\n\t\t\t\t\t\t\torder);\n\t\tif (rinfo->dir_in)\n\t\t\tbreak;\n\t\torder--;\n\t}\n\tif (!rinfo->dir_in)\n\t\treturn -ENOMEM;\n\n\tnum_entries = (PAGE_SIZE << order) / size;\n\tnum_entries = min(num_entries, opt->max_readdir);\n\n\trinfo->dir_buf_size = PAGE_SIZE << order;\n\treq->r_num_caps = num_entries + 1;\n\treq->r_args.readdir.max_entries = cpu_to_le32(num_entries);\n\treq->r_args.readdir.max_bytes = cpu_to_le32(opt->max_readdir_bytes);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "opt->max_readdir_bytes"
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "num_entries"
          ],
          "line": 1632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "num_entries",
            "opt->max_readdir"
          ],
          "line": 1628
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_adjust_min_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "143-149",
          "snippet": "void ceph_adjust_min_caps(struct ceph_mds_client *mdsc, int delta)\n{\n\tspin_lock(&mdsc->caps_list_lock);\n\tmdsc->caps_min_count += delta;\n\tBUG_ON(mdsc->caps_min_count < 0);\n\tspin_unlock(&mdsc->caps_list_lock);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_adjust_min_caps(struct ceph_mds_client *mdsc, int delta)\n{\n\tspin_lock(&mdsc->caps_list_lock);\n\tmdsc->caps_min_count += delta;\n\tBUG_ON(mdsc->caps_min_count < 0);\n\tspin_unlock(&mdsc->caps_list_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_free_pages",
          "args": [
            "GFP_NOFS | __GFP_NOWARN",
            "order"
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "size * num_entries"
          ],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "num_entries",
            "1"
          ],
          "line": 1613
        },
        "resolved": true,
        "details": {
          "function_name": "check_max_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "2175-2196",
          "snippet": "static void check_max_size(struct inode *inode, loff_t endoff)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint check = 0;\n\n\t/* do we need to explicitly request a larger max_size? */\n\tspin_lock(&ci->i_ceph_lock);\n\tif (endoff >= ci->i_max_size && endoff > ci->i_wanted_max_size) {\n\t\tdout(\"write %p at large endoff %llu, req max_size\\n\",\n\t\t     inode, endoff);\n\t\tci->i_wanted_max_size = endoff;\n\t}\n\t/* duplicate ceph_check_caps()'s logic */\n\tif (ci->i_auth_cap &&\n\t    (ci->i_auth_cap->issued & CEPH_CAP_FILE_WR) &&\n\t    ci->i_wanted_max_size > ci->i_max_size &&\n\t    ci->i_wanted_max_size > ci->i_requested_max_size)\n\t\tcheck = 1;\n\tspin_unlock(&ci->i_ceph_lock);\n\tif (check)\n\t\tceph_check_caps(ci, CHECK_CAPS_AUTHONLY, NULL);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void check_max_size(struct inode *inode, loff_t endoff)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint check = 0;\n\n\t/* do we need to explicitly request a larger max_size? */\n\tspin_lock(&ci->i_ceph_lock);\n\tif (endoff >= ci->i_max_size && endoff > ci->i_wanted_max_size) {\n\t\tdout(\"write %p at large endoff %llu, req max_size\\n\",\n\t\t     inode, endoff);\n\t\tci->i_wanted_max_size = endoff;\n\t}\n\t/* duplicate ceph_check_caps()'s logic */\n\tif (ci->i_auth_cap &&\n\t    (ci->i_auth_cap->issued & CEPH_CAP_FILE_WR) &&\n\t    ci->i_wanted_max_size > ci->i_max_size &&\n\t    ci->i_wanted_max_size > ci->i_requested_max_size)\n\t\tcheck = 1;\n\tspin_unlock(&ci->i_ceph_lock);\n\tif (check)\n\t\tceph_check_caps(ci, CHECK_CAPS_AUTHONLY, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 1612
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 1610
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "dir"
          ],
          "line": 1603
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_alloc_readdir_reply_buffer(struct ceph_mds_request *req,\n\t\t\t\t    struct inode *dir)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(dir);\n\tstruct ceph_mds_reply_info_parsed *rinfo = &req->r_reply_info;\n\tstruct ceph_mount_options *opt = req->r_mdsc->fsc->mount_options;\n\tsize_t size = sizeof(*rinfo->dir_in) + sizeof(*rinfo->dir_dname_len) +\n\t\t      sizeof(*rinfo->dir_dname) + sizeof(*rinfo->dir_dlease);\n\tint order, num_entries;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tnum_entries = ci->i_files + ci->i_subdirs;\n\tspin_unlock(&ci->i_ceph_lock);\n\tnum_entries = max(num_entries, 1);\n\tnum_entries = min(num_entries, opt->max_readdir);\n\n\torder = get_order(size * num_entries);\n\twhile (order >= 0) {\n\t\trinfo->dir_in = (void*)__get_free_pages(GFP_NOFS | __GFP_NOWARN,\n\t\t\t\t\t\t\torder);\n\t\tif (rinfo->dir_in)\n\t\t\tbreak;\n\t\torder--;\n\t}\n\tif (!rinfo->dir_in)\n\t\treturn -ENOMEM;\n\n\tnum_entries = (PAGE_SIZE << order) / size;\n\tnum_entries = min(num_entries, opt->max_readdir);\n\n\trinfo->dir_buf_size = PAGE_SIZE << order;\n\treq->r_num_caps = num_entries + 1;\n\treq->r_args.readdir.max_entries = cpu_to_le32(num_entries);\n\treq->r_args.readdir.max_bytes = cpu_to_le32(opt->max_readdir_bytes);\n\treturn 0;\n}"
  },
  {
    "function_name": "discard_cap_releases",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "1557-1594",
    "snippet": "static void discard_cap_releases(struct ceph_mds_client *mdsc,\n\t\t\t\t struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *msg;\n\tstruct ceph_mds_cap_release *head;\n\tunsigned num;\n\n\tdout(\"discard_cap_releases mds%d\\n\", session->s_mds);\n\n\tif (!list_empty(&session->s_cap_releases)) {\n\t\t/* zero out the in-progress message */\n\t\tmsg = list_first_entry(&session->s_cap_releases,\n\t\t\t\t\tstruct ceph_msg, list_head);\n\t\thead = msg->front.iov_base;\n\t\tnum = le32_to_cpu(head->num);\n\t\tdout(\"discard_cap_releases mds%d %p %u\\n\",\n\t\t     session->s_mds, msg, num);\n\t\thead->num = cpu_to_le32(0);\n\t\tmsg->front.iov_len = sizeof(*head);\n\t\tsession->s_num_cap_releases += num;\n\t}\n\n\t/* requeue completed messages */\n\twhile (!list_empty(&session->s_cap_releases_done)) {\n\t\tmsg = list_first_entry(&session->s_cap_releases_done,\n\t\t\t\t struct ceph_msg, list_head);\n\t\tlist_del_init(&msg->list_head);\n\n\t\thead = msg->front.iov_base;\n\t\tnum = le32_to_cpu(head->num);\n\t\tdout(\"discard_cap_releases mds%d %p %u\\n\", session->s_mds, msg,\n\t\t     num);\n\t\tsession->s_num_cap_releases += num;\n\t\thead->num = cpu_to_le32(0);\n\t\tmsg->front.iov_len = sizeof(*head);\n\t\tlist_add(&msg->list_head, &session->s_cap_releases);\n\t}\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&msg->list_head",
            "&session->s_cap_releases"
          ],
          "line": 1592
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "0"
          ],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"discard_cap_releases mds%d %p %u\\n\"",
            "session->s_mds",
            "msg",
            "num"
          ],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "head->num"
          ],
          "line": 1586
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&msg->list_head"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&session->s_cap_releases_done",
            "structceph_msg",
            "list_head"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&session->s_cap_releases_done"
          ],
          "line": 1580
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "0"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"discard_cap_releases mds%d %p %u\\n\"",
            "session->s_mds",
            "msg",
            "num"
          ],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&session->s_cap_releases",
            "structceph_msg",
            "list_head"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"discard_cap_releases mds%d\\n\"",
            "session->s_mds"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);\n\nstatic void discard_cap_releases(struct ceph_mds_client *mdsc,\n\t\t\t\t struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *msg;\n\tstruct ceph_mds_cap_release *head;\n\tunsigned num;\n\n\tdout(\"discard_cap_releases mds%d\\n\", session->s_mds);\n\n\tif (!list_empty(&session->s_cap_releases)) {\n\t\t/* zero out the in-progress message */\n\t\tmsg = list_first_entry(&session->s_cap_releases,\n\t\t\t\t\tstruct ceph_msg, list_head);\n\t\thead = msg->front.iov_base;\n\t\tnum = le32_to_cpu(head->num);\n\t\tdout(\"discard_cap_releases mds%d %p %u\\n\",\n\t\t     session->s_mds, msg, num);\n\t\thead->num = cpu_to_le32(0);\n\t\tmsg->front.iov_len = sizeof(*head);\n\t\tsession->s_num_cap_releases += num;\n\t}\n\n\t/* requeue completed messages */\n\twhile (!list_empty(&session->s_cap_releases_done)) {\n\t\tmsg = list_first_entry(&session->s_cap_releases_done,\n\t\t\t\t struct ceph_msg, list_head);\n\t\tlist_del_init(&msg->list_head);\n\n\t\thead = msg->front.iov_base;\n\t\tnum = le32_to_cpu(head->num);\n\t\tdout(\"discard_cap_releases mds%d %p %u\\n\", session->s_mds, msg,\n\t\t     num);\n\t\tsession->s_num_cap_releases += num;\n\t\thead->num = cpu_to_le32(0);\n\t\tmsg->front.iov_len = sizeof(*head);\n\t\tlist_add(&msg->list_head, &session->s_cap_releases);\n\t}\n}"
  },
  {
    "function_name": "ceph_send_cap_releases",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "1537-1555",
    "snippet": "void ceph_send_cap_releases(struct ceph_mds_client *mdsc,\n\t\t\t    struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *msg;\n\n\tdout(\"send_cap_releases mds%d\\n\", session->s_mds);\n\tspin_lock(&session->s_cap_lock);\n\twhile (!list_empty(&session->s_cap_releases_done)) {\n\t\tmsg = list_first_entry(&session->s_cap_releases_done,\n\t\t\t\t struct ceph_msg, list_head);\n\t\tlist_del_init(&msg->list_head);\n\t\tspin_unlock(&session->s_cap_lock);\n\t\tmsg->hdr.front_len = cpu_to_le32(msg->front.iov_len);\n\t\tdout(\"send_cap_releases mds%d %p\\n\", session->s_mds, msg);\n\t\tceph_con_send(&session->s_con, msg);\n\t\tspin_lock(&session->s_cap_lock);\n\t}\n\tspin_unlock(&session->s_cap_lock);\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&session->s_cap_lock"
          ],
          "line": 1554
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&session->s_cap_lock"
          ],
          "line": 1552
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_con_send",
          "args": [
            "&session->s_con",
            "msg"
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"send_cap_releases mds%d %p\\n\"",
            "session->s_mds",
            "msg"
          ],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "msg->front.iov_len"
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&msg->list_head"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&session->s_cap_releases_done",
            "structceph_msg",
            "list_head"
          ],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&session->s_cap_releases_done"
          ],
          "line": 1544
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"send_cap_releases mds%d\\n\"",
            "session->s_mds"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_send_cap_releases(struct ceph_mds_client *mdsc,\n\t\t\t    struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *msg;\n\n\tdout(\"send_cap_releases mds%d\\n\", session->s_mds);\n\tspin_lock(&session->s_cap_lock);\n\twhile (!list_empty(&session->s_cap_releases_done)) {\n\t\tmsg = list_first_entry(&session->s_cap_releases_done,\n\t\t\t\t struct ceph_msg, list_head);\n\t\tlist_del_init(&msg->list_head);\n\t\tspin_unlock(&session->s_cap_lock);\n\t\tmsg->hdr.front_len = cpu_to_le32(msg->front.iov_len);\n\t\tdout(\"send_cap_releases mds%d %p\\n\", session->s_mds, msg);\n\t\tceph_con_send(&session->s_con, msg);\n\t\tspin_lock(&session->s_cap_lock);\n\t}\n\tspin_unlock(&session->s_cap_lock);\n}"
  },
  {
    "function_name": "wait_caps_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "1488-1532",
    "snippet": "static void wait_caps_flush(struct ceph_mds_client *mdsc, u64 want_flush_seq)\n{\n\tint mds;\n\n\tdout(\"check_cap_flush want %lld\\n\", want_flush_seq);\n\tmutex_lock(&mdsc->mutex);\n\tfor (mds = 0; mds < mdsc->max_sessions; mds++) {\n\t\tstruct ceph_mds_session *session = mdsc->sessions[mds];\n\t\tstruct inode *inode = NULL;\n\n\t\tif (!session)\n\t\t\tcontinue;\n\t\tget_session(session);\n\t\tmutex_unlock(&mdsc->mutex);\n\n\t\tmutex_lock(&session->s_mutex);\n\t\tif (!list_empty(&session->s_cap_flushing)) {\n\t\t\tstruct ceph_inode_info *ci =\n\t\t\t\tlist_entry(session->s_cap_flushing.next,\n\t\t\t\t\t   struct ceph_inode_info,\n\t\t\t\t\t   i_flushing_item);\n\n\t\t\tif (!check_cap_flush(&ci->vfs_inode, want_flush_seq)) {\n\t\t\t\tdout(\"check_cap_flush still flushing %p \"\n\t\t\t\t     \"seq %lld <= %lld to mds%d\\n\",\n\t\t\t\t     &ci->vfs_inode, ci->i_cap_flush_seq,\n\t\t\t\t     want_flush_seq, session->s_mds);\n\t\t\t\tinode = igrab(&ci->vfs_inode);\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&session->s_mutex);\n\t\tceph_put_mds_session(session);\n\n\t\tif (inode) {\n\t\t\twait_event(mdsc->cap_flushing_wq,\n\t\t\t\t   check_cap_flush(inode, want_flush_seq));\n\t\t\tiput(inode);\n\t\t}\n\n\t\tmutex_lock(&mdsc->mutex);\n\t}\n\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"check_cap_flush ok, flushed thru %lld\\n\", want_flush_seq);\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"check_cap_flush ok, flushed thru %lld\\n\"",
            "want_flush_seq"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 1524
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "mdsc->cap_flushing_wq",
            "check_cap_flush(inode, want_flush_seq)"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_cap_flush",
          "args": [
            "inode",
            "want_flush_seq"
          ],
          "line": 1523
        },
        "resolved": true,
        "details": {
          "function_name": "check_cap_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1470-1481",
          "snippet": "static int check_cap_flush(struct inode *inode, u64 want_flush_seq)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint ret;\n\tspin_lock(&ci->i_ceph_lock);\n\tif (ci->i_flushing_caps)\n\t\tret = ci->i_cap_flush_seq >= want_flush_seq;\n\telse\n\t\tret = 1;\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int check_cap_flush(struct inode *inode, u64 want_flush_seq)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint ret;\n\tspin_lock(&ci->i_ceph_lock);\n\tif (ci->i_flushing_caps)\n\t\tret = ci->i_cap_flush_seq >= want_flush_seq;\n\telse\n\t\tret = 1;\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_put_mds_session",
          "args": [
            "session"
          ],
          "line": 1519
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_put_mds_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "374-385",
          "snippet": "void ceph_put_mds_session(struct ceph_mds_session *s)\n{\n\tdout(\"mdsc put_session %p %d -> %d\\n\", s,\n\t     atomic_read(&s->s_ref), atomic_read(&s->s_ref)-1);\n\tif (atomic_dec_and_test(&s->s_ref)) {\n\t\tif (s->s_auth.authorizer)\n\t\t\tceph_auth_destroy_authorizer(\n\t\t\t\ts->s_mdsc->fsc->client->monc.auth,\n\t\t\t\ts->s_auth.authorizer);\n\t\tkfree(s);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_put_mds_session(struct ceph_mds_session *s)\n{\n\tdout(\"mdsc put_session %p %d -> %d\\n\", s,\n\t     atomic_read(&s->s_ref), atomic_read(&s->s_ref)-1);\n\tif (atomic_dec_and_test(&s->s_ref)) {\n\t\tif (s->s_auth.authorizer)\n\t\t\tceph_auth_destroy_authorizer(\n\t\t\t\ts->s_mdsc->fsc->client->monc.auth,\n\t\t\t\ts->s_auth.authorizer);\n\t\tkfree(s);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&session->s_mutex"
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "igrab",
          "args": [
            "&ci->vfs_inode"
          ],
          "line": 1515
        },
        "resolved": true,
        "details": {
          "function_name": "igrab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1173-1189",
          "snippet": "struct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"check_cap_flush still flushing %p \"\n\t\t\t\t     \"seq %lld <= %lld to mds%d\\n\"",
            "&ci->vfs_inode",
            "ci->i_cap_flush_seq",
            "want_flush_seq",
            "session->s_mds"
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "session->s_cap_flushing.next",
            "structceph_inode_info",
            "i_flushing_item"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&session->s_cap_flushing"
          ],
          "line": 1504
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&session->s_mutex"
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_session",
          "args": [
            "session"
          ],
          "line": 1500
        },
        "resolved": true,
        "details": {
          "function_name": "get_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "362-372",
          "snippet": "static struct ceph_mds_session *get_session(struct ceph_mds_session *s)\n{\n\tif (atomic_inc_not_zero(&s->s_ref)) {\n\t\tdout(\"mdsc get_session %p %d -> %d\\n\", s,\n\t\t     atomic_read(&s->s_ref)-1, atomic_read(&s->s_ref));\n\t\treturn s;\n\t} else {\n\t\tdout(\"mdsc get_session %p 0 -- FAIL\", s);\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_mds_session *get_session(struct ceph_mds_session *s)\n{\n\tif (atomic_inc_not_zero(&s->s_ref)) {\n\t\tdout(\"mdsc get_session %p %d -> %d\\n\", s,\n\t\t     atomic_read(&s->s_ref)-1, atomic_read(&s->s_ref));\n\t\treturn s;\n\t} else {\n\t\tdout(\"mdsc get_session %p 0 -- FAIL\", s);\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"check_cap_flush want %lld\\n\"",
            "want_flush_seq"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void wait_caps_flush(struct ceph_mds_client *mdsc, u64 want_flush_seq)\n{\n\tint mds;\n\n\tdout(\"check_cap_flush want %lld\\n\", want_flush_seq);\n\tmutex_lock(&mdsc->mutex);\n\tfor (mds = 0; mds < mdsc->max_sessions; mds++) {\n\t\tstruct ceph_mds_session *session = mdsc->sessions[mds];\n\t\tstruct inode *inode = NULL;\n\n\t\tif (!session)\n\t\t\tcontinue;\n\t\tget_session(session);\n\t\tmutex_unlock(&mdsc->mutex);\n\n\t\tmutex_lock(&session->s_mutex);\n\t\tif (!list_empty(&session->s_cap_flushing)) {\n\t\t\tstruct ceph_inode_info *ci =\n\t\t\t\tlist_entry(session->s_cap_flushing.next,\n\t\t\t\t\t   struct ceph_inode_info,\n\t\t\t\t\t   i_flushing_item);\n\n\t\t\tif (!check_cap_flush(&ci->vfs_inode, want_flush_seq)) {\n\t\t\t\tdout(\"check_cap_flush still flushing %p \"\n\t\t\t\t     \"seq %lld <= %lld to mds%d\\n\",\n\t\t\t\t     &ci->vfs_inode, ci->i_cap_flush_seq,\n\t\t\t\t     want_flush_seq, session->s_mds);\n\t\t\t\tinode = igrab(&ci->vfs_inode);\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&session->s_mutex);\n\t\tceph_put_mds_session(session);\n\n\t\tif (inode) {\n\t\t\twait_event(mdsc->cap_flushing_wq,\n\t\t\t\t   check_cap_flush(inode, want_flush_seq));\n\t\t\tiput(inode);\n\t\t}\n\n\t\tmutex_lock(&mdsc->mutex);\n\t}\n\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"check_cap_flush ok, flushed thru %lld\\n\", want_flush_seq);\n}"
  },
  {
    "function_name": "check_cap_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "1470-1481",
    "snippet": "static int check_cap_flush(struct inode *inode, u64 want_flush_seq)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint ret;\n\tspin_lock(&ci->i_ceph_lock);\n\tif (ci->i_flushing_caps)\n\t\tret = ci->i_cap_flush_seq >= want_flush_seq;\n\telse\n\t\tret = 1;\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 1479
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 1474
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 1472
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int check_cap_flush(struct inode *inode, u64 want_flush_seq)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint ret;\n\tspin_lock(&ci->i_ceph_lock);\n\tif (ci->i_flushing_caps)\n\t\tret = ci->i_cap_flush_seq >= want_flush_seq;\n\telse\n\t\tret = 1;\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "ceph_add_cap_releases",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "1412-1468",
    "snippet": "int ceph_add_cap_releases(struct ceph_mds_client *mdsc,\n\t\t\t  struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *msg, *partial = NULL;\n\tstruct ceph_mds_cap_release *head;\n\tint err = -ENOMEM;\n\tint extra = mdsc->fsc->mount_options->cap_release_safety;\n\tint num;\n\n\tdout(\"add_cap_releases %p mds%d extra %d\\n\", session, session->s_mds,\n\t     extra);\n\n\tspin_lock(&session->s_cap_lock);\n\n\tif (!list_empty(&session->s_cap_releases)) {\n\t\tmsg = list_first_entry(&session->s_cap_releases,\n\t\t\t\t       struct ceph_msg,\n\t\t\t\t list_head);\n\t\thead = msg->front.iov_base;\n\t\tnum = le32_to_cpu(head->num);\n\t\tif (num) {\n\t\t\tdout(\" partial %p with (%d/%d)\\n\", msg, num,\n\t\t\t     (int)CEPH_CAPS_PER_RELEASE);\n\t\t\textra += CEPH_CAPS_PER_RELEASE - num;\n\t\t\tpartial = msg;\n\t\t}\n\t}\n\twhile (session->s_num_cap_releases < session->s_nr_caps + extra) {\n\t\tspin_unlock(&session->s_cap_lock);\n\t\tmsg = ceph_msg_new(CEPH_MSG_CLIENT_CAPRELEASE, PAGE_CACHE_SIZE,\n\t\t\t\t   GFP_NOFS, false);\n\t\tif (!msg)\n\t\t\tgoto out_unlocked;\n\t\tdout(\"add_cap_releases %p msg %p now %d\\n\", session, msg,\n\t\t     (int)msg->front.iov_len);\n\t\thead = msg->front.iov_base;\n\t\thead->num = cpu_to_le32(0);\n\t\tmsg->front.iov_len = sizeof(*head);\n\t\tspin_lock(&session->s_cap_lock);\n\t\tlist_add(&msg->list_head, &session->s_cap_releases);\n\t\tsession->s_num_cap_releases += CEPH_CAPS_PER_RELEASE;\n\t}\n\n\tif (partial) {\n\t\thead = partial->front.iov_base;\n\t\tnum = le32_to_cpu(head->num);\n\t\tdout(\" queueing partial %p with %d/%d\\n\", partial, num,\n\t\t     (int)CEPH_CAPS_PER_RELEASE);\n\t\tlist_move_tail(&partial->list_head,\n\t\t\t       &session->s_cap_releases_done);\n\t\tsession->s_num_cap_releases -= CEPH_CAPS_PER_RELEASE - num;\n\t}\n\terr = 0;\n\tspin_unlock(&session->s_cap_lock);\nout_unlocked:\n\treturn err;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&session->s_cap_lock"
          ],
          "line": 1465
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&partial->list_head",
            "&session->s_cap_releases_done"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" queueing partial %p with %d/%d\\n\"",
            "partial",
            "num",
            "(int)CEPH_CAPS_PER_RELEASE"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "head->num"
          ],
          "line": 1457
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&msg->list_head",
            "&session->s_cap_releases"
          ],
          "line": 1451
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&session->s_cap_lock"
          ],
          "line": 1450
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "0"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"add_cap_releases %p msg %p now %d\\n\"",
            "session",
            "msg",
            "(int)msg->front.iov_len"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_msg_new",
          "args": [
            "CEPH_MSG_CLIENT_CAPRELEASE",
            "PAGE_CACHE_SIZE",
            "GFP_NOFS",
            "false"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" partial %p with (%d/%d)\\n\"",
            "msg",
            "num",
            "(int)CEPH_CAPS_PER_RELEASE"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&session->s_cap_releases",
            "structceph_msg",
            "list_head"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&session->s_cap_releases"
          ],
          "line": 1426
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"add_cap_releases %p mds%d extra %d\\n\"",
            "session",
            "session->s_mds",
            "extra"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);\n\nint ceph_add_cap_releases(struct ceph_mds_client *mdsc,\n\t\t\t  struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *msg, *partial = NULL;\n\tstruct ceph_mds_cap_release *head;\n\tint err = -ENOMEM;\n\tint extra = mdsc->fsc->mount_options->cap_release_safety;\n\tint num;\n\n\tdout(\"add_cap_releases %p mds%d extra %d\\n\", session, session->s_mds,\n\t     extra);\n\n\tspin_lock(&session->s_cap_lock);\n\n\tif (!list_empty(&session->s_cap_releases)) {\n\t\tmsg = list_first_entry(&session->s_cap_releases,\n\t\t\t\t       struct ceph_msg,\n\t\t\t\t list_head);\n\t\thead = msg->front.iov_base;\n\t\tnum = le32_to_cpu(head->num);\n\t\tif (num) {\n\t\t\tdout(\" partial %p with (%d/%d)\\n\", msg, num,\n\t\t\t     (int)CEPH_CAPS_PER_RELEASE);\n\t\t\textra += CEPH_CAPS_PER_RELEASE - num;\n\t\t\tpartial = msg;\n\t\t}\n\t}\n\twhile (session->s_num_cap_releases < session->s_nr_caps + extra) {\n\t\tspin_unlock(&session->s_cap_lock);\n\t\tmsg = ceph_msg_new(CEPH_MSG_CLIENT_CAPRELEASE, PAGE_CACHE_SIZE,\n\t\t\t\t   GFP_NOFS, false);\n\t\tif (!msg)\n\t\t\tgoto out_unlocked;\n\t\tdout(\"add_cap_releases %p msg %p now %d\\n\", session, msg,\n\t\t     (int)msg->front.iov_len);\n\t\thead = msg->front.iov_base;\n\t\thead->num = cpu_to_le32(0);\n\t\tmsg->front.iov_len = sizeof(*head);\n\t\tspin_lock(&session->s_cap_lock);\n\t\tlist_add(&msg->list_head, &session->s_cap_releases);\n\t\tsession->s_num_cap_releases += CEPH_CAPS_PER_RELEASE;\n\t}\n\n\tif (partial) {\n\t\thead = partial->front.iov_base;\n\t\tnum = le32_to_cpu(head->num);\n\t\tdout(\" queueing partial %p with %d/%d\\n\", partial, num,\n\t\t     (int)CEPH_CAPS_PER_RELEASE);\n\t\tlist_move_tail(&partial->list_head,\n\t\t\t       &session->s_cap_releases_done);\n\t\tsession->s_num_cap_releases -= CEPH_CAPS_PER_RELEASE - num;\n\t}\n\terr = 0;\n\tspin_unlock(&session->s_cap_lock);\nout_unlocked:\n\treturn err;\n}"
  },
  {
    "function_name": "trim_caps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "1383-1403",
    "snippet": "static int trim_caps(struct ceph_mds_client *mdsc,\n\t\t     struct ceph_mds_session *session,\n\t\t     int max_caps)\n{\n\tint trim_caps = session->s_nr_caps - max_caps;\n\n\tdout(\"trim_caps mds%d start: %d / %d, trim %d\\n\",\n\t     session->s_mds, session->s_nr_caps, max_caps, trim_caps);\n\tif (trim_caps > 0) {\n\t\tsession->s_trim_caps = trim_caps;\n\t\titerate_session_caps(session, trim_caps_cb, session);\n\t\tdout(\"trim_caps mds%d done: %d / %d, trimmed %d\\n\",\n\t\t     session->s_mds, session->s_nr_caps, max_caps,\n\t\t\ttrim_caps - session->s_trim_caps);\n\t\tsession->s_trim_caps = 0;\n\t}\n\n\tceph_add_cap_releases(mdsc, session);\n\tceph_send_cap_releases(mdsc, session);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_send_cap_releases",
          "args": [
            "mdsc",
            "session"
          ],
          "line": 1401
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_send_cap_releases",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1537-1555",
          "snippet": "void ceph_send_cap_releases(struct ceph_mds_client *mdsc,\n\t\t\t    struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *msg;\n\n\tdout(\"send_cap_releases mds%d\\n\", session->s_mds);\n\tspin_lock(&session->s_cap_lock);\n\twhile (!list_empty(&session->s_cap_releases_done)) {\n\t\tmsg = list_first_entry(&session->s_cap_releases_done,\n\t\t\t\t struct ceph_msg, list_head);\n\t\tlist_del_init(&msg->list_head);\n\t\tspin_unlock(&session->s_cap_lock);\n\t\tmsg->hdr.front_len = cpu_to_le32(msg->front.iov_len);\n\t\tdout(\"send_cap_releases mds%d %p\\n\", session->s_mds, msg);\n\t\tceph_con_send(&session->s_con, msg);\n\t\tspin_lock(&session->s_cap_lock);\n\t}\n\tspin_unlock(&session->s_cap_lock);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_send_cap_releases(struct ceph_mds_client *mdsc,\n\t\t\t    struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *msg;\n\n\tdout(\"send_cap_releases mds%d\\n\", session->s_mds);\n\tspin_lock(&session->s_cap_lock);\n\twhile (!list_empty(&session->s_cap_releases_done)) {\n\t\tmsg = list_first_entry(&session->s_cap_releases_done,\n\t\t\t\t struct ceph_msg, list_head);\n\t\tlist_del_init(&msg->list_head);\n\t\tspin_unlock(&session->s_cap_lock);\n\t\tmsg->hdr.front_len = cpu_to_le32(msg->front.iov_len);\n\t\tdout(\"send_cap_releases mds%d %p\\n\", session->s_mds, msg);\n\t\tceph_con_send(&session->s_con, msg);\n\t\tspin_lock(&session->s_cap_lock);\n\t}\n\tspin_unlock(&session->s_cap_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_add_cap_releases",
          "args": [
            "mdsc",
            "session"
          ],
          "line": 1400
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_add_cap_releases",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1412-1468",
          "snippet": "int ceph_add_cap_releases(struct ceph_mds_client *mdsc,\n\t\t\t  struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *msg, *partial = NULL;\n\tstruct ceph_mds_cap_release *head;\n\tint err = -ENOMEM;\n\tint extra = mdsc->fsc->mount_options->cap_release_safety;\n\tint num;\n\n\tdout(\"add_cap_releases %p mds%d extra %d\\n\", session, session->s_mds,\n\t     extra);\n\n\tspin_lock(&session->s_cap_lock);\n\n\tif (!list_empty(&session->s_cap_releases)) {\n\t\tmsg = list_first_entry(&session->s_cap_releases,\n\t\t\t\t       struct ceph_msg,\n\t\t\t\t list_head);\n\t\thead = msg->front.iov_base;\n\t\tnum = le32_to_cpu(head->num);\n\t\tif (num) {\n\t\t\tdout(\" partial %p with (%d/%d)\\n\", msg, num,\n\t\t\t     (int)CEPH_CAPS_PER_RELEASE);\n\t\t\textra += CEPH_CAPS_PER_RELEASE - num;\n\t\t\tpartial = msg;\n\t\t}\n\t}\n\twhile (session->s_num_cap_releases < session->s_nr_caps + extra) {\n\t\tspin_unlock(&session->s_cap_lock);\n\t\tmsg = ceph_msg_new(CEPH_MSG_CLIENT_CAPRELEASE, PAGE_CACHE_SIZE,\n\t\t\t\t   GFP_NOFS, false);\n\t\tif (!msg)\n\t\t\tgoto out_unlocked;\n\t\tdout(\"add_cap_releases %p msg %p now %d\\n\", session, msg,\n\t\t     (int)msg->front.iov_len);\n\t\thead = msg->front.iov_base;\n\t\thead->num = cpu_to_le32(0);\n\t\tmsg->front.iov_len = sizeof(*head);\n\t\tspin_lock(&session->s_cap_lock);\n\t\tlist_add(&msg->list_head, &session->s_cap_releases);\n\t\tsession->s_num_cap_releases += CEPH_CAPS_PER_RELEASE;\n\t}\n\n\tif (partial) {\n\t\thead = partial->front.iov_base;\n\t\tnum = le32_to_cpu(head->num);\n\t\tdout(\" queueing partial %p with %d/%d\\n\", partial, num,\n\t\t     (int)CEPH_CAPS_PER_RELEASE);\n\t\tlist_move_tail(&partial->list_head,\n\t\t\t       &session->s_cap_releases_done);\n\t\tsession->s_num_cap_releases -= CEPH_CAPS_PER_RELEASE - num;\n\t}\n\terr = 0;\n\tspin_unlock(&session->s_cap_lock);\nout_unlocked:\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);\n\nint ceph_add_cap_releases(struct ceph_mds_client *mdsc,\n\t\t\t  struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *msg, *partial = NULL;\n\tstruct ceph_mds_cap_release *head;\n\tint err = -ENOMEM;\n\tint extra = mdsc->fsc->mount_options->cap_release_safety;\n\tint num;\n\n\tdout(\"add_cap_releases %p mds%d extra %d\\n\", session, session->s_mds,\n\t     extra);\n\n\tspin_lock(&session->s_cap_lock);\n\n\tif (!list_empty(&session->s_cap_releases)) {\n\t\tmsg = list_first_entry(&session->s_cap_releases,\n\t\t\t\t       struct ceph_msg,\n\t\t\t\t list_head);\n\t\thead = msg->front.iov_base;\n\t\tnum = le32_to_cpu(head->num);\n\t\tif (num) {\n\t\t\tdout(\" partial %p with (%d/%d)\\n\", msg, num,\n\t\t\t     (int)CEPH_CAPS_PER_RELEASE);\n\t\t\textra += CEPH_CAPS_PER_RELEASE - num;\n\t\t\tpartial = msg;\n\t\t}\n\t}\n\twhile (session->s_num_cap_releases < session->s_nr_caps + extra) {\n\t\tspin_unlock(&session->s_cap_lock);\n\t\tmsg = ceph_msg_new(CEPH_MSG_CLIENT_CAPRELEASE, PAGE_CACHE_SIZE,\n\t\t\t\t   GFP_NOFS, false);\n\t\tif (!msg)\n\t\t\tgoto out_unlocked;\n\t\tdout(\"add_cap_releases %p msg %p now %d\\n\", session, msg,\n\t\t     (int)msg->front.iov_len);\n\t\thead = msg->front.iov_base;\n\t\thead->num = cpu_to_le32(0);\n\t\tmsg->front.iov_len = sizeof(*head);\n\t\tspin_lock(&session->s_cap_lock);\n\t\tlist_add(&msg->list_head, &session->s_cap_releases);\n\t\tsession->s_num_cap_releases += CEPH_CAPS_PER_RELEASE;\n\t}\n\n\tif (partial) {\n\t\thead = partial->front.iov_base;\n\t\tnum = le32_to_cpu(head->num);\n\t\tdout(\" queueing partial %p with %d/%d\\n\", partial, num,\n\t\t     (int)CEPH_CAPS_PER_RELEASE);\n\t\tlist_move_tail(&partial->list_head,\n\t\t\t       &session->s_cap_releases_done);\n\t\tsession->s_num_cap_releases -= CEPH_CAPS_PER_RELEASE - num;\n\t}\n\terr = 0;\n\tspin_unlock(&session->s_cap_lock);\nout_unlocked:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"trim_caps mds%d done: %d / %d, trimmed %d\\n\"",
            "session->s_mds",
            "session->s_nr_caps",
            "max_caps",
            "trim_caps - session->s_trim_caps"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iterate_session_caps",
          "args": [
            "session",
            "trim_caps_cb",
            "session"
          ],
          "line": 1393
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_session_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1030-1089",
          "snippet": "static int iterate_session_caps(struct ceph_mds_session *session,\n\t\t\t\t int (*cb)(struct inode *, struct ceph_cap *,\n\t\t\t\t\t    void *), void *arg)\n{\n\tstruct list_head *p;\n\tstruct ceph_cap *cap;\n\tstruct inode *inode, *last_inode = NULL;\n\tstruct ceph_cap *old_cap = NULL;\n\tint ret;\n\n\tdout(\"iterate_session_caps %p mds%d\\n\", session, session->s_mds);\n\tspin_lock(&session->s_cap_lock);\n\tp = session->s_caps.next;\n\twhile (p != &session->s_caps) {\n\t\tcap = list_entry(p, struct ceph_cap, session_caps);\n\t\tinode = igrab(&cap->ci->vfs_inode);\n\t\tif (!inode) {\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tsession->s_cap_iterator = cap;\n\t\tspin_unlock(&session->s_cap_lock);\n\n\t\tif (last_inode) {\n\t\t\tiput(last_inode);\n\t\t\tlast_inode = NULL;\n\t\t}\n\t\tif (old_cap) {\n\t\t\tceph_put_cap(session->s_mdsc, old_cap);\n\t\t\told_cap = NULL;\n\t\t}\n\n\t\tret = cb(inode, cap, arg);\n\t\tlast_inode = inode;\n\n\t\tspin_lock(&session->s_cap_lock);\n\t\tp = p->next;\n\t\tif (cap->ci == NULL) {\n\t\t\tdout(\"iterate_session_caps  finishing cap %p removal\\n\",\n\t\t\t     cap);\n\t\t\tBUG_ON(cap->session != session);\n\t\t\tlist_del_init(&cap->session_caps);\n\t\t\tsession->s_nr_caps--;\n\t\t\tcap->session = NULL;\n\t\t\told_cap = cap;  /* put_cap it w/o locks held */\n\t\t}\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tsession->s_cap_iterator = NULL;\n\tspin_unlock(&session->s_cap_lock);\n\n\tiput(last_inode);\n\tif (old_cap)\n\t\tceph_put_cap(session->s_mdsc, old_cap);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int iterate_session_caps(struct ceph_mds_session *session,\n\t\t\t\t int (*cb)(struct inode *, struct ceph_cap *,\n\t\t\t\t\t    void *), void *arg)\n{\n\tstruct list_head *p;\n\tstruct ceph_cap *cap;\n\tstruct inode *inode, *last_inode = NULL;\n\tstruct ceph_cap *old_cap = NULL;\n\tint ret;\n\n\tdout(\"iterate_session_caps %p mds%d\\n\", session, session->s_mds);\n\tspin_lock(&session->s_cap_lock);\n\tp = session->s_caps.next;\n\twhile (p != &session->s_caps) {\n\t\tcap = list_entry(p, struct ceph_cap, session_caps);\n\t\tinode = igrab(&cap->ci->vfs_inode);\n\t\tif (!inode) {\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tsession->s_cap_iterator = cap;\n\t\tspin_unlock(&session->s_cap_lock);\n\n\t\tif (last_inode) {\n\t\t\tiput(last_inode);\n\t\t\tlast_inode = NULL;\n\t\t}\n\t\tif (old_cap) {\n\t\t\tceph_put_cap(session->s_mdsc, old_cap);\n\t\t\told_cap = NULL;\n\t\t}\n\n\t\tret = cb(inode, cap, arg);\n\t\tlast_inode = inode;\n\n\t\tspin_lock(&session->s_cap_lock);\n\t\tp = p->next;\n\t\tif (cap->ci == NULL) {\n\t\t\tdout(\"iterate_session_caps  finishing cap %p removal\\n\",\n\t\t\t     cap);\n\t\t\tBUG_ON(cap->session != session);\n\t\t\tlist_del_init(&cap->session_caps);\n\t\t\tsession->s_nr_caps--;\n\t\t\tcap->session = NULL;\n\t\t\told_cap = cap;  /* put_cap it w/o locks held */\n\t\t}\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tsession->s_cap_iterator = NULL;\n\tspin_unlock(&session->s_cap_lock);\n\n\tiput(last_inode);\n\tif (old_cap)\n\t\tceph_put_cap(session->s_mdsc, old_cap);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"trim_caps mds%d start: %d / %d, trim %d\\n\"",
            "session->s_mds",
            "session->s_nr_caps",
            "max_caps",
            "trim_caps"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int trim_caps(struct ceph_mds_client *mdsc,\n\t\t     struct ceph_mds_session *session,\n\t\t     int max_caps)\n{\n\tint trim_caps = session->s_nr_caps - max_caps;\n\n\tdout(\"trim_caps mds%d start: %d / %d, trim %d\\n\",\n\t     session->s_mds, session->s_nr_caps, max_caps, trim_caps);\n\tif (trim_caps > 0) {\n\t\tsession->s_trim_caps = trim_caps;\n\t\titerate_session_caps(session, trim_caps_cb, session);\n\t\tdout(\"trim_caps mds%d done: %d / %d, trimmed %d\\n\",\n\t\t     session->s_mds, session->s_nr_caps, max_caps,\n\t\t\ttrim_caps - session->s_trim_caps);\n\t\tsession->s_trim_caps = 0;\n\t}\n\n\tceph_add_cap_releases(mdsc, session);\n\tceph_send_cap_releases(mdsc, session);\n\treturn 0;\n}"
  },
  {
    "function_name": "trim_caps_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "1335-1378",
    "snippet": "static int trim_caps_cb(struct inode *inode, struct ceph_cap *cap, void *arg)\n{\n\tstruct ceph_mds_session *session = arg;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint used, wanted, oissued, mine;\n\n\tif (session->s_trim_caps <= 0)\n\t\treturn -1;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tmine = cap->issued | cap->implemented;\n\tused = __ceph_caps_used(ci);\n\twanted = __ceph_caps_file_wanted(ci);\n\toissued = __ceph_caps_issued_other(ci, cap);\n\n\tdout(\"trim_caps_cb %p cap %p mine %s oissued %s used %s wanted %s\\n\",\n\t     inode, cap, ceph_cap_string(mine), ceph_cap_string(oissued),\n\t     ceph_cap_string(used), ceph_cap_string(wanted));\n\tif (cap == ci->i_auth_cap) {\n\t\tif (ci->i_dirty_caps | ci->i_flushing_caps)\n\t\t\tgoto out;\n\t\tif ((used | wanted) & CEPH_CAP_ANY_WR)\n\t\t\tgoto out;\n\t}\n\tif ((used | wanted) & ~oissued & mine)\n\t\tgoto out;   /* we need these caps */\n\n\tsession->s_trim_caps--;\n\tif (oissued) {\n\t\t/* we aren't the only cap.. just remove us */\n\t\t__ceph_remove_cap(cap, true);\n\t} else {\n\t\t/* try to drop referring dentries */\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\td_prune_aliases(inode);\n\t\tdout(\"trim_caps_cb %p cap %p  pruned, count now %d\\n\",\n\t\t     inode, cap, atomic_read(&inode->i_count));\n\t\treturn 0;\n\t}\n\nout:\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"trim_caps_cb %p cap %p  pruned, count now %d\\n\"",
            "inode",
            "cap",
            "atomic_read(&inode->i_count)"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&inode->i_count"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_prune_aliases",
          "args": [
            "inode"
          ],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "d_prune_aliases",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "882-902",
          "snippet": "void d_prune_aliases(struct inode *inode)\n{\n\tstruct dentry *dentry;\nrestart:\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry(dentry, &inode->i_dentry, d_u.d_alias) {\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (!dentry->d_lockref.count) {\n\t\t\tstruct dentry *parent = lock_parent(dentry);\n\t\t\tif (likely(!dentry->d_lockref.count)) {\n\t\t\t\t__dentry_kill(dentry);\n\t\t\t\tdput(parent);\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t\tif (parent)\n\t\t\t\tspin_unlock(&parent->d_lock);\n\t\t}\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid d_prune_aliases(struct inode *inode)\n{\n\tstruct dentry *dentry;\nrestart:\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry(dentry, &inode->i_dentry, d_u.d_alias) {\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (!dentry->d_lockref.count) {\n\t\t\tstruct dentry *parent = lock_parent(dentry);\n\t\t\tif (likely(!dentry->d_lockref.count)) {\n\t\t\t\t__dentry_kill(dentry);\n\t\t\t\tdput(parent);\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t\tif (parent)\n\t\t\t\tspin_unlock(&parent->d_lock);\n\t\t}\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_remove_cap",
          "args": [
            "cap",
            "true"
          ],
          "line": 1365
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_remove_cap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "905-960",
          "snippet": "void __ceph_remove_cap(struct ceph_cap *cap, bool queue_release)\n{\n\tstruct ceph_mds_session *session = cap->session;\n\tstruct ceph_inode_info *ci = cap->ci;\n\tstruct ceph_mds_client *mdsc =\n\t\tceph_sb_to_client(ci->vfs_inode.i_sb)->mdsc;\n\tint removed = 0;\n\n\tdout(\"__ceph_remove_cap %p from %p\\n\", cap, &ci->vfs_inode);\n\n\t/* remove from session list */\n\tspin_lock(&session->s_cap_lock);\n\t/*\n\t * s_cap_reconnect is protected by s_cap_lock. no one changes\n\t * s_cap_gen while session is in the reconnect state.\n\t */\n\tif (queue_release &&\n\t    (!session->s_cap_reconnect ||\n\t     cap->cap_gen == session->s_cap_gen))\n\t\t__queue_cap_release(session, ci->i_vino.ino, cap->cap_id,\n\t\t\t\t    cap->mseq, cap->issue_seq);\n\n\tif (session->s_cap_iterator == cap) {\n\t\t/* not yet, we are iterating over this very cap */\n\t\tdout(\"__ceph_remove_cap  delaying %p removal from session %p\\n\",\n\t\t     cap, cap->session);\n\t} else {\n\t\tlist_del_init(&cap->session_caps);\n\t\tsession->s_nr_caps--;\n\t\tcap->session = NULL;\n\t\tremoved = 1;\n\t}\n\t/* protect backpointer with s_cap_lock: see iterate_session_caps */\n\tcap->ci = NULL;\n\tspin_unlock(&session->s_cap_lock);\n\n\t/* remove from inode list */\n\trb_erase(&cap->ci_node, &ci->i_caps);\n\tif (ci->i_auth_cap == cap)\n\t\tci->i_auth_cap = NULL;\n\n\tif (removed)\n\t\tceph_put_cap(mdsc, cap);\n\n\tif (!__ceph_is_any_caps(ci) && ci->i_snap_realm) {\n\t\tstruct ceph_snap_realm *realm = ci->i_snap_realm;\n\t\tspin_lock(&realm->inodes_with_caps_lock);\n\t\tlist_del_init(&ci->i_snap_realm_item);\n\t\tci->i_snap_realm_counter++;\n\t\tci->i_snap_realm = NULL;\n\t\tspin_unlock(&realm->inodes_with_caps_lock);\n\t\tceph_put_snap_realm(mdsc, realm);\n\t}\n\tif (!__ceph_is_any_real_caps(ci))\n\t\t__cap_delay_cancel(mdsc, ci);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid __ceph_remove_cap(struct ceph_cap *cap, bool queue_release)\n{\n\tstruct ceph_mds_session *session = cap->session;\n\tstruct ceph_inode_info *ci = cap->ci;\n\tstruct ceph_mds_client *mdsc =\n\t\tceph_sb_to_client(ci->vfs_inode.i_sb)->mdsc;\n\tint removed = 0;\n\n\tdout(\"__ceph_remove_cap %p from %p\\n\", cap, &ci->vfs_inode);\n\n\t/* remove from session list */\n\tspin_lock(&session->s_cap_lock);\n\t/*\n\t * s_cap_reconnect is protected by s_cap_lock. no one changes\n\t * s_cap_gen while session is in the reconnect state.\n\t */\n\tif (queue_release &&\n\t    (!session->s_cap_reconnect ||\n\t     cap->cap_gen == session->s_cap_gen))\n\t\t__queue_cap_release(session, ci->i_vino.ino, cap->cap_id,\n\t\t\t\t    cap->mseq, cap->issue_seq);\n\n\tif (session->s_cap_iterator == cap) {\n\t\t/* not yet, we are iterating over this very cap */\n\t\tdout(\"__ceph_remove_cap  delaying %p removal from session %p\\n\",\n\t\t     cap, cap->session);\n\t} else {\n\t\tlist_del_init(&cap->session_caps);\n\t\tsession->s_nr_caps--;\n\t\tcap->session = NULL;\n\t\tremoved = 1;\n\t}\n\t/* protect backpointer with s_cap_lock: see iterate_session_caps */\n\tcap->ci = NULL;\n\tspin_unlock(&session->s_cap_lock);\n\n\t/* remove from inode list */\n\trb_erase(&cap->ci_node, &ci->i_caps);\n\tif (ci->i_auth_cap == cap)\n\t\tci->i_auth_cap = NULL;\n\n\tif (removed)\n\t\tceph_put_cap(mdsc, cap);\n\n\tif (!__ceph_is_any_caps(ci) && ci->i_snap_realm) {\n\t\tstruct ceph_snap_realm *realm = ci->i_snap_realm;\n\t\tspin_lock(&realm->inodes_with_caps_lock);\n\t\tlist_del_init(&ci->i_snap_realm_item);\n\t\tci->i_snap_realm_counter++;\n\t\tci->i_snap_realm = NULL;\n\t\tspin_unlock(&realm->inodes_with_caps_lock);\n\t\tceph_put_snap_realm(mdsc, realm);\n\t}\n\tif (!__ceph_is_any_real_caps(ci))\n\t\t__cap_delay_cancel(mdsc, ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"trim_caps_cb %p cap %p mine %s oissued %s used %s wanted %s\\n\"",
            "inode",
            "cap",
            "ceph_cap_string(mine)",
            "ceph_cap_string(oissued)",
            "ceph_cap_string(used)",
            "ceph_cap_string(wanted)"
          ],
          "line": 1350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_cap_string",
          "args": [
            "wanted"
          ],
          "line": 1352
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_cap_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "71-116",
          "snippet": "const char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [
            "#define MAX_CAP_STR 20"
          ],
          "globals_used": [
            "static char cap_str[MAX_CAP_STR][40];",
            "static DEFINE_SPINLOCK(cap_str_lock);",
            "static int last_cap_str;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\n#define MAX_CAP_STR 20\n\nstatic char cap_str[MAX_CAP_STR][40];\nstatic DEFINE_SPINLOCK(cap_str_lock);\nstatic int last_cap_str;\n\nconst char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_caps_issued_other",
          "args": [
            "ci",
            "cap"
          ],
          "line": 1348
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_caps_issued_other",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "700-715",
          "snippet": "int __ceph_caps_issued_other(struct ceph_inode_info *ci, struct ceph_cap *ocap)\n{\n\tint have = ci->i_snap_caps;\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (cap == ocap)\n\t\t\tcontinue;\n\t\tif (!__cap_is_valid(cap))\n\t\t\tcontinue;\n\t\thave |= cap->issued;\n\t}\n\treturn have;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_caps_issued_other(struct ceph_inode_info *ci, struct ceph_cap *ocap)\n{\n\tint have = ci->i_snap_caps;\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (cap == ocap)\n\t\t\tcontinue;\n\t\tif (!__cap_is_valid(cap))\n\t\t\tcontinue;\n\t\thave |= cap->issued;\n\t}\n\treturn have;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_caps_file_wanted",
          "args": [
            "ci"
          ],
          "line": 1347
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_caps_file_wanted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "848-856",
          "snippet": "int __ceph_caps_file_wanted(struct ceph_inode_info *ci)\n{\n\tint want = 0;\n\tint mode;\n\tfor (mode = 0; mode < CEPH_FILE_MODE_NUM; mode++)\n\t\tif (ci->i_nr_by_mode[mode])\n\t\t\twant |= ceph_caps_for_mode(mode);\n\treturn want;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_caps_file_wanted(struct ceph_inode_info *ci)\n{\n\tint want = 0;\n\tint mode;\n\tfor (mode = 0; mode < CEPH_FILE_MODE_NUM; mode++)\n\t\tif (ci->i_nr_by_mode[mode])\n\t\t\twant |= ceph_caps_for_mode(mode);\n\treturn want;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_caps_used",
          "args": [
            "ci"
          ],
          "line": 1346
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_caps_used",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "829-843",
          "snippet": "int __ceph_caps_used(struct ceph_inode_info *ci)\n{\n\tint used = 0;\n\tif (ci->i_pin_ref)\n\t\tused |= CEPH_CAP_PIN;\n\tif (ci->i_rd_ref)\n\t\tused |= CEPH_CAP_FILE_RD;\n\tif (ci->i_rdcache_ref || ci->vfs_inode.i_data.nrpages)\n\t\tused |= CEPH_CAP_FILE_CACHE;\n\tif (ci->i_wr_ref)\n\t\tused |= CEPH_CAP_FILE_WR;\n\tif (ci->i_wb_ref || ci->i_wrbuffer_ref)\n\t\tused |= CEPH_CAP_FILE_BUFFER;\n\treturn used;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_caps_used(struct ceph_inode_info *ci)\n{\n\tint used = 0;\n\tif (ci->i_pin_ref)\n\t\tused |= CEPH_CAP_PIN;\n\tif (ci->i_rd_ref)\n\t\tused |= CEPH_CAP_FILE_RD;\n\tif (ci->i_rdcache_ref || ci->vfs_inode.i_data.nrpages)\n\t\tused |= CEPH_CAP_FILE_CACHE;\n\tif (ci->i_wr_ref)\n\t\tused |= CEPH_CAP_FILE_WR;\n\tif (ci->i_wb_ref || ci->i_wrbuffer_ref)\n\t\tused |= CEPH_CAP_FILE_BUFFER;\n\treturn used;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 1344
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int trim_caps_cb(struct inode *inode, struct ceph_cap *cap, void *arg)\n{\n\tstruct ceph_mds_session *session = arg;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint used, wanted, oissued, mine;\n\n\tif (session->s_trim_caps <= 0)\n\t\treturn -1;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tmine = cap->issued | cap->implemented;\n\tused = __ceph_caps_used(ci);\n\twanted = __ceph_caps_file_wanted(ci);\n\toissued = __ceph_caps_issued_other(ci, cap);\n\n\tdout(\"trim_caps_cb %p cap %p mine %s oissued %s used %s wanted %s\\n\",\n\t     inode, cap, ceph_cap_string(mine), ceph_cap_string(oissued),\n\t     ceph_cap_string(used), ceph_cap_string(wanted));\n\tif (cap == ci->i_auth_cap) {\n\t\tif (ci->i_dirty_caps | ci->i_flushing_caps)\n\t\t\tgoto out;\n\t\tif ((used | wanted) & CEPH_CAP_ANY_WR)\n\t\t\tgoto out;\n\t}\n\tif ((used | wanted) & ~oissued & mine)\n\t\tgoto out;   /* we need these caps */\n\n\tsession->s_trim_caps--;\n\tif (oissued) {\n\t\t/* we aren't the only cap.. just remove us */\n\t\t__ceph_remove_cap(cap, true);\n\t} else {\n\t\t/* try to drop referring dentries */\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\td_prune_aliases(inode);\n\t\tdout(\"trim_caps_cb %p cap %p  pruned, count now %d\\n\",\n\t\t     inode, cap, atomic_read(&inode->i_count));\n\t\treturn 0;\n\t}\n\nout:\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "__close_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "1316-1323",
    "snippet": "static int __close_session(struct ceph_mds_client *mdsc,\n\t\t\t struct ceph_mds_session *session)\n{\n\tif (session->s_state >= CEPH_MDS_SESSION_CLOSING)\n\t\treturn 0;\n\tsession->s_state = CEPH_MDS_SESSION_CLOSING;\n\treturn request_close_session(mdsc, session);\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "request_close_session",
          "args": [
            "mdsc",
            "session"
          ],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "request_close_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1298-1311",
          "snippet": "static int request_close_session(struct ceph_mds_client *mdsc,\n\t\t\t\t struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *msg;\n\n\tdout(\"request_close_session mds%d state %s seq %lld\\n\",\n\t     session->s_mds, ceph_session_state_name(session->s_state),\n\t     session->s_seq);\n\tmsg = create_session_msg(CEPH_SESSION_REQUEST_CLOSE, session->s_seq);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\tceph_con_send(&session->s_con, msg);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int request_close_session(struct ceph_mds_client *mdsc,\n\t\t\t\t struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *msg;\n\n\tdout(\"request_close_session mds%d state %s seq %lld\\n\",\n\t     session->s_mds, ceph_session_state_name(session->s_state),\n\t     session->s_seq);\n\tmsg = create_session_msg(CEPH_SESSION_REQUEST_CLOSE, session->s_seq);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\tceph_con_send(&session->s_con, msg);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __close_session(struct ceph_mds_client *mdsc,\n\t\t\t struct ceph_mds_session *session)\n{\n\tif (session->s_state >= CEPH_MDS_SESSION_CLOSING)\n\t\treturn 0;\n\tsession->s_state = CEPH_MDS_SESSION_CLOSING;\n\treturn request_close_session(mdsc, session);\n}"
  },
  {
    "function_name": "request_close_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "1298-1311",
    "snippet": "static int request_close_session(struct ceph_mds_client *mdsc,\n\t\t\t\t struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *msg;\n\n\tdout(\"request_close_session mds%d state %s seq %lld\\n\",\n\t     session->s_mds, ceph_session_state_name(session->s_state),\n\t     session->s_seq);\n\tmsg = create_session_msg(CEPH_SESSION_REQUEST_CLOSE, session->s_seq);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\tceph_con_send(&session->s_con, msg);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_con_send",
          "args": [
            "&session->s_con",
            "msg"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_session_msg",
          "args": [
            "CEPH_SESSION_REQUEST_CLOSE",
            "session->s_seq"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "create_session_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "815-831",
          "snippet": "static struct ceph_msg *create_session_msg(u32 op, u64 seq)\n{\n\tstruct ceph_msg *msg;\n\tstruct ceph_mds_session_head *h;\n\n\tmsg = ceph_msg_new(CEPH_MSG_CLIENT_SESSION, sizeof(*h), GFP_NOFS,\n\t\t\t   false);\n\tif (!msg) {\n\t\tpr_err(\"create_session_msg ENOMEM creating msg\\n\");\n\t\treturn NULL;\n\t}\n\th = msg->front.iov_base;\n\th->op = cpu_to_le32(op);\n\th->seq = cpu_to_le64(seq);\n\n\treturn msg;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_msg *create_session_msg(u32 op, u64 seq)\n{\n\tstruct ceph_msg *msg;\n\tstruct ceph_mds_session_head *h;\n\n\tmsg = ceph_msg_new(CEPH_MSG_CLIENT_SESSION, sizeof(*h), GFP_NOFS,\n\t\t\t   false);\n\tif (!msg) {\n\t\tpr_err(\"create_session_msg ENOMEM creating msg\\n\");\n\t\treturn NULL;\n\t}\n\th = msg->front.iov_base;\n\th->op = cpu_to_le32(op);\n\th->seq = cpu_to_le64(seq);\n\n\treturn msg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"request_close_session mds%d state %s seq %lld\\n\"",
            "session->s_mds",
            "ceph_session_state_name(session->s_state)",
            "session->s_seq"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_session_state_name",
          "args": [
            "session->s_state"
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_session_state_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "348-360",
          "snippet": "const char *ceph_session_state_name(int s)\n{\n\tswitch (s) {\n\tcase CEPH_MDS_SESSION_NEW: return \"new\";\n\tcase CEPH_MDS_SESSION_OPENING: return \"opening\";\n\tcase CEPH_MDS_SESSION_OPEN: return \"open\";\n\tcase CEPH_MDS_SESSION_HUNG: return \"hung\";\n\tcase CEPH_MDS_SESSION_CLOSING: return \"closing\";\n\tcase CEPH_MDS_SESSION_RESTARTING: return \"restarting\";\n\tcase CEPH_MDS_SESSION_RECONNECTING: return \"reconnecting\";\n\tdefault: return \"???\";\n\t}\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nconst char *ceph_session_state_name(int s)\n{\n\tswitch (s) {\n\tcase CEPH_MDS_SESSION_NEW: return \"new\";\n\tcase CEPH_MDS_SESSION_OPENING: return \"opening\";\n\tcase CEPH_MDS_SESSION_OPEN: return \"open\";\n\tcase CEPH_MDS_SESSION_HUNG: return \"hung\";\n\tcase CEPH_MDS_SESSION_CLOSING: return \"closing\";\n\tcase CEPH_MDS_SESSION_RESTARTING: return \"restarting\";\n\tcase CEPH_MDS_SESSION_RECONNECTING: return \"reconnecting\";\n\tdefault: return \"???\";\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int request_close_session(struct ceph_mds_client *mdsc,\n\t\t\t\t struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *msg;\n\n\tdout(\"request_close_session mds%d state %s seq %lld\\n\",\n\t     session->s_mds, ceph_session_state_name(session->s_state),\n\t     session->s_seq);\n\tmsg = create_session_msg(CEPH_SESSION_REQUEST_CLOSE, session->s_seq);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\tceph_con_send(&session->s_con, msg);\n\treturn 0;\n}"
  },
  {
    "function_name": "renewed_caps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "1266-1293",
    "snippet": "static void renewed_caps(struct ceph_mds_client *mdsc,\n\t\t\t struct ceph_mds_session *session, int is_renew)\n{\n\tint was_stale;\n\tint wake = 0;\n\n\tspin_lock(&session->s_cap_lock);\n\twas_stale = is_renew && time_after_eq(jiffies, session->s_cap_ttl);\n\n\tsession->s_cap_ttl = session->s_renew_requested +\n\t\tmdsc->mdsmap->m_session_timeout*HZ;\n\n\tif (was_stale) {\n\t\tif (time_before(jiffies, session->s_cap_ttl)) {\n\t\t\tpr_info(\"mds%d caps renewed\\n\", session->s_mds);\n\t\t\twake = 1;\n\t\t} else {\n\t\t\tpr_info(\"mds%d caps still stale\\n\", session->s_mds);\n\t\t}\n\t}\n\tdout(\"renewed_caps mds%d ttl now %lu, was %s, now %s\\n\",\n\t     session->s_mds, session->s_cap_ttl, was_stale ? \"stale\" : \"fresh\",\n\t     time_before(jiffies, session->s_cap_ttl) ? \"stale\" : \"fresh\");\n\tspin_unlock(&session->s_cap_lock);\n\n\tif (wake)\n\t\twake_up_session_caps(session, 0);\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_session_caps",
          "args": [
            "session",
            "0"
          ],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_session_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1202-1208",
          "snippet": "static void wake_up_session_caps(struct ceph_mds_session *session,\n\t\t\t\t int reconnect)\n{\n\tdout(\"wake_up_session_caps %p mds%d\\n\", session, session->s_mds);\n\titerate_session_caps(session, wake_up_session_cb,\n\t\t\t     (void *)(unsigned long)reconnect);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void wake_up_session_caps(struct ceph_mds_session *session,\n\t\t\t\t int reconnect)\n{\n\tdout(\"wake_up_session_caps %p mds%d\\n\", session, session->s_mds);\n\titerate_session_caps(session, wake_up_session_cb,\n\t\t\t     (void *)(unsigned long)reconnect);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&session->s_cap_lock"
          ],
          "line": 1289
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"renewed_caps mds%d ttl now %lu, was %s, now %s\\n\"",
            "session->s_mds",
            "session->s_cap_ttl",
            "was_stale ? \"stale\" : \"fresh\"",
            "time_before(jiffies, session->s_cap_ttl) ? \"stale\" : \"fresh\""
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "jiffies",
            "session->s_cap_ttl"
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"mds%d caps still stale\\n\"",
            "session->s_mds"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"mds%d caps renewed\\n\"",
            "session->s_mds"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "jiffies",
            "session->s_cap_ttl"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after_eq",
          "args": [
            "jiffies",
            "session->s_cap_ttl"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&session->s_cap_lock"
          ],
          "line": 1272
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void renewed_caps(struct ceph_mds_client *mdsc,\n\t\t\t struct ceph_mds_session *session, int is_renew)\n{\n\tint was_stale;\n\tint wake = 0;\n\n\tspin_lock(&session->s_cap_lock);\n\twas_stale = is_renew && time_after_eq(jiffies, session->s_cap_ttl);\n\n\tsession->s_cap_ttl = session->s_renew_requested +\n\t\tmdsc->mdsmap->m_session_timeout*HZ;\n\n\tif (was_stale) {\n\t\tif (time_before(jiffies, session->s_cap_ttl)) {\n\t\t\tpr_info(\"mds%d caps renewed\\n\", session->s_mds);\n\t\t\twake = 1;\n\t\t} else {\n\t\t\tpr_info(\"mds%d caps still stale\\n\", session->s_mds);\n\t\t}\n\t}\n\tdout(\"renewed_caps mds%d ttl now %lu, was %s, now %s\\n\",\n\t     session->s_mds, session->s_cap_ttl, was_stale ? \"stale\" : \"fresh\",\n\t     time_before(jiffies, session->s_cap_ttl) ? \"stale\" : \"fresh\");\n\tspin_unlock(&session->s_cap_lock);\n\n\tif (wake)\n\t\twake_up_session_caps(session, 0);\n}"
  },
  {
    "function_name": "send_flushmsg_ack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "1246-1258",
    "snippet": "static int send_flushmsg_ack(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_mds_session *session, u64 seq)\n{\n\tstruct ceph_msg *msg;\n\n\tdout(\"send_flushmsg_ack to mds%d (%s)s seq %lld\\n\",\n\t     session->s_mds, ceph_session_state_name(session->s_state), seq);\n\tmsg = create_session_msg(CEPH_SESSION_FLUSHMSG_ACK, seq);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\tceph_con_send(&session->s_con, msg);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_con_send",
          "args": [
            "&session->s_con",
            "msg"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_session_msg",
          "args": [
            "CEPH_SESSION_FLUSHMSG_ACK",
            "seq"
          ],
          "line": 1253
        },
        "resolved": true,
        "details": {
          "function_name": "create_session_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "815-831",
          "snippet": "static struct ceph_msg *create_session_msg(u32 op, u64 seq)\n{\n\tstruct ceph_msg *msg;\n\tstruct ceph_mds_session_head *h;\n\n\tmsg = ceph_msg_new(CEPH_MSG_CLIENT_SESSION, sizeof(*h), GFP_NOFS,\n\t\t\t   false);\n\tif (!msg) {\n\t\tpr_err(\"create_session_msg ENOMEM creating msg\\n\");\n\t\treturn NULL;\n\t}\n\th = msg->front.iov_base;\n\th->op = cpu_to_le32(op);\n\th->seq = cpu_to_le64(seq);\n\n\treturn msg;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_msg *create_session_msg(u32 op, u64 seq)\n{\n\tstruct ceph_msg *msg;\n\tstruct ceph_mds_session_head *h;\n\n\tmsg = ceph_msg_new(CEPH_MSG_CLIENT_SESSION, sizeof(*h), GFP_NOFS,\n\t\t\t   false);\n\tif (!msg) {\n\t\tpr_err(\"create_session_msg ENOMEM creating msg\\n\");\n\t\treturn NULL;\n\t}\n\th = msg->front.iov_base;\n\th->op = cpu_to_le32(op);\n\th->seq = cpu_to_le64(seq);\n\n\treturn msg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"send_flushmsg_ack to mds%d (%s)s seq %lld\\n\"",
            "session->s_mds",
            "ceph_session_state_name(session->s_state)",
            "seq"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_session_state_name",
          "args": [
            "session->s_state"
          ],
          "line": 1252
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_session_state_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "348-360",
          "snippet": "const char *ceph_session_state_name(int s)\n{\n\tswitch (s) {\n\tcase CEPH_MDS_SESSION_NEW: return \"new\";\n\tcase CEPH_MDS_SESSION_OPENING: return \"opening\";\n\tcase CEPH_MDS_SESSION_OPEN: return \"open\";\n\tcase CEPH_MDS_SESSION_HUNG: return \"hung\";\n\tcase CEPH_MDS_SESSION_CLOSING: return \"closing\";\n\tcase CEPH_MDS_SESSION_RESTARTING: return \"restarting\";\n\tcase CEPH_MDS_SESSION_RECONNECTING: return \"reconnecting\";\n\tdefault: return \"???\";\n\t}\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nconst char *ceph_session_state_name(int s)\n{\n\tswitch (s) {\n\tcase CEPH_MDS_SESSION_NEW: return \"new\";\n\tcase CEPH_MDS_SESSION_OPENING: return \"opening\";\n\tcase CEPH_MDS_SESSION_OPEN: return \"open\";\n\tcase CEPH_MDS_SESSION_HUNG: return \"hung\";\n\tcase CEPH_MDS_SESSION_CLOSING: return \"closing\";\n\tcase CEPH_MDS_SESSION_RESTARTING: return \"restarting\";\n\tcase CEPH_MDS_SESSION_RECONNECTING: return \"reconnecting\";\n\tdefault: return \"???\";\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int send_flushmsg_ack(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_mds_session *session, u64 seq)\n{\n\tstruct ceph_msg *msg;\n\n\tdout(\"send_flushmsg_ack to mds%d (%s)s seq %lld\\n\",\n\t     session->s_mds, ceph_session_state_name(session->s_state), seq);\n\tmsg = create_session_msg(CEPH_SESSION_FLUSHMSG_ACK, seq);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\tceph_con_send(&session->s_con, msg);\n\treturn 0;\n}"
  },
  {
    "function_name": "send_renew_caps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "1216-1244",
    "snippet": "static int send_renew_caps(struct ceph_mds_client *mdsc,\n\t\t\t   struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *msg;\n\tint state;\n\n\tif (time_after_eq(jiffies, session->s_cap_ttl) &&\n\t    time_after_eq(session->s_cap_ttl, session->s_renew_requested))\n\t\tpr_info(\"mds%d caps stale\\n\", session->s_mds);\n\tsession->s_renew_requested = jiffies;\n\n\t/* do not try to renew caps until a recovering mds has reconnected\n\t * with its clients. */\n\tstate = ceph_mdsmap_get_state(mdsc->mdsmap, session->s_mds);\n\tif (state < CEPH_MDS_STATE_RECONNECT) {\n\t\tdout(\"send_renew_caps ignoring mds%d (%s)\\n\",\n\t\t     session->s_mds, ceph_mds_state_name(state));\n\t\treturn 0;\n\t}\n\n\tdout(\"send_renew_caps to mds%d (%s)\\n\", session->s_mds,\n\t\tceph_mds_state_name(state));\n\tmsg = create_session_msg(CEPH_SESSION_REQUEST_RENEWCAPS,\n\t\t\t\t ++session->s_renew_seq);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\tceph_con_send(&session->s_con, msg);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_con_send",
          "args": [
            "&session->s_con",
            "msg"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_session_msg",
          "args": [
            "CEPH_SESSION_REQUEST_RENEWCAPS",
            "++session->s_renew_seq"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "create_session_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "815-831",
          "snippet": "static struct ceph_msg *create_session_msg(u32 op, u64 seq)\n{\n\tstruct ceph_msg *msg;\n\tstruct ceph_mds_session_head *h;\n\n\tmsg = ceph_msg_new(CEPH_MSG_CLIENT_SESSION, sizeof(*h), GFP_NOFS,\n\t\t\t   false);\n\tif (!msg) {\n\t\tpr_err(\"create_session_msg ENOMEM creating msg\\n\");\n\t\treturn NULL;\n\t}\n\th = msg->front.iov_base;\n\th->op = cpu_to_le32(op);\n\th->seq = cpu_to_le64(seq);\n\n\treturn msg;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_msg *create_session_msg(u32 op, u64 seq)\n{\n\tstruct ceph_msg *msg;\n\tstruct ceph_mds_session_head *h;\n\n\tmsg = ceph_msg_new(CEPH_MSG_CLIENT_SESSION, sizeof(*h), GFP_NOFS,\n\t\t\t   false);\n\tif (!msg) {\n\t\tpr_err(\"create_session_msg ENOMEM creating msg\\n\");\n\t\treturn NULL;\n\t}\n\th = msg->front.iov_base;\n\th->op = cpu_to_le32(op);\n\th->seq = cpu_to_le64(seq);\n\n\treturn msg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"send_renew_caps to mds%d (%s)\\n\"",
            "session->s_mds",
            "ceph_mds_state_name(state)"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mds_state_name",
          "args": [
            "state"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mds_state_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/strings.c",
          "lines": "8-31",
          "snippet": "const char *ceph_mds_state_name(int s)\n{\n\tswitch (s) {\n\t\t/* down and out */\n\tcase CEPH_MDS_STATE_DNE:        return \"down:dne\";\n\tcase CEPH_MDS_STATE_STOPPED:    return \"down:stopped\";\n\t\t/* up and out */\n\tcase CEPH_MDS_STATE_BOOT:       return \"up:boot\";\n\tcase CEPH_MDS_STATE_STANDBY:    return \"up:standby\";\n\tcase CEPH_MDS_STATE_STANDBY_REPLAY:    return \"up:standby-replay\";\n\tcase CEPH_MDS_STATE_REPLAYONCE: return \"up:oneshot-replay\";\n\tcase CEPH_MDS_STATE_CREATING:   return \"up:creating\";\n\tcase CEPH_MDS_STATE_STARTING:   return \"up:starting\";\n\t\t/* up and in */\n\tcase CEPH_MDS_STATE_REPLAY:     return \"up:replay\";\n\tcase CEPH_MDS_STATE_RESOLVE:    return \"up:resolve\";\n\tcase CEPH_MDS_STATE_RECONNECT:  return \"up:reconnect\";\n\tcase CEPH_MDS_STATE_REJOIN:     return \"up:rejoin\";\n\tcase CEPH_MDS_STATE_CLIENTREPLAY: return \"up:clientreplay\";\n\tcase CEPH_MDS_STATE_ACTIVE:     return \"up:active\";\n\tcase CEPH_MDS_STATE_STOPPING:   return \"up:stopping\";\n\t}\n\treturn \"???\";\n}",
          "includes": [
            "#include <linux/ceph/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/types.h>\n#include <linux/module.h>\n\nconst char *ceph_mds_state_name(int s)\n{\n\tswitch (s) {\n\t\t/* down and out */\n\tcase CEPH_MDS_STATE_DNE:        return \"down:dne\";\n\tcase CEPH_MDS_STATE_STOPPED:    return \"down:stopped\";\n\t\t/* up and out */\n\tcase CEPH_MDS_STATE_BOOT:       return \"up:boot\";\n\tcase CEPH_MDS_STATE_STANDBY:    return \"up:standby\";\n\tcase CEPH_MDS_STATE_STANDBY_REPLAY:    return \"up:standby-replay\";\n\tcase CEPH_MDS_STATE_REPLAYONCE: return \"up:oneshot-replay\";\n\tcase CEPH_MDS_STATE_CREATING:   return \"up:creating\";\n\tcase CEPH_MDS_STATE_STARTING:   return \"up:starting\";\n\t\t/* up and in */\n\tcase CEPH_MDS_STATE_REPLAY:     return \"up:replay\";\n\tcase CEPH_MDS_STATE_RESOLVE:    return \"up:resolve\";\n\tcase CEPH_MDS_STATE_RECONNECT:  return \"up:reconnect\";\n\tcase CEPH_MDS_STATE_REJOIN:     return \"up:rejoin\";\n\tcase CEPH_MDS_STATE_CLIENTREPLAY: return \"up:clientreplay\";\n\tcase CEPH_MDS_STATE_ACTIVE:     return \"up:active\";\n\tcase CEPH_MDS_STATE_STOPPING:   return \"up:stopping\";\n\t}\n\treturn \"???\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"send_renew_caps ignoring mds%d (%s)\\n\"",
            "session->s_mds",
            "ceph_mds_state_name(state)"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mdsmap_get_state",
          "args": [
            "mdsc->mdsmap",
            "session->s_mds"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"mds%d caps stale\\n\"",
            "session->s_mds"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after_eq",
          "args": [
            "session->s_cap_ttl",
            "session->s_renew_requested"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after_eq",
          "args": [
            "jiffies",
            "session->s_cap_ttl"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int send_renew_caps(struct ceph_mds_client *mdsc,\n\t\t\t   struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *msg;\n\tint state;\n\n\tif (time_after_eq(jiffies, session->s_cap_ttl) &&\n\t    time_after_eq(session->s_cap_ttl, session->s_renew_requested))\n\t\tpr_info(\"mds%d caps stale\\n\", session->s_mds);\n\tsession->s_renew_requested = jiffies;\n\n\t/* do not try to renew caps until a recovering mds has reconnected\n\t * with its clients. */\n\tstate = ceph_mdsmap_get_state(mdsc->mdsmap, session->s_mds);\n\tif (state < CEPH_MDS_STATE_RECONNECT) {\n\t\tdout(\"send_renew_caps ignoring mds%d (%s)\\n\",\n\t\t     session->s_mds, ceph_mds_state_name(state));\n\t\treturn 0;\n\t}\n\n\tdout(\"send_renew_caps to mds%d (%s)\\n\", session->s_mds,\n\t\tceph_mds_state_name(state));\n\tmsg = create_session_msg(CEPH_SESSION_REQUEST_RENEWCAPS,\n\t\t\t\t ++session->s_renew_seq);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\tceph_con_send(&session->s_con, msg);\n\treturn 0;\n}"
  },
  {
    "function_name": "wake_up_session_caps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "1202-1208",
    "snippet": "static void wake_up_session_caps(struct ceph_mds_session *session,\n\t\t\t\t int reconnect)\n{\n\tdout(\"wake_up_session_caps %p mds%d\\n\", session, session->s_mds);\n\titerate_session_caps(session, wake_up_session_cb,\n\t\t\t     (void *)(unsigned long)reconnect);\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iterate_session_caps",
          "args": [
            "session",
            "wake_up_session_cb",
            "(void *)(unsigned long)reconnect"
          ],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_session_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1030-1089",
          "snippet": "static int iterate_session_caps(struct ceph_mds_session *session,\n\t\t\t\t int (*cb)(struct inode *, struct ceph_cap *,\n\t\t\t\t\t    void *), void *arg)\n{\n\tstruct list_head *p;\n\tstruct ceph_cap *cap;\n\tstruct inode *inode, *last_inode = NULL;\n\tstruct ceph_cap *old_cap = NULL;\n\tint ret;\n\n\tdout(\"iterate_session_caps %p mds%d\\n\", session, session->s_mds);\n\tspin_lock(&session->s_cap_lock);\n\tp = session->s_caps.next;\n\twhile (p != &session->s_caps) {\n\t\tcap = list_entry(p, struct ceph_cap, session_caps);\n\t\tinode = igrab(&cap->ci->vfs_inode);\n\t\tif (!inode) {\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tsession->s_cap_iterator = cap;\n\t\tspin_unlock(&session->s_cap_lock);\n\n\t\tif (last_inode) {\n\t\t\tiput(last_inode);\n\t\t\tlast_inode = NULL;\n\t\t}\n\t\tif (old_cap) {\n\t\t\tceph_put_cap(session->s_mdsc, old_cap);\n\t\t\told_cap = NULL;\n\t\t}\n\n\t\tret = cb(inode, cap, arg);\n\t\tlast_inode = inode;\n\n\t\tspin_lock(&session->s_cap_lock);\n\t\tp = p->next;\n\t\tif (cap->ci == NULL) {\n\t\t\tdout(\"iterate_session_caps  finishing cap %p removal\\n\",\n\t\t\t     cap);\n\t\t\tBUG_ON(cap->session != session);\n\t\t\tlist_del_init(&cap->session_caps);\n\t\t\tsession->s_nr_caps--;\n\t\t\tcap->session = NULL;\n\t\t\told_cap = cap;  /* put_cap it w/o locks held */\n\t\t}\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tsession->s_cap_iterator = NULL;\n\tspin_unlock(&session->s_cap_lock);\n\n\tiput(last_inode);\n\tif (old_cap)\n\t\tceph_put_cap(session->s_mdsc, old_cap);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int iterate_session_caps(struct ceph_mds_session *session,\n\t\t\t\t int (*cb)(struct inode *, struct ceph_cap *,\n\t\t\t\t\t    void *), void *arg)\n{\n\tstruct list_head *p;\n\tstruct ceph_cap *cap;\n\tstruct inode *inode, *last_inode = NULL;\n\tstruct ceph_cap *old_cap = NULL;\n\tint ret;\n\n\tdout(\"iterate_session_caps %p mds%d\\n\", session, session->s_mds);\n\tspin_lock(&session->s_cap_lock);\n\tp = session->s_caps.next;\n\twhile (p != &session->s_caps) {\n\t\tcap = list_entry(p, struct ceph_cap, session_caps);\n\t\tinode = igrab(&cap->ci->vfs_inode);\n\t\tif (!inode) {\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tsession->s_cap_iterator = cap;\n\t\tspin_unlock(&session->s_cap_lock);\n\n\t\tif (last_inode) {\n\t\t\tiput(last_inode);\n\t\t\tlast_inode = NULL;\n\t\t}\n\t\tif (old_cap) {\n\t\t\tceph_put_cap(session->s_mdsc, old_cap);\n\t\t\told_cap = NULL;\n\t\t}\n\n\t\tret = cb(inode, cap, arg);\n\t\tlast_inode = inode;\n\n\t\tspin_lock(&session->s_cap_lock);\n\t\tp = p->next;\n\t\tif (cap->ci == NULL) {\n\t\t\tdout(\"iterate_session_caps  finishing cap %p removal\\n\",\n\t\t\t     cap);\n\t\t\tBUG_ON(cap->session != session);\n\t\t\tlist_del_init(&cap->session_caps);\n\t\t\tsession->s_nr_caps--;\n\t\t\tcap->session = NULL;\n\t\t\told_cap = cap;  /* put_cap it w/o locks held */\n\t\t}\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tsession->s_cap_iterator = NULL;\n\tspin_unlock(&session->s_cap_lock);\n\n\tiput(last_inode);\n\tif (old_cap)\n\t\tceph_put_cap(session->s_mdsc, old_cap);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"wake_up_session_caps %p mds%d\\n\"",
            "session",
            "session->s_mds"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void wake_up_session_caps(struct ceph_mds_session *session,\n\t\t\t\t int reconnect)\n{\n\tdout(\"wake_up_session_caps %p mds%d\\n\", session, session->s_mds);\n\titerate_session_caps(session, wake_up_session_cb,\n\t\t\t     (void *)(unsigned long)reconnect);\n}"
  },
  {
    "function_name": "wake_up_session_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "1187-1200",
    "snippet": "static int wake_up_session_cb(struct inode *inode, struct ceph_cap *cap,\n\t\t\t      void *arg)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\twake_up_all(&ci->i_cap_wq);\n\tif (arg) {\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tci->i_wanted_max_size = 0;\n\t\tci->i_requested_max_size = 0;\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 1194
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&ci->i_cap_wq"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int wake_up_session_cb(struct inode *inode, struct ceph_cap *cap,\n\t\t\t      void *arg)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\twake_up_all(&ci->i_cap_wq);\n\tif (arg) {\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tci->i_wanted_max_size = 0;\n\t\tci->i_requested_max_size = 0;\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "remove_session_caps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "1141-1179",
    "snippet": "static void remove_session_caps(struct ceph_mds_session *session)\n{\n\tdout(\"remove_session_caps on %p\\n\", session);\n\titerate_session_caps(session, remove_session_caps_cb, NULL);\n\n\tspin_lock(&session->s_cap_lock);\n\tif (session->s_nr_caps > 0) {\n\t\tstruct super_block *sb = session->s_mdsc->fsc->sb;\n\t\tstruct inode *inode;\n\t\tstruct ceph_cap *cap, *prev = NULL;\n\t\tstruct ceph_vino vino;\n\t\t/*\n\t\t * iterate_session_caps() skips inodes that are being\n\t\t * deleted, we need to wait until deletions are complete.\n\t\t * __wait_on_freeing_inode() is designed for the job,\n\t\t * but it is not exported, so use lookup inode function\n\t\t * to access it.\n\t\t */\n\t\twhile (!list_empty(&session->s_caps)) {\n\t\t\tcap = list_entry(session->s_caps.next,\n\t\t\t\t\t struct ceph_cap, session_caps);\n\t\t\tif (cap == prev)\n\t\t\t\tbreak;\n\t\t\tprev = cap;\n\t\t\tvino = cap->ci->i_vino;\n\t\t\tspin_unlock(&session->s_cap_lock);\n\n\t\t\tinode = ceph_find_inode(sb, vino);\n\t\t\tiput(inode);\n\n\t\t\tspin_lock(&session->s_cap_lock);\n\t\t}\n\t}\n\tspin_unlock(&session->s_cap_lock);\n\n\tBUG_ON(session->s_nr_caps > 0);\n\tBUG_ON(!list_empty(&session->s_cap_flushing));\n\tcleanup_cap_releases(session);\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cleanup_cap_releases",
          "args": [
            "session"
          ],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_cap_releases",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1004-1022",
          "snippet": "static void cleanup_cap_releases(struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *msg;\n\n\tspin_lock(&session->s_cap_lock);\n\twhile (!list_empty(&session->s_cap_releases)) {\n\t\tmsg = list_first_entry(&session->s_cap_releases,\n\t\t\t\t       struct ceph_msg, list_head);\n\t\tlist_del_init(&msg->list_head);\n\t\tceph_msg_put(msg);\n\t}\n\twhile (!list_empty(&session->s_cap_releases_done)) {\n\t\tmsg = list_first_entry(&session->s_cap_releases_done,\n\t\t\t\t       struct ceph_msg, list_head);\n\t\tlist_del_init(&msg->list_head);\n\t\tceph_msg_put(msg);\n\t}\n\tspin_unlock(&session->s_cap_lock);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void cleanup_cap_releases(struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *msg;\n\n\tspin_lock(&session->s_cap_lock);\n\twhile (!list_empty(&session->s_cap_releases)) {\n\t\tmsg = list_first_entry(&session->s_cap_releases,\n\t\t\t\t       struct ceph_msg, list_head);\n\t\tlist_del_init(&msg->list_head);\n\t\tceph_msg_put(msg);\n\t}\n\twhile (!list_empty(&session->s_cap_releases_done)) {\n\t\tmsg = list_first_entry(&session->s_cap_releases_done,\n\t\t\t\t       struct ceph_msg, list_head);\n\t\tlist_del_init(&msg->list_head);\n\t\tceph_msg_put(msg);\n\t}\n\tspin_unlock(&session->s_cap_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&session->s_cap_flushing)"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&session->s_cap_flushing"
          ],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "session->s_nr_caps > 0"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&session->s_cap_lock"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&session->s_cap_lock"
          ],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 1169
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_find_inode",
          "args": [
            "sb",
            "vino"
          ],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_find_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "429-434",
          "snippet": "static inline struct inode *ceph_find_inode(struct super_block *sb,\n\t\t\t\t\t    struct ceph_vino vino)\n{\n\tino_t t = ceph_vino_to_ino(vino);\n\treturn ilookup5(sb, t, ceph_ino_compare, &vino);\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct inode *ceph_find_inode(struct super_block *sb,\n\t\t\t\t\t    struct ceph_vino vino)\n{\n\tino_t t = ceph_vino_to_ino(vino);\n\treturn ilookup5(sb, t, ceph_ino_compare, &vino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "session->s_caps.next",
            "structceph_cap",
            "session_caps"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iterate_session_caps",
          "args": [
            "session",
            "remove_session_caps_cb",
            "NULL"
          ],
          "line": 1144
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_session_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1030-1089",
          "snippet": "static int iterate_session_caps(struct ceph_mds_session *session,\n\t\t\t\t int (*cb)(struct inode *, struct ceph_cap *,\n\t\t\t\t\t    void *), void *arg)\n{\n\tstruct list_head *p;\n\tstruct ceph_cap *cap;\n\tstruct inode *inode, *last_inode = NULL;\n\tstruct ceph_cap *old_cap = NULL;\n\tint ret;\n\n\tdout(\"iterate_session_caps %p mds%d\\n\", session, session->s_mds);\n\tspin_lock(&session->s_cap_lock);\n\tp = session->s_caps.next;\n\twhile (p != &session->s_caps) {\n\t\tcap = list_entry(p, struct ceph_cap, session_caps);\n\t\tinode = igrab(&cap->ci->vfs_inode);\n\t\tif (!inode) {\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tsession->s_cap_iterator = cap;\n\t\tspin_unlock(&session->s_cap_lock);\n\n\t\tif (last_inode) {\n\t\t\tiput(last_inode);\n\t\t\tlast_inode = NULL;\n\t\t}\n\t\tif (old_cap) {\n\t\t\tceph_put_cap(session->s_mdsc, old_cap);\n\t\t\told_cap = NULL;\n\t\t}\n\n\t\tret = cb(inode, cap, arg);\n\t\tlast_inode = inode;\n\n\t\tspin_lock(&session->s_cap_lock);\n\t\tp = p->next;\n\t\tif (cap->ci == NULL) {\n\t\t\tdout(\"iterate_session_caps  finishing cap %p removal\\n\",\n\t\t\t     cap);\n\t\t\tBUG_ON(cap->session != session);\n\t\t\tlist_del_init(&cap->session_caps);\n\t\t\tsession->s_nr_caps--;\n\t\t\tcap->session = NULL;\n\t\t\told_cap = cap;  /* put_cap it w/o locks held */\n\t\t}\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tsession->s_cap_iterator = NULL;\n\tspin_unlock(&session->s_cap_lock);\n\n\tiput(last_inode);\n\tif (old_cap)\n\t\tceph_put_cap(session->s_mdsc, old_cap);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int iterate_session_caps(struct ceph_mds_session *session,\n\t\t\t\t int (*cb)(struct inode *, struct ceph_cap *,\n\t\t\t\t\t    void *), void *arg)\n{\n\tstruct list_head *p;\n\tstruct ceph_cap *cap;\n\tstruct inode *inode, *last_inode = NULL;\n\tstruct ceph_cap *old_cap = NULL;\n\tint ret;\n\n\tdout(\"iterate_session_caps %p mds%d\\n\", session, session->s_mds);\n\tspin_lock(&session->s_cap_lock);\n\tp = session->s_caps.next;\n\twhile (p != &session->s_caps) {\n\t\tcap = list_entry(p, struct ceph_cap, session_caps);\n\t\tinode = igrab(&cap->ci->vfs_inode);\n\t\tif (!inode) {\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tsession->s_cap_iterator = cap;\n\t\tspin_unlock(&session->s_cap_lock);\n\n\t\tif (last_inode) {\n\t\t\tiput(last_inode);\n\t\t\tlast_inode = NULL;\n\t\t}\n\t\tif (old_cap) {\n\t\t\tceph_put_cap(session->s_mdsc, old_cap);\n\t\t\told_cap = NULL;\n\t\t}\n\n\t\tret = cb(inode, cap, arg);\n\t\tlast_inode = inode;\n\n\t\tspin_lock(&session->s_cap_lock);\n\t\tp = p->next;\n\t\tif (cap->ci == NULL) {\n\t\t\tdout(\"iterate_session_caps  finishing cap %p removal\\n\",\n\t\t\t     cap);\n\t\t\tBUG_ON(cap->session != session);\n\t\t\tlist_del_init(&cap->session_caps);\n\t\t\tsession->s_nr_caps--;\n\t\t\tcap->session = NULL;\n\t\t\told_cap = cap;  /* put_cap it w/o locks held */\n\t\t}\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tsession->s_cap_iterator = NULL;\n\tspin_unlock(&session->s_cap_lock);\n\n\tiput(last_inode);\n\tif (old_cap)\n\t\tceph_put_cap(session->s_mdsc, old_cap);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"remove_session_caps on %p\\n\"",
            "session"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void remove_session_caps(struct ceph_mds_session *session)\n{\n\tdout(\"remove_session_caps on %p\\n\", session);\n\titerate_session_caps(session, remove_session_caps_cb, NULL);\n\n\tspin_lock(&session->s_cap_lock);\n\tif (session->s_nr_caps > 0) {\n\t\tstruct super_block *sb = session->s_mdsc->fsc->sb;\n\t\tstruct inode *inode;\n\t\tstruct ceph_cap *cap, *prev = NULL;\n\t\tstruct ceph_vino vino;\n\t\t/*\n\t\t * iterate_session_caps() skips inodes that are being\n\t\t * deleted, we need to wait until deletions are complete.\n\t\t * __wait_on_freeing_inode() is designed for the job,\n\t\t * but it is not exported, so use lookup inode function\n\t\t * to access it.\n\t\t */\n\t\twhile (!list_empty(&session->s_caps)) {\n\t\t\tcap = list_entry(session->s_caps.next,\n\t\t\t\t\t struct ceph_cap, session_caps);\n\t\t\tif (cap == prev)\n\t\t\t\tbreak;\n\t\t\tprev = cap;\n\t\t\tvino = cap->ci->i_vino;\n\t\t\tspin_unlock(&session->s_cap_lock);\n\n\t\t\tinode = ceph_find_inode(sb, vino);\n\t\t\tiput(inode);\n\n\t\t\tspin_lock(&session->s_cap_lock);\n\t\t}\n\t}\n\tspin_unlock(&session->s_cap_lock);\n\n\tBUG_ON(session->s_nr_caps > 0);\n\tBUG_ON(!list_empty(&session->s_cap_flushing));\n\tcleanup_cap_releases(session);\n}"
  },
  {
    "function_name": "remove_session_caps_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "1091-1136",
    "snippet": "static int remove_session_caps_cb(struct inode *inode, struct ceph_cap *cap,\n\t\t\t\t  void *arg)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint drop = 0;\n\n\tdout(\"removing cap %p, ci is %p, inode is %p\\n\",\n\t     cap, ci, &ci->vfs_inode);\n\tspin_lock(&ci->i_ceph_lock);\n\t__ceph_remove_cap(cap, false);\n\tif (!__ceph_is_any_real_caps(ci)) {\n\t\tstruct ceph_mds_client *mdsc =\n\t\t\tceph_sb_to_client(inode->i_sb)->mdsc;\n\n\t\tspin_lock(&mdsc->cap_dirty_lock);\n\t\tif (!list_empty(&ci->i_dirty_item)) {\n\t\t\tpr_info(\" dropping dirty %s state for %p %lld\\n\",\n\t\t\t\tceph_cap_string(ci->i_dirty_caps),\n\t\t\t\tinode, ceph_ino(inode));\n\t\t\tci->i_dirty_caps = 0;\n\t\t\tlist_del_init(&ci->i_dirty_item);\n\t\t\tdrop = 1;\n\t\t}\n\t\tif (!list_empty(&ci->i_flushing_item)) {\n\t\t\tpr_info(\" dropping dirty+flushing %s state for %p %lld\\n\",\n\t\t\t\tceph_cap_string(ci->i_flushing_caps),\n\t\t\t\tinode, ceph_ino(inode));\n\t\t\tci->i_flushing_caps = 0;\n\t\t\tlist_del_init(&ci->i_flushing_item);\n\t\t\tmdsc->num_cap_flushing--;\n\t\t\tdrop = 1;\n\t\t}\n\t\tif (drop && ci->i_wrbuffer_ref) {\n\t\t\tpr_info(\" dropping dirty data for %p %lld\\n\",\n\t\t\t\tinode, ceph_ino(inode));\n\t\t\tci->i_wrbuffer_ref = 0;\n\t\t\tci->i_wrbuffer_ref_head = 0;\n\t\t\tdrop++;\n\t\t}\n\t\tspin_unlock(&mdsc->cap_dirty_lock);\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\twhile (drop--)\n\t\tiput(inode);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 1132
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\" dropping dirty data for %p %lld\\n\"",
            "inode",
            "ceph_ino(inode)"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_ino",
          "args": [
            "inode"
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "412-415",
          "snippet": "static inline u64 ceph_ino(struct inode *inode)\n{\n\treturn ceph_inode(inode)->i_vino.ino;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline u64 ceph_ino(struct inode *inode)\n{\n\treturn ceph_inode(inode)->i_vino.ino;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&ci->i_flushing_item"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\" dropping dirty+flushing %s state for %p %lld\\n\"",
            "ceph_cap_string(ci->i_flushing_caps)",
            "inode",
            "ceph_ino(inode)"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_cap_string",
          "args": [
            "ci->i_flushing_caps"
          ],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_cap_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "71-116",
          "snippet": "const char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [
            "#define MAX_CAP_STR 20"
          ],
          "globals_used": [
            "static char cap_str[MAX_CAP_STR][40];",
            "static DEFINE_SPINLOCK(cap_str_lock);",
            "static int last_cap_str;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\n#define MAX_CAP_STR 20\n\nstatic char cap_str[MAX_CAP_STR][40];\nstatic DEFINE_SPINLOCK(cap_str_lock);\nstatic int last_cap_str;\n\nconst char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ci->i_flushing_item"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&ci->i_dirty_item"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\" dropping dirty %s state for %p %lld\\n\"",
            "ceph_cap_string(ci->i_dirty_caps)",
            "inode",
            "ceph_ino(inode)"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mdsc->cap_dirty_lock"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_sb_to_client",
          "args": [
            "inode->i_sb"
          ],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_sb_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "352-355",
          "snippet": "static inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_is_any_real_caps",
          "args": [
            "ci"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_is_any_real_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "521-524",
          "snippet": "static inline bool __ceph_is_any_real_caps(struct ceph_inode_info *ci)\n{\n\treturn !RB_EMPTY_ROOT(&ci->i_caps);\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline bool __ceph_is_any_real_caps(struct ceph_inode_info *ci)\n{\n\treturn !RB_EMPTY_ROOT(&ci->i_caps);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_remove_cap",
          "args": [
            "cap",
            "false"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_remove_cap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "905-960",
          "snippet": "void __ceph_remove_cap(struct ceph_cap *cap, bool queue_release)\n{\n\tstruct ceph_mds_session *session = cap->session;\n\tstruct ceph_inode_info *ci = cap->ci;\n\tstruct ceph_mds_client *mdsc =\n\t\tceph_sb_to_client(ci->vfs_inode.i_sb)->mdsc;\n\tint removed = 0;\n\n\tdout(\"__ceph_remove_cap %p from %p\\n\", cap, &ci->vfs_inode);\n\n\t/* remove from session list */\n\tspin_lock(&session->s_cap_lock);\n\t/*\n\t * s_cap_reconnect is protected by s_cap_lock. no one changes\n\t * s_cap_gen while session is in the reconnect state.\n\t */\n\tif (queue_release &&\n\t    (!session->s_cap_reconnect ||\n\t     cap->cap_gen == session->s_cap_gen))\n\t\t__queue_cap_release(session, ci->i_vino.ino, cap->cap_id,\n\t\t\t\t    cap->mseq, cap->issue_seq);\n\n\tif (session->s_cap_iterator == cap) {\n\t\t/* not yet, we are iterating over this very cap */\n\t\tdout(\"__ceph_remove_cap  delaying %p removal from session %p\\n\",\n\t\t     cap, cap->session);\n\t} else {\n\t\tlist_del_init(&cap->session_caps);\n\t\tsession->s_nr_caps--;\n\t\tcap->session = NULL;\n\t\tremoved = 1;\n\t}\n\t/* protect backpointer with s_cap_lock: see iterate_session_caps */\n\tcap->ci = NULL;\n\tspin_unlock(&session->s_cap_lock);\n\n\t/* remove from inode list */\n\trb_erase(&cap->ci_node, &ci->i_caps);\n\tif (ci->i_auth_cap == cap)\n\t\tci->i_auth_cap = NULL;\n\n\tif (removed)\n\t\tceph_put_cap(mdsc, cap);\n\n\tif (!__ceph_is_any_caps(ci) && ci->i_snap_realm) {\n\t\tstruct ceph_snap_realm *realm = ci->i_snap_realm;\n\t\tspin_lock(&realm->inodes_with_caps_lock);\n\t\tlist_del_init(&ci->i_snap_realm_item);\n\t\tci->i_snap_realm_counter++;\n\t\tci->i_snap_realm = NULL;\n\t\tspin_unlock(&realm->inodes_with_caps_lock);\n\t\tceph_put_snap_realm(mdsc, realm);\n\t}\n\tif (!__ceph_is_any_real_caps(ci))\n\t\t__cap_delay_cancel(mdsc, ci);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid __ceph_remove_cap(struct ceph_cap *cap, bool queue_release)\n{\n\tstruct ceph_mds_session *session = cap->session;\n\tstruct ceph_inode_info *ci = cap->ci;\n\tstruct ceph_mds_client *mdsc =\n\t\tceph_sb_to_client(ci->vfs_inode.i_sb)->mdsc;\n\tint removed = 0;\n\n\tdout(\"__ceph_remove_cap %p from %p\\n\", cap, &ci->vfs_inode);\n\n\t/* remove from session list */\n\tspin_lock(&session->s_cap_lock);\n\t/*\n\t * s_cap_reconnect is protected by s_cap_lock. no one changes\n\t * s_cap_gen while session is in the reconnect state.\n\t */\n\tif (queue_release &&\n\t    (!session->s_cap_reconnect ||\n\t     cap->cap_gen == session->s_cap_gen))\n\t\t__queue_cap_release(session, ci->i_vino.ino, cap->cap_id,\n\t\t\t\t    cap->mseq, cap->issue_seq);\n\n\tif (session->s_cap_iterator == cap) {\n\t\t/* not yet, we are iterating over this very cap */\n\t\tdout(\"__ceph_remove_cap  delaying %p removal from session %p\\n\",\n\t\t     cap, cap->session);\n\t} else {\n\t\tlist_del_init(&cap->session_caps);\n\t\tsession->s_nr_caps--;\n\t\tcap->session = NULL;\n\t\tremoved = 1;\n\t}\n\t/* protect backpointer with s_cap_lock: see iterate_session_caps */\n\tcap->ci = NULL;\n\tspin_unlock(&session->s_cap_lock);\n\n\t/* remove from inode list */\n\trb_erase(&cap->ci_node, &ci->i_caps);\n\tif (ci->i_auth_cap == cap)\n\t\tci->i_auth_cap = NULL;\n\n\tif (removed)\n\t\tceph_put_cap(mdsc, cap);\n\n\tif (!__ceph_is_any_caps(ci) && ci->i_snap_realm) {\n\t\tstruct ceph_snap_realm *realm = ci->i_snap_realm;\n\t\tspin_lock(&realm->inodes_with_caps_lock);\n\t\tlist_del_init(&ci->i_snap_realm_item);\n\t\tci->i_snap_realm_counter++;\n\t\tci->i_snap_realm = NULL;\n\t\tspin_unlock(&realm->inodes_with_caps_lock);\n\t\tceph_put_snap_realm(mdsc, realm);\n\t}\n\tif (!__ceph_is_any_real_caps(ci))\n\t\t__cap_delay_cancel(mdsc, ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"removing cap %p, ci is %p, inode is %p\\n\"",
            "cap",
            "ci",
            "&ci->vfs_inode"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int remove_session_caps_cb(struct inode *inode, struct ceph_cap *cap,\n\t\t\t\t  void *arg)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint drop = 0;\n\n\tdout(\"removing cap %p, ci is %p, inode is %p\\n\",\n\t     cap, ci, &ci->vfs_inode);\n\tspin_lock(&ci->i_ceph_lock);\n\t__ceph_remove_cap(cap, false);\n\tif (!__ceph_is_any_real_caps(ci)) {\n\t\tstruct ceph_mds_client *mdsc =\n\t\t\tceph_sb_to_client(inode->i_sb)->mdsc;\n\n\t\tspin_lock(&mdsc->cap_dirty_lock);\n\t\tif (!list_empty(&ci->i_dirty_item)) {\n\t\t\tpr_info(\" dropping dirty %s state for %p %lld\\n\",\n\t\t\t\tceph_cap_string(ci->i_dirty_caps),\n\t\t\t\tinode, ceph_ino(inode));\n\t\t\tci->i_dirty_caps = 0;\n\t\t\tlist_del_init(&ci->i_dirty_item);\n\t\t\tdrop = 1;\n\t\t}\n\t\tif (!list_empty(&ci->i_flushing_item)) {\n\t\t\tpr_info(\" dropping dirty+flushing %s state for %p %lld\\n\",\n\t\t\t\tceph_cap_string(ci->i_flushing_caps),\n\t\t\t\tinode, ceph_ino(inode));\n\t\t\tci->i_flushing_caps = 0;\n\t\t\tlist_del_init(&ci->i_flushing_item);\n\t\t\tmdsc->num_cap_flushing--;\n\t\t\tdrop = 1;\n\t\t}\n\t\tif (drop && ci->i_wrbuffer_ref) {\n\t\t\tpr_info(\" dropping dirty data for %p %lld\\n\",\n\t\t\t\tinode, ceph_ino(inode));\n\t\t\tci->i_wrbuffer_ref = 0;\n\t\t\tci->i_wrbuffer_ref_head = 0;\n\t\t\tdrop++;\n\t\t}\n\t\tspin_unlock(&mdsc->cap_dirty_lock);\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\twhile (drop--)\n\t\tiput(inode);\n\treturn 0;\n}"
  },
  {
    "function_name": "iterate_session_caps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "1030-1089",
    "snippet": "static int iterate_session_caps(struct ceph_mds_session *session,\n\t\t\t\t int (*cb)(struct inode *, struct ceph_cap *,\n\t\t\t\t\t    void *), void *arg)\n{\n\tstruct list_head *p;\n\tstruct ceph_cap *cap;\n\tstruct inode *inode, *last_inode = NULL;\n\tstruct ceph_cap *old_cap = NULL;\n\tint ret;\n\n\tdout(\"iterate_session_caps %p mds%d\\n\", session, session->s_mds);\n\tspin_lock(&session->s_cap_lock);\n\tp = session->s_caps.next;\n\twhile (p != &session->s_caps) {\n\t\tcap = list_entry(p, struct ceph_cap, session_caps);\n\t\tinode = igrab(&cap->ci->vfs_inode);\n\t\tif (!inode) {\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tsession->s_cap_iterator = cap;\n\t\tspin_unlock(&session->s_cap_lock);\n\n\t\tif (last_inode) {\n\t\t\tiput(last_inode);\n\t\t\tlast_inode = NULL;\n\t\t}\n\t\tif (old_cap) {\n\t\t\tceph_put_cap(session->s_mdsc, old_cap);\n\t\t\told_cap = NULL;\n\t\t}\n\n\t\tret = cb(inode, cap, arg);\n\t\tlast_inode = inode;\n\n\t\tspin_lock(&session->s_cap_lock);\n\t\tp = p->next;\n\t\tif (cap->ci == NULL) {\n\t\t\tdout(\"iterate_session_caps  finishing cap %p removal\\n\",\n\t\t\t     cap);\n\t\t\tBUG_ON(cap->session != session);\n\t\t\tlist_del_init(&cap->session_caps);\n\t\t\tsession->s_nr_caps--;\n\t\t\tcap->session = NULL;\n\t\t\told_cap = cap;  /* put_cap it w/o locks held */\n\t\t}\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tsession->s_cap_iterator = NULL;\n\tspin_unlock(&session->s_cap_lock);\n\n\tiput(last_inode);\n\tif (old_cap)\n\t\tceph_put_cap(session->s_mdsc, old_cap);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_put_cap",
          "args": [
            "session->s_mdsc",
            "old_cap"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_put_cap_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "2274-2326",
          "snippet": "void ceph_put_cap_refs(struct ceph_inode_info *ci, int had)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint last = 0, put = 0, flushsnaps = 0, wake = 0;\n\tstruct ceph_cap_snap *capsnap;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (had & CEPH_CAP_PIN)\n\t\t--ci->i_pin_ref;\n\tif (had & CEPH_CAP_FILE_RD)\n\t\tif (--ci->i_rd_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_CACHE)\n\t\tif (--ci->i_rdcache_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_BUFFER) {\n\t\tif (--ci->i_wb_ref == 0) {\n\t\t\tlast++;\n\t\t\tput++;\n\t\t}\n\t\tdout(\"put_cap_refs %p wb %d -> %d (?)\\n\",\n\t\t     inode, ci->i_wb_ref+1, ci->i_wb_ref);\n\t}\n\tif (had & CEPH_CAP_FILE_WR)\n\t\tif (--ci->i_wr_ref == 0) {\n\t\t\tlast++;\n\t\t\tif (!list_empty(&ci->i_cap_snaps)) {\n\t\t\t\tcapsnap = list_first_entry(&ci->i_cap_snaps,\n\t\t\t\t\t\t     struct ceph_cap_snap,\n\t\t\t\t\t\t     ci_item);\n\t\t\t\tif (capsnap->writing) {\n\t\t\t\t\tcapsnap->writing = 0;\n\t\t\t\t\tflushsnaps =\n\t\t\t\t\t\t__ceph_finish_cap_snap(ci,\n\t\t\t\t\t\t\t\t       capsnap);\n\t\t\t\t\twake = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tdout(\"put_cap_refs %p had %s%s%s\\n\", inode, ceph_cap_string(had),\n\t     last ? \" last\" : \"\", put ? \" put\" : \"\");\n\n\tif (last && !flushsnaps)\n\t\tceph_check_caps(ci, 0, NULL);\n\telse if (flushsnaps)\n\t\tceph_flush_snaps(ci);\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\tif (put)\n\t\tiput(inode);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_put_cap_refs(struct ceph_inode_info *ci, int had)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint last = 0, put = 0, flushsnaps = 0, wake = 0;\n\tstruct ceph_cap_snap *capsnap;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (had & CEPH_CAP_PIN)\n\t\t--ci->i_pin_ref;\n\tif (had & CEPH_CAP_FILE_RD)\n\t\tif (--ci->i_rd_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_CACHE)\n\t\tif (--ci->i_rdcache_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_BUFFER) {\n\t\tif (--ci->i_wb_ref == 0) {\n\t\t\tlast++;\n\t\t\tput++;\n\t\t}\n\t\tdout(\"put_cap_refs %p wb %d -> %d (?)\\n\",\n\t\t     inode, ci->i_wb_ref+1, ci->i_wb_ref);\n\t}\n\tif (had & CEPH_CAP_FILE_WR)\n\t\tif (--ci->i_wr_ref == 0) {\n\t\t\tlast++;\n\t\t\tif (!list_empty(&ci->i_cap_snaps)) {\n\t\t\t\tcapsnap = list_first_entry(&ci->i_cap_snaps,\n\t\t\t\t\t\t     struct ceph_cap_snap,\n\t\t\t\t\t\t     ci_item);\n\t\t\t\tif (capsnap->writing) {\n\t\t\t\t\tcapsnap->writing = 0;\n\t\t\t\t\tflushsnaps =\n\t\t\t\t\t\t__ceph_finish_cap_snap(ci,\n\t\t\t\t\t\t\t\t       capsnap);\n\t\t\t\t\twake = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tdout(\"put_cap_refs %p had %s%s%s\\n\", inode, ceph_cap_string(had),\n\t     last ? \" last\" : \"\", put ? \" put\" : \"\");\n\n\tif (last && !flushsnaps)\n\t\tceph_check_caps(ci, 0, NULL);\n\telse if (flushsnaps)\n\t\tceph_flush_snaps(ci);\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\tif (put)\n\t\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "last_inode"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&session->s_cap_lock"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&cap->session_caps"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cap->session != session"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"iterate_session_caps  finishing cap %p removal\\n\"",
            "cap"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&session->s_cap_lock"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cb",
          "args": [
            "inode",
            "cap",
            "arg"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "encode_caps_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "2695-2805",
          "snippet": "static int encode_caps_cb(struct inode *inode, struct ceph_cap *cap,\n\t\t\t  void *arg)\n{\n\tunion {\n\t\tstruct ceph_mds_cap_reconnect v2;\n\t\tstruct ceph_mds_cap_reconnect_v1 v1;\n\t} rec;\n\tsize_t reclen;\n\tstruct ceph_inode_info *ci;\n\tstruct ceph_reconnect_state *recon_state = arg;\n\tstruct ceph_pagelist *pagelist = recon_state->pagelist;\n\tchar *path;\n\tint pathlen, err;\n\tu64 pathbase;\n\tstruct dentry *dentry;\n\n\tci = cap->ci;\n\n\tdout(\" adding %p ino %llx.%llx cap %p %lld %s\\n\",\n\t     inode, ceph_vinop(inode), cap, cap->cap_id,\n\t     ceph_cap_string(cap->issued));\n\terr = ceph_pagelist_encode_64(pagelist, ceph_ino(inode));\n\tif (err)\n\t\treturn err;\n\n\tdentry = d_find_alias(inode);\n\tif (dentry) {\n\t\tpath = ceph_mdsc_build_path(dentry, &pathlen, &pathbase, 0);\n\t\tif (IS_ERR(path)) {\n\t\t\terr = PTR_ERR(path);\n\t\t\tgoto out_dput;\n\t\t}\n\t} else {\n\t\tpath = NULL;\n\t\tpathlen = 0;\n\t}\n\terr = ceph_pagelist_encode_string(pagelist, path, pathlen);\n\tif (err)\n\t\tgoto out_free;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tcap->seq = 0;        /* reset cap seq */\n\tcap->issue_seq = 0;  /* and issue_seq */\n\tcap->mseq = 0;       /* and migrate_seq */\n\tcap->cap_gen = cap->session->s_cap_gen;\n\n\tif (recon_state->flock) {\n\t\trec.v2.cap_id = cpu_to_le64(cap->cap_id);\n\t\trec.v2.wanted = cpu_to_le32(__ceph_caps_wanted(ci));\n\t\trec.v2.issued = cpu_to_le32(cap->issued);\n\t\trec.v2.snaprealm = cpu_to_le64(ci->i_snap_realm->ino);\n\t\trec.v2.pathbase = cpu_to_le64(pathbase);\n\t\trec.v2.flock_len = 0;\n\t\treclen = sizeof(rec.v2);\n\t} else {\n\t\trec.v1.cap_id = cpu_to_le64(cap->cap_id);\n\t\trec.v1.wanted = cpu_to_le32(__ceph_caps_wanted(ci));\n\t\trec.v1.issued = cpu_to_le32(cap->issued);\n\t\trec.v1.size = cpu_to_le64(inode->i_size);\n\t\tceph_encode_timespec(&rec.v1.mtime, &inode->i_mtime);\n\t\tceph_encode_timespec(&rec.v1.atime, &inode->i_atime);\n\t\trec.v1.snaprealm = cpu_to_le64(ci->i_snap_realm->ino);\n\t\trec.v1.pathbase = cpu_to_le64(pathbase);\n\t\treclen = sizeof(rec.v1);\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (recon_state->flock) {\n\t\tint num_fcntl_locks, num_flock_locks;\n\t\tstruct ceph_filelock *flocks;\n\nencode_again:\n\t\tceph_count_locks(inode, &num_fcntl_locks, &num_flock_locks);\n\t\tflocks = kmalloc((num_fcntl_locks+num_flock_locks) *\n\t\t\t\t sizeof(struct ceph_filelock), GFP_NOFS);\n\t\tif (!flocks) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_free;\n\t\t}\n\t\terr = ceph_encode_locks_to_buffer(inode, flocks,\n\t\t\t\t\t\t  num_fcntl_locks,\n\t\t\t\t\t\t  num_flock_locks);\n\t\tif (err) {\n\t\t\tkfree(flocks);\n\t\t\tif (err == -ENOSPC)\n\t\t\t\tgoto encode_again;\n\t\t\tgoto out_free;\n\t\t}\n\t\t/*\n\t\t * number of encoded locks is stable, so copy to pagelist\n\t\t */\n\t\trec.v2.flock_len = cpu_to_le32(2*sizeof(u32) +\n\t\t\t\t    (num_fcntl_locks+num_flock_locks) *\n\t\t\t\t    sizeof(struct ceph_filelock));\n\t\terr = ceph_pagelist_append(pagelist, &rec, reclen);\n\t\tif (!err)\n\t\t\terr = ceph_locks_to_pagelist(flocks, pagelist,\n\t\t\t\t\t\t     num_fcntl_locks,\n\t\t\t\t\t\t     num_flock_locks);\n\t\tkfree(flocks);\n\t} else {\n\t\terr = ceph_pagelist_append(pagelist, &rec, reclen);\n\t}\n\n\trecon_state->nr_caps++;\nout_free:\n\tkfree(path);\nout_dput:\n\tdput(dentry);\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int encode_caps_cb(struct inode *inode, struct ceph_cap *cap,\n\t\t\t  void *arg)\n{\n\tunion {\n\t\tstruct ceph_mds_cap_reconnect v2;\n\t\tstruct ceph_mds_cap_reconnect_v1 v1;\n\t} rec;\n\tsize_t reclen;\n\tstruct ceph_inode_info *ci;\n\tstruct ceph_reconnect_state *recon_state = arg;\n\tstruct ceph_pagelist *pagelist = recon_state->pagelist;\n\tchar *path;\n\tint pathlen, err;\n\tu64 pathbase;\n\tstruct dentry *dentry;\n\n\tci = cap->ci;\n\n\tdout(\" adding %p ino %llx.%llx cap %p %lld %s\\n\",\n\t     inode, ceph_vinop(inode), cap, cap->cap_id,\n\t     ceph_cap_string(cap->issued));\n\terr = ceph_pagelist_encode_64(pagelist, ceph_ino(inode));\n\tif (err)\n\t\treturn err;\n\n\tdentry = d_find_alias(inode);\n\tif (dentry) {\n\t\tpath = ceph_mdsc_build_path(dentry, &pathlen, &pathbase, 0);\n\t\tif (IS_ERR(path)) {\n\t\t\terr = PTR_ERR(path);\n\t\t\tgoto out_dput;\n\t\t}\n\t} else {\n\t\tpath = NULL;\n\t\tpathlen = 0;\n\t}\n\terr = ceph_pagelist_encode_string(pagelist, path, pathlen);\n\tif (err)\n\t\tgoto out_free;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tcap->seq = 0;        /* reset cap seq */\n\tcap->issue_seq = 0;  /* and issue_seq */\n\tcap->mseq = 0;       /* and migrate_seq */\n\tcap->cap_gen = cap->session->s_cap_gen;\n\n\tif (recon_state->flock) {\n\t\trec.v2.cap_id = cpu_to_le64(cap->cap_id);\n\t\trec.v2.wanted = cpu_to_le32(__ceph_caps_wanted(ci));\n\t\trec.v2.issued = cpu_to_le32(cap->issued);\n\t\trec.v2.snaprealm = cpu_to_le64(ci->i_snap_realm->ino);\n\t\trec.v2.pathbase = cpu_to_le64(pathbase);\n\t\trec.v2.flock_len = 0;\n\t\treclen = sizeof(rec.v2);\n\t} else {\n\t\trec.v1.cap_id = cpu_to_le64(cap->cap_id);\n\t\trec.v1.wanted = cpu_to_le32(__ceph_caps_wanted(ci));\n\t\trec.v1.issued = cpu_to_le32(cap->issued);\n\t\trec.v1.size = cpu_to_le64(inode->i_size);\n\t\tceph_encode_timespec(&rec.v1.mtime, &inode->i_mtime);\n\t\tceph_encode_timespec(&rec.v1.atime, &inode->i_atime);\n\t\trec.v1.snaprealm = cpu_to_le64(ci->i_snap_realm->ino);\n\t\trec.v1.pathbase = cpu_to_le64(pathbase);\n\t\treclen = sizeof(rec.v1);\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (recon_state->flock) {\n\t\tint num_fcntl_locks, num_flock_locks;\n\t\tstruct ceph_filelock *flocks;\n\nencode_again:\n\t\tceph_count_locks(inode, &num_fcntl_locks, &num_flock_locks);\n\t\tflocks = kmalloc((num_fcntl_locks+num_flock_locks) *\n\t\t\t\t sizeof(struct ceph_filelock), GFP_NOFS);\n\t\tif (!flocks) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_free;\n\t\t}\n\t\terr = ceph_encode_locks_to_buffer(inode, flocks,\n\t\t\t\t\t\t  num_fcntl_locks,\n\t\t\t\t\t\t  num_flock_locks);\n\t\tif (err) {\n\t\t\tkfree(flocks);\n\t\t\tif (err == -ENOSPC)\n\t\t\t\tgoto encode_again;\n\t\t\tgoto out_free;\n\t\t}\n\t\t/*\n\t\t * number of encoded locks is stable, so copy to pagelist\n\t\t */\n\t\trec.v2.flock_len = cpu_to_le32(2*sizeof(u32) +\n\t\t\t\t    (num_fcntl_locks+num_flock_locks) *\n\t\t\t\t    sizeof(struct ceph_filelock));\n\t\terr = ceph_pagelist_append(pagelist, &rec, reclen);\n\t\tif (!err)\n\t\t\terr = ceph_locks_to_pagelist(flocks, pagelist,\n\t\t\t\t\t\t     num_fcntl_locks,\n\t\t\t\t\t\t     num_flock_locks);\n\t\tkfree(flocks);\n\t} else {\n\t\terr = ceph_pagelist_append(pagelist, &rec, reclen);\n\t}\n\n\trecon_state->nr_caps++;\nout_free:\n\tkfree(path);\nout_dput:\n\tdput(dentry);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "igrab",
          "args": [
            "&cap->ci->vfs_inode"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "igrab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1173-1189",
          "snippet": "struct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "p",
            "structceph_cap",
            "session_caps"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"iterate_session_caps %p mds%d\\n\"",
            "session",
            "session->s_mds"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int iterate_session_caps(struct ceph_mds_session *session,\n\t\t\t\t int (*cb)(struct inode *, struct ceph_cap *,\n\t\t\t\t\t    void *), void *arg)\n{\n\tstruct list_head *p;\n\tstruct ceph_cap *cap;\n\tstruct inode *inode, *last_inode = NULL;\n\tstruct ceph_cap *old_cap = NULL;\n\tint ret;\n\n\tdout(\"iterate_session_caps %p mds%d\\n\", session, session->s_mds);\n\tspin_lock(&session->s_cap_lock);\n\tp = session->s_caps.next;\n\twhile (p != &session->s_caps) {\n\t\tcap = list_entry(p, struct ceph_cap, session_caps);\n\t\tinode = igrab(&cap->ci->vfs_inode);\n\t\tif (!inode) {\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tsession->s_cap_iterator = cap;\n\t\tspin_unlock(&session->s_cap_lock);\n\n\t\tif (last_inode) {\n\t\t\tiput(last_inode);\n\t\t\tlast_inode = NULL;\n\t\t}\n\t\tif (old_cap) {\n\t\t\tceph_put_cap(session->s_mdsc, old_cap);\n\t\t\told_cap = NULL;\n\t\t}\n\n\t\tret = cb(inode, cap, arg);\n\t\tlast_inode = inode;\n\n\t\tspin_lock(&session->s_cap_lock);\n\t\tp = p->next;\n\t\tif (cap->ci == NULL) {\n\t\t\tdout(\"iterate_session_caps  finishing cap %p removal\\n\",\n\t\t\t     cap);\n\t\t\tBUG_ON(cap->session != session);\n\t\t\tlist_del_init(&cap->session_caps);\n\t\t\tsession->s_nr_caps--;\n\t\t\tcap->session = NULL;\n\t\t\told_cap = cap;  /* put_cap it w/o locks held */\n\t\t}\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tsession->s_cap_iterator = NULL;\n\tspin_unlock(&session->s_cap_lock);\n\n\tiput(last_inode);\n\tif (old_cap)\n\t\tceph_put_cap(session->s_mdsc, old_cap);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "cleanup_cap_releases",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "1004-1022",
    "snippet": "static void cleanup_cap_releases(struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *msg;\n\n\tspin_lock(&session->s_cap_lock);\n\twhile (!list_empty(&session->s_cap_releases)) {\n\t\tmsg = list_first_entry(&session->s_cap_releases,\n\t\t\t\t       struct ceph_msg, list_head);\n\t\tlist_del_init(&msg->list_head);\n\t\tceph_msg_put(msg);\n\t}\n\twhile (!list_empty(&session->s_cap_releases_done)) {\n\t\tmsg = list_first_entry(&session->s_cap_releases_done,\n\t\t\t\t       struct ceph_msg, list_head);\n\t\tlist_del_init(&msg->list_head);\n\t\tceph_msg_put(msg);\n\t}\n\tspin_unlock(&session->s_cap_lock);\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&session->s_cap_lock"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_msg_put",
          "args": [
            "msg"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&msg->list_head"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&session->s_cap_releases_done",
            "structceph_msg",
            "list_head"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&session->s_cap_releases_done"
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_msg_put",
          "args": [
            "msg"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&msg->list_head"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&session->s_cap_releases",
            "structceph_msg",
            "list_head"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&session->s_cap_lock"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void cleanup_cap_releases(struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *msg;\n\n\tspin_lock(&session->s_cap_lock);\n\twhile (!list_empty(&session->s_cap_releases)) {\n\t\tmsg = list_first_entry(&session->s_cap_releases,\n\t\t\t\t       struct ceph_msg, list_head);\n\t\tlist_del_init(&msg->list_head);\n\t\tceph_msg_put(msg);\n\t}\n\twhile (!list_empty(&session->s_cap_releases_done)) {\n\t\tmsg = list_first_entry(&session->s_cap_releases_done,\n\t\t\t\t       struct ceph_msg, list_head);\n\t\tlist_del_init(&msg->list_head);\n\t\tceph_msg_put(msg);\n\t}\n\tspin_unlock(&session->s_cap_lock);\n}"
  },
  {
    "function_name": "ceph_mdsc_open_export_target_sessions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "989-995",
    "snippet": "void ceph_mdsc_open_export_target_sessions(struct ceph_mds_client *mdsc,\n\t\t\t\t\t   struct ceph_mds_session *session)\n{\n\tmutex_lock(&mdsc->mutex);\n\t__open_export_target_sessions(mdsc, session);\n\tmutex_unlock(&mdsc->mutex);\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__open_export_target_sessions",
          "args": [
            "mdsc",
            "session"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "__open_export_target_sessions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "968-987",
          "snippet": "static void __open_export_target_sessions(struct ceph_mds_client *mdsc,\n\t\t\t\t\t  struct ceph_mds_session *session)\n{\n\tstruct ceph_mds_info *mi;\n\tstruct ceph_mds_session *ts;\n\tint i, mds = session->s_mds;\n\n\tif (mds >= mdsc->mdsmap->m_max_mds)\n\t\treturn;\n\n\tmi = &mdsc->mdsmap->m_info[mds];\n\tdout(\"open_export_target_sessions for mds%d (%d targets)\\n\",\n\t     session->s_mds, mi->num_export_targets);\n\n\tfor (i = 0; i < mi->num_export_targets; i++) {\n\t\tts = __open_export_target_session(mdsc, mi->export_targets[i]);\n\t\tif (!IS_ERR(ts))\n\t\t\tceph_put_mds_session(ts);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __open_export_target_sessions(struct ceph_mds_client *mdsc,\n\t\t\t\t\t  struct ceph_mds_session *session)\n{\n\tstruct ceph_mds_info *mi;\n\tstruct ceph_mds_session *ts;\n\tint i, mds = session->s_mds;\n\n\tif (mds >= mdsc->mdsmap->m_max_mds)\n\t\treturn;\n\n\tmi = &mdsc->mdsmap->m_info[mds];\n\tdout(\"open_export_target_sessions for mds%d (%d targets)\\n\",\n\t     session->s_mds, mi->num_export_targets);\n\n\tfor (i = 0; i < mi->num_export_targets; i++) {\n\t\tts = __open_export_target_session(mdsc, mi->export_targets[i]);\n\t\tif (!IS_ERR(ts))\n\t\t\tceph_put_mds_session(ts);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_mdsc_open_export_target_sessions(struct ceph_mds_client *mdsc,\n\t\t\t\t\t   struct ceph_mds_session *session)\n{\n\tmutex_lock(&mdsc->mutex);\n\t__open_export_target_sessions(mdsc, session);\n\tmutex_unlock(&mdsc->mutex);\n}"
  },
  {
    "function_name": "__open_export_target_sessions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "968-987",
    "snippet": "static void __open_export_target_sessions(struct ceph_mds_client *mdsc,\n\t\t\t\t\t  struct ceph_mds_session *session)\n{\n\tstruct ceph_mds_info *mi;\n\tstruct ceph_mds_session *ts;\n\tint i, mds = session->s_mds;\n\n\tif (mds >= mdsc->mdsmap->m_max_mds)\n\t\treturn;\n\n\tmi = &mdsc->mdsmap->m_info[mds];\n\tdout(\"open_export_target_sessions for mds%d (%d targets)\\n\",\n\t     session->s_mds, mi->num_export_targets);\n\n\tfor (i = 0; i < mi->num_export_targets; i++) {\n\t\tts = __open_export_target_session(mdsc, mi->export_targets[i]);\n\t\tif (!IS_ERR(ts))\n\t\t\tceph_put_mds_session(ts);\n\t}\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_put_mds_session",
          "args": [
            "ts"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_put_mds_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "374-385",
          "snippet": "void ceph_put_mds_session(struct ceph_mds_session *s)\n{\n\tdout(\"mdsc put_session %p %d -> %d\\n\", s,\n\t     atomic_read(&s->s_ref), atomic_read(&s->s_ref)-1);\n\tif (atomic_dec_and_test(&s->s_ref)) {\n\t\tif (s->s_auth.authorizer)\n\t\t\tceph_auth_destroy_authorizer(\n\t\t\t\ts->s_mdsc->fsc->client->monc.auth,\n\t\t\t\ts->s_auth.authorizer);\n\t\tkfree(s);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_put_mds_session(struct ceph_mds_session *s)\n{\n\tdout(\"mdsc put_session %p %d -> %d\\n\", s,\n\t     atomic_read(&s->s_ref), atomic_read(&s->s_ref)-1);\n\tif (atomic_dec_and_test(&s->s_ref)) {\n\t\tif (s->s_auth.authorizer)\n\t\t\tceph_auth_destroy_authorizer(\n\t\t\t\ts->s_mdsc->fsc->client->monc.auth,\n\t\t\t\ts->s_auth.authorizer);\n\t\tkfree(s);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ts"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__open_export_target_session",
          "args": [
            "mdsc",
            "mi->export_targets[i]"
          ],
          "line": 983
        },
        "resolved": true,
        "details": {
          "function_name": "__open_export_target_sessions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "968-987",
          "snippet": "static void __open_export_target_sessions(struct ceph_mds_client *mdsc,\n\t\t\t\t\t  struct ceph_mds_session *session)\n{\n\tstruct ceph_mds_info *mi;\n\tstruct ceph_mds_session *ts;\n\tint i, mds = session->s_mds;\n\n\tif (mds >= mdsc->mdsmap->m_max_mds)\n\t\treturn;\n\n\tmi = &mdsc->mdsmap->m_info[mds];\n\tdout(\"open_export_target_sessions for mds%d (%d targets)\\n\",\n\t     session->s_mds, mi->num_export_targets);\n\n\tfor (i = 0; i < mi->num_export_targets; i++) {\n\t\tts = __open_export_target_session(mdsc, mi->export_targets[i]);\n\t\tif (!IS_ERR(ts))\n\t\t\tceph_put_mds_session(ts);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"open_export_target_sessions for mds%d (%d targets)\\n\"",
            "session->s_mds",
            "mi->num_export_targets"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __open_export_target_sessions(struct ceph_mds_client *mdsc,\n\t\t\t\t\t  struct ceph_mds_session *session)\n{\n\tstruct ceph_mds_info *mi;\n\tstruct ceph_mds_session *ts;\n\tint i, mds = session->s_mds;\n\n\tif (mds >= mdsc->mdsmap->m_max_mds)\n\t\treturn;\n\n\tmi = &mdsc->mdsmap->m_info[mds];\n\tdout(\"open_export_target_sessions for mds%d (%d targets)\\n\",\n\t     session->s_mds, mi->num_export_targets);\n\n\tfor (i = 0; i < mi->num_export_targets; i++) {\n\t\tts = __open_export_target_session(mdsc, mi->export_targets[i]);\n\t\tif (!IS_ERR(ts))\n\t\t\tceph_put_mds_session(ts);\n\t}\n}"
  },
  {
    "function_name": "ceph_mdsc_open_export_target_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "954-966",
    "snippet": "struct ceph_mds_session *\nceph_mdsc_open_export_target_session(struct ceph_mds_client *mdsc, int target)\n{\n\tstruct ceph_mds_session *session;\n\n\tdout(\"open_export_target_session to mds%d\\n\", target);\n\n\tmutex_lock(&mdsc->mutex);\n\tsession = __open_export_target_session(mdsc, target);\n\tmutex_unlock(&mdsc->mutex);\n\n\treturn session;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__open_export_target_session",
          "args": [
            "mdsc",
            "target"
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "__open_export_target_sessions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "968-987",
          "snippet": "static void __open_export_target_sessions(struct ceph_mds_client *mdsc,\n\t\t\t\t\t  struct ceph_mds_session *session)\n{\n\tstruct ceph_mds_info *mi;\n\tstruct ceph_mds_session *ts;\n\tint i, mds = session->s_mds;\n\n\tif (mds >= mdsc->mdsmap->m_max_mds)\n\t\treturn;\n\n\tmi = &mdsc->mdsmap->m_info[mds];\n\tdout(\"open_export_target_sessions for mds%d (%d targets)\\n\",\n\t     session->s_mds, mi->num_export_targets);\n\n\tfor (i = 0; i < mi->num_export_targets; i++) {\n\t\tts = __open_export_target_session(mdsc, mi->export_targets[i]);\n\t\tif (!IS_ERR(ts))\n\t\t\tceph_put_mds_session(ts);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __open_export_target_sessions(struct ceph_mds_client *mdsc,\n\t\t\t\t\t  struct ceph_mds_session *session)\n{\n\tstruct ceph_mds_info *mi;\n\tstruct ceph_mds_session *ts;\n\tint i, mds = session->s_mds;\n\n\tif (mds >= mdsc->mdsmap->m_max_mds)\n\t\treturn;\n\n\tmi = &mdsc->mdsmap->m_info[mds];\n\tdout(\"open_export_target_sessions for mds%d (%d targets)\\n\",\n\t     session->s_mds, mi->num_export_targets);\n\n\tfor (i = 0; i < mi->num_export_targets; i++) {\n\t\tts = __open_export_target_session(mdsc, mi->export_targets[i]);\n\t\tif (!IS_ERR(ts))\n\t\t\tceph_put_mds_session(ts);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"open_export_target_session to mds%d\\n\"",
            "target"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct ceph_mds_session *\nceph_mdsc_open_export_target_session(struct ceph_mds_client *mdsc, int target)\n{\n\tstruct ceph_mds_session *session;\n\n\tdout(\"open_export_target_session to mds%d\\n\", target);\n\n\tmutex_lock(&mdsc->mutex);\n\tsession = __open_export_target_session(mdsc, target);\n\tmutex_unlock(&mdsc->mutex);\n\n\treturn session;\n}"
  },
  {
    "function_name": "__open_export_target_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "936-952",
    "snippet": "static struct ceph_mds_session *\n__open_export_target_session(struct ceph_mds_client *mdsc, int target)\n{\n\tstruct ceph_mds_session *session;\n\n\tsession = __ceph_lookup_mds_session(mdsc, target);\n\tif (!session) {\n\t\tsession = register_session(mdsc, target);\n\t\tif (IS_ERR(session))\n\t\t\treturn session;\n\t}\n\tif (session->s_state == CEPH_MDS_SESSION_NEW ||\n\t    session->s_state == CEPH_MDS_SESSION_CLOSING)\n\t\t__open_session(mdsc, session);\n\n\treturn session;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__open_session",
          "args": [
            "mdsc",
            "session"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "__open_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "909-929",
          "snippet": "static int __open_session(struct ceph_mds_client *mdsc,\n\t\t\t  struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *msg;\n\tint mstate;\n\tint mds = session->s_mds;\n\n\t/* wait for mds to go active? */\n\tmstate = ceph_mdsmap_get_state(mdsc->mdsmap, mds);\n\tdout(\"open_session to mds%d (%s)\\n\", mds,\n\t     ceph_mds_state_name(mstate));\n\tsession->s_state = CEPH_MDS_SESSION_OPENING;\n\tsession->s_renew_requested = jiffies;\n\n\t/* send connect message */\n\tmsg = create_session_open_msg(mdsc, session->s_seq);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\tceph_con_send(&session->s_con, msg);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __open_session(struct ceph_mds_client *mdsc,\n\t\t\t  struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *msg;\n\tint mstate;\n\tint mds = session->s_mds;\n\n\t/* wait for mds to go active? */\n\tmstate = ceph_mdsmap_get_state(mdsc->mdsmap, mds);\n\tdout(\"open_session to mds%d (%s)\\n\", mds,\n\t     ceph_mds_state_name(mstate));\n\tsession->s_state = CEPH_MDS_SESSION_OPENING;\n\tsession->s_renew_requested = jiffies;\n\n\t/* send connect message */\n\tmsg = create_session_open_msg(mdsc, session->s_seq);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\tceph_con_send(&session->s_con, msg);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "session"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_session",
          "args": [
            "mdsc",
            "target"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "__unregister_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "499-508",
          "snippet": "static void __unregister_session(struct ceph_mds_client *mdsc,\n\t\t\t       struct ceph_mds_session *s)\n{\n\tdout(\"__unregister_session mds%d %p\\n\", s->s_mds, s);\n\tBUG_ON(mdsc->sessions[s->s_mds] != s);\n\tmdsc->sessions[s->s_mds] = NULL;\n\tceph_con_close(&s->s_con);\n\tceph_put_mds_session(s);\n\tatomic_dec(&mdsc->num_sessions);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __unregister_session(struct ceph_mds_client *mdsc,\n\t\t\t       struct ceph_mds_session *s)\n{\n\tdout(\"__unregister_session mds%d %p\\n\", s->s_mds, s);\n\tBUG_ON(mdsc->sessions[s->s_mds] != s);\n\tmdsc->sessions[s->s_mds] = NULL;\n\tceph_con_close(&s->s_con);\n\tceph_put_mds_session(s);\n\tatomic_dec(&mdsc->num_sessions);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_lookup_mds_session",
          "args": [
            "mdsc",
            "target"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_lookup_mds_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "390-402",
          "snippet": "struct ceph_mds_session *__ceph_lookup_mds_session(struct ceph_mds_client *mdsc,\n\t\t\t\t\t\t   int mds)\n{\n\tstruct ceph_mds_session *session;\n\n\tif (mds >= mdsc->max_sessions || mdsc->sessions[mds] == NULL)\n\t\treturn NULL;\n\tsession = mdsc->sessions[mds];\n\tdout(\"lookup_mds_session %p %d\\n\", session,\n\t     atomic_read(&session->s_ref));\n\tget_session(session);\n\treturn session;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct ceph_mds_session *__ceph_lookup_mds_session(struct ceph_mds_client *mdsc,\n\t\t\t\t\t\t   int mds)\n{\n\tstruct ceph_mds_session *session;\n\n\tif (mds >= mdsc->max_sessions || mdsc->sessions[mds] == NULL)\n\t\treturn NULL;\n\tsession = mdsc->sessions[mds];\n\tdout(\"lookup_mds_session %p %d\\n\", session,\n\t     atomic_read(&session->s_ref));\n\tget_session(session);\n\treturn session;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_mds_session *\n__open_export_target_session(struct ceph_mds_client *mdsc, int target)\n{\n\tstruct ceph_mds_session *session;\n\n\tsession = __ceph_lookup_mds_session(mdsc, target);\n\tif (!session) {\n\t\tsession = register_session(mdsc, target);\n\t\tif (IS_ERR(session))\n\t\t\treturn session;\n\t}\n\tif (session->s_state == CEPH_MDS_SESSION_NEW ||\n\t    session->s_state == CEPH_MDS_SESSION_CLOSING)\n\t\t__open_session(mdsc, session);\n\n\treturn session;\n}"
  },
  {
    "function_name": "__open_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "909-929",
    "snippet": "static int __open_session(struct ceph_mds_client *mdsc,\n\t\t\t  struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *msg;\n\tint mstate;\n\tint mds = session->s_mds;\n\n\t/* wait for mds to go active? */\n\tmstate = ceph_mdsmap_get_state(mdsc->mdsmap, mds);\n\tdout(\"open_session to mds%d (%s)\\n\", mds,\n\t     ceph_mds_state_name(mstate));\n\tsession->s_state = CEPH_MDS_SESSION_OPENING;\n\tsession->s_renew_requested = jiffies;\n\n\t/* send connect message */\n\tmsg = create_session_open_msg(mdsc, session->s_seq);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\tceph_con_send(&session->s_con, msg);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_con_send",
          "args": [
            "&session->s_con",
            "msg"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_session_open_msg",
          "args": [
            "mdsc",
            "session->s_seq"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "create_session_open_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "837-902",
          "snippet": "static struct ceph_msg *create_session_open_msg(struct ceph_mds_client *mdsc, u64 seq)\n{\n\tstruct ceph_msg *msg;\n\tstruct ceph_mds_session_head *h;\n\tint i = -1;\n\tint metadata_bytes = 0;\n\tint metadata_key_count = 0;\n\tstruct ceph_options *opt = mdsc->fsc->client->options;\n\tvoid *p;\n\n\tconst char* metadata[][2] = {\n\t\t{\"hostname\", utsname()->nodename},\n\t\t{\"kernel_version\", utsname()->release},\n\t\t{\"entity_id\", opt->name ? opt->name : \"\"},\n\t\t{NULL, NULL}\n\t};\n\n\t/* Calculate serialized length of metadata */\n\tmetadata_bytes = 4;  /* map length */\n\tfor (i = 0; metadata[i][0] != NULL; ++i) {\n\t\tmetadata_bytes += 8 + strlen(metadata[i][0]) +\n\t\t\tstrlen(metadata[i][1]);\n\t\tmetadata_key_count++;\n\t}\n\n\t/* Allocate the message */\n\tmsg = ceph_msg_new(CEPH_MSG_CLIENT_SESSION, sizeof(*h) + metadata_bytes,\n\t\t\t   GFP_NOFS, false);\n\tif (!msg) {\n\t\tpr_err(\"create_session_msg ENOMEM creating msg\\n\");\n\t\treturn NULL;\n\t}\n\th = msg->front.iov_base;\n\th->op = cpu_to_le32(CEPH_SESSION_REQUEST_OPEN);\n\th->seq = cpu_to_le64(seq);\n\n\t/*\n\t * Serialize client metadata into waiting buffer space, using\n\t * the format that userspace expects for map<string, string>\n\t *\n\t * ClientSession messages with metadata are v2\n\t */\n\tmsg->hdr.version = cpu_to_le16(2);\n\tmsg->hdr.compat_version = cpu_to_le16(1);\n\n\t/* The write pointer, following the session_head structure */\n\tp = msg->front.iov_base + sizeof(*h);\n\n\t/* Number of entries in the map */\n\tceph_encode_32(&p, metadata_key_count);\n\n\t/* Two length-prefixed strings for each entry in the map */\n\tfor (i = 0; metadata[i][0] != NULL; ++i) {\n\t\tsize_t const key_len = strlen(metadata[i][0]);\n\t\tsize_t const val_len = strlen(metadata[i][1]);\n\n\t\tceph_encode_32(&p, key_len);\n\t\tmemcpy(p, metadata[i][0], key_len);\n\t\tp += key_len;\n\t\tceph_encode_32(&p, val_len);\n\t\tmemcpy(p, metadata[i][1], val_len);\n\t\tp += val_len;\n\t}\n\n\treturn msg;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_msg *create_session_open_msg(struct ceph_mds_client *mdsc, u64 seq)\n{\n\tstruct ceph_msg *msg;\n\tstruct ceph_mds_session_head *h;\n\tint i = -1;\n\tint metadata_bytes = 0;\n\tint metadata_key_count = 0;\n\tstruct ceph_options *opt = mdsc->fsc->client->options;\n\tvoid *p;\n\n\tconst char* metadata[][2] = {\n\t\t{\"hostname\", utsname()->nodename},\n\t\t{\"kernel_version\", utsname()->release},\n\t\t{\"entity_id\", opt->name ? opt->name : \"\"},\n\t\t{NULL, NULL}\n\t};\n\n\t/* Calculate serialized length of metadata */\n\tmetadata_bytes = 4;  /* map length */\n\tfor (i = 0; metadata[i][0] != NULL; ++i) {\n\t\tmetadata_bytes += 8 + strlen(metadata[i][0]) +\n\t\t\tstrlen(metadata[i][1]);\n\t\tmetadata_key_count++;\n\t}\n\n\t/* Allocate the message */\n\tmsg = ceph_msg_new(CEPH_MSG_CLIENT_SESSION, sizeof(*h) + metadata_bytes,\n\t\t\t   GFP_NOFS, false);\n\tif (!msg) {\n\t\tpr_err(\"create_session_msg ENOMEM creating msg\\n\");\n\t\treturn NULL;\n\t}\n\th = msg->front.iov_base;\n\th->op = cpu_to_le32(CEPH_SESSION_REQUEST_OPEN);\n\th->seq = cpu_to_le64(seq);\n\n\t/*\n\t * Serialize client metadata into waiting buffer space, using\n\t * the format that userspace expects for map<string, string>\n\t *\n\t * ClientSession messages with metadata are v2\n\t */\n\tmsg->hdr.version = cpu_to_le16(2);\n\tmsg->hdr.compat_version = cpu_to_le16(1);\n\n\t/* The write pointer, following the session_head structure */\n\tp = msg->front.iov_base + sizeof(*h);\n\n\t/* Number of entries in the map */\n\tceph_encode_32(&p, metadata_key_count);\n\n\t/* Two length-prefixed strings for each entry in the map */\n\tfor (i = 0; metadata[i][0] != NULL; ++i) {\n\t\tsize_t const key_len = strlen(metadata[i][0]);\n\t\tsize_t const val_len = strlen(metadata[i][1]);\n\n\t\tceph_encode_32(&p, key_len);\n\t\tmemcpy(p, metadata[i][0], key_len);\n\t\tp += key_len;\n\t\tceph_encode_32(&p, val_len);\n\t\tmemcpy(p, metadata[i][1], val_len);\n\t\tp += val_len;\n\t}\n\n\treturn msg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"open_session to mds%d (%s)\\n\"",
            "mds",
            "ceph_mds_state_name(mstate)"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mds_state_name",
          "args": [
            "mstate"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mds_state_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/strings.c",
          "lines": "8-31",
          "snippet": "const char *ceph_mds_state_name(int s)\n{\n\tswitch (s) {\n\t\t/* down and out */\n\tcase CEPH_MDS_STATE_DNE:        return \"down:dne\";\n\tcase CEPH_MDS_STATE_STOPPED:    return \"down:stopped\";\n\t\t/* up and out */\n\tcase CEPH_MDS_STATE_BOOT:       return \"up:boot\";\n\tcase CEPH_MDS_STATE_STANDBY:    return \"up:standby\";\n\tcase CEPH_MDS_STATE_STANDBY_REPLAY:    return \"up:standby-replay\";\n\tcase CEPH_MDS_STATE_REPLAYONCE: return \"up:oneshot-replay\";\n\tcase CEPH_MDS_STATE_CREATING:   return \"up:creating\";\n\tcase CEPH_MDS_STATE_STARTING:   return \"up:starting\";\n\t\t/* up and in */\n\tcase CEPH_MDS_STATE_REPLAY:     return \"up:replay\";\n\tcase CEPH_MDS_STATE_RESOLVE:    return \"up:resolve\";\n\tcase CEPH_MDS_STATE_RECONNECT:  return \"up:reconnect\";\n\tcase CEPH_MDS_STATE_REJOIN:     return \"up:rejoin\";\n\tcase CEPH_MDS_STATE_CLIENTREPLAY: return \"up:clientreplay\";\n\tcase CEPH_MDS_STATE_ACTIVE:     return \"up:active\";\n\tcase CEPH_MDS_STATE_STOPPING:   return \"up:stopping\";\n\t}\n\treturn \"???\";\n}",
          "includes": [
            "#include <linux/ceph/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/types.h>\n#include <linux/module.h>\n\nconst char *ceph_mds_state_name(int s)\n{\n\tswitch (s) {\n\t\t/* down and out */\n\tcase CEPH_MDS_STATE_DNE:        return \"down:dne\";\n\tcase CEPH_MDS_STATE_STOPPED:    return \"down:stopped\";\n\t\t/* up and out */\n\tcase CEPH_MDS_STATE_BOOT:       return \"up:boot\";\n\tcase CEPH_MDS_STATE_STANDBY:    return \"up:standby\";\n\tcase CEPH_MDS_STATE_STANDBY_REPLAY:    return \"up:standby-replay\";\n\tcase CEPH_MDS_STATE_REPLAYONCE: return \"up:oneshot-replay\";\n\tcase CEPH_MDS_STATE_CREATING:   return \"up:creating\";\n\tcase CEPH_MDS_STATE_STARTING:   return \"up:starting\";\n\t\t/* up and in */\n\tcase CEPH_MDS_STATE_REPLAY:     return \"up:replay\";\n\tcase CEPH_MDS_STATE_RESOLVE:    return \"up:resolve\";\n\tcase CEPH_MDS_STATE_RECONNECT:  return \"up:reconnect\";\n\tcase CEPH_MDS_STATE_REJOIN:     return \"up:rejoin\";\n\tcase CEPH_MDS_STATE_CLIENTREPLAY: return \"up:clientreplay\";\n\tcase CEPH_MDS_STATE_ACTIVE:     return \"up:active\";\n\tcase CEPH_MDS_STATE_STOPPING:   return \"up:stopping\";\n\t}\n\treturn \"???\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_mdsmap_get_state",
          "args": [
            "mdsc->mdsmap",
            "mds"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __open_session(struct ceph_mds_client *mdsc,\n\t\t\t  struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *msg;\n\tint mstate;\n\tint mds = session->s_mds;\n\n\t/* wait for mds to go active? */\n\tmstate = ceph_mdsmap_get_state(mdsc->mdsmap, mds);\n\tdout(\"open_session to mds%d (%s)\\n\", mds,\n\t     ceph_mds_state_name(mstate));\n\tsession->s_state = CEPH_MDS_SESSION_OPENING;\n\tsession->s_renew_requested = jiffies;\n\n\t/* send connect message */\n\tmsg = create_session_open_msg(mdsc, session->s_seq);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\tceph_con_send(&session->s_con, msg);\n\treturn 0;\n}"
  },
  {
    "function_name": "create_session_open_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "837-902",
    "snippet": "static struct ceph_msg *create_session_open_msg(struct ceph_mds_client *mdsc, u64 seq)\n{\n\tstruct ceph_msg *msg;\n\tstruct ceph_mds_session_head *h;\n\tint i = -1;\n\tint metadata_bytes = 0;\n\tint metadata_key_count = 0;\n\tstruct ceph_options *opt = mdsc->fsc->client->options;\n\tvoid *p;\n\n\tconst char* metadata[][2] = {\n\t\t{\"hostname\", utsname()->nodename},\n\t\t{\"kernel_version\", utsname()->release},\n\t\t{\"entity_id\", opt->name ? opt->name : \"\"},\n\t\t{NULL, NULL}\n\t};\n\n\t/* Calculate serialized length of metadata */\n\tmetadata_bytes = 4;  /* map length */\n\tfor (i = 0; metadata[i][0] != NULL; ++i) {\n\t\tmetadata_bytes += 8 + strlen(metadata[i][0]) +\n\t\t\tstrlen(metadata[i][1]);\n\t\tmetadata_key_count++;\n\t}\n\n\t/* Allocate the message */\n\tmsg = ceph_msg_new(CEPH_MSG_CLIENT_SESSION, sizeof(*h) + metadata_bytes,\n\t\t\t   GFP_NOFS, false);\n\tif (!msg) {\n\t\tpr_err(\"create_session_msg ENOMEM creating msg\\n\");\n\t\treturn NULL;\n\t}\n\th = msg->front.iov_base;\n\th->op = cpu_to_le32(CEPH_SESSION_REQUEST_OPEN);\n\th->seq = cpu_to_le64(seq);\n\n\t/*\n\t * Serialize client metadata into waiting buffer space, using\n\t * the format that userspace expects for map<string, string>\n\t *\n\t * ClientSession messages with metadata are v2\n\t */\n\tmsg->hdr.version = cpu_to_le16(2);\n\tmsg->hdr.compat_version = cpu_to_le16(1);\n\n\t/* The write pointer, following the session_head structure */\n\tp = msg->front.iov_base + sizeof(*h);\n\n\t/* Number of entries in the map */\n\tceph_encode_32(&p, metadata_key_count);\n\n\t/* Two length-prefixed strings for each entry in the map */\n\tfor (i = 0; metadata[i][0] != NULL; ++i) {\n\t\tsize_t const key_len = strlen(metadata[i][0]);\n\t\tsize_t const val_len = strlen(metadata[i][1]);\n\n\t\tceph_encode_32(&p, key_len);\n\t\tmemcpy(p, metadata[i][0], key_len);\n\t\tp += key_len;\n\t\tceph_encode_32(&p, val_len);\n\t\tmemcpy(p, metadata[i][1], val_len);\n\t\tp += val_len;\n\t}\n\n\treturn msg;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p",
            "metadata[i][1]",
            "val_len"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_encode_32",
          "args": [
            "&p",
            "val_len"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p",
            "metadata[i][0]",
            "key_len"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_encode_32",
          "args": [
            "&p",
            "key_len"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "metadata[i][1]"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_encode_32",
          "args": [
            "&p",
            "metadata_key_count"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "2"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "seq"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "CEPH_SESSION_REQUEST_OPEN"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"create_session_msg ENOMEM creating msg\\n\""
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_msg_new",
          "args": [
            "CEPH_MSG_CLIENT_SESSION",
            "sizeof(*h) + metadata_bytes",
            "GFP_NOFS",
            "false"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utsname",
          "args": [],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utsname",
          "args": [],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_msg *create_session_open_msg(struct ceph_mds_client *mdsc, u64 seq)\n{\n\tstruct ceph_msg *msg;\n\tstruct ceph_mds_session_head *h;\n\tint i = -1;\n\tint metadata_bytes = 0;\n\tint metadata_key_count = 0;\n\tstruct ceph_options *opt = mdsc->fsc->client->options;\n\tvoid *p;\n\n\tconst char* metadata[][2] = {\n\t\t{\"hostname\", utsname()->nodename},\n\t\t{\"kernel_version\", utsname()->release},\n\t\t{\"entity_id\", opt->name ? opt->name : \"\"},\n\t\t{NULL, NULL}\n\t};\n\n\t/* Calculate serialized length of metadata */\n\tmetadata_bytes = 4;  /* map length */\n\tfor (i = 0; metadata[i][0] != NULL; ++i) {\n\t\tmetadata_bytes += 8 + strlen(metadata[i][0]) +\n\t\t\tstrlen(metadata[i][1]);\n\t\tmetadata_key_count++;\n\t}\n\n\t/* Allocate the message */\n\tmsg = ceph_msg_new(CEPH_MSG_CLIENT_SESSION, sizeof(*h) + metadata_bytes,\n\t\t\t   GFP_NOFS, false);\n\tif (!msg) {\n\t\tpr_err(\"create_session_msg ENOMEM creating msg\\n\");\n\t\treturn NULL;\n\t}\n\th = msg->front.iov_base;\n\th->op = cpu_to_le32(CEPH_SESSION_REQUEST_OPEN);\n\th->seq = cpu_to_le64(seq);\n\n\t/*\n\t * Serialize client metadata into waiting buffer space, using\n\t * the format that userspace expects for map<string, string>\n\t *\n\t * ClientSession messages with metadata are v2\n\t */\n\tmsg->hdr.version = cpu_to_le16(2);\n\tmsg->hdr.compat_version = cpu_to_le16(1);\n\n\t/* The write pointer, following the session_head structure */\n\tp = msg->front.iov_base + sizeof(*h);\n\n\t/* Number of entries in the map */\n\tceph_encode_32(&p, metadata_key_count);\n\n\t/* Two length-prefixed strings for each entry in the map */\n\tfor (i = 0; metadata[i][0] != NULL; ++i) {\n\t\tsize_t const key_len = strlen(metadata[i][0]);\n\t\tsize_t const val_len = strlen(metadata[i][1]);\n\n\t\tceph_encode_32(&p, key_len);\n\t\tmemcpy(p, metadata[i][0], key_len);\n\t\tp += key_len;\n\t\tceph_encode_32(&p, val_len);\n\t\tmemcpy(p, metadata[i][1], val_len);\n\t\tp += val_len;\n\t}\n\n\treturn msg;\n}"
  },
  {
    "function_name": "create_session_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "815-831",
    "snippet": "static struct ceph_msg *create_session_msg(u32 op, u64 seq)\n{\n\tstruct ceph_msg *msg;\n\tstruct ceph_mds_session_head *h;\n\n\tmsg = ceph_msg_new(CEPH_MSG_CLIENT_SESSION, sizeof(*h), GFP_NOFS,\n\t\t\t   false);\n\tif (!msg) {\n\t\tpr_err(\"create_session_msg ENOMEM creating msg\\n\");\n\t\treturn NULL;\n\t}\n\th = msg->front.iov_base;\n\th->op = cpu_to_le32(op);\n\th->seq = cpu_to_le64(seq);\n\n\treturn msg;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "seq"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "op"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"create_session_msg ENOMEM creating msg\\n\""
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_msg_new",
          "args": [
            "CEPH_MSG_CLIENT_SESSION",
            "sizeof(*h)",
            "GFP_NOFS",
            "false"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_msg *create_session_msg(u32 op, u64 seq)\n{\n\tstruct ceph_msg *msg;\n\tstruct ceph_mds_session_head *h;\n\n\tmsg = ceph_msg_new(CEPH_MSG_CLIENT_SESSION, sizeof(*h), GFP_NOFS,\n\t\t\t   false);\n\tif (!msg) {\n\t\tpr_err(\"create_session_msg ENOMEM creating msg\\n\");\n\t\treturn NULL;\n\t}\n\th = msg->front.iov_base;\n\th->op = cpu_to_le32(op);\n\th->seq = cpu_to_le64(seq);\n\n\treturn msg;\n}"
  },
  {
    "function_name": "__choose_mds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "687-809",
    "snippet": "static int __choose_mds(struct ceph_mds_client *mdsc,\n\t\t\tstruct ceph_mds_request *req)\n{\n\tstruct inode *inode;\n\tstruct ceph_inode_info *ci;\n\tstruct ceph_cap *cap;\n\tint mode = req->r_direct_mode;\n\tint mds = -1;\n\tu32 hash = req->r_direct_hash;\n\tbool is_hash = req->r_direct_is_hash;\n\n\t/*\n\t * is there a specific mds we should try?  ignore hint if we have\n\t * no session and the mds is not up (active or recovering).\n\t */\n\tif (req->r_resend_mds >= 0 &&\n\t    (__have_session(mdsc, req->r_resend_mds) ||\n\t     ceph_mdsmap_get_state(mdsc->mdsmap, req->r_resend_mds) > 0)) {\n\t\tdout(\"choose_mds using resend_mds mds%d\\n\",\n\t\t     req->r_resend_mds);\n\t\treturn req->r_resend_mds;\n\t}\n\n\tif (mode == USE_RANDOM_MDS)\n\t\tgoto random;\n\n\tinode = NULL;\n\tif (req->r_inode) {\n\t\tinode = req->r_inode;\n\t} else if (req->r_dentry) {\n\t\t/* ignore race with rename; old or new d_parent is okay */\n\t\tstruct dentry *parent = req->r_dentry->d_parent;\n\t\tstruct inode *dir = parent->d_inode;\n\n\t\tif (dir->i_sb != mdsc->fsc->sb) {\n\t\t\t/* not this fs! */\n\t\t\tinode = req->r_dentry->d_inode;\n\t\t} else if (ceph_snap(dir) != CEPH_NOSNAP) {\n\t\t\t/* direct snapped/virtual snapdir requests\n\t\t\t * based on parent dir inode */\n\t\t\tstruct dentry *dn = get_nonsnap_parent(parent);\n\t\t\tinode = dn->d_inode;\n\t\t\tdout(\"__choose_mds using nonsnap parent %p\\n\", inode);\n\t\t} else {\n\t\t\t/* dentry target */\n\t\t\tinode = req->r_dentry->d_inode;\n\t\t\tif (!inode || mode == USE_AUTH_MDS) {\n\t\t\t\t/* dir + name */\n\t\t\t\tinode = dir;\n\t\t\t\thash = ceph_dentry_hash(dir, req->r_dentry);\n\t\t\t\tis_hash = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tdout(\"__choose_mds %p is_hash=%d (%d) mode %d\\n\", inode, (int)is_hash,\n\t     (int)hash, mode);\n\tif (!inode)\n\t\tgoto random;\n\tci = ceph_inode(inode);\n\n\tif (is_hash && S_ISDIR(inode->i_mode)) {\n\t\tstruct ceph_inode_frag frag;\n\t\tint found;\n\n\t\tceph_choose_frag(ci, hash, &frag, &found);\n\t\tif (found) {\n\t\t\tif (mode == USE_ANY_MDS && frag.ndist > 0) {\n\t\t\t\tu8 r;\n\n\t\t\t\t/* choose a random replica */\n\t\t\t\tget_random_bytes(&r, 1);\n\t\t\t\tr %= frag.ndist;\n\t\t\t\tmds = frag.dist[r];\n\t\t\t\tdout(\"choose_mds %p %llx.%llx \"\n\t\t\t\t     \"frag %u mds%d (%d/%d)\\n\",\n\t\t\t\t     inode, ceph_vinop(inode),\n\t\t\t\t     frag.frag, mds,\n\t\t\t\t     (int)r, frag.ndist);\n\t\t\t\tif (ceph_mdsmap_get_state(mdsc->mdsmap, mds) >=\n\t\t\t\t    CEPH_MDS_STATE_ACTIVE)\n\t\t\t\t\treturn mds;\n\t\t\t}\n\n\t\t\t/* since this file/dir wasn't known to be\n\t\t\t * replicated, then we want to look for the\n\t\t\t * authoritative mds. */\n\t\t\tmode = USE_AUTH_MDS;\n\t\t\tif (frag.mds >= 0) {\n\t\t\t\t/* choose auth mds */\n\t\t\t\tmds = frag.mds;\n\t\t\t\tdout(\"choose_mds %p %llx.%llx \"\n\t\t\t\t     \"frag %u mds%d (auth)\\n\",\n\t\t\t\t     inode, ceph_vinop(inode), frag.frag, mds);\n\t\t\t\tif (ceph_mdsmap_get_state(mdsc->mdsmap, mds) >=\n\t\t\t\t    CEPH_MDS_STATE_ACTIVE)\n\t\t\t\t\treturn mds;\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_lock(&ci->i_ceph_lock);\n\tcap = NULL;\n\tif (mode == USE_AUTH_MDS)\n\t\tcap = ci->i_auth_cap;\n\tif (!cap && !RB_EMPTY_ROOT(&ci->i_caps))\n\t\tcap = rb_entry(rb_first(&ci->i_caps), struct ceph_cap, ci_node);\n\tif (!cap) {\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tgoto random;\n\t}\n\tmds = cap->session->s_mds;\n\tdout(\"choose_mds %p %llx.%llx mds%d (%scap %p)\\n\",\n\t     inode, ceph_vinop(inode), mds,\n\t     cap == ci->i_auth_cap ? \"auth \" : \"\", cap);\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn mds;\n\nrandom:\n\tmds = ceph_mdsmap_get_random_mds(mdsc->mdsmap);\n\tdout(\"choose_mds chose random mds%d\\n\", mds);\n\treturn mds;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"choose_mds chose random mds%d\\n\"",
            "mds"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mdsmap_get_random_mds",
          "args": [
            "mdsc->mdsmap"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsmap_get_random_mds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mdsmap.c",
          "lines": "19-43",
          "snippet": "int ceph_mdsmap_get_random_mds(struct ceph_mdsmap *m)\n{\n\tint n = 0;\n\tint i;\n\n\t/* special case for one mds */\n\tif (1 == m->m_max_mds && m->m_info[0].state > 0)\n\t\treturn 0;\n\n\t/* count */\n\tfor (i = 0; i < m->m_max_mds; i++)\n\t\tif (m->m_info[i].state > 0)\n\t\t\tn++;\n\tif (n == 0)\n\t\treturn -1;\n\n\t/* pick */\n\tn = prandom_u32() % n;\n\ti = 0;\n\tfor (i = 0; n > 0; i++, n--)\n\t\twhile (m->m_info[i].state <= 0)\n\t\t\ti++;\n\n\treturn i;\n}",
          "includes": [
            "#include \"super.h\"",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/mdsmap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/random.h>",
            "#include <linux/err.h>",
            "#include <linux/bug.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"super.h\"\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/mdsmap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/err.h>\n#include <linux/bug.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_mdsmap_get_random_mds(struct ceph_mdsmap *m)\n{\n\tint n = 0;\n\tint i;\n\n\t/* special case for one mds */\n\tif (1 == m->m_max_mds && m->m_info[0].state > 0)\n\t\treturn 0;\n\n\t/* count */\n\tfor (i = 0; i < m->m_max_mds; i++)\n\t\tif (m->m_info[i].state > 0)\n\t\t\tn++;\n\tif (n == 0)\n\t\treturn -1;\n\n\t/* pick */\n\tn = prandom_u32() % n;\n\ti = 0;\n\tfor (i = 0; n > 0; i++, n--)\n\t\twhile (m->m_info[i].state <= 0)\n\t\t\ti++;\n\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"choose_mds %p %llx.%llx mds%d (%scap %p)\\n\"",
            "inode",
            "ceph_vinop(inode)",
            "mds",
            "cap == ci->i_auth_cap ? \"auth \" : \"\"",
            "cap"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vinop",
          "args": [
            "inode"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "rb_first(&ci->i_caps)",
            "structceph_cap",
            "ci_node"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&ci->i_caps"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_ROOT",
          "args": [
            "&ci->i_caps"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_mdsmap_get_state",
          "args": [
            "mdsc->mdsmap",
            "mds"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"choose_mds %p %llx.%llx \"\n\t\t\t\t     \"frag %u mds%d (auth)\\n\"",
            "inode",
            "ceph_vinop(inode)",
            "frag.frag",
            "mds"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vinop",
          "args": [
            "inode"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mdsmap_get_state",
          "args": [
            "mdsc->mdsmap",
            "mds"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"choose_mds %p %llx.%llx \"\n\t\t\t\t     \"frag %u mds%d (%d/%d)\\n\"",
            "inode",
            "ceph_vinop(inode)",
            "frag.frag",
            "mds",
            "(int)r",
            "frag.ndist"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vinop",
          "args": [
            "inode"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_random_bytes",
          "args": [
            "&r",
            "1"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_choose_frag",
          "args": [
            "ci",
            "hash",
            "&frag",
            "&found"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_choose_frag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "225-233",
          "snippet": "u32 ceph_choose_frag(struct ceph_inode_info *ci, u32 v,\n\t\t     struct ceph_inode_frag *pfrag, int *found)\n{\n\tu32 ret;\n\tmutex_lock(&ci->i_fragtree_mutex);\n\tret = __ceph_choose_frag(ci, v, pfrag, found);\n\tmutex_unlock(&ci->i_fragtree_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nu32 ceph_choose_frag(struct ceph_inode_info *ci, u32 v,\n\t\t     struct ceph_inode_frag *pfrag, int *found)\n{\n\tu32 ret;\n\tmutex_lock(&ci->i_fragtree_mutex);\n\tret = __ceph_choose_frag(ci, v, pfrag, found);\n\tmutex_unlock(&ci->i_fragtree_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"__choose_mds %p is_hash=%d (%d) mode %d\\n\"",
            "inode",
            "(int)is_hash",
            "(int)hash",
            "mode"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_dentry_hash",
          "args": [
            "dir",
            "req->r_dentry"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_dentry_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/dir.c",
          "lines": "1315-1328",
          "snippet": "unsigned ceph_dentry_hash(struct inode *dir, struct dentry *dn)\n{\n\tstruct ceph_inode_info *dci = ceph_inode(dir);\n\n\tswitch (dci->i_dir_layout.dl_dir_hash) {\n\tcase 0:\t/* for backward compat */\n\tcase CEPH_STR_HASH_LINUX:\n\t\treturn dn->d_name.hash;\n\n\tdefault:\n\t\treturn ceph_str_hash(dci->i_dir_layout.dl_dir_hash,\n\t\t\t\t     dn->d_name.name, dn->d_name.len);\n\t}\n}",
          "includes": [
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/fs_struct.h>\n#include <linux/spinlock.h>\n#include <linux/ceph/ceph_debug.h>\n\nunsigned ceph_dentry_hash(struct inode *dir, struct dentry *dn)\n{\n\tstruct ceph_inode_info *dci = ceph_inode(dir);\n\n\tswitch (dci->i_dir_layout.dl_dir_hash) {\n\tcase 0:\t/* for backward compat */\n\tcase CEPH_STR_HASH_LINUX:\n\t\treturn dn->d_name.hash;\n\n\tdefault:\n\t\treturn ceph_str_hash(dci->i_dir_layout.dl_dir_hash,\n\t\t\t\t     dn->d_name.name, dn->d_name.len);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"__choose_mds using nonsnap parent %p\\n\"",
            "inode"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_nonsnap_parent",
          "args": [
            "parent"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "get_nonsnap_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "674-685",
          "snippet": "static struct dentry *get_nonsnap_parent(struct dentry *dentry)\n{\n\t/*\n\t * we don't need to worry about protecting the d_parent access\n\t * here because we never renaming inside the snapped namespace\n\t * except to resplice to another snapdir, and either the old or new\n\t * result is a valid result.\n\t */\n\twhile (!IS_ROOT(dentry) && ceph_snap(dentry->d_inode) != CEPH_NOSNAP)\n\t\tdentry = dentry->d_parent;\n\treturn dentry;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct dentry *get_nonsnap_parent(struct dentry *dentry)\n{\n\t/*\n\t * we don't need to worry about protecting the d_parent access\n\t * here because we never renaming inside the snapped namespace\n\t * except to resplice to another snapdir, and either the old or new\n\t * result is a valid result.\n\t */\n\twhile (!IS_ROOT(dentry) && ceph_snap(dentry->d_inode) != CEPH_NOSNAP)\n\t\tdentry = dentry->d_parent;\n\treturn dentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_snap",
          "args": [
            "dir"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_snap_op_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/strings.c",
          "lines": "115-124",
          "snippet": "const char *ceph_snap_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_SNAP_OP_UPDATE: return \"update\";\n\tcase CEPH_SNAP_OP_CREATE: return \"create\";\n\tcase CEPH_SNAP_OP_DESTROY: return \"destroy\";\n\tcase CEPH_SNAP_OP_SPLIT: return \"split\";\n\t}\n\treturn \"???\";\n}",
          "includes": [
            "#include <linux/ceph/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/types.h>\n#include <linux/module.h>\n\nconst char *ceph_snap_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_SNAP_OP_UPDATE: return \"update\";\n\tcase CEPH_SNAP_OP_CREATE: return \"create\";\n\tcase CEPH_SNAP_OP_DESTROY: return \"destroy\";\n\tcase CEPH_SNAP_OP_SPLIT: return \"split\";\n\t}\n\treturn \"???\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"choose_mds using resend_mds mds%d\\n\"",
            "req->r_resend_mds"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mdsmap_get_state",
          "args": [
            "mdsc->mdsmap",
            "req->r_resend_mds"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__have_session",
          "args": [
            "mdsc",
            "req->r_resend_mds"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "__have_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "404-409",
          "snippet": "static bool __have_session(struct ceph_mds_client *mdsc, int mds)\n{\n\tif (mds >= mdsc->max_sessions)\n\t\treturn false;\n\treturn mdsc->sessions[mds];\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic bool __have_session(struct ceph_mds_client *mdsc, int mds)\n{\n\tif (mds >= mdsc->max_sessions)\n\t\treturn false;\n\treturn mdsc->sessions[mds];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __choose_mds(struct ceph_mds_client *mdsc,\n\t\t\tstruct ceph_mds_request *req)\n{\n\tstruct inode *inode;\n\tstruct ceph_inode_info *ci;\n\tstruct ceph_cap *cap;\n\tint mode = req->r_direct_mode;\n\tint mds = -1;\n\tu32 hash = req->r_direct_hash;\n\tbool is_hash = req->r_direct_is_hash;\n\n\t/*\n\t * is there a specific mds we should try?  ignore hint if we have\n\t * no session and the mds is not up (active or recovering).\n\t */\n\tif (req->r_resend_mds >= 0 &&\n\t    (__have_session(mdsc, req->r_resend_mds) ||\n\t     ceph_mdsmap_get_state(mdsc->mdsmap, req->r_resend_mds) > 0)) {\n\t\tdout(\"choose_mds using resend_mds mds%d\\n\",\n\t\t     req->r_resend_mds);\n\t\treturn req->r_resend_mds;\n\t}\n\n\tif (mode == USE_RANDOM_MDS)\n\t\tgoto random;\n\n\tinode = NULL;\n\tif (req->r_inode) {\n\t\tinode = req->r_inode;\n\t} else if (req->r_dentry) {\n\t\t/* ignore race with rename; old or new d_parent is okay */\n\t\tstruct dentry *parent = req->r_dentry->d_parent;\n\t\tstruct inode *dir = parent->d_inode;\n\n\t\tif (dir->i_sb != mdsc->fsc->sb) {\n\t\t\t/* not this fs! */\n\t\t\tinode = req->r_dentry->d_inode;\n\t\t} else if (ceph_snap(dir) != CEPH_NOSNAP) {\n\t\t\t/* direct snapped/virtual snapdir requests\n\t\t\t * based on parent dir inode */\n\t\t\tstruct dentry *dn = get_nonsnap_parent(parent);\n\t\t\tinode = dn->d_inode;\n\t\t\tdout(\"__choose_mds using nonsnap parent %p\\n\", inode);\n\t\t} else {\n\t\t\t/* dentry target */\n\t\t\tinode = req->r_dentry->d_inode;\n\t\t\tif (!inode || mode == USE_AUTH_MDS) {\n\t\t\t\t/* dir + name */\n\t\t\t\tinode = dir;\n\t\t\t\thash = ceph_dentry_hash(dir, req->r_dentry);\n\t\t\t\tis_hash = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tdout(\"__choose_mds %p is_hash=%d (%d) mode %d\\n\", inode, (int)is_hash,\n\t     (int)hash, mode);\n\tif (!inode)\n\t\tgoto random;\n\tci = ceph_inode(inode);\n\n\tif (is_hash && S_ISDIR(inode->i_mode)) {\n\t\tstruct ceph_inode_frag frag;\n\t\tint found;\n\n\t\tceph_choose_frag(ci, hash, &frag, &found);\n\t\tif (found) {\n\t\t\tif (mode == USE_ANY_MDS && frag.ndist > 0) {\n\t\t\t\tu8 r;\n\n\t\t\t\t/* choose a random replica */\n\t\t\t\tget_random_bytes(&r, 1);\n\t\t\t\tr %= frag.ndist;\n\t\t\t\tmds = frag.dist[r];\n\t\t\t\tdout(\"choose_mds %p %llx.%llx \"\n\t\t\t\t     \"frag %u mds%d (%d/%d)\\n\",\n\t\t\t\t     inode, ceph_vinop(inode),\n\t\t\t\t     frag.frag, mds,\n\t\t\t\t     (int)r, frag.ndist);\n\t\t\t\tif (ceph_mdsmap_get_state(mdsc->mdsmap, mds) >=\n\t\t\t\t    CEPH_MDS_STATE_ACTIVE)\n\t\t\t\t\treturn mds;\n\t\t\t}\n\n\t\t\t/* since this file/dir wasn't known to be\n\t\t\t * replicated, then we want to look for the\n\t\t\t * authoritative mds. */\n\t\t\tmode = USE_AUTH_MDS;\n\t\t\tif (frag.mds >= 0) {\n\t\t\t\t/* choose auth mds */\n\t\t\t\tmds = frag.mds;\n\t\t\t\tdout(\"choose_mds %p %llx.%llx \"\n\t\t\t\t     \"frag %u mds%d (auth)\\n\",\n\t\t\t\t     inode, ceph_vinop(inode), frag.frag, mds);\n\t\t\t\tif (ceph_mdsmap_get_state(mdsc->mdsmap, mds) >=\n\t\t\t\t    CEPH_MDS_STATE_ACTIVE)\n\t\t\t\t\treturn mds;\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_lock(&ci->i_ceph_lock);\n\tcap = NULL;\n\tif (mode == USE_AUTH_MDS)\n\t\tcap = ci->i_auth_cap;\n\tif (!cap && !RB_EMPTY_ROOT(&ci->i_caps))\n\t\tcap = rb_entry(rb_first(&ci->i_caps), struct ceph_cap, ci_node);\n\tif (!cap) {\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tgoto random;\n\t}\n\tmds = cap->session->s_mds;\n\tdout(\"choose_mds %p %llx.%llx mds%d (%scap %p)\\n\",\n\t     inode, ceph_vinop(inode), mds,\n\t     cap == ci->i_auth_cap ? \"auth \" : \"\", cap);\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn mds;\n\nrandom:\n\tmds = ceph_mdsmap_get_random_mds(mdsc->mdsmap);\n\tdout(\"choose_mds chose random mds%d\\n\", mds);\n\treturn mds;\n}"
  },
  {
    "function_name": "get_nonsnap_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "674-685",
    "snippet": "static struct dentry *get_nonsnap_parent(struct dentry *dentry)\n{\n\t/*\n\t * we don't need to worry about protecting the d_parent access\n\t * here because we never renaming inside the snapped namespace\n\t * except to resplice to another snapdir, and either the old or new\n\t * result is a valid result.\n\t */\n\twhile (!IS_ROOT(dentry) && ceph_snap(dentry->d_inode) != CEPH_NOSNAP)\n\t\tdentry = dentry->d_parent;\n\treturn dentry;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_snap",
          "args": [
            "dentry->d_inode"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_snap_op_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/strings.c",
          "lines": "115-124",
          "snippet": "const char *ceph_snap_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_SNAP_OP_UPDATE: return \"update\";\n\tcase CEPH_SNAP_OP_CREATE: return \"create\";\n\tcase CEPH_SNAP_OP_DESTROY: return \"destroy\";\n\tcase CEPH_SNAP_OP_SPLIT: return \"split\";\n\t}\n\treturn \"???\";\n}",
          "includes": [
            "#include <linux/ceph/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/types.h>\n#include <linux/module.h>\n\nconst char *ceph_snap_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_SNAP_OP_UPDATE: return \"update\";\n\tcase CEPH_SNAP_OP_CREATE: return \"create\";\n\tcase CEPH_SNAP_OP_DESTROY: return \"destroy\";\n\tcase CEPH_SNAP_OP_SPLIT: return \"split\";\n\t}\n\treturn \"???\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "dentry"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct dentry *get_nonsnap_parent(struct dentry *dentry)\n{\n\t/*\n\t * we don't need to worry about protecting the d_parent access\n\t * here because we never renaming inside the snapped namespace\n\t * except to resplice to another snapdir, and either the old or new\n\t * result is a valid result.\n\t */\n\twhile (!IS_ROOT(dentry) && ceph_snap(dentry->d_inode) != CEPH_NOSNAP)\n\t\tdentry = dentry->d_parent;\n\treturn dentry;\n}"
  },
  {
    "function_name": "__unregister_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "643-664",
    "snippet": "static void __unregister_request(struct ceph_mds_client *mdsc,\n\t\t\t\t struct ceph_mds_request *req)\n{\n\tdout(\"__unregister_request %p tid %lld\\n\", req, req->r_tid);\n\trb_erase(&req->r_node, &mdsc->request_tree);\n\tRB_CLEAR_NODE(&req->r_node);\n\n\tif (req->r_unsafe_dir) {\n\t\tstruct ceph_inode_info *ci = ceph_inode(req->r_unsafe_dir);\n\n\t\tspin_lock(&ci->i_unsafe_lock);\n\t\tlist_del_init(&req->r_unsafe_dir_item);\n\t\tspin_unlock(&ci->i_unsafe_lock);\n\n\t\tiput(req->r_unsafe_dir);\n\t\treq->r_unsafe_dir = NULL;\n\t}\n\n\tcomplete_all(&req->r_safe_completion);\n\n\tceph_mdsc_put_request(req);\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_mdsc_put_request",
          "args": [
            "req"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_put_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.h",
          "lines": "377-380",
          "snippet": "static inline void ceph_mdsc_put_request(struct ceph_mds_request *req)\n{\n\tkref_put(&req->r_kref, ceph_mdsc_release_request);\n}",
          "includes": [
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mdsmap.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/kref.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/auth.h>\n#include <linux/ceph/mdsmap.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/types.h>\n#include <linux/spinlock.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/kref.h>\n#include <linux/completion.h>\n\nstatic inline void ceph_mdsc_put_request(struct ceph_mds_request *req)\n{\n\tkref_put(&req->r_kref, ceph_mdsc_release_request);\n}"
        }
      },
      {
        "call_info": {
          "callee": "complete_all",
          "args": [
            "&req->r_safe_completion"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "req->r_unsafe_dir"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_unsafe_lock"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&req->r_unsafe_dir_item"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_unsafe_lock"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "req->r_unsafe_dir"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RB_CLEAR_NODE",
          "args": [
            "&req->r_node"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&req->r_node",
            "&mdsc->request_tree"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"__unregister_request %p tid %lld\\n\"",
            "req",
            "req->r_tid"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __unregister_request(struct ceph_mds_client *mdsc,\n\t\t\t\t struct ceph_mds_request *req)\n{\n\tdout(\"__unregister_request %p tid %lld\\n\", req, req->r_tid);\n\trb_erase(&req->r_node, &mdsc->request_tree);\n\tRB_CLEAR_NODE(&req->r_node);\n\n\tif (req->r_unsafe_dir) {\n\t\tstruct ceph_inode_info *ci = ceph_inode(req->r_unsafe_dir);\n\n\t\tspin_lock(&ci->i_unsafe_lock);\n\t\tlist_del_init(&req->r_unsafe_dir_item);\n\t\tspin_unlock(&ci->i_unsafe_lock);\n\n\t\tiput(req->r_unsafe_dir);\n\t\treq->r_unsafe_dir = NULL;\n\t}\n\n\tcomplete_all(&req->r_safe_completion);\n\n\tceph_mdsc_put_request(req);\n}"
  },
  {
    "function_name": "__register_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "617-641",
    "snippet": "static void __register_request(struct ceph_mds_client *mdsc,\n\t\t\t       struct ceph_mds_request *req,\n\t\t\t       struct inode *dir)\n{\n\treq->r_tid = ++mdsc->last_tid;\n\tif (req->r_num_caps)\n\t\tceph_reserve_caps(mdsc, &req->r_caps_reservation,\n\t\t\t\t  req->r_num_caps);\n\tdout(\"__register_request %p tid %lld\\n\", req, req->r_tid);\n\tceph_mdsc_get_request(req);\n\t__insert_request(mdsc, req);\n\n\treq->r_uid = current_fsuid();\n\treq->r_gid = current_fsgid();\n\n\tif (dir) {\n\t\tstruct ceph_inode_info *ci = ceph_inode(dir);\n\n\t\tihold(dir);\n\t\tspin_lock(&ci->i_unsafe_lock);\n\t\treq->r_unsafe_dir = dir;\n\t\tlist_add_tail(&req->r_unsafe_dir_item, &ci->i_unsafe_dirops);\n\t\tspin_unlock(&ci->i_unsafe_lock);\n\t}\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_unsafe_lock"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&req->r_unsafe_dir_item",
            "&ci->i_unsafe_dirops"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_unsafe_lock"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "dir"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "dir"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fsgid",
          "args": [],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__insert_request",
          "args": [
            "mdsc",
            "req"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "__insert_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "589-609",
          "snippet": "static void __insert_request(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_mds_request *new)\n{\n\tstruct rb_node **p = &mdsc->request_tree.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct ceph_mds_request *req = NULL;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\treq = rb_entry(parent, struct ceph_mds_request, r_node);\n\t\tif (new->r_tid < req->r_tid)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (new->r_tid > req->r_tid)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tBUG();\n\t}\n\n\trb_link_node(&new->r_node, parent, p);\n\trb_insert_color(&new->r_node, &mdsc->request_tree);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __insert_request(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_mds_request *new)\n{\n\tstruct rb_node **p = &mdsc->request_tree.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct ceph_mds_request *req = NULL;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\treq = rb_entry(parent, struct ceph_mds_request, r_node);\n\t\tif (new->r_tid < req->r_tid)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (new->r_tid > req->r_tid)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tBUG();\n\t}\n\n\trb_link_node(&new->r_node, parent, p);\n\trb_insert_color(&new->r_node, &mdsc->request_tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_get_request",
          "args": [
            "req"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_get_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.h",
          "lines": "372-375",
          "snippet": "static inline void ceph_mdsc_get_request(struct ceph_mds_request *req)\n{\n\tkref_get(&req->r_kref);\n}",
          "includes": [
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mdsmap.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/kref.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/auth.h>\n#include <linux/ceph/mdsmap.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/types.h>\n#include <linux/spinlock.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/kref.h>\n#include <linux/completion.h>\n\nstatic inline void ceph_mdsc_get_request(struct ceph_mds_request *req)\n{\n\tkref_get(&req->r_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"__register_request %p tid %lld\\n\"",
            "req",
            "req->r_tid"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_reserve_caps",
          "args": [
            "mdsc",
            "&req->r_caps_reservation",
            "req->r_num_caps"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_reserve_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "151-201",
          "snippet": "void ceph_reserve_caps(struct ceph_mds_client *mdsc,\n\t\t      struct ceph_cap_reservation *ctx, int need)\n{\n\tint i;\n\tstruct ceph_cap *cap;\n\tint have;\n\tint alloc = 0;\n\tLIST_HEAD(newcaps);\n\n\tdout(\"reserve caps ctx=%p need=%d\\n\", ctx, need);\n\n\t/* first reserve any caps that are already allocated */\n\tspin_lock(&mdsc->caps_list_lock);\n\tif (mdsc->caps_avail_count >= need)\n\t\thave = need;\n\telse\n\t\thave = mdsc->caps_avail_count;\n\tmdsc->caps_avail_count -= have;\n\tmdsc->caps_reserve_count += have;\n\tBUG_ON(mdsc->caps_total_count != mdsc->caps_use_count +\n\t\t\t\t\t mdsc->caps_reserve_count +\n\t\t\t\t\t mdsc->caps_avail_count);\n\tspin_unlock(&mdsc->caps_list_lock);\n\n\tfor (i = have; i < need; i++) {\n\t\tcap = kmem_cache_alloc(ceph_cap_cachep, GFP_NOFS);\n\t\tif (!cap)\n\t\t\tbreak;\n\t\tlist_add(&cap->caps_item, &newcaps);\n\t\talloc++;\n\t}\n\t/* we didn't manage to reserve as much as we needed */\n\tif (have + alloc != need)\n\t\tpr_warn(\"reserve caps ctx=%p ENOMEM need=%d got=%d\\n\",\n\t\t\tctx, need, have + alloc);\n\n\tspin_lock(&mdsc->caps_list_lock);\n\tmdsc->caps_total_count += alloc;\n\tmdsc->caps_reserve_count += alloc;\n\tlist_splice(&newcaps, &mdsc->caps_list);\n\n\tBUG_ON(mdsc->caps_total_count != mdsc->caps_use_count +\n\t\t\t\t\t mdsc->caps_reserve_count +\n\t\t\t\t\t mdsc->caps_avail_count);\n\tspin_unlock(&mdsc->caps_list_lock);\n\n\tctx->count = need;\n\tdout(\"reserve caps ctx=%p %d = %d used + %d resv + %d avail\\n\",\n\t     ctx, mdsc->caps_total_count, mdsc->caps_use_count,\n\t     mdsc->caps_reserve_count, mdsc->caps_avail_count);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_reserve_caps(struct ceph_mds_client *mdsc,\n\t\t      struct ceph_cap_reservation *ctx, int need)\n{\n\tint i;\n\tstruct ceph_cap *cap;\n\tint have;\n\tint alloc = 0;\n\tLIST_HEAD(newcaps);\n\n\tdout(\"reserve caps ctx=%p need=%d\\n\", ctx, need);\n\n\t/* first reserve any caps that are already allocated */\n\tspin_lock(&mdsc->caps_list_lock);\n\tif (mdsc->caps_avail_count >= need)\n\t\thave = need;\n\telse\n\t\thave = mdsc->caps_avail_count;\n\tmdsc->caps_avail_count -= have;\n\tmdsc->caps_reserve_count += have;\n\tBUG_ON(mdsc->caps_total_count != mdsc->caps_use_count +\n\t\t\t\t\t mdsc->caps_reserve_count +\n\t\t\t\t\t mdsc->caps_avail_count);\n\tspin_unlock(&mdsc->caps_list_lock);\n\n\tfor (i = have; i < need; i++) {\n\t\tcap = kmem_cache_alloc(ceph_cap_cachep, GFP_NOFS);\n\t\tif (!cap)\n\t\t\tbreak;\n\t\tlist_add(&cap->caps_item, &newcaps);\n\t\talloc++;\n\t}\n\t/* we didn't manage to reserve as much as we needed */\n\tif (have + alloc != need)\n\t\tpr_warn(\"reserve caps ctx=%p ENOMEM need=%d got=%d\\n\",\n\t\t\tctx, need, have + alloc);\n\n\tspin_lock(&mdsc->caps_list_lock);\n\tmdsc->caps_total_count += alloc;\n\tmdsc->caps_reserve_count += alloc;\n\tlist_splice(&newcaps, &mdsc->caps_list);\n\n\tBUG_ON(mdsc->caps_total_count != mdsc->caps_use_count +\n\t\t\t\t\t mdsc->caps_reserve_count +\n\t\t\t\t\t mdsc->caps_avail_count);\n\tspin_unlock(&mdsc->caps_list_lock);\n\n\tctx->count = need;\n\tdout(\"reserve caps ctx=%p %d = %d used + %d resv + %d avail\\n\",\n\t     ctx, mdsc->caps_total_count, mdsc->caps_use_count,\n\t     mdsc->caps_reserve_count, mdsc->caps_avail_count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __register_request(struct ceph_mds_client *mdsc,\n\t\t\t       struct ceph_mds_request *req,\n\t\t\t       struct inode *dir)\n{\n\treq->r_tid = ++mdsc->last_tid;\n\tif (req->r_num_caps)\n\t\tceph_reserve_caps(mdsc, &req->r_caps_reservation,\n\t\t\t\t  req->r_num_caps);\n\tdout(\"__register_request %p tid %lld\\n\", req, req->r_tid);\n\tceph_mdsc_get_request(req);\n\t__insert_request(mdsc, req);\n\n\treq->r_uid = current_fsuid();\n\treq->r_gid = current_fsgid();\n\n\tif (dir) {\n\t\tstruct ceph_inode_info *ci = ceph_inode(dir);\n\n\t\tihold(dir);\n\t\tspin_lock(&ci->i_unsafe_lock);\n\t\treq->r_unsafe_dir = dir;\n\t\tlist_add_tail(&req->r_unsafe_dir_item, &ci->i_unsafe_dirops);\n\t\tspin_unlock(&ci->i_unsafe_lock);\n\t}\n}"
  },
  {
    "function_name": "__insert_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "589-609",
    "snippet": "static void __insert_request(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_mds_request *new)\n{\n\tstruct rb_node **p = &mdsc->request_tree.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct ceph_mds_request *req = NULL;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\treq = rb_entry(parent, struct ceph_mds_request, r_node);\n\t\tif (new->r_tid < req->r_tid)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (new->r_tid > req->r_tid)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tBUG();\n\t}\n\n\trb_link_node(&new->r_node, parent, p);\n\trb_insert_color(&new->r_node, &mdsc->request_tree);\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&new->r_node",
            "&mdsc->request_tree"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&new->r_node",
            "parent",
            "p"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structceph_mds_request",
            "r_node"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __insert_request(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_mds_request *new)\n{\n\tstruct rb_node **p = &mdsc->request_tree.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct ceph_mds_request *req = NULL;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\treq = rb_entry(parent, struct ceph_mds_request, r_node);\n\t\tif (new->r_tid < req->r_tid)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (new->r_tid > req->r_tid)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tBUG();\n\t}\n\n\trb_link_node(&new->r_node, parent, p);\n\trb_insert_color(&new->r_node, &mdsc->request_tree);\n}"
  },
  {
    "function_name": "__lookup_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "569-587",
    "snippet": "static struct ceph_mds_request *__lookup_request(struct ceph_mds_client *mdsc,\n\t\t\t\t\t     u64 tid)\n{\n\tstruct ceph_mds_request *req;\n\tstruct rb_node *n = mdsc->request_tree.rb_node;\n\n\twhile (n) {\n\t\treq = rb_entry(n, struct ceph_mds_request, r_node);\n\t\tif (tid < req->r_tid)\n\t\t\tn = n->rb_left;\n\t\telse if (tid > req->r_tid)\n\t\t\tn = n->rb_right;\n\t\telse {\n\t\t\tceph_mdsc_get_request(req);\n\t\t\treturn req;\n\t\t}\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_mdsc_get_request",
          "args": [
            "req"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_get_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.h",
          "lines": "372-375",
          "snippet": "static inline void ceph_mdsc_get_request(struct ceph_mds_request *req)\n{\n\tkref_get(&req->r_kref);\n}",
          "includes": [
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mdsmap.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/kref.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/auth.h>\n#include <linux/ceph/mdsmap.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/types.h>\n#include <linux/spinlock.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/kref.h>\n#include <linux/completion.h>\n\nstatic inline void ceph_mdsc_get_request(struct ceph_mds_request *req)\n{\n\tkref_get(&req->r_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structceph_mds_request",
            "r_node"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_mds_request *__lookup_request(struct ceph_mds_client *mdsc,\n\t\t\t\t\t     u64 tid)\n{\n\tstruct ceph_mds_request *req;\n\tstruct rb_node *n = mdsc->request_tree.rb_node;\n\n\twhile (n) {\n\t\treq = rb_entry(n, struct ceph_mds_request, r_node);\n\t\tif (tid < req->r_tid)\n\t\t\tn = n->rb_left;\n\t\telse if (tid > req->r_tid)\n\t\t\tn = n->rb_right;\n\t\telse {\n\t\t\tceph_mdsc_get_request(req);\n\t\t\treturn req;\n\t\t}\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "ceph_mdsc_release_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "523-562",
    "snippet": "void ceph_mdsc_release_request(struct kref *kref)\n{\n\tstruct ceph_mds_request *req = container_of(kref,\n\t\t\t\t\t\t    struct ceph_mds_request,\n\t\t\t\t\t\t    r_kref);\n\tdestroy_reply_info(&req->r_reply_info);\n\tif (req->r_request)\n\t\tceph_msg_put(req->r_request);\n\tif (req->r_reply)\n\t\tceph_msg_put(req->r_reply);\n\tif (req->r_inode) {\n\t\tceph_put_cap_refs(ceph_inode(req->r_inode), CEPH_CAP_PIN);\n\t\tiput(req->r_inode);\n\t}\n\tif (req->r_locked_dir)\n\t\tceph_put_cap_refs(ceph_inode(req->r_locked_dir), CEPH_CAP_PIN);\n\tiput(req->r_target_inode);\n\tif (req->r_dentry)\n\t\tdput(req->r_dentry);\n\tif (req->r_old_dentry)\n\t\tdput(req->r_old_dentry);\n\tif (req->r_old_dentry_dir) {\n\t\t/*\n\t\t * track (and drop pins for) r_old_dentry_dir\n\t\t * separately, since r_old_dentry's d_parent may have\n\t\t * changed between the dir mutex being dropped and\n\t\t * this request being freed.\n\t\t */\n\t\tceph_put_cap_refs(ceph_inode(req->r_old_dentry_dir),\n\t\t\t\t  CEPH_CAP_PIN);\n\t\tiput(req->r_old_dentry_dir);\n\t}\n\tkfree(req->r_path1);\n\tkfree(req->r_path2);\n\tif (req->r_pagelist)\n\t\tceph_pagelist_release(req->r_pagelist);\n\tput_request_session(req);\n\tceph_unreserve_caps(req->r_mdsc, &req->r_caps_reservation);\n\tkfree(req);\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "req"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_unreserve_caps",
          "args": [
            "req->r_mdsc",
            "&req->r_caps_reservation"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_unreserve_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "203-222",
          "snippet": "int ceph_unreserve_caps(struct ceph_mds_client *mdsc,\n\t\t\tstruct ceph_cap_reservation *ctx)\n{\n\tdout(\"unreserve caps ctx=%p count=%d\\n\", ctx, ctx->count);\n\tif (ctx->count) {\n\t\tspin_lock(&mdsc->caps_list_lock);\n\t\tBUG_ON(mdsc->caps_reserve_count < ctx->count);\n\t\tmdsc->caps_reserve_count -= ctx->count;\n\t\tmdsc->caps_avail_count += ctx->count;\n\t\tctx->count = 0;\n\t\tdout(\"unreserve caps %d = %d used + %d resv + %d avail\\n\",\n\t\t     mdsc->caps_total_count, mdsc->caps_use_count,\n\t\t     mdsc->caps_reserve_count, mdsc->caps_avail_count);\n\t\tBUG_ON(mdsc->caps_total_count != mdsc->caps_use_count +\n\t\t\t\t\t\t mdsc->caps_reserve_count +\n\t\t\t\t\t\t mdsc->caps_avail_count);\n\t\tspin_unlock(&mdsc->caps_list_lock);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_unreserve_caps(struct ceph_mds_client *mdsc,\n\t\t\tstruct ceph_cap_reservation *ctx)\n{\n\tdout(\"unreserve caps ctx=%p count=%d\\n\", ctx, ctx->count);\n\tif (ctx->count) {\n\t\tspin_lock(&mdsc->caps_list_lock);\n\t\tBUG_ON(mdsc->caps_reserve_count < ctx->count);\n\t\tmdsc->caps_reserve_count -= ctx->count;\n\t\tmdsc->caps_avail_count += ctx->count;\n\t\tctx->count = 0;\n\t\tdout(\"unreserve caps %d = %d used + %d resv + %d avail\\n\",\n\t\t     mdsc->caps_total_count, mdsc->caps_use_count,\n\t\t     mdsc->caps_reserve_count, mdsc->caps_avail_count);\n\t\tBUG_ON(mdsc->caps_total_count != mdsc->caps_use_count +\n\t\t\t\t\t\t mdsc->caps_reserve_count +\n\t\t\t\t\t\t mdsc->caps_avail_count);\n\t\tspin_unlock(&mdsc->caps_list_lock);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_request_session",
          "args": [
            "req"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "put_request_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "515-521",
          "snippet": "static void put_request_session(struct ceph_mds_request *req)\n{\n\tif (req->r_session) {\n\t\tceph_put_mds_session(req->r_session);\n\t\treq->r_session = NULL;\n\t}\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void put_request_session(struct ceph_mds_request *req)\n{\n\tif (req->r_session) {\n\t\tceph_put_mds_session(req->r_session);\n\t\treq->r_session = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_pagelist_release",
          "args": [
            "req->r_pagelist"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "req->r_path2"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "req->r_path1"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "req->r_old_dentry_dir"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_put_cap_refs",
          "args": [
            "ceph_inode(req->r_old_dentry_dir)",
            "CEPH_CAP_PIN"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_put_cap_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "2274-2326",
          "snippet": "void ceph_put_cap_refs(struct ceph_inode_info *ci, int had)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint last = 0, put = 0, flushsnaps = 0, wake = 0;\n\tstruct ceph_cap_snap *capsnap;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (had & CEPH_CAP_PIN)\n\t\t--ci->i_pin_ref;\n\tif (had & CEPH_CAP_FILE_RD)\n\t\tif (--ci->i_rd_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_CACHE)\n\t\tif (--ci->i_rdcache_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_BUFFER) {\n\t\tif (--ci->i_wb_ref == 0) {\n\t\t\tlast++;\n\t\t\tput++;\n\t\t}\n\t\tdout(\"put_cap_refs %p wb %d -> %d (?)\\n\",\n\t\t     inode, ci->i_wb_ref+1, ci->i_wb_ref);\n\t}\n\tif (had & CEPH_CAP_FILE_WR)\n\t\tif (--ci->i_wr_ref == 0) {\n\t\t\tlast++;\n\t\t\tif (!list_empty(&ci->i_cap_snaps)) {\n\t\t\t\tcapsnap = list_first_entry(&ci->i_cap_snaps,\n\t\t\t\t\t\t     struct ceph_cap_snap,\n\t\t\t\t\t\t     ci_item);\n\t\t\t\tif (capsnap->writing) {\n\t\t\t\t\tcapsnap->writing = 0;\n\t\t\t\t\tflushsnaps =\n\t\t\t\t\t\t__ceph_finish_cap_snap(ci,\n\t\t\t\t\t\t\t\t       capsnap);\n\t\t\t\t\twake = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tdout(\"put_cap_refs %p had %s%s%s\\n\", inode, ceph_cap_string(had),\n\t     last ? \" last\" : \"\", put ? \" put\" : \"\");\n\n\tif (last && !flushsnaps)\n\t\tceph_check_caps(ci, 0, NULL);\n\telse if (flushsnaps)\n\t\tceph_flush_snaps(ci);\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\tif (put)\n\t\tiput(inode);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_put_cap_refs(struct ceph_inode_info *ci, int had)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint last = 0, put = 0, flushsnaps = 0, wake = 0;\n\tstruct ceph_cap_snap *capsnap;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (had & CEPH_CAP_PIN)\n\t\t--ci->i_pin_ref;\n\tif (had & CEPH_CAP_FILE_RD)\n\t\tif (--ci->i_rd_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_CACHE)\n\t\tif (--ci->i_rdcache_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_BUFFER) {\n\t\tif (--ci->i_wb_ref == 0) {\n\t\t\tlast++;\n\t\t\tput++;\n\t\t}\n\t\tdout(\"put_cap_refs %p wb %d -> %d (?)\\n\",\n\t\t     inode, ci->i_wb_ref+1, ci->i_wb_ref);\n\t}\n\tif (had & CEPH_CAP_FILE_WR)\n\t\tif (--ci->i_wr_ref == 0) {\n\t\t\tlast++;\n\t\t\tif (!list_empty(&ci->i_cap_snaps)) {\n\t\t\t\tcapsnap = list_first_entry(&ci->i_cap_snaps,\n\t\t\t\t\t\t     struct ceph_cap_snap,\n\t\t\t\t\t\t     ci_item);\n\t\t\t\tif (capsnap->writing) {\n\t\t\t\t\tcapsnap->writing = 0;\n\t\t\t\t\tflushsnaps =\n\t\t\t\t\t\t__ceph_finish_cap_snap(ci,\n\t\t\t\t\t\t\t\t       capsnap);\n\t\t\t\t\twake = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tdout(\"put_cap_refs %p had %s%s%s\\n\", inode, ceph_cap_string(had),\n\t     last ? \" last\" : \"\", put ? \" put\" : \"\");\n\n\tif (last && !flushsnaps)\n\t\tceph_check_caps(ci, 0, NULL);\n\telse if (flushsnaps)\n\t\tceph_flush_snaps(ci);\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\tif (put)\n\t\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "req->r_old_dentry_dir"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "req->r_old_dentry"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_msg_put",
          "args": [
            "req->r_reply"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_msg_put",
          "args": [
            "req->r_request"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_reply_info",
          "args": [
            "&req->r_reply_info"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_reply_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "337-342",
          "snippet": "static void destroy_reply_info(struct ceph_mds_reply_info_parsed *info)\n{\n\tif (!info->dir_in)\n\t\treturn;\n\tfree_pages((unsigned long)info->dir_in, get_order(info->dir_buf_size));\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void destroy_reply_info(struct ceph_mds_reply_info_parsed *info)\n{\n\tif (!info->dir_in)\n\t\treturn;\n\tfree_pages((unsigned long)info->dir_in, get_order(info->dir_buf_size));\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kref",
            "structceph_mds_request",
            "r_kref"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_mdsc_release_request(struct kref *kref)\n{\n\tstruct ceph_mds_request *req = container_of(kref,\n\t\t\t\t\t\t    struct ceph_mds_request,\n\t\t\t\t\t\t    r_kref);\n\tdestroy_reply_info(&req->r_reply_info);\n\tif (req->r_request)\n\t\tceph_msg_put(req->r_request);\n\tif (req->r_reply)\n\t\tceph_msg_put(req->r_reply);\n\tif (req->r_inode) {\n\t\tceph_put_cap_refs(ceph_inode(req->r_inode), CEPH_CAP_PIN);\n\t\tiput(req->r_inode);\n\t}\n\tif (req->r_locked_dir)\n\t\tceph_put_cap_refs(ceph_inode(req->r_locked_dir), CEPH_CAP_PIN);\n\tiput(req->r_target_inode);\n\tif (req->r_dentry)\n\t\tdput(req->r_dentry);\n\tif (req->r_old_dentry)\n\t\tdput(req->r_old_dentry);\n\tif (req->r_old_dentry_dir) {\n\t\t/*\n\t\t * track (and drop pins for) r_old_dentry_dir\n\t\t * separately, since r_old_dentry's d_parent may have\n\t\t * changed between the dir mutex being dropped and\n\t\t * this request being freed.\n\t\t */\n\t\tceph_put_cap_refs(ceph_inode(req->r_old_dentry_dir),\n\t\t\t\t  CEPH_CAP_PIN);\n\t\tiput(req->r_old_dentry_dir);\n\t}\n\tkfree(req->r_path1);\n\tkfree(req->r_path2);\n\tif (req->r_pagelist)\n\t\tceph_pagelist_release(req->r_pagelist);\n\tput_request_session(req);\n\tceph_unreserve_caps(req->r_mdsc, &req->r_caps_reservation);\n\tkfree(req);\n}"
  },
  {
    "function_name": "put_request_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "515-521",
    "snippet": "static void put_request_session(struct ceph_mds_request *req)\n{\n\tif (req->r_session) {\n\t\tceph_put_mds_session(req->r_session);\n\t\treq->r_session = NULL;\n\t}\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_put_mds_session",
          "args": [
            "req->r_session"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_put_mds_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "374-385",
          "snippet": "void ceph_put_mds_session(struct ceph_mds_session *s)\n{\n\tdout(\"mdsc put_session %p %d -> %d\\n\", s,\n\t     atomic_read(&s->s_ref), atomic_read(&s->s_ref)-1);\n\tif (atomic_dec_and_test(&s->s_ref)) {\n\t\tif (s->s_auth.authorizer)\n\t\t\tceph_auth_destroy_authorizer(\n\t\t\t\ts->s_mdsc->fsc->client->monc.auth,\n\t\t\t\ts->s_auth.authorizer);\n\t\tkfree(s);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_put_mds_session(struct ceph_mds_session *s)\n{\n\tdout(\"mdsc put_session %p %d -> %d\\n\", s,\n\t     atomic_read(&s->s_ref), atomic_read(&s->s_ref)-1);\n\tif (atomic_dec_and_test(&s->s_ref)) {\n\t\tif (s->s_auth.authorizer)\n\t\t\tceph_auth_destroy_authorizer(\n\t\t\t\ts->s_mdsc->fsc->client->monc.auth,\n\t\t\t\ts->s_auth.authorizer);\n\t\tkfree(s);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void put_request_session(struct ceph_mds_request *req)\n{\n\tif (req->r_session) {\n\t\tceph_put_mds_session(req->r_session);\n\t\treq->r_session = NULL;\n\t}\n}"
  },
  {
    "function_name": "__unregister_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "499-508",
    "snippet": "static void __unregister_session(struct ceph_mds_client *mdsc,\n\t\t\t       struct ceph_mds_session *s)\n{\n\tdout(\"__unregister_session mds%d %p\\n\", s->s_mds, s);\n\tBUG_ON(mdsc->sessions[s->s_mds] != s);\n\tmdsc->sessions[s->s_mds] = NULL;\n\tceph_con_close(&s->s_con);\n\tceph_put_mds_session(s);\n\tatomic_dec(&mdsc->num_sessions);\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&mdsc->num_sessions"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_put_mds_session",
          "args": [
            "s"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_put_mds_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "374-385",
          "snippet": "void ceph_put_mds_session(struct ceph_mds_session *s)\n{\n\tdout(\"mdsc put_session %p %d -> %d\\n\", s,\n\t     atomic_read(&s->s_ref), atomic_read(&s->s_ref)-1);\n\tif (atomic_dec_and_test(&s->s_ref)) {\n\t\tif (s->s_auth.authorizer)\n\t\t\tceph_auth_destroy_authorizer(\n\t\t\t\ts->s_mdsc->fsc->client->monc.auth,\n\t\t\t\ts->s_auth.authorizer);\n\t\tkfree(s);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_put_mds_session(struct ceph_mds_session *s)\n{\n\tdout(\"mdsc put_session %p %d -> %d\\n\", s,\n\t     atomic_read(&s->s_ref), atomic_read(&s->s_ref)-1);\n\tif (atomic_dec_and_test(&s->s_ref)) {\n\t\tif (s->s_auth.authorizer)\n\t\t\tceph_auth_destroy_authorizer(\n\t\t\t\ts->s_mdsc->fsc->client->monc.auth,\n\t\t\t\ts->s_auth.authorizer);\n\t\tkfree(s);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_con_close",
          "args": [
            "&s->s_con"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "mdsc->sessions[s->s_mds] != s"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"__unregister_session mds%d %p\\n\"",
            "s->s_mds",
            "s"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __unregister_session(struct ceph_mds_client *mdsc,\n\t\t\t       struct ceph_mds_session *s)\n{\n\tdout(\"__unregister_session mds%d %p\\n\", s->s_mds, s);\n\tBUG_ON(mdsc->sessions[s->s_mds] != s);\n\tmdsc->sessions[s->s_mds] = NULL;\n\tceph_con_close(&s->s_con);\n\tceph_put_mds_session(s);\n\tatomic_dec(&mdsc->num_sessions);\n}"
  },
  {
    "function_name": "register_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "424-494",
    "snippet": "static struct ceph_mds_session *register_session(struct ceph_mds_client *mdsc,\n\t\t\t\t\t\t int mds)\n{\n\tstruct ceph_mds_session *s;\n\n\tif (mds >= mdsc->mdsmap->m_max_mds)\n\t\treturn ERR_PTR(-EINVAL);\n\n\ts = kzalloc(sizeof(*s), GFP_NOFS);\n\tif (!s)\n\t\treturn ERR_PTR(-ENOMEM);\n\ts->s_mdsc = mdsc;\n\ts->s_mds = mds;\n\ts->s_state = CEPH_MDS_SESSION_NEW;\n\ts->s_ttl = 0;\n\ts->s_seq = 0;\n\tmutex_init(&s->s_mutex);\n\n\tceph_con_init(&s->s_con, s, &mds_con_ops, &mdsc->fsc->client->msgr);\n\n\tspin_lock_init(&s->s_gen_ttl_lock);\n\ts->s_cap_gen = 0;\n\ts->s_cap_ttl = jiffies - 1;\n\n\tspin_lock_init(&s->s_cap_lock);\n\ts->s_renew_requested = 0;\n\ts->s_renew_seq = 0;\n\tINIT_LIST_HEAD(&s->s_caps);\n\ts->s_nr_caps = 0;\n\ts->s_trim_caps = 0;\n\tatomic_set(&s->s_ref, 1);\n\tINIT_LIST_HEAD(&s->s_waiting);\n\tINIT_LIST_HEAD(&s->s_unsafe);\n\ts->s_num_cap_releases = 0;\n\ts->s_cap_reconnect = 0;\n\ts->s_cap_iterator = NULL;\n\tINIT_LIST_HEAD(&s->s_cap_releases);\n\tINIT_LIST_HEAD(&s->s_cap_releases_done);\n\tINIT_LIST_HEAD(&s->s_cap_flushing);\n\tINIT_LIST_HEAD(&s->s_cap_snaps_flushing);\n\n\tdout(\"register_session mds%d\\n\", mds);\n\tif (mds >= mdsc->max_sessions) {\n\t\tint newmax = 1 << get_count_order(mds+1);\n\t\tstruct ceph_mds_session **sa;\n\n\t\tdout(\"register_session realloc to %d\\n\", newmax);\n\t\tsa = kcalloc(newmax, sizeof(void *), GFP_NOFS);\n\t\tif (sa == NULL)\n\t\t\tgoto fail_realloc;\n\t\tif (mdsc->sessions) {\n\t\t\tmemcpy(sa, mdsc->sessions,\n\t\t\t       mdsc->max_sessions * sizeof(void *));\n\t\t\tkfree(mdsc->sessions);\n\t\t}\n\t\tmdsc->sessions = sa;\n\t\tmdsc->max_sessions = newmax;\n\t}\n\tmdsc->sessions[mds] = s;\n\tatomic_inc(&mdsc->num_sessions);\n\tatomic_inc(&s->s_ref);  /* one ref to sessions[], one to caller */\n\n\tceph_con_open(&s->s_con, CEPH_ENTITY_TYPE_MDS, mds,\n\t\t      ceph_mdsmap_get_addr(mdsc->mdsmap, mds));\n\n\treturn s;\n\nfail_realloc:\n\tkfree(s);\n\treturn ERR_PTR(-ENOMEM);\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct ceph_connection_operations mds_con_ops;",
      "static const struct ceph_connection_operations mds_con_ops = {\n\t.get = con_get,\n\t.put = con_put,\n\t.dispatch = dispatch,\n\t.get_authorizer = get_authorizer,\n\t.verify_authorizer_reply = verify_authorizer_reply,\n\t.invalidate_authorizer = invalidate_authorizer,\n\t.peer_reset = peer_reset,\n\t.alloc_msg = mds_alloc_msg,\n\t.sign_message = sign_message,\n\t.check_message_signature = check_message_signature,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "s"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_con_open",
          "args": [
            "&s->s_con",
            "CEPH_ENTITY_TYPE_MDS",
            "mds",
            "ceph_mdsmap_get_addr(mdsc->mdsmap, mds)"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mdsmap_get_addr",
          "args": [
            "mdsc->mdsmap",
            "mds"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&s->s_ref"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&mdsc->num_sessions"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "mdsc->sessions"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sa",
            "mdsc->sessions",
            "mdsc->max_sessions * sizeof(void *)"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "newmax",
            "sizeof(void *)",
            "GFP_NOFS"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"register_session realloc to %d\\n\"",
            "newmax"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_count_order",
          "args": [
            "mds+1"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"register_session mds%d\\n\"",
            "mds"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&s->s_cap_snaps_flushing"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&s->s_cap_flushing"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&s->s_cap_releases_done"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&s->s_cap_releases"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&s->s_unsafe"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&s->s_waiting"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&s->s_ref",
            "1"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&s->s_caps"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&s->s_cap_lock"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&s->s_gen_ttl_lock"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_con_init",
          "args": [
            "&s->s_con",
            "s",
            "&mds_con_ops",
            "&mdsc->fsc->client->msgr"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&s->s_mutex"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*s)",
            "GFP_NOFS"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic const struct ceph_connection_operations mds_con_ops;\nstatic const struct ceph_connection_operations mds_con_ops = {\n\t.get = con_get,\n\t.put = con_put,\n\t.dispatch = dispatch,\n\t.get_authorizer = get_authorizer,\n\t.verify_authorizer_reply = verify_authorizer_reply,\n\t.invalidate_authorizer = invalidate_authorizer,\n\t.peer_reset = peer_reset,\n\t.alloc_msg = mds_alloc_msg,\n\t.sign_message = sign_message,\n\t.check_message_signature = check_message_signature,\n};\n\nstatic struct ceph_mds_session *register_session(struct ceph_mds_client *mdsc,\n\t\t\t\t\t\t int mds)\n{\n\tstruct ceph_mds_session *s;\n\n\tif (mds >= mdsc->mdsmap->m_max_mds)\n\t\treturn ERR_PTR(-EINVAL);\n\n\ts = kzalloc(sizeof(*s), GFP_NOFS);\n\tif (!s)\n\t\treturn ERR_PTR(-ENOMEM);\n\ts->s_mdsc = mdsc;\n\ts->s_mds = mds;\n\ts->s_state = CEPH_MDS_SESSION_NEW;\n\ts->s_ttl = 0;\n\ts->s_seq = 0;\n\tmutex_init(&s->s_mutex);\n\n\tceph_con_init(&s->s_con, s, &mds_con_ops, &mdsc->fsc->client->msgr);\n\n\tspin_lock_init(&s->s_gen_ttl_lock);\n\ts->s_cap_gen = 0;\n\ts->s_cap_ttl = jiffies - 1;\n\n\tspin_lock_init(&s->s_cap_lock);\n\ts->s_renew_requested = 0;\n\ts->s_renew_seq = 0;\n\tINIT_LIST_HEAD(&s->s_caps);\n\ts->s_nr_caps = 0;\n\ts->s_trim_caps = 0;\n\tatomic_set(&s->s_ref, 1);\n\tINIT_LIST_HEAD(&s->s_waiting);\n\tINIT_LIST_HEAD(&s->s_unsafe);\n\ts->s_num_cap_releases = 0;\n\ts->s_cap_reconnect = 0;\n\ts->s_cap_iterator = NULL;\n\tINIT_LIST_HEAD(&s->s_cap_releases);\n\tINIT_LIST_HEAD(&s->s_cap_releases_done);\n\tINIT_LIST_HEAD(&s->s_cap_flushing);\n\tINIT_LIST_HEAD(&s->s_cap_snaps_flushing);\n\n\tdout(\"register_session mds%d\\n\", mds);\n\tif (mds >= mdsc->max_sessions) {\n\t\tint newmax = 1 << get_count_order(mds+1);\n\t\tstruct ceph_mds_session **sa;\n\n\t\tdout(\"register_session realloc to %d\\n\", newmax);\n\t\tsa = kcalloc(newmax, sizeof(void *), GFP_NOFS);\n\t\tif (sa == NULL)\n\t\t\tgoto fail_realloc;\n\t\tif (mdsc->sessions) {\n\t\t\tmemcpy(sa, mdsc->sessions,\n\t\t\t       mdsc->max_sessions * sizeof(void *));\n\t\t\tkfree(mdsc->sessions);\n\t\t}\n\t\tmdsc->sessions = sa;\n\t\tmdsc->max_sessions = newmax;\n\t}\n\tmdsc->sessions[mds] = s;\n\tatomic_inc(&mdsc->num_sessions);\n\tatomic_inc(&s->s_ref);  /* one ref to sessions[], one to caller */\n\n\tceph_con_open(&s->s_con, CEPH_ENTITY_TYPE_MDS, mds,\n\t\t      ceph_mdsmap_get_addr(mdsc->mdsmap, mds));\n\n\treturn s;\n\nfail_realloc:\n\tkfree(s);\n\treturn ERR_PTR(-ENOMEM);\n}"
  },
  {
    "function_name": "__verify_registered_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "411-418",
    "snippet": "static int __verify_registered_session(struct ceph_mds_client *mdsc,\n\t\t\t\t       struct ceph_mds_session *s)\n{\n\tif (s->s_mds >= mdsc->max_sessions ||\n\t    mdsc->sessions[s->s_mds] != s)\n\t\treturn -ENOENT;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __verify_registered_session(struct ceph_mds_client *mdsc,\n\t\t\t\t       struct ceph_mds_session *s)\n{\n\tif (s->s_mds >= mdsc->max_sessions ||\n\t    mdsc->sessions[s->s_mds] != s)\n\t\treturn -ENOENT;\n\treturn 0;\n}"
  },
  {
    "function_name": "__have_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "404-409",
    "snippet": "static bool __have_session(struct ceph_mds_client *mdsc, int mds)\n{\n\tif (mds >= mdsc->max_sessions)\n\t\treturn false;\n\treturn mdsc->sessions[mds];\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic bool __have_session(struct ceph_mds_client *mdsc, int mds)\n{\n\tif (mds >= mdsc->max_sessions)\n\t\treturn false;\n\treturn mdsc->sessions[mds];\n}"
  },
  {
    "function_name": "__ceph_lookup_mds_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "390-402",
    "snippet": "struct ceph_mds_session *__ceph_lookup_mds_session(struct ceph_mds_client *mdsc,\n\t\t\t\t\t\t   int mds)\n{\n\tstruct ceph_mds_session *session;\n\n\tif (mds >= mdsc->max_sessions || mdsc->sessions[mds] == NULL)\n\t\treturn NULL;\n\tsession = mdsc->sessions[mds];\n\tdout(\"lookup_mds_session %p %d\\n\", session,\n\t     atomic_read(&session->s_ref));\n\tget_session(session);\n\treturn session;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_session",
          "args": [
            "session"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "get_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "362-372",
          "snippet": "static struct ceph_mds_session *get_session(struct ceph_mds_session *s)\n{\n\tif (atomic_inc_not_zero(&s->s_ref)) {\n\t\tdout(\"mdsc get_session %p %d -> %d\\n\", s,\n\t\t     atomic_read(&s->s_ref)-1, atomic_read(&s->s_ref));\n\t\treturn s;\n\t} else {\n\t\tdout(\"mdsc get_session %p 0 -- FAIL\", s);\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_mds_session *get_session(struct ceph_mds_session *s)\n{\n\tif (atomic_inc_not_zero(&s->s_ref)) {\n\t\tdout(\"mdsc get_session %p %d -> %d\\n\", s,\n\t\t     atomic_read(&s->s_ref)-1, atomic_read(&s->s_ref));\n\t\treturn s;\n\t} else {\n\t\tdout(\"mdsc get_session %p 0 -- FAIL\", s);\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"lookup_mds_session %p %d\\n\"",
            "session",
            "atomic_read(&session->s_ref)"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&session->s_ref"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct ceph_mds_session *__ceph_lookup_mds_session(struct ceph_mds_client *mdsc,\n\t\t\t\t\t\t   int mds)\n{\n\tstruct ceph_mds_session *session;\n\n\tif (mds >= mdsc->max_sessions || mdsc->sessions[mds] == NULL)\n\t\treturn NULL;\n\tsession = mdsc->sessions[mds];\n\tdout(\"lookup_mds_session %p %d\\n\", session,\n\t     atomic_read(&session->s_ref));\n\tget_session(session);\n\treturn session;\n}"
  },
  {
    "function_name": "ceph_put_mds_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "374-385",
    "snippet": "void ceph_put_mds_session(struct ceph_mds_session *s)\n{\n\tdout(\"mdsc put_session %p %d -> %d\\n\", s,\n\t     atomic_read(&s->s_ref), atomic_read(&s->s_ref)-1);\n\tif (atomic_dec_and_test(&s->s_ref)) {\n\t\tif (s->s_auth.authorizer)\n\t\t\tceph_auth_destroy_authorizer(\n\t\t\t\ts->s_mdsc->fsc->client->monc.auth,\n\t\t\t\ts->s_auth.authorizer);\n\t\tkfree(s);\n\t}\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "s"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_auth_destroy_authorizer",
          "args": [
            "s->s_mdsc->fsc->client->monc.auth",
            "s->s_auth.authorizer"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&s->s_ref"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"mdsc put_session %p %d -> %d\\n\"",
            "s",
            "atomic_read(&s->s_ref)",
            "atomic_read(&s->s_ref)-1"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&s->s_ref"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&s->s_ref"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_put_mds_session(struct ceph_mds_session *s)\n{\n\tdout(\"mdsc put_session %p %d -> %d\\n\", s,\n\t     atomic_read(&s->s_ref), atomic_read(&s->s_ref)-1);\n\tif (atomic_dec_and_test(&s->s_ref)) {\n\t\tif (s->s_auth.authorizer)\n\t\t\tceph_auth_destroy_authorizer(\n\t\t\t\ts->s_mdsc->fsc->client->monc.auth,\n\t\t\t\ts->s_auth.authorizer);\n\t\tkfree(s);\n\t}\n}"
  },
  {
    "function_name": "get_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "362-372",
    "snippet": "static struct ceph_mds_session *get_session(struct ceph_mds_session *s)\n{\n\tif (atomic_inc_not_zero(&s->s_ref)) {\n\t\tdout(\"mdsc get_session %p %d -> %d\\n\", s,\n\t\t     atomic_read(&s->s_ref)-1, atomic_read(&s->s_ref));\n\t\treturn s;\n\t} else {\n\t\tdout(\"mdsc get_session %p 0 -- FAIL\", s);\n\t\treturn NULL;\n\t}\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"mdsc get_session %p 0 -- FAIL\"",
            "s"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"mdsc get_session %p %d -> %d\\n\"",
            "s",
            "atomic_read(&s->s_ref)-1",
            "atomic_read(&s->s_ref)"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&s->s_ref"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&s->s_ref"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_not_zero",
          "args": [
            "&s->s_ref"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_mds_session *get_session(struct ceph_mds_session *s)\n{\n\tif (atomic_inc_not_zero(&s->s_ref)) {\n\t\tdout(\"mdsc get_session %p %d -> %d\\n\", s,\n\t\t     atomic_read(&s->s_ref)-1, atomic_read(&s->s_ref));\n\t\treturn s;\n\t} else {\n\t\tdout(\"mdsc get_session %p 0 -- FAIL\", s);\n\t\treturn NULL;\n\t}\n}"
  },
  {
    "function_name": "ceph_session_state_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "348-360",
    "snippet": "const char *ceph_session_state_name(int s)\n{\n\tswitch (s) {\n\tcase CEPH_MDS_SESSION_NEW: return \"new\";\n\tcase CEPH_MDS_SESSION_OPENING: return \"opening\";\n\tcase CEPH_MDS_SESSION_OPEN: return \"open\";\n\tcase CEPH_MDS_SESSION_HUNG: return \"hung\";\n\tcase CEPH_MDS_SESSION_CLOSING: return \"closing\";\n\tcase CEPH_MDS_SESSION_RESTARTING: return \"restarting\";\n\tcase CEPH_MDS_SESSION_RECONNECTING: return \"reconnecting\";\n\tdefault: return \"???\";\n\t}\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nconst char *ceph_session_state_name(int s)\n{\n\tswitch (s) {\n\tcase CEPH_MDS_SESSION_NEW: return \"new\";\n\tcase CEPH_MDS_SESSION_OPENING: return \"opening\";\n\tcase CEPH_MDS_SESSION_OPEN: return \"open\";\n\tcase CEPH_MDS_SESSION_HUNG: return \"hung\";\n\tcase CEPH_MDS_SESSION_CLOSING: return \"closing\";\n\tcase CEPH_MDS_SESSION_RESTARTING: return \"restarting\";\n\tcase CEPH_MDS_SESSION_RECONNECTING: return \"reconnecting\";\n\tdefault: return \"???\";\n\t}\n}"
  },
  {
    "function_name": "destroy_reply_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "337-342",
    "snippet": "static void destroy_reply_info(struct ceph_mds_reply_info_parsed *info)\n{\n\tif (!info->dir_in)\n\t\treturn;\n\tfree_pages((unsigned long)info->dir_in, get_order(info->dir_buf_size));\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_pages",
          "args": [
            "(unsigned long)info->dir_in",
            "get_order(info->dir_buf_size)"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_and_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1114-1125",
          "snippet": "void ocfs2_unlock_and_free_pages(struct page **pages, int num_pages)\n{\n\tint i;\n\n\tfor(i = 0; i < num_pages; i++) {\n\t\tif (pages[i]) {\n\t\t\tunlock_page(pages[i]);\n\t\t\tmark_page_accessed(pages[i]);\n\t\t\tpage_cache_release(pages[i]);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid ocfs2_unlock_and_free_pages(struct page **pages, int num_pages)\n{\n\tint i;\n\n\tfor(i = 0; i < num_pages; i++) {\n\t\tif (pages[i]) {\n\t\t\tunlock_page(pages[i]);\n\t\t\tmark_page_accessed(pages[i]);\n\t\t\tpage_cache_release(pages[i]);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "info->dir_buf_size"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void destroy_reply_info(struct ceph_mds_reply_info_parsed *info)\n{\n\tif (!info->dir_in)\n\t\treturn;\n\tfree_pages((unsigned long)info->dir_in, get_order(info->dir_buf_size));\n}"
  },
  {
    "function_name": "parse_reply_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "290-335",
    "snippet": "static int parse_reply_info(struct ceph_msg *msg,\n\t\t\t    struct ceph_mds_reply_info_parsed *info,\n\t\t\t    u64 features)\n{\n\tvoid *p, *end;\n\tu32 len;\n\tint err;\n\n\tinfo->head = msg->front.iov_base;\n\tp = msg->front.iov_base + sizeof(struct ceph_mds_reply_head);\n\tend = p + msg->front.iov_len - sizeof(struct ceph_mds_reply_head);\n\n\t/* trace */\n\tceph_decode_32_safe(&p, end, len, bad);\n\tif (len > 0) {\n\t\tceph_decode_need(&p, end, len, bad);\n\t\terr = parse_reply_info_trace(&p, p+len, info, features);\n\t\tif (err < 0)\n\t\t\tgoto out_bad;\n\t}\n\n\t/* extra */\n\tceph_decode_32_safe(&p, end, len, bad);\n\tif (len > 0) {\n\t\tceph_decode_need(&p, end, len, bad);\n\t\terr = parse_reply_info_extra(&p, p+len, info, features);\n\t\tif (err < 0)\n\t\t\tgoto out_bad;\n\t}\n\n\t/* snap blob */\n\tceph_decode_32_safe(&p, end, len, bad);\n\tinfo->snapblob_len = len;\n\tinfo->snapblob = p;\n\tp += len;\n\n\tif (p != end)\n\t\tgoto bad;\n\treturn 0;\n\nbad:\n\terr = -EIO;\nout_bad:\n\tpr_err(\"mds parse_reply err %d\\n\", err);\n\treturn err;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"mds parse_reply err %d\\n\"",
            "err"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_32_safe",
          "args": [
            "&p",
            "end",
            "len",
            "bad"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_reply_info_extra",
          "args": [
            "&p",
            "p+len",
            "info",
            "features"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "parse_reply_info_extra",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "272-285",
          "snippet": "static int parse_reply_info_extra(void **p, void *end,\n\t\t\t\t  struct ceph_mds_reply_info_parsed *info,\n\t\t\t\t  u64 features)\n{\n\tif (info->head->op == CEPH_MDS_OP_GETFILELOCK)\n\t\treturn parse_reply_info_filelock(p, end, info, features);\n\telse if (info->head->op == CEPH_MDS_OP_READDIR ||\n\t\t info->head->op == CEPH_MDS_OP_LSSNAP)\n\t\treturn parse_reply_info_dir(p, end, info, features);\n\telse if (info->head->op == CEPH_MDS_OP_CREATE)\n\t\treturn parse_reply_info_create(p, end, info, features);\n\telse\n\t\treturn -EIO;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);\n\nstatic int parse_reply_info_extra(void **p, void *end,\n\t\t\t\t  struct ceph_mds_reply_info_parsed *info,\n\t\t\t\t  u64 features)\n{\n\tif (info->head->op == CEPH_MDS_OP_GETFILELOCK)\n\t\treturn parse_reply_info_filelock(p, end, info, features);\n\telse if (info->head->op == CEPH_MDS_OP_READDIR ||\n\t\t info->head->op == CEPH_MDS_OP_LSSNAP)\n\t\treturn parse_reply_info_dir(p, end, info, features);\n\telse if (info->head->op == CEPH_MDS_OP_CREATE)\n\t\treturn parse_reply_info_create(p, end, info, features);\n\telse\n\t\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_decode_need",
          "args": [
            "&p",
            "end",
            "len",
            "bad"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_32_safe",
          "args": [
            "&p",
            "end",
            "len",
            "bad"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_reply_info_trace",
          "args": [
            "&p",
            "p+len",
            "info",
            "features"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "parse_reply_info_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "111-153",
          "snippet": "static int parse_reply_info_trace(void **p, void *end,\n\t\t\t\t  struct ceph_mds_reply_info_parsed *info,\n\t\t\t\t  u64 features)\n{\n\tint err;\n\n\tif (info->head->is_dentry) {\n\t\terr = parse_reply_info_in(p, end, &info->diri, features);\n\t\tif (err < 0)\n\t\t\tgoto out_bad;\n\n\t\tif (unlikely(*p + sizeof(*info->dirfrag) > end))\n\t\t\tgoto bad;\n\t\tinfo->dirfrag = *p;\n\t\t*p += sizeof(*info->dirfrag) +\n\t\t\tsizeof(u32)*le32_to_cpu(info->dirfrag->ndist);\n\t\tif (unlikely(*p > end))\n\t\t\tgoto bad;\n\n\t\tceph_decode_32_safe(p, end, info->dname_len, bad);\n\t\tceph_decode_need(p, end, info->dname_len, bad);\n\t\tinfo->dname = *p;\n\t\t*p += info->dname_len;\n\t\tinfo->dlease = *p;\n\t\t*p += sizeof(*info->dlease);\n\t}\n\n\tif (info->head->is_target) {\n\t\terr = parse_reply_info_in(p, end, &info->targeti, features);\n\t\tif (err < 0)\n\t\t\tgoto out_bad;\n\t}\n\n\tif (unlikely(*p != end))\n\t\tgoto bad;\n\treturn 0;\n\nbad:\n\terr = -EIO;\nout_bad:\n\tpr_err(\"problem parsing mds trace %d\\n\", err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);\n\nstatic int parse_reply_info_trace(void **p, void *end,\n\t\t\t\t  struct ceph_mds_reply_info_parsed *info,\n\t\t\t\t  u64 features)\n{\n\tint err;\n\n\tif (info->head->is_dentry) {\n\t\terr = parse_reply_info_in(p, end, &info->diri, features);\n\t\tif (err < 0)\n\t\t\tgoto out_bad;\n\n\t\tif (unlikely(*p + sizeof(*info->dirfrag) > end))\n\t\t\tgoto bad;\n\t\tinfo->dirfrag = *p;\n\t\t*p += sizeof(*info->dirfrag) +\n\t\t\tsizeof(u32)*le32_to_cpu(info->dirfrag->ndist);\n\t\tif (unlikely(*p > end))\n\t\t\tgoto bad;\n\n\t\tceph_decode_32_safe(p, end, info->dname_len, bad);\n\t\tceph_decode_need(p, end, info->dname_len, bad);\n\t\tinfo->dname = *p;\n\t\t*p += info->dname_len;\n\t\tinfo->dlease = *p;\n\t\t*p += sizeof(*info->dlease);\n\t}\n\n\tif (info->head->is_target) {\n\t\terr = parse_reply_info_in(p, end, &info->targeti, features);\n\t\tif (err < 0)\n\t\t\tgoto out_bad;\n\t}\n\n\tif (unlikely(*p != end))\n\t\tgoto bad;\n\treturn 0;\n\nbad:\n\terr = -EIO;\nout_bad:\n\tpr_err(\"problem parsing mds trace %d\\n\", err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_decode_need",
          "args": [
            "&p",
            "end",
            "len",
            "bad"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_32_safe",
          "args": [
            "&p",
            "end",
            "len",
            "bad"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);\n\nstatic int parse_reply_info(struct ceph_msg *msg,\n\t\t\t    struct ceph_mds_reply_info_parsed *info,\n\t\t\t    u64 features)\n{\n\tvoid *p, *end;\n\tu32 len;\n\tint err;\n\n\tinfo->head = msg->front.iov_base;\n\tp = msg->front.iov_base + sizeof(struct ceph_mds_reply_head);\n\tend = p + msg->front.iov_len - sizeof(struct ceph_mds_reply_head);\n\n\t/* trace */\n\tceph_decode_32_safe(&p, end, len, bad);\n\tif (len > 0) {\n\t\tceph_decode_need(&p, end, len, bad);\n\t\terr = parse_reply_info_trace(&p, p+len, info, features);\n\t\tif (err < 0)\n\t\t\tgoto out_bad;\n\t}\n\n\t/* extra */\n\tceph_decode_32_safe(&p, end, len, bad);\n\tif (len > 0) {\n\t\tceph_decode_need(&p, end, len, bad);\n\t\terr = parse_reply_info_extra(&p, p+len, info, features);\n\t\tif (err < 0)\n\t\t\tgoto out_bad;\n\t}\n\n\t/* snap blob */\n\tceph_decode_32_safe(&p, end, len, bad);\n\tinfo->snapblob_len = len;\n\tinfo->snapblob = p;\n\tp += len;\n\n\tif (p != end)\n\t\tgoto bad;\n\treturn 0;\n\nbad:\n\terr = -EIO;\nout_bad:\n\tpr_err(\"mds parse_reply err %d\\n\", err);\n\treturn err;\n}"
  },
  {
    "function_name": "parse_reply_info_extra",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "272-285",
    "snippet": "static int parse_reply_info_extra(void **p, void *end,\n\t\t\t\t  struct ceph_mds_reply_info_parsed *info,\n\t\t\t\t  u64 features)\n{\n\tif (info->head->op == CEPH_MDS_OP_GETFILELOCK)\n\t\treturn parse_reply_info_filelock(p, end, info, features);\n\telse if (info->head->op == CEPH_MDS_OP_READDIR ||\n\t\t info->head->op == CEPH_MDS_OP_LSSNAP)\n\t\treturn parse_reply_info_dir(p, end, info, features);\n\telse if (info->head->op == CEPH_MDS_OP_CREATE)\n\t\treturn parse_reply_info_create(p, end, info, features);\n\telse\n\t\treturn -EIO;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "parse_reply_info_create",
          "args": [
            "p",
            "end",
            "info",
            "features"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "parse_reply_info_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "248-267",
          "snippet": "static int parse_reply_info_create(void **p, void *end,\n\t\t\t\t  struct ceph_mds_reply_info_parsed *info,\n\t\t\t\t  u64 features)\n{\n\tif (features & CEPH_FEATURE_REPLY_CREATE_INODE) {\n\t\tif (*p == end) {\n\t\t\tinfo->has_create_ino = false;\n\t\t} else {\n\t\t\tinfo->has_create_ino = true;\n\t\t\tinfo->ino = ceph_decode_64(p);\n\t\t}\n\t}\n\n\tif (unlikely(*p != end))\n\t\tgoto bad;\n\treturn 0;\n\nbad:\n\treturn -EIO;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int parse_reply_info_create(void **p, void *end,\n\t\t\t\t  struct ceph_mds_reply_info_parsed *info,\n\t\t\t\t  u64 features)\n{\n\tif (features & CEPH_FEATURE_REPLY_CREATE_INODE) {\n\t\tif (*p == end) {\n\t\t\tinfo->has_create_ino = false;\n\t\t} else {\n\t\t\tinfo->has_create_ino = true;\n\t\t\tinfo->ino = ceph_decode_64(p);\n\t\t}\n\t}\n\n\tif (unlikely(*p != end))\n\t\tgoto bad;\n\treturn 0;\n\nbad:\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_reply_info_dir",
          "args": [
            "p",
            "end",
            "info",
            "features"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "parse_reply_info_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "158-222",
          "snippet": "static int parse_reply_info_dir(void **p, void *end,\n\t\t\t\tstruct ceph_mds_reply_info_parsed *info,\n\t\t\t\tu64 features)\n{\n\tu32 num, i = 0;\n\tint err;\n\n\tinfo->dir_dir = *p;\n\tif (*p + sizeof(*info->dir_dir) > end)\n\t\tgoto bad;\n\t*p += sizeof(*info->dir_dir) +\n\t\tsizeof(u32)*le32_to_cpu(info->dir_dir->ndist);\n\tif (*p > end)\n\t\tgoto bad;\n\n\tceph_decode_need(p, end, sizeof(num) + 2, bad);\n\tnum = ceph_decode_32(p);\n\tinfo->dir_end = ceph_decode_8(p);\n\tinfo->dir_complete = ceph_decode_8(p);\n\tif (num == 0)\n\t\tgoto done;\n\n\tBUG_ON(!info->dir_in);\n\tinfo->dir_dname = (void *)(info->dir_in + num);\n\tinfo->dir_dname_len = (void *)(info->dir_dname + num);\n\tinfo->dir_dlease = (void *)(info->dir_dname_len + num);\n\tif ((unsigned long)(info->dir_dlease + num) >\n\t    (unsigned long)info->dir_in + info->dir_buf_size) {\n\t\tpr_err(\"dir contents are larger than expected\\n\");\n\t\tWARN_ON(1);\n\t\tgoto bad;\n\t}\n\n\tinfo->dir_nr = num;\n\twhile (num) {\n\t\t/* dentry */\n\t\tceph_decode_need(p, end, sizeof(u32)*2, bad);\n\t\tinfo->dir_dname_len[i] = ceph_decode_32(p);\n\t\tceph_decode_need(p, end, info->dir_dname_len[i], bad);\n\t\tinfo->dir_dname[i] = *p;\n\t\t*p += info->dir_dname_len[i];\n\t\tdout(\"parsed dir dname '%.*s'\\n\", info->dir_dname_len[i],\n\t\t     info->dir_dname[i]);\n\t\tinfo->dir_dlease[i] = *p;\n\t\t*p += sizeof(struct ceph_mds_reply_lease);\n\n\t\t/* inode */\n\t\terr = parse_reply_info_in(p, end, &info->dir_in[i], features);\n\t\tif (err < 0)\n\t\t\tgoto out_bad;\n\t\ti++;\n\t\tnum--;\n\t}\n\ndone:\n\tif (*p != end)\n\t\tgoto bad;\n\treturn 0;\n\nbad:\n\terr = -EIO;\nout_bad:\n\tpr_err(\"problem parsing dir contents %d\\n\", err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int parse_reply_info_dir(void **p, void *end,\n\t\t\t\tstruct ceph_mds_reply_info_parsed *info,\n\t\t\t\tu64 features)\n{\n\tu32 num, i = 0;\n\tint err;\n\n\tinfo->dir_dir = *p;\n\tif (*p + sizeof(*info->dir_dir) > end)\n\t\tgoto bad;\n\t*p += sizeof(*info->dir_dir) +\n\t\tsizeof(u32)*le32_to_cpu(info->dir_dir->ndist);\n\tif (*p > end)\n\t\tgoto bad;\n\n\tceph_decode_need(p, end, sizeof(num) + 2, bad);\n\tnum = ceph_decode_32(p);\n\tinfo->dir_end = ceph_decode_8(p);\n\tinfo->dir_complete = ceph_decode_8(p);\n\tif (num == 0)\n\t\tgoto done;\n\n\tBUG_ON(!info->dir_in);\n\tinfo->dir_dname = (void *)(info->dir_in + num);\n\tinfo->dir_dname_len = (void *)(info->dir_dname + num);\n\tinfo->dir_dlease = (void *)(info->dir_dname_len + num);\n\tif ((unsigned long)(info->dir_dlease + num) >\n\t    (unsigned long)info->dir_in + info->dir_buf_size) {\n\t\tpr_err(\"dir contents are larger than expected\\n\");\n\t\tWARN_ON(1);\n\t\tgoto bad;\n\t}\n\n\tinfo->dir_nr = num;\n\twhile (num) {\n\t\t/* dentry */\n\t\tceph_decode_need(p, end, sizeof(u32)*2, bad);\n\t\tinfo->dir_dname_len[i] = ceph_decode_32(p);\n\t\tceph_decode_need(p, end, info->dir_dname_len[i], bad);\n\t\tinfo->dir_dname[i] = *p;\n\t\t*p += info->dir_dname_len[i];\n\t\tdout(\"parsed dir dname '%.*s'\\n\", info->dir_dname_len[i],\n\t\t     info->dir_dname[i]);\n\t\tinfo->dir_dlease[i] = *p;\n\t\t*p += sizeof(struct ceph_mds_reply_lease);\n\n\t\t/* inode */\n\t\terr = parse_reply_info_in(p, end, &info->dir_in[i], features);\n\t\tif (err < 0)\n\t\t\tgoto out_bad;\n\t\ti++;\n\t\tnum--;\n\t}\n\ndone:\n\tif (*p != end)\n\t\tgoto bad;\n\treturn 0;\n\nbad:\n\terr = -EIO;\nout_bad:\n\tpr_err(\"problem parsing dir contents %d\\n\", err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_reply_info_filelock",
          "args": [
            "p",
            "end",
            "info",
            "features"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "parse_reply_info_filelock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "227-243",
          "snippet": "static int parse_reply_info_filelock(void **p, void *end,\n\t\t\t\t     struct ceph_mds_reply_info_parsed *info,\n\t\t\t\t     u64 features)\n{\n\tif (*p + sizeof(*info->filelock_reply) > end)\n\t\tgoto bad;\n\n\tinfo->filelock_reply = *p;\n\t*p += sizeof(*info->filelock_reply);\n\n\tif (unlikely(*p != end))\n\t\tgoto bad;\n\treturn 0;\n\nbad:\n\treturn -EIO;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int parse_reply_info_filelock(void **p, void *end,\n\t\t\t\t     struct ceph_mds_reply_info_parsed *info,\n\t\t\t\t     u64 features)\n{\n\tif (*p + sizeof(*info->filelock_reply) > end)\n\t\tgoto bad;\n\n\tinfo->filelock_reply = *p;\n\t*p += sizeof(*info->filelock_reply);\n\n\tif (unlikely(*p != end))\n\t\tgoto bad;\n\treturn 0;\n\nbad:\n\treturn -EIO;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);\n\nstatic int parse_reply_info_extra(void **p, void *end,\n\t\t\t\t  struct ceph_mds_reply_info_parsed *info,\n\t\t\t\t  u64 features)\n{\n\tif (info->head->op == CEPH_MDS_OP_GETFILELOCK)\n\t\treturn parse_reply_info_filelock(p, end, info, features);\n\telse if (info->head->op == CEPH_MDS_OP_READDIR ||\n\t\t info->head->op == CEPH_MDS_OP_LSSNAP)\n\t\treturn parse_reply_info_dir(p, end, info, features);\n\telse if (info->head->op == CEPH_MDS_OP_CREATE)\n\t\treturn parse_reply_info_create(p, end, info, features);\n\telse\n\t\treturn -EIO;\n}"
  },
  {
    "function_name": "parse_reply_info_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "248-267",
    "snippet": "static int parse_reply_info_create(void **p, void *end,\n\t\t\t\t  struct ceph_mds_reply_info_parsed *info,\n\t\t\t\t  u64 features)\n{\n\tif (features & CEPH_FEATURE_REPLY_CREATE_INODE) {\n\t\tif (*p == end) {\n\t\t\tinfo->has_create_ino = false;\n\t\t} else {\n\t\t\tinfo->has_create_ino = true;\n\t\t\tinfo->ino = ceph_decode_64(p);\n\t\t}\n\t}\n\n\tif (unlikely(*p != end))\n\t\tgoto bad;\n\treturn 0;\n\nbad:\n\treturn -EIO;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "*p != end"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_64",
          "args": [
            "p"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int parse_reply_info_create(void **p, void *end,\n\t\t\t\t  struct ceph_mds_reply_info_parsed *info,\n\t\t\t\t  u64 features)\n{\n\tif (features & CEPH_FEATURE_REPLY_CREATE_INODE) {\n\t\tif (*p == end) {\n\t\t\tinfo->has_create_ino = false;\n\t\t} else {\n\t\t\tinfo->has_create_ino = true;\n\t\t\tinfo->ino = ceph_decode_64(p);\n\t\t}\n\t}\n\n\tif (unlikely(*p != end))\n\t\tgoto bad;\n\treturn 0;\n\nbad:\n\treturn -EIO;\n}"
  },
  {
    "function_name": "parse_reply_info_filelock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "227-243",
    "snippet": "static int parse_reply_info_filelock(void **p, void *end,\n\t\t\t\t     struct ceph_mds_reply_info_parsed *info,\n\t\t\t\t     u64 features)\n{\n\tif (*p + sizeof(*info->filelock_reply) > end)\n\t\tgoto bad;\n\n\tinfo->filelock_reply = *p;\n\t*p += sizeof(*info->filelock_reply);\n\n\tif (unlikely(*p != end))\n\t\tgoto bad;\n\treturn 0;\n\nbad:\n\treturn -EIO;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "*p != end"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int parse_reply_info_filelock(void **p, void *end,\n\t\t\t\t     struct ceph_mds_reply_info_parsed *info,\n\t\t\t\t     u64 features)\n{\n\tif (*p + sizeof(*info->filelock_reply) > end)\n\t\tgoto bad;\n\n\tinfo->filelock_reply = *p;\n\t*p += sizeof(*info->filelock_reply);\n\n\tif (unlikely(*p != end))\n\t\tgoto bad;\n\treturn 0;\n\nbad:\n\treturn -EIO;\n}"
  },
  {
    "function_name": "parse_reply_info_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "158-222",
    "snippet": "static int parse_reply_info_dir(void **p, void *end,\n\t\t\t\tstruct ceph_mds_reply_info_parsed *info,\n\t\t\t\tu64 features)\n{\n\tu32 num, i = 0;\n\tint err;\n\n\tinfo->dir_dir = *p;\n\tif (*p + sizeof(*info->dir_dir) > end)\n\t\tgoto bad;\n\t*p += sizeof(*info->dir_dir) +\n\t\tsizeof(u32)*le32_to_cpu(info->dir_dir->ndist);\n\tif (*p > end)\n\t\tgoto bad;\n\n\tceph_decode_need(p, end, sizeof(num) + 2, bad);\n\tnum = ceph_decode_32(p);\n\tinfo->dir_end = ceph_decode_8(p);\n\tinfo->dir_complete = ceph_decode_8(p);\n\tif (num == 0)\n\t\tgoto done;\n\n\tBUG_ON(!info->dir_in);\n\tinfo->dir_dname = (void *)(info->dir_in + num);\n\tinfo->dir_dname_len = (void *)(info->dir_dname + num);\n\tinfo->dir_dlease = (void *)(info->dir_dname_len + num);\n\tif ((unsigned long)(info->dir_dlease + num) >\n\t    (unsigned long)info->dir_in + info->dir_buf_size) {\n\t\tpr_err(\"dir contents are larger than expected\\n\");\n\t\tWARN_ON(1);\n\t\tgoto bad;\n\t}\n\n\tinfo->dir_nr = num;\n\twhile (num) {\n\t\t/* dentry */\n\t\tceph_decode_need(p, end, sizeof(u32)*2, bad);\n\t\tinfo->dir_dname_len[i] = ceph_decode_32(p);\n\t\tceph_decode_need(p, end, info->dir_dname_len[i], bad);\n\t\tinfo->dir_dname[i] = *p;\n\t\t*p += info->dir_dname_len[i];\n\t\tdout(\"parsed dir dname '%.*s'\\n\", info->dir_dname_len[i],\n\t\t     info->dir_dname[i]);\n\t\tinfo->dir_dlease[i] = *p;\n\t\t*p += sizeof(struct ceph_mds_reply_lease);\n\n\t\t/* inode */\n\t\terr = parse_reply_info_in(p, end, &info->dir_in[i], features);\n\t\tif (err < 0)\n\t\t\tgoto out_bad;\n\t\ti++;\n\t\tnum--;\n\t}\n\ndone:\n\tif (*p != end)\n\t\tgoto bad;\n\treturn 0;\n\nbad:\n\terr = -EIO;\nout_bad:\n\tpr_err(\"problem parsing dir contents %d\\n\", err);\n\treturn err;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"problem parsing dir contents %d\\n\"",
            "err"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_reply_info_in",
          "args": [
            "p",
            "end",
            "&info->dir_in[i]",
            "features"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "parse_reply_info_in",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "66-105",
          "snippet": "static int parse_reply_info_in(void **p, void *end,\n\t\t\t       struct ceph_mds_reply_info_in *info,\n\t\t\t       u64 features)\n{\n\tint err = -EIO;\n\n\tinfo->in = *p;\n\t*p += sizeof(struct ceph_mds_reply_inode) +\n\t\tsizeof(*info->in->fragtree.splits) *\n\t\tle32_to_cpu(info->in->fragtree.nsplits);\n\n\tceph_decode_32_safe(p, end, info->symlink_len, bad);\n\tceph_decode_need(p, end, info->symlink_len, bad);\n\tinfo->symlink = *p;\n\t*p += info->symlink_len;\n\n\tif (features & CEPH_FEATURE_DIRLAYOUTHASH)\n\t\tceph_decode_copy_safe(p, end, &info->dir_layout,\n\t\t\t\t      sizeof(info->dir_layout), bad);\n\telse\n\t\tmemset(&info->dir_layout, 0, sizeof(info->dir_layout));\n\n\tceph_decode_32_safe(p, end, info->xattr_len, bad);\n\tceph_decode_need(p, end, info->xattr_len, bad);\n\tinfo->xattr_data = *p;\n\t*p += info->xattr_len;\n\n\tif (features & CEPH_FEATURE_MDS_INLINE_DATA) {\n\t\tceph_decode_64_safe(p, end, info->inline_version, bad);\n\t\tceph_decode_32_safe(p, end, info->inline_len, bad);\n\t\tceph_decode_need(p, end, info->inline_len, bad);\n\t\tinfo->inline_data = *p;\n\t\t*p += info->inline_len;\n\t} else\n\t\tinfo->inline_version = CEPH_INLINE_NONE;\n\n\treturn 0;\nbad:\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int parse_reply_info_in(void **p, void *end,\n\t\t\t       struct ceph_mds_reply_info_in *info,\n\t\t\t       u64 features)\n{\n\tint err = -EIO;\n\n\tinfo->in = *p;\n\t*p += sizeof(struct ceph_mds_reply_inode) +\n\t\tsizeof(*info->in->fragtree.splits) *\n\t\tle32_to_cpu(info->in->fragtree.nsplits);\n\n\tceph_decode_32_safe(p, end, info->symlink_len, bad);\n\tceph_decode_need(p, end, info->symlink_len, bad);\n\tinfo->symlink = *p;\n\t*p += info->symlink_len;\n\n\tif (features & CEPH_FEATURE_DIRLAYOUTHASH)\n\t\tceph_decode_copy_safe(p, end, &info->dir_layout,\n\t\t\t\t      sizeof(info->dir_layout), bad);\n\telse\n\t\tmemset(&info->dir_layout, 0, sizeof(info->dir_layout));\n\n\tceph_decode_32_safe(p, end, info->xattr_len, bad);\n\tceph_decode_need(p, end, info->xattr_len, bad);\n\tinfo->xattr_data = *p;\n\t*p += info->xattr_len;\n\n\tif (features & CEPH_FEATURE_MDS_INLINE_DATA) {\n\t\tceph_decode_64_safe(p, end, info->inline_version, bad);\n\t\tceph_decode_32_safe(p, end, info->inline_len, bad);\n\t\tceph_decode_need(p, end, info->inline_len, bad);\n\t\tinfo->inline_data = *p;\n\t\t*p += info->inline_len;\n\t} else\n\t\tinfo->inline_version = CEPH_INLINE_NONE;\n\n\treturn 0;\nbad:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"parsed dir dname '%.*s'\\n\"",
            "info->dir_dname_len[i]",
            "info->dir_dname[i]"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_need",
          "args": [
            "p",
            "end",
            "info->dir_dname_len[i]",
            "bad"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_32",
          "args": [
            "p"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_need",
          "args": [
            "p",
            "end",
            "sizeof(u32)*2",
            "bad"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"dir contents are larger than expected\\n\""
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!info->dir_in"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_8",
          "args": [
            "p"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_8",
          "args": [
            "p"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_32",
          "args": [
            "p"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_need",
          "args": [
            "p",
            "end",
            "sizeof(num) + 2",
            "bad"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "info->dir_dir->ndist"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int parse_reply_info_dir(void **p, void *end,\n\t\t\t\tstruct ceph_mds_reply_info_parsed *info,\n\t\t\t\tu64 features)\n{\n\tu32 num, i = 0;\n\tint err;\n\n\tinfo->dir_dir = *p;\n\tif (*p + sizeof(*info->dir_dir) > end)\n\t\tgoto bad;\n\t*p += sizeof(*info->dir_dir) +\n\t\tsizeof(u32)*le32_to_cpu(info->dir_dir->ndist);\n\tif (*p > end)\n\t\tgoto bad;\n\n\tceph_decode_need(p, end, sizeof(num) + 2, bad);\n\tnum = ceph_decode_32(p);\n\tinfo->dir_end = ceph_decode_8(p);\n\tinfo->dir_complete = ceph_decode_8(p);\n\tif (num == 0)\n\t\tgoto done;\n\n\tBUG_ON(!info->dir_in);\n\tinfo->dir_dname = (void *)(info->dir_in + num);\n\tinfo->dir_dname_len = (void *)(info->dir_dname + num);\n\tinfo->dir_dlease = (void *)(info->dir_dname_len + num);\n\tif ((unsigned long)(info->dir_dlease + num) >\n\t    (unsigned long)info->dir_in + info->dir_buf_size) {\n\t\tpr_err(\"dir contents are larger than expected\\n\");\n\t\tWARN_ON(1);\n\t\tgoto bad;\n\t}\n\n\tinfo->dir_nr = num;\n\twhile (num) {\n\t\t/* dentry */\n\t\tceph_decode_need(p, end, sizeof(u32)*2, bad);\n\t\tinfo->dir_dname_len[i] = ceph_decode_32(p);\n\t\tceph_decode_need(p, end, info->dir_dname_len[i], bad);\n\t\tinfo->dir_dname[i] = *p;\n\t\t*p += info->dir_dname_len[i];\n\t\tdout(\"parsed dir dname '%.*s'\\n\", info->dir_dname_len[i],\n\t\t     info->dir_dname[i]);\n\t\tinfo->dir_dlease[i] = *p;\n\t\t*p += sizeof(struct ceph_mds_reply_lease);\n\n\t\t/* inode */\n\t\terr = parse_reply_info_in(p, end, &info->dir_in[i], features);\n\t\tif (err < 0)\n\t\t\tgoto out_bad;\n\t\ti++;\n\t\tnum--;\n\t}\n\ndone:\n\tif (*p != end)\n\t\tgoto bad;\n\treturn 0;\n\nbad:\n\terr = -EIO;\nout_bad:\n\tpr_err(\"problem parsing dir contents %d\\n\", err);\n\treturn err;\n}"
  },
  {
    "function_name": "parse_reply_info_trace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "111-153",
    "snippet": "static int parse_reply_info_trace(void **p, void *end,\n\t\t\t\t  struct ceph_mds_reply_info_parsed *info,\n\t\t\t\t  u64 features)\n{\n\tint err;\n\n\tif (info->head->is_dentry) {\n\t\terr = parse_reply_info_in(p, end, &info->diri, features);\n\t\tif (err < 0)\n\t\t\tgoto out_bad;\n\n\t\tif (unlikely(*p + sizeof(*info->dirfrag) > end))\n\t\t\tgoto bad;\n\t\tinfo->dirfrag = *p;\n\t\t*p += sizeof(*info->dirfrag) +\n\t\t\tsizeof(u32)*le32_to_cpu(info->dirfrag->ndist);\n\t\tif (unlikely(*p > end))\n\t\t\tgoto bad;\n\n\t\tceph_decode_32_safe(p, end, info->dname_len, bad);\n\t\tceph_decode_need(p, end, info->dname_len, bad);\n\t\tinfo->dname = *p;\n\t\t*p += info->dname_len;\n\t\tinfo->dlease = *p;\n\t\t*p += sizeof(*info->dlease);\n\t}\n\n\tif (info->head->is_target) {\n\t\terr = parse_reply_info_in(p, end, &info->targeti, features);\n\t\tif (err < 0)\n\t\t\tgoto out_bad;\n\t}\n\n\tif (unlikely(*p != end))\n\t\tgoto bad;\n\treturn 0;\n\nbad:\n\terr = -EIO;\nout_bad:\n\tpr_err(\"problem parsing mds trace %d\\n\", err);\n\treturn err;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"problem parsing mds trace %d\\n\"",
            "err"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "*p != end"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_reply_info_in",
          "args": [
            "p",
            "end",
            "&info->targeti",
            "features"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "parse_reply_info_in",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "66-105",
          "snippet": "static int parse_reply_info_in(void **p, void *end,\n\t\t\t       struct ceph_mds_reply_info_in *info,\n\t\t\t       u64 features)\n{\n\tint err = -EIO;\n\n\tinfo->in = *p;\n\t*p += sizeof(struct ceph_mds_reply_inode) +\n\t\tsizeof(*info->in->fragtree.splits) *\n\t\tle32_to_cpu(info->in->fragtree.nsplits);\n\n\tceph_decode_32_safe(p, end, info->symlink_len, bad);\n\tceph_decode_need(p, end, info->symlink_len, bad);\n\tinfo->symlink = *p;\n\t*p += info->symlink_len;\n\n\tif (features & CEPH_FEATURE_DIRLAYOUTHASH)\n\t\tceph_decode_copy_safe(p, end, &info->dir_layout,\n\t\t\t\t      sizeof(info->dir_layout), bad);\n\telse\n\t\tmemset(&info->dir_layout, 0, sizeof(info->dir_layout));\n\n\tceph_decode_32_safe(p, end, info->xattr_len, bad);\n\tceph_decode_need(p, end, info->xattr_len, bad);\n\tinfo->xattr_data = *p;\n\t*p += info->xattr_len;\n\n\tif (features & CEPH_FEATURE_MDS_INLINE_DATA) {\n\t\tceph_decode_64_safe(p, end, info->inline_version, bad);\n\t\tceph_decode_32_safe(p, end, info->inline_len, bad);\n\t\tceph_decode_need(p, end, info->inline_len, bad);\n\t\tinfo->inline_data = *p;\n\t\t*p += info->inline_len;\n\t} else\n\t\tinfo->inline_version = CEPH_INLINE_NONE;\n\n\treturn 0;\nbad:\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int parse_reply_info_in(void **p, void *end,\n\t\t\t       struct ceph_mds_reply_info_in *info,\n\t\t\t       u64 features)\n{\n\tint err = -EIO;\n\n\tinfo->in = *p;\n\t*p += sizeof(struct ceph_mds_reply_inode) +\n\t\tsizeof(*info->in->fragtree.splits) *\n\t\tle32_to_cpu(info->in->fragtree.nsplits);\n\n\tceph_decode_32_safe(p, end, info->symlink_len, bad);\n\tceph_decode_need(p, end, info->symlink_len, bad);\n\tinfo->symlink = *p;\n\t*p += info->symlink_len;\n\n\tif (features & CEPH_FEATURE_DIRLAYOUTHASH)\n\t\tceph_decode_copy_safe(p, end, &info->dir_layout,\n\t\t\t\t      sizeof(info->dir_layout), bad);\n\telse\n\t\tmemset(&info->dir_layout, 0, sizeof(info->dir_layout));\n\n\tceph_decode_32_safe(p, end, info->xattr_len, bad);\n\tceph_decode_need(p, end, info->xattr_len, bad);\n\tinfo->xattr_data = *p;\n\t*p += info->xattr_len;\n\n\tif (features & CEPH_FEATURE_MDS_INLINE_DATA) {\n\t\tceph_decode_64_safe(p, end, info->inline_version, bad);\n\t\tceph_decode_32_safe(p, end, info->inline_len, bad);\n\t\tceph_decode_need(p, end, info->inline_len, bad);\n\t\tinfo->inline_data = *p;\n\t\t*p += info->inline_len;\n\t} else\n\t\tinfo->inline_version = CEPH_INLINE_NONE;\n\n\treturn 0;\nbad:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_decode_need",
          "args": [
            "p",
            "end",
            "info->dname_len",
            "bad"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_32_safe",
          "args": [
            "p",
            "end",
            "info->dname_len",
            "bad"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "*p > end"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "info->dirfrag->ndist"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "*p + sizeof(*info->dirfrag) > end"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);\n\nstatic int parse_reply_info_trace(void **p, void *end,\n\t\t\t\t  struct ceph_mds_reply_info_parsed *info,\n\t\t\t\t  u64 features)\n{\n\tint err;\n\n\tif (info->head->is_dentry) {\n\t\terr = parse_reply_info_in(p, end, &info->diri, features);\n\t\tif (err < 0)\n\t\t\tgoto out_bad;\n\n\t\tif (unlikely(*p + sizeof(*info->dirfrag) > end))\n\t\t\tgoto bad;\n\t\tinfo->dirfrag = *p;\n\t\t*p += sizeof(*info->dirfrag) +\n\t\t\tsizeof(u32)*le32_to_cpu(info->dirfrag->ndist);\n\t\tif (unlikely(*p > end))\n\t\t\tgoto bad;\n\n\t\tceph_decode_32_safe(p, end, info->dname_len, bad);\n\t\tceph_decode_need(p, end, info->dname_len, bad);\n\t\tinfo->dname = *p;\n\t\t*p += info->dname_len;\n\t\tinfo->dlease = *p;\n\t\t*p += sizeof(*info->dlease);\n\t}\n\n\tif (info->head->is_target) {\n\t\terr = parse_reply_info_in(p, end, &info->targeti, features);\n\t\tif (err < 0)\n\t\t\tgoto out_bad;\n\t}\n\n\tif (unlikely(*p != end))\n\t\tgoto bad;\n\treturn 0;\n\nbad:\n\terr = -EIO;\nout_bad:\n\tpr_err(\"problem parsing mds trace %d\\n\", err);\n\treturn err;\n}"
  },
  {
    "function_name": "parse_reply_info_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
    "lines": "66-105",
    "snippet": "static int parse_reply_info_in(void **p, void *end,\n\t\t\t       struct ceph_mds_reply_info_in *info,\n\t\t\t       u64 features)\n{\n\tint err = -EIO;\n\n\tinfo->in = *p;\n\t*p += sizeof(struct ceph_mds_reply_inode) +\n\t\tsizeof(*info->in->fragtree.splits) *\n\t\tle32_to_cpu(info->in->fragtree.nsplits);\n\n\tceph_decode_32_safe(p, end, info->symlink_len, bad);\n\tceph_decode_need(p, end, info->symlink_len, bad);\n\tinfo->symlink = *p;\n\t*p += info->symlink_len;\n\n\tif (features & CEPH_FEATURE_DIRLAYOUTHASH)\n\t\tceph_decode_copy_safe(p, end, &info->dir_layout,\n\t\t\t\t      sizeof(info->dir_layout), bad);\n\telse\n\t\tmemset(&info->dir_layout, 0, sizeof(info->dir_layout));\n\n\tceph_decode_32_safe(p, end, info->xattr_len, bad);\n\tceph_decode_need(p, end, info->xattr_len, bad);\n\tinfo->xattr_data = *p;\n\t*p += info->xattr_len;\n\n\tif (features & CEPH_FEATURE_MDS_INLINE_DATA) {\n\t\tceph_decode_64_safe(p, end, info->inline_version, bad);\n\t\tceph_decode_32_safe(p, end, info->inline_len, bad);\n\t\tceph_decode_need(p, end, info->inline_len, bad);\n\t\tinfo->inline_data = *p;\n\t\t*p += info->inline_len;\n\t} else\n\t\tinfo->inline_version = CEPH_INLINE_NONE;\n\n\treturn 0;\nbad:\n\treturn err;\n}",
    "includes": [
      "#include <linux/ceph/debugfs.h>",
      "#include <linux/ceph/auth.h>",
      "#include <linux/ceph/pagelist.h>",
      "#include <linux/ceph/decode.h>",
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/ceph_features.h>",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/utsname.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/gfp.h>",
      "#include <linux/slab.h>",
      "#include <linux/wait.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_decode_need",
          "args": [
            "p",
            "end",
            "info->inline_len",
            "bad"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_32_safe",
          "args": [
            "p",
            "end",
            "info->inline_len",
            "bad"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_64_safe",
          "args": [
            "p",
            "end",
            "info->inline_version",
            "bad"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_need",
          "args": [
            "p",
            "end",
            "info->xattr_len",
            "bad"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_32_safe",
          "args": [
            "p",
            "end",
            "info->xattr_len",
            "bad"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&info->dir_layout",
            "0",
            "sizeof(info->dir_layout)"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_copy_safe",
          "args": [
            "p",
            "end",
            "&info->dir_layout",
            "sizeof(info->dir_layout)",
            "bad"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_need",
          "args": [
            "p",
            "end",
            "info->symlink_len",
            "bad"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_32_safe",
          "args": [
            "p",
            "end",
            "info->symlink_len",
            "bad"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "info->in->fragtree.nsplits"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int parse_reply_info_in(void **p, void *end,\n\t\t\t       struct ceph_mds_reply_info_in *info,\n\t\t\t       u64 features)\n{\n\tint err = -EIO;\n\n\tinfo->in = *p;\n\t*p += sizeof(struct ceph_mds_reply_inode) +\n\t\tsizeof(*info->in->fragtree.splits) *\n\t\tle32_to_cpu(info->in->fragtree.nsplits);\n\n\tceph_decode_32_safe(p, end, info->symlink_len, bad);\n\tceph_decode_need(p, end, info->symlink_len, bad);\n\tinfo->symlink = *p;\n\t*p += info->symlink_len;\n\n\tif (features & CEPH_FEATURE_DIRLAYOUTHASH)\n\t\tceph_decode_copy_safe(p, end, &info->dir_layout,\n\t\t\t\t      sizeof(info->dir_layout), bad);\n\telse\n\t\tmemset(&info->dir_layout, 0, sizeof(info->dir_layout));\n\n\tceph_decode_32_safe(p, end, info->xattr_len, bad);\n\tceph_decode_need(p, end, info->xattr_len, bad);\n\tinfo->xattr_data = *p;\n\t*p += info->xattr_len;\n\n\tif (features & CEPH_FEATURE_MDS_INLINE_DATA) {\n\t\tceph_decode_64_safe(p, end, info->inline_version, bad);\n\t\tceph_decode_32_safe(p, end, info->inline_len, bad);\n\t\tceph_decode_need(p, end, info->inline_len, bad);\n\t\tinfo->inline_data = *p;\n\t\t*p += info->inline_len;\n\t} else\n\t\tinfo->inline_version = CEPH_INLINE_NONE;\n\n\treturn 0;\nbad:\n\treturn err;\n}"
  }
]