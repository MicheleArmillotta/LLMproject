[
  {
    "function_name": "ext3_release_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
    "lines": "519-525",
    "snippet": "static int ext3_release_dir (struct inode * inode, struct file * filp)\n{\n       if (filp->private_data)\n\t\text3_htree_free_dir_info(filp->private_data);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/compat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_htree_free_dir_info",
          "args": [
            "filp->private_data"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_htree_free_dir_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
          "lines": "337-341",
          "snippet": "void ext3_htree_free_dir_info(struct dir_private_info *p)\n{\n\tfree_rb_tree_fname(&p->root);\n\tkfree(p);\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nvoid ext3_htree_free_dir_info(struct dir_private_info *p)\n{\n\tfree_rb_tree_fname(&p->root);\n\tkfree(p);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nstatic int ext3_release_dir (struct inode * inode, struct file * filp)\n{\n       if (filp->private_data)\n\t\text3_htree_free_dir_info(filp->private_data);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ext3_dx_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
    "lines": "432-517",
    "snippet": "static int ext3_dx_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct dir_private_info *info = file->private_data;\n\tstruct inode *inode = file_inode(file);\n\tstruct fname *fname;\n\tint\tret;\n\n\tif (!info) {\n\t\tinfo = ext3_htree_create_dir_info(file, ctx->pos);\n\t\tif (!info)\n\t\t\treturn -ENOMEM;\n\t\tfile->private_data = info;\n\t}\n\n\tif (ctx->pos == ext3_get_htree_eof(file))\n\t\treturn 0;\t/* EOF */\n\n\t/* Some one has messed with f_pos; reset the world */\n\tif (info->last_pos != ctx->pos) {\n\t\tfree_rb_tree_fname(&info->root);\n\t\tinfo->curr_node = NULL;\n\t\tinfo->extra_fname = NULL;\n\t\tinfo->curr_hash = pos2maj_hash(file, ctx->pos);\n\t\tinfo->curr_minor_hash = pos2min_hash(file, ctx->pos);\n\t}\n\n\t/*\n\t * If there are any leftover names on the hash collision\n\t * chain, return them first.\n\t */\n\tif (info->extra_fname) {\n\t\tif (!call_filldir(file, ctx, info->extra_fname))\n\t\t\tgoto finished;\n\t\tinfo->extra_fname = NULL;\n\t\tgoto next_node;\n\t} else if (!info->curr_node)\n\t\tinfo->curr_node = rb_first(&info->root);\n\n\twhile (1) {\n\t\t/*\n\t\t * Fill the rbtree if we have no more entries,\n\t\t * or the inode has changed since we last read in the\n\t\t * cached entries.\n\t\t */\n\t\tif ((!info->curr_node) ||\n\t\t    (file->f_version != inode->i_version)) {\n\t\t\tinfo->curr_node = NULL;\n\t\t\tfree_rb_tree_fname(&info->root);\n\t\t\tfile->f_version = inode->i_version;\n\t\t\tret = ext3_htree_fill_tree(file, info->curr_hash,\n\t\t\t\t\t\t   info->curr_minor_hash,\n\t\t\t\t\t\t   &info->next_hash);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (ret == 0) {\n\t\t\t\tctx->pos = ext3_get_htree_eof(file);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tinfo->curr_node = rb_first(&info->root);\n\t\t}\n\n\t\tfname = rb_entry(info->curr_node, struct fname, rb_hash);\n\t\tinfo->curr_hash = fname->hash;\n\t\tinfo->curr_minor_hash = fname->minor_hash;\n\t\tif (!call_filldir(file, ctx, fname))\n\t\t\tbreak;\n\tnext_node:\n\t\tinfo->curr_node = rb_next(info->curr_node);\n\t\tif (info->curr_node) {\n\t\t\tfname = rb_entry(info->curr_node, struct fname,\n\t\t\t\t\t rb_hash);\n\t\t\tinfo->curr_hash = fname->hash;\n\t\t\tinfo->curr_minor_hash = fname->minor_hash;\n\t\t} else {\n\t\t\tif (info->next_hash == ~0) {\n\t\t\t\tctx->pos = ext3_get_htree_eof(file);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tinfo->curr_hash = info->next_hash;\n\t\t\tinfo->curr_minor_hash = 0;\n\t\t}\n\t}\nfinished:\n\tinfo->last_pos = ctx->pos;\n\treturn 0;\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/compat.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_dx_readdir(struct file *, struct dir_context *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_get_htree_eof",
          "args": [
            "file"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_get_htree_eof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
          "lines": "256-263",
          "snippet": "static inline loff_t ext3_get_htree_eof(struct file *filp)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn EXT3_HTREE_EOF_32BIT;\n\telse\n\t\treturn EXT3_HTREE_EOF_64BIT;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nstatic inline loff_t ext3_get_htree_eof(struct file *filp)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn EXT3_HTREE_EOF_32BIT;\n\telse\n\t\treturn EXT3_HTREE_EOF_64BIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "info->curr_node",
            "structfname",
            "rb_hash"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "info->curr_node"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call_filldir",
          "args": [
            "file",
            "ctx",
            "fname"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "call_filldir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
          "lines": "408-430",
          "snippet": "static bool call_filldir(struct file *file, struct dir_context *ctx,\n\t\t\tstruct fname *fname)\n{\n\tstruct dir_private_info *info = file->private_data;\n\tstruct inode *inode = file_inode(file);\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (!fname) {\n\t\tprintk(\"call_filldir: called with null fname?!?\\n\");\n\t\treturn true;\n\t}\n\tctx->pos = hash2pos(file, fname->hash, fname->minor_hash);\n\twhile (fname) {\n\t\tif (!dir_emit(ctx, fname->name, fname->name_len,\n\t\t\t\tfname->inode,\n\t\t\t\tget_dtype(sb, fname->file_type))) {\n\t\t\tinfo->extra_fname = fname;\n\t\t\treturn false;\n\t\t}\n\t\tfname = fname->next;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_dx_readdir(struct file *, struct dir_context *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nstatic int ext3_dx_readdir(struct file *, struct dir_context *);\n\nstatic bool call_filldir(struct file *file, struct dir_context *ctx,\n\t\t\tstruct fname *fname)\n{\n\tstruct dir_private_info *info = file->private_data;\n\tstruct inode *inode = file_inode(file);\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (!fname) {\n\t\tprintk(\"call_filldir: called with null fname?!?\\n\");\n\t\treturn true;\n\t}\n\tctx->pos = hash2pos(file, fname->hash, fname->minor_hash);\n\twhile (fname) {\n\t\tif (!dir_emit(ctx, fname->name, fname->name_len,\n\t\t\t\tfname->inode,\n\t\t\t\tget_dtype(sb, fname->file_type))) {\n\t\t\tinfo->extra_fname = fname;\n\t\t\treturn false;\n\t\t}\n\t\tfname = fname->next;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "info->curr_node",
            "structfname",
            "rb_hash"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&info->root"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_htree_fill_tree",
          "args": [
            "file",
            "info->curr_hash",
            "info->curr_minor_hash",
            "&info->next_hash"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_htree_fill_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/namei.c",
          "lines": "609-689",
          "snippet": "int ext3_htree_fill_tree(struct file *dir_file, __u32 start_hash,\n\t\t\t __u32 start_minor_hash, __u32 *next_hash)\n{\n\tstruct dx_hash_info hinfo;\n\tstruct ext3_dir_entry_2 *de;\n\tstruct dx_frame frames[2], *frame;\n\tstruct inode *dir;\n\tint block, err;\n\tint count = 0;\n\tint ret;\n\t__u32 hashval;\n\n\tdxtrace(printk(\"In htree_fill_tree, start hash: %x:%x\\n\", start_hash,\n\t\t       start_minor_hash));\n\tdir = file_inode(dir_file);\n\tif (!(EXT3_I(dir)->i_flags & EXT3_INDEX_FL)) {\n\t\thinfo.hash_version = EXT3_SB(dir->i_sb)->s_def_hash_version;\n\t\tif (hinfo.hash_version <= DX_HASH_TEA)\n\t\t\thinfo.hash_version +=\n\t\t\t\tEXT3_SB(dir->i_sb)->s_hash_unsigned;\n\t\thinfo.seed = EXT3_SB(dir->i_sb)->s_hash_seed;\n\t\tcount = htree_dirblock_to_tree(dir_file, dir, 0, &hinfo,\n\t\t\t\t\t       start_hash, start_minor_hash);\n\t\t*next_hash = ~0;\n\t\treturn count;\n\t}\n\thinfo.hash = start_hash;\n\thinfo.minor_hash = 0;\n\tframe = dx_probe(NULL, file_inode(dir_file), &hinfo, frames, &err);\n\tif (!frame)\n\t\treturn err;\n\n\t/* Add '.' and '..' from the htree header */\n\tif (!start_hash && !start_minor_hash) {\n\t\tde = (struct ext3_dir_entry_2 *) frames[0].bh->b_data;\n\t\tif ((err = ext3_htree_store_dirent(dir_file, 0, 0, de)) != 0)\n\t\t\tgoto errout;\n\t\tcount++;\n\t}\n\tif (start_hash < 2 || (start_hash ==2 && start_minor_hash==0)) {\n\t\tde = (struct ext3_dir_entry_2 *) frames[0].bh->b_data;\n\t\tde = ext3_next_entry(de);\n\t\tif ((err = ext3_htree_store_dirent(dir_file, 2, 0, de)) != 0)\n\t\t\tgoto errout;\n\t\tcount++;\n\t}\n\n\twhile (1) {\n\t\tblock = dx_get_block(frame->at);\n\t\tret = htree_dirblock_to_tree(dir_file, dir, block, &hinfo,\n\t\t\t\t\t     start_hash, start_minor_hash);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto errout;\n\t\t}\n\t\tcount += ret;\n\t\thashval = ~0;\n\t\tret = ext3_htree_next_block(dir, HASH_NB_ALWAYS,\n\t\t\t\t\t    frame, frames, &hashval);\n\t\t*next_hash = hashval;\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto errout;\n\t\t}\n\t\t/*\n\t\t * Stop if:  (a) there are no more entries, or\n\t\t * (b) we have inserted at least one entry and the\n\t\t * next hash value is not a continuation\n\t\t */\n\t\tif ((ret == 0) ||\n\t\t    (count && ((hashval & 1) == 0)))\n\t\t\tbreak;\n\t}\n\tdx_release(frames);\n\tdxtrace(printk(\"Fill tree: returned %d entries, next hash: %x\\n\",\n\t\t       count, *next_hash));\n\treturn count;\nerrout:\n\tdx_release(frames);\n\treturn (err);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"namei.h\"",
            "#include \"ext3.h\"",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline unsigned dx_get_block (struct dx_entry *entry);",
            "static void dx_set_block (struct dx_entry *entry, unsigned value);",
            "static inline unsigned dx_get_hash (struct dx_entry *entry);",
            "static void dx_set_hash (struct dx_entry *entry, unsigned value);",
            "static unsigned dx_get_count (struct dx_entry *entries);",
            "static unsigned dx_get_limit (struct dx_entry *entries);",
            "static void dx_set_count (struct dx_entry *entries, unsigned value);",
            "static void dx_set_limit (struct dx_entry *entries, unsigned value);",
            "static unsigned dx_node_limit (struct inode *dir);",
            "static struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);",
            "static void dx_release (struct dx_frame *frames);",
            "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
            "static struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);",
            "static void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);",
            "static int ext3_htree_next_block(struct inode *dir, __u32 hash,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t struct dx_frame *frames,\n\t\t\t\t __u32 *start_hash);",
            "static struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);",
            "static int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"namei.h\"\n#include \"ext3.h\"\n#include <linux/quotaops.h>\n\nstatic inline unsigned dx_get_block (struct dx_entry *entry);\nstatic void dx_set_block (struct dx_entry *entry, unsigned value);\nstatic inline unsigned dx_get_hash (struct dx_entry *entry);\nstatic void dx_set_hash (struct dx_entry *entry, unsigned value);\nstatic unsigned dx_get_count (struct dx_entry *entries);\nstatic unsigned dx_get_limit (struct dx_entry *entries);\nstatic void dx_set_count (struct dx_entry *entries, unsigned value);\nstatic void dx_set_limit (struct dx_entry *entries, unsigned value);\nstatic unsigned dx_node_limit (struct inode *dir);\nstatic struct dx_frame *dx_probe(struct qstr *entry,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t int *err);\nstatic void dx_release (struct dx_frame *frames);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic struct ext3_dir_entry_2 *dx_move_dirents (char *from, char *to,\n\t\tstruct dx_map_entry *offsets, int count);\nstatic void dx_insert_block (struct dx_frame *frame, u32 hash, u32 block);\nstatic int ext3_htree_next_block(struct inode *dir, __u32 hash,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t struct dx_frame *frames,\n\t\t\t\t __u32 *start_hash);\nstatic struct buffer_head * ext3_dx_find_entry(struct inode *dir,\n\t\t\tstruct qstr *entry, struct ext3_dir_entry_2 **res_dir,\n\t\t\tint *err);\nstatic int ext3_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext3_htree_fill_tree(struct file *dir_file, __u32 start_hash,\n\t\t\t __u32 start_minor_hash, __u32 *next_hash)\n{\n\tstruct dx_hash_info hinfo;\n\tstruct ext3_dir_entry_2 *de;\n\tstruct dx_frame frames[2], *frame;\n\tstruct inode *dir;\n\tint block, err;\n\tint count = 0;\n\tint ret;\n\t__u32 hashval;\n\n\tdxtrace(printk(\"In htree_fill_tree, start hash: %x:%x\\n\", start_hash,\n\t\t       start_minor_hash));\n\tdir = file_inode(dir_file);\n\tif (!(EXT3_I(dir)->i_flags & EXT3_INDEX_FL)) {\n\t\thinfo.hash_version = EXT3_SB(dir->i_sb)->s_def_hash_version;\n\t\tif (hinfo.hash_version <= DX_HASH_TEA)\n\t\t\thinfo.hash_version +=\n\t\t\t\tEXT3_SB(dir->i_sb)->s_hash_unsigned;\n\t\thinfo.seed = EXT3_SB(dir->i_sb)->s_hash_seed;\n\t\tcount = htree_dirblock_to_tree(dir_file, dir, 0, &hinfo,\n\t\t\t\t\t       start_hash, start_minor_hash);\n\t\t*next_hash = ~0;\n\t\treturn count;\n\t}\n\thinfo.hash = start_hash;\n\thinfo.minor_hash = 0;\n\tframe = dx_probe(NULL, file_inode(dir_file), &hinfo, frames, &err);\n\tif (!frame)\n\t\treturn err;\n\n\t/* Add '.' and '..' from the htree header */\n\tif (!start_hash && !start_minor_hash) {\n\t\tde = (struct ext3_dir_entry_2 *) frames[0].bh->b_data;\n\t\tif ((err = ext3_htree_store_dirent(dir_file, 0, 0, de)) != 0)\n\t\t\tgoto errout;\n\t\tcount++;\n\t}\n\tif (start_hash < 2 || (start_hash ==2 && start_minor_hash==0)) {\n\t\tde = (struct ext3_dir_entry_2 *) frames[0].bh->b_data;\n\t\tde = ext3_next_entry(de);\n\t\tif ((err = ext3_htree_store_dirent(dir_file, 2, 0, de)) != 0)\n\t\t\tgoto errout;\n\t\tcount++;\n\t}\n\n\twhile (1) {\n\t\tblock = dx_get_block(frame->at);\n\t\tret = htree_dirblock_to_tree(dir_file, dir, block, &hinfo,\n\t\t\t\t\t     start_hash, start_minor_hash);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto errout;\n\t\t}\n\t\tcount += ret;\n\t\thashval = ~0;\n\t\tret = ext3_htree_next_block(dir, HASH_NB_ALWAYS,\n\t\t\t\t\t    frame, frames, &hashval);\n\t\t*next_hash = hashval;\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto errout;\n\t\t}\n\t\t/*\n\t\t * Stop if:  (a) there are no more entries, or\n\t\t * (b) we have inserted at least one entry and the\n\t\t * next hash value is not a continuation\n\t\t */\n\t\tif ((ret == 0) ||\n\t\t    (count && ((hashval & 1) == 0)))\n\t\t\tbreak;\n\t}\n\tdx_release(frames);\n\tdxtrace(printk(\"Fill tree: returned %d entries, next hash: %x\\n\",\n\t\t       count, *next_hash));\n\treturn count;\nerrout:\n\tdx_release(frames);\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_rb_tree_fname",
          "args": [
            "&info->root"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "free_rb_tree_fname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
          "lines": "310-322",
          "snippet": "static void free_rb_tree_fname(struct rb_root *root)\n{\n\tstruct fname *fname, *next;\n\n\trbtree_postorder_for_each_entry_safe(fname, next, root, rb_hash)\n\t\tdo {\n\t\t\tstruct fname *old = fname;\n\t\t\tfname = fname->next;\n\t\t\tkfree(old);\n\t\t} while (fname);\n\n\t*root = RB_ROOT;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nstatic void free_rb_tree_fname(struct rb_root *root)\n{\n\tstruct fname *fname, *next;\n\n\trbtree_postorder_for_each_entry_safe(fname, next, root, rb_hash)\n\t\tdo {\n\t\t\tstruct fname *old = fname;\n\t\t\tfname = fname->next;\n\t\t\tkfree(old);\n\t\t} while (fname);\n\n\t*root = RB_ROOT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&info->root"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pos2min_hash",
          "args": [
            "file",
            "ctx->pos"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "pos2min_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
          "lines": "244-251",
          "snippet": "static inline __u32 pos2min_hash(struct file *filp, loff_t pos)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn 0;\n\telse\n\t\treturn pos & 0xffffffff;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nstatic inline __u32 pos2min_hash(struct file *filp, loff_t pos)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn 0;\n\telse\n\t\treturn pos & 0xffffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pos2maj_hash",
          "args": [
            "file",
            "ctx->pos"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "pos2maj_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
          "lines": "235-242",
          "snippet": "static inline __u32 pos2maj_hash(struct file *filp, loff_t pos)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn (pos << 1) & 0xffffffff;\n\telse\n\t\treturn ((pos >> 32) << 1) & 0xffffffff;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nstatic inline __u32 pos2maj_hash(struct file *filp, loff_t pos)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn (pos << 1) & 0xffffffff;\n\telse\n\t\treturn ((pos >> 32) << 1) & 0xffffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_htree_create_dir_info",
          "args": [
            "file",
            "ctx->pos"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_htree_create_dir_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
          "lines": "324-335",
          "snippet": "static struct dir_private_info *ext3_htree_create_dir_info(struct file *filp,\n\t\t\t\t\t\t\t   loff_t pos)\n{\n\tstruct dir_private_info *p;\n\n\tp = kzalloc(sizeof(struct dir_private_info), GFP_KERNEL);\n\tif (!p)\n\t\treturn NULL;\n\tp->curr_hash = pos2maj_hash(filp, pos);\n\tp->curr_minor_hash = pos2min_hash(filp, pos);\n\treturn p;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nstatic struct dir_private_info *ext3_htree_create_dir_info(struct file *filp,\n\t\t\t\t\t\t\t   loff_t pos)\n{\n\tstruct dir_private_info *p;\n\n\tp = kzalloc(sizeof(struct dir_private_info), GFP_KERNEL);\n\tif (!p)\n\t\treturn NULL;\n\tp->curr_hash = pos2maj_hash(filp, pos);\n\tp->curr_minor_hash = pos2min_hash(filp, pos);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nstatic int ext3_dx_readdir(struct file *, struct dir_context *);\n\nstatic int ext3_dx_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct dir_private_info *info = file->private_data;\n\tstruct inode *inode = file_inode(file);\n\tstruct fname *fname;\n\tint\tret;\n\n\tif (!info) {\n\t\tinfo = ext3_htree_create_dir_info(file, ctx->pos);\n\t\tif (!info)\n\t\t\treturn -ENOMEM;\n\t\tfile->private_data = info;\n\t}\n\n\tif (ctx->pos == ext3_get_htree_eof(file))\n\t\treturn 0;\t/* EOF */\n\n\t/* Some one has messed with f_pos; reset the world */\n\tif (info->last_pos != ctx->pos) {\n\t\tfree_rb_tree_fname(&info->root);\n\t\tinfo->curr_node = NULL;\n\t\tinfo->extra_fname = NULL;\n\t\tinfo->curr_hash = pos2maj_hash(file, ctx->pos);\n\t\tinfo->curr_minor_hash = pos2min_hash(file, ctx->pos);\n\t}\n\n\t/*\n\t * If there are any leftover names on the hash collision\n\t * chain, return them first.\n\t */\n\tif (info->extra_fname) {\n\t\tif (!call_filldir(file, ctx, info->extra_fname))\n\t\t\tgoto finished;\n\t\tinfo->extra_fname = NULL;\n\t\tgoto next_node;\n\t} else if (!info->curr_node)\n\t\tinfo->curr_node = rb_first(&info->root);\n\n\twhile (1) {\n\t\t/*\n\t\t * Fill the rbtree if we have no more entries,\n\t\t * or the inode has changed since we last read in the\n\t\t * cached entries.\n\t\t */\n\t\tif ((!info->curr_node) ||\n\t\t    (file->f_version != inode->i_version)) {\n\t\t\tinfo->curr_node = NULL;\n\t\t\tfree_rb_tree_fname(&info->root);\n\t\t\tfile->f_version = inode->i_version;\n\t\t\tret = ext3_htree_fill_tree(file, info->curr_hash,\n\t\t\t\t\t\t   info->curr_minor_hash,\n\t\t\t\t\t\t   &info->next_hash);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (ret == 0) {\n\t\t\t\tctx->pos = ext3_get_htree_eof(file);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tinfo->curr_node = rb_first(&info->root);\n\t\t}\n\n\t\tfname = rb_entry(info->curr_node, struct fname, rb_hash);\n\t\tinfo->curr_hash = fname->hash;\n\t\tinfo->curr_minor_hash = fname->minor_hash;\n\t\tif (!call_filldir(file, ctx, fname))\n\t\t\tbreak;\n\tnext_node:\n\t\tinfo->curr_node = rb_next(info->curr_node);\n\t\tif (info->curr_node) {\n\t\t\tfname = rb_entry(info->curr_node, struct fname,\n\t\t\t\t\t rb_hash);\n\t\t\tinfo->curr_hash = fname->hash;\n\t\t\tinfo->curr_minor_hash = fname->minor_hash;\n\t\t} else {\n\t\t\tif (info->next_hash == ~0) {\n\t\t\t\tctx->pos = ext3_get_htree_eof(file);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tinfo->curr_hash = info->next_hash;\n\t\t\tinfo->curr_minor_hash = 0;\n\t\t}\n\t}\nfinished:\n\tinfo->last_pos = ctx->pos;\n\treturn 0;\n}"
  },
  {
    "function_name": "call_filldir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
    "lines": "408-430",
    "snippet": "static bool call_filldir(struct file *file, struct dir_context *ctx,\n\t\t\tstruct fname *fname)\n{\n\tstruct dir_private_info *info = file->private_data;\n\tstruct inode *inode = file_inode(file);\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (!fname) {\n\t\tprintk(\"call_filldir: called with null fname?!?\\n\");\n\t\treturn true;\n\t}\n\tctx->pos = hash2pos(file, fname->hash, fname->minor_hash);\n\twhile (fname) {\n\t\tif (!dir_emit(ctx, fname->name, fname->name_len,\n\t\t\t\tfname->inode,\n\t\t\t\tget_dtype(sb, fname->file_type))) {\n\t\t\tinfo->extra_fname = fname;\n\t\t\treturn false;\n\t\t}\n\t\tfname = fname->next;\n\t}\n\treturn true;\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/compat.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_dx_readdir(struct file *, struct dir_context *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "fname->name",
            "fname->name_len",
            "fname->inode",
            "get_dtype(sb, fname->file_type)"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dtype",
          "args": [
            "sb",
            "fname->file_type"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "get_dtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
          "lines": "33-40",
          "snippet": "static unsigned char get_dtype(struct super_block *sb, int filetype)\n{\n\tif (!EXT3_HAS_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_FILETYPE) ||\n\t    (filetype >= EXT3_FT_MAX))\n\t\treturn DT_UNKNOWN;\n\n\treturn (ext3_filetype_table[filetype]);\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned char ext3_filetype_table[] = {\n\tDT_UNKNOWN, DT_REG, DT_DIR, DT_CHR, DT_BLK, DT_FIFO, DT_SOCK, DT_LNK\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nstatic unsigned char ext3_filetype_table[] = {\n\tDT_UNKNOWN, DT_REG, DT_DIR, DT_CHR, DT_BLK, DT_FIFO, DT_SOCK, DT_LNK\n};\n\nstatic unsigned char get_dtype(struct super_block *sb, int filetype)\n{\n\tif (!EXT3_HAS_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_FILETYPE) ||\n\t    (filetype >= EXT3_FT_MAX))\n\t\treturn DT_UNKNOWN;\n\n\treturn (ext3_filetype_table[filetype]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash2pos",
          "args": [
            "file",
            "fname->hash",
            "fname->minor_hash"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "hash2pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
          "lines": "226-233",
          "snippet": "static inline loff_t hash2pos(struct file *filp, __u32 major, __u32 minor)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn major >> 1;\n\telse\n\t\treturn ((__u64)(major >> 1) << 32) | (__u64)minor;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nstatic inline loff_t hash2pos(struct file *filp, __u32 major, __u32 minor)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn major >> 1;\n\telse\n\t\treturn ((__u64)(major >> 1) << 32) | (__u64)minor;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"call_filldir: called with null fname?!?\\n\""
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nstatic int ext3_dx_readdir(struct file *, struct dir_context *);\n\nstatic bool call_filldir(struct file *file, struct dir_context *ctx,\n\t\t\tstruct fname *fname)\n{\n\tstruct dir_private_info *info = file->private_data;\n\tstruct inode *inode = file_inode(file);\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (!fname) {\n\t\tprintk(\"call_filldir: called with null fname?!?\\n\");\n\t\treturn true;\n\t}\n\tctx->pos = hash2pos(file, fname->hash, fname->minor_hash);\n\twhile (fname) {\n\t\tif (!dir_emit(ctx, fname->name, fname->name_len,\n\t\t\t\tfname->inode,\n\t\t\t\tget_dtype(sb, fname->file_type))) {\n\t\t\tinfo->extra_fname = fname;\n\t\t\treturn false;\n\t\t}\n\t\tfname = fname->next;\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "ext3_htree_store_dirent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
    "lines": "346-399",
    "snippet": "int ext3_htree_store_dirent(struct file *dir_file, __u32 hash,\n\t\t\t     __u32 minor_hash,\n\t\t\t     struct ext3_dir_entry_2 *dirent)\n{\n\tstruct rb_node **p, *parent = NULL;\n\tstruct fname * fname, *new_fn;\n\tstruct dir_private_info *info;\n\tint len;\n\n\tinfo = (struct dir_private_info *) dir_file->private_data;\n\tp = &info->root.rb_node;\n\n\t/* Create and allocate the fname structure */\n\tlen = sizeof(struct fname) + dirent->name_len + 1;\n\tnew_fn = kzalloc(len, GFP_KERNEL);\n\tif (!new_fn)\n\t\treturn -ENOMEM;\n\tnew_fn->hash = hash;\n\tnew_fn->minor_hash = minor_hash;\n\tnew_fn->inode = le32_to_cpu(dirent->inode);\n\tnew_fn->name_len = dirent->name_len;\n\tnew_fn->file_type = dirent->file_type;\n\tmemcpy(new_fn->name, dirent->name, dirent->name_len);\n\tnew_fn->name[dirent->name_len] = 0;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tfname = rb_entry(parent, struct fname, rb_hash);\n\n\t\t/*\n\t\t * If the hash and minor hash match up, then we put\n\t\t * them on a linked list.  This rarely happens...\n\t\t */\n\t\tif ((new_fn->hash == fname->hash) &&\n\t\t    (new_fn->minor_hash == fname->minor_hash)) {\n\t\t\tnew_fn->next = fname->next;\n\t\t\tfname->next = new_fn;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (new_fn->hash < fname->hash)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (new_fn->hash > fname->hash)\n\t\t\tp = &(*p)->rb_right;\n\t\telse if (new_fn->minor_hash < fname->minor_hash)\n\t\t\tp = &(*p)->rb_left;\n\t\telse /* if (new_fn->minor_hash > fname->minor_hash) */\n\t\t\tp = &(*p)->rb_right;\n\t}\n\n\trb_link_node(&new_fn->rb_hash, parent, p);\n\trb_insert_color(&new_fn->rb_hash, &info->root);\n\treturn 0;\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/compat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&new_fn->rb_hash",
            "&info->root"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&new_fn->rb_hash",
            "parent",
            "p"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structfname",
            "rb_hash"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new_fn->name",
            "dirent->name",
            "dirent->name_len"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dirent->inode"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "len",
            "GFP_KERNEL"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nint ext3_htree_store_dirent(struct file *dir_file, __u32 hash,\n\t\t\t     __u32 minor_hash,\n\t\t\t     struct ext3_dir_entry_2 *dirent)\n{\n\tstruct rb_node **p, *parent = NULL;\n\tstruct fname * fname, *new_fn;\n\tstruct dir_private_info *info;\n\tint len;\n\n\tinfo = (struct dir_private_info *) dir_file->private_data;\n\tp = &info->root.rb_node;\n\n\t/* Create and allocate the fname structure */\n\tlen = sizeof(struct fname) + dirent->name_len + 1;\n\tnew_fn = kzalloc(len, GFP_KERNEL);\n\tif (!new_fn)\n\t\treturn -ENOMEM;\n\tnew_fn->hash = hash;\n\tnew_fn->minor_hash = minor_hash;\n\tnew_fn->inode = le32_to_cpu(dirent->inode);\n\tnew_fn->name_len = dirent->name_len;\n\tnew_fn->file_type = dirent->file_type;\n\tmemcpy(new_fn->name, dirent->name, dirent->name_len);\n\tnew_fn->name[dirent->name_len] = 0;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tfname = rb_entry(parent, struct fname, rb_hash);\n\n\t\t/*\n\t\t * If the hash and minor hash match up, then we put\n\t\t * them on a linked list.  This rarely happens...\n\t\t */\n\t\tif ((new_fn->hash == fname->hash) &&\n\t\t    (new_fn->minor_hash == fname->minor_hash)) {\n\t\t\tnew_fn->next = fname->next;\n\t\t\tfname->next = new_fn;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (new_fn->hash < fname->hash)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (new_fn->hash > fname->hash)\n\t\t\tp = &(*p)->rb_right;\n\t\telse if (new_fn->minor_hash < fname->minor_hash)\n\t\t\tp = &(*p)->rb_left;\n\t\telse /* if (new_fn->minor_hash > fname->minor_hash) */\n\t\t\tp = &(*p)->rb_right;\n\t}\n\n\trb_link_node(&new_fn->rb_hash, parent, p);\n\trb_insert_color(&new_fn->rb_hash, &info->root);\n\treturn 0;\n}"
  },
  {
    "function_name": "ext3_htree_free_dir_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
    "lines": "337-341",
    "snippet": "void ext3_htree_free_dir_info(struct dir_private_info *p)\n{\n\tfree_rb_tree_fname(&p->root);\n\tkfree(p);\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/compat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "p"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_rb_tree_fname",
          "args": [
            "&p->root"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "free_rb_tree_fname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
          "lines": "310-322",
          "snippet": "static void free_rb_tree_fname(struct rb_root *root)\n{\n\tstruct fname *fname, *next;\n\n\trbtree_postorder_for_each_entry_safe(fname, next, root, rb_hash)\n\t\tdo {\n\t\t\tstruct fname *old = fname;\n\t\t\tfname = fname->next;\n\t\t\tkfree(old);\n\t\t} while (fname);\n\n\t*root = RB_ROOT;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nstatic void free_rb_tree_fname(struct rb_root *root)\n{\n\tstruct fname *fname, *next;\n\n\trbtree_postorder_for_each_entry_safe(fname, next, root, rb_hash)\n\t\tdo {\n\t\t\tstruct fname *old = fname;\n\t\t\tfname = fname->next;\n\t\t\tkfree(old);\n\t\t} while (fname);\n\n\t*root = RB_ROOT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nvoid ext3_htree_free_dir_info(struct dir_private_info *p)\n{\n\tfree_rb_tree_fname(&p->root);\n\tkfree(p);\n}"
  },
  {
    "function_name": "ext3_htree_create_dir_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
    "lines": "324-335",
    "snippet": "static struct dir_private_info *ext3_htree_create_dir_info(struct file *filp,\n\t\t\t\t\t\t\t   loff_t pos)\n{\n\tstruct dir_private_info *p;\n\n\tp = kzalloc(sizeof(struct dir_private_info), GFP_KERNEL);\n\tif (!p)\n\t\treturn NULL;\n\tp->curr_hash = pos2maj_hash(filp, pos);\n\tp->curr_minor_hash = pos2min_hash(filp, pos);\n\treturn p;\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/compat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pos2min_hash",
          "args": [
            "filp",
            "pos"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "pos2min_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
          "lines": "244-251",
          "snippet": "static inline __u32 pos2min_hash(struct file *filp, loff_t pos)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn 0;\n\telse\n\t\treturn pos & 0xffffffff;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nstatic inline __u32 pos2min_hash(struct file *filp, loff_t pos)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn 0;\n\telse\n\t\treturn pos & 0xffffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pos2maj_hash",
          "args": [
            "filp",
            "pos"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "pos2maj_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
          "lines": "235-242",
          "snippet": "static inline __u32 pos2maj_hash(struct file *filp, loff_t pos)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn (pos << 1) & 0xffffffff;\n\telse\n\t\treturn ((pos >> 32) << 1) & 0xffffffff;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nstatic inline __u32 pos2maj_hash(struct file *filp, loff_t pos)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn (pos << 1) & 0xffffffff;\n\telse\n\t\treturn ((pos >> 32) << 1) & 0xffffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct dir_private_info)",
            "GFP_KERNEL"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nstatic struct dir_private_info *ext3_htree_create_dir_info(struct file *filp,\n\t\t\t\t\t\t\t   loff_t pos)\n{\n\tstruct dir_private_info *p;\n\n\tp = kzalloc(sizeof(struct dir_private_info), GFP_KERNEL);\n\tif (!p)\n\t\treturn NULL;\n\tp->curr_hash = pos2maj_hash(filp, pos);\n\tp->curr_minor_hash = pos2min_hash(filp, pos);\n\treturn p;\n}"
  },
  {
    "function_name": "free_rb_tree_fname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
    "lines": "310-322",
    "snippet": "static void free_rb_tree_fname(struct rb_root *root)\n{\n\tstruct fname *fname, *next;\n\n\trbtree_postorder_for_each_entry_safe(fname, next, root, rb_hash)\n\t\tdo {\n\t\t\tstruct fname *old = fname;\n\t\t\tfname = fname->next;\n\t\t\tkfree(old);\n\t\t} while (fname);\n\n\t*root = RB_ROOT;\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/compat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "old"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rbtree_postorder_for_each_entry_safe",
          "args": [
            "fname",
            "next",
            "root",
            "rb_hash"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nstatic void free_rb_tree_fname(struct rb_root *root)\n{\n\tstruct fname *fname, *next;\n\n\trbtree_postorder_for_each_entry_safe(fname, next, root, rb_hash)\n\t\tdo {\n\t\t\tstruct fname *old = fname;\n\t\t\tfname = fname->next;\n\t\t\tkfree(old);\n\t\t} while (fname);\n\n\t*root = RB_ROOT;\n}"
  },
  {
    "function_name": "ext3_dir_llseek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
    "lines": "278-289",
    "snippet": "static loff_t ext3_dir_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tint dx_dir = is_dx_dir(inode);\n\tloff_t htree_max = ext3_get_htree_eof(file);\n\n\tif (likely(dx_dir))\n\t\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\t        htree_max, htree_max);\n\telse\n\t\treturn generic_file_llseek(file, offset, whence);\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/compat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_file_llseek",
          "args": [
            "file",
            "offset",
            "whence"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "generic_file_llseek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "147-154",
          "snippet": "loff_t generic_file_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\n\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\tinode->i_sb->s_maxbytes,\n\t\t\t\t\ti_size_read(inode));\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t generic_file_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\n\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\tinode->i_sb->s_maxbytes,\n\t\t\t\t\ti_size_read(inode));\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_file_llseek_size",
          "args": [
            "file",
            "offset",
            "whence",
            "htree_max",
            "htree_max"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "generic_file_llseek_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "88-134",
          "snippet": "loff_t\ngeneric_file_llseek_size(struct file *file, loff_t offset, int whence,\n\t\tloff_t maxsize, loff_t eof)\n{\n\tswitch (whence) {\n\tcase SEEK_END:\n\t\toffset += eof;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\t/*\n\t\t * Here we special-case the lseek(fd, 0, SEEK_CUR)\n\t\t * position-querying operation.  Avoid rewriting the \"same\"\n\t\t * f_pos value back to the file because a concurrent read(),\n\t\t * write() or lseek() might have altered it\n\t\t */\n\t\tif (offset == 0)\n\t\t\treturn file->f_pos;\n\t\t/*\n\t\t * f_lock protects against read/modify/write race with other\n\t\t * SEEK_CURs. Note that parallel writes and reads behave\n\t\t * like SEEK_SET.\n\t\t */\n\t\tspin_lock(&file->f_lock);\n\t\toffset = vfs_setpos(file, file->f_pos + offset, maxsize);\n\t\tspin_unlock(&file->f_lock);\n\t\treturn offset;\n\tcase SEEK_DATA:\n\t\t/*\n\t\t * In the generic case the entire file is data, so as long as\n\t\t * offset isn't at the end of the file then the offset is data.\n\t\t */\n\t\tif (offset >= eof)\n\t\t\treturn -ENXIO;\n\t\tbreak;\n\tcase SEEK_HOLE:\n\t\t/*\n\t\t * There is a virtual hole at the end of the file, so as long as\n\t\t * offset isn't i_size or larger, return i_size.\n\t\t */\n\t\tif (offset >= eof)\n\t\t\treturn -ENXIO;\n\t\toffset = eof;\n\t\tbreak;\n\t}\n\n\treturn vfs_setpos(file, offset, maxsize);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t\ngeneric_file_llseek_size(struct file *file, loff_t offset, int whence,\n\t\tloff_t maxsize, loff_t eof)\n{\n\tswitch (whence) {\n\tcase SEEK_END:\n\t\toffset += eof;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\t/*\n\t\t * Here we special-case the lseek(fd, 0, SEEK_CUR)\n\t\t * position-querying operation.  Avoid rewriting the \"same\"\n\t\t * f_pos value back to the file because a concurrent read(),\n\t\t * write() or lseek() might have altered it\n\t\t */\n\t\tif (offset == 0)\n\t\t\treturn file->f_pos;\n\t\t/*\n\t\t * f_lock protects against read/modify/write race with other\n\t\t * SEEK_CURs. Note that parallel writes and reads behave\n\t\t * like SEEK_SET.\n\t\t */\n\t\tspin_lock(&file->f_lock);\n\t\toffset = vfs_setpos(file, file->f_pos + offset, maxsize);\n\t\tspin_unlock(&file->f_lock);\n\t\treturn offset;\n\tcase SEEK_DATA:\n\t\t/*\n\t\t * In the generic case the entire file is data, so as long as\n\t\t * offset isn't at the end of the file then the offset is data.\n\t\t */\n\t\tif (offset >= eof)\n\t\t\treturn -ENXIO;\n\t\tbreak;\n\tcase SEEK_HOLE:\n\t\t/*\n\t\t * There is a virtual hole at the end of the file, so as long as\n\t\t * offset isn't i_size or larger, return i_size.\n\t\t */\n\t\tif (offset >= eof)\n\t\t\treturn -ENXIO;\n\t\toffset = eof;\n\t\tbreak;\n\t}\n\n\treturn vfs_setpos(file, offset, maxsize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "dx_dir"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_get_htree_eof",
          "args": [
            "file"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_get_htree_eof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
          "lines": "256-263",
          "snippet": "static inline loff_t ext3_get_htree_eof(struct file *filp)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn EXT3_HTREE_EOF_32BIT;\n\telse\n\t\treturn EXT3_HTREE_EOF_64BIT;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nstatic inline loff_t ext3_get_htree_eof(struct file *filp)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn EXT3_HTREE_EOF_32BIT;\n\telse\n\t\treturn EXT3_HTREE_EOF_64BIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_dx_dir",
          "args": [
            "inode"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "is_dx_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
          "lines": "49-60",
          "snippet": "static int is_dx_dir(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (EXT3_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t     EXT3_FEATURE_COMPAT_DIR_INDEX) &&\n\t    ((EXT3_I(inode)->i_flags & EXT3_INDEX_FL) ||\n\t     ((inode->i_size >> sb->s_blocksize_bits) == 1)))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nstatic int is_dx_dir(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (EXT3_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t     EXT3_FEATURE_COMPAT_DIR_INDEX) &&\n\t    ((EXT3_I(inode)->i_flags & EXT3_INDEX_FL) ||\n\t     ((inode->i_size >> sb->s_blocksize_bits) == 1)))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nstatic loff_t ext3_dir_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tint dx_dir = is_dx_dir(inode);\n\tloff_t htree_max = ext3_get_htree_eof(file);\n\n\tif (likely(dx_dir))\n\t\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\t        htree_max, htree_max);\n\telse\n\t\treturn generic_file_llseek(file, offset, whence);\n}"
  },
  {
    "function_name": "ext3_get_htree_eof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
    "lines": "256-263",
    "snippet": "static inline loff_t ext3_get_htree_eof(struct file *filp)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn EXT3_HTREE_EOF_32BIT;\n\telse\n\t\treturn EXT3_HTREE_EOF_64BIT;\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/compat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_32bit_api",
          "args": [],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "is_32bit_api",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
          "lines": "208-215",
          "snippet": "static inline int is_32bit_api(void)\n{\n#ifdef CONFIG_COMPAT\n\treturn is_compat_task();\n#else\n\treturn (BITS_PER_LONG == 32);\n#endif\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nstatic inline int is_32bit_api(void)\n{\n#ifdef CONFIG_COMPAT\n\treturn is_compat_task();\n#else\n\treturn (BITS_PER_LONG == 32);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nstatic inline loff_t ext3_get_htree_eof(struct file *filp)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn EXT3_HTREE_EOF_32BIT;\n\telse\n\t\treturn EXT3_HTREE_EOF_64BIT;\n}"
  },
  {
    "function_name": "pos2min_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
    "lines": "244-251",
    "snippet": "static inline __u32 pos2min_hash(struct file *filp, loff_t pos)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn 0;\n\telse\n\t\treturn pos & 0xffffffff;\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/compat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_32bit_api",
          "args": [],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "is_32bit_api",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
          "lines": "208-215",
          "snippet": "static inline int is_32bit_api(void)\n{\n#ifdef CONFIG_COMPAT\n\treturn is_compat_task();\n#else\n\treturn (BITS_PER_LONG == 32);\n#endif\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nstatic inline int is_32bit_api(void)\n{\n#ifdef CONFIG_COMPAT\n\treturn is_compat_task();\n#else\n\treturn (BITS_PER_LONG == 32);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nstatic inline __u32 pos2min_hash(struct file *filp, loff_t pos)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn 0;\n\telse\n\t\treturn pos & 0xffffffff;\n}"
  },
  {
    "function_name": "pos2maj_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
    "lines": "235-242",
    "snippet": "static inline __u32 pos2maj_hash(struct file *filp, loff_t pos)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn (pos << 1) & 0xffffffff;\n\telse\n\t\treturn ((pos >> 32) << 1) & 0xffffffff;\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/compat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_32bit_api",
          "args": [],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "is_32bit_api",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
          "lines": "208-215",
          "snippet": "static inline int is_32bit_api(void)\n{\n#ifdef CONFIG_COMPAT\n\treturn is_compat_task();\n#else\n\treturn (BITS_PER_LONG == 32);\n#endif\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nstatic inline int is_32bit_api(void)\n{\n#ifdef CONFIG_COMPAT\n\treturn is_compat_task();\n#else\n\treturn (BITS_PER_LONG == 32);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nstatic inline __u32 pos2maj_hash(struct file *filp, loff_t pos)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn (pos << 1) & 0xffffffff;\n\telse\n\t\treturn ((pos >> 32) << 1) & 0xffffffff;\n}"
  },
  {
    "function_name": "hash2pos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
    "lines": "226-233",
    "snippet": "static inline loff_t hash2pos(struct file *filp, __u32 major, __u32 minor)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn major >> 1;\n\telse\n\t\treturn ((__u64)(major >> 1) << 32) | (__u64)minor;\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/compat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "major >> 1"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_32bit_api",
          "args": [],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "is_32bit_api",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
          "lines": "208-215",
          "snippet": "static inline int is_32bit_api(void)\n{\n#ifdef CONFIG_COMPAT\n\treturn is_compat_task();\n#else\n\treturn (BITS_PER_LONG == 32);\n#endif\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nstatic inline int is_32bit_api(void)\n{\n#ifdef CONFIG_COMPAT\n\treturn is_compat_task();\n#else\n\treturn (BITS_PER_LONG == 32);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nstatic inline loff_t hash2pos(struct file *filp, __u32 major, __u32 minor)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn major >> 1;\n\telse\n\t\treturn ((__u64)(major >> 1) << 32) | (__u64)minor;\n}"
  },
  {
    "function_name": "is_32bit_api",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
    "lines": "208-215",
    "snippet": "static inline int is_32bit_api(void)\n{\n#ifdef CONFIG_COMPAT\n\treturn is_compat_task();\n#else\n\treturn (BITS_PER_LONG == 32);\n#endif\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/compat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_compat_task",
          "args": [],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nstatic inline int is_32bit_api(void)\n{\n#ifdef CONFIG_COMPAT\n\treturn is_compat_task();\n#else\n\treturn (BITS_PER_LONG == 32);\n#endif\n}"
  },
  {
    "function_name": "ext3_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
    "lines": "93-206",
    "snippet": "static int ext3_readdir(struct file *file, struct dir_context *ctx)\n{\n\tunsigned long offset;\n\tint i;\n\tstruct ext3_dir_entry_2 *de;\n\tint err;\n\tstruct inode *inode = file_inode(file);\n\tstruct super_block *sb = inode->i_sb;\n\tint dir_has_error = 0;\n\n\tif (is_dx_dir(inode)) {\n\t\terr = ext3_dx_readdir(file, ctx);\n\t\tif (err != ERR_BAD_DX_DIR)\n\t\t\treturn err;\n\t\t/*\n\t\t * We don't set the inode dirty flag since it's not\n\t\t * critical that it get flushed back to the disk.\n\t\t */\n\t\tEXT3_I(inode)->i_flags &= ~EXT3_INDEX_FL;\n\t}\n\toffset = ctx->pos & (sb->s_blocksize - 1);\n\n\twhile (ctx->pos < inode->i_size) {\n\t\tunsigned long blk = ctx->pos >> EXT3_BLOCK_SIZE_BITS(sb);\n\t\tstruct buffer_head map_bh;\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tmap_bh.b_state = 0;\n\t\terr = ext3_get_blocks_handle(NULL, inode, blk, 1, &map_bh, 0);\n\t\tif (err > 0) {\n\t\t\tpgoff_t index = map_bh.b_blocknr >>\n\t\t\t\t\t(PAGE_CACHE_SHIFT - inode->i_blkbits);\n\t\t\tif (!ra_has_index(&file->f_ra, index))\n\t\t\t\tpage_cache_sync_readahead(\n\t\t\t\t\tsb->s_bdev->bd_inode->i_mapping,\n\t\t\t\t\t&file->f_ra, file,\n\t\t\t\t\tindex, 1);\n\t\t\tfile->f_ra.prev_pos = (loff_t)index << PAGE_CACHE_SHIFT;\n\t\t\tbh = ext3_bread(NULL, inode, blk, 0, &err);\n\t\t}\n\n\t\t/*\n\t\t * We ignore I/O errors on directories so users have a chance\n\t\t * of recovering data when there's a bad sector\n\t\t */\n\t\tif (!bh) {\n\t\t\tif (!dir_has_error) {\n\t\t\t\text3_error(sb, __func__, \"directory #%lu \"\n\t\t\t\t\t\"contains a hole at offset %lld\",\n\t\t\t\t\tinode->i_ino, ctx->pos);\n\t\t\t\tdir_has_error = 1;\n\t\t\t}\n\t\t\t/* corrupt size?  Maybe no more blocks to read */\n\t\t\tif (ctx->pos > inode->i_blocks << 9)\n\t\t\t\tbreak;\n\t\t\tctx->pos += sb->s_blocksize - offset;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* If the dir block has changed since the last call to\n\t\t * readdir(2), then we might be pointing to an invalid\n\t\t * dirent right now.  Scan from the start of the block\n\t\t * to make sure. */\n\t\tif (offset && file->f_version != inode->i_version) {\n\t\t\tfor (i = 0; i < sb->s_blocksize && i < offset; ) {\n\t\t\t\tde = (struct ext3_dir_entry_2 *)\n\t\t\t\t\t(bh->b_data + i);\n\t\t\t\t/* It's too expensive to do a full\n\t\t\t\t * dirent test each time round this\n\t\t\t\t * loop, but we do have to test at\n\t\t\t\t * least that it is non-zero.  A\n\t\t\t\t * failure will be detected in the\n\t\t\t\t * dirent test below. */\n\t\t\t\tif (ext3_rec_len_from_disk(de->rec_len) <\n\t\t\t\t\t\tEXT3_DIR_REC_LEN(1))\n\t\t\t\t\tbreak;\n\t\t\t\ti += ext3_rec_len_from_disk(de->rec_len);\n\t\t\t}\n\t\t\toffset = i;\n\t\t\tctx->pos = (ctx->pos & ~(sb->s_blocksize - 1))\n\t\t\t\t| offset;\n\t\t\tfile->f_version = inode->i_version;\n\t\t}\n\n\t\twhile (ctx->pos < inode->i_size\n\t\t       && offset < sb->s_blocksize) {\n\t\t\tde = (struct ext3_dir_entry_2 *) (bh->b_data + offset);\n\t\t\tif (!ext3_check_dir_entry (\"ext3_readdir\", inode, de,\n\t\t\t\t\t\t   bh, offset)) {\n\t\t\t\t/* On error, skip the to the\n                                   next block. */\n\t\t\t\tctx->pos = (ctx->pos |\n\t\t\t\t\t\t(sb->s_blocksize - 1)) + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\toffset += ext3_rec_len_from_disk(de->rec_len);\n\t\t\tif (le32_to_cpu(de->inode)) {\n\t\t\t\tif (!dir_emit(ctx, de->name, de->name_len,\n\t\t\t\t\t      le32_to_cpu(de->inode),\n\t\t\t\t\t      get_dtype(sb, de->file_type))) {\n\t\t\t\t\tbrelse(bh);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tctx->pos += ext3_rec_len_from_disk(de->rec_len);\n\t\t}\n\t\toffset = 0;\n\t\tbrelse (bh);\n\t\tif (ctx->pos < inode->i_size)\n\t\t\tif (!dir_relax(inode))\n\t\t\t\treturn 0;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/compat.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_dx_readdir(struct file *, struct dir_context *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dir_relax",
          "args": [
            "inode"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_rec_len_from_disk",
          "args": [
            "de->rec_len"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_rec_len_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "878-887",
          "snippet": "static inline unsigned ext3_rec_len_from_disk(__le16 dlen)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT3_MAX_REC_LEN)\n\t\treturn 1 << 16;\n#endif\n\treturn len;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT3_MAX_REC_LEN\t\t((1<<16)-1)"
          ],
          "globals_used": [
            "extern int ext3_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t       u64 start, u64 len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\n#define EXT3_MAX_REC_LEN\t\t((1<<16)-1)\n\nextern int ext3_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t       u64 start, u64 len);\n\nstatic inline unsigned ext3_rec_len_from_disk(__le16 dlen)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT3_MAX_REC_LEN)\n\t\treturn 1 << 16;\n#endif\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "de->name",
            "de->name_len",
            "le32_to_cpu(de->inode)",
            "get_dtype(sb, de->file_type)"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dtype",
          "args": [
            "sb",
            "de->file_type"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "get_dtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
          "lines": "33-40",
          "snippet": "static unsigned char get_dtype(struct super_block *sb, int filetype)\n{\n\tif (!EXT3_HAS_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_FILETYPE) ||\n\t    (filetype >= EXT3_FT_MAX))\n\t\treturn DT_UNKNOWN;\n\n\treturn (ext3_filetype_table[filetype]);\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned char ext3_filetype_table[] = {\n\tDT_UNKNOWN, DT_REG, DT_DIR, DT_CHR, DT_BLK, DT_FIFO, DT_SOCK, DT_LNK\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nstatic unsigned char ext3_filetype_table[] = {\n\tDT_UNKNOWN, DT_REG, DT_DIR, DT_CHR, DT_BLK, DT_FIFO, DT_SOCK, DT_LNK\n};\n\nstatic unsigned char get_dtype(struct super_block *sb, int filetype)\n{\n\tif (!EXT3_HAS_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_FILETYPE) ||\n\t    (filetype >= EXT3_FT_MAX))\n\t\treturn DT_UNKNOWN;\n\n\treturn (ext3_filetype_table[filetype]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "de->inode"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_check_dir_entry",
          "args": [
            "\"ext3_readdir\"",
            "inode",
            "de",
            "bh",
            "offset"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_check_dir_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
          "lines": "62-91",
          "snippet": "int ext3_check_dir_entry (const char * function, struct inode * dir,\n\t\t\t  struct ext3_dir_entry_2 * de,\n\t\t\t  struct buffer_head * bh,\n\t\t\t  unsigned long offset)\n{\n\tconst char * error_msg = NULL;\n\tconst int rlen = ext3_rec_len_from_disk(de->rec_len);\n\n\tif (unlikely(rlen < EXT3_DIR_REC_LEN(1)))\n\t\terror_msg = \"rec_len is smaller than minimal\";\n\telse if (unlikely(rlen % 4 != 0))\n\t\terror_msg = \"rec_len % 4 != 0\";\n\telse if (unlikely(rlen < EXT3_DIR_REC_LEN(de->name_len)))\n\t\terror_msg = \"rec_len is too small for name_len\";\n\telse if (unlikely((((char *) de - bh->b_data) + rlen > dir->i_sb->s_blocksize)))\n\t\terror_msg = \"directory entry across blocks\";\n\telse if (unlikely(le32_to_cpu(de->inode) >\n\t\t\tle32_to_cpu(EXT3_SB(dir->i_sb)->s_es->s_inodes_count)))\n\t\terror_msg = \"inode out of bounds\";\n\n\tif (unlikely(error_msg != NULL))\n\t\text3_error (dir->i_sb, function,\n\t\t\t\"bad entry in directory #%lu: %s - \"\n\t\t\t\"offset=%lu, inode=%lu, rec_len=%d, name_len=%d\",\n\t\t\tdir->i_ino, error_msg, offset,\n\t\t\t(unsigned long) le32_to_cpu(de->inode),\n\t\t\trlen, de->name_len);\n\n\treturn error_msg == NULL ? 1 : 0;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nint ext3_check_dir_entry (const char * function, struct inode * dir,\n\t\t\t  struct ext3_dir_entry_2 * de,\n\t\t\t  struct buffer_head * bh,\n\t\t\t  unsigned long offset)\n{\n\tconst char * error_msg = NULL;\n\tconst int rlen = ext3_rec_len_from_disk(de->rec_len);\n\n\tif (unlikely(rlen < EXT3_DIR_REC_LEN(1)))\n\t\terror_msg = \"rec_len is smaller than minimal\";\n\telse if (unlikely(rlen % 4 != 0))\n\t\terror_msg = \"rec_len % 4 != 0\";\n\telse if (unlikely(rlen < EXT3_DIR_REC_LEN(de->name_len)))\n\t\terror_msg = \"rec_len is too small for name_len\";\n\telse if (unlikely((((char *) de - bh->b_data) + rlen > dir->i_sb->s_blocksize)))\n\t\terror_msg = \"directory entry across blocks\";\n\telse if (unlikely(le32_to_cpu(de->inode) >\n\t\t\tle32_to_cpu(EXT3_SB(dir->i_sb)->s_es->s_inodes_count)))\n\t\terror_msg = \"inode out of bounds\";\n\n\tif (unlikely(error_msg != NULL))\n\t\text3_error (dir->i_sb, function,\n\t\t\t\"bad entry in directory #%lu: %s - \"\n\t\t\t\"offset=%lu, inode=%lu, rec_len=%d, name_len=%d\",\n\t\t\tdir->i_ino, error_msg, offset,\n\t\t\t(unsigned long) le32_to_cpu(de->inode),\n\t\t\trlen, de->name_len);\n\n\treturn error_msg == NULL ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_DIR_REC_LEN",
          "args": [
            "1"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_error",
          "args": [
            "sb",
            "__func__",
            "\"directory #%lu \"\n\t\t\t\t\t\"contains a hole at offset %lld\"",
            "inode->i_ino",
            "ctx->pos"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "191-208",
          "snippet": "void ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_bread",
          "args": [
            "NULL",
            "inode",
            "blk",
            "0",
            "&err"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "1128-1147",
          "snippet": "struct buffer_head *ext3_bread(handle_t *handle, struct inode *inode,\n\t\t\t       int block, int create, int *err)\n{\n\tstruct buffer_head * bh;\n\n\tbh = ext3_getblk(handle, inode, block, create, err);\n\tif (!bh)\n\t\treturn bh;\n\tif (bh_uptodate_or_lock(bh))\n\t\treturn bh;\n\tget_bh(bh);\n\tbh->b_end_io = end_buffer_read_sync;\n\tsubmit_bh(READ | REQ_META | REQ_PRIO, bh);\n\twait_on_buffer(bh);\n\tif (buffer_uptodate(bh))\n\t\treturn bh;\n\tput_bh(bh);\n\t*err = -EIO;\n\treturn NULL;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nstruct buffer_head *ext3_bread(handle_t *handle, struct inode *inode,\n\t\t\t       int block, int create, int *err)\n{\n\tstruct buffer_head * bh;\n\n\tbh = ext3_getblk(handle, inode, block, create, err);\n\tif (!bh)\n\t\treturn bh;\n\tif (bh_uptodate_or_lock(bh))\n\t\treturn bh;\n\tget_bh(bh);\n\tbh->b_end_io = end_buffer_read_sync;\n\tsubmit_bh(READ | REQ_META | REQ_PRIO, bh);\n\twait_on_buffer(bh);\n\tif (buffer_uptodate(bh))\n\t\treturn bh;\n\tput_bh(bh);\n\t*err = -EIO;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_sync_readahead",
          "args": [
            "sb->s_bdev->bd_inode->i_mapping",
            "&file->f_ra",
            "file",
            "index",
            "1"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ra_has_index",
          "args": [
            "&file->f_ra",
            "index"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_get_blocks_handle",
          "args": [
            "NULL",
            "inode",
            "blk",
            "1",
            "&map_bh",
            "0"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_get_blocks_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "857-1008",
          "snippet": "int ext3_get_blocks_handle(handle_t *handle, struct inode *inode,\n\t\tsector_t iblock, unsigned long maxblocks,\n\t\tstruct buffer_head *bh_result,\n\t\tint create)\n{\n\tint err = -EIO;\n\tint offsets[4];\n\tIndirect chain[4];\n\tIndirect *partial;\n\text3_fsblk_t goal;\n\tint indirect_blks;\n\tint blocks_to_boundary = 0;\n\tint depth;\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tint count = 0;\n\text3_fsblk_t first_block = 0;\n\n\n\ttrace_ext3_get_blocks_enter(inode, iblock, maxblocks, create);\n\tJ_ASSERT(handle != NULL || create == 0);\n\tdepth = ext3_block_to_path(inode,iblock,offsets,&blocks_to_boundary);\n\n\tif (depth == 0)\n\t\tgoto out;\n\n\tpartial = ext3_get_branch(inode, depth, offsets, chain, &err);\n\n\t/* Simplest case - block found, no allocation needed */\n\tif (!partial) {\n\t\tfirst_block = le32_to_cpu(chain[depth - 1].key);\n\t\tclear_buffer_new(bh_result);\n\t\tcount++;\n\t\t/*map more blocks*/\n\t\twhile (count < maxblocks && count <= blocks_to_boundary) {\n\t\t\text3_fsblk_t blk;\n\n\t\t\tif (!verify_chain(chain, chain + depth - 1)) {\n\t\t\t\t/*\n\t\t\t\t * Indirect block might be removed by\n\t\t\t\t * truncate while we were reading it.\n\t\t\t\t * Handling of that case: forget what we've\n\t\t\t\t * got now. Flag the err as EAGAIN, so it\n\t\t\t\t * will reread.\n\t\t\t\t */\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tcount = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tblk = le32_to_cpu(*(chain[depth-1].p + count));\n\n\t\t\tif (blk == first_block + count)\n\t\t\t\tcount++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tif (err != -EAGAIN)\n\t\t\tgoto got_it;\n\t}\n\n\t/* Next simple case - plain lookup or failed read of indirect block */\n\tif (!create || err == -EIO)\n\t\tgoto cleanup;\n\n\t/*\n\t * Block out ext3_truncate while we alter the tree\n\t */\n\tmutex_lock(&ei->truncate_mutex);\n\n\t/*\n\t * If the indirect block is missing while we are reading\n\t * the chain(ext3_get_branch() returns -EAGAIN err), or\n\t * if the chain has been changed after we grab the semaphore,\n\t * (either because another process truncated this branch, or\n\t * another get_block allocated this branch) re-grab the chain to see if\n\t * the request block has been allocated or not.\n\t *\n\t * Since we already block the truncate/other get_block\n\t * at this point, we will have the current copy of the chain when we\n\t * splice the branch into the tree.\n\t */\n\tif (err == -EAGAIN || !verify_chain(chain, partial)) {\n\t\twhile (partial > chain) {\n\t\t\tbrelse(partial->bh);\n\t\t\tpartial--;\n\t\t}\n\t\tpartial = ext3_get_branch(inode, depth, offsets, chain, &err);\n\t\tif (!partial) {\n\t\t\tcount++;\n\t\t\tmutex_unlock(&ei->truncate_mutex);\n\t\t\tif (err)\n\t\t\t\tgoto cleanup;\n\t\t\tclear_buffer_new(bh_result);\n\t\t\tgoto got_it;\n\t\t}\n\t}\n\n\t/*\n\t * Okay, we need to do block allocation.  Lazily initialize the block\n\t * allocation info here if necessary\n\t*/\n\tif (S_ISREG(inode->i_mode) && (!ei->i_block_alloc_info))\n\t\text3_init_block_alloc_info(inode);\n\n\tgoal = ext3_find_goal(inode, iblock, partial);\n\n\t/* the number of blocks need to allocate for [d,t]indirect blocks */\n\tindirect_blks = (chain + depth) - partial - 1;\n\n\t/*\n\t * Next look up the indirect map to count the totoal number of\n\t * direct blocks to allocate for this branch.\n\t */\n\tcount = ext3_blks_to_allocate(partial, indirect_blks,\n\t\t\t\t\tmaxblocks, blocks_to_boundary);\n\terr = ext3_alloc_branch(handle, inode, indirect_blks, &count, goal,\n\t\t\t\toffsets + (partial - chain), partial);\n\n\t/*\n\t * The ext3_splice_branch call will free and forget any buffers\n\t * on the new chain if there is a failure, but that risks using\n\t * up transaction credits, especially for bitmaps where the\n\t * credits cannot be returned.  Can we handle this somehow?  We\n\t * may need to return -EAGAIN upwards in the worst case.  --sct\n\t */\n\tif (!err)\n\t\terr = ext3_splice_branch(handle, inode, iblock,\n\t\t\t\t\tpartial, indirect_blks, count);\n\tmutex_unlock(&ei->truncate_mutex);\n\tif (err)\n\t\tgoto cleanup;\n\n\tset_buffer_new(bh_result);\ngot_it:\n\tmap_bh(bh_result, inode->i_sb, le32_to_cpu(chain[depth-1].key));\n\tif (count > blocks_to_boundary)\n\t\tset_buffer_boundary(bh_result);\n\terr = count;\n\t/* Clean up and exit */\n\tpartial = chain + depth - 1;\t/* the whole chain */\ncleanup:\n\twhile (partial > chain) {\n\t\tBUFFER_TRACE(partial->bh, \"call brelse\");\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\n\tBUFFER_TRACE(bh_result, \"returned\");\nout:\n\ttrace_ext3_get_blocks_exit(inode, iblock,\n\t\t\t\t   depth ? le32_to_cpu(chain[depth-1].key) : 0,\n\t\t\t\t   count, err);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_get_blocks_handle(handle_t *handle, struct inode *inode,\n\t\tsector_t iblock, unsigned long maxblocks,\n\t\tstruct buffer_head *bh_result,\n\t\tint create)\n{\n\tint err = -EIO;\n\tint offsets[4];\n\tIndirect chain[4];\n\tIndirect *partial;\n\text3_fsblk_t goal;\n\tint indirect_blks;\n\tint blocks_to_boundary = 0;\n\tint depth;\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tint count = 0;\n\text3_fsblk_t first_block = 0;\n\n\n\ttrace_ext3_get_blocks_enter(inode, iblock, maxblocks, create);\n\tJ_ASSERT(handle != NULL || create == 0);\n\tdepth = ext3_block_to_path(inode,iblock,offsets,&blocks_to_boundary);\n\n\tif (depth == 0)\n\t\tgoto out;\n\n\tpartial = ext3_get_branch(inode, depth, offsets, chain, &err);\n\n\t/* Simplest case - block found, no allocation needed */\n\tif (!partial) {\n\t\tfirst_block = le32_to_cpu(chain[depth - 1].key);\n\t\tclear_buffer_new(bh_result);\n\t\tcount++;\n\t\t/*map more blocks*/\n\t\twhile (count < maxblocks && count <= blocks_to_boundary) {\n\t\t\text3_fsblk_t blk;\n\n\t\t\tif (!verify_chain(chain, chain + depth - 1)) {\n\t\t\t\t/*\n\t\t\t\t * Indirect block might be removed by\n\t\t\t\t * truncate while we were reading it.\n\t\t\t\t * Handling of that case: forget what we've\n\t\t\t\t * got now. Flag the err as EAGAIN, so it\n\t\t\t\t * will reread.\n\t\t\t\t */\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tcount = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tblk = le32_to_cpu(*(chain[depth-1].p + count));\n\n\t\t\tif (blk == first_block + count)\n\t\t\t\tcount++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tif (err != -EAGAIN)\n\t\t\tgoto got_it;\n\t}\n\n\t/* Next simple case - plain lookup or failed read of indirect block */\n\tif (!create || err == -EIO)\n\t\tgoto cleanup;\n\n\t/*\n\t * Block out ext3_truncate while we alter the tree\n\t */\n\tmutex_lock(&ei->truncate_mutex);\n\n\t/*\n\t * If the indirect block is missing while we are reading\n\t * the chain(ext3_get_branch() returns -EAGAIN err), or\n\t * if the chain has been changed after we grab the semaphore,\n\t * (either because another process truncated this branch, or\n\t * another get_block allocated this branch) re-grab the chain to see if\n\t * the request block has been allocated or not.\n\t *\n\t * Since we already block the truncate/other get_block\n\t * at this point, we will have the current copy of the chain when we\n\t * splice the branch into the tree.\n\t */\n\tif (err == -EAGAIN || !verify_chain(chain, partial)) {\n\t\twhile (partial > chain) {\n\t\t\tbrelse(partial->bh);\n\t\t\tpartial--;\n\t\t}\n\t\tpartial = ext3_get_branch(inode, depth, offsets, chain, &err);\n\t\tif (!partial) {\n\t\t\tcount++;\n\t\t\tmutex_unlock(&ei->truncate_mutex);\n\t\t\tif (err)\n\t\t\t\tgoto cleanup;\n\t\t\tclear_buffer_new(bh_result);\n\t\t\tgoto got_it;\n\t\t}\n\t}\n\n\t/*\n\t * Okay, we need to do block allocation.  Lazily initialize the block\n\t * allocation info here if necessary\n\t*/\n\tif (S_ISREG(inode->i_mode) && (!ei->i_block_alloc_info))\n\t\text3_init_block_alloc_info(inode);\n\n\tgoal = ext3_find_goal(inode, iblock, partial);\n\n\t/* the number of blocks need to allocate for [d,t]indirect blocks */\n\tindirect_blks = (chain + depth) - partial - 1;\n\n\t/*\n\t * Next look up the indirect map to count the totoal number of\n\t * direct blocks to allocate for this branch.\n\t */\n\tcount = ext3_blks_to_allocate(partial, indirect_blks,\n\t\t\t\t\tmaxblocks, blocks_to_boundary);\n\terr = ext3_alloc_branch(handle, inode, indirect_blks, &count, goal,\n\t\t\t\toffsets + (partial - chain), partial);\n\n\t/*\n\t * The ext3_splice_branch call will free and forget any buffers\n\t * on the new chain if there is a failure, but that risks using\n\t * up transaction credits, especially for bitmaps where the\n\t * credits cannot be returned.  Can we handle this somehow?  We\n\t * may need to return -EAGAIN upwards in the worst case.  --sct\n\t */\n\tif (!err)\n\t\terr = ext3_splice_branch(handle, inode, iblock,\n\t\t\t\t\tpartial, indirect_blks, count);\n\tmutex_unlock(&ei->truncate_mutex);\n\tif (err)\n\t\tgoto cleanup;\n\n\tset_buffer_new(bh_result);\ngot_it:\n\tmap_bh(bh_result, inode->i_sb, le32_to_cpu(chain[depth-1].key));\n\tif (count > blocks_to_boundary)\n\t\tset_buffer_boundary(bh_result);\n\terr = count;\n\t/* Clean up and exit */\n\tpartial = chain + depth - 1;\t/* the whole chain */\ncleanup:\n\twhile (partial > chain) {\n\t\tBUFFER_TRACE(partial->bh, \"call brelse\");\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\n\tBUFFER_TRACE(bh_result, \"returned\");\nout:\n\ttrace_ext3_get_blocks_exit(inode, iblock,\n\t\t\t\t   depth ? le32_to_cpu(chain[depth-1].key) : 0,\n\t\t\t\t   count, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_BLOCK_SIZE_BITS",
          "args": [
            "sb"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_dx_readdir",
          "args": [
            "file",
            "ctx"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_dx_readdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
          "lines": "432-517",
          "snippet": "static int ext3_dx_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct dir_private_info *info = file->private_data;\n\tstruct inode *inode = file_inode(file);\n\tstruct fname *fname;\n\tint\tret;\n\n\tif (!info) {\n\t\tinfo = ext3_htree_create_dir_info(file, ctx->pos);\n\t\tif (!info)\n\t\t\treturn -ENOMEM;\n\t\tfile->private_data = info;\n\t}\n\n\tif (ctx->pos == ext3_get_htree_eof(file))\n\t\treturn 0;\t/* EOF */\n\n\t/* Some one has messed with f_pos; reset the world */\n\tif (info->last_pos != ctx->pos) {\n\t\tfree_rb_tree_fname(&info->root);\n\t\tinfo->curr_node = NULL;\n\t\tinfo->extra_fname = NULL;\n\t\tinfo->curr_hash = pos2maj_hash(file, ctx->pos);\n\t\tinfo->curr_minor_hash = pos2min_hash(file, ctx->pos);\n\t}\n\n\t/*\n\t * If there are any leftover names on the hash collision\n\t * chain, return them first.\n\t */\n\tif (info->extra_fname) {\n\t\tif (!call_filldir(file, ctx, info->extra_fname))\n\t\t\tgoto finished;\n\t\tinfo->extra_fname = NULL;\n\t\tgoto next_node;\n\t} else if (!info->curr_node)\n\t\tinfo->curr_node = rb_first(&info->root);\n\n\twhile (1) {\n\t\t/*\n\t\t * Fill the rbtree if we have no more entries,\n\t\t * or the inode has changed since we last read in the\n\t\t * cached entries.\n\t\t */\n\t\tif ((!info->curr_node) ||\n\t\t    (file->f_version != inode->i_version)) {\n\t\t\tinfo->curr_node = NULL;\n\t\t\tfree_rb_tree_fname(&info->root);\n\t\t\tfile->f_version = inode->i_version;\n\t\t\tret = ext3_htree_fill_tree(file, info->curr_hash,\n\t\t\t\t\t\t   info->curr_minor_hash,\n\t\t\t\t\t\t   &info->next_hash);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (ret == 0) {\n\t\t\t\tctx->pos = ext3_get_htree_eof(file);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tinfo->curr_node = rb_first(&info->root);\n\t\t}\n\n\t\tfname = rb_entry(info->curr_node, struct fname, rb_hash);\n\t\tinfo->curr_hash = fname->hash;\n\t\tinfo->curr_minor_hash = fname->minor_hash;\n\t\tif (!call_filldir(file, ctx, fname))\n\t\t\tbreak;\n\tnext_node:\n\t\tinfo->curr_node = rb_next(info->curr_node);\n\t\tif (info->curr_node) {\n\t\t\tfname = rb_entry(info->curr_node, struct fname,\n\t\t\t\t\t rb_hash);\n\t\t\tinfo->curr_hash = fname->hash;\n\t\t\tinfo->curr_minor_hash = fname->minor_hash;\n\t\t} else {\n\t\t\tif (info->next_hash == ~0) {\n\t\t\t\tctx->pos = ext3_get_htree_eof(file);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tinfo->curr_hash = info->next_hash;\n\t\t\tinfo->curr_minor_hash = 0;\n\t\t}\n\t}\nfinished:\n\tinfo->last_pos = ctx->pos;\n\treturn 0;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_dx_readdir(struct file *, struct dir_context *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nstatic int ext3_dx_readdir(struct file *, struct dir_context *);\n\nstatic int ext3_dx_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct dir_private_info *info = file->private_data;\n\tstruct inode *inode = file_inode(file);\n\tstruct fname *fname;\n\tint\tret;\n\n\tif (!info) {\n\t\tinfo = ext3_htree_create_dir_info(file, ctx->pos);\n\t\tif (!info)\n\t\t\treturn -ENOMEM;\n\t\tfile->private_data = info;\n\t}\n\n\tif (ctx->pos == ext3_get_htree_eof(file))\n\t\treturn 0;\t/* EOF */\n\n\t/* Some one has messed with f_pos; reset the world */\n\tif (info->last_pos != ctx->pos) {\n\t\tfree_rb_tree_fname(&info->root);\n\t\tinfo->curr_node = NULL;\n\t\tinfo->extra_fname = NULL;\n\t\tinfo->curr_hash = pos2maj_hash(file, ctx->pos);\n\t\tinfo->curr_minor_hash = pos2min_hash(file, ctx->pos);\n\t}\n\n\t/*\n\t * If there are any leftover names on the hash collision\n\t * chain, return them first.\n\t */\n\tif (info->extra_fname) {\n\t\tif (!call_filldir(file, ctx, info->extra_fname))\n\t\t\tgoto finished;\n\t\tinfo->extra_fname = NULL;\n\t\tgoto next_node;\n\t} else if (!info->curr_node)\n\t\tinfo->curr_node = rb_first(&info->root);\n\n\twhile (1) {\n\t\t/*\n\t\t * Fill the rbtree if we have no more entries,\n\t\t * or the inode has changed since we last read in the\n\t\t * cached entries.\n\t\t */\n\t\tif ((!info->curr_node) ||\n\t\t    (file->f_version != inode->i_version)) {\n\t\t\tinfo->curr_node = NULL;\n\t\t\tfree_rb_tree_fname(&info->root);\n\t\t\tfile->f_version = inode->i_version;\n\t\t\tret = ext3_htree_fill_tree(file, info->curr_hash,\n\t\t\t\t\t\t   info->curr_minor_hash,\n\t\t\t\t\t\t   &info->next_hash);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (ret == 0) {\n\t\t\t\tctx->pos = ext3_get_htree_eof(file);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tinfo->curr_node = rb_first(&info->root);\n\t\t}\n\n\t\tfname = rb_entry(info->curr_node, struct fname, rb_hash);\n\t\tinfo->curr_hash = fname->hash;\n\t\tinfo->curr_minor_hash = fname->minor_hash;\n\t\tif (!call_filldir(file, ctx, fname))\n\t\t\tbreak;\n\tnext_node:\n\t\tinfo->curr_node = rb_next(info->curr_node);\n\t\tif (info->curr_node) {\n\t\t\tfname = rb_entry(info->curr_node, struct fname,\n\t\t\t\t\t rb_hash);\n\t\t\tinfo->curr_hash = fname->hash;\n\t\t\tinfo->curr_minor_hash = fname->minor_hash;\n\t\t} else {\n\t\t\tif (info->next_hash == ~0) {\n\t\t\t\tctx->pos = ext3_get_htree_eof(file);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tinfo->curr_hash = info->next_hash;\n\t\t\tinfo->curr_minor_hash = 0;\n\t\t}\n\t}\nfinished:\n\tinfo->last_pos = ctx->pos;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_dx_dir",
          "args": [
            "inode"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "is_dx_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
          "lines": "49-60",
          "snippet": "static int is_dx_dir(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (EXT3_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t     EXT3_FEATURE_COMPAT_DIR_INDEX) &&\n\t    ((EXT3_I(inode)->i_flags & EXT3_INDEX_FL) ||\n\t     ((inode->i_size >> sb->s_blocksize_bits) == 1)))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nstatic int is_dx_dir(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (EXT3_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t     EXT3_FEATURE_COMPAT_DIR_INDEX) &&\n\t    ((EXT3_I(inode)->i_flags & EXT3_INDEX_FL) ||\n\t     ((inode->i_size >> sb->s_blocksize_bits) == 1)))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nstatic int ext3_dx_readdir(struct file *, struct dir_context *);\n\nstatic int ext3_readdir(struct file *file, struct dir_context *ctx)\n{\n\tunsigned long offset;\n\tint i;\n\tstruct ext3_dir_entry_2 *de;\n\tint err;\n\tstruct inode *inode = file_inode(file);\n\tstruct super_block *sb = inode->i_sb;\n\tint dir_has_error = 0;\n\n\tif (is_dx_dir(inode)) {\n\t\terr = ext3_dx_readdir(file, ctx);\n\t\tif (err != ERR_BAD_DX_DIR)\n\t\t\treturn err;\n\t\t/*\n\t\t * We don't set the inode dirty flag since it's not\n\t\t * critical that it get flushed back to the disk.\n\t\t */\n\t\tEXT3_I(inode)->i_flags &= ~EXT3_INDEX_FL;\n\t}\n\toffset = ctx->pos & (sb->s_blocksize - 1);\n\n\twhile (ctx->pos < inode->i_size) {\n\t\tunsigned long blk = ctx->pos >> EXT3_BLOCK_SIZE_BITS(sb);\n\t\tstruct buffer_head map_bh;\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tmap_bh.b_state = 0;\n\t\terr = ext3_get_blocks_handle(NULL, inode, blk, 1, &map_bh, 0);\n\t\tif (err > 0) {\n\t\t\tpgoff_t index = map_bh.b_blocknr >>\n\t\t\t\t\t(PAGE_CACHE_SHIFT - inode->i_blkbits);\n\t\t\tif (!ra_has_index(&file->f_ra, index))\n\t\t\t\tpage_cache_sync_readahead(\n\t\t\t\t\tsb->s_bdev->bd_inode->i_mapping,\n\t\t\t\t\t&file->f_ra, file,\n\t\t\t\t\tindex, 1);\n\t\t\tfile->f_ra.prev_pos = (loff_t)index << PAGE_CACHE_SHIFT;\n\t\t\tbh = ext3_bread(NULL, inode, blk, 0, &err);\n\t\t}\n\n\t\t/*\n\t\t * We ignore I/O errors on directories so users have a chance\n\t\t * of recovering data when there's a bad sector\n\t\t */\n\t\tif (!bh) {\n\t\t\tif (!dir_has_error) {\n\t\t\t\text3_error(sb, __func__, \"directory #%lu \"\n\t\t\t\t\t\"contains a hole at offset %lld\",\n\t\t\t\t\tinode->i_ino, ctx->pos);\n\t\t\t\tdir_has_error = 1;\n\t\t\t}\n\t\t\t/* corrupt size?  Maybe no more blocks to read */\n\t\t\tif (ctx->pos > inode->i_blocks << 9)\n\t\t\t\tbreak;\n\t\t\tctx->pos += sb->s_blocksize - offset;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* If the dir block has changed since the last call to\n\t\t * readdir(2), then we might be pointing to an invalid\n\t\t * dirent right now.  Scan from the start of the block\n\t\t * to make sure. */\n\t\tif (offset && file->f_version != inode->i_version) {\n\t\t\tfor (i = 0; i < sb->s_blocksize && i < offset; ) {\n\t\t\t\tde = (struct ext3_dir_entry_2 *)\n\t\t\t\t\t(bh->b_data + i);\n\t\t\t\t/* It's too expensive to do a full\n\t\t\t\t * dirent test each time round this\n\t\t\t\t * loop, but we do have to test at\n\t\t\t\t * least that it is non-zero.  A\n\t\t\t\t * failure will be detected in the\n\t\t\t\t * dirent test below. */\n\t\t\t\tif (ext3_rec_len_from_disk(de->rec_len) <\n\t\t\t\t\t\tEXT3_DIR_REC_LEN(1))\n\t\t\t\t\tbreak;\n\t\t\t\ti += ext3_rec_len_from_disk(de->rec_len);\n\t\t\t}\n\t\t\toffset = i;\n\t\t\tctx->pos = (ctx->pos & ~(sb->s_blocksize - 1))\n\t\t\t\t| offset;\n\t\t\tfile->f_version = inode->i_version;\n\t\t}\n\n\t\twhile (ctx->pos < inode->i_size\n\t\t       && offset < sb->s_blocksize) {\n\t\t\tde = (struct ext3_dir_entry_2 *) (bh->b_data + offset);\n\t\t\tif (!ext3_check_dir_entry (\"ext3_readdir\", inode, de,\n\t\t\t\t\t\t   bh, offset)) {\n\t\t\t\t/* On error, skip the to the\n                                   next block. */\n\t\t\t\tctx->pos = (ctx->pos |\n\t\t\t\t\t\t(sb->s_blocksize - 1)) + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\toffset += ext3_rec_len_from_disk(de->rec_len);\n\t\t\tif (le32_to_cpu(de->inode)) {\n\t\t\t\tif (!dir_emit(ctx, de->name, de->name_len,\n\t\t\t\t\t      le32_to_cpu(de->inode),\n\t\t\t\t\t      get_dtype(sb, de->file_type))) {\n\t\t\t\t\tbrelse(bh);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tctx->pos += ext3_rec_len_from_disk(de->rec_len);\n\t\t}\n\t\toffset = 0;\n\t\tbrelse (bh);\n\t\tif (ctx->pos < inode->i_size)\n\t\t\tif (!dir_relax(inode))\n\t\t\t\treturn 0;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ext3_check_dir_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
    "lines": "62-91",
    "snippet": "int ext3_check_dir_entry (const char * function, struct inode * dir,\n\t\t\t  struct ext3_dir_entry_2 * de,\n\t\t\t  struct buffer_head * bh,\n\t\t\t  unsigned long offset)\n{\n\tconst char * error_msg = NULL;\n\tconst int rlen = ext3_rec_len_from_disk(de->rec_len);\n\n\tif (unlikely(rlen < EXT3_DIR_REC_LEN(1)))\n\t\terror_msg = \"rec_len is smaller than minimal\";\n\telse if (unlikely(rlen % 4 != 0))\n\t\terror_msg = \"rec_len % 4 != 0\";\n\telse if (unlikely(rlen < EXT3_DIR_REC_LEN(de->name_len)))\n\t\terror_msg = \"rec_len is too small for name_len\";\n\telse if (unlikely((((char *) de - bh->b_data) + rlen > dir->i_sb->s_blocksize)))\n\t\terror_msg = \"directory entry across blocks\";\n\telse if (unlikely(le32_to_cpu(de->inode) >\n\t\t\tle32_to_cpu(EXT3_SB(dir->i_sb)->s_es->s_inodes_count)))\n\t\terror_msg = \"inode out of bounds\";\n\n\tif (unlikely(error_msg != NULL))\n\t\text3_error (dir->i_sb, function,\n\t\t\t\"bad entry in directory #%lu: %s - \"\n\t\t\t\"offset=%lu, inode=%lu, rec_len=%d, name_len=%d\",\n\t\t\tdir->i_ino, error_msg, offset,\n\t\t\t(unsigned long) le32_to_cpu(de->inode),\n\t\t\trlen, de->name_len);\n\n\treturn error_msg == NULL ? 1 : 0;\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/compat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_error",
          "args": [
            "dir->i_sb",
            "function",
            "\"bad entry in directory #%lu: %s - \"\n\t\t\t\"offset=%lu, inode=%lu, rec_len=%d, name_len=%d\"",
            "dir->i_ino",
            "error_msg",
            "offset",
            "(unsigned long) le32_to_cpu(de->inode)",
            "rlen",
            "de->name_len"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "191-208",
          "snippet": "void ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "de->inode"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error_msg != NULL"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "le32_to_cpu(de->inode) >\n\t\t\tle32_to_cpu(EXT3_SB(dir->i_sb)->s_es->s_inodes_count)"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(((char *) de - bh->b_data) + rlen > dir->i_sb->s_blocksize)"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rlen < EXT3_DIR_REC_LEN(de->name_len)"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_DIR_REC_LEN",
          "args": [
            "de->name_len"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rlen % 4 != 0"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rlen < EXT3_DIR_REC_LEN(1)"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_DIR_REC_LEN",
          "args": [
            "1"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_rec_len_from_disk",
          "args": [
            "de->rec_len"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_rec_len_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "878-887",
          "snippet": "static inline unsigned ext3_rec_len_from_disk(__le16 dlen)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT3_MAX_REC_LEN)\n\t\treturn 1 << 16;\n#endif\n\treturn len;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT3_MAX_REC_LEN\t\t((1<<16)-1)"
          ],
          "globals_used": [
            "extern int ext3_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t       u64 start, u64 len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\n#define EXT3_MAX_REC_LEN\t\t((1<<16)-1)\n\nextern int ext3_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t       u64 start, u64 len);\n\nstatic inline unsigned ext3_rec_len_from_disk(__le16 dlen)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT3_MAX_REC_LEN)\n\t\treturn 1 << 16;\n#endif\n\treturn len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nint ext3_check_dir_entry (const char * function, struct inode * dir,\n\t\t\t  struct ext3_dir_entry_2 * de,\n\t\t\t  struct buffer_head * bh,\n\t\t\t  unsigned long offset)\n{\n\tconst char * error_msg = NULL;\n\tconst int rlen = ext3_rec_len_from_disk(de->rec_len);\n\n\tif (unlikely(rlen < EXT3_DIR_REC_LEN(1)))\n\t\terror_msg = \"rec_len is smaller than minimal\";\n\telse if (unlikely(rlen % 4 != 0))\n\t\terror_msg = \"rec_len % 4 != 0\";\n\telse if (unlikely(rlen < EXT3_DIR_REC_LEN(de->name_len)))\n\t\terror_msg = \"rec_len is too small for name_len\";\n\telse if (unlikely((((char *) de - bh->b_data) + rlen > dir->i_sb->s_blocksize)))\n\t\terror_msg = \"directory entry across blocks\";\n\telse if (unlikely(le32_to_cpu(de->inode) >\n\t\t\tle32_to_cpu(EXT3_SB(dir->i_sb)->s_es->s_inodes_count)))\n\t\terror_msg = \"inode out of bounds\";\n\n\tif (unlikely(error_msg != NULL))\n\t\text3_error (dir->i_sb, function,\n\t\t\t\"bad entry in directory #%lu: %s - \"\n\t\t\t\"offset=%lu, inode=%lu, rec_len=%d, name_len=%d\",\n\t\t\tdir->i_ino, error_msg, offset,\n\t\t\t(unsigned long) le32_to_cpu(de->inode),\n\t\t\trlen, de->name_len);\n\n\treturn error_msg == NULL ? 1 : 0;\n}"
  },
  {
    "function_name": "is_dx_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
    "lines": "49-60",
    "snippet": "static int is_dx_dir(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (EXT3_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t     EXT3_FEATURE_COMPAT_DIR_INDEX) &&\n\t    ((EXT3_I(inode)->i_flags & EXT3_INDEX_FL) ||\n\t     ((inode->i_size >> sb->s_blocksize_bits) == 1)))\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/compat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_HAS_COMPAT_FEATURE",
          "args": [
            "inode->i_sb",
            "EXT3_FEATURE_COMPAT_DIR_INDEX"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nstatic int is_dx_dir(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (EXT3_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t     EXT3_FEATURE_COMPAT_DIR_INDEX) &&\n\t    ((EXT3_I(inode)->i_flags & EXT3_INDEX_FL) ||\n\t     ((inode->i_size >> sb->s_blocksize_bits) == 1)))\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "get_dtype",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
    "lines": "33-40",
    "snippet": "static unsigned char get_dtype(struct super_block *sb, int filetype)\n{\n\tif (!EXT3_HAS_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_FILETYPE) ||\n\t    (filetype >= EXT3_FT_MAX))\n\t\treturn DT_UNKNOWN;\n\n\treturn (ext3_filetype_table[filetype]);\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/compat.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned char ext3_filetype_table[] = {\n\tDT_UNKNOWN, DT_REG, DT_DIR, DT_CHR, DT_BLK, DT_FIFO, DT_SOCK, DT_LNK\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT3_HAS_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT3_FEATURE_INCOMPAT_FILETYPE"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nstatic unsigned char ext3_filetype_table[] = {\n\tDT_UNKNOWN, DT_REG, DT_DIR, DT_CHR, DT_BLK, DT_FIFO, DT_SOCK, DT_LNK\n};\n\nstatic unsigned char get_dtype(struct super_block *sb, int filetype)\n{\n\tif (!EXT3_HAS_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_FILETYPE) ||\n\t    (filetype >= EXT3_FT_MAX))\n\t\treturn DT_UNKNOWN;\n\n\treturn (ext3_filetype_table[filetype]);\n}"
  }
]