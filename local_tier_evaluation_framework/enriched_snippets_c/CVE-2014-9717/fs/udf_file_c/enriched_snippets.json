[
  {
    "function_name": "udf_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/file.c",
    "lines": "256-275",
    "snippet": "static int udf_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = udf_setsize(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>",
      "#include <linux/string.h> /* memset */",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "setattr_copy",
          "args": [
            "inode",
            "attr"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "__setattr_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
          "lines": "572-597",
          "snippet": "static void __setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) && !capable(CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tset_acl_inode(fi, mode);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/types.h>",
            "#include <linux/falloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define __setattr_copy setattr_copy"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\n#define __setattr_copy setattr_copy\n\nstatic void __setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) && !capable(CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tset_acl_inode(fi, mode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_setsize",
          "args": [
            "inode",
            "attr->ia_size"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "udf_setsize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "1207-1271",
          "snippet": "int udf_setsize(struct inode *inode, loff_t newsize)\n{\n\tint err;\n\tstruct udf_inode_info *iinfo;\n\tint bsize = 1 << inode->i_blkbits;\n\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t      S_ISLNK(inode->i_mode)))\n\t\treturn -EINVAL;\n\tif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\n\tiinfo = UDF_I(inode);\n\tif (newsize > inode->i_size) {\n\t\tdown_write(&iinfo->i_data_sem);\n\t\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\t\tif (bsize <\n\t\t\t    (udf_file_entry_alloc_offset(inode) + newsize)) {\n\t\t\t\terr = udf_expand_file_adinicb(inode);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tdown_write(&iinfo->i_data_sem);\n\t\t\t} else {\n\t\t\t\tiinfo->i_lenAlloc = newsize;\n\t\t\t\tgoto set_size;\n\t\t\t}\n\t\t}\n\t\terr = udf_extend_file(inode, newsize);\n\t\tif (err) {\n\t\t\tup_write(&iinfo->i_data_sem);\n\t\t\treturn err;\n\t\t}\nset_size:\n\t\ttruncate_setsize(inode, newsize);\n\t\tup_write(&iinfo->i_data_sem);\n\t} else {\n\t\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\t\tdown_write(&iinfo->i_data_sem);\n\t\t\tudf_clear_extent_cache(inode);\n\t\t\tmemset(iinfo->i_ext.i_data + iinfo->i_lenEAttr + newsize,\n\t\t\t       0x00, bsize - newsize -\n\t\t\t       udf_file_entry_alloc_offset(inode));\n\t\t\tiinfo->i_lenAlloc = newsize;\n\t\t\ttruncate_setsize(inode, newsize);\n\t\t\tup_write(&iinfo->i_data_sem);\n\t\t\tgoto update_time;\n\t\t}\n\t\terr = block_truncate_page(inode->i_mapping, newsize,\n\t\t\t\t\t  udf_get_block);\n\t\tif (err)\n\t\t\treturn err;\n\t\tdown_write(&iinfo->i_data_sem);\n\t\tudf_clear_extent_cache(inode);\n\t\ttruncate_setsize(inode, newsize);\n\t\tudf_truncate_extents(inode);\n\t\tup_write(&iinfo->i_data_sem);\n\t}\nupdate_time:\n\tinode->i_mtime = inode->i_ctime = current_fs_time(inode->i_sb);\n\tif (IS_SYNC(inode))\n\t\tudf_sync_inode(inode);\n\telse\n\t\tmark_inode_dirty(inode);\n\treturn 0;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\n\nint udf_setsize(struct inode *inode, loff_t newsize)\n{\n\tint err;\n\tstruct udf_inode_info *iinfo;\n\tint bsize = 1 << inode->i_blkbits;\n\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t      S_ISLNK(inode->i_mode)))\n\t\treturn -EINVAL;\n\tif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\n\tiinfo = UDF_I(inode);\n\tif (newsize > inode->i_size) {\n\t\tdown_write(&iinfo->i_data_sem);\n\t\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\t\tif (bsize <\n\t\t\t    (udf_file_entry_alloc_offset(inode) + newsize)) {\n\t\t\t\terr = udf_expand_file_adinicb(inode);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tdown_write(&iinfo->i_data_sem);\n\t\t\t} else {\n\t\t\t\tiinfo->i_lenAlloc = newsize;\n\t\t\t\tgoto set_size;\n\t\t\t}\n\t\t}\n\t\terr = udf_extend_file(inode, newsize);\n\t\tif (err) {\n\t\t\tup_write(&iinfo->i_data_sem);\n\t\t\treturn err;\n\t\t}\nset_size:\n\t\ttruncate_setsize(inode, newsize);\n\t\tup_write(&iinfo->i_data_sem);\n\t} else {\n\t\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\t\tdown_write(&iinfo->i_data_sem);\n\t\t\tudf_clear_extent_cache(inode);\n\t\t\tmemset(iinfo->i_ext.i_data + iinfo->i_lenEAttr + newsize,\n\t\t\t       0x00, bsize - newsize -\n\t\t\t       udf_file_entry_alloc_offset(inode));\n\t\t\tiinfo->i_lenAlloc = newsize;\n\t\t\ttruncate_setsize(inode, newsize);\n\t\t\tup_write(&iinfo->i_data_sem);\n\t\t\tgoto update_time;\n\t\t}\n\t\terr = block_truncate_page(inode->i_mapping, newsize,\n\t\t\t\t\t  udf_get_block);\n\t\tif (err)\n\t\t\treturn err;\n\t\tdown_write(&iinfo->i_data_sem);\n\t\tudf_clear_extent_cache(inode);\n\t\ttruncate_setsize(inode, newsize);\n\t\tudf_truncate_extents(inode);\n\t\tup_write(&iinfo->i_data_sem);\n\t}\nupdate_time:\n\tinode->i_mtime = inode->i_ctime = current_fs_time(inode->i_sb);\n\tif (IS_SYNC(inode))\n\t\tudf_sync_inode(inode);\n\telse\n\t\tmark_inode_dirty(inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_change_ok",
          "args": [
            "inode",
            "attr"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "inode_change_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "31-81",
          "snippet": "int inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n#include <linux/string.h> /* memset */\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstatic int udf_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = udf_setsize(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}"
  },
  {
    "function_name": "udf_release_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/file.c",
    "lines": "224-240",
    "snippet": "static int udf_release_file(struct inode *inode, struct file *filp)\n{\n\tif (filp->f_mode & FMODE_WRITE &&\n\t    atomic_read(&inode->i_writecount) == 1) {\n\t\t/*\n\t\t * Grab i_mutex to avoid races with writes changing i_size\n\t\t * while we are running.\n\t\t */\n\t\tmutex_lock(&inode->i_mutex);\n\t\tdown_write(&UDF_I(inode)->i_data_sem);\n\t\tudf_discard_prealloc(inode);\n\t\tudf_truncate_tail_extent(inode);\n\t\tup_write(&UDF_I(inode)->i_data_sem);\n\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>",
      "#include <linux/string.h> /* memset */",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&UDF_I(inode)->i_data_sem"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "inode"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_truncate_tail_extent",
          "args": [
            "inode"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "udf_truncate_tail_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/truncate.c",
          "lines": "68-120",
          "snippet": "void udf_truncate_tail_extent(struct inode *inode)\n{\n\tstruct extent_position epos = {};\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen, nelen;\n\tuint64_t lbcount = 0;\n\tint8_t etype = -1, netype;\n\tint adsize;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ||\n\t    inode->i_size == iinfo->i_lenExtents)\n\t\treturn;\n\t/* Are we going to delete the file anyway? */\n\tif (inode->i_nlink == 0)\n\t\treturn;\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\tBUG();\n\n\t/* Find the last extent in the file */\n\twhile ((netype = udf_next_aext(inode, &epos, &eloc, &elen, 1)) != -1) {\n\t\tetype = netype;\n\t\tlbcount += elen;\n\t\tif (lbcount > inode->i_size) {\n\t\t\tif (lbcount - inode->i_size >= inode->i_sb->s_blocksize)\n\t\t\t\tudf_warn(inode->i_sb,\n\t\t\t\t\t \"Too long extent after EOF in inode %u: i_size: %lld lbcount: %lld extent %u+%u\\n\",\n\t\t\t\t\t (unsigned)inode->i_ino,\n\t\t\t\t\t (long long)inode->i_size,\n\t\t\t\t\t (long long)lbcount,\n\t\t\t\t\t (unsigned)eloc.logicalBlockNum,\n\t\t\t\t\t (unsigned)elen);\n\t\t\tnelen = elen - (lbcount - inode->i_size);\n\t\t\tepos.offset -= adsize;\n\t\t\textent_trunc(inode, &epos, &eloc, etype, elen, nelen);\n\t\t\tepos.offset += adsize;\n\t\t\tif (udf_next_aext(inode, &epos, &eloc, &elen, 1) != -1)\n\t\t\t\tudf_err(inode->i_sb,\n\t\t\t\t\t\"Extent after EOF in inode %u\\n\",\n\t\t\t\t\t(unsigned)inode->i_ino);\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* This inode entry is in-memory only and thus we don't have to mark\n\t * the inode dirty */\n\tiinfo->i_lenExtents = inode->i_size;\n\tbrelse(epos.bh);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nvoid udf_truncate_tail_extent(struct inode *inode)\n{\n\tstruct extent_position epos = {};\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen, nelen;\n\tuint64_t lbcount = 0;\n\tint8_t etype = -1, netype;\n\tint adsize;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ||\n\t    inode->i_size == iinfo->i_lenExtents)\n\t\treturn;\n\t/* Are we going to delete the file anyway? */\n\tif (inode->i_nlink == 0)\n\t\treturn;\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\tBUG();\n\n\t/* Find the last extent in the file */\n\twhile ((netype = udf_next_aext(inode, &epos, &eloc, &elen, 1)) != -1) {\n\t\tetype = netype;\n\t\tlbcount += elen;\n\t\tif (lbcount > inode->i_size) {\n\t\t\tif (lbcount - inode->i_size >= inode->i_sb->s_blocksize)\n\t\t\t\tudf_warn(inode->i_sb,\n\t\t\t\t\t \"Too long extent after EOF in inode %u: i_size: %lld lbcount: %lld extent %u+%u\\n\",\n\t\t\t\t\t (unsigned)inode->i_ino,\n\t\t\t\t\t (long long)inode->i_size,\n\t\t\t\t\t (long long)lbcount,\n\t\t\t\t\t (unsigned)eloc.logicalBlockNum,\n\t\t\t\t\t (unsigned)elen);\n\t\t\tnelen = elen - (lbcount - inode->i_size);\n\t\t\tepos.offset -= adsize;\n\t\t\textent_trunc(inode, &epos, &eloc, etype, elen, nelen);\n\t\t\tepos.offset += adsize;\n\t\t\tif (udf_next_aext(inode, &epos, &eloc, &elen, 1) != -1)\n\t\t\t\tudf_err(inode->i_sb,\n\t\t\t\t\t\"Extent after EOF in inode %u\\n\",\n\t\t\t\t\t(unsigned)inode->i_ino);\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* This inode entry is in-memory only and thus we don't have to mark\n\t * the inode dirty */\n\tiinfo->i_lenExtents = inode->i_size;\n\tbrelse(epos.bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_discard_prealloc",
          "args": [
            "inode"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "udf_discard_prealloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/truncate.c",
          "lines": "122-178",
          "snippet": "void udf_discard_prealloc(struct inode *inode)\n{\n\tstruct extent_position epos = { NULL, 0, {0, 0} };\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tuint64_t lbcount = 0;\n\tint8_t etype = -1, netype;\n\tint adsize;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ||\n\t    inode->i_size == iinfo->i_lenExtents)\n\t\treturn;\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\tadsize = 0;\n\n\tepos.block = iinfo->i_location;\n\n\t/* Find the last extent in the file */\n\twhile ((netype = udf_next_aext(inode, &epos, &eloc, &elen, 1)) != -1) {\n\t\tetype = netype;\n\t\tlbcount += elen;\n\t}\n\tif (etype == (EXT_NOT_RECORDED_ALLOCATED >> 30)) {\n\t\tepos.offset -= adsize;\n\t\tlbcount -= elen;\n\t\textent_trunc(inode, &epos, &eloc, etype, elen, 0);\n\t\tif (!epos.bh) {\n\t\t\tiinfo->i_lenAlloc =\n\t\t\t\tepos.offset -\n\t\t\t\tudf_file_entry_alloc_offset(inode);\n\t\t\tmark_inode_dirty(inode);\n\t\t} else {\n\t\t\tstruct allocExtDesc *aed =\n\t\t\t\t(struct allocExtDesc *)(epos.bh->b_data);\n\t\t\taed->lengthAllocDescs =\n\t\t\t\tcpu_to_le32(epos.offset -\n\t\t\t\t\t    sizeof(struct allocExtDesc));\n\t\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201)\n\t\t\t\tudf_update_tag(epos.bh->b_data, epos.offset);\n\t\t\telse\n\t\t\t\tudf_update_tag(epos.bh->b_data,\n\t\t\t\t\t       sizeof(struct allocExtDesc));\n\t\t\tmark_buffer_dirty_inode(epos.bh, inode);\n\t\t}\n\t}\n\t/* This inode entry is in-memory only and thus we don't have to mark\n\t * the inode dirty */\n\tiinfo->i_lenExtents = lbcount;\n\tbrelse(epos.bh);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/buffer_head.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nvoid udf_discard_prealloc(struct inode *inode)\n{\n\tstruct extent_position epos = { NULL, 0, {0, 0} };\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tuint64_t lbcount = 0;\n\tint8_t etype = -1, netype;\n\tint adsize;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ||\n\t    inode->i_size == iinfo->i_lenExtents)\n\t\treturn;\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\tadsize = sizeof(struct short_ad);\n\telse if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\tadsize = sizeof(struct long_ad);\n\telse\n\t\tadsize = 0;\n\n\tepos.block = iinfo->i_location;\n\n\t/* Find the last extent in the file */\n\twhile ((netype = udf_next_aext(inode, &epos, &eloc, &elen, 1)) != -1) {\n\t\tetype = netype;\n\t\tlbcount += elen;\n\t}\n\tif (etype == (EXT_NOT_RECORDED_ALLOCATED >> 30)) {\n\t\tepos.offset -= adsize;\n\t\tlbcount -= elen;\n\t\textent_trunc(inode, &epos, &eloc, etype, elen, 0);\n\t\tif (!epos.bh) {\n\t\t\tiinfo->i_lenAlloc =\n\t\t\t\tepos.offset -\n\t\t\t\tudf_file_entry_alloc_offset(inode);\n\t\t\tmark_inode_dirty(inode);\n\t\t} else {\n\t\t\tstruct allocExtDesc *aed =\n\t\t\t\t(struct allocExtDesc *)(epos.bh->b_data);\n\t\t\taed->lengthAllocDescs =\n\t\t\t\tcpu_to_le32(epos.offset -\n\t\t\t\t\t    sizeof(struct allocExtDesc));\n\t\t\tif (!UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_STRICT) ||\n\t\t\t    UDF_SB(inode->i_sb)->s_udfrev >= 0x0201)\n\t\t\t\tudf_update_tag(epos.bh->b_data, epos.offset);\n\t\t\telse\n\t\t\t\tudf_update_tag(epos.bh->b_data,\n\t\t\t\t\t       sizeof(struct allocExtDesc));\n\t\t\tmark_buffer_dirty_inode(epos.bh, inode);\n\t\t}\n\t}\n\t/* This inode entry is in-memory only and thus we don't have to mark\n\t * the inode dirty */\n\tiinfo->i_lenExtents = lbcount;\n\tbrelse(epos.bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&UDF_I(inode)->i_data_sem"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&inode->i_writecount"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n#include <linux/string.h> /* memset */\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstatic int udf_release_file(struct inode *inode, struct file *filp)\n{\n\tif (filp->f_mode & FMODE_WRITE &&\n\t    atomic_read(&inode->i_writecount) == 1) {\n\t\t/*\n\t\t * Grab i_mutex to avoid races with writes changing i_size\n\t\t * while we are running.\n\t\t */\n\t\tmutex_lock(&inode->i_mutex);\n\t\tdown_write(&UDF_I(inode)->i_data_sem);\n\t\tudf_discard_prealloc(inode);\n\t\tudf_truncate_tail_extent(inode);\n\t\tup_write(&UDF_I(inode)->i_data_sem);\n\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "udf_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/file.c",
    "lines": "170-222",
    "snippet": "long udf_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tlong old_block, new_block;\n\tint result = -EINVAL;\n\n\tif (inode_permission(inode, MAY_READ) != 0) {\n\t\tudf_debug(\"no permission to access inode %lu\\n\", inode->i_ino);\n\t\tresult = -EPERM;\n\t\tgoto out;\n\t}\n\n\tif (!arg) {\n\t\tudf_debug(\"invalid argument to udf_ioctl\\n\");\n\t\tresult = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tswitch (cmd) {\n\tcase UDF_GETVOLIDENT:\n\t\tif (copy_to_user((char __user *)arg,\n\t\t\t\t UDF_SB(inode->i_sb)->s_volume_ident, 32))\n\t\t\tresult = -EFAULT;\n\t\telse\n\t\t\tresult = 0;\n\t\tgoto out;\n\tcase UDF_RELOCATE_BLOCKS:\n\t\tif (!capable(CAP_SYS_ADMIN)) {\n\t\t\tresult = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\t\tif (get_user(old_block, (long __user *)arg)) {\n\t\t\tresult = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tresult = udf_relocate_blocks(inode->i_sb,\n\t\t\t\t\t\told_block, &new_block);\n\t\tif (result == 0)\n\t\t\tresult = put_user(new_block, (long __user *)arg);\n\t\tgoto out;\n\tcase UDF_GETEASIZE:\n\t\tresult = put_user(UDF_I(inode)->i_lenEAttr, (int __user *)arg);\n\t\tgoto out;\n\tcase UDF_GETEABLOCK:\n\t\tresult = copy_to_user((char __user *)arg,\n\t\t\t\t      UDF_I(inode)->i_ext.i_data,\n\t\t\t\t      UDF_I(inode)->i_lenEAttr) ? -EFAULT : 0;\n\t\tgoto out;\n\t}\n\nout:\n\treturn result;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>",
      "#include <linux/string.h> /* memset */",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "(char __user *)arg",
            "UDF_I(inode)->i_ext.i_data",
            "UDF_I(inode)->i_lenEAttr"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "inode"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "UDF_I(inode)->i_lenEAttr",
            "(int __user *)arg"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "new_block",
            "(long __user *)arg"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_relocate_blocks",
          "args": [
            "inode->i_sb",
            "old_block",
            "&new_block"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "udf_relocate_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/partition.c",
          "lines": "153-279",
          "snippet": "int udf_relocate_blocks(struct super_block *sb, long old_block, long *new_block)\n{\n\tstruct udf_sparing_data *sdata;\n\tstruct sparingTable *st = NULL;\n\tstruct sparingEntry mapEntry;\n\tuint32_t packet;\n\tint i, j, k, l;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tu16 reallocationTableLen;\n\tstruct buffer_head *bh;\n\tint ret = 0;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tfor (i = 0; i < sbi->s_partitions; i++) {\n\t\tstruct udf_part_map *map = &sbi->s_partmaps[i];\n\t\tif (old_block > map->s_partition_root &&\n\t\t    old_block < map->s_partition_root + map->s_partition_len) {\n\t\t\tsdata = &map->s_type_specific.s_sparing;\n\t\t\tpacket = (old_block - map->s_partition_root) &\n\t\t\t\t\t\t~(sdata->s_packet_len - 1);\n\n\t\t\tfor (j = 0; j < 4; j++)\n\t\t\t\tif (sdata->s_spar_map[j] != NULL) {\n\t\t\t\t\tst = (struct sparingTable *)\n\t\t\t\t\t\tsdata->s_spar_map[j]->b_data;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tif (!st) {\n\t\t\t\tret = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\treallocationTableLen =\n\t\t\t\t\tle16_to_cpu(st->reallocationTableLen);\n\t\t\tfor (k = 0; k < reallocationTableLen; k++) {\n\t\t\t\tstruct sparingEntry *entry = &st->mapEntry[k];\n\t\t\t\tu32 origLoc = le32_to_cpu(entry->origLocation);\n\n\t\t\t\tif (origLoc == 0xFFFFFFFF) {\n\t\t\t\t\tfor (; j < 4; j++) {\n\t\t\t\t\t\tint len;\n\t\t\t\t\t\tbh = sdata->s_spar_map[j];\n\t\t\t\t\t\tif (!bh)\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tst = (struct sparingTable *)\n\t\t\t\t\t\t\t\tbh->b_data;\n\t\t\t\t\t\tentry->origLocation =\n\t\t\t\t\t\t\tcpu_to_le32(packet);\n\t\t\t\t\t\tlen =\n\t\t\t\t\t\t  sizeof(struct sparingTable) +\n\t\t\t\t\t\t  reallocationTableLen *\n\t\t\t\t\t\t  sizeof(struct sparingEntry);\n\t\t\t\t\t\tudf_update_tag((char *)st, len);\n\t\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\t}\n\t\t\t\t\t*new_block = le32_to_cpu(\n\t\t\t\t\t\t\tentry->mappedLocation) +\n\t\t\t\t\t\t     ((old_block -\n\t\t\t\t\t\t\tmap->s_partition_root) &\n\t\t\t\t\t\t     (sdata->s_packet_len - 1));\n\t\t\t\t\tret = 0;\n\t\t\t\t\tgoto out;\n\t\t\t\t} else if (origLoc == packet) {\n\t\t\t\t\t*new_block = le32_to_cpu(\n\t\t\t\t\t\t\tentry->mappedLocation) +\n\t\t\t\t\t\t     ((old_block -\n\t\t\t\t\t\t\tmap->s_partition_root) &\n\t\t\t\t\t\t     (sdata->s_packet_len - 1));\n\t\t\t\t\tret = 0;\n\t\t\t\t\tgoto out;\n\t\t\t\t} else if (origLoc > packet)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (l = k; l < reallocationTableLen; l++) {\n\t\t\t\tstruct sparingEntry *entry = &st->mapEntry[l];\n\t\t\t\tu32 origLoc = le32_to_cpu(entry->origLocation);\n\n\t\t\t\tif (origLoc != 0xFFFFFFFF)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfor (; j < 4; j++) {\n\t\t\t\t\tbh = sdata->s_spar_map[j];\n\t\t\t\t\tif (!bh)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tst = (struct sparingTable *)bh->b_data;\n\t\t\t\t\tmapEntry = st->mapEntry[l];\n\t\t\t\t\tmapEntry.origLocation =\n\t\t\t\t\t\t\tcpu_to_le32(packet);\n\t\t\t\t\tmemmove(&st->mapEntry[k + 1],\n\t\t\t\t\t\t&st->mapEntry[k],\n\t\t\t\t\t\t(l - k) *\n\t\t\t\t\t\tsizeof(struct sparingEntry));\n\t\t\t\t\tst->mapEntry[k] = mapEntry;\n\t\t\t\t\tudf_update_tag((char *)st,\n\t\t\t\t\t\tsizeof(struct sparingTable) +\n\t\t\t\t\t\treallocationTableLen *\n\t\t\t\t\t\tsizeof(struct sparingEntry));\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t}\n\t\t\t\t*new_block =\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\t      st->mapEntry[k].mappedLocation) +\n\t\t\t\t\t((old_block - map->s_partition_root) &\n\t\t\t\t\t (sdata->s_packet_len - 1));\n\t\t\t\tret = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t} /* if old_block */\n\t}\n\n\tif (i == sbi->s_partitions) {\n\t\t/* outside of partitions */\n\t\t/* for now, fail =) */\n\t\tret = 1;\n\t}\n\nout:\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include \"udfdecl.h\"\n\nint udf_relocate_blocks(struct super_block *sb, long old_block, long *new_block)\n{\n\tstruct udf_sparing_data *sdata;\n\tstruct sparingTable *st = NULL;\n\tstruct sparingEntry mapEntry;\n\tuint32_t packet;\n\tint i, j, k, l;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tu16 reallocationTableLen;\n\tstruct buffer_head *bh;\n\tint ret = 0;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tfor (i = 0; i < sbi->s_partitions; i++) {\n\t\tstruct udf_part_map *map = &sbi->s_partmaps[i];\n\t\tif (old_block > map->s_partition_root &&\n\t\t    old_block < map->s_partition_root + map->s_partition_len) {\n\t\t\tsdata = &map->s_type_specific.s_sparing;\n\t\t\tpacket = (old_block - map->s_partition_root) &\n\t\t\t\t\t\t~(sdata->s_packet_len - 1);\n\n\t\t\tfor (j = 0; j < 4; j++)\n\t\t\t\tif (sdata->s_spar_map[j] != NULL) {\n\t\t\t\t\tst = (struct sparingTable *)\n\t\t\t\t\t\tsdata->s_spar_map[j]->b_data;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tif (!st) {\n\t\t\t\tret = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\treallocationTableLen =\n\t\t\t\t\tle16_to_cpu(st->reallocationTableLen);\n\t\t\tfor (k = 0; k < reallocationTableLen; k++) {\n\t\t\t\tstruct sparingEntry *entry = &st->mapEntry[k];\n\t\t\t\tu32 origLoc = le32_to_cpu(entry->origLocation);\n\n\t\t\t\tif (origLoc == 0xFFFFFFFF) {\n\t\t\t\t\tfor (; j < 4; j++) {\n\t\t\t\t\t\tint len;\n\t\t\t\t\t\tbh = sdata->s_spar_map[j];\n\t\t\t\t\t\tif (!bh)\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tst = (struct sparingTable *)\n\t\t\t\t\t\t\t\tbh->b_data;\n\t\t\t\t\t\tentry->origLocation =\n\t\t\t\t\t\t\tcpu_to_le32(packet);\n\t\t\t\t\t\tlen =\n\t\t\t\t\t\t  sizeof(struct sparingTable) +\n\t\t\t\t\t\t  reallocationTableLen *\n\t\t\t\t\t\t  sizeof(struct sparingEntry);\n\t\t\t\t\t\tudf_update_tag((char *)st, len);\n\t\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\t}\n\t\t\t\t\t*new_block = le32_to_cpu(\n\t\t\t\t\t\t\tentry->mappedLocation) +\n\t\t\t\t\t\t     ((old_block -\n\t\t\t\t\t\t\tmap->s_partition_root) &\n\t\t\t\t\t\t     (sdata->s_packet_len - 1));\n\t\t\t\t\tret = 0;\n\t\t\t\t\tgoto out;\n\t\t\t\t} else if (origLoc == packet) {\n\t\t\t\t\t*new_block = le32_to_cpu(\n\t\t\t\t\t\t\tentry->mappedLocation) +\n\t\t\t\t\t\t     ((old_block -\n\t\t\t\t\t\t\tmap->s_partition_root) &\n\t\t\t\t\t\t     (sdata->s_packet_len - 1));\n\t\t\t\t\tret = 0;\n\t\t\t\t\tgoto out;\n\t\t\t\t} else if (origLoc > packet)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (l = k; l < reallocationTableLen; l++) {\n\t\t\t\tstruct sparingEntry *entry = &st->mapEntry[l];\n\t\t\t\tu32 origLoc = le32_to_cpu(entry->origLocation);\n\n\t\t\t\tif (origLoc != 0xFFFFFFFF)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfor (; j < 4; j++) {\n\t\t\t\t\tbh = sdata->s_spar_map[j];\n\t\t\t\t\tif (!bh)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tst = (struct sparingTable *)bh->b_data;\n\t\t\t\t\tmapEntry = st->mapEntry[l];\n\t\t\t\t\tmapEntry.origLocation =\n\t\t\t\t\t\t\tcpu_to_le32(packet);\n\t\t\t\t\tmemmove(&st->mapEntry[k + 1],\n\t\t\t\t\t\t&st->mapEntry[k],\n\t\t\t\t\t\t(l - k) *\n\t\t\t\t\t\tsizeof(struct sparingEntry));\n\t\t\t\t\tst->mapEntry[k] = mapEntry;\n\t\t\t\t\tudf_update_tag((char *)st,\n\t\t\t\t\t\tsizeof(struct sparingTable) +\n\t\t\t\t\t\treallocationTableLen *\n\t\t\t\t\t\tsizeof(struct sparingEntry));\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t}\n\t\t\t\t*new_block =\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\t      st->mapEntry[k].mappedLocation) +\n\t\t\t\t\t((old_block - map->s_partition_root) &\n\t\t\t\t\t (sdata->s_packet_len - 1));\n\t\t\t\tret = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t} /* if old_block */\n\t}\n\n\tif (i == sbi->s_partitions) {\n\t\t/* outside of partitions */\n\t\t/* for now, fail =) */\n\t\tret = 1;\n\t}\n\nout:\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "old_block",
            "(long __user *)arg"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_arg_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "399-418",
          "snippet": "static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "(char __user *)arg",
            "UDF_SB(inode->i_sb)->s_volume_ident",
            "32"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"invalid argument to udf_ioctl\\n\""
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"no permission to access inode %lu\\n\"",
            "inode->i_ino"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_permission",
          "args": [
            "inode",
            "MAY_READ"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "inode_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "459-467",
          "snippet": "int inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\treturn __inode_permission(inode, mask);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\treturn __inode_permission(inode, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n#include <linux/string.h> /* memset */\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nlong udf_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tlong old_block, new_block;\n\tint result = -EINVAL;\n\n\tif (inode_permission(inode, MAY_READ) != 0) {\n\t\tudf_debug(\"no permission to access inode %lu\\n\", inode->i_ino);\n\t\tresult = -EPERM;\n\t\tgoto out;\n\t}\n\n\tif (!arg) {\n\t\tudf_debug(\"invalid argument to udf_ioctl\\n\");\n\t\tresult = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tswitch (cmd) {\n\tcase UDF_GETVOLIDENT:\n\t\tif (copy_to_user((char __user *)arg,\n\t\t\t\t UDF_SB(inode->i_sb)->s_volume_ident, 32))\n\t\t\tresult = -EFAULT;\n\t\telse\n\t\t\tresult = 0;\n\t\tgoto out;\n\tcase UDF_RELOCATE_BLOCKS:\n\t\tif (!capable(CAP_SYS_ADMIN)) {\n\t\t\tresult = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\t\tif (get_user(old_block, (long __user *)arg)) {\n\t\t\tresult = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tresult = udf_relocate_blocks(inode->i_sb,\n\t\t\t\t\t\told_block, &new_block);\n\t\tif (result == 0)\n\t\t\tresult = put_user(new_block, (long __user *)arg);\n\t\tgoto out;\n\tcase UDF_GETEASIZE:\n\t\tresult = put_user(UDF_I(inode)->i_lenEAttr, (int __user *)arg);\n\t\tgoto out;\n\tcase UDF_GETEABLOCK:\n\t\tresult = copy_to_user((char __user *)arg,\n\t\t\t\t      UDF_I(inode)->i_ext.i_data,\n\t\t\t\t      UDF_I(inode)->i_lenEAttr) ? -EFAULT : 0;\n\t\tgoto out;\n\t}\n\nout:\n\treturn result;\n}"
  },
  {
    "function_name": "udf_file_write_iter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/file.c",
    "lines": "119-168",
    "snippet": "static ssize_t udf_file_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tssize_t retval;\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tint err, pos;\n\tsize_t count = iocb->ki_nbytes;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tmutex_lock(&inode->i_mutex);\n\tdown_write(&iinfo->i_data_sem);\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\tif (file->f_flags & O_APPEND)\n\t\t\tpos = inode->i_size;\n\t\telse\n\t\t\tpos = iocb->ki_pos;\n\n\t\tif (inode->i_sb->s_blocksize <\n\t\t\t\t(udf_file_entry_alloc_offset(inode) +\n\t\t\t\t\t\tpos + count)) {\n\t\t\terr = udf_expand_file_adinicb(inode);\n\t\t\tif (err) {\n\t\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\t\tudf_debug(\"udf_expand_adinicb: err=%d\\n\", err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t} else {\n\t\t\tif (pos + count > inode->i_size)\n\t\t\t\tiinfo->i_lenAlloc = pos + count;\n\t\t\telse\n\t\t\t\tiinfo->i_lenAlloc = inode->i_size;\n\t\t\tup_write(&iinfo->i_data_sem);\n\t\t}\n\t} else\n\t\tup_write(&iinfo->i_data_sem);\n\n\tretval = __generic_file_write_iter(iocb, from);\n\tmutex_unlock(&inode->i_mutex);\n\n\tif (retval > 0) {\n\t\tssize_t err;\n\n\t\tmark_inode_dirty(inode);\n\t\terr = generic_write_sync(file, iocb->ki_pos - retval, retval);\n\t\tif (err < 0)\n\t\t\tretval = err;\n\t}\n\n\treturn retval;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>",
      "#include <linux/string.h> /* memset */",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_write_sync",
          "args": [
            "file",
            "iocb->ki_pos - retval",
            "retval"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__generic_file_write_iter",
          "args": [
            "iocb",
            "from"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&iinfo->i_data_sem"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&iinfo->i_data_sem"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"udf_expand_adinicb: err=%d\\n\"",
            "err"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_expand_file_adinicb",
          "args": [
            "inode"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "udf_expand_file_adinicb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "256-328",
          "snippet": "int udf_expand_file_adinicb(struct inode *inode)\n{\n\tstruct page *page;\n\tchar *kaddr;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tint err;\n\tstruct writeback_control udf_wbc = {\n\t\t.sync_mode = WB_SYNC_NONE,\n\t\t.nr_to_write = 1,\n\t};\n\n\tWARN_ON_ONCE(!mutex_is_locked(&inode->i_mutex));\n\tif (!iinfo->i_lenAlloc) {\n\t\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n\t\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_SHORT;\n\t\telse\n\t\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_LONG;\n\t\t/* from now on we have normal address_space methods */\n\t\tinode->i_data.a_ops = &udf_aops;\n\t\tup_write(&iinfo->i_data_sem);\n\t\tmark_inode_dirty(inode);\n\t\treturn 0;\n\t}\n\t/*\n\t * Release i_data_sem so that we can lock a page - page lock ranks\n\t * above i_data_sem. i_mutex still protects us against file changes.\n\t */\n\tup_write(&iinfo->i_data_sem);\n\n\tpage = find_or_create_page(inode->i_mapping, 0, GFP_NOFS);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tif (!PageUptodate(page)) {\n\t\tkaddr = kmap(page);\n\t\tmemset(kaddr + iinfo->i_lenAlloc, 0x00,\n\t\t       PAGE_CACHE_SIZE - iinfo->i_lenAlloc);\n\t\tmemcpy(kaddr, iinfo->i_ext.i_data + iinfo->i_lenEAttr,\n\t\t\tiinfo->i_lenAlloc);\n\t\tflush_dcache_page(page);\n\t\tSetPageUptodate(page);\n\t\tkunmap(page);\n\t}\n\tdown_write(&iinfo->i_data_sem);\n\tmemset(iinfo->i_ext.i_data + iinfo->i_lenEAttr, 0x00,\n\t       iinfo->i_lenAlloc);\n\tiinfo->i_lenAlloc = 0;\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_SHORT;\n\telse\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_LONG;\n\t/* from now on we have normal address_space methods */\n\tinode->i_data.a_ops = &udf_aops;\n\tup_write(&iinfo->i_data_sem);\n\terr = inode->i_data.a_ops->writepage(page, &udf_wbc);\n\tif (err) {\n\t\t/* Restore everything back so that we don't lose data... */\n\t\tlock_page(page);\n\t\tkaddr = kmap(page);\n\t\tdown_write(&iinfo->i_data_sem);\n\t\tmemcpy(iinfo->i_ext.i_data + iinfo->i_lenEAttr, kaddr,\n\t\t       inode->i_size);\n\t\tkunmap(page);\n\t\tunlock_page(page);\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_IN_ICB;\n\t\tinode->i_data.a_ops = &udf_adinicb_aops;\n\t\tup_write(&iinfo->i_data_sem);\n\t}\n\tpage_cache_release(page);\n\tmark_inode_dirty(inode);\n\n\treturn err;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "const struct address_space_operations udf_aops = {\n\t.readpage\t= udf_readpage,\n\t.readpages\t= udf_readpages,\n\t.writepage\t= udf_writepage,\n\t.writepages\t= udf_writepages,\n\t.write_begin\t= udf_write_begin,\n\t.write_end\t= generic_write_end,\n\t.direct_IO\t= udf_direct_IO,\n\t.bmap\t\t= udf_bmap,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nconst struct address_space_operations udf_aops = {\n\t.readpage\t= udf_readpage,\n\t.readpages\t= udf_readpages,\n\t.writepage\t= udf_writepage,\n\t.writepages\t= udf_writepages,\n\t.write_begin\t= udf_write_begin,\n\t.write_end\t= generic_write_end,\n\t.direct_IO\t= udf_direct_IO,\n\t.bmap\t\t= udf_bmap,\n};\n\nint udf_expand_file_adinicb(struct inode *inode)\n{\n\tstruct page *page;\n\tchar *kaddr;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tint err;\n\tstruct writeback_control udf_wbc = {\n\t\t.sync_mode = WB_SYNC_NONE,\n\t\t.nr_to_write = 1,\n\t};\n\n\tWARN_ON_ONCE(!mutex_is_locked(&inode->i_mutex));\n\tif (!iinfo->i_lenAlloc) {\n\t\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n\t\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_SHORT;\n\t\telse\n\t\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_LONG;\n\t\t/* from now on we have normal address_space methods */\n\t\tinode->i_data.a_ops = &udf_aops;\n\t\tup_write(&iinfo->i_data_sem);\n\t\tmark_inode_dirty(inode);\n\t\treturn 0;\n\t}\n\t/*\n\t * Release i_data_sem so that we can lock a page - page lock ranks\n\t * above i_data_sem. i_mutex still protects us against file changes.\n\t */\n\tup_write(&iinfo->i_data_sem);\n\n\tpage = find_or_create_page(inode->i_mapping, 0, GFP_NOFS);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tif (!PageUptodate(page)) {\n\t\tkaddr = kmap(page);\n\t\tmemset(kaddr + iinfo->i_lenAlloc, 0x00,\n\t\t       PAGE_CACHE_SIZE - iinfo->i_lenAlloc);\n\t\tmemcpy(kaddr, iinfo->i_ext.i_data + iinfo->i_lenEAttr,\n\t\t\tiinfo->i_lenAlloc);\n\t\tflush_dcache_page(page);\n\t\tSetPageUptodate(page);\n\t\tkunmap(page);\n\t}\n\tdown_write(&iinfo->i_data_sem);\n\tmemset(iinfo->i_ext.i_data + iinfo->i_lenEAttr, 0x00,\n\t       iinfo->i_lenAlloc);\n\tiinfo->i_lenAlloc = 0;\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_SHORT;\n\telse\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_LONG;\n\t/* from now on we have normal address_space methods */\n\tinode->i_data.a_ops = &udf_aops;\n\tup_write(&iinfo->i_data_sem);\n\terr = inode->i_data.a_ops->writepage(page, &udf_wbc);\n\tif (err) {\n\t\t/* Restore everything back so that we don't lose data... */\n\t\tlock_page(page);\n\t\tkaddr = kmap(page);\n\t\tdown_write(&iinfo->i_data_sem);\n\t\tmemcpy(iinfo->i_ext.i_data + iinfo->i_lenEAttr, kaddr,\n\t\t       inode->i_size);\n\t\tkunmap(page);\n\t\tunlock_page(page);\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_IN_ICB;\n\t\tinode->i_data.a_ops = &udf_adinicb_aops;\n\t\tup_write(&iinfo->i_data_sem);\n\t}\n\tpage_cache_release(page);\n\tmark_inode_dirty(inode);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_file_entry_alloc_offset",
          "args": [
            "inode"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "udf_file_entry_alloc_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "55-64",
          "snippet": "static inline size_t udf_file_entry_alloc_offset(struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tif (iinfo->i_use)\n\t\treturn sizeof(struct unallocSpaceEntry);\n\telse if (iinfo->i_efe)\n\t\treturn sizeof(struct extendedFileEntry) + iinfo->i_lenEAttr;\n\telse\n\t\treturn sizeof(struct fileEntry) + iinfo->i_lenEAttr;\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline size_t udf_file_entry_alloc_offset(struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tif (iinfo->i_use)\n\t\treturn sizeof(struct unallocSpaceEntry);\n\telse if (iinfo->i_efe)\n\t\treturn sizeof(struct extendedFileEntry) + iinfo->i_lenEAttr;\n\telse\n\t\treturn sizeof(struct fileEntry) + iinfo->i_lenEAttr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&iinfo->i_data_sem"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "inode"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n#include <linux/string.h> /* memset */\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstatic ssize_t udf_file_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tssize_t retval;\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tint err, pos;\n\tsize_t count = iocb->ki_nbytes;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tmutex_lock(&inode->i_mutex);\n\tdown_write(&iinfo->i_data_sem);\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\tif (file->f_flags & O_APPEND)\n\t\t\tpos = inode->i_size;\n\t\telse\n\t\t\tpos = iocb->ki_pos;\n\n\t\tif (inode->i_sb->s_blocksize <\n\t\t\t\t(udf_file_entry_alloc_offset(inode) +\n\t\t\t\t\t\tpos + count)) {\n\t\t\terr = udf_expand_file_adinicb(inode);\n\t\t\tif (err) {\n\t\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\t\tudf_debug(\"udf_expand_adinicb: err=%d\\n\", err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t} else {\n\t\t\tif (pos + count > inode->i_size)\n\t\t\t\tiinfo->i_lenAlloc = pos + count;\n\t\t\telse\n\t\t\t\tiinfo->i_lenAlloc = inode->i_size;\n\t\t\tup_write(&iinfo->i_data_sem);\n\t\t}\n\t} else\n\t\tup_write(&iinfo->i_data_sem);\n\n\tretval = __generic_file_write_iter(iocb, from);\n\tmutex_unlock(&inode->i_mutex);\n\n\tif (retval > 0) {\n\t\tssize_t err;\n\n\t\tmark_inode_dirty(inode);\n\t\terr = generic_write_sync(file, iocb->ki_pos - retval, retval);\n\t\tif (err < 0)\n\t\t\tretval = err;\n\t}\n\n\treturn retval;\n}"
  },
  {
    "function_name": "udf_adinicb_direct_IO",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/file.c",
    "lines": "103-109",
    "snippet": "static ssize_t udf_adinicb_direct_IO(int rw, struct kiocb *iocb,\n\t\t\t\t     struct iov_iter *iter,\n\t\t\t\t     loff_t offset)\n{\n\t/* Fallback to buffered I/O. */\n\treturn 0;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>",
      "#include <linux/string.h> /* memset */",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n#include <linux/string.h> /* memset */\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstatic ssize_t udf_adinicb_direct_IO(int rw, struct kiocb *iocb,\n\t\t\t\t     struct iov_iter *iter,\n\t\t\t\t     loff_t offset)\n{\n\t/* Fallback to buffered I/O. */\n\treturn 0;\n}"
  },
  {
    "function_name": "udf_adinicb_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/file.c",
    "lines": "84-101",
    "snippet": "static int udf_adinicb_write_begin(struct file *file,\n\t\t\tstruct address_space *mapping, loff_t pos,\n\t\t\tunsigned len, unsigned flags, struct page **pagep,\n\t\t\tvoid **fsdata)\n{\n\tstruct page *page;\n\n\tif (WARN_ON_ONCE(pos >= PAGE_CACHE_SIZE))\n\t\treturn -EIO;\n\tpage = grab_cache_page_write_begin(mapping, 0, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\t*pagep = page;\n\n\tif (!PageUptodate(page) && len != PAGE_CACHE_SIZE)\n\t\t__udf_adinicb_readpage(page);\n\treturn 0;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>",
      "#include <linux/string.h> /* memset */",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__udf_adinicb_readpage",
          "args": [
            "page"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "__udf_adinicb_readpage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/file.c",
          "lines": "42-54",
          "snippet": "static void __udf_adinicb_readpage(struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tchar *kaddr;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tkaddr = kmap(page);\n\tmemcpy(kaddr, iinfo->i_ext.i_data + iinfo->i_lenEAttr, inode->i_size);\n\tmemset(kaddr + inode->i_size, 0, PAGE_CACHE_SIZE - inode->i_size);\n\tflush_dcache_page(page);\n\tSetPageUptodate(page);\n\tkunmap(page);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/errno.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h> /* memset */",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n#include <linux/string.h> /* memset */\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstatic void __udf_adinicb_readpage(struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tchar *kaddr;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tkaddr = kmap(page);\n\tmemcpy(kaddr, iinfo->i_ext.i_data + iinfo->i_lenEAttr, inode->i_size);\n\tmemset(kaddr + inode->i_size, 0, PAGE_CACHE_SIZE - inode->i_size);\n\tflush_dcache_page(page);\n\tSetPageUptodate(page);\n\tkunmap(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_cache_page_write_begin",
          "args": [
            "mapping",
            "0",
            "flags"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "pos >= PAGE_CACHE_SIZE"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n#include <linux/string.h> /* memset */\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstatic int udf_adinicb_write_begin(struct file *file,\n\t\t\tstruct address_space *mapping, loff_t pos,\n\t\t\tunsigned len, unsigned flags, struct page **pagep,\n\t\t\tvoid **fsdata)\n{\n\tstruct page *page;\n\n\tif (WARN_ON_ONCE(pos >= PAGE_CACHE_SIZE))\n\t\treturn -EIO;\n\tpage = grab_cache_page_write_begin(mapping, 0, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\t*pagep = page;\n\n\tif (!PageUptodate(page) && len != PAGE_CACHE_SIZE)\n\t\t__udf_adinicb_readpage(page);\n\treturn 0;\n}"
  },
  {
    "function_name": "udf_adinicb_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/file.c",
    "lines": "65-82",
    "snippet": "static int udf_adinicb_writepage(struct page *page,\n\t\t\t\t struct writeback_control *wbc)\n{\n\tstruct inode *inode = page->mapping->host;\n\tchar *kaddr;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tBUG_ON(!PageLocked(page));\n\n\tkaddr = kmap(page);\n\tmemcpy(iinfo->i_ext.i_data + iinfo->i_lenEAttr, kaddr, inode->i_size);\n\tmark_inode_dirty(inode);\n\tSetPageUptodate(page);\n\tkunmap(page);\n\tunlock_page(page);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>",
      "#include <linux/string.h> /* memset */",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "iinfo->i_ext.i_data + iinfo->i_lenEAttr",
            "kaddr",
            "inode->i_size"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "inode"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n#include <linux/string.h> /* memset */\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstatic int udf_adinicb_writepage(struct page *page,\n\t\t\t\t struct writeback_control *wbc)\n{\n\tstruct inode *inode = page->mapping->host;\n\tchar *kaddr;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tBUG_ON(!PageLocked(page));\n\n\tkaddr = kmap(page);\n\tmemcpy(iinfo->i_ext.i_data + iinfo->i_lenEAttr, kaddr, inode->i_size);\n\tmark_inode_dirty(inode);\n\tSetPageUptodate(page);\n\tkunmap(page);\n\tunlock_page(page);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "udf_adinicb_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/file.c",
    "lines": "56-63",
    "snippet": "static int udf_adinicb_readpage(struct file *file, struct page *page)\n{\n\tBUG_ON(!PageLocked(page));\n\t__udf_adinicb_readpage(page);\n\tunlock_page(page);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>",
      "#include <linux/string.h> /* memset */",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__udf_adinicb_readpage",
          "args": [
            "page"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "__udf_adinicb_readpage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/file.c",
          "lines": "42-54",
          "snippet": "static void __udf_adinicb_readpage(struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tchar *kaddr;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tkaddr = kmap(page);\n\tmemcpy(kaddr, iinfo->i_ext.i_data + iinfo->i_lenEAttr, inode->i_size);\n\tmemset(kaddr + inode->i_size, 0, PAGE_CACHE_SIZE - inode->i_size);\n\tflush_dcache_page(page);\n\tSetPageUptodate(page);\n\tkunmap(page);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/errno.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h> /* memset */",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n#include <linux/string.h> /* memset */\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstatic void __udf_adinicb_readpage(struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tchar *kaddr;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tkaddr = kmap(page);\n\tmemcpy(kaddr, iinfo->i_ext.i_data + iinfo->i_lenEAttr, inode->i_size);\n\tmemset(kaddr + inode->i_size, 0, PAGE_CACHE_SIZE - inode->i_size);\n\tflush_dcache_page(page);\n\tSetPageUptodate(page);\n\tkunmap(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n#include <linux/string.h> /* memset */\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstatic int udf_adinicb_readpage(struct file *file, struct page *page)\n{\n\tBUG_ON(!PageLocked(page));\n\t__udf_adinicb_readpage(page);\n\tunlock_page(page);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__udf_adinicb_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/file.c",
    "lines": "42-54",
    "snippet": "static void __udf_adinicb_readpage(struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tchar *kaddr;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tkaddr = kmap(page);\n\tmemcpy(kaddr, iinfo->i_ext.i_data + iinfo->i_lenEAttr, inode->i_size);\n\tmemset(kaddr + inode->i_size, 0, PAGE_CACHE_SIZE - inode->i_size);\n\tflush_dcache_page(page);\n\tSetPageUptodate(page);\n\tkunmap(page);\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/aio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/errno.h>",
      "#include <linux/capability.h>",
      "#include <linux/string.h> /* memset */",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "kaddr + inode->i_size",
            "0",
            "PAGE_CACHE_SIZE - inode->i_size"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "kaddr",
            "iinfo->i_ext.i_data + iinfo->i_lenEAttr",
            "inode->i_size"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "inode"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n#include <linux/string.h> /* memset */\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstatic void __udf_adinicb_readpage(struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tchar *kaddr;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tkaddr = kmap(page);\n\tmemcpy(kaddr, iinfo->i_ext.i_data + iinfo->i_lenEAttr, inode->i_size);\n\tmemset(kaddr + inode->i_size, 0, PAGE_CACHE_SIZE - inode->i_size);\n\tflush_dcache_page(page);\n\tSetPageUptodate(page);\n\tkunmap(page);\n}"
  }
]