[
  {
    "function_name": "ceph_encode_dentry_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "3391-3425",
    "snippet": "int ceph_encode_dentry_release(void **p, struct dentry *dentry,\n\t\t\t       int mds, int drop, int unless)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct ceph_mds_request_release *rel = *p;\n\tstruct ceph_dentry_info *di = ceph_dentry(dentry);\n\tint force = 0;\n\tint ret;\n\n\t/*\n\t * force an record for the directory caps if we have a dentry lease.\n\t * this is racy (can't take i_ceph_lock and d_lock together), but it\n\t * doesn't have to be perfect; the mds will revoke anything we don't\n\t * release.\n\t */\n\tspin_lock(&dentry->d_lock);\n\tif (di->lease_session && di->lease_session->s_mds == mds)\n\t\tforce = 1;\n\tspin_unlock(&dentry->d_lock);\n\n\tret = ceph_encode_inode_release(p, dir, mds, drop, unless, force);\n\n\tspin_lock(&dentry->d_lock);\n\tif (ret && di->lease_session && di->lease_session->s_mds == mds) {\n\t\tdout(\"encode_dentry_release %p mds%d seq %d\\n\",\n\t\t     dentry, mds, (int)di->lease_seq);\n\t\trel->dname_len = cpu_to_le32(dentry->d_name.len);\n\t\tmemcpy(*p, dentry->d_name.name, dentry->d_name.len);\n\t\t*p += dentry->d_name.len;\n\t\trel->dname_seq = cpu_to_le32(di->lease_seq);\n\t\t__ceph_mdsc_drop_dentry_lease(dentry);\n\t}\n\tspin_unlock(&dentry->d_lock);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 3423
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_mdsc_drop_dentry_lease",
          "args": [
            "dentry"
          ],
          "line": 3421
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_mdsc_drop_dentry_lease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "3055-3061",
          "snippet": "void __ceph_mdsc_drop_dentry_lease(struct dentry *dentry)\n{\n\tstruct ceph_dentry_info *di = ceph_dentry(dentry);\n\n\tceph_put_mds_session(di->lease_session);\n\tdi->lease_session = NULL;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid __ceph_mdsc_drop_dentry_lease(struct dentry *dentry)\n{\n\tstruct ceph_dentry_info *di = ceph_dentry(dentry);\n\n\tceph_put_mds_session(di->lease_session);\n\tdi->lease_session = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "di->lease_seq"
          ],
          "line": 3420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "*p",
            "dentry->d_name.name",
            "dentry->d_name.len"
          ],
          "line": 3418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "dentry->d_name.len"
          ],
          "line": 3417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"encode_dentry_release %p mds%d seq %d\\n\"",
            "dentry",
            "mds",
            "(int)di->lease_seq"
          ],
          "line": 3415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 3413
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_encode_inode_release",
          "args": [
            "p",
            "dir",
            "mds",
            "drop",
            "unless",
            "force"
          ],
          "line": 3411
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_encode_inode_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "3325-3389",
          "snippet": "int ceph_encode_inode_release(void **p, struct inode *inode,\n\t\t\t      int mds, int drop, int unless, int force)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_cap *cap;\n\tstruct ceph_mds_request_release *rel = *p;\n\tint used, dirty;\n\tint ret = 0;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tused = __ceph_caps_used(ci);\n\tdirty = __ceph_caps_dirty(ci);\n\n\tdout(\"encode_inode_release %p mds%d used|dirty %s drop %s unless %s\\n\",\n\t     inode, mds, ceph_cap_string(used|dirty), ceph_cap_string(drop),\n\t     ceph_cap_string(unless));\n\n\t/* only drop unused, clean caps */\n\tdrop &= ~(used | dirty);\n\n\tcap = __get_cap_for_mds(ci, mds);\n\tif (cap && __cap_is_valid(cap)) {\n\t\tif (force ||\n\t\t    ((cap->issued & drop) &&\n\t\t     (cap->issued & unless) == 0)) {\n\t\t\tif ((cap->issued & drop) &&\n\t\t\t    (cap->issued & unless) == 0) {\n\t\t\t\tint wanted = __ceph_caps_wanted(ci);\n\t\t\t\tif ((ci->i_ceph_flags & CEPH_I_NODELAY) == 0)\n\t\t\t\t\twanted |= cap->mds_wanted;\n\t\t\t\tdout(\"encode_inode_release %p cap %p \"\n\t\t\t\t     \"%s -> %s, wanted %s -> %s\\n\", inode, cap,\n\t\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t\t     ceph_cap_string(cap->issued & ~drop),\n\t\t\t\t     ceph_cap_string(cap->mds_wanted),\n\t\t\t\t     ceph_cap_string(wanted));\n\n\t\t\t\tcap->issued &= ~drop;\n\t\t\t\tcap->implemented &= ~drop;\n\t\t\t\tcap->mds_wanted = wanted;\n\t\t\t} else {\n\t\t\t\tdout(\"encode_inode_release %p cap %p %s\"\n\t\t\t\t     \" (force)\\n\", inode, cap,\n\t\t\t\t     ceph_cap_string(cap->issued));\n\t\t\t}\n\n\t\t\trel->ino = cpu_to_le64(ceph_ino(inode));\n\t\t\trel->cap_id = cpu_to_le64(cap->cap_id);\n\t\t\trel->seq = cpu_to_le32(cap->seq);\n\t\t\trel->issue_seq = cpu_to_le32(cap->issue_seq);\n\t\t\trel->mseq = cpu_to_le32(cap->mseq);\n\t\t\trel->caps = cpu_to_le32(cap->implemented);\n\t\t\trel->wanted = cpu_to_le32(cap->mds_wanted);\n\t\t\trel->dname_len = 0;\n\t\t\trel->dname_seq = 0;\n\t\t\t*p += sizeof(*rel);\n\t\t\tret = 1;\n\t\t} else {\n\t\t\tdout(\"encode_inode_release %p cap %p %s\\n\",\n\t\t\t     inode, cap, ceph_cap_string(cap->issued));\n\t\t}\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_encode_inode_release(void **p, struct inode *inode,\n\t\t\t      int mds, int drop, int unless, int force)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_cap *cap;\n\tstruct ceph_mds_request_release *rel = *p;\n\tint used, dirty;\n\tint ret = 0;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tused = __ceph_caps_used(ci);\n\tdirty = __ceph_caps_dirty(ci);\n\n\tdout(\"encode_inode_release %p mds%d used|dirty %s drop %s unless %s\\n\",\n\t     inode, mds, ceph_cap_string(used|dirty), ceph_cap_string(drop),\n\t     ceph_cap_string(unless));\n\n\t/* only drop unused, clean caps */\n\tdrop &= ~(used | dirty);\n\n\tcap = __get_cap_for_mds(ci, mds);\n\tif (cap && __cap_is_valid(cap)) {\n\t\tif (force ||\n\t\t    ((cap->issued & drop) &&\n\t\t     (cap->issued & unless) == 0)) {\n\t\t\tif ((cap->issued & drop) &&\n\t\t\t    (cap->issued & unless) == 0) {\n\t\t\t\tint wanted = __ceph_caps_wanted(ci);\n\t\t\t\tif ((ci->i_ceph_flags & CEPH_I_NODELAY) == 0)\n\t\t\t\t\twanted |= cap->mds_wanted;\n\t\t\t\tdout(\"encode_inode_release %p cap %p \"\n\t\t\t\t     \"%s -> %s, wanted %s -> %s\\n\", inode, cap,\n\t\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t\t     ceph_cap_string(cap->issued & ~drop),\n\t\t\t\t     ceph_cap_string(cap->mds_wanted),\n\t\t\t\t     ceph_cap_string(wanted));\n\n\t\t\t\tcap->issued &= ~drop;\n\t\t\t\tcap->implemented &= ~drop;\n\t\t\t\tcap->mds_wanted = wanted;\n\t\t\t} else {\n\t\t\t\tdout(\"encode_inode_release %p cap %p %s\"\n\t\t\t\t     \" (force)\\n\", inode, cap,\n\t\t\t\t     ceph_cap_string(cap->issued));\n\t\t\t}\n\n\t\t\trel->ino = cpu_to_le64(ceph_ino(inode));\n\t\t\trel->cap_id = cpu_to_le64(cap->cap_id);\n\t\t\trel->seq = cpu_to_le32(cap->seq);\n\t\t\trel->issue_seq = cpu_to_le32(cap->issue_seq);\n\t\t\trel->mseq = cpu_to_le32(cap->mseq);\n\t\t\trel->caps = cpu_to_le32(cap->implemented);\n\t\t\trel->wanted = cpu_to_le32(cap->mds_wanted);\n\t\t\trel->dname_len = 0;\n\t\t\trel->dname_seq = 0;\n\t\t\t*p += sizeof(*rel);\n\t\t\tret = 1;\n\t\t} else {\n\t\t\tdout(\"encode_inode_release %p cap %p %s\\n\",\n\t\t\t     inode, cap, ceph_cap_string(cap->issued));\n\t\t}\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_dentry",
          "args": [
            "dentry"
          ],
          "line": 3396
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "508-511",
          "snippet": "static inline struct ceph_dentry_info *ceph_dentry(struct dentry *dentry)\n{\n\treturn (struct ceph_dentry_info *)dentry->d_fsdata;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_dentry_info *ceph_dentry(struct dentry *dentry)\n{\n\treturn (struct ceph_dentry_info *)dentry->d_fsdata;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_encode_dentry_release(void **p, struct dentry *dentry,\n\t\t\t       int mds, int drop, int unless)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct ceph_mds_request_release *rel = *p;\n\tstruct ceph_dentry_info *di = ceph_dentry(dentry);\n\tint force = 0;\n\tint ret;\n\n\t/*\n\t * force an record for the directory caps if we have a dentry lease.\n\t * this is racy (can't take i_ceph_lock and d_lock together), but it\n\t * doesn't have to be perfect; the mds will revoke anything we don't\n\t * release.\n\t */\n\tspin_lock(&dentry->d_lock);\n\tif (di->lease_session && di->lease_session->s_mds == mds)\n\t\tforce = 1;\n\tspin_unlock(&dentry->d_lock);\n\n\tret = ceph_encode_inode_release(p, dir, mds, drop, unless, force);\n\n\tspin_lock(&dentry->d_lock);\n\tif (ret && di->lease_session && di->lease_session->s_mds == mds) {\n\t\tdout(\"encode_dentry_release %p mds%d seq %d\\n\",\n\t\t     dentry, mds, (int)di->lease_seq);\n\t\trel->dname_len = cpu_to_le32(dentry->d_name.len);\n\t\tmemcpy(*p, dentry->d_name.name, dentry->d_name.len);\n\t\t*p += dentry->d_name.len;\n\t\trel->dname_seq = cpu_to_le32(di->lease_seq);\n\t\t__ceph_mdsc_drop_dentry_lease(dentry);\n\t}\n\tspin_unlock(&dentry->d_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "ceph_encode_inode_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "3325-3389",
    "snippet": "int ceph_encode_inode_release(void **p, struct inode *inode,\n\t\t\t      int mds, int drop, int unless, int force)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_cap *cap;\n\tstruct ceph_mds_request_release *rel = *p;\n\tint used, dirty;\n\tint ret = 0;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tused = __ceph_caps_used(ci);\n\tdirty = __ceph_caps_dirty(ci);\n\n\tdout(\"encode_inode_release %p mds%d used|dirty %s drop %s unless %s\\n\",\n\t     inode, mds, ceph_cap_string(used|dirty), ceph_cap_string(drop),\n\t     ceph_cap_string(unless));\n\n\t/* only drop unused, clean caps */\n\tdrop &= ~(used | dirty);\n\n\tcap = __get_cap_for_mds(ci, mds);\n\tif (cap && __cap_is_valid(cap)) {\n\t\tif (force ||\n\t\t    ((cap->issued & drop) &&\n\t\t     (cap->issued & unless) == 0)) {\n\t\t\tif ((cap->issued & drop) &&\n\t\t\t    (cap->issued & unless) == 0) {\n\t\t\t\tint wanted = __ceph_caps_wanted(ci);\n\t\t\t\tif ((ci->i_ceph_flags & CEPH_I_NODELAY) == 0)\n\t\t\t\t\twanted |= cap->mds_wanted;\n\t\t\t\tdout(\"encode_inode_release %p cap %p \"\n\t\t\t\t     \"%s -> %s, wanted %s -> %s\\n\", inode, cap,\n\t\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t\t     ceph_cap_string(cap->issued & ~drop),\n\t\t\t\t     ceph_cap_string(cap->mds_wanted),\n\t\t\t\t     ceph_cap_string(wanted));\n\n\t\t\t\tcap->issued &= ~drop;\n\t\t\t\tcap->implemented &= ~drop;\n\t\t\t\tcap->mds_wanted = wanted;\n\t\t\t} else {\n\t\t\t\tdout(\"encode_inode_release %p cap %p %s\"\n\t\t\t\t     \" (force)\\n\", inode, cap,\n\t\t\t\t     ceph_cap_string(cap->issued));\n\t\t\t}\n\n\t\t\trel->ino = cpu_to_le64(ceph_ino(inode));\n\t\t\trel->cap_id = cpu_to_le64(cap->cap_id);\n\t\t\trel->seq = cpu_to_le32(cap->seq);\n\t\t\trel->issue_seq = cpu_to_le32(cap->issue_seq);\n\t\t\trel->mseq = cpu_to_le32(cap->mseq);\n\t\t\trel->caps = cpu_to_le32(cap->implemented);\n\t\t\trel->wanted = cpu_to_le32(cap->mds_wanted);\n\t\t\trel->dname_len = 0;\n\t\t\trel->dname_seq = 0;\n\t\t\t*p += sizeof(*rel);\n\t\t\tret = 1;\n\t\t} else {\n\t\t\tdout(\"encode_inode_release %p cap %p %s\\n\",\n\t\t\t     inode, cap, ceph_cap_string(cap->issued));\n\t\t}\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 3387
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"encode_inode_release %p cap %p %s\\n\"",
            "inode",
            "cap",
            "ceph_cap_string(cap->issued)"
          ],
          "line": 3383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_cap_string",
          "args": [
            "cap->issued"
          ],
          "line": 3384
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_cap_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "71-116",
          "snippet": "const char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [
            "#define MAX_CAP_STR 20"
          ],
          "globals_used": [
            "static char cap_str[MAX_CAP_STR][40];",
            "static DEFINE_SPINLOCK(cap_str_lock);",
            "static int last_cap_str;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\n#define MAX_CAP_STR 20\n\nstatic char cap_str[MAX_CAP_STR][40];\nstatic DEFINE_SPINLOCK(cap_str_lock);\nstatic int last_cap_str;\n\nconst char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "cap->mds_wanted"
          ],
          "line": 3377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "cap->implemented"
          ],
          "line": 3376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "cap->mseq"
          ],
          "line": 3375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "cap->issue_seq"
          ],
          "line": 3374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "cap->seq"
          ],
          "line": 3373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "cap->cap_id"
          ],
          "line": 3372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "ceph_ino(inode)"
          ],
          "line": 3371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_ino",
          "args": [
            "inode"
          ],
          "line": 3371
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "412-415",
          "snippet": "static inline u64 ceph_ino(struct inode *inode)\n{\n\treturn ceph_inode(inode)->i_vino.ino;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline u64 ceph_ino(struct inode *inode)\n{\n\treturn ceph_inode(inode)->i_vino.ino;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"encode_inode_release %p cap %p %s\"\n\t\t\t\t     \" (force)\\n\"",
            "inode",
            "cap",
            "ceph_cap_string(cap->issued)"
          ],
          "line": 3366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"encode_inode_release %p cap %p \"\n\t\t\t\t     \"%s -> %s, wanted %s -> %s\\n\"",
            "inode",
            "cap",
            "ceph_cap_string(cap->issued)",
            "ceph_cap_string(cap->issued & ~drop)",
            "ceph_cap_string(cap->mds_wanted)",
            "ceph_cap_string(wanted)"
          ],
          "line": 3355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ceph_caps_wanted",
          "args": [
            "ci"
          ],
          "line": 3352
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_caps_wanted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "566-572",
          "snippet": "static inline int __ceph_caps_wanted(struct ceph_inode_info *ci)\n{\n\tint w = __ceph_caps_file_wanted(ci) | __ceph_caps_used(ci);\n\tif (w & CEPH_CAP_FILE_BUFFER)\n\t\tw |= CEPH_CAP_FILE_EXCL;  /* we want EXCL if dirty data */\n\treturn w;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline int __ceph_caps_wanted(struct ceph_inode_info *ci)\n{\n\tint w = __ceph_caps_file_wanted(ci) | __ceph_caps_used(ci);\n\tif (w & CEPH_CAP_FILE_BUFFER)\n\t\tw |= CEPH_CAP_FILE_EXCL;  /* we want EXCL if dirty data */\n\treturn w;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__cap_is_valid",
          "args": [
            "cap"
          ],
          "line": 3346
        },
        "resolved": true,
        "details": {
          "function_name": "__cap_is_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "642-660",
          "snippet": "static int __cap_is_valid(struct ceph_cap *cap)\n{\n\tunsigned long ttl;\n\tu32 gen;\n\n\tspin_lock(&cap->session->s_gen_ttl_lock);\n\tgen = cap->session->s_cap_gen;\n\tttl = cap->session->s_cap_ttl;\n\tspin_unlock(&cap->session->s_gen_ttl_lock);\n\n\tif (cap->cap_gen < gen || time_after_eq(jiffies, ttl)) {\n\t\tdout(\"__cap_is_valid %p cap %p issued %s \"\n\t\t     \"but STALE (gen %u vs %u)\\n\", &cap->ci->vfs_inode,\n\t\t     cap, ceph_cap_string(cap->issued), cap->cap_gen, gen);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __cap_is_valid(struct ceph_cap *cap)\n{\n\tunsigned long ttl;\n\tu32 gen;\n\n\tspin_lock(&cap->session->s_gen_ttl_lock);\n\tgen = cap->session->s_cap_gen;\n\tttl = cap->session->s_cap_ttl;\n\tspin_unlock(&cap->session->s_gen_ttl_lock);\n\n\tif (cap->cap_gen < gen || time_after_eq(jiffies, ttl)) {\n\t\tdout(\"__cap_is_valid %p cap %p issued %s \"\n\t\t     \"but STALE (gen %u vs %u)\\n\", &cap->ci->vfs_inode,\n\t\t     cap, ceph_cap_string(cap->issued), cap->cap_gen, gen);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_cap_for_mds",
          "args": [
            "ci",
            "mds"
          ],
          "line": 3345
        },
        "resolved": true,
        "details": {
          "function_name": "__get_cap_for_mds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "310-325",
          "snippet": "static struct ceph_cap *__get_cap_for_mds(struct ceph_inode_info *ci, int mds)\n{\n\tstruct ceph_cap *cap;\n\tstruct rb_node *n = ci->i_caps.rb_node;\n\n\twhile (n) {\n\t\tcap = rb_entry(n, struct ceph_cap, ci_node);\n\t\tif (mds < cap->mds)\n\t\t\tn = n->rb_left;\n\t\telse if (mds > cap->mds)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn cap;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_cap *__get_cap_for_mds(struct ceph_inode_info *ci, int mds)\n{\n\tstruct ceph_cap *cap;\n\tstruct rb_node *n = ci->i_caps.rb_node;\n\n\twhile (n) {\n\t\tcap = rb_entry(n, struct ceph_cap, ci_node);\n\t\tif (mds < cap->mds)\n\t\t\tn = n->rb_left;\n\t\telse if (mds > cap->mds)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn cap;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"encode_inode_release %p mds%d used|dirty %s drop %s unless %s\\n\"",
            "inode",
            "mds",
            "ceph_cap_string(used|dirty)",
            "ceph_cap_string(drop)",
            "ceph_cap_string(unless)"
          ],
          "line": 3338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ceph_caps_dirty",
          "args": [
            "ci"
          ],
          "line": 3336
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_caps_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "550-553",
          "snippet": "static inline int __ceph_caps_dirty(struct ceph_inode_info *ci)\n{\n\treturn ci->i_dirty_caps | ci->i_flushing_caps;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline int __ceph_caps_dirty(struct ceph_inode_info *ci)\n{\n\treturn ci->i_dirty_caps | ci->i_flushing_caps;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_caps_used",
          "args": [
            "ci"
          ],
          "line": 3335
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_caps_used",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "829-843",
          "snippet": "int __ceph_caps_used(struct ceph_inode_info *ci)\n{\n\tint used = 0;\n\tif (ci->i_pin_ref)\n\t\tused |= CEPH_CAP_PIN;\n\tif (ci->i_rd_ref)\n\t\tused |= CEPH_CAP_FILE_RD;\n\tif (ci->i_rdcache_ref || ci->vfs_inode.i_data.nrpages)\n\t\tused |= CEPH_CAP_FILE_CACHE;\n\tif (ci->i_wr_ref)\n\t\tused |= CEPH_CAP_FILE_WR;\n\tif (ci->i_wb_ref || ci->i_wrbuffer_ref)\n\t\tused |= CEPH_CAP_FILE_BUFFER;\n\treturn used;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_caps_used(struct ceph_inode_info *ci)\n{\n\tint used = 0;\n\tif (ci->i_pin_ref)\n\t\tused |= CEPH_CAP_PIN;\n\tif (ci->i_rd_ref)\n\t\tused |= CEPH_CAP_FILE_RD;\n\tif (ci->i_rdcache_ref || ci->vfs_inode.i_data.nrpages)\n\t\tused |= CEPH_CAP_FILE_CACHE;\n\tif (ci->i_wr_ref)\n\t\tused |= CEPH_CAP_FILE_WR;\n\tif (ci->i_wb_ref || ci->i_wrbuffer_ref)\n\t\tused |= CEPH_CAP_FILE_BUFFER;\n\treturn used;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 3334
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 3328
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_encode_inode_release(void **p, struct inode *inode,\n\t\t\t      int mds, int drop, int unless, int force)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_cap *cap;\n\tstruct ceph_mds_request_release *rel = *p;\n\tint used, dirty;\n\tint ret = 0;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tused = __ceph_caps_used(ci);\n\tdirty = __ceph_caps_dirty(ci);\n\n\tdout(\"encode_inode_release %p mds%d used|dirty %s drop %s unless %s\\n\",\n\t     inode, mds, ceph_cap_string(used|dirty), ceph_cap_string(drop),\n\t     ceph_cap_string(unless));\n\n\t/* only drop unused, clean caps */\n\tdrop &= ~(used | dirty);\n\n\tcap = __get_cap_for_mds(ci, mds);\n\tif (cap && __cap_is_valid(cap)) {\n\t\tif (force ||\n\t\t    ((cap->issued & drop) &&\n\t\t     (cap->issued & unless) == 0)) {\n\t\t\tif ((cap->issued & drop) &&\n\t\t\t    (cap->issued & unless) == 0) {\n\t\t\t\tint wanted = __ceph_caps_wanted(ci);\n\t\t\t\tif ((ci->i_ceph_flags & CEPH_I_NODELAY) == 0)\n\t\t\t\t\twanted |= cap->mds_wanted;\n\t\t\t\tdout(\"encode_inode_release %p cap %p \"\n\t\t\t\t     \"%s -> %s, wanted %s -> %s\\n\", inode, cap,\n\t\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t\t     ceph_cap_string(cap->issued & ~drop),\n\t\t\t\t     ceph_cap_string(cap->mds_wanted),\n\t\t\t\t     ceph_cap_string(wanted));\n\n\t\t\t\tcap->issued &= ~drop;\n\t\t\t\tcap->implemented &= ~drop;\n\t\t\t\tcap->mds_wanted = wanted;\n\t\t\t} else {\n\t\t\t\tdout(\"encode_inode_release %p cap %p %s\"\n\t\t\t\t     \" (force)\\n\", inode, cap,\n\t\t\t\t     ceph_cap_string(cap->issued));\n\t\t\t}\n\n\t\t\trel->ino = cpu_to_le64(ceph_ino(inode));\n\t\t\trel->cap_id = cpu_to_le64(cap->cap_id);\n\t\t\trel->seq = cpu_to_le32(cap->seq);\n\t\t\trel->issue_seq = cpu_to_le32(cap->issue_seq);\n\t\t\trel->mseq = cpu_to_le32(cap->mseq);\n\t\t\trel->caps = cpu_to_le32(cap->implemented);\n\t\t\trel->wanted = cpu_to_le32(cap->mds_wanted);\n\t\t\trel->dname_len = 0;\n\t\t\trel->dname_seq = 0;\n\t\t\t*p += sizeof(*rel);\n\t\t\tret = 1;\n\t\t} else {\n\t\t\tdout(\"encode_inode_release %p cap %p %s\\n\",\n\t\t\t     inode, cap, ceph_cap_string(cap->issued));\n\t\t}\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "ceph_put_fmode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "3300-3315",
    "snippet": "void ceph_put_fmode(struct ceph_inode_info *ci, int fmode)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint last = 0;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tdout(\"put_fmode %p fmode %d %d -> %d\\n\", inode, fmode,\n\t     ci->i_nr_by_mode[fmode], ci->i_nr_by_mode[fmode]-1);\n\tBUG_ON(ci->i_nr_by_mode[fmode] == 0);\n\tif (--ci->i_nr_by_mode[fmode] == 0)\n\t\tlast++;\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (last && ci->i_vino.snap == CEPH_NOSNAP)\n\t\tceph_check_caps(ci, 0, NULL);\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_check_caps",
          "args": [
            "ci",
            "0",
            "NULL"
          ],
          "line": 3314
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_check_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "1504-1751",
          "snippet": "void ceph_check_caps(struct ceph_inode_info *ci, int flags,\n\t\t     struct ceph_mds_session *session)\n{\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(&ci->vfs_inode);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct inode *inode = &ci->vfs_inode;\n\tstruct ceph_cap *cap;\n\tint file_wanted, used, cap_used;\n\tint took_snap_rwsem = 0;             /* true if mdsc->snap_rwsem held */\n\tint issued, implemented, want, retain, revoking, flushing = 0;\n\tint mds = -1;   /* keep track of how far we've gone through i_caps list\n\t\t\t   to avoid an infinite loop on retry */\n\tstruct rb_node *p;\n\tint tried_invalidate = 0;\n\tint delayed = 0, sent = 0, force_requeue = 0, num;\n\tint queue_invalidate = 0;\n\tint is_delayed = flags & CHECK_CAPS_NODELAY;\n\n\t/* if we are unmounting, flush any unused caps immediately. */\n\tif (mdsc->stopping)\n\t\tis_delayed = 1;\n\n\tspin_lock(&ci->i_ceph_lock);\n\n\tif (ci->i_ceph_flags & CEPH_I_FLUSH)\n\t\tflags |= CHECK_CAPS_FLUSH;\n\n\t/* flush snaps first time around only */\n\tif (!list_empty(&ci->i_cap_snaps))\n\t\t__ceph_flush_snaps(ci, &session, 0);\n\tgoto retry_locked;\nretry:\n\tspin_lock(&ci->i_ceph_lock);\nretry_locked:\n\tfile_wanted = __ceph_caps_file_wanted(ci);\n\tused = __ceph_caps_used(ci);\n\twant = file_wanted | used;\n\tissued = __ceph_caps_issued(ci, &implemented);\n\trevoking = implemented & ~issued;\n\n\tretain = want | CEPH_CAP_PIN;\n\tif (!mdsc->stopping && inode->i_nlink > 0) {\n\t\tif (want) {\n\t\t\tretain |= CEPH_CAP_ANY;       /* be greedy */\n\t\t} else {\n\t\t\tretain |= CEPH_CAP_ANY_SHARED;\n\t\t\t/*\n\t\t\t * keep RD only if we didn't have the file open RW,\n\t\t\t * because then the mds would revoke it anyway to\n\t\t\t * journal max_size=0.\n\t\t\t */\n\t\t\tif (ci->i_max_size == 0)\n\t\t\t\tretain |= CEPH_CAP_ANY_RD;\n\t\t}\n\t}\n\n\tdout(\"check_caps %p file_want %s used %s dirty %s flushing %s\"\n\t     \" issued %s revoking %s retain %s %s%s%s\\n\", inode,\n\t     ceph_cap_string(file_wanted),\n\t     ceph_cap_string(used), ceph_cap_string(ci->i_dirty_caps),\n\t     ceph_cap_string(ci->i_flushing_caps),\n\t     ceph_cap_string(issued), ceph_cap_string(revoking),\n\t     ceph_cap_string(retain),\n\t     (flags & CHECK_CAPS_AUTHONLY) ? \" AUTHONLY\" : \"\",\n\t     (flags & CHECK_CAPS_NODELAY) ? \" NODELAY\" : \"\",\n\t     (flags & CHECK_CAPS_FLUSH) ? \" FLUSH\" : \"\");\n\n\t/*\n\t * If we no longer need to hold onto old our caps, and we may\n\t * have cached pages, but don't want them, then try to invalidate.\n\t * If we fail, it's because pages are locked.... try again later.\n\t */\n\tif ((!is_delayed || mdsc->stopping) &&\n\t    ci->i_wrbuffer_ref == 0 &&               /* no dirty pages... */\n\t    inode->i_data.nrpages &&                 /* have cached pages */\n\t    (file_wanted == 0 ||                     /* no open files */\n\t     (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t  CEPH_CAP_FILE_LAZYIO))) && /*  or revoking cache */\n\t    !tried_invalidate) {\n\t\tdout(\"check_caps trying to invalidate on %p\\n\", inode);\n\t\tif (try_nonblocking_invalidate(inode) < 0) {\n\t\t\tif (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t\t\tCEPH_CAP_FILE_LAZYIO)) {\n\t\t\t\tdout(\"check_caps queuing invalidate\\n\");\n\t\t\t\tqueue_invalidate = 1;\n\t\t\t\tci->i_rdcache_revoking = ci->i_rdcache_gen;\n\t\t\t} else {\n\t\t\t\tdout(\"check_caps failed to invalidate pages\\n\");\n\t\t\t\t/* we failed to invalidate pages.  check these\n\t\t\t\t   caps again later. */\n\t\t\t\tforce_requeue = 1;\n\t\t\t\t__cap_set_timeouts(mdsc, ci);\n\t\t\t}\n\t\t}\n\t\ttried_invalidate = 1;\n\t\tgoto retry_locked;\n\t}\n\n\tnum = 0;\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tnum++;\n\n\t\t/* avoid looping forever */\n\t\tif (mds >= cap->mds ||\n\t\t    ((flags & CHECK_CAPS_AUTHONLY) && cap != ci->i_auth_cap))\n\t\t\tcontinue;\n\n\t\t/* NOTE: no side-effects allowed, until we take s_mutex */\n\n\t\tcap_used = used;\n\t\tif (ci->i_auth_cap && cap != ci->i_auth_cap)\n\t\t\tcap_used &= ~ci->i_auth_cap->issued;\n\n\t\trevoking = cap->implemented & ~cap->issued;\n\t\tdout(\" mds%d cap %p used %s issued %s implemented %s revoking %s\\n\",\n\t\t     cap->mds, cap, ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(cap_used),\n\t\t     ceph_cap_string(cap->implemented),\n\t\t     ceph_cap_string(revoking));\n\n\t\tif (cap == ci->i_auth_cap &&\n\t\t    (cap->issued & CEPH_CAP_FILE_WR)) {\n\t\t\t/* request larger max_size from MDS? */\n\t\t\tif (ci->i_wanted_max_size > ci->i_max_size &&\n\t\t\t    ci->i_wanted_max_size > ci->i_requested_max_size) {\n\t\t\t\tdout(\"requesting new max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\n\t\t\t/* approaching file_max? */\n\t\t\tif ((inode->i_size << 1) >= ci->i_max_size &&\n\t\t\t    (ci->i_reported_size << 1) < ci->i_max_size) {\n\t\t\t\tdout(\"i_size approaching max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\t\t}\n\t\t/* flush anything dirty? */\n\t\tif (cap == ci->i_auth_cap && (flags & CHECK_CAPS_FLUSH) &&\n\t\t    ci->i_dirty_caps) {\n\t\t\tdout(\"flushing dirty caps\\n\");\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* completed revocation? going down and there are no caps? */\n\t\tif (revoking && (revoking & cap_used) == 0) {\n\t\t\tdout(\"completed revocation of %s\\n\",\n\t\t\t     ceph_cap_string(cap->implemented & ~cap->issued));\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* want more caps from mds? */\n\t\tif (want & ~(cap->mds_wanted | cap->issued))\n\t\t\tgoto ack;\n\n\t\t/* things we might delay */\n\t\tif ((cap->issued & ~retain) == 0 &&\n\t\t    cap->mds_wanted == want)\n\t\t\tcontinue;     /* nope, all good */\n\n\t\tif (is_delayed)\n\t\t\tgoto ack;\n\n\t\t/* delay? */\n\t\tif ((ci->i_ceph_flags & CEPH_I_NODELAY) == 0 &&\n\t\t    time_before(jiffies, ci->i_hold_caps_max)) {\n\t\t\tdout(\" delaying issued %s -> %s, wanted %s -> %s\\n\",\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(cap->issued & retain),\n\t\t\t     ceph_cap_string(cap->mds_wanted),\n\t\t\t     ceph_cap_string(want));\n\t\t\tdelayed++;\n\t\t\tcontinue;\n\t\t}\n\nack:\n\t\tif (ci->i_ceph_flags & CEPH_I_NOFLUSH) {\n\t\t\tdout(\" skipping %p I_NOFLUSH set\\n\", inode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (session && session != cap->session) {\n\t\t\tdout(\"oops, wrong session %p mutex\\n\", session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tsession = NULL;\n\t\t}\n\t\tif (!session) {\n\t\t\tsession = cap->session;\n\t\t\tif (mutex_trylock(&session->s_mutex) == 0) {\n\t\t\t\tdout(\"inverting session/ino locks on %p\\n\",\n\t\t\t\t     session);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tif (took_snap_rwsem) {\n\t\t\t\t\tup_read(&mdsc->snap_rwsem);\n\t\t\t\t\ttook_snap_rwsem = 0;\n\t\t\t\t}\n\t\t\t\tmutex_lock(&session->s_mutex);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t\t/* take snap_rwsem after session mutex */\n\t\tif (!took_snap_rwsem) {\n\t\t\tif (down_read_trylock(&mdsc->snap_rwsem) == 0) {\n\t\t\t\tdout(\"inverting snap/in locks on %p\\n\",\n\t\t\t\t     inode);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tdown_read(&mdsc->snap_rwsem);\n\t\t\t\ttook_snap_rwsem = 1;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\ttook_snap_rwsem = 1;\n\t\t}\n\n\t\tif (cap == ci->i_auth_cap && ci->i_dirty_caps)\n\t\t\tflushing = __mark_caps_flushing(inode, session);\n\t\telse\n\t\t\tflushing = 0;\n\n\t\tmds = cap->mds;  /* remember mds, so we don't repeat */\n\t\tsent++;\n\n\t\t/* __send_cap drops i_ceph_lock */\n\t\tdelayed += __send_cap(mdsc, cap, CEPH_CAP_OP_UPDATE, cap_used,\n\t\t\t\t      want, retain, flushing, NULL);\n\t\tgoto retry; /* retake i_ceph_lock and restart our cap scan. */\n\t}\n\n\t/*\n\t * Reschedule delayed caps release if we delayed anything,\n\t * otherwise cancel.\n\t */\n\tif (delayed && is_delayed)\n\t\tforce_requeue = 1;   /* __send_cap delayed release; requeue */\n\tif (!delayed && !is_delayed)\n\t\t__cap_delay_cancel(mdsc, ci);\n\telse if (!is_delayed || force_requeue)\n\t\t__cap_delay_requeue(mdsc, ci);\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (queue_invalidate)\n\t\tceph_queue_invalidate(inode);\n\n\tif (session)\n\t\tmutex_unlock(&session->s_mutex);\n\tif (took_snap_rwsem)\n\t\tup_read(&mdsc->snap_rwsem);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_check_caps(struct ceph_inode_info *ci, int flags,\n\t\t     struct ceph_mds_session *session)\n{\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(&ci->vfs_inode);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct inode *inode = &ci->vfs_inode;\n\tstruct ceph_cap *cap;\n\tint file_wanted, used, cap_used;\n\tint took_snap_rwsem = 0;             /* true if mdsc->snap_rwsem held */\n\tint issued, implemented, want, retain, revoking, flushing = 0;\n\tint mds = -1;   /* keep track of how far we've gone through i_caps list\n\t\t\t   to avoid an infinite loop on retry */\n\tstruct rb_node *p;\n\tint tried_invalidate = 0;\n\tint delayed = 0, sent = 0, force_requeue = 0, num;\n\tint queue_invalidate = 0;\n\tint is_delayed = flags & CHECK_CAPS_NODELAY;\n\n\t/* if we are unmounting, flush any unused caps immediately. */\n\tif (mdsc->stopping)\n\t\tis_delayed = 1;\n\n\tspin_lock(&ci->i_ceph_lock);\n\n\tif (ci->i_ceph_flags & CEPH_I_FLUSH)\n\t\tflags |= CHECK_CAPS_FLUSH;\n\n\t/* flush snaps first time around only */\n\tif (!list_empty(&ci->i_cap_snaps))\n\t\t__ceph_flush_snaps(ci, &session, 0);\n\tgoto retry_locked;\nretry:\n\tspin_lock(&ci->i_ceph_lock);\nretry_locked:\n\tfile_wanted = __ceph_caps_file_wanted(ci);\n\tused = __ceph_caps_used(ci);\n\twant = file_wanted | used;\n\tissued = __ceph_caps_issued(ci, &implemented);\n\trevoking = implemented & ~issued;\n\n\tretain = want | CEPH_CAP_PIN;\n\tif (!mdsc->stopping && inode->i_nlink > 0) {\n\t\tif (want) {\n\t\t\tretain |= CEPH_CAP_ANY;       /* be greedy */\n\t\t} else {\n\t\t\tretain |= CEPH_CAP_ANY_SHARED;\n\t\t\t/*\n\t\t\t * keep RD only if we didn't have the file open RW,\n\t\t\t * because then the mds would revoke it anyway to\n\t\t\t * journal max_size=0.\n\t\t\t */\n\t\t\tif (ci->i_max_size == 0)\n\t\t\t\tretain |= CEPH_CAP_ANY_RD;\n\t\t}\n\t}\n\n\tdout(\"check_caps %p file_want %s used %s dirty %s flushing %s\"\n\t     \" issued %s revoking %s retain %s %s%s%s\\n\", inode,\n\t     ceph_cap_string(file_wanted),\n\t     ceph_cap_string(used), ceph_cap_string(ci->i_dirty_caps),\n\t     ceph_cap_string(ci->i_flushing_caps),\n\t     ceph_cap_string(issued), ceph_cap_string(revoking),\n\t     ceph_cap_string(retain),\n\t     (flags & CHECK_CAPS_AUTHONLY) ? \" AUTHONLY\" : \"\",\n\t     (flags & CHECK_CAPS_NODELAY) ? \" NODELAY\" : \"\",\n\t     (flags & CHECK_CAPS_FLUSH) ? \" FLUSH\" : \"\");\n\n\t/*\n\t * If we no longer need to hold onto old our caps, and we may\n\t * have cached pages, but don't want them, then try to invalidate.\n\t * If we fail, it's because pages are locked.... try again later.\n\t */\n\tif ((!is_delayed || mdsc->stopping) &&\n\t    ci->i_wrbuffer_ref == 0 &&               /* no dirty pages... */\n\t    inode->i_data.nrpages &&                 /* have cached pages */\n\t    (file_wanted == 0 ||                     /* no open files */\n\t     (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t  CEPH_CAP_FILE_LAZYIO))) && /*  or revoking cache */\n\t    !tried_invalidate) {\n\t\tdout(\"check_caps trying to invalidate on %p\\n\", inode);\n\t\tif (try_nonblocking_invalidate(inode) < 0) {\n\t\t\tif (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t\t\tCEPH_CAP_FILE_LAZYIO)) {\n\t\t\t\tdout(\"check_caps queuing invalidate\\n\");\n\t\t\t\tqueue_invalidate = 1;\n\t\t\t\tci->i_rdcache_revoking = ci->i_rdcache_gen;\n\t\t\t} else {\n\t\t\t\tdout(\"check_caps failed to invalidate pages\\n\");\n\t\t\t\t/* we failed to invalidate pages.  check these\n\t\t\t\t   caps again later. */\n\t\t\t\tforce_requeue = 1;\n\t\t\t\t__cap_set_timeouts(mdsc, ci);\n\t\t\t}\n\t\t}\n\t\ttried_invalidate = 1;\n\t\tgoto retry_locked;\n\t}\n\n\tnum = 0;\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tnum++;\n\n\t\t/* avoid looping forever */\n\t\tif (mds >= cap->mds ||\n\t\t    ((flags & CHECK_CAPS_AUTHONLY) && cap != ci->i_auth_cap))\n\t\t\tcontinue;\n\n\t\t/* NOTE: no side-effects allowed, until we take s_mutex */\n\n\t\tcap_used = used;\n\t\tif (ci->i_auth_cap && cap != ci->i_auth_cap)\n\t\t\tcap_used &= ~ci->i_auth_cap->issued;\n\n\t\trevoking = cap->implemented & ~cap->issued;\n\t\tdout(\" mds%d cap %p used %s issued %s implemented %s revoking %s\\n\",\n\t\t     cap->mds, cap, ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(cap_used),\n\t\t     ceph_cap_string(cap->implemented),\n\t\t     ceph_cap_string(revoking));\n\n\t\tif (cap == ci->i_auth_cap &&\n\t\t    (cap->issued & CEPH_CAP_FILE_WR)) {\n\t\t\t/* request larger max_size from MDS? */\n\t\t\tif (ci->i_wanted_max_size > ci->i_max_size &&\n\t\t\t    ci->i_wanted_max_size > ci->i_requested_max_size) {\n\t\t\t\tdout(\"requesting new max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\n\t\t\t/* approaching file_max? */\n\t\t\tif ((inode->i_size << 1) >= ci->i_max_size &&\n\t\t\t    (ci->i_reported_size << 1) < ci->i_max_size) {\n\t\t\t\tdout(\"i_size approaching max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\t\t}\n\t\t/* flush anything dirty? */\n\t\tif (cap == ci->i_auth_cap && (flags & CHECK_CAPS_FLUSH) &&\n\t\t    ci->i_dirty_caps) {\n\t\t\tdout(\"flushing dirty caps\\n\");\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* completed revocation? going down and there are no caps? */\n\t\tif (revoking && (revoking & cap_used) == 0) {\n\t\t\tdout(\"completed revocation of %s\\n\",\n\t\t\t     ceph_cap_string(cap->implemented & ~cap->issued));\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* want more caps from mds? */\n\t\tif (want & ~(cap->mds_wanted | cap->issued))\n\t\t\tgoto ack;\n\n\t\t/* things we might delay */\n\t\tif ((cap->issued & ~retain) == 0 &&\n\t\t    cap->mds_wanted == want)\n\t\t\tcontinue;     /* nope, all good */\n\n\t\tif (is_delayed)\n\t\t\tgoto ack;\n\n\t\t/* delay? */\n\t\tif ((ci->i_ceph_flags & CEPH_I_NODELAY) == 0 &&\n\t\t    time_before(jiffies, ci->i_hold_caps_max)) {\n\t\t\tdout(\" delaying issued %s -> %s, wanted %s -> %s\\n\",\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(cap->issued & retain),\n\t\t\t     ceph_cap_string(cap->mds_wanted),\n\t\t\t     ceph_cap_string(want));\n\t\t\tdelayed++;\n\t\t\tcontinue;\n\t\t}\n\nack:\n\t\tif (ci->i_ceph_flags & CEPH_I_NOFLUSH) {\n\t\t\tdout(\" skipping %p I_NOFLUSH set\\n\", inode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (session && session != cap->session) {\n\t\t\tdout(\"oops, wrong session %p mutex\\n\", session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tsession = NULL;\n\t\t}\n\t\tif (!session) {\n\t\t\tsession = cap->session;\n\t\t\tif (mutex_trylock(&session->s_mutex) == 0) {\n\t\t\t\tdout(\"inverting session/ino locks on %p\\n\",\n\t\t\t\t     session);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tif (took_snap_rwsem) {\n\t\t\t\t\tup_read(&mdsc->snap_rwsem);\n\t\t\t\t\ttook_snap_rwsem = 0;\n\t\t\t\t}\n\t\t\t\tmutex_lock(&session->s_mutex);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t\t/* take snap_rwsem after session mutex */\n\t\tif (!took_snap_rwsem) {\n\t\t\tif (down_read_trylock(&mdsc->snap_rwsem) == 0) {\n\t\t\t\tdout(\"inverting snap/in locks on %p\\n\",\n\t\t\t\t     inode);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tdown_read(&mdsc->snap_rwsem);\n\t\t\t\ttook_snap_rwsem = 1;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\ttook_snap_rwsem = 1;\n\t\t}\n\n\t\tif (cap == ci->i_auth_cap && ci->i_dirty_caps)\n\t\t\tflushing = __mark_caps_flushing(inode, session);\n\t\telse\n\t\t\tflushing = 0;\n\n\t\tmds = cap->mds;  /* remember mds, so we don't repeat */\n\t\tsent++;\n\n\t\t/* __send_cap drops i_ceph_lock */\n\t\tdelayed += __send_cap(mdsc, cap, CEPH_CAP_OP_UPDATE, cap_used,\n\t\t\t\t      want, retain, flushing, NULL);\n\t\tgoto retry; /* retake i_ceph_lock and restart our cap scan. */\n\t}\n\n\t/*\n\t * Reschedule delayed caps release if we delayed anything,\n\t * otherwise cancel.\n\t */\n\tif (delayed && is_delayed)\n\t\tforce_requeue = 1;   /* __send_cap delayed release; requeue */\n\tif (!delayed && !is_delayed)\n\t\t__cap_delay_cancel(mdsc, ci);\n\telse if (!is_delayed || force_requeue)\n\t\t__cap_delay_requeue(mdsc, ci);\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (queue_invalidate)\n\t\tceph_queue_invalidate(inode);\n\n\tif (session)\n\t\tmutex_unlock(&session->s_mutex);\n\tif (took_snap_rwsem)\n\t\tup_read(&mdsc->snap_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 3311
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ci->i_nr_by_mode[fmode] == 0"
          ],
          "line": 3308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"put_fmode %p fmode %d %d -> %d\\n\"",
            "inode",
            "fmode",
            "ci->i_nr_by_mode[fmode]",
            "ci->i_nr_by_mode[fmode]-1"
          ],
          "line": 3306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 3305
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_put_fmode(struct ceph_inode_info *ci, int fmode)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint last = 0;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tdout(\"put_fmode %p fmode %d %d -> %d\\n\", inode, fmode,\n\t     ci->i_nr_by_mode[fmode], ci->i_nr_by_mode[fmode]-1);\n\tBUG_ON(ci->i_nr_by_mode[fmode] == 0);\n\tif (--ci->i_nr_by_mode[fmode] == 0)\n\t\tlast++;\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (last && ci->i_vino.snap == CEPH_NOSNAP)\n\t\tceph_check_caps(ci, 0, NULL);\n}"
  },
  {
    "function_name": "ceph_flush_dirty_caps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "3273-3293",
    "snippet": "void ceph_flush_dirty_caps(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_inode_info *ci;\n\tstruct inode *inode;\n\n\tdout(\"flush_dirty_caps\\n\");\n\tspin_lock(&mdsc->cap_dirty_lock);\n\twhile (!list_empty(&mdsc->cap_dirty)) {\n\t\tci = list_first_entry(&mdsc->cap_dirty, struct ceph_inode_info,\n\t\t\t\t      i_dirty_item);\n\t\tinode = &ci->vfs_inode;\n\t\tihold(inode);\n\t\tdout(\"flush_dirty_caps %p\\n\", inode);\n\t\tspin_unlock(&mdsc->cap_dirty_lock);\n\t\tceph_check_caps(ci, CHECK_CAPS_NODELAY|CHECK_CAPS_FLUSH, NULL);\n\t\tiput(inode);\n\t\tspin_lock(&mdsc->cap_dirty_lock);\n\t}\n\tspin_unlock(&mdsc->cap_dirty_lock);\n\tdout(\"flush_dirty_caps done\\n\");\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"flush_dirty_caps done\\n\""
          ],
          "line": 3292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mdsc->cap_dirty_lock"
          ],
          "line": 3291
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mdsc->cap_dirty_lock"
          ],
          "line": 3289
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 3288
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_check_caps",
          "args": [
            "ci",
            "CHECK_CAPS_NODELAY|CHECK_CAPS_FLUSH",
            "NULL"
          ],
          "line": 3287
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_check_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "1504-1751",
          "snippet": "void ceph_check_caps(struct ceph_inode_info *ci, int flags,\n\t\t     struct ceph_mds_session *session)\n{\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(&ci->vfs_inode);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct inode *inode = &ci->vfs_inode;\n\tstruct ceph_cap *cap;\n\tint file_wanted, used, cap_used;\n\tint took_snap_rwsem = 0;             /* true if mdsc->snap_rwsem held */\n\tint issued, implemented, want, retain, revoking, flushing = 0;\n\tint mds = -1;   /* keep track of how far we've gone through i_caps list\n\t\t\t   to avoid an infinite loop on retry */\n\tstruct rb_node *p;\n\tint tried_invalidate = 0;\n\tint delayed = 0, sent = 0, force_requeue = 0, num;\n\tint queue_invalidate = 0;\n\tint is_delayed = flags & CHECK_CAPS_NODELAY;\n\n\t/* if we are unmounting, flush any unused caps immediately. */\n\tif (mdsc->stopping)\n\t\tis_delayed = 1;\n\n\tspin_lock(&ci->i_ceph_lock);\n\n\tif (ci->i_ceph_flags & CEPH_I_FLUSH)\n\t\tflags |= CHECK_CAPS_FLUSH;\n\n\t/* flush snaps first time around only */\n\tif (!list_empty(&ci->i_cap_snaps))\n\t\t__ceph_flush_snaps(ci, &session, 0);\n\tgoto retry_locked;\nretry:\n\tspin_lock(&ci->i_ceph_lock);\nretry_locked:\n\tfile_wanted = __ceph_caps_file_wanted(ci);\n\tused = __ceph_caps_used(ci);\n\twant = file_wanted | used;\n\tissued = __ceph_caps_issued(ci, &implemented);\n\trevoking = implemented & ~issued;\n\n\tretain = want | CEPH_CAP_PIN;\n\tif (!mdsc->stopping && inode->i_nlink > 0) {\n\t\tif (want) {\n\t\t\tretain |= CEPH_CAP_ANY;       /* be greedy */\n\t\t} else {\n\t\t\tretain |= CEPH_CAP_ANY_SHARED;\n\t\t\t/*\n\t\t\t * keep RD only if we didn't have the file open RW,\n\t\t\t * because then the mds would revoke it anyway to\n\t\t\t * journal max_size=0.\n\t\t\t */\n\t\t\tif (ci->i_max_size == 0)\n\t\t\t\tretain |= CEPH_CAP_ANY_RD;\n\t\t}\n\t}\n\n\tdout(\"check_caps %p file_want %s used %s dirty %s flushing %s\"\n\t     \" issued %s revoking %s retain %s %s%s%s\\n\", inode,\n\t     ceph_cap_string(file_wanted),\n\t     ceph_cap_string(used), ceph_cap_string(ci->i_dirty_caps),\n\t     ceph_cap_string(ci->i_flushing_caps),\n\t     ceph_cap_string(issued), ceph_cap_string(revoking),\n\t     ceph_cap_string(retain),\n\t     (flags & CHECK_CAPS_AUTHONLY) ? \" AUTHONLY\" : \"\",\n\t     (flags & CHECK_CAPS_NODELAY) ? \" NODELAY\" : \"\",\n\t     (flags & CHECK_CAPS_FLUSH) ? \" FLUSH\" : \"\");\n\n\t/*\n\t * If we no longer need to hold onto old our caps, and we may\n\t * have cached pages, but don't want them, then try to invalidate.\n\t * If we fail, it's because pages are locked.... try again later.\n\t */\n\tif ((!is_delayed || mdsc->stopping) &&\n\t    ci->i_wrbuffer_ref == 0 &&               /* no dirty pages... */\n\t    inode->i_data.nrpages &&                 /* have cached pages */\n\t    (file_wanted == 0 ||                     /* no open files */\n\t     (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t  CEPH_CAP_FILE_LAZYIO))) && /*  or revoking cache */\n\t    !tried_invalidate) {\n\t\tdout(\"check_caps trying to invalidate on %p\\n\", inode);\n\t\tif (try_nonblocking_invalidate(inode) < 0) {\n\t\t\tif (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t\t\tCEPH_CAP_FILE_LAZYIO)) {\n\t\t\t\tdout(\"check_caps queuing invalidate\\n\");\n\t\t\t\tqueue_invalidate = 1;\n\t\t\t\tci->i_rdcache_revoking = ci->i_rdcache_gen;\n\t\t\t} else {\n\t\t\t\tdout(\"check_caps failed to invalidate pages\\n\");\n\t\t\t\t/* we failed to invalidate pages.  check these\n\t\t\t\t   caps again later. */\n\t\t\t\tforce_requeue = 1;\n\t\t\t\t__cap_set_timeouts(mdsc, ci);\n\t\t\t}\n\t\t}\n\t\ttried_invalidate = 1;\n\t\tgoto retry_locked;\n\t}\n\n\tnum = 0;\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tnum++;\n\n\t\t/* avoid looping forever */\n\t\tif (mds >= cap->mds ||\n\t\t    ((flags & CHECK_CAPS_AUTHONLY) && cap != ci->i_auth_cap))\n\t\t\tcontinue;\n\n\t\t/* NOTE: no side-effects allowed, until we take s_mutex */\n\n\t\tcap_used = used;\n\t\tif (ci->i_auth_cap && cap != ci->i_auth_cap)\n\t\t\tcap_used &= ~ci->i_auth_cap->issued;\n\n\t\trevoking = cap->implemented & ~cap->issued;\n\t\tdout(\" mds%d cap %p used %s issued %s implemented %s revoking %s\\n\",\n\t\t     cap->mds, cap, ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(cap_used),\n\t\t     ceph_cap_string(cap->implemented),\n\t\t     ceph_cap_string(revoking));\n\n\t\tif (cap == ci->i_auth_cap &&\n\t\t    (cap->issued & CEPH_CAP_FILE_WR)) {\n\t\t\t/* request larger max_size from MDS? */\n\t\t\tif (ci->i_wanted_max_size > ci->i_max_size &&\n\t\t\t    ci->i_wanted_max_size > ci->i_requested_max_size) {\n\t\t\t\tdout(\"requesting new max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\n\t\t\t/* approaching file_max? */\n\t\t\tif ((inode->i_size << 1) >= ci->i_max_size &&\n\t\t\t    (ci->i_reported_size << 1) < ci->i_max_size) {\n\t\t\t\tdout(\"i_size approaching max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\t\t}\n\t\t/* flush anything dirty? */\n\t\tif (cap == ci->i_auth_cap && (flags & CHECK_CAPS_FLUSH) &&\n\t\t    ci->i_dirty_caps) {\n\t\t\tdout(\"flushing dirty caps\\n\");\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* completed revocation? going down and there are no caps? */\n\t\tif (revoking && (revoking & cap_used) == 0) {\n\t\t\tdout(\"completed revocation of %s\\n\",\n\t\t\t     ceph_cap_string(cap->implemented & ~cap->issued));\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* want more caps from mds? */\n\t\tif (want & ~(cap->mds_wanted | cap->issued))\n\t\t\tgoto ack;\n\n\t\t/* things we might delay */\n\t\tif ((cap->issued & ~retain) == 0 &&\n\t\t    cap->mds_wanted == want)\n\t\t\tcontinue;     /* nope, all good */\n\n\t\tif (is_delayed)\n\t\t\tgoto ack;\n\n\t\t/* delay? */\n\t\tif ((ci->i_ceph_flags & CEPH_I_NODELAY) == 0 &&\n\t\t    time_before(jiffies, ci->i_hold_caps_max)) {\n\t\t\tdout(\" delaying issued %s -> %s, wanted %s -> %s\\n\",\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(cap->issued & retain),\n\t\t\t     ceph_cap_string(cap->mds_wanted),\n\t\t\t     ceph_cap_string(want));\n\t\t\tdelayed++;\n\t\t\tcontinue;\n\t\t}\n\nack:\n\t\tif (ci->i_ceph_flags & CEPH_I_NOFLUSH) {\n\t\t\tdout(\" skipping %p I_NOFLUSH set\\n\", inode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (session && session != cap->session) {\n\t\t\tdout(\"oops, wrong session %p mutex\\n\", session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tsession = NULL;\n\t\t}\n\t\tif (!session) {\n\t\t\tsession = cap->session;\n\t\t\tif (mutex_trylock(&session->s_mutex) == 0) {\n\t\t\t\tdout(\"inverting session/ino locks on %p\\n\",\n\t\t\t\t     session);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tif (took_snap_rwsem) {\n\t\t\t\t\tup_read(&mdsc->snap_rwsem);\n\t\t\t\t\ttook_snap_rwsem = 0;\n\t\t\t\t}\n\t\t\t\tmutex_lock(&session->s_mutex);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t\t/* take snap_rwsem after session mutex */\n\t\tif (!took_snap_rwsem) {\n\t\t\tif (down_read_trylock(&mdsc->snap_rwsem) == 0) {\n\t\t\t\tdout(\"inverting snap/in locks on %p\\n\",\n\t\t\t\t     inode);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tdown_read(&mdsc->snap_rwsem);\n\t\t\t\ttook_snap_rwsem = 1;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\ttook_snap_rwsem = 1;\n\t\t}\n\n\t\tif (cap == ci->i_auth_cap && ci->i_dirty_caps)\n\t\t\tflushing = __mark_caps_flushing(inode, session);\n\t\telse\n\t\t\tflushing = 0;\n\n\t\tmds = cap->mds;  /* remember mds, so we don't repeat */\n\t\tsent++;\n\n\t\t/* __send_cap drops i_ceph_lock */\n\t\tdelayed += __send_cap(mdsc, cap, CEPH_CAP_OP_UPDATE, cap_used,\n\t\t\t\t      want, retain, flushing, NULL);\n\t\tgoto retry; /* retake i_ceph_lock and restart our cap scan. */\n\t}\n\n\t/*\n\t * Reschedule delayed caps release if we delayed anything,\n\t * otherwise cancel.\n\t */\n\tif (delayed && is_delayed)\n\t\tforce_requeue = 1;   /* __send_cap delayed release; requeue */\n\tif (!delayed && !is_delayed)\n\t\t__cap_delay_cancel(mdsc, ci);\n\telse if (!is_delayed || force_requeue)\n\t\t__cap_delay_requeue(mdsc, ci);\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (queue_invalidate)\n\t\tceph_queue_invalidate(inode);\n\n\tif (session)\n\t\tmutex_unlock(&session->s_mutex);\n\tif (took_snap_rwsem)\n\t\tup_read(&mdsc->snap_rwsem);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_check_caps(struct ceph_inode_info *ci, int flags,\n\t\t     struct ceph_mds_session *session)\n{\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(&ci->vfs_inode);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct inode *inode = &ci->vfs_inode;\n\tstruct ceph_cap *cap;\n\tint file_wanted, used, cap_used;\n\tint took_snap_rwsem = 0;             /* true if mdsc->snap_rwsem held */\n\tint issued, implemented, want, retain, revoking, flushing = 0;\n\tint mds = -1;   /* keep track of how far we've gone through i_caps list\n\t\t\t   to avoid an infinite loop on retry */\n\tstruct rb_node *p;\n\tint tried_invalidate = 0;\n\tint delayed = 0, sent = 0, force_requeue = 0, num;\n\tint queue_invalidate = 0;\n\tint is_delayed = flags & CHECK_CAPS_NODELAY;\n\n\t/* if we are unmounting, flush any unused caps immediately. */\n\tif (mdsc->stopping)\n\t\tis_delayed = 1;\n\n\tspin_lock(&ci->i_ceph_lock);\n\n\tif (ci->i_ceph_flags & CEPH_I_FLUSH)\n\t\tflags |= CHECK_CAPS_FLUSH;\n\n\t/* flush snaps first time around only */\n\tif (!list_empty(&ci->i_cap_snaps))\n\t\t__ceph_flush_snaps(ci, &session, 0);\n\tgoto retry_locked;\nretry:\n\tspin_lock(&ci->i_ceph_lock);\nretry_locked:\n\tfile_wanted = __ceph_caps_file_wanted(ci);\n\tused = __ceph_caps_used(ci);\n\twant = file_wanted | used;\n\tissued = __ceph_caps_issued(ci, &implemented);\n\trevoking = implemented & ~issued;\n\n\tretain = want | CEPH_CAP_PIN;\n\tif (!mdsc->stopping && inode->i_nlink > 0) {\n\t\tif (want) {\n\t\t\tretain |= CEPH_CAP_ANY;       /* be greedy */\n\t\t} else {\n\t\t\tretain |= CEPH_CAP_ANY_SHARED;\n\t\t\t/*\n\t\t\t * keep RD only if we didn't have the file open RW,\n\t\t\t * because then the mds would revoke it anyway to\n\t\t\t * journal max_size=0.\n\t\t\t */\n\t\t\tif (ci->i_max_size == 0)\n\t\t\t\tretain |= CEPH_CAP_ANY_RD;\n\t\t}\n\t}\n\n\tdout(\"check_caps %p file_want %s used %s dirty %s flushing %s\"\n\t     \" issued %s revoking %s retain %s %s%s%s\\n\", inode,\n\t     ceph_cap_string(file_wanted),\n\t     ceph_cap_string(used), ceph_cap_string(ci->i_dirty_caps),\n\t     ceph_cap_string(ci->i_flushing_caps),\n\t     ceph_cap_string(issued), ceph_cap_string(revoking),\n\t     ceph_cap_string(retain),\n\t     (flags & CHECK_CAPS_AUTHONLY) ? \" AUTHONLY\" : \"\",\n\t     (flags & CHECK_CAPS_NODELAY) ? \" NODELAY\" : \"\",\n\t     (flags & CHECK_CAPS_FLUSH) ? \" FLUSH\" : \"\");\n\n\t/*\n\t * If we no longer need to hold onto old our caps, and we may\n\t * have cached pages, but don't want them, then try to invalidate.\n\t * If we fail, it's because pages are locked.... try again later.\n\t */\n\tif ((!is_delayed || mdsc->stopping) &&\n\t    ci->i_wrbuffer_ref == 0 &&               /* no dirty pages... */\n\t    inode->i_data.nrpages &&                 /* have cached pages */\n\t    (file_wanted == 0 ||                     /* no open files */\n\t     (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t  CEPH_CAP_FILE_LAZYIO))) && /*  or revoking cache */\n\t    !tried_invalidate) {\n\t\tdout(\"check_caps trying to invalidate on %p\\n\", inode);\n\t\tif (try_nonblocking_invalidate(inode) < 0) {\n\t\t\tif (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t\t\tCEPH_CAP_FILE_LAZYIO)) {\n\t\t\t\tdout(\"check_caps queuing invalidate\\n\");\n\t\t\t\tqueue_invalidate = 1;\n\t\t\t\tci->i_rdcache_revoking = ci->i_rdcache_gen;\n\t\t\t} else {\n\t\t\t\tdout(\"check_caps failed to invalidate pages\\n\");\n\t\t\t\t/* we failed to invalidate pages.  check these\n\t\t\t\t   caps again later. */\n\t\t\t\tforce_requeue = 1;\n\t\t\t\t__cap_set_timeouts(mdsc, ci);\n\t\t\t}\n\t\t}\n\t\ttried_invalidate = 1;\n\t\tgoto retry_locked;\n\t}\n\n\tnum = 0;\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tnum++;\n\n\t\t/* avoid looping forever */\n\t\tif (mds >= cap->mds ||\n\t\t    ((flags & CHECK_CAPS_AUTHONLY) && cap != ci->i_auth_cap))\n\t\t\tcontinue;\n\n\t\t/* NOTE: no side-effects allowed, until we take s_mutex */\n\n\t\tcap_used = used;\n\t\tif (ci->i_auth_cap && cap != ci->i_auth_cap)\n\t\t\tcap_used &= ~ci->i_auth_cap->issued;\n\n\t\trevoking = cap->implemented & ~cap->issued;\n\t\tdout(\" mds%d cap %p used %s issued %s implemented %s revoking %s\\n\",\n\t\t     cap->mds, cap, ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(cap_used),\n\t\t     ceph_cap_string(cap->implemented),\n\t\t     ceph_cap_string(revoking));\n\n\t\tif (cap == ci->i_auth_cap &&\n\t\t    (cap->issued & CEPH_CAP_FILE_WR)) {\n\t\t\t/* request larger max_size from MDS? */\n\t\t\tif (ci->i_wanted_max_size > ci->i_max_size &&\n\t\t\t    ci->i_wanted_max_size > ci->i_requested_max_size) {\n\t\t\t\tdout(\"requesting new max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\n\t\t\t/* approaching file_max? */\n\t\t\tif ((inode->i_size << 1) >= ci->i_max_size &&\n\t\t\t    (ci->i_reported_size << 1) < ci->i_max_size) {\n\t\t\t\tdout(\"i_size approaching max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\t\t}\n\t\t/* flush anything dirty? */\n\t\tif (cap == ci->i_auth_cap && (flags & CHECK_CAPS_FLUSH) &&\n\t\t    ci->i_dirty_caps) {\n\t\t\tdout(\"flushing dirty caps\\n\");\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* completed revocation? going down and there are no caps? */\n\t\tif (revoking && (revoking & cap_used) == 0) {\n\t\t\tdout(\"completed revocation of %s\\n\",\n\t\t\t     ceph_cap_string(cap->implemented & ~cap->issued));\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* want more caps from mds? */\n\t\tif (want & ~(cap->mds_wanted | cap->issued))\n\t\t\tgoto ack;\n\n\t\t/* things we might delay */\n\t\tif ((cap->issued & ~retain) == 0 &&\n\t\t    cap->mds_wanted == want)\n\t\t\tcontinue;     /* nope, all good */\n\n\t\tif (is_delayed)\n\t\t\tgoto ack;\n\n\t\t/* delay? */\n\t\tif ((ci->i_ceph_flags & CEPH_I_NODELAY) == 0 &&\n\t\t    time_before(jiffies, ci->i_hold_caps_max)) {\n\t\t\tdout(\" delaying issued %s -> %s, wanted %s -> %s\\n\",\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(cap->issued & retain),\n\t\t\t     ceph_cap_string(cap->mds_wanted),\n\t\t\t     ceph_cap_string(want));\n\t\t\tdelayed++;\n\t\t\tcontinue;\n\t\t}\n\nack:\n\t\tif (ci->i_ceph_flags & CEPH_I_NOFLUSH) {\n\t\t\tdout(\" skipping %p I_NOFLUSH set\\n\", inode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (session && session != cap->session) {\n\t\t\tdout(\"oops, wrong session %p mutex\\n\", session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tsession = NULL;\n\t\t}\n\t\tif (!session) {\n\t\t\tsession = cap->session;\n\t\t\tif (mutex_trylock(&session->s_mutex) == 0) {\n\t\t\t\tdout(\"inverting session/ino locks on %p\\n\",\n\t\t\t\t     session);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tif (took_snap_rwsem) {\n\t\t\t\t\tup_read(&mdsc->snap_rwsem);\n\t\t\t\t\ttook_snap_rwsem = 0;\n\t\t\t\t}\n\t\t\t\tmutex_lock(&session->s_mutex);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t\t/* take snap_rwsem after session mutex */\n\t\tif (!took_snap_rwsem) {\n\t\t\tif (down_read_trylock(&mdsc->snap_rwsem) == 0) {\n\t\t\t\tdout(\"inverting snap/in locks on %p\\n\",\n\t\t\t\t     inode);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tdown_read(&mdsc->snap_rwsem);\n\t\t\t\ttook_snap_rwsem = 1;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\ttook_snap_rwsem = 1;\n\t\t}\n\n\t\tif (cap == ci->i_auth_cap && ci->i_dirty_caps)\n\t\t\tflushing = __mark_caps_flushing(inode, session);\n\t\telse\n\t\t\tflushing = 0;\n\n\t\tmds = cap->mds;  /* remember mds, so we don't repeat */\n\t\tsent++;\n\n\t\t/* __send_cap drops i_ceph_lock */\n\t\tdelayed += __send_cap(mdsc, cap, CEPH_CAP_OP_UPDATE, cap_used,\n\t\t\t\t      want, retain, flushing, NULL);\n\t\tgoto retry; /* retake i_ceph_lock and restart our cap scan. */\n\t}\n\n\t/*\n\t * Reschedule delayed caps release if we delayed anything,\n\t * otherwise cancel.\n\t */\n\tif (delayed && is_delayed)\n\t\tforce_requeue = 1;   /* __send_cap delayed release; requeue */\n\tif (!delayed && !is_delayed)\n\t\t__cap_delay_cancel(mdsc, ci);\n\telse if (!is_delayed || force_requeue)\n\t\t__cap_delay_requeue(mdsc, ci);\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (queue_invalidate)\n\t\tceph_queue_invalidate(inode);\n\n\tif (session)\n\t\tmutex_unlock(&session->s_mutex);\n\tif (took_snap_rwsem)\n\t\tup_read(&mdsc->snap_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"flush_dirty_caps %p\\n\"",
            "inode"
          ],
          "line": 3285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "inode"
          ],
          "line": 3284
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&mdsc->cap_dirty",
            "structceph_inode_info",
            "i_dirty_item"
          ],
          "line": 3281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&mdsc->cap_dirty"
          ],
          "line": 3280
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"flush_dirty_caps\\n\""
          ],
          "line": 3278
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_flush_dirty_caps(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_inode_info *ci;\n\tstruct inode *inode;\n\n\tdout(\"flush_dirty_caps\\n\");\n\tspin_lock(&mdsc->cap_dirty_lock);\n\twhile (!list_empty(&mdsc->cap_dirty)) {\n\t\tci = list_first_entry(&mdsc->cap_dirty, struct ceph_inode_info,\n\t\t\t\t      i_dirty_item);\n\t\tinode = &ci->vfs_inode;\n\t\tihold(inode);\n\t\tdout(\"flush_dirty_caps %p\\n\", inode);\n\t\tspin_unlock(&mdsc->cap_dirty_lock);\n\t\tceph_check_caps(ci, CHECK_CAPS_NODELAY|CHECK_CAPS_FLUSH, NULL);\n\t\tiput(inode);\n\t\tspin_lock(&mdsc->cap_dirty_lock);\n\t}\n\tspin_unlock(&mdsc->cap_dirty_lock);\n\tdout(\"flush_dirty_caps done\\n\");\n}"
  },
  {
    "function_name": "ceph_check_delayed_caps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "3246-3268",
    "snippet": "void ceph_check_delayed_caps(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_inode_info *ci;\n\tint flags = CHECK_CAPS_NODELAY;\n\n\tdout(\"check_delayed_caps\\n\");\n\twhile (1) {\n\t\tspin_lock(&mdsc->cap_delay_lock);\n\t\tif (list_empty(&mdsc->cap_delay_list))\n\t\t\tbreak;\n\t\tci = list_first_entry(&mdsc->cap_delay_list,\n\t\t\t\t      struct ceph_inode_info,\n\t\t\t\t      i_cap_delay_list);\n\t\tif ((ci->i_ceph_flags & CEPH_I_FLUSH) == 0 &&\n\t\t    time_before(jiffies, ci->i_hold_caps_max))\n\t\t\tbreak;\n\t\tlist_del_init(&ci->i_cap_delay_list);\n\t\tspin_unlock(&mdsc->cap_delay_lock);\n\t\tdout(\"check_delayed_caps on %p\\n\", &ci->vfs_inode);\n\t\tceph_check_caps(ci, flags, NULL);\n\t}\n\tspin_unlock(&mdsc->cap_delay_lock);\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mdsc->cap_delay_lock"
          ],
          "line": 3267
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_check_caps",
          "args": [
            "ci",
            "flags",
            "NULL"
          ],
          "line": 3265
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_check_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "1504-1751",
          "snippet": "void ceph_check_caps(struct ceph_inode_info *ci, int flags,\n\t\t     struct ceph_mds_session *session)\n{\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(&ci->vfs_inode);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct inode *inode = &ci->vfs_inode;\n\tstruct ceph_cap *cap;\n\tint file_wanted, used, cap_used;\n\tint took_snap_rwsem = 0;             /* true if mdsc->snap_rwsem held */\n\tint issued, implemented, want, retain, revoking, flushing = 0;\n\tint mds = -1;   /* keep track of how far we've gone through i_caps list\n\t\t\t   to avoid an infinite loop on retry */\n\tstruct rb_node *p;\n\tint tried_invalidate = 0;\n\tint delayed = 0, sent = 0, force_requeue = 0, num;\n\tint queue_invalidate = 0;\n\tint is_delayed = flags & CHECK_CAPS_NODELAY;\n\n\t/* if we are unmounting, flush any unused caps immediately. */\n\tif (mdsc->stopping)\n\t\tis_delayed = 1;\n\n\tspin_lock(&ci->i_ceph_lock);\n\n\tif (ci->i_ceph_flags & CEPH_I_FLUSH)\n\t\tflags |= CHECK_CAPS_FLUSH;\n\n\t/* flush snaps first time around only */\n\tif (!list_empty(&ci->i_cap_snaps))\n\t\t__ceph_flush_snaps(ci, &session, 0);\n\tgoto retry_locked;\nretry:\n\tspin_lock(&ci->i_ceph_lock);\nretry_locked:\n\tfile_wanted = __ceph_caps_file_wanted(ci);\n\tused = __ceph_caps_used(ci);\n\twant = file_wanted | used;\n\tissued = __ceph_caps_issued(ci, &implemented);\n\trevoking = implemented & ~issued;\n\n\tretain = want | CEPH_CAP_PIN;\n\tif (!mdsc->stopping && inode->i_nlink > 0) {\n\t\tif (want) {\n\t\t\tretain |= CEPH_CAP_ANY;       /* be greedy */\n\t\t} else {\n\t\t\tretain |= CEPH_CAP_ANY_SHARED;\n\t\t\t/*\n\t\t\t * keep RD only if we didn't have the file open RW,\n\t\t\t * because then the mds would revoke it anyway to\n\t\t\t * journal max_size=0.\n\t\t\t */\n\t\t\tif (ci->i_max_size == 0)\n\t\t\t\tretain |= CEPH_CAP_ANY_RD;\n\t\t}\n\t}\n\n\tdout(\"check_caps %p file_want %s used %s dirty %s flushing %s\"\n\t     \" issued %s revoking %s retain %s %s%s%s\\n\", inode,\n\t     ceph_cap_string(file_wanted),\n\t     ceph_cap_string(used), ceph_cap_string(ci->i_dirty_caps),\n\t     ceph_cap_string(ci->i_flushing_caps),\n\t     ceph_cap_string(issued), ceph_cap_string(revoking),\n\t     ceph_cap_string(retain),\n\t     (flags & CHECK_CAPS_AUTHONLY) ? \" AUTHONLY\" : \"\",\n\t     (flags & CHECK_CAPS_NODELAY) ? \" NODELAY\" : \"\",\n\t     (flags & CHECK_CAPS_FLUSH) ? \" FLUSH\" : \"\");\n\n\t/*\n\t * If we no longer need to hold onto old our caps, and we may\n\t * have cached pages, but don't want them, then try to invalidate.\n\t * If we fail, it's because pages are locked.... try again later.\n\t */\n\tif ((!is_delayed || mdsc->stopping) &&\n\t    ci->i_wrbuffer_ref == 0 &&               /* no dirty pages... */\n\t    inode->i_data.nrpages &&                 /* have cached pages */\n\t    (file_wanted == 0 ||                     /* no open files */\n\t     (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t  CEPH_CAP_FILE_LAZYIO))) && /*  or revoking cache */\n\t    !tried_invalidate) {\n\t\tdout(\"check_caps trying to invalidate on %p\\n\", inode);\n\t\tif (try_nonblocking_invalidate(inode) < 0) {\n\t\t\tif (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t\t\tCEPH_CAP_FILE_LAZYIO)) {\n\t\t\t\tdout(\"check_caps queuing invalidate\\n\");\n\t\t\t\tqueue_invalidate = 1;\n\t\t\t\tci->i_rdcache_revoking = ci->i_rdcache_gen;\n\t\t\t} else {\n\t\t\t\tdout(\"check_caps failed to invalidate pages\\n\");\n\t\t\t\t/* we failed to invalidate pages.  check these\n\t\t\t\t   caps again later. */\n\t\t\t\tforce_requeue = 1;\n\t\t\t\t__cap_set_timeouts(mdsc, ci);\n\t\t\t}\n\t\t}\n\t\ttried_invalidate = 1;\n\t\tgoto retry_locked;\n\t}\n\n\tnum = 0;\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tnum++;\n\n\t\t/* avoid looping forever */\n\t\tif (mds >= cap->mds ||\n\t\t    ((flags & CHECK_CAPS_AUTHONLY) && cap != ci->i_auth_cap))\n\t\t\tcontinue;\n\n\t\t/* NOTE: no side-effects allowed, until we take s_mutex */\n\n\t\tcap_used = used;\n\t\tif (ci->i_auth_cap && cap != ci->i_auth_cap)\n\t\t\tcap_used &= ~ci->i_auth_cap->issued;\n\n\t\trevoking = cap->implemented & ~cap->issued;\n\t\tdout(\" mds%d cap %p used %s issued %s implemented %s revoking %s\\n\",\n\t\t     cap->mds, cap, ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(cap_used),\n\t\t     ceph_cap_string(cap->implemented),\n\t\t     ceph_cap_string(revoking));\n\n\t\tif (cap == ci->i_auth_cap &&\n\t\t    (cap->issued & CEPH_CAP_FILE_WR)) {\n\t\t\t/* request larger max_size from MDS? */\n\t\t\tif (ci->i_wanted_max_size > ci->i_max_size &&\n\t\t\t    ci->i_wanted_max_size > ci->i_requested_max_size) {\n\t\t\t\tdout(\"requesting new max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\n\t\t\t/* approaching file_max? */\n\t\t\tif ((inode->i_size << 1) >= ci->i_max_size &&\n\t\t\t    (ci->i_reported_size << 1) < ci->i_max_size) {\n\t\t\t\tdout(\"i_size approaching max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\t\t}\n\t\t/* flush anything dirty? */\n\t\tif (cap == ci->i_auth_cap && (flags & CHECK_CAPS_FLUSH) &&\n\t\t    ci->i_dirty_caps) {\n\t\t\tdout(\"flushing dirty caps\\n\");\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* completed revocation? going down and there are no caps? */\n\t\tif (revoking && (revoking & cap_used) == 0) {\n\t\t\tdout(\"completed revocation of %s\\n\",\n\t\t\t     ceph_cap_string(cap->implemented & ~cap->issued));\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* want more caps from mds? */\n\t\tif (want & ~(cap->mds_wanted | cap->issued))\n\t\t\tgoto ack;\n\n\t\t/* things we might delay */\n\t\tif ((cap->issued & ~retain) == 0 &&\n\t\t    cap->mds_wanted == want)\n\t\t\tcontinue;     /* nope, all good */\n\n\t\tif (is_delayed)\n\t\t\tgoto ack;\n\n\t\t/* delay? */\n\t\tif ((ci->i_ceph_flags & CEPH_I_NODELAY) == 0 &&\n\t\t    time_before(jiffies, ci->i_hold_caps_max)) {\n\t\t\tdout(\" delaying issued %s -> %s, wanted %s -> %s\\n\",\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(cap->issued & retain),\n\t\t\t     ceph_cap_string(cap->mds_wanted),\n\t\t\t     ceph_cap_string(want));\n\t\t\tdelayed++;\n\t\t\tcontinue;\n\t\t}\n\nack:\n\t\tif (ci->i_ceph_flags & CEPH_I_NOFLUSH) {\n\t\t\tdout(\" skipping %p I_NOFLUSH set\\n\", inode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (session && session != cap->session) {\n\t\t\tdout(\"oops, wrong session %p mutex\\n\", session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tsession = NULL;\n\t\t}\n\t\tif (!session) {\n\t\t\tsession = cap->session;\n\t\t\tif (mutex_trylock(&session->s_mutex) == 0) {\n\t\t\t\tdout(\"inverting session/ino locks on %p\\n\",\n\t\t\t\t     session);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tif (took_snap_rwsem) {\n\t\t\t\t\tup_read(&mdsc->snap_rwsem);\n\t\t\t\t\ttook_snap_rwsem = 0;\n\t\t\t\t}\n\t\t\t\tmutex_lock(&session->s_mutex);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t\t/* take snap_rwsem after session mutex */\n\t\tif (!took_snap_rwsem) {\n\t\t\tif (down_read_trylock(&mdsc->snap_rwsem) == 0) {\n\t\t\t\tdout(\"inverting snap/in locks on %p\\n\",\n\t\t\t\t     inode);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tdown_read(&mdsc->snap_rwsem);\n\t\t\t\ttook_snap_rwsem = 1;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\ttook_snap_rwsem = 1;\n\t\t}\n\n\t\tif (cap == ci->i_auth_cap && ci->i_dirty_caps)\n\t\t\tflushing = __mark_caps_flushing(inode, session);\n\t\telse\n\t\t\tflushing = 0;\n\n\t\tmds = cap->mds;  /* remember mds, so we don't repeat */\n\t\tsent++;\n\n\t\t/* __send_cap drops i_ceph_lock */\n\t\tdelayed += __send_cap(mdsc, cap, CEPH_CAP_OP_UPDATE, cap_used,\n\t\t\t\t      want, retain, flushing, NULL);\n\t\tgoto retry; /* retake i_ceph_lock and restart our cap scan. */\n\t}\n\n\t/*\n\t * Reschedule delayed caps release if we delayed anything,\n\t * otherwise cancel.\n\t */\n\tif (delayed && is_delayed)\n\t\tforce_requeue = 1;   /* __send_cap delayed release; requeue */\n\tif (!delayed && !is_delayed)\n\t\t__cap_delay_cancel(mdsc, ci);\n\telse if (!is_delayed || force_requeue)\n\t\t__cap_delay_requeue(mdsc, ci);\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (queue_invalidate)\n\t\tceph_queue_invalidate(inode);\n\n\tif (session)\n\t\tmutex_unlock(&session->s_mutex);\n\tif (took_snap_rwsem)\n\t\tup_read(&mdsc->snap_rwsem);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_check_caps(struct ceph_inode_info *ci, int flags,\n\t\t     struct ceph_mds_session *session)\n{\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(&ci->vfs_inode);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct inode *inode = &ci->vfs_inode;\n\tstruct ceph_cap *cap;\n\tint file_wanted, used, cap_used;\n\tint took_snap_rwsem = 0;             /* true if mdsc->snap_rwsem held */\n\tint issued, implemented, want, retain, revoking, flushing = 0;\n\tint mds = -1;   /* keep track of how far we've gone through i_caps list\n\t\t\t   to avoid an infinite loop on retry */\n\tstruct rb_node *p;\n\tint tried_invalidate = 0;\n\tint delayed = 0, sent = 0, force_requeue = 0, num;\n\tint queue_invalidate = 0;\n\tint is_delayed = flags & CHECK_CAPS_NODELAY;\n\n\t/* if we are unmounting, flush any unused caps immediately. */\n\tif (mdsc->stopping)\n\t\tis_delayed = 1;\n\n\tspin_lock(&ci->i_ceph_lock);\n\n\tif (ci->i_ceph_flags & CEPH_I_FLUSH)\n\t\tflags |= CHECK_CAPS_FLUSH;\n\n\t/* flush snaps first time around only */\n\tif (!list_empty(&ci->i_cap_snaps))\n\t\t__ceph_flush_snaps(ci, &session, 0);\n\tgoto retry_locked;\nretry:\n\tspin_lock(&ci->i_ceph_lock);\nretry_locked:\n\tfile_wanted = __ceph_caps_file_wanted(ci);\n\tused = __ceph_caps_used(ci);\n\twant = file_wanted | used;\n\tissued = __ceph_caps_issued(ci, &implemented);\n\trevoking = implemented & ~issued;\n\n\tretain = want | CEPH_CAP_PIN;\n\tif (!mdsc->stopping && inode->i_nlink > 0) {\n\t\tif (want) {\n\t\t\tretain |= CEPH_CAP_ANY;       /* be greedy */\n\t\t} else {\n\t\t\tretain |= CEPH_CAP_ANY_SHARED;\n\t\t\t/*\n\t\t\t * keep RD only if we didn't have the file open RW,\n\t\t\t * because then the mds would revoke it anyway to\n\t\t\t * journal max_size=0.\n\t\t\t */\n\t\t\tif (ci->i_max_size == 0)\n\t\t\t\tretain |= CEPH_CAP_ANY_RD;\n\t\t}\n\t}\n\n\tdout(\"check_caps %p file_want %s used %s dirty %s flushing %s\"\n\t     \" issued %s revoking %s retain %s %s%s%s\\n\", inode,\n\t     ceph_cap_string(file_wanted),\n\t     ceph_cap_string(used), ceph_cap_string(ci->i_dirty_caps),\n\t     ceph_cap_string(ci->i_flushing_caps),\n\t     ceph_cap_string(issued), ceph_cap_string(revoking),\n\t     ceph_cap_string(retain),\n\t     (flags & CHECK_CAPS_AUTHONLY) ? \" AUTHONLY\" : \"\",\n\t     (flags & CHECK_CAPS_NODELAY) ? \" NODELAY\" : \"\",\n\t     (flags & CHECK_CAPS_FLUSH) ? \" FLUSH\" : \"\");\n\n\t/*\n\t * If we no longer need to hold onto old our caps, and we may\n\t * have cached pages, but don't want them, then try to invalidate.\n\t * If we fail, it's because pages are locked.... try again later.\n\t */\n\tif ((!is_delayed || mdsc->stopping) &&\n\t    ci->i_wrbuffer_ref == 0 &&               /* no dirty pages... */\n\t    inode->i_data.nrpages &&                 /* have cached pages */\n\t    (file_wanted == 0 ||                     /* no open files */\n\t     (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t  CEPH_CAP_FILE_LAZYIO))) && /*  or revoking cache */\n\t    !tried_invalidate) {\n\t\tdout(\"check_caps trying to invalidate on %p\\n\", inode);\n\t\tif (try_nonblocking_invalidate(inode) < 0) {\n\t\t\tif (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t\t\tCEPH_CAP_FILE_LAZYIO)) {\n\t\t\t\tdout(\"check_caps queuing invalidate\\n\");\n\t\t\t\tqueue_invalidate = 1;\n\t\t\t\tci->i_rdcache_revoking = ci->i_rdcache_gen;\n\t\t\t} else {\n\t\t\t\tdout(\"check_caps failed to invalidate pages\\n\");\n\t\t\t\t/* we failed to invalidate pages.  check these\n\t\t\t\t   caps again later. */\n\t\t\t\tforce_requeue = 1;\n\t\t\t\t__cap_set_timeouts(mdsc, ci);\n\t\t\t}\n\t\t}\n\t\ttried_invalidate = 1;\n\t\tgoto retry_locked;\n\t}\n\n\tnum = 0;\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tnum++;\n\n\t\t/* avoid looping forever */\n\t\tif (mds >= cap->mds ||\n\t\t    ((flags & CHECK_CAPS_AUTHONLY) && cap != ci->i_auth_cap))\n\t\t\tcontinue;\n\n\t\t/* NOTE: no side-effects allowed, until we take s_mutex */\n\n\t\tcap_used = used;\n\t\tif (ci->i_auth_cap && cap != ci->i_auth_cap)\n\t\t\tcap_used &= ~ci->i_auth_cap->issued;\n\n\t\trevoking = cap->implemented & ~cap->issued;\n\t\tdout(\" mds%d cap %p used %s issued %s implemented %s revoking %s\\n\",\n\t\t     cap->mds, cap, ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(cap_used),\n\t\t     ceph_cap_string(cap->implemented),\n\t\t     ceph_cap_string(revoking));\n\n\t\tif (cap == ci->i_auth_cap &&\n\t\t    (cap->issued & CEPH_CAP_FILE_WR)) {\n\t\t\t/* request larger max_size from MDS? */\n\t\t\tif (ci->i_wanted_max_size > ci->i_max_size &&\n\t\t\t    ci->i_wanted_max_size > ci->i_requested_max_size) {\n\t\t\t\tdout(\"requesting new max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\n\t\t\t/* approaching file_max? */\n\t\t\tif ((inode->i_size << 1) >= ci->i_max_size &&\n\t\t\t    (ci->i_reported_size << 1) < ci->i_max_size) {\n\t\t\t\tdout(\"i_size approaching max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\t\t}\n\t\t/* flush anything dirty? */\n\t\tif (cap == ci->i_auth_cap && (flags & CHECK_CAPS_FLUSH) &&\n\t\t    ci->i_dirty_caps) {\n\t\t\tdout(\"flushing dirty caps\\n\");\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* completed revocation? going down and there are no caps? */\n\t\tif (revoking && (revoking & cap_used) == 0) {\n\t\t\tdout(\"completed revocation of %s\\n\",\n\t\t\t     ceph_cap_string(cap->implemented & ~cap->issued));\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* want more caps from mds? */\n\t\tif (want & ~(cap->mds_wanted | cap->issued))\n\t\t\tgoto ack;\n\n\t\t/* things we might delay */\n\t\tif ((cap->issued & ~retain) == 0 &&\n\t\t    cap->mds_wanted == want)\n\t\t\tcontinue;     /* nope, all good */\n\n\t\tif (is_delayed)\n\t\t\tgoto ack;\n\n\t\t/* delay? */\n\t\tif ((ci->i_ceph_flags & CEPH_I_NODELAY) == 0 &&\n\t\t    time_before(jiffies, ci->i_hold_caps_max)) {\n\t\t\tdout(\" delaying issued %s -> %s, wanted %s -> %s\\n\",\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(cap->issued & retain),\n\t\t\t     ceph_cap_string(cap->mds_wanted),\n\t\t\t     ceph_cap_string(want));\n\t\t\tdelayed++;\n\t\t\tcontinue;\n\t\t}\n\nack:\n\t\tif (ci->i_ceph_flags & CEPH_I_NOFLUSH) {\n\t\t\tdout(\" skipping %p I_NOFLUSH set\\n\", inode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (session && session != cap->session) {\n\t\t\tdout(\"oops, wrong session %p mutex\\n\", session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tsession = NULL;\n\t\t}\n\t\tif (!session) {\n\t\t\tsession = cap->session;\n\t\t\tif (mutex_trylock(&session->s_mutex) == 0) {\n\t\t\t\tdout(\"inverting session/ino locks on %p\\n\",\n\t\t\t\t     session);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tif (took_snap_rwsem) {\n\t\t\t\t\tup_read(&mdsc->snap_rwsem);\n\t\t\t\t\ttook_snap_rwsem = 0;\n\t\t\t\t}\n\t\t\t\tmutex_lock(&session->s_mutex);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t\t/* take snap_rwsem after session mutex */\n\t\tif (!took_snap_rwsem) {\n\t\t\tif (down_read_trylock(&mdsc->snap_rwsem) == 0) {\n\t\t\t\tdout(\"inverting snap/in locks on %p\\n\",\n\t\t\t\t     inode);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tdown_read(&mdsc->snap_rwsem);\n\t\t\t\ttook_snap_rwsem = 1;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\ttook_snap_rwsem = 1;\n\t\t}\n\n\t\tif (cap == ci->i_auth_cap && ci->i_dirty_caps)\n\t\t\tflushing = __mark_caps_flushing(inode, session);\n\t\telse\n\t\t\tflushing = 0;\n\n\t\tmds = cap->mds;  /* remember mds, so we don't repeat */\n\t\tsent++;\n\n\t\t/* __send_cap drops i_ceph_lock */\n\t\tdelayed += __send_cap(mdsc, cap, CEPH_CAP_OP_UPDATE, cap_used,\n\t\t\t\t      want, retain, flushing, NULL);\n\t\tgoto retry; /* retake i_ceph_lock and restart our cap scan. */\n\t}\n\n\t/*\n\t * Reschedule delayed caps release if we delayed anything,\n\t * otherwise cancel.\n\t */\n\tif (delayed && is_delayed)\n\t\tforce_requeue = 1;   /* __send_cap delayed release; requeue */\n\tif (!delayed && !is_delayed)\n\t\t__cap_delay_cancel(mdsc, ci);\n\telse if (!is_delayed || force_requeue)\n\t\t__cap_delay_requeue(mdsc, ci);\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (queue_invalidate)\n\t\tceph_queue_invalidate(inode);\n\n\tif (session)\n\t\tmutex_unlock(&session->s_mutex);\n\tif (took_snap_rwsem)\n\t\tup_read(&mdsc->snap_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"check_delayed_caps on %p\\n\"",
            "&ci->vfs_inode"
          ],
          "line": 3264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&ci->i_cap_delay_list"
          ],
          "line": 3262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "jiffies",
            "ci->i_hold_caps_max"
          ],
          "line": 3260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&mdsc->cap_delay_list",
            "structceph_inode_info",
            "i_cap_delay_list"
          ],
          "line": 3256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&mdsc->cap_delay_list"
          ],
          "line": 3254
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mdsc->cap_delay_lock"
          ],
          "line": 3253
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"check_delayed_caps\\n\""
          ],
          "line": 3251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_check_delayed_caps(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_inode_info *ci;\n\tint flags = CHECK_CAPS_NODELAY;\n\n\tdout(\"check_delayed_caps\\n\");\n\twhile (1) {\n\t\tspin_lock(&mdsc->cap_delay_lock);\n\t\tif (list_empty(&mdsc->cap_delay_list))\n\t\t\tbreak;\n\t\tci = list_first_entry(&mdsc->cap_delay_list,\n\t\t\t\t      struct ceph_inode_info,\n\t\t\t\t      i_cap_delay_list);\n\t\tif ((ci->i_ceph_flags & CEPH_I_FLUSH) == 0 &&\n\t\t    time_before(jiffies, ci->i_hold_caps_max))\n\t\t\tbreak;\n\t\tlist_del_init(&ci->i_cap_delay_list);\n\t\tspin_unlock(&mdsc->cap_delay_lock);\n\t\tdout(\"check_delayed_caps on %p\\n\", &ci->vfs_inode);\n\t\tceph_check_caps(ci, flags, NULL);\n\t}\n\tspin_unlock(&mdsc->cap_delay_lock);\n}"
  },
  {
    "function_name": "ceph_handle_caps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "3053-3241",
    "snippet": "void ceph_handle_caps(struct ceph_mds_session *session,\n\t\t      struct ceph_msg *msg)\n{\n\tstruct ceph_mds_client *mdsc = session->s_mdsc;\n\tstruct super_block *sb = mdsc->fsc->sb;\n\tstruct inode *inode;\n\tstruct ceph_inode_info *ci;\n\tstruct ceph_cap *cap;\n\tstruct ceph_mds_caps *h;\n\tstruct ceph_mds_cap_peer *peer = NULL;\n\tstruct ceph_snap_realm *realm;\n\tint mds = session->s_mds;\n\tint op, issued;\n\tu32 seq, mseq;\n\tstruct ceph_vino vino;\n\tu64 cap_id;\n\tu64 size, max_size;\n\tu64 tid;\n\tu64 inline_version = 0;\n\tvoid *inline_data = NULL;\n\tu32  inline_len = 0;\n\tvoid *snaptrace;\n\tsize_t snaptrace_len;\n\tvoid *p, *end;\n\n\tdout(\"handle_caps from mds%d\\n\", mds);\n\n\t/* decode */\n\tend = msg->front.iov_base + msg->front.iov_len;\n\ttid = le64_to_cpu(msg->hdr.tid);\n\tif (msg->front.iov_len < sizeof(*h))\n\t\tgoto bad;\n\th = msg->front.iov_base;\n\top = le32_to_cpu(h->op);\n\tvino.ino = le64_to_cpu(h->ino);\n\tvino.snap = CEPH_NOSNAP;\n\tcap_id = le64_to_cpu(h->cap_id);\n\tseq = le32_to_cpu(h->seq);\n\tmseq = le32_to_cpu(h->migrate_seq);\n\tsize = le64_to_cpu(h->size);\n\tmax_size = le64_to_cpu(h->max_size);\n\n\tsnaptrace = h + 1;\n\tsnaptrace_len = le32_to_cpu(h->snap_trace_len);\n\tp = snaptrace + snaptrace_len;\n\n\tif (le16_to_cpu(msg->hdr.version) >= 2) {\n\t\tu32 flock_len;\n\t\tceph_decode_32_safe(&p, end, flock_len, bad);\n\t\tif (p + flock_len > end)\n\t\t\tgoto bad;\n\t\tp += flock_len;\n\t}\n\n\tif (le16_to_cpu(msg->hdr.version) >= 3) {\n\t\tif (op == CEPH_CAP_OP_IMPORT) {\n\t\t\tif (p + sizeof(*peer) > end)\n\t\t\t\tgoto bad;\n\t\t\tpeer = p;\n\t\t\tp += sizeof(*peer);\n\t\t} else if (op == CEPH_CAP_OP_EXPORT) {\n\t\t\t/* recorded in unused fields */\n\t\t\tpeer = (void *)&h->size;\n\t\t}\n\t}\n\n\tif (le16_to_cpu(msg->hdr.version) >= 4) {\n\t\tceph_decode_64_safe(&p, end, inline_version, bad);\n\t\tceph_decode_32_safe(&p, end, inline_len, bad);\n\t\tif (p + inline_len > end)\n\t\t\tgoto bad;\n\t\tinline_data = p;\n\t\tp += inline_len;\n\t}\n\n\t/* lookup ino */\n\tinode = ceph_find_inode(sb, vino);\n\tci = ceph_inode(inode);\n\tdout(\" op %s ino %llx.%llx inode %p\\n\", ceph_cap_op_name(op), vino.ino,\n\t     vino.snap, inode);\n\n\tmutex_lock(&session->s_mutex);\n\tsession->s_seq++;\n\tdout(\" mds%d seq %lld cap seq %u\\n\", session->s_mds, session->s_seq,\n\t     (unsigned)seq);\n\n\tif (op == CEPH_CAP_OP_IMPORT)\n\t\tceph_add_cap_releases(mdsc, session);\n\n\tif (!inode) {\n\t\tdout(\" i don't have ino %llx\\n\", vino.ino);\n\n\t\tif (op == CEPH_CAP_OP_IMPORT) {\n\t\t\tspin_lock(&session->s_cap_lock);\n\t\t\t__queue_cap_release(session, vino.ino, cap_id,\n\t\t\t\t\t    mseq, seq);\n\t\t\tspin_unlock(&session->s_cap_lock);\n\t\t}\n\t\tgoto flush_cap_releases;\n\t}\n\n\t/* these will work even if we don't have a cap yet */\n\tswitch (op) {\n\tcase CEPH_CAP_OP_FLUSHSNAP_ACK:\n\t\thandle_cap_flushsnap_ack(inode, tid, h, session);\n\t\tgoto done;\n\n\tcase CEPH_CAP_OP_EXPORT:\n\t\thandle_cap_export(inode, h, peer, session);\n\t\tgoto done_unlocked;\n\n\tcase CEPH_CAP_OP_IMPORT:\n\t\trealm = NULL;\n\t\tif (snaptrace_len) {\n\t\t\tdown_write(&mdsc->snap_rwsem);\n\t\t\tceph_update_snap_trace(mdsc, snaptrace,\n\t\t\t\t\t       snaptrace + snaptrace_len,\n\t\t\t\t\t       false, &realm);\n\t\t\tdowngrade_write(&mdsc->snap_rwsem);\n\t\t} else {\n\t\t\tdown_read(&mdsc->snap_rwsem);\n\t\t}\n\t\thandle_cap_import(mdsc, inode, h, peer, session,\n\t\t\t\t  &cap, &issued);\n\t\thandle_cap_grant(mdsc, inode, h,\n\t\t\t\t inline_version, inline_data, inline_len,\n\t\t\t\t msg->middle, session, cap, issued);\n\t\tif (realm)\n\t\t\tceph_put_snap_realm(mdsc, realm);\n\t\tgoto done_unlocked;\n\t}\n\n\t/* the rest require a cap */\n\tspin_lock(&ci->i_ceph_lock);\n\tcap = __get_cap_for_mds(ceph_inode(inode), mds);\n\tif (!cap) {\n\t\tdout(\" no cap on %p ino %llx.%llx from mds%d\\n\",\n\t\t     inode, ceph_ino(inode), ceph_snap(inode), mds);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tgoto flush_cap_releases;\n\t}\n\n\t/* note that each of these drops i_ceph_lock for us */\n\tswitch (op) {\n\tcase CEPH_CAP_OP_REVOKE:\n\tcase CEPH_CAP_OP_GRANT:\n\t\t__ceph_caps_issued(ci, &issued);\n\t\tissued |= __ceph_caps_dirty(ci);\n\t\thandle_cap_grant(mdsc, inode, h,\n\t\t\t\t inline_version, inline_data, inline_len,\n\t\t\t\t msg->middle, session, cap, issued);\n\t\tgoto done_unlocked;\n\n\tcase CEPH_CAP_OP_FLUSH_ACK:\n\t\thandle_cap_flush_ack(inode, tid, h, session, cap);\n\t\tbreak;\n\n\tcase CEPH_CAP_OP_TRUNC:\n\t\thandle_cap_trunc(inode, h, session);\n\t\tbreak;\n\n\tdefault:\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tpr_err(\"ceph_handle_caps: unknown cap op %d %s\\n\", op,\n\t\t       ceph_cap_op_name(op));\n\t}\n\n\tgoto done;\n\nflush_cap_releases:\n\t/*\n\t * send any full release message to try to move things\n\t * along for the mds (who clearly thinks we still have this\n\t * cap).\n\t */\n\tceph_add_cap_releases(mdsc, session);\n\tceph_send_cap_releases(mdsc, session);\n\ndone:\n\tmutex_unlock(&session->s_mutex);\ndone_unlocked:\n\tiput(inode);\n\treturn;\n\nbad:\n\tpr_err(\"ceph_handle_caps: corrupt message\\n\");\n\tceph_msg_dump(msg);\n\treturn;\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_msg_dump",
          "args": [
            "msg"
          ],
          "line": 3239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"ceph_handle_caps: corrupt message\\n\""
          ],
          "line": 3238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 3234
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&session->s_mutex"
          ],
          "line": 3232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_send_cap_releases",
          "args": [
            "mdsc",
            "session"
          ],
          "line": 3229
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_send_cap_releases",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1537-1555",
          "snippet": "void ceph_send_cap_releases(struct ceph_mds_client *mdsc,\n\t\t\t    struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *msg;\n\n\tdout(\"send_cap_releases mds%d\\n\", session->s_mds);\n\tspin_lock(&session->s_cap_lock);\n\twhile (!list_empty(&session->s_cap_releases_done)) {\n\t\tmsg = list_first_entry(&session->s_cap_releases_done,\n\t\t\t\t struct ceph_msg, list_head);\n\t\tlist_del_init(&msg->list_head);\n\t\tspin_unlock(&session->s_cap_lock);\n\t\tmsg->hdr.front_len = cpu_to_le32(msg->front.iov_len);\n\t\tdout(\"send_cap_releases mds%d %p\\n\", session->s_mds, msg);\n\t\tceph_con_send(&session->s_con, msg);\n\t\tspin_lock(&session->s_cap_lock);\n\t}\n\tspin_unlock(&session->s_cap_lock);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_send_cap_releases(struct ceph_mds_client *mdsc,\n\t\t\t    struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *msg;\n\n\tdout(\"send_cap_releases mds%d\\n\", session->s_mds);\n\tspin_lock(&session->s_cap_lock);\n\twhile (!list_empty(&session->s_cap_releases_done)) {\n\t\tmsg = list_first_entry(&session->s_cap_releases_done,\n\t\t\t\t struct ceph_msg, list_head);\n\t\tlist_del_init(&msg->list_head);\n\t\tspin_unlock(&session->s_cap_lock);\n\t\tmsg->hdr.front_len = cpu_to_le32(msg->front.iov_len);\n\t\tdout(\"send_cap_releases mds%d %p\\n\", session->s_mds, msg);\n\t\tceph_con_send(&session->s_con, msg);\n\t\tspin_lock(&session->s_cap_lock);\n\t}\n\tspin_unlock(&session->s_cap_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_add_cap_releases",
          "args": [
            "mdsc",
            "session"
          ],
          "line": 3228
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_add_cap_releases",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1412-1468",
          "snippet": "int ceph_add_cap_releases(struct ceph_mds_client *mdsc,\n\t\t\t  struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *msg, *partial = NULL;\n\tstruct ceph_mds_cap_release *head;\n\tint err = -ENOMEM;\n\tint extra = mdsc->fsc->mount_options->cap_release_safety;\n\tint num;\n\n\tdout(\"add_cap_releases %p mds%d extra %d\\n\", session, session->s_mds,\n\t     extra);\n\n\tspin_lock(&session->s_cap_lock);\n\n\tif (!list_empty(&session->s_cap_releases)) {\n\t\tmsg = list_first_entry(&session->s_cap_releases,\n\t\t\t\t       struct ceph_msg,\n\t\t\t\t list_head);\n\t\thead = msg->front.iov_base;\n\t\tnum = le32_to_cpu(head->num);\n\t\tif (num) {\n\t\t\tdout(\" partial %p with (%d/%d)\\n\", msg, num,\n\t\t\t     (int)CEPH_CAPS_PER_RELEASE);\n\t\t\textra += CEPH_CAPS_PER_RELEASE - num;\n\t\t\tpartial = msg;\n\t\t}\n\t}\n\twhile (session->s_num_cap_releases < session->s_nr_caps + extra) {\n\t\tspin_unlock(&session->s_cap_lock);\n\t\tmsg = ceph_msg_new(CEPH_MSG_CLIENT_CAPRELEASE, PAGE_CACHE_SIZE,\n\t\t\t\t   GFP_NOFS, false);\n\t\tif (!msg)\n\t\t\tgoto out_unlocked;\n\t\tdout(\"add_cap_releases %p msg %p now %d\\n\", session, msg,\n\t\t     (int)msg->front.iov_len);\n\t\thead = msg->front.iov_base;\n\t\thead->num = cpu_to_le32(0);\n\t\tmsg->front.iov_len = sizeof(*head);\n\t\tspin_lock(&session->s_cap_lock);\n\t\tlist_add(&msg->list_head, &session->s_cap_releases);\n\t\tsession->s_num_cap_releases += CEPH_CAPS_PER_RELEASE;\n\t}\n\n\tif (partial) {\n\t\thead = partial->front.iov_base;\n\t\tnum = le32_to_cpu(head->num);\n\t\tdout(\" queueing partial %p with %d/%d\\n\", partial, num,\n\t\t     (int)CEPH_CAPS_PER_RELEASE);\n\t\tlist_move_tail(&partial->list_head,\n\t\t\t       &session->s_cap_releases_done);\n\t\tsession->s_num_cap_releases -= CEPH_CAPS_PER_RELEASE - num;\n\t}\n\terr = 0;\n\tspin_unlock(&session->s_cap_lock);\nout_unlocked:\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);\n\nint ceph_add_cap_releases(struct ceph_mds_client *mdsc,\n\t\t\t  struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *msg, *partial = NULL;\n\tstruct ceph_mds_cap_release *head;\n\tint err = -ENOMEM;\n\tint extra = mdsc->fsc->mount_options->cap_release_safety;\n\tint num;\n\n\tdout(\"add_cap_releases %p mds%d extra %d\\n\", session, session->s_mds,\n\t     extra);\n\n\tspin_lock(&session->s_cap_lock);\n\n\tif (!list_empty(&session->s_cap_releases)) {\n\t\tmsg = list_first_entry(&session->s_cap_releases,\n\t\t\t\t       struct ceph_msg,\n\t\t\t\t list_head);\n\t\thead = msg->front.iov_base;\n\t\tnum = le32_to_cpu(head->num);\n\t\tif (num) {\n\t\t\tdout(\" partial %p with (%d/%d)\\n\", msg, num,\n\t\t\t     (int)CEPH_CAPS_PER_RELEASE);\n\t\t\textra += CEPH_CAPS_PER_RELEASE - num;\n\t\t\tpartial = msg;\n\t\t}\n\t}\n\twhile (session->s_num_cap_releases < session->s_nr_caps + extra) {\n\t\tspin_unlock(&session->s_cap_lock);\n\t\tmsg = ceph_msg_new(CEPH_MSG_CLIENT_CAPRELEASE, PAGE_CACHE_SIZE,\n\t\t\t\t   GFP_NOFS, false);\n\t\tif (!msg)\n\t\t\tgoto out_unlocked;\n\t\tdout(\"add_cap_releases %p msg %p now %d\\n\", session, msg,\n\t\t     (int)msg->front.iov_len);\n\t\thead = msg->front.iov_base;\n\t\thead->num = cpu_to_le32(0);\n\t\tmsg->front.iov_len = sizeof(*head);\n\t\tspin_lock(&session->s_cap_lock);\n\t\tlist_add(&msg->list_head, &session->s_cap_releases);\n\t\tsession->s_num_cap_releases += CEPH_CAPS_PER_RELEASE;\n\t}\n\n\tif (partial) {\n\t\thead = partial->front.iov_base;\n\t\tnum = le32_to_cpu(head->num);\n\t\tdout(\" queueing partial %p with %d/%d\\n\", partial, num,\n\t\t     (int)CEPH_CAPS_PER_RELEASE);\n\t\tlist_move_tail(&partial->list_head,\n\t\t\t       &session->s_cap_releases_done);\n\t\tsession->s_num_cap_releases -= CEPH_CAPS_PER_RELEASE - num;\n\t}\n\terr = 0;\n\tspin_unlock(&session->s_cap_lock);\nout_unlocked:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"ceph_handle_caps: unknown cap op %d %s\\n\"",
            "op",
            "ceph_cap_op_name(op)"
          ],
          "line": 3216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_cap_op_name",
          "args": [
            "op"
          ],
          "line": 3217
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_cap_op_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/strings.c",
          "lines": "84-102",
          "snippet": "const char *ceph_cap_op_name(int op)\n{\n\tswitch (op) {\n\tcase CEPH_CAP_OP_GRANT: return \"grant\";\n\tcase CEPH_CAP_OP_REVOKE: return \"revoke\";\n\tcase CEPH_CAP_OP_TRUNC: return \"trunc\";\n\tcase CEPH_CAP_OP_EXPORT: return \"export\";\n\tcase CEPH_CAP_OP_IMPORT: return \"import\";\n\tcase CEPH_CAP_OP_UPDATE: return \"update\";\n\tcase CEPH_CAP_OP_DROP: return \"drop\";\n\tcase CEPH_CAP_OP_FLUSH: return \"flush\";\n\tcase CEPH_CAP_OP_FLUSH_ACK: return \"flush_ack\";\n\tcase CEPH_CAP_OP_FLUSHSNAP: return \"flushsnap\";\n\tcase CEPH_CAP_OP_FLUSHSNAP_ACK: return \"flushsnap_ack\";\n\tcase CEPH_CAP_OP_RELEASE: return \"release\";\n\tcase CEPH_CAP_OP_RENEW: return \"renew\";\n\t}\n\treturn \"???\";\n}",
          "includes": [
            "#include <linux/ceph/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/types.h>\n#include <linux/module.h>\n\nconst char *ceph_cap_op_name(int op)\n{\n\tswitch (op) {\n\tcase CEPH_CAP_OP_GRANT: return \"grant\";\n\tcase CEPH_CAP_OP_REVOKE: return \"revoke\";\n\tcase CEPH_CAP_OP_TRUNC: return \"trunc\";\n\tcase CEPH_CAP_OP_EXPORT: return \"export\";\n\tcase CEPH_CAP_OP_IMPORT: return \"import\";\n\tcase CEPH_CAP_OP_UPDATE: return \"update\";\n\tcase CEPH_CAP_OP_DROP: return \"drop\";\n\tcase CEPH_CAP_OP_FLUSH: return \"flush\";\n\tcase CEPH_CAP_OP_FLUSH_ACK: return \"flush_ack\";\n\tcase CEPH_CAP_OP_FLUSHSNAP: return \"flushsnap\";\n\tcase CEPH_CAP_OP_FLUSHSNAP_ACK: return \"flushsnap_ack\";\n\tcase CEPH_CAP_OP_RELEASE: return \"release\";\n\tcase CEPH_CAP_OP_RENEW: return \"renew\";\n\t}\n\treturn \"???\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 3215
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_cap_trunc",
          "args": [
            "inode",
            "h",
            "session"
          ],
          "line": 3211
        },
        "resolved": true,
        "details": {
          "function_name": "handle_cap_trunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "2812-2840",
          "snippet": "static void handle_cap_trunc(struct inode *inode,\n\t\t\t     struct ceph_mds_caps *trunc,\n\t\t\t     struct ceph_mds_session *session)\n\t__releases(ci->i_ceph_lock)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint mds = session->s_mds;\n\tint seq = le32_to_cpu(trunc->seq);\n\tu32 truncate_seq = le32_to_cpu(trunc->truncate_seq);\n\tu64 truncate_size = le64_to_cpu(trunc->truncate_size);\n\tu64 size = le64_to_cpu(trunc->size);\n\tint implemented = 0;\n\tint dirty = __ceph_caps_dirty(ci);\n\tint issued = __ceph_caps_issued(ceph_inode(inode), &implemented);\n\tint queue_trunc = 0;\n\n\tissued |= implemented | dirty;\n\n\tdout(\"handle_cap_trunc inode %p mds%d seq %d to %lld seq %d\\n\",\n\t     inode, mds, seq, truncate_size, truncate_seq);\n\tqueue_trunc = ceph_fill_file_size(inode, issued,\n\t\t\t\t\t  truncate_seq, truncate_size, size);\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (queue_trunc) {\n\t\tceph_queue_vmtruncate(inode);\n\t\tceph_fscache_invalidate(inode);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void handle_cap_trunc(struct inode *inode,\n\t\t\t     struct ceph_mds_caps *trunc,\n\t\t\t     struct ceph_mds_session *session)\n\t__releases(ci->i_ceph_lock)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint mds = session->s_mds;\n\tint seq = le32_to_cpu(trunc->seq);\n\tu32 truncate_seq = le32_to_cpu(trunc->truncate_seq);\n\tu64 truncate_size = le64_to_cpu(trunc->truncate_size);\n\tu64 size = le64_to_cpu(trunc->size);\n\tint implemented = 0;\n\tint dirty = __ceph_caps_dirty(ci);\n\tint issued = __ceph_caps_issued(ceph_inode(inode), &implemented);\n\tint queue_trunc = 0;\n\n\tissued |= implemented | dirty;\n\n\tdout(\"handle_cap_trunc inode %p mds%d seq %d to %lld seq %d\\n\",\n\t     inode, mds, seq, truncate_size, truncate_seq);\n\tqueue_trunc = ceph_fill_file_size(inode, issued,\n\t\t\t\t\t  truncate_seq, truncate_size, size);\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (queue_trunc) {\n\t\tceph_queue_vmtruncate(inode);\n\t\tceph_fscache_invalidate(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_cap_flush_ack",
          "args": [
            "inode",
            "tid",
            "h",
            "session",
            "cap"
          ],
          "line": 3207
        },
        "resolved": true,
        "details": {
          "function_name": "handle_cap_flush_ack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "2696-2759",
          "snippet": "static void handle_cap_flush_ack(struct inode *inode, u64 flush_tid,\n\t\t\t\t struct ceph_mds_caps *m,\n\t\t\t\t struct ceph_mds_session *session,\n\t\t\t\t struct ceph_cap *cap)\n\t__releases(ci->i_ceph_lock)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;\n\tunsigned seq = le32_to_cpu(m->seq);\n\tint dirty = le32_to_cpu(m->dirty);\n\tint cleaned = 0;\n\tint drop = 0;\n\tint i;\n\n\tfor (i = 0; i < CEPH_CAP_BITS; i++)\n\t\tif ((dirty & (1 << i)) &&\n\t\t    (u16)flush_tid == ci->i_cap_flush_tid[i])\n\t\t\tcleaned |= 1 << i;\n\n\tdout(\"handle_cap_flush_ack inode %p mds%d seq %d on %s cleaned %s,\"\n\t     \" flushing %s -> %s\\n\",\n\t     inode, session->s_mds, seq, ceph_cap_string(dirty),\n\t     ceph_cap_string(cleaned), ceph_cap_string(ci->i_flushing_caps),\n\t     ceph_cap_string(ci->i_flushing_caps & ~cleaned));\n\n\tif (ci->i_flushing_caps == (ci->i_flushing_caps & ~cleaned))\n\t\tgoto out;\n\n\tci->i_flushing_caps &= ~cleaned;\n\n\tspin_lock(&mdsc->cap_dirty_lock);\n\tif (ci->i_flushing_caps == 0) {\n\t\tlist_del_init(&ci->i_flushing_item);\n\t\tif (!list_empty(&session->s_cap_flushing))\n\t\t\tdout(\" mds%d still flushing cap on %p\\n\",\n\t\t\t     session->s_mds,\n\t\t\t     &list_entry(session->s_cap_flushing.next,\n\t\t\t\t\t struct ceph_inode_info,\n\t\t\t\t\t i_flushing_item)->vfs_inode);\n\t\tmdsc->num_cap_flushing--;\n\t\twake_up_all(&mdsc->cap_flushing_wq);\n\t\tdout(\" inode %p now !flushing\\n\", inode);\n\n\t\tif (ci->i_dirty_caps == 0) {\n\t\t\tdout(\" inode %p now clean\\n\", inode);\n\t\t\tBUG_ON(!list_empty(&ci->i_dirty_item));\n\t\t\tdrop = 1;\n\t\t\tif (ci->i_wrbuffer_ref_head == 0) {\n\t\t\t\tBUG_ON(!ci->i_head_snapc);\n\t\t\t\tceph_put_snap_context(ci->i_head_snapc);\n\t\t\t\tci->i_head_snapc = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tBUG_ON(list_empty(&ci->i_dirty_item));\n\t\t}\n\t}\n\tspin_unlock(&mdsc->cap_dirty_lock);\n\twake_up_all(&ci->i_cap_wq);\n\nout:\n\tspin_unlock(&ci->i_ceph_lock);\n\tif (drop)\n\t\tiput(inode);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void handle_cap_flush_ack(struct inode *inode, u64 flush_tid,\n\t\t\t\t struct ceph_mds_caps *m,\n\t\t\t\t struct ceph_mds_session *session,\n\t\t\t\t struct ceph_cap *cap)\n\t__releases(ci->i_ceph_lock)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;\n\tunsigned seq = le32_to_cpu(m->seq);\n\tint dirty = le32_to_cpu(m->dirty);\n\tint cleaned = 0;\n\tint drop = 0;\n\tint i;\n\n\tfor (i = 0; i < CEPH_CAP_BITS; i++)\n\t\tif ((dirty & (1 << i)) &&\n\t\t    (u16)flush_tid == ci->i_cap_flush_tid[i])\n\t\t\tcleaned |= 1 << i;\n\n\tdout(\"handle_cap_flush_ack inode %p mds%d seq %d on %s cleaned %s,\"\n\t     \" flushing %s -> %s\\n\",\n\t     inode, session->s_mds, seq, ceph_cap_string(dirty),\n\t     ceph_cap_string(cleaned), ceph_cap_string(ci->i_flushing_caps),\n\t     ceph_cap_string(ci->i_flushing_caps & ~cleaned));\n\n\tif (ci->i_flushing_caps == (ci->i_flushing_caps & ~cleaned))\n\t\tgoto out;\n\n\tci->i_flushing_caps &= ~cleaned;\n\n\tspin_lock(&mdsc->cap_dirty_lock);\n\tif (ci->i_flushing_caps == 0) {\n\t\tlist_del_init(&ci->i_flushing_item);\n\t\tif (!list_empty(&session->s_cap_flushing))\n\t\t\tdout(\" mds%d still flushing cap on %p\\n\",\n\t\t\t     session->s_mds,\n\t\t\t     &list_entry(session->s_cap_flushing.next,\n\t\t\t\t\t struct ceph_inode_info,\n\t\t\t\t\t i_flushing_item)->vfs_inode);\n\t\tmdsc->num_cap_flushing--;\n\t\twake_up_all(&mdsc->cap_flushing_wq);\n\t\tdout(\" inode %p now !flushing\\n\", inode);\n\n\t\tif (ci->i_dirty_caps == 0) {\n\t\t\tdout(\" inode %p now clean\\n\", inode);\n\t\t\tBUG_ON(!list_empty(&ci->i_dirty_item));\n\t\t\tdrop = 1;\n\t\t\tif (ci->i_wrbuffer_ref_head == 0) {\n\t\t\t\tBUG_ON(!ci->i_head_snapc);\n\t\t\t\tceph_put_snap_context(ci->i_head_snapc);\n\t\t\t\tci->i_head_snapc = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tBUG_ON(list_empty(&ci->i_dirty_item));\n\t\t}\n\t}\n\tspin_unlock(&mdsc->cap_dirty_lock);\n\twake_up_all(&ci->i_cap_wq);\n\nout:\n\tspin_unlock(&ci->i_ceph_lock);\n\tif (drop)\n\t\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_cap_grant",
          "args": [
            "mdsc",
            "inode",
            "h",
            "inline_version",
            "inline_data",
            "inline_len",
            "msg->middle",
            "session",
            "cap",
            "issued"
          ],
          "line": 3201
        },
        "resolved": true,
        "details": {
          "function_name": "handle_cap_grant",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "2445-2690",
          "snippet": "static void handle_cap_grant(struct ceph_mds_client *mdsc,\n\t\t\t     struct inode *inode, struct ceph_mds_caps *grant,\n\t\t\t     u64 inline_version,\n\t\t\t     void *inline_data, int inline_len,\n\t\t\t     struct ceph_buffer *xattr_buf,\n\t\t\t     struct ceph_mds_session *session,\n\t\t\t     struct ceph_cap *cap, int issued)\n\t__releases(ci->i_ceph_lock)\n\t__releases(mdsc->snap_rwsem)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint mds = session->s_mds;\n\tint seq = le32_to_cpu(grant->seq);\n\tint newcaps = le32_to_cpu(grant->caps);\n\tint used, wanted, dirty;\n\tu64 size = le64_to_cpu(grant->size);\n\tu64 max_size = le64_to_cpu(grant->max_size);\n\tstruct timespec mtime, atime, ctime;\n\tint check_caps = 0;\n\tbool wake = false;\n\tbool writeback = false;\n\tbool queue_trunc = false;\n\tbool queue_invalidate = false;\n\tbool queue_revalidate = false;\n\tbool deleted_inode = false;\n\tbool fill_inline = false;\n\n\tdout(\"handle_cap_grant inode %p cap %p mds%d seq %d %s\\n\",\n\t     inode, cap, mds, seq, ceph_cap_string(newcaps));\n\tdout(\" size %llu max_size %llu, i_size %llu\\n\", size, max_size,\n\t\tinode->i_size);\n\n\n\t/*\n\t * auth mds of the inode changed. we received the cap export message,\n\t * but still haven't received the cap import message. handle_cap_export\n\t * updated the new auth MDS' cap.\n\t *\n\t * \"ceph_seq_cmp(seq, cap->seq) <= 0\" means we are processing a message\n\t * that was sent before the cap import message. So don't remove caps.\n\t */\n\tif (ceph_seq_cmp(seq, cap->seq) <= 0) {\n\t\tWARN_ON(cap != ci->i_auth_cap);\n\t\tWARN_ON(cap->cap_id != le64_to_cpu(grant->cap_id));\n\t\tseq = cap->seq;\n\t\tnewcaps |= cap->issued;\n\t}\n\n\t/*\n\t * If CACHE is being revoked, and we have no dirty buffers,\n\t * try to invalidate (once).  (If there are dirty buffers, we\n\t * will invalidate _after_ writeback.)\n\t */\n\tif (((cap->issued & ~newcaps) & CEPH_CAP_FILE_CACHE) &&\n\t    (newcaps & CEPH_CAP_FILE_LAZYIO) == 0 &&\n\t    !ci->i_wrbuffer_ref) {\n\t\tif (try_nonblocking_invalidate(inode)) {\n\t\t\t/* there were locked pages.. invalidate later\n\t\t\t   in a separate thread. */\n\t\t\tif (ci->i_rdcache_revoking != ci->i_rdcache_gen) {\n\t\t\t\tqueue_invalidate = true;\n\t\t\t\tci->i_rdcache_revoking = ci->i_rdcache_gen;\n\t\t\t}\n\t\t}\n\n\t\tceph_fscache_invalidate(inode);\n\t}\n\n\t/* side effects now are allowed */\n\tcap->cap_gen = session->s_cap_gen;\n\tcap->seq = seq;\n\n\t__check_cap_issue(ci, cap, newcaps);\n\n\tif ((newcaps & CEPH_CAP_AUTH_SHARED) &&\n\t    (issued & CEPH_CAP_AUTH_EXCL) == 0) {\n\t\tinode->i_mode = le32_to_cpu(grant->mode);\n\t\tinode->i_uid = make_kuid(&init_user_ns, le32_to_cpu(grant->uid));\n\t\tinode->i_gid = make_kgid(&init_user_ns, le32_to_cpu(grant->gid));\n\t\tdout(\"%p mode 0%o uid.gid %d.%d\\n\", inode, inode->i_mode,\n\t\t     from_kuid(&init_user_ns, inode->i_uid),\n\t\t     from_kgid(&init_user_ns, inode->i_gid));\n\t}\n\n\tif ((newcaps & CEPH_CAP_AUTH_SHARED) &&\n\t    (issued & CEPH_CAP_LINK_EXCL) == 0) {\n\t\tset_nlink(inode, le32_to_cpu(grant->nlink));\n\t\tif (inode->i_nlink == 0 &&\n\t\t    (newcaps & (CEPH_CAP_LINK_SHARED | CEPH_CAP_LINK_EXCL)))\n\t\t\tdeleted_inode = true;\n\t}\n\n\tif ((issued & CEPH_CAP_XATTR_EXCL) == 0 && grant->xattr_len) {\n\t\tint len = le32_to_cpu(grant->xattr_len);\n\t\tu64 version = le64_to_cpu(grant->xattr_version);\n\n\t\tif (version > ci->i_xattrs.version) {\n\t\t\tdout(\" got new xattrs v%llu on %p len %d\\n\",\n\t\t\t     version, inode, len);\n\t\t\tif (ci->i_xattrs.blob)\n\t\t\t\tceph_buffer_put(ci->i_xattrs.blob);\n\t\t\tci->i_xattrs.blob = ceph_buffer_get(xattr_buf);\n\t\t\tci->i_xattrs.version = version;\n\t\t\tceph_forget_all_cached_acls(inode);\n\t\t}\n\t}\n\n\t/* Do we need to revalidate our fscache cookie. Don't bother on the\n\t * first cache cap as we already validate at cookie creation time. */\n\tif ((issued & CEPH_CAP_FILE_CACHE) && ci->i_rdcache_gen > 1)\n\t\tqueue_revalidate = true;\n\n\tif (newcaps & CEPH_CAP_ANY_RD) {\n\t\t/* ctime/mtime/atime? */\n\t\tceph_decode_timespec(&mtime, &grant->mtime);\n\t\tceph_decode_timespec(&atime, &grant->atime);\n\t\tceph_decode_timespec(&ctime, &grant->ctime);\n\t\tceph_fill_file_time(inode, issued,\n\t\t\t\t    le32_to_cpu(grant->time_warp_seq),\n\t\t\t\t    &ctime, &mtime, &atime);\n\t}\n\n\tif (newcaps & (CEPH_CAP_ANY_FILE_RD | CEPH_CAP_ANY_FILE_WR)) {\n\t\t/* file layout may have changed */\n\t\tci->i_layout = grant->layout;\n\t\t/* size/truncate_seq? */\n\t\tqueue_trunc = ceph_fill_file_size(inode, issued,\n\t\t\t\t\tle32_to_cpu(grant->truncate_seq),\n\t\t\t\t\tle64_to_cpu(grant->truncate_size),\n\t\t\t\t\tsize);\n\t\t/* max size increase? */\n\t\tif (ci->i_auth_cap == cap && max_size != ci->i_max_size) {\n\t\t\tdout(\"max_size %lld -> %llu\\n\",\n\t\t\t     ci->i_max_size, max_size);\n\t\t\tci->i_max_size = max_size;\n\t\t\tif (max_size >= ci->i_wanted_max_size) {\n\t\t\t\tci->i_wanted_max_size = 0;  /* reset */\n\t\t\t\tci->i_requested_max_size = 0;\n\t\t\t}\n\t\t\twake = true;\n\t\t}\n\t}\n\n\t/* check cap bits */\n\twanted = __ceph_caps_wanted(ci);\n\tused = __ceph_caps_used(ci);\n\tdirty = __ceph_caps_dirty(ci);\n\tdout(\" my wanted = %s, used = %s, dirty %s\\n\",\n\t     ceph_cap_string(wanted),\n\t     ceph_cap_string(used),\n\t     ceph_cap_string(dirty));\n\tif (wanted != le32_to_cpu(grant->wanted)) {\n\t\tdout(\"mds wanted %s -> %s\\n\",\n\t\t     ceph_cap_string(le32_to_cpu(grant->wanted)),\n\t\t     ceph_cap_string(wanted));\n\t\t/* imported cap may not have correct mds_wanted */\n\t\tif (le32_to_cpu(grant->op) == CEPH_CAP_OP_IMPORT)\n\t\t\tcheck_caps = 1;\n\t}\n\n\t/* revocation, grant, or no-op? */\n\tif (cap->issued & ~newcaps) {\n\t\tint revoking = cap->issued & ~newcaps;\n\n\t\tdout(\"revocation: %s -> %s (revoking %s)\\n\",\n\t\t     ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(newcaps),\n\t\t     ceph_cap_string(revoking));\n\t\tif (revoking & used & CEPH_CAP_FILE_BUFFER)\n\t\t\twriteback = true;  /* initiate writeback; will delay ack */\n\t\telse if (revoking == CEPH_CAP_FILE_CACHE &&\n\t\t\t (newcaps & CEPH_CAP_FILE_LAZYIO) == 0 &&\n\t\t\t queue_invalidate)\n\t\t\t; /* do nothing yet, invalidation will be queued */\n\t\telse if (cap == ci->i_auth_cap)\n\t\t\tcheck_caps = 1; /* check auth cap only */\n\t\telse\n\t\t\tcheck_caps = 2; /* check all caps */\n\t\tcap->issued = newcaps;\n\t\tcap->implemented |= newcaps;\n\t} else if (cap->issued == newcaps) {\n\t\tdout(\"caps unchanged: %s -> %s\\n\",\n\t\t     ceph_cap_string(cap->issued), ceph_cap_string(newcaps));\n\t} else {\n\t\tdout(\"grant: %s -> %s\\n\", ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(newcaps));\n\t\t/* non-auth MDS is revoking the newly grant caps ? */\n\t\tif (cap == ci->i_auth_cap &&\n\t\t    __ceph_caps_revoking_other(ci, cap, newcaps))\n\t\t    check_caps = 2;\n\n\t\tcap->issued = newcaps;\n\t\tcap->implemented |= newcaps; /* add bits only, to\n\t\t\t\t\t      * avoid stepping on a\n\t\t\t\t\t      * pending revocation */\n\t\twake = true;\n\t}\n\tBUG_ON(cap->issued & ~cap->implemented);\n\n\tif (inline_version > 0 && inline_version >= ci->i_inline_version) {\n\t\tci->i_inline_version = inline_version;\n\t\tif (ci->i_inline_version != CEPH_INLINE_NONE &&\n\t\t    (newcaps & (CEPH_CAP_FILE_CACHE|CEPH_CAP_FILE_LAZYIO)))\n\t\t\tfill_inline = true;\n\t}\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (le32_to_cpu(grant->op) == CEPH_CAP_OP_IMPORT) {\n\t\tkick_flushing_inode_caps(mdsc, session, inode);\n\t\tup_read(&mdsc->snap_rwsem);\n\t\tif (newcaps & ~issued)\n\t\t\twake = true;\n\t}\n\n\tif (fill_inline)\n\t\tceph_fill_inline_data(inode, NULL, inline_data, inline_len);\n\n\tif (queue_trunc) {\n\t\tceph_queue_vmtruncate(inode);\n\t\tceph_queue_revalidate(inode);\n\t} else if (queue_revalidate)\n\t\tceph_queue_revalidate(inode);\n\n\tif (writeback)\n\t\t/*\n\t\t * queue inode for writeback: we can't actually call\n\t\t * filemap_write_and_wait, etc. from message handler\n\t\t * context.\n\t\t */\n\t\tceph_queue_writeback(inode);\n\tif (queue_invalidate)\n\t\tceph_queue_invalidate(inode);\n\tif (deleted_inode)\n\t\tinvalidate_aliases(inode);\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\n\tif (check_caps == 1)\n\t\tceph_check_caps(ci, CHECK_CAPS_NODELAY|CHECK_CAPS_AUTHONLY,\n\t\t\t\tsession);\n\telse if (check_caps == 2)\n\t\tceph_check_caps(ci, CHECK_CAPS_NODELAY, session);\n\telse\n\t\tmutex_unlock(&session->s_mutex);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void handle_cap_grant(struct ceph_mds_client *mdsc,\n\t\t\t     struct inode *inode, struct ceph_mds_caps *grant,\n\t\t\t     u64 inline_version,\n\t\t\t     void *inline_data, int inline_len,\n\t\t\t     struct ceph_buffer *xattr_buf,\n\t\t\t     struct ceph_mds_session *session,\n\t\t\t     struct ceph_cap *cap, int issued)\n\t__releases(ci->i_ceph_lock)\n\t__releases(mdsc->snap_rwsem)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint mds = session->s_mds;\n\tint seq = le32_to_cpu(grant->seq);\n\tint newcaps = le32_to_cpu(grant->caps);\n\tint used, wanted, dirty;\n\tu64 size = le64_to_cpu(grant->size);\n\tu64 max_size = le64_to_cpu(grant->max_size);\n\tstruct timespec mtime, atime, ctime;\n\tint check_caps = 0;\n\tbool wake = false;\n\tbool writeback = false;\n\tbool queue_trunc = false;\n\tbool queue_invalidate = false;\n\tbool queue_revalidate = false;\n\tbool deleted_inode = false;\n\tbool fill_inline = false;\n\n\tdout(\"handle_cap_grant inode %p cap %p mds%d seq %d %s\\n\",\n\t     inode, cap, mds, seq, ceph_cap_string(newcaps));\n\tdout(\" size %llu max_size %llu, i_size %llu\\n\", size, max_size,\n\t\tinode->i_size);\n\n\n\t/*\n\t * auth mds of the inode changed. we received the cap export message,\n\t * but still haven't received the cap import message. handle_cap_export\n\t * updated the new auth MDS' cap.\n\t *\n\t * \"ceph_seq_cmp(seq, cap->seq) <= 0\" means we are processing a message\n\t * that was sent before the cap import message. So don't remove caps.\n\t */\n\tif (ceph_seq_cmp(seq, cap->seq) <= 0) {\n\t\tWARN_ON(cap != ci->i_auth_cap);\n\t\tWARN_ON(cap->cap_id != le64_to_cpu(grant->cap_id));\n\t\tseq = cap->seq;\n\t\tnewcaps |= cap->issued;\n\t}\n\n\t/*\n\t * If CACHE is being revoked, and we have no dirty buffers,\n\t * try to invalidate (once).  (If there are dirty buffers, we\n\t * will invalidate _after_ writeback.)\n\t */\n\tif (((cap->issued & ~newcaps) & CEPH_CAP_FILE_CACHE) &&\n\t    (newcaps & CEPH_CAP_FILE_LAZYIO) == 0 &&\n\t    !ci->i_wrbuffer_ref) {\n\t\tif (try_nonblocking_invalidate(inode)) {\n\t\t\t/* there were locked pages.. invalidate later\n\t\t\t   in a separate thread. */\n\t\t\tif (ci->i_rdcache_revoking != ci->i_rdcache_gen) {\n\t\t\t\tqueue_invalidate = true;\n\t\t\t\tci->i_rdcache_revoking = ci->i_rdcache_gen;\n\t\t\t}\n\t\t}\n\n\t\tceph_fscache_invalidate(inode);\n\t}\n\n\t/* side effects now are allowed */\n\tcap->cap_gen = session->s_cap_gen;\n\tcap->seq = seq;\n\n\t__check_cap_issue(ci, cap, newcaps);\n\n\tif ((newcaps & CEPH_CAP_AUTH_SHARED) &&\n\t    (issued & CEPH_CAP_AUTH_EXCL) == 0) {\n\t\tinode->i_mode = le32_to_cpu(grant->mode);\n\t\tinode->i_uid = make_kuid(&init_user_ns, le32_to_cpu(grant->uid));\n\t\tinode->i_gid = make_kgid(&init_user_ns, le32_to_cpu(grant->gid));\n\t\tdout(\"%p mode 0%o uid.gid %d.%d\\n\", inode, inode->i_mode,\n\t\t     from_kuid(&init_user_ns, inode->i_uid),\n\t\t     from_kgid(&init_user_ns, inode->i_gid));\n\t}\n\n\tif ((newcaps & CEPH_CAP_AUTH_SHARED) &&\n\t    (issued & CEPH_CAP_LINK_EXCL) == 0) {\n\t\tset_nlink(inode, le32_to_cpu(grant->nlink));\n\t\tif (inode->i_nlink == 0 &&\n\t\t    (newcaps & (CEPH_CAP_LINK_SHARED | CEPH_CAP_LINK_EXCL)))\n\t\t\tdeleted_inode = true;\n\t}\n\n\tif ((issued & CEPH_CAP_XATTR_EXCL) == 0 && grant->xattr_len) {\n\t\tint len = le32_to_cpu(grant->xattr_len);\n\t\tu64 version = le64_to_cpu(grant->xattr_version);\n\n\t\tif (version > ci->i_xattrs.version) {\n\t\t\tdout(\" got new xattrs v%llu on %p len %d\\n\",\n\t\t\t     version, inode, len);\n\t\t\tif (ci->i_xattrs.blob)\n\t\t\t\tceph_buffer_put(ci->i_xattrs.blob);\n\t\t\tci->i_xattrs.blob = ceph_buffer_get(xattr_buf);\n\t\t\tci->i_xattrs.version = version;\n\t\t\tceph_forget_all_cached_acls(inode);\n\t\t}\n\t}\n\n\t/* Do we need to revalidate our fscache cookie. Don't bother on the\n\t * first cache cap as we already validate at cookie creation time. */\n\tif ((issued & CEPH_CAP_FILE_CACHE) && ci->i_rdcache_gen > 1)\n\t\tqueue_revalidate = true;\n\n\tif (newcaps & CEPH_CAP_ANY_RD) {\n\t\t/* ctime/mtime/atime? */\n\t\tceph_decode_timespec(&mtime, &grant->mtime);\n\t\tceph_decode_timespec(&atime, &grant->atime);\n\t\tceph_decode_timespec(&ctime, &grant->ctime);\n\t\tceph_fill_file_time(inode, issued,\n\t\t\t\t    le32_to_cpu(grant->time_warp_seq),\n\t\t\t\t    &ctime, &mtime, &atime);\n\t}\n\n\tif (newcaps & (CEPH_CAP_ANY_FILE_RD | CEPH_CAP_ANY_FILE_WR)) {\n\t\t/* file layout may have changed */\n\t\tci->i_layout = grant->layout;\n\t\t/* size/truncate_seq? */\n\t\tqueue_trunc = ceph_fill_file_size(inode, issued,\n\t\t\t\t\tle32_to_cpu(grant->truncate_seq),\n\t\t\t\t\tle64_to_cpu(grant->truncate_size),\n\t\t\t\t\tsize);\n\t\t/* max size increase? */\n\t\tif (ci->i_auth_cap == cap && max_size != ci->i_max_size) {\n\t\t\tdout(\"max_size %lld -> %llu\\n\",\n\t\t\t     ci->i_max_size, max_size);\n\t\t\tci->i_max_size = max_size;\n\t\t\tif (max_size >= ci->i_wanted_max_size) {\n\t\t\t\tci->i_wanted_max_size = 0;  /* reset */\n\t\t\t\tci->i_requested_max_size = 0;\n\t\t\t}\n\t\t\twake = true;\n\t\t}\n\t}\n\n\t/* check cap bits */\n\twanted = __ceph_caps_wanted(ci);\n\tused = __ceph_caps_used(ci);\n\tdirty = __ceph_caps_dirty(ci);\n\tdout(\" my wanted = %s, used = %s, dirty %s\\n\",\n\t     ceph_cap_string(wanted),\n\t     ceph_cap_string(used),\n\t     ceph_cap_string(dirty));\n\tif (wanted != le32_to_cpu(grant->wanted)) {\n\t\tdout(\"mds wanted %s -> %s\\n\",\n\t\t     ceph_cap_string(le32_to_cpu(grant->wanted)),\n\t\t     ceph_cap_string(wanted));\n\t\t/* imported cap may not have correct mds_wanted */\n\t\tif (le32_to_cpu(grant->op) == CEPH_CAP_OP_IMPORT)\n\t\t\tcheck_caps = 1;\n\t}\n\n\t/* revocation, grant, or no-op? */\n\tif (cap->issued & ~newcaps) {\n\t\tint revoking = cap->issued & ~newcaps;\n\n\t\tdout(\"revocation: %s -> %s (revoking %s)\\n\",\n\t\t     ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(newcaps),\n\t\t     ceph_cap_string(revoking));\n\t\tif (revoking & used & CEPH_CAP_FILE_BUFFER)\n\t\t\twriteback = true;  /* initiate writeback; will delay ack */\n\t\telse if (revoking == CEPH_CAP_FILE_CACHE &&\n\t\t\t (newcaps & CEPH_CAP_FILE_LAZYIO) == 0 &&\n\t\t\t queue_invalidate)\n\t\t\t; /* do nothing yet, invalidation will be queued */\n\t\telse if (cap == ci->i_auth_cap)\n\t\t\tcheck_caps = 1; /* check auth cap only */\n\t\telse\n\t\t\tcheck_caps = 2; /* check all caps */\n\t\tcap->issued = newcaps;\n\t\tcap->implemented |= newcaps;\n\t} else if (cap->issued == newcaps) {\n\t\tdout(\"caps unchanged: %s -> %s\\n\",\n\t\t     ceph_cap_string(cap->issued), ceph_cap_string(newcaps));\n\t} else {\n\t\tdout(\"grant: %s -> %s\\n\", ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(newcaps));\n\t\t/* non-auth MDS is revoking the newly grant caps ? */\n\t\tif (cap == ci->i_auth_cap &&\n\t\t    __ceph_caps_revoking_other(ci, cap, newcaps))\n\t\t    check_caps = 2;\n\n\t\tcap->issued = newcaps;\n\t\tcap->implemented |= newcaps; /* add bits only, to\n\t\t\t\t\t      * avoid stepping on a\n\t\t\t\t\t      * pending revocation */\n\t\twake = true;\n\t}\n\tBUG_ON(cap->issued & ~cap->implemented);\n\n\tif (inline_version > 0 && inline_version >= ci->i_inline_version) {\n\t\tci->i_inline_version = inline_version;\n\t\tif (ci->i_inline_version != CEPH_INLINE_NONE &&\n\t\t    (newcaps & (CEPH_CAP_FILE_CACHE|CEPH_CAP_FILE_LAZYIO)))\n\t\t\tfill_inline = true;\n\t}\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (le32_to_cpu(grant->op) == CEPH_CAP_OP_IMPORT) {\n\t\tkick_flushing_inode_caps(mdsc, session, inode);\n\t\tup_read(&mdsc->snap_rwsem);\n\t\tif (newcaps & ~issued)\n\t\t\twake = true;\n\t}\n\n\tif (fill_inline)\n\t\tceph_fill_inline_data(inode, NULL, inline_data, inline_len);\n\n\tif (queue_trunc) {\n\t\tceph_queue_vmtruncate(inode);\n\t\tceph_queue_revalidate(inode);\n\t} else if (queue_revalidate)\n\t\tceph_queue_revalidate(inode);\n\n\tif (writeback)\n\t\t/*\n\t\t * queue inode for writeback: we can't actually call\n\t\t * filemap_write_and_wait, etc. from message handler\n\t\t * context.\n\t\t */\n\t\tceph_queue_writeback(inode);\n\tif (queue_invalidate)\n\t\tceph_queue_invalidate(inode);\n\tif (deleted_inode)\n\t\tinvalidate_aliases(inode);\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\n\tif (check_caps == 1)\n\t\tceph_check_caps(ci, CHECK_CAPS_NODELAY|CHECK_CAPS_AUTHONLY,\n\t\t\t\tsession);\n\telse if (check_caps == 2)\n\t\tceph_check_caps(ci, CHECK_CAPS_NODELAY, session);\n\telse\n\t\tmutex_unlock(&session->s_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_caps_dirty",
          "args": [
            "ci"
          ],
          "line": 3200
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_caps_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "550-553",
          "snippet": "static inline int __ceph_caps_dirty(struct ceph_inode_info *ci)\n{\n\treturn ci->i_dirty_caps | ci->i_flushing_caps;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline int __ceph_caps_dirty(struct ceph_inode_info *ci)\n{\n\treturn ci->i_dirty_caps | ci->i_flushing_caps;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_caps_issued",
          "args": [
            "ci",
            "&issued"
          ],
          "line": 3199
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_caps_issued_other",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "700-715",
          "snippet": "int __ceph_caps_issued_other(struct ceph_inode_info *ci, struct ceph_cap *ocap)\n{\n\tint have = ci->i_snap_caps;\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (cap == ocap)\n\t\t\tcontinue;\n\t\tif (!__cap_is_valid(cap))\n\t\t\tcontinue;\n\t\thave |= cap->issued;\n\t}\n\treturn have;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_caps_issued_other(struct ceph_inode_info *ci, struct ceph_cap *ocap)\n{\n\tint have = ci->i_snap_caps;\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (cap == ocap)\n\t\t\tcontinue;\n\t\tif (!__cap_is_valid(cap))\n\t\t\tcontinue;\n\t\thave |= cap->issued;\n\t}\n\treturn have;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" no cap on %p ino %llx.%llx from mds%d\\n\"",
            "inode",
            "ceph_ino(inode)",
            "ceph_snap(inode)",
            "mds"
          ],
          "line": 3189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_snap",
          "args": [
            "inode"
          ],
          "line": 3190
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_snap_op_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/strings.c",
          "lines": "115-124",
          "snippet": "const char *ceph_snap_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_SNAP_OP_UPDATE: return \"update\";\n\tcase CEPH_SNAP_OP_CREATE: return \"create\";\n\tcase CEPH_SNAP_OP_DESTROY: return \"destroy\";\n\tcase CEPH_SNAP_OP_SPLIT: return \"split\";\n\t}\n\treturn \"???\";\n}",
          "includes": [
            "#include <linux/ceph/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/types.h>\n#include <linux/module.h>\n\nconst char *ceph_snap_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_SNAP_OP_UPDATE: return \"update\";\n\tcase CEPH_SNAP_OP_CREATE: return \"create\";\n\tcase CEPH_SNAP_OP_DESTROY: return \"destroy\";\n\tcase CEPH_SNAP_OP_SPLIT: return \"split\";\n\t}\n\treturn \"???\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_ino",
          "args": [
            "inode"
          ],
          "line": 3190
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "412-415",
          "snippet": "static inline u64 ceph_ino(struct inode *inode)\n{\n\treturn ceph_inode(inode)->i_vino.ino;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline u64 ceph_ino(struct inode *inode)\n{\n\treturn ceph_inode(inode)->i_vino.ino;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_cap_for_mds",
          "args": [
            "ceph_inode(inode)",
            "mds"
          ],
          "line": 3187
        },
        "resolved": true,
        "details": {
          "function_name": "__get_cap_for_mds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "310-325",
          "snippet": "static struct ceph_cap *__get_cap_for_mds(struct ceph_inode_info *ci, int mds)\n{\n\tstruct ceph_cap *cap;\n\tstruct rb_node *n = ci->i_caps.rb_node;\n\n\twhile (n) {\n\t\tcap = rb_entry(n, struct ceph_cap, ci_node);\n\t\tif (mds < cap->mds)\n\t\t\tn = n->rb_left;\n\t\telse if (mds > cap->mds)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn cap;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_cap *__get_cap_for_mds(struct ceph_inode_info *ci, int mds)\n{\n\tstruct ceph_cap *cap;\n\tstruct rb_node *n = ci->i_caps.rb_node;\n\n\twhile (n) {\n\t\tcap = rb_entry(n, struct ceph_cap, ci_node);\n\t\tif (mds < cap->mds)\n\t\t\tn = n->rb_left;\n\t\telse if (mds > cap->mds)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn cap;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 3187
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 3186
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_put_snap_realm",
          "args": [
            "mdsc",
            "realm"
          ],
          "line": 3181
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_put_snap_realm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
          "lines": "204-220",
          "snippet": "void ceph_put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t struct ceph_snap_realm *realm)\n{\n\tdout(\"put_snap_realm %llx %p %d -> %d\\n\", realm->ino, realm,\n\t     atomic_read(&realm->nref), atomic_read(&realm->nref)-1);\n\tif (!atomic_dec_and_test(&realm->nref))\n\t\treturn;\n\n\tif (down_write_trylock(&mdsc->snap_rwsem)) {\n\t\t__destroy_snap_realm(mdsc, realm);\n\t\tup_write(&mdsc->snap_rwsem);\n\t} else {\n\t\tspin_lock(&mdsc->snap_empty_lock);\n\t\tlist_add(&realm->empty_item, &mdsc->snap_empty);\n\t\tspin_unlock(&mdsc->snap_empty_lock);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);\n\nvoid ceph_put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t struct ceph_snap_realm *realm)\n{\n\tdout(\"put_snap_realm %llx %p %d -> %d\\n\", realm->ino, realm,\n\t     atomic_read(&realm->nref), atomic_read(&realm->nref)-1);\n\tif (!atomic_dec_and_test(&realm->nref))\n\t\treturn;\n\n\tif (down_write_trylock(&mdsc->snap_rwsem)) {\n\t\t__destroy_snap_realm(mdsc, realm);\n\t\tup_write(&mdsc->snap_rwsem);\n\t} else {\n\t\tspin_lock(&mdsc->snap_empty_lock);\n\t\tlist_add(&realm->empty_item, &mdsc->snap_empty);\n\t\tspin_unlock(&mdsc->snap_empty_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_cap_import",
          "args": [
            "mdsc",
            "inode",
            "h",
            "peer",
            "session",
            "&cap",
            "&issued"
          ],
          "line": 3175
        },
        "resolved": true,
        "details": {
          "function_name": "handle_cap_import",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "2968-3045",
          "snippet": "static void handle_cap_import(struct ceph_mds_client *mdsc,\n\t\t\t      struct inode *inode, struct ceph_mds_caps *im,\n\t\t\t      struct ceph_mds_cap_peer *ph,\n\t\t\t      struct ceph_mds_session *session,\n\t\t\t      struct ceph_cap **target_cap, int *old_issued)\n\t__acquires(ci->i_ceph_lock)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_cap *cap, *ocap, *new_cap = NULL;\n\tint mds = session->s_mds;\n\tint issued;\n\tunsigned caps = le32_to_cpu(im->caps);\n\tunsigned wanted = le32_to_cpu(im->wanted);\n\tunsigned seq = le32_to_cpu(im->seq);\n\tunsigned mseq = le32_to_cpu(im->migrate_seq);\n\tu64 realmino = le64_to_cpu(im->realm);\n\tu64 cap_id = le64_to_cpu(im->cap_id);\n\tu64 p_cap_id;\n\tint peer;\n\n\tif (ph) {\n\t\tp_cap_id = le64_to_cpu(ph->cap_id);\n\t\tpeer = le32_to_cpu(ph->mds);\n\t} else {\n\t\tp_cap_id = 0;\n\t\tpeer = -1;\n\t}\n\n\tdout(\"handle_cap_import inode %p ci %p mds%d mseq %d peer %d\\n\",\n\t     inode, ci, mds, mseq, peer);\n\nretry:\n\tspin_lock(&ci->i_ceph_lock);\n\tcap = __get_cap_for_mds(ci, mds);\n\tif (!cap) {\n\t\tif (!new_cap) {\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\tnew_cap = ceph_get_cap(mdsc, NULL);\n\t\t\tgoto retry;\n\t\t}\n\t\tcap = new_cap;\n\t} else {\n\t\tif (new_cap) {\n\t\t\tceph_put_cap(mdsc, new_cap);\n\t\t\tnew_cap = NULL;\n\t\t}\n\t}\n\n\t__ceph_caps_issued(ci, &issued);\n\tissued |= __ceph_caps_dirty(ci);\n\n\tceph_add_cap(inode, session, cap_id, -1, caps, wanted, seq, mseq,\n\t\t     realmino, CEPH_CAP_FLAG_AUTH, &new_cap);\n\n\tocap = peer >= 0 ? __get_cap_for_mds(ci, peer) : NULL;\n\tif (ocap && ocap->cap_id == p_cap_id) {\n\t\tdout(\" remove export cap %p mds%d flags %d\\n\",\n\t\t     ocap, peer, ph->flags);\n\t\tif ((ph->flags & CEPH_CAP_FLAG_AUTH) &&\n\t\t    (ocap->seq != le32_to_cpu(ph->seq) ||\n\t\t     ocap->mseq != le32_to_cpu(ph->mseq))) {\n\t\t\tpr_err(\"handle_cap_import: mismatched seq/mseq: \"\n\t\t\t       \"ino (%llx.%llx) mds%d seq %d mseq %d \"\n\t\t\t       \"importer mds%d has peer seq %d mseq %d\\n\",\n\t\t\t       ceph_vinop(inode), peer, ocap->seq,\n\t\t\t       ocap->mseq, mds, le32_to_cpu(ph->seq),\n\t\t\t       le32_to_cpu(ph->mseq));\n\t\t}\n\t\t__ceph_remove_cap(ocap, (ph->flags & CEPH_CAP_FLAG_RELEASE));\n\t}\n\n\t/* make sure we re-request max_size, if necessary */\n\tci->i_wanted_max_size = 0;\n\tci->i_requested_max_size = 0;\n\n\t*old_issued = issued;\n\t*target_cap = cap;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void handle_cap_import(struct ceph_mds_client *mdsc,\n\t\t\t      struct inode *inode, struct ceph_mds_caps *im,\n\t\t\t      struct ceph_mds_cap_peer *ph,\n\t\t\t      struct ceph_mds_session *session,\n\t\t\t      struct ceph_cap **target_cap, int *old_issued)\n\t__acquires(ci->i_ceph_lock)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_cap *cap, *ocap, *new_cap = NULL;\n\tint mds = session->s_mds;\n\tint issued;\n\tunsigned caps = le32_to_cpu(im->caps);\n\tunsigned wanted = le32_to_cpu(im->wanted);\n\tunsigned seq = le32_to_cpu(im->seq);\n\tunsigned mseq = le32_to_cpu(im->migrate_seq);\n\tu64 realmino = le64_to_cpu(im->realm);\n\tu64 cap_id = le64_to_cpu(im->cap_id);\n\tu64 p_cap_id;\n\tint peer;\n\n\tif (ph) {\n\t\tp_cap_id = le64_to_cpu(ph->cap_id);\n\t\tpeer = le32_to_cpu(ph->mds);\n\t} else {\n\t\tp_cap_id = 0;\n\t\tpeer = -1;\n\t}\n\n\tdout(\"handle_cap_import inode %p ci %p mds%d mseq %d peer %d\\n\",\n\t     inode, ci, mds, mseq, peer);\n\nretry:\n\tspin_lock(&ci->i_ceph_lock);\n\tcap = __get_cap_for_mds(ci, mds);\n\tif (!cap) {\n\t\tif (!new_cap) {\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\tnew_cap = ceph_get_cap(mdsc, NULL);\n\t\t\tgoto retry;\n\t\t}\n\t\tcap = new_cap;\n\t} else {\n\t\tif (new_cap) {\n\t\t\tceph_put_cap(mdsc, new_cap);\n\t\t\tnew_cap = NULL;\n\t\t}\n\t}\n\n\t__ceph_caps_issued(ci, &issued);\n\tissued |= __ceph_caps_dirty(ci);\n\n\tceph_add_cap(inode, session, cap_id, -1, caps, wanted, seq, mseq,\n\t\t     realmino, CEPH_CAP_FLAG_AUTH, &new_cap);\n\n\tocap = peer >= 0 ? __get_cap_for_mds(ci, peer) : NULL;\n\tif (ocap && ocap->cap_id == p_cap_id) {\n\t\tdout(\" remove export cap %p mds%d flags %d\\n\",\n\t\t     ocap, peer, ph->flags);\n\t\tif ((ph->flags & CEPH_CAP_FLAG_AUTH) &&\n\t\t    (ocap->seq != le32_to_cpu(ph->seq) ||\n\t\t     ocap->mseq != le32_to_cpu(ph->mseq))) {\n\t\t\tpr_err(\"handle_cap_import: mismatched seq/mseq: \"\n\t\t\t       \"ino (%llx.%llx) mds%d seq %d mseq %d \"\n\t\t\t       \"importer mds%d has peer seq %d mseq %d\\n\",\n\t\t\t       ceph_vinop(inode), peer, ocap->seq,\n\t\t\t       ocap->mseq, mds, le32_to_cpu(ph->seq),\n\t\t\t       le32_to_cpu(ph->mseq));\n\t\t}\n\t\t__ceph_remove_cap(ocap, (ph->flags & CEPH_CAP_FLAG_RELEASE));\n\t}\n\n\t/* make sure we re-request max_size, if necessary */\n\tci->i_wanted_max_size = 0;\n\tci->i_requested_max_size = 0;\n\n\t*old_issued = issued;\n\t*target_cap = cap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&mdsc->snap_rwsem"
          ],
          "line": 3173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "downgrade_write",
          "args": [
            "&mdsc->snap_rwsem"
          ],
          "line": 3171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_update_snap_trace",
          "args": [
            "mdsc",
            "snaptrace",
            "snaptrace + snaptrace_len",
            "false",
            "&realm"
          ],
          "line": 3168
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_update_snap_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
          "lines": "640-755",
          "snippet": "int ceph_update_snap_trace(struct ceph_mds_client *mdsc,\n\t\t\t   void *p, void *e, bool deletion,\n\t\t\t   struct ceph_snap_realm **realm_ret)\n{\n\tstruct ceph_mds_snap_realm *ri;    /* encoded */\n\t__le64 *snaps;                     /* encoded */\n\t__le64 *prior_parent_snaps;        /* encoded */\n\tstruct ceph_snap_realm *realm = NULL;\n\tstruct ceph_snap_realm *first_realm = NULL;\n\tint invalidate = 0;\n\tint err = -ENOMEM;\n\tLIST_HEAD(dirty_realms);\n\n\tdout(\"update_snap_trace deletion=%d\\n\", deletion);\nmore:\n\tceph_decode_need(&p, e, sizeof(*ri), bad);\n\tri = p;\n\tp += sizeof(*ri);\n\tceph_decode_need(&p, e, sizeof(u64)*(le32_to_cpu(ri->num_snaps) +\n\t\t\t    le32_to_cpu(ri->num_prior_parent_snaps)), bad);\n\tsnaps = p;\n\tp += sizeof(u64) * le32_to_cpu(ri->num_snaps);\n\tprior_parent_snaps = p;\n\tp += sizeof(u64) * le32_to_cpu(ri->num_prior_parent_snaps);\n\n\trealm = ceph_lookup_snap_realm(mdsc, le64_to_cpu(ri->ino));\n\tif (!realm) {\n\t\trealm = ceph_create_snap_realm(mdsc, le64_to_cpu(ri->ino));\n\t\tif (IS_ERR(realm)) {\n\t\t\terr = PTR_ERR(realm);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t/* ensure the parent is correct */\n\terr = adjust_snap_realm_parent(mdsc, realm, le64_to_cpu(ri->parent));\n\tif (err < 0)\n\t\tgoto fail;\n\tinvalidate += err;\n\n\tif (le64_to_cpu(ri->seq) > realm->seq) {\n\t\tdout(\"update_snap_trace updating %llx %p %lld -> %lld\\n\",\n\t\t     realm->ino, realm, realm->seq, le64_to_cpu(ri->seq));\n\t\t/* update realm parameters, snap lists */\n\t\trealm->seq = le64_to_cpu(ri->seq);\n\t\trealm->created = le64_to_cpu(ri->created);\n\t\trealm->parent_since = le64_to_cpu(ri->parent_since);\n\n\t\trealm->num_snaps = le32_to_cpu(ri->num_snaps);\n\t\terr = dup_array(&realm->snaps, snaps, realm->num_snaps);\n\t\tif (err < 0)\n\t\t\tgoto fail;\n\n\t\trealm->num_prior_parent_snaps =\n\t\t\tle32_to_cpu(ri->num_prior_parent_snaps);\n\t\terr = dup_array(&realm->prior_parent_snaps, prior_parent_snaps,\n\t\t\t\trealm->num_prior_parent_snaps);\n\t\tif (err < 0)\n\t\t\tgoto fail;\n\n\t\t/* queue realm for cap_snap creation */\n\t\tlist_add(&realm->dirty_item, &dirty_realms);\n\n\t\tinvalidate = 1;\n\t} else if (!realm->cached_context) {\n\t\tdout(\"update_snap_trace %llx %p seq %lld new\\n\",\n\t\t     realm->ino, realm, realm->seq);\n\t\tinvalidate = 1;\n\t} else {\n\t\tdout(\"update_snap_trace %llx %p seq %lld unchanged\\n\",\n\t\t     realm->ino, realm, realm->seq);\n\t}\n\n\tdout(\"done with %llx %p, invalidated=%d, %p %p\\n\", realm->ino,\n\t     realm, invalidate, p, e);\n\n\t/* invalidate when we reach the _end_ (root) of the trace */\n\tif (invalidate && p >= e)\n\t\trebuild_snap_realms(realm);\n\n\tif (!first_realm)\n\t\tfirst_realm = realm;\n\telse\n\t\tceph_put_snap_realm(mdsc, realm);\n\n\tif (p < e)\n\t\tgoto more;\n\n\t/*\n\t * queue cap snaps _after_ we've built the new snap contexts,\n\t * so that i_head_snapc can be set appropriately.\n\t */\n\twhile (!list_empty(&dirty_realms)) {\n\t\trealm = list_first_entry(&dirty_realms, struct ceph_snap_realm,\n\t\t\t\t\t dirty_item);\n\t\tqueue_realm_cap_snaps(realm);\n\t}\n\n\tif (realm_ret)\n\t\t*realm_ret = first_realm;\n\telse\n\t\tceph_put_snap_realm(mdsc, first_realm);\n\n\t__cleanup_empty_realms(mdsc);\n\treturn 0;\n\nbad:\n\terr = -EINVAL;\nfail:\n\tif (realm && !IS_ERR(realm))\n\t\tceph_put_snap_realm(mdsc, realm);\n\tif (first_realm)\n\t\tceph_put_snap_realm(mdsc, first_realm);\n\tpr_err(\"update_snap_trace error %d\\n\", err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);\n\nint ceph_update_snap_trace(struct ceph_mds_client *mdsc,\n\t\t\t   void *p, void *e, bool deletion,\n\t\t\t   struct ceph_snap_realm **realm_ret)\n{\n\tstruct ceph_mds_snap_realm *ri;    /* encoded */\n\t__le64 *snaps;                     /* encoded */\n\t__le64 *prior_parent_snaps;        /* encoded */\n\tstruct ceph_snap_realm *realm = NULL;\n\tstruct ceph_snap_realm *first_realm = NULL;\n\tint invalidate = 0;\n\tint err = -ENOMEM;\n\tLIST_HEAD(dirty_realms);\n\n\tdout(\"update_snap_trace deletion=%d\\n\", deletion);\nmore:\n\tceph_decode_need(&p, e, sizeof(*ri), bad);\n\tri = p;\n\tp += sizeof(*ri);\n\tceph_decode_need(&p, e, sizeof(u64)*(le32_to_cpu(ri->num_snaps) +\n\t\t\t    le32_to_cpu(ri->num_prior_parent_snaps)), bad);\n\tsnaps = p;\n\tp += sizeof(u64) * le32_to_cpu(ri->num_snaps);\n\tprior_parent_snaps = p;\n\tp += sizeof(u64) * le32_to_cpu(ri->num_prior_parent_snaps);\n\n\trealm = ceph_lookup_snap_realm(mdsc, le64_to_cpu(ri->ino));\n\tif (!realm) {\n\t\trealm = ceph_create_snap_realm(mdsc, le64_to_cpu(ri->ino));\n\t\tif (IS_ERR(realm)) {\n\t\t\terr = PTR_ERR(realm);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t/* ensure the parent is correct */\n\terr = adjust_snap_realm_parent(mdsc, realm, le64_to_cpu(ri->parent));\n\tif (err < 0)\n\t\tgoto fail;\n\tinvalidate += err;\n\n\tif (le64_to_cpu(ri->seq) > realm->seq) {\n\t\tdout(\"update_snap_trace updating %llx %p %lld -> %lld\\n\",\n\t\t     realm->ino, realm, realm->seq, le64_to_cpu(ri->seq));\n\t\t/* update realm parameters, snap lists */\n\t\trealm->seq = le64_to_cpu(ri->seq);\n\t\trealm->created = le64_to_cpu(ri->created);\n\t\trealm->parent_since = le64_to_cpu(ri->parent_since);\n\n\t\trealm->num_snaps = le32_to_cpu(ri->num_snaps);\n\t\terr = dup_array(&realm->snaps, snaps, realm->num_snaps);\n\t\tif (err < 0)\n\t\t\tgoto fail;\n\n\t\trealm->num_prior_parent_snaps =\n\t\t\tle32_to_cpu(ri->num_prior_parent_snaps);\n\t\terr = dup_array(&realm->prior_parent_snaps, prior_parent_snaps,\n\t\t\t\trealm->num_prior_parent_snaps);\n\t\tif (err < 0)\n\t\t\tgoto fail;\n\n\t\t/* queue realm for cap_snap creation */\n\t\tlist_add(&realm->dirty_item, &dirty_realms);\n\n\t\tinvalidate = 1;\n\t} else if (!realm->cached_context) {\n\t\tdout(\"update_snap_trace %llx %p seq %lld new\\n\",\n\t\t     realm->ino, realm, realm->seq);\n\t\tinvalidate = 1;\n\t} else {\n\t\tdout(\"update_snap_trace %llx %p seq %lld unchanged\\n\",\n\t\t     realm->ino, realm, realm->seq);\n\t}\n\n\tdout(\"done with %llx %p, invalidated=%d, %p %p\\n\", realm->ino,\n\t     realm, invalidate, p, e);\n\n\t/* invalidate when we reach the _end_ (root) of the trace */\n\tif (invalidate && p >= e)\n\t\trebuild_snap_realms(realm);\n\n\tif (!first_realm)\n\t\tfirst_realm = realm;\n\telse\n\t\tceph_put_snap_realm(mdsc, realm);\n\n\tif (p < e)\n\t\tgoto more;\n\n\t/*\n\t * queue cap snaps _after_ we've built the new snap contexts,\n\t * so that i_head_snapc can be set appropriately.\n\t */\n\twhile (!list_empty(&dirty_realms)) {\n\t\trealm = list_first_entry(&dirty_realms, struct ceph_snap_realm,\n\t\t\t\t\t dirty_item);\n\t\tqueue_realm_cap_snaps(realm);\n\t}\n\n\tif (realm_ret)\n\t\t*realm_ret = first_realm;\n\telse\n\t\tceph_put_snap_realm(mdsc, first_realm);\n\n\t__cleanup_empty_realms(mdsc);\n\treturn 0;\n\nbad:\n\terr = -EINVAL;\nfail:\n\tif (realm && !IS_ERR(realm))\n\t\tceph_put_snap_realm(mdsc, realm);\n\tif (first_realm)\n\t\tceph_put_snap_realm(mdsc, first_realm);\n\tpr_err(\"update_snap_trace error %d\\n\", err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&mdsc->snap_rwsem"
          ],
          "line": 3167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_cap_export",
          "args": [
            "inode",
            "h",
            "peer",
            "session"
          ],
          "line": 3161
        },
        "resolved": true,
        "details": {
          "function_name": "handle_cap_export",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "2850-2961",
          "snippet": "static void handle_cap_export(struct inode *inode, struct ceph_mds_caps *ex,\n\t\t\t      struct ceph_mds_cap_peer *ph,\n\t\t\t      struct ceph_mds_session *session)\n{\n\tstruct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;\n\tstruct ceph_mds_session *tsession = NULL;\n\tstruct ceph_cap *cap, *tcap, *new_cap = NULL;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tu64 t_cap_id;\n\tunsigned mseq = le32_to_cpu(ex->migrate_seq);\n\tunsigned t_seq, t_mseq;\n\tint target, issued;\n\tint mds = session->s_mds;\n\n\tif (ph) {\n\t\tt_cap_id = le64_to_cpu(ph->cap_id);\n\t\tt_seq = le32_to_cpu(ph->seq);\n\t\tt_mseq = le32_to_cpu(ph->mseq);\n\t\ttarget = le32_to_cpu(ph->mds);\n\t} else {\n\t\tt_cap_id = t_seq = t_mseq = 0;\n\t\ttarget = -1;\n\t}\n\n\tdout(\"handle_cap_export inode %p ci %p mds%d mseq %d target %d\\n\",\n\t     inode, ci, mds, mseq, target);\nretry:\n\tspin_lock(&ci->i_ceph_lock);\n\tcap = __get_cap_for_mds(ci, mds);\n\tif (!cap || cap->cap_id != le64_to_cpu(ex->cap_id))\n\t\tgoto out_unlock;\n\n\tif (target < 0) {\n\t\t__ceph_remove_cap(cap, false);\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * now we know we haven't received the cap import message yet\n\t * because the exported cap still exist.\n\t */\n\n\tissued = cap->issued;\n\tWARN_ON(issued != cap->implemented);\n\n\ttcap = __get_cap_for_mds(ci, target);\n\tif (tcap) {\n\t\t/* already have caps from the target */\n\t\tif (tcap->cap_id != t_cap_id ||\n\t\t    ceph_seq_cmp(tcap->seq, t_seq) < 0) {\n\t\t\tdout(\" updating import cap %p mds%d\\n\", tcap, target);\n\t\t\ttcap->cap_id = t_cap_id;\n\t\t\ttcap->seq = t_seq - 1;\n\t\t\ttcap->issue_seq = t_seq - 1;\n\t\t\ttcap->mseq = t_mseq;\n\t\t\ttcap->issued |= issued;\n\t\t\ttcap->implemented |= issued;\n\t\t\tif (cap == ci->i_auth_cap)\n\t\t\t\tci->i_auth_cap = tcap;\n\t\t\tif (ci->i_flushing_caps && ci->i_auth_cap == tcap) {\n\t\t\t\tspin_lock(&mdsc->cap_dirty_lock);\n\t\t\t\tlist_move_tail(&ci->i_flushing_item,\n\t\t\t\t\t       &tcap->session->s_cap_flushing);\n\t\t\t\tspin_unlock(&mdsc->cap_dirty_lock);\n\t\t\t}\n\t\t}\n\t\t__ceph_remove_cap(cap, false);\n\t\tgoto out_unlock;\n\t} else if (tsession) {\n\t\t/* add placeholder for the export tagert */\n\t\tint flag = (cap == ci->i_auth_cap) ? CEPH_CAP_FLAG_AUTH : 0;\n\t\tceph_add_cap(inode, tsession, t_cap_id, -1, issued, 0,\n\t\t\t     t_seq - 1, t_mseq, (u64)-1, flag, &new_cap);\n\n\t\t__ceph_remove_cap(cap, false);\n\t\tgoto out_unlock;\n\t}\n\n\tspin_unlock(&ci->i_ceph_lock);\n\tmutex_unlock(&session->s_mutex);\n\n\t/* open target session */\n\ttsession = ceph_mdsc_open_export_target_session(mdsc, target);\n\tif (!IS_ERR(tsession)) {\n\t\tif (mds > target) {\n\t\t\tmutex_lock(&session->s_mutex);\n\t\t\tmutex_lock_nested(&tsession->s_mutex,\n\t\t\t\t\t  SINGLE_DEPTH_NESTING);\n\t\t} else {\n\t\t\tmutex_lock(&tsession->s_mutex);\n\t\t\tmutex_lock_nested(&session->s_mutex,\n\t\t\t\t\t  SINGLE_DEPTH_NESTING);\n\t\t}\n\t\tceph_add_cap_releases(mdsc, tsession);\n\t\tnew_cap = ceph_get_cap(mdsc, NULL);\n\t} else {\n\t\tWARN_ON(1);\n\t\ttsession = NULL;\n\t\ttarget = -1;\n\t}\n\tgoto retry;\n\nout_unlock:\n\tspin_unlock(&ci->i_ceph_lock);\n\tmutex_unlock(&session->s_mutex);\n\tif (tsession) {\n\t\tmutex_unlock(&tsession->s_mutex);\n\t\tceph_put_mds_session(tsession);\n\t}\n\tif (new_cap)\n\t\tceph_put_cap(mdsc, new_cap);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void handle_cap_export(struct inode *inode, struct ceph_mds_caps *ex,\n\t\t\t      struct ceph_mds_cap_peer *ph,\n\t\t\t      struct ceph_mds_session *session)\n{\n\tstruct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;\n\tstruct ceph_mds_session *tsession = NULL;\n\tstruct ceph_cap *cap, *tcap, *new_cap = NULL;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tu64 t_cap_id;\n\tunsigned mseq = le32_to_cpu(ex->migrate_seq);\n\tunsigned t_seq, t_mseq;\n\tint target, issued;\n\tint mds = session->s_mds;\n\n\tif (ph) {\n\t\tt_cap_id = le64_to_cpu(ph->cap_id);\n\t\tt_seq = le32_to_cpu(ph->seq);\n\t\tt_mseq = le32_to_cpu(ph->mseq);\n\t\ttarget = le32_to_cpu(ph->mds);\n\t} else {\n\t\tt_cap_id = t_seq = t_mseq = 0;\n\t\ttarget = -1;\n\t}\n\n\tdout(\"handle_cap_export inode %p ci %p mds%d mseq %d target %d\\n\",\n\t     inode, ci, mds, mseq, target);\nretry:\n\tspin_lock(&ci->i_ceph_lock);\n\tcap = __get_cap_for_mds(ci, mds);\n\tif (!cap || cap->cap_id != le64_to_cpu(ex->cap_id))\n\t\tgoto out_unlock;\n\n\tif (target < 0) {\n\t\t__ceph_remove_cap(cap, false);\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * now we know we haven't received the cap import message yet\n\t * because the exported cap still exist.\n\t */\n\n\tissued = cap->issued;\n\tWARN_ON(issued != cap->implemented);\n\n\ttcap = __get_cap_for_mds(ci, target);\n\tif (tcap) {\n\t\t/* already have caps from the target */\n\t\tif (tcap->cap_id != t_cap_id ||\n\t\t    ceph_seq_cmp(tcap->seq, t_seq) < 0) {\n\t\t\tdout(\" updating import cap %p mds%d\\n\", tcap, target);\n\t\t\ttcap->cap_id = t_cap_id;\n\t\t\ttcap->seq = t_seq - 1;\n\t\t\ttcap->issue_seq = t_seq - 1;\n\t\t\ttcap->mseq = t_mseq;\n\t\t\ttcap->issued |= issued;\n\t\t\ttcap->implemented |= issued;\n\t\t\tif (cap == ci->i_auth_cap)\n\t\t\t\tci->i_auth_cap = tcap;\n\t\t\tif (ci->i_flushing_caps && ci->i_auth_cap == tcap) {\n\t\t\t\tspin_lock(&mdsc->cap_dirty_lock);\n\t\t\t\tlist_move_tail(&ci->i_flushing_item,\n\t\t\t\t\t       &tcap->session->s_cap_flushing);\n\t\t\t\tspin_unlock(&mdsc->cap_dirty_lock);\n\t\t\t}\n\t\t}\n\t\t__ceph_remove_cap(cap, false);\n\t\tgoto out_unlock;\n\t} else if (tsession) {\n\t\t/* add placeholder for the export tagert */\n\t\tint flag = (cap == ci->i_auth_cap) ? CEPH_CAP_FLAG_AUTH : 0;\n\t\tceph_add_cap(inode, tsession, t_cap_id, -1, issued, 0,\n\t\t\t     t_seq - 1, t_mseq, (u64)-1, flag, &new_cap);\n\n\t\t__ceph_remove_cap(cap, false);\n\t\tgoto out_unlock;\n\t}\n\n\tspin_unlock(&ci->i_ceph_lock);\n\tmutex_unlock(&session->s_mutex);\n\n\t/* open target session */\n\ttsession = ceph_mdsc_open_export_target_session(mdsc, target);\n\tif (!IS_ERR(tsession)) {\n\t\tif (mds > target) {\n\t\t\tmutex_lock(&session->s_mutex);\n\t\t\tmutex_lock_nested(&tsession->s_mutex,\n\t\t\t\t\t  SINGLE_DEPTH_NESTING);\n\t\t} else {\n\t\t\tmutex_lock(&tsession->s_mutex);\n\t\t\tmutex_lock_nested(&session->s_mutex,\n\t\t\t\t\t  SINGLE_DEPTH_NESTING);\n\t\t}\n\t\tceph_add_cap_releases(mdsc, tsession);\n\t\tnew_cap = ceph_get_cap(mdsc, NULL);\n\t} else {\n\t\tWARN_ON(1);\n\t\ttsession = NULL;\n\t\ttarget = -1;\n\t}\n\tgoto retry;\n\nout_unlock:\n\tspin_unlock(&ci->i_ceph_lock);\n\tmutex_unlock(&session->s_mutex);\n\tif (tsession) {\n\t\tmutex_unlock(&tsession->s_mutex);\n\t\tceph_put_mds_session(tsession);\n\t}\n\tif (new_cap)\n\t\tceph_put_cap(mdsc, new_cap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_cap_flushsnap_ack",
          "args": [
            "inode",
            "tid",
            "h",
            "session"
          ],
          "line": 3157
        },
        "resolved": true,
        "details": {
          "function_name": "handle_cap_flushsnap_ack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "2767-2805",
          "snippet": "static void handle_cap_flushsnap_ack(struct inode *inode, u64 flush_tid,\n\t\t\t\t     struct ceph_mds_caps *m,\n\t\t\t\t     struct ceph_mds_session *session)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tu64 follows = le64_to_cpu(m->snap_follows);\n\tstruct ceph_cap_snap *capsnap;\n\tint drop = 0;\n\n\tdout(\"handle_cap_flushsnap_ack inode %p ci %p mds%d follows %lld\\n\",\n\t     inode, ci, session->s_mds, follows);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tlist_for_each_entry(capsnap, &ci->i_cap_snaps, ci_item) {\n\t\tif (capsnap->follows == follows) {\n\t\t\tif (capsnap->flush_tid != flush_tid) {\n\t\t\t\tdout(\" cap_snap %p follows %lld tid %lld !=\"\n\t\t\t\t     \" %lld\\n\", capsnap, follows,\n\t\t\t\t     flush_tid, capsnap->flush_tid);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tWARN_ON(capsnap->dirty_pages || capsnap->writing);\n\t\t\tdout(\" removing %p cap_snap %p follows %lld\\n\",\n\t\t\t     inode, capsnap, follows);\n\t\t\tceph_put_snap_context(capsnap->context);\n\t\t\tlist_del(&capsnap->ci_item);\n\t\t\tlist_del(&capsnap->flushing_item);\n\t\t\tceph_put_cap_snap(capsnap);\n\t\t\tdrop = 1;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tdout(\" skipping cap_snap %p follows %lld\\n\",\n\t\t\t     capsnap, capsnap->follows);\n\t\t}\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\tif (drop)\n\t\tiput(inode);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void handle_cap_flushsnap_ack(struct inode *inode, u64 flush_tid,\n\t\t\t\t     struct ceph_mds_caps *m,\n\t\t\t\t     struct ceph_mds_session *session)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tu64 follows = le64_to_cpu(m->snap_follows);\n\tstruct ceph_cap_snap *capsnap;\n\tint drop = 0;\n\n\tdout(\"handle_cap_flushsnap_ack inode %p ci %p mds%d follows %lld\\n\",\n\t     inode, ci, session->s_mds, follows);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tlist_for_each_entry(capsnap, &ci->i_cap_snaps, ci_item) {\n\t\tif (capsnap->follows == follows) {\n\t\t\tif (capsnap->flush_tid != flush_tid) {\n\t\t\t\tdout(\" cap_snap %p follows %lld tid %lld !=\"\n\t\t\t\t     \" %lld\\n\", capsnap, follows,\n\t\t\t\t     flush_tid, capsnap->flush_tid);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tWARN_ON(capsnap->dirty_pages || capsnap->writing);\n\t\t\tdout(\" removing %p cap_snap %p follows %lld\\n\",\n\t\t\t     inode, capsnap, follows);\n\t\t\tceph_put_snap_context(capsnap->context);\n\t\t\tlist_del(&capsnap->ci_item);\n\t\t\tlist_del(&capsnap->flushing_item);\n\t\t\tceph_put_cap_snap(capsnap);\n\t\t\tdrop = 1;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tdout(\" skipping cap_snap %p follows %lld\\n\",\n\t\t\t     capsnap, capsnap->follows);\n\t\t}\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\tif (drop)\n\t\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__queue_cap_release",
          "args": [
            "session",
            "vino.ino",
            "cap_id",
            "mseq",
            "seq"
          ],
          "line": 3147
        },
        "resolved": true,
        "details": {
          "function_name": "__queue_cap_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "1046-1082",
          "snippet": "void __queue_cap_release(struct ceph_mds_session *session,\n\t\t\t u64 ino, u64 cap_id, u32 migrate_seq,\n\t\t\t u32 issue_seq)\n{\n\tstruct ceph_msg *msg;\n\tstruct ceph_mds_cap_release *head;\n\tstruct ceph_mds_cap_item *item;\n\n\tBUG_ON(!session->s_num_cap_releases);\n\tmsg = list_first_entry(&session->s_cap_releases,\n\t\t\t       struct ceph_msg, list_head);\n\n\tdout(\" adding %llx release to mds%d msg %p (%d left)\\n\",\n\t     ino, session->s_mds, msg, session->s_num_cap_releases);\n\n\tBUG_ON(msg->front.iov_len + sizeof(*item) > PAGE_CACHE_SIZE);\n\thead = msg->front.iov_base;\n\tle32_add_cpu(&head->num, 1);\n\titem = msg->front.iov_base + msg->front.iov_len;\n\titem->ino = cpu_to_le64(ino);\n\titem->cap_id = cpu_to_le64(cap_id);\n\titem->migrate_seq = cpu_to_le32(migrate_seq);\n\titem->seq = cpu_to_le32(issue_seq);\n\n\tsession->s_num_cap_releases--;\n\n\tmsg->front.iov_len += sizeof(*item);\n\tif (le32_to_cpu(head->num) == CEPH_CAPS_PER_RELEASE) {\n\t\tdout(\" release msg %p full\\n\", msg);\n\t\tlist_move_tail(&msg->list_head, &session->s_cap_releases_done);\n\t} else {\n\t\tdout(\" release msg %p at %d/%d (%d)\\n\", msg,\n\t\t     (int)le32_to_cpu(head->num),\n\t\t     (int)CEPH_CAPS_PER_RELEASE,\n\t\t     (int)msg->front.iov_len);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid __queue_cap_release(struct ceph_mds_session *session,\n\t\t\t u64 ino, u64 cap_id, u32 migrate_seq,\n\t\t\t u32 issue_seq)\n{\n\tstruct ceph_msg *msg;\n\tstruct ceph_mds_cap_release *head;\n\tstruct ceph_mds_cap_item *item;\n\n\tBUG_ON(!session->s_num_cap_releases);\n\tmsg = list_first_entry(&session->s_cap_releases,\n\t\t\t       struct ceph_msg, list_head);\n\n\tdout(\" adding %llx release to mds%d msg %p (%d left)\\n\",\n\t     ino, session->s_mds, msg, session->s_num_cap_releases);\n\n\tBUG_ON(msg->front.iov_len + sizeof(*item) > PAGE_CACHE_SIZE);\n\thead = msg->front.iov_base;\n\tle32_add_cpu(&head->num, 1);\n\titem = msg->front.iov_base + msg->front.iov_len;\n\titem->ino = cpu_to_le64(ino);\n\titem->cap_id = cpu_to_le64(cap_id);\n\titem->migrate_seq = cpu_to_le32(migrate_seq);\n\titem->seq = cpu_to_le32(issue_seq);\n\n\tsession->s_num_cap_releases--;\n\n\tmsg->front.iov_len += sizeof(*item);\n\tif (le32_to_cpu(head->num) == CEPH_CAPS_PER_RELEASE) {\n\t\tdout(\" release msg %p full\\n\", msg);\n\t\tlist_move_tail(&msg->list_head, &session->s_cap_releases_done);\n\t} else {\n\t\tdout(\" release msg %p at %d/%d (%d)\\n\", msg,\n\t\t     (int)le32_to_cpu(head->num),\n\t\t     (int)CEPH_CAPS_PER_RELEASE,\n\t\t     (int)msg->front.iov_len);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" i don't have ino %llx\\n\"",
            "vino.ino"
          ],
          "line": 3143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" mds%d seq %lld cap seq %u\\n\"",
            "session->s_mds",
            "session->s_seq",
            "(unsigned)seq"
          ],
          "line": 3136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&session->s_mutex"
          ],
          "line": 3134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" op %s ino %llx.%llx inode %p\\n\"",
            "ceph_cap_op_name(op)",
            "vino.ino",
            "vino.snap",
            "inode"
          ],
          "line": 3131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_find_inode",
          "args": [
            "sb",
            "vino"
          ],
          "line": 3129
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_find_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "429-434",
          "snippet": "static inline struct inode *ceph_find_inode(struct super_block *sb,\n\t\t\t\t\t    struct ceph_vino vino)\n{\n\tino_t t = ceph_vino_to_ino(vino);\n\treturn ilookup5(sb, t, ceph_ino_compare, &vino);\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct inode *ceph_find_inode(struct super_block *sb,\n\t\t\t\t\t    struct ceph_vino vino)\n{\n\tino_t t = ceph_vino_to_ino(vino);\n\treturn ilookup5(sb, t, ceph_ino_compare, &vino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_decode_32_safe",
          "args": [
            "&p",
            "end",
            "inline_len",
            "bad"
          ],
          "line": 3121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_64_safe",
          "args": [
            "&p",
            "end",
            "inline_version",
            "bad"
          ],
          "line": 3120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "msg->hdr.version"
          ],
          "line": 3119
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_decode_32_safe",
          "args": [
            "&p",
            "end",
            "flock_len",
            "bad"
          ],
          "line": 3101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "h->snap_trace_len"
          ],
          "line": 3096
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "h->max_size"
          ],
          "line": 3093
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"handle_caps from mds%d\\n\"",
            "mds"
          ],
          "line": 3078
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_handle_caps(struct ceph_mds_session *session,\n\t\t      struct ceph_msg *msg)\n{\n\tstruct ceph_mds_client *mdsc = session->s_mdsc;\n\tstruct super_block *sb = mdsc->fsc->sb;\n\tstruct inode *inode;\n\tstruct ceph_inode_info *ci;\n\tstruct ceph_cap *cap;\n\tstruct ceph_mds_caps *h;\n\tstruct ceph_mds_cap_peer *peer = NULL;\n\tstruct ceph_snap_realm *realm;\n\tint mds = session->s_mds;\n\tint op, issued;\n\tu32 seq, mseq;\n\tstruct ceph_vino vino;\n\tu64 cap_id;\n\tu64 size, max_size;\n\tu64 tid;\n\tu64 inline_version = 0;\n\tvoid *inline_data = NULL;\n\tu32  inline_len = 0;\n\tvoid *snaptrace;\n\tsize_t snaptrace_len;\n\tvoid *p, *end;\n\n\tdout(\"handle_caps from mds%d\\n\", mds);\n\n\t/* decode */\n\tend = msg->front.iov_base + msg->front.iov_len;\n\ttid = le64_to_cpu(msg->hdr.tid);\n\tif (msg->front.iov_len < sizeof(*h))\n\t\tgoto bad;\n\th = msg->front.iov_base;\n\top = le32_to_cpu(h->op);\n\tvino.ino = le64_to_cpu(h->ino);\n\tvino.snap = CEPH_NOSNAP;\n\tcap_id = le64_to_cpu(h->cap_id);\n\tseq = le32_to_cpu(h->seq);\n\tmseq = le32_to_cpu(h->migrate_seq);\n\tsize = le64_to_cpu(h->size);\n\tmax_size = le64_to_cpu(h->max_size);\n\n\tsnaptrace = h + 1;\n\tsnaptrace_len = le32_to_cpu(h->snap_trace_len);\n\tp = snaptrace + snaptrace_len;\n\n\tif (le16_to_cpu(msg->hdr.version) >= 2) {\n\t\tu32 flock_len;\n\t\tceph_decode_32_safe(&p, end, flock_len, bad);\n\t\tif (p + flock_len > end)\n\t\t\tgoto bad;\n\t\tp += flock_len;\n\t}\n\n\tif (le16_to_cpu(msg->hdr.version) >= 3) {\n\t\tif (op == CEPH_CAP_OP_IMPORT) {\n\t\t\tif (p + sizeof(*peer) > end)\n\t\t\t\tgoto bad;\n\t\t\tpeer = p;\n\t\t\tp += sizeof(*peer);\n\t\t} else if (op == CEPH_CAP_OP_EXPORT) {\n\t\t\t/* recorded in unused fields */\n\t\t\tpeer = (void *)&h->size;\n\t\t}\n\t}\n\n\tif (le16_to_cpu(msg->hdr.version) >= 4) {\n\t\tceph_decode_64_safe(&p, end, inline_version, bad);\n\t\tceph_decode_32_safe(&p, end, inline_len, bad);\n\t\tif (p + inline_len > end)\n\t\t\tgoto bad;\n\t\tinline_data = p;\n\t\tp += inline_len;\n\t}\n\n\t/* lookup ino */\n\tinode = ceph_find_inode(sb, vino);\n\tci = ceph_inode(inode);\n\tdout(\" op %s ino %llx.%llx inode %p\\n\", ceph_cap_op_name(op), vino.ino,\n\t     vino.snap, inode);\n\n\tmutex_lock(&session->s_mutex);\n\tsession->s_seq++;\n\tdout(\" mds%d seq %lld cap seq %u\\n\", session->s_mds, session->s_seq,\n\t     (unsigned)seq);\n\n\tif (op == CEPH_CAP_OP_IMPORT)\n\t\tceph_add_cap_releases(mdsc, session);\n\n\tif (!inode) {\n\t\tdout(\" i don't have ino %llx\\n\", vino.ino);\n\n\t\tif (op == CEPH_CAP_OP_IMPORT) {\n\t\t\tspin_lock(&session->s_cap_lock);\n\t\t\t__queue_cap_release(session, vino.ino, cap_id,\n\t\t\t\t\t    mseq, seq);\n\t\t\tspin_unlock(&session->s_cap_lock);\n\t\t}\n\t\tgoto flush_cap_releases;\n\t}\n\n\t/* these will work even if we don't have a cap yet */\n\tswitch (op) {\n\tcase CEPH_CAP_OP_FLUSHSNAP_ACK:\n\t\thandle_cap_flushsnap_ack(inode, tid, h, session);\n\t\tgoto done;\n\n\tcase CEPH_CAP_OP_EXPORT:\n\t\thandle_cap_export(inode, h, peer, session);\n\t\tgoto done_unlocked;\n\n\tcase CEPH_CAP_OP_IMPORT:\n\t\trealm = NULL;\n\t\tif (snaptrace_len) {\n\t\t\tdown_write(&mdsc->snap_rwsem);\n\t\t\tceph_update_snap_trace(mdsc, snaptrace,\n\t\t\t\t\t       snaptrace + snaptrace_len,\n\t\t\t\t\t       false, &realm);\n\t\t\tdowngrade_write(&mdsc->snap_rwsem);\n\t\t} else {\n\t\t\tdown_read(&mdsc->snap_rwsem);\n\t\t}\n\t\thandle_cap_import(mdsc, inode, h, peer, session,\n\t\t\t\t  &cap, &issued);\n\t\thandle_cap_grant(mdsc, inode, h,\n\t\t\t\t inline_version, inline_data, inline_len,\n\t\t\t\t msg->middle, session, cap, issued);\n\t\tif (realm)\n\t\t\tceph_put_snap_realm(mdsc, realm);\n\t\tgoto done_unlocked;\n\t}\n\n\t/* the rest require a cap */\n\tspin_lock(&ci->i_ceph_lock);\n\tcap = __get_cap_for_mds(ceph_inode(inode), mds);\n\tif (!cap) {\n\t\tdout(\" no cap on %p ino %llx.%llx from mds%d\\n\",\n\t\t     inode, ceph_ino(inode), ceph_snap(inode), mds);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tgoto flush_cap_releases;\n\t}\n\n\t/* note that each of these drops i_ceph_lock for us */\n\tswitch (op) {\n\tcase CEPH_CAP_OP_REVOKE:\n\tcase CEPH_CAP_OP_GRANT:\n\t\t__ceph_caps_issued(ci, &issued);\n\t\tissued |= __ceph_caps_dirty(ci);\n\t\thandle_cap_grant(mdsc, inode, h,\n\t\t\t\t inline_version, inline_data, inline_len,\n\t\t\t\t msg->middle, session, cap, issued);\n\t\tgoto done_unlocked;\n\n\tcase CEPH_CAP_OP_FLUSH_ACK:\n\t\thandle_cap_flush_ack(inode, tid, h, session, cap);\n\t\tbreak;\n\n\tcase CEPH_CAP_OP_TRUNC:\n\t\thandle_cap_trunc(inode, h, session);\n\t\tbreak;\n\n\tdefault:\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tpr_err(\"ceph_handle_caps: unknown cap op %d %s\\n\", op,\n\t\t       ceph_cap_op_name(op));\n\t}\n\n\tgoto done;\n\nflush_cap_releases:\n\t/*\n\t * send any full release message to try to move things\n\t * along for the mds (who clearly thinks we still have this\n\t * cap).\n\t */\n\tceph_add_cap_releases(mdsc, session);\n\tceph_send_cap_releases(mdsc, session);\n\ndone:\n\tmutex_unlock(&session->s_mutex);\ndone_unlocked:\n\tiput(inode);\n\treturn;\n\nbad:\n\tpr_err(\"ceph_handle_caps: corrupt message\\n\");\n\tceph_msg_dump(msg);\n\treturn;\n}"
  },
  {
    "function_name": "handle_cap_import",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "2968-3045",
    "snippet": "static void handle_cap_import(struct ceph_mds_client *mdsc,\n\t\t\t      struct inode *inode, struct ceph_mds_caps *im,\n\t\t\t      struct ceph_mds_cap_peer *ph,\n\t\t\t      struct ceph_mds_session *session,\n\t\t\t      struct ceph_cap **target_cap, int *old_issued)\n\t__acquires(ci->i_ceph_lock)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_cap *cap, *ocap, *new_cap = NULL;\n\tint mds = session->s_mds;\n\tint issued;\n\tunsigned caps = le32_to_cpu(im->caps);\n\tunsigned wanted = le32_to_cpu(im->wanted);\n\tunsigned seq = le32_to_cpu(im->seq);\n\tunsigned mseq = le32_to_cpu(im->migrate_seq);\n\tu64 realmino = le64_to_cpu(im->realm);\n\tu64 cap_id = le64_to_cpu(im->cap_id);\n\tu64 p_cap_id;\n\tint peer;\n\n\tif (ph) {\n\t\tp_cap_id = le64_to_cpu(ph->cap_id);\n\t\tpeer = le32_to_cpu(ph->mds);\n\t} else {\n\t\tp_cap_id = 0;\n\t\tpeer = -1;\n\t}\n\n\tdout(\"handle_cap_import inode %p ci %p mds%d mseq %d peer %d\\n\",\n\t     inode, ci, mds, mseq, peer);\n\nretry:\n\tspin_lock(&ci->i_ceph_lock);\n\tcap = __get_cap_for_mds(ci, mds);\n\tif (!cap) {\n\t\tif (!new_cap) {\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\tnew_cap = ceph_get_cap(mdsc, NULL);\n\t\t\tgoto retry;\n\t\t}\n\t\tcap = new_cap;\n\t} else {\n\t\tif (new_cap) {\n\t\t\tceph_put_cap(mdsc, new_cap);\n\t\t\tnew_cap = NULL;\n\t\t}\n\t}\n\n\t__ceph_caps_issued(ci, &issued);\n\tissued |= __ceph_caps_dirty(ci);\n\n\tceph_add_cap(inode, session, cap_id, -1, caps, wanted, seq, mseq,\n\t\t     realmino, CEPH_CAP_FLAG_AUTH, &new_cap);\n\n\tocap = peer >= 0 ? __get_cap_for_mds(ci, peer) : NULL;\n\tif (ocap && ocap->cap_id == p_cap_id) {\n\t\tdout(\" remove export cap %p mds%d flags %d\\n\",\n\t\t     ocap, peer, ph->flags);\n\t\tif ((ph->flags & CEPH_CAP_FLAG_AUTH) &&\n\t\t    (ocap->seq != le32_to_cpu(ph->seq) ||\n\t\t     ocap->mseq != le32_to_cpu(ph->mseq))) {\n\t\t\tpr_err(\"handle_cap_import: mismatched seq/mseq: \"\n\t\t\t       \"ino (%llx.%llx) mds%d seq %d mseq %d \"\n\t\t\t       \"importer mds%d has peer seq %d mseq %d\\n\",\n\t\t\t       ceph_vinop(inode), peer, ocap->seq,\n\t\t\t       ocap->mseq, mds, le32_to_cpu(ph->seq),\n\t\t\t       le32_to_cpu(ph->mseq));\n\t\t}\n\t\t__ceph_remove_cap(ocap, (ph->flags & CEPH_CAP_FLAG_RELEASE));\n\t}\n\n\t/* make sure we re-request max_size, if necessary */\n\tci->i_wanted_max_size = 0;\n\tci->i_requested_max_size = 0;\n\n\t*old_issued = issued;\n\t*target_cap = cap;\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ceph_remove_cap",
          "args": [
            "ocap",
            "(ph->flags & CEPH_CAP_FLAG_RELEASE)"
          ],
          "line": 3036
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_remove_cap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "905-960",
          "snippet": "void __ceph_remove_cap(struct ceph_cap *cap, bool queue_release)\n{\n\tstruct ceph_mds_session *session = cap->session;\n\tstruct ceph_inode_info *ci = cap->ci;\n\tstruct ceph_mds_client *mdsc =\n\t\tceph_sb_to_client(ci->vfs_inode.i_sb)->mdsc;\n\tint removed = 0;\n\n\tdout(\"__ceph_remove_cap %p from %p\\n\", cap, &ci->vfs_inode);\n\n\t/* remove from session list */\n\tspin_lock(&session->s_cap_lock);\n\t/*\n\t * s_cap_reconnect is protected by s_cap_lock. no one changes\n\t * s_cap_gen while session is in the reconnect state.\n\t */\n\tif (queue_release &&\n\t    (!session->s_cap_reconnect ||\n\t     cap->cap_gen == session->s_cap_gen))\n\t\t__queue_cap_release(session, ci->i_vino.ino, cap->cap_id,\n\t\t\t\t    cap->mseq, cap->issue_seq);\n\n\tif (session->s_cap_iterator == cap) {\n\t\t/* not yet, we are iterating over this very cap */\n\t\tdout(\"__ceph_remove_cap  delaying %p removal from session %p\\n\",\n\t\t     cap, cap->session);\n\t} else {\n\t\tlist_del_init(&cap->session_caps);\n\t\tsession->s_nr_caps--;\n\t\tcap->session = NULL;\n\t\tremoved = 1;\n\t}\n\t/* protect backpointer with s_cap_lock: see iterate_session_caps */\n\tcap->ci = NULL;\n\tspin_unlock(&session->s_cap_lock);\n\n\t/* remove from inode list */\n\trb_erase(&cap->ci_node, &ci->i_caps);\n\tif (ci->i_auth_cap == cap)\n\t\tci->i_auth_cap = NULL;\n\n\tif (removed)\n\t\tceph_put_cap(mdsc, cap);\n\n\tif (!__ceph_is_any_caps(ci) && ci->i_snap_realm) {\n\t\tstruct ceph_snap_realm *realm = ci->i_snap_realm;\n\t\tspin_lock(&realm->inodes_with_caps_lock);\n\t\tlist_del_init(&ci->i_snap_realm_item);\n\t\tci->i_snap_realm_counter++;\n\t\tci->i_snap_realm = NULL;\n\t\tspin_unlock(&realm->inodes_with_caps_lock);\n\t\tceph_put_snap_realm(mdsc, realm);\n\t}\n\tif (!__ceph_is_any_real_caps(ci))\n\t\t__cap_delay_cancel(mdsc, ci);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid __ceph_remove_cap(struct ceph_cap *cap, bool queue_release)\n{\n\tstruct ceph_mds_session *session = cap->session;\n\tstruct ceph_inode_info *ci = cap->ci;\n\tstruct ceph_mds_client *mdsc =\n\t\tceph_sb_to_client(ci->vfs_inode.i_sb)->mdsc;\n\tint removed = 0;\n\n\tdout(\"__ceph_remove_cap %p from %p\\n\", cap, &ci->vfs_inode);\n\n\t/* remove from session list */\n\tspin_lock(&session->s_cap_lock);\n\t/*\n\t * s_cap_reconnect is protected by s_cap_lock. no one changes\n\t * s_cap_gen while session is in the reconnect state.\n\t */\n\tif (queue_release &&\n\t    (!session->s_cap_reconnect ||\n\t     cap->cap_gen == session->s_cap_gen))\n\t\t__queue_cap_release(session, ci->i_vino.ino, cap->cap_id,\n\t\t\t\t    cap->mseq, cap->issue_seq);\n\n\tif (session->s_cap_iterator == cap) {\n\t\t/* not yet, we are iterating over this very cap */\n\t\tdout(\"__ceph_remove_cap  delaying %p removal from session %p\\n\",\n\t\t     cap, cap->session);\n\t} else {\n\t\tlist_del_init(&cap->session_caps);\n\t\tsession->s_nr_caps--;\n\t\tcap->session = NULL;\n\t\tremoved = 1;\n\t}\n\t/* protect backpointer with s_cap_lock: see iterate_session_caps */\n\tcap->ci = NULL;\n\tspin_unlock(&session->s_cap_lock);\n\n\t/* remove from inode list */\n\trb_erase(&cap->ci_node, &ci->i_caps);\n\tif (ci->i_auth_cap == cap)\n\t\tci->i_auth_cap = NULL;\n\n\tif (removed)\n\t\tceph_put_cap(mdsc, cap);\n\n\tif (!__ceph_is_any_caps(ci) && ci->i_snap_realm) {\n\t\tstruct ceph_snap_realm *realm = ci->i_snap_realm;\n\t\tspin_lock(&realm->inodes_with_caps_lock);\n\t\tlist_del_init(&ci->i_snap_realm_item);\n\t\tci->i_snap_realm_counter++;\n\t\tci->i_snap_realm = NULL;\n\t\tspin_unlock(&realm->inodes_with_caps_lock);\n\t\tceph_put_snap_realm(mdsc, realm);\n\t}\n\tif (!__ceph_is_any_real_caps(ci))\n\t\t__cap_delay_cancel(mdsc, ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"handle_cap_import: mismatched seq/mseq: \"\n\t\t\t       \"ino (%llx.%llx) mds%d seq %d mseq %d \"\n\t\t\t       \"importer mds%d has peer seq %d mseq %d\\n\"",
            "ceph_vinop(inode)",
            "peer",
            "ocap->seq",
            "ocap->mseq",
            "mds",
            "le32_to_cpu(ph->seq)",
            "le32_to_cpu(ph->mseq)"
          ],
          "line": 3029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ph->mseq"
          ],
          "line": 3034
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_vinop",
          "args": [
            "inode"
          ],
          "line": 3032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" remove export cap %p mds%d flags %d\\n\"",
            "ocap",
            "peer",
            "ph->flags"
          ],
          "line": 3024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_cap_for_mds",
          "args": [
            "ci",
            "peer"
          ],
          "line": 3022
        },
        "resolved": true,
        "details": {
          "function_name": "__get_cap_for_mds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "310-325",
          "snippet": "static struct ceph_cap *__get_cap_for_mds(struct ceph_inode_info *ci, int mds)\n{\n\tstruct ceph_cap *cap;\n\tstruct rb_node *n = ci->i_caps.rb_node;\n\n\twhile (n) {\n\t\tcap = rb_entry(n, struct ceph_cap, ci_node);\n\t\tif (mds < cap->mds)\n\t\t\tn = n->rb_left;\n\t\telse if (mds > cap->mds)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn cap;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_cap *__get_cap_for_mds(struct ceph_inode_info *ci, int mds)\n{\n\tstruct ceph_cap *cap;\n\tstruct rb_node *n = ci->i_caps.rb_node;\n\n\twhile (n) {\n\t\tcap = rb_entry(n, struct ceph_cap, ci_node);\n\t\tif (mds < cap->mds)\n\t\t\tn = n->rb_left;\n\t\telse if (mds > cap->mds)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn cap;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_add_cap",
          "args": [
            "inode",
            "session",
            "cap_id",
            "-1",
            "caps",
            "wanted",
            "seq",
            "mseq",
            "realmino",
            "CEPH_CAP_FLAG_AUTH",
            "&new_cap"
          ],
          "line": 3019
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_add_cap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "511-635",
          "snippet": "void ceph_add_cap(struct inode *inode,\n\t\t  struct ceph_mds_session *session, u64 cap_id,\n\t\t  int fmode, unsigned issued, unsigned wanted,\n\t\t  unsigned seq, unsigned mseq, u64 realmino, int flags,\n\t\t  struct ceph_cap **new_cap)\n{\n\tstruct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_cap *cap;\n\tint mds = session->s_mds;\n\tint actual_wanted;\n\n\tdout(\"add_cap %p mds%d cap %llx %s seq %d\\n\", inode,\n\t     session->s_mds, cap_id, ceph_cap_string(issued), seq);\n\n\t/*\n\t * If we are opening the file, include file mode wanted bits\n\t * in wanted.\n\t */\n\tif (fmode >= 0)\n\t\twanted |= ceph_caps_for_mode(fmode);\n\n\tcap = __get_cap_for_mds(ci, mds);\n\tif (!cap) {\n\t\tcap = *new_cap;\n\t\t*new_cap = NULL;\n\n\t\tcap->issued = 0;\n\t\tcap->implemented = 0;\n\t\tcap->mds = mds;\n\t\tcap->mds_wanted = 0;\n\t\tcap->mseq = 0;\n\n\t\tcap->ci = ci;\n\t\t__insert_cap_node(ci, cap);\n\n\t\t/* add to session cap list */\n\t\tcap->session = session;\n\t\tspin_lock(&session->s_cap_lock);\n\t\tlist_add_tail(&cap->session_caps, &session->s_caps);\n\t\tsession->s_nr_caps++;\n\t\tspin_unlock(&session->s_cap_lock);\n\t} else {\n\t\t/*\n\t\t * auth mds of the inode changed. we received the cap export\n\t\t * message, but still haven't received the cap import message.\n\t\t * handle_cap_export() updated the new auth MDS' cap.\n\t\t *\n\t\t * \"ceph_seq_cmp(seq, cap->seq) <= 0\" means we are processing\n\t\t * a message that was send before the cap import message. So\n\t\t * don't remove caps.\n\t\t */\n\t\tif (ceph_seq_cmp(seq, cap->seq) <= 0) {\n\t\t\tWARN_ON(cap != ci->i_auth_cap);\n\t\t\tWARN_ON(cap->cap_id != cap_id);\n\t\t\tseq = cap->seq;\n\t\t\tmseq = cap->mseq;\n\t\t\tissued |= cap->issued;\n\t\t\tflags |= CEPH_CAP_FLAG_AUTH;\n\t\t}\n\t}\n\n\tif (!ci->i_snap_realm) {\n\t\t/*\n\t\t * add this inode to the appropriate snap realm\n\t\t */\n\t\tstruct ceph_snap_realm *realm = ceph_lookup_snap_realm(mdsc,\n\t\t\t\t\t\t\t       realmino);\n\t\tif (realm) {\n\t\t\tspin_lock(&realm->inodes_with_caps_lock);\n\t\t\tci->i_snap_realm = realm;\n\t\t\tlist_add(&ci->i_snap_realm_item,\n\t\t\t\t &realm->inodes_with_caps);\n\t\t\tspin_unlock(&realm->inodes_with_caps_lock);\n\t\t} else {\n\t\t\tpr_err(\"ceph_add_cap: couldn't find snap realm %llx\\n\",\n\t\t\t       realmino);\n\t\t\tWARN_ON(!realm);\n\t\t}\n\t}\n\n\t__check_cap_issue(ci, cap, issued);\n\n\t/*\n\t * If we are issued caps we don't want, or the mds' wanted\n\t * value appears to be off, queue a check so we'll release\n\t * later and/or update the mds wanted value.\n\t */\n\tactual_wanted = __ceph_caps_wanted(ci);\n\tif ((wanted & ~actual_wanted) ||\n\t    (issued & ~actual_wanted & CEPH_CAP_ANY_WR)) {\n\t\tdout(\" issued %s, mds wanted %s, actual %s, queueing\\n\",\n\t\t     ceph_cap_string(issued), ceph_cap_string(wanted),\n\t\t     ceph_cap_string(actual_wanted));\n\t\t__cap_delay_requeue(mdsc, ci);\n\t}\n\n\tif (flags & CEPH_CAP_FLAG_AUTH) {\n\t\tif (ci->i_auth_cap == NULL ||\n\t\t    ceph_seq_cmp(ci->i_auth_cap->mseq, mseq) < 0) {\n\t\t\tci->i_auth_cap = cap;\n\t\t\tcap->mds_wanted = wanted;\n\t\t}\n\t} else {\n\t\tWARN_ON(ci->i_auth_cap == cap);\n\t}\n\n\tdout(\"add_cap inode %p (%llx.%llx) cap %p %s now %s seq %d mds%d\\n\",\n\t     inode, ceph_vinop(inode), cap, ceph_cap_string(issued),\n\t     ceph_cap_string(issued|cap->issued), seq, mds);\n\tcap->cap_id = cap_id;\n\tcap->issued = issued;\n\tcap->implemented |= issued;\n\tif (ceph_seq_cmp(mseq, cap->mseq) > 0)\n\t\tcap->mds_wanted = wanted;\n\telse\n\t\tcap->mds_wanted |= wanted;\n\tcap->seq = seq;\n\tcap->issue_seq = seq;\n\tcap->mseq = mseq;\n\tcap->cap_gen = session->s_cap_gen;\n\n\tif (fmode >= 0)\n\t\t__ceph_get_fmode(ci, fmode);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_add_cap(struct inode *inode,\n\t\t  struct ceph_mds_session *session, u64 cap_id,\n\t\t  int fmode, unsigned issued, unsigned wanted,\n\t\t  unsigned seq, unsigned mseq, u64 realmino, int flags,\n\t\t  struct ceph_cap **new_cap)\n{\n\tstruct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_cap *cap;\n\tint mds = session->s_mds;\n\tint actual_wanted;\n\n\tdout(\"add_cap %p mds%d cap %llx %s seq %d\\n\", inode,\n\t     session->s_mds, cap_id, ceph_cap_string(issued), seq);\n\n\t/*\n\t * If we are opening the file, include file mode wanted bits\n\t * in wanted.\n\t */\n\tif (fmode >= 0)\n\t\twanted |= ceph_caps_for_mode(fmode);\n\n\tcap = __get_cap_for_mds(ci, mds);\n\tif (!cap) {\n\t\tcap = *new_cap;\n\t\t*new_cap = NULL;\n\n\t\tcap->issued = 0;\n\t\tcap->implemented = 0;\n\t\tcap->mds = mds;\n\t\tcap->mds_wanted = 0;\n\t\tcap->mseq = 0;\n\n\t\tcap->ci = ci;\n\t\t__insert_cap_node(ci, cap);\n\n\t\t/* add to session cap list */\n\t\tcap->session = session;\n\t\tspin_lock(&session->s_cap_lock);\n\t\tlist_add_tail(&cap->session_caps, &session->s_caps);\n\t\tsession->s_nr_caps++;\n\t\tspin_unlock(&session->s_cap_lock);\n\t} else {\n\t\t/*\n\t\t * auth mds of the inode changed. we received the cap export\n\t\t * message, but still haven't received the cap import message.\n\t\t * handle_cap_export() updated the new auth MDS' cap.\n\t\t *\n\t\t * \"ceph_seq_cmp(seq, cap->seq) <= 0\" means we are processing\n\t\t * a message that was send before the cap import message. So\n\t\t * don't remove caps.\n\t\t */\n\t\tif (ceph_seq_cmp(seq, cap->seq) <= 0) {\n\t\t\tWARN_ON(cap != ci->i_auth_cap);\n\t\t\tWARN_ON(cap->cap_id != cap_id);\n\t\t\tseq = cap->seq;\n\t\t\tmseq = cap->mseq;\n\t\t\tissued |= cap->issued;\n\t\t\tflags |= CEPH_CAP_FLAG_AUTH;\n\t\t}\n\t}\n\n\tif (!ci->i_snap_realm) {\n\t\t/*\n\t\t * add this inode to the appropriate snap realm\n\t\t */\n\t\tstruct ceph_snap_realm *realm = ceph_lookup_snap_realm(mdsc,\n\t\t\t\t\t\t\t       realmino);\n\t\tif (realm) {\n\t\t\tspin_lock(&realm->inodes_with_caps_lock);\n\t\t\tci->i_snap_realm = realm;\n\t\t\tlist_add(&ci->i_snap_realm_item,\n\t\t\t\t &realm->inodes_with_caps);\n\t\t\tspin_unlock(&realm->inodes_with_caps_lock);\n\t\t} else {\n\t\t\tpr_err(\"ceph_add_cap: couldn't find snap realm %llx\\n\",\n\t\t\t       realmino);\n\t\t\tWARN_ON(!realm);\n\t\t}\n\t}\n\n\t__check_cap_issue(ci, cap, issued);\n\n\t/*\n\t * If we are issued caps we don't want, or the mds' wanted\n\t * value appears to be off, queue a check so we'll release\n\t * later and/or update the mds wanted value.\n\t */\n\tactual_wanted = __ceph_caps_wanted(ci);\n\tif ((wanted & ~actual_wanted) ||\n\t    (issued & ~actual_wanted & CEPH_CAP_ANY_WR)) {\n\t\tdout(\" issued %s, mds wanted %s, actual %s, queueing\\n\",\n\t\t     ceph_cap_string(issued), ceph_cap_string(wanted),\n\t\t     ceph_cap_string(actual_wanted));\n\t\t__cap_delay_requeue(mdsc, ci);\n\t}\n\n\tif (flags & CEPH_CAP_FLAG_AUTH) {\n\t\tif (ci->i_auth_cap == NULL ||\n\t\t    ceph_seq_cmp(ci->i_auth_cap->mseq, mseq) < 0) {\n\t\t\tci->i_auth_cap = cap;\n\t\t\tcap->mds_wanted = wanted;\n\t\t}\n\t} else {\n\t\tWARN_ON(ci->i_auth_cap == cap);\n\t}\n\n\tdout(\"add_cap inode %p (%llx.%llx) cap %p %s now %s seq %d mds%d\\n\",\n\t     inode, ceph_vinop(inode), cap, ceph_cap_string(issued),\n\t     ceph_cap_string(issued|cap->issued), seq, mds);\n\tcap->cap_id = cap_id;\n\tcap->issued = issued;\n\tcap->implemented |= issued;\n\tif (ceph_seq_cmp(mseq, cap->mseq) > 0)\n\t\tcap->mds_wanted = wanted;\n\telse\n\t\tcap->mds_wanted |= wanted;\n\tcap->seq = seq;\n\tcap->issue_seq = seq;\n\tcap->mseq = mseq;\n\tcap->cap_gen = session->s_cap_gen;\n\n\tif (fmode >= 0)\n\t\t__ceph_get_fmode(ci, fmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_caps_dirty",
          "args": [
            "ci"
          ],
          "line": 3017
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_caps_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "550-553",
          "snippet": "static inline int __ceph_caps_dirty(struct ceph_inode_info *ci)\n{\n\treturn ci->i_dirty_caps | ci->i_flushing_caps;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline int __ceph_caps_dirty(struct ceph_inode_info *ci)\n{\n\treturn ci->i_dirty_caps | ci->i_flushing_caps;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_caps_issued",
          "args": [
            "ci",
            "&issued"
          ],
          "line": 3016
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_caps_issued_other",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "700-715",
          "snippet": "int __ceph_caps_issued_other(struct ceph_inode_info *ci, struct ceph_cap *ocap)\n{\n\tint have = ci->i_snap_caps;\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (cap == ocap)\n\t\t\tcontinue;\n\t\tif (!__cap_is_valid(cap))\n\t\t\tcontinue;\n\t\thave |= cap->issued;\n\t}\n\treturn have;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_caps_issued_other(struct ceph_inode_info *ci, struct ceph_cap *ocap)\n{\n\tint have = ci->i_snap_caps;\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (cap == ocap)\n\t\t\tcontinue;\n\t\tif (!__cap_is_valid(cap))\n\t\t\tcontinue;\n\t\thave |= cap->issued;\n\t}\n\treturn have;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_put_cap",
          "args": [
            "mdsc",
            "new_cap"
          ],
          "line": 3011
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_put_cap_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "2274-2326",
          "snippet": "void ceph_put_cap_refs(struct ceph_inode_info *ci, int had)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint last = 0, put = 0, flushsnaps = 0, wake = 0;\n\tstruct ceph_cap_snap *capsnap;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (had & CEPH_CAP_PIN)\n\t\t--ci->i_pin_ref;\n\tif (had & CEPH_CAP_FILE_RD)\n\t\tif (--ci->i_rd_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_CACHE)\n\t\tif (--ci->i_rdcache_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_BUFFER) {\n\t\tif (--ci->i_wb_ref == 0) {\n\t\t\tlast++;\n\t\t\tput++;\n\t\t}\n\t\tdout(\"put_cap_refs %p wb %d -> %d (?)\\n\",\n\t\t     inode, ci->i_wb_ref+1, ci->i_wb_ref);\n\t}\n\tif (had & CEPH_CAP_FILE_WR)\n\t\tif (--ci->i_wr_ref == 0) {\n\t\t\tlast++;\n\t\t\tif (!list_empty(&ci->i_cap_snaps)) {\n\t\t\t\tcapsnap = list_first_entry(&ci->i_cap_snaps,\n\t\t\t\t\t\t     struct ceph_cap_snap,\n\t\t\t\t\t\t     ci_item);\n\t\t\t\tif (capsnap->writing) {\n\t\t\t\t\tcapsnap->writing = 0;\n\t\t\t\t\tflushsnaps =\n\t\t\t\t\t\t__ceph_finish_cap_snap(ci,\n\t\t\t\t\t\t\t\t       capsnap);\n\t\t\t\t\twake = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tdout(\"put_cap_refs %p had %s%s%s\\n\", inode, ceph_cap_string(had),\n\t     last ? \" last\" : \"\", put ? \" put\" : \"\");\n\n\tif (last && !flushsnaps)\n\t\tceph_check_caps(ci, 0, NULL);\n\telse if (flushsnaps)\n\t\tceph_flush_snaps(ci);\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\tif (put)\n\t\tiput(inode);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_put_cap_refs(struct ceph_inode_info *ci, int had)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint last = 0, put = 0, flushsnaps = 0, wake = 0;\n\tstruct ceph_cap_snap *capsnap;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (had & CEPH_CAP_PIN)\n\t\t--ci->i_pin_ref;\n\tif (had & CEPH_CAP_FILE_RD)\n\t\tif (--ci->i_rd_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_CACHE)\n\t\tif (--ci->i_rdcache_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_BUFFER) {\n\t\tif (--ci->i_wb_ref == 0) {\n\t\t\tlast++;\n\t\t\tput++;\n\t\t}\n\t\tdout(\"put_cap_refs %p wb %d -> %d (?)\\n\",\n\t\t     inode, ci->i_wb_ref+1, ci->i_wb_ref);\n\t}\n\tif (had & CEPH_CAP_FILE_WR)\n\t\tif (--ci->i_wr_ref == 0) {\n\t\t\tlast++;\n\t\t\tif (!list_empty(&ci->i_cap_snaps)) {\n\t\t\t\tcapsnap = list_first_entry(&ci->i_cap_snaps,\n\t\t\t\t\t\t     struct ceph_cap_snap,\n\t\t\t\t\t\t     ci_item);\n\t\t\t\tif (capsnap->writing) {\n\t\t\t\t\tcapsnap->writing = 0;\n\t\t\t\t\tflushsnaps =\n\t\t\t\t\t\t__ceph_finish_cap_snap(ci,\n\t\t\t\t\t\t\t\t       capsnap);\n\t\t\t\t\twake = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tdout(\"put_cap_refs %p had %s%s%s\\n\", inode, ceph_cap_string(had),\n\t     last ? \" last\" : \"\", put ? \" put\" : \"\");\n\n\tif (last && !flushsnaps)\n\t\tceph_check_caps(ci, 0, NULL);\n\telse if (flushsnaps)\n\t\tceph_flush_snaps(ci);\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\tif (put)\n\t\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_get_cap",
          "args": [
            "mdsc",
            "NULL"
          ],
          "line": 3005
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_get_cap_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "2258-2263",
          "snippet": "void ceph_get_cap_refs(struct ceph_inode_info *ci, int caps)\n{\n\tspin_lock(&ci->i_ceph_lock);\n\t__take_cap_refs(ci, caps);\n\tspin_unlock(&ci->i_ceph_lock);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_get_cap_refs(struct ceph_inode_info *ci, int caps)\n{\n\tspin_lock(&ci->i_ceph_lock);\n\t__take_cap_refs(ci, caps);\n\tspin_unlock(&ci->i_ceph_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 3004
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 3000
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"handle_cap_import inode %p ci %p mds%d mseq %d peer %d\\n\"",
            "inode",
            "ci",
            "mds",
            "mseq",
            "peer"
          ],
          "line": 2996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "ph->cap_id"
          ],
          "line": 2989
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 2975
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "ci->i_ceph_lock"
          ],
          "line": 2973
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void handle_cap_import(struct ceph_mds_client *mdsc,\n\t\t\t      struct inode *inode, struct ceph_mds_caps *im,\n\t\t\t      struct ceph_mds_cap_peer *ph,\n\t\t\t      struct ceph_mds_session *session,\n\t\t\t      struct ceph_cap **target_cap, int *old_issued)\n\t__acquires(ci->i_ceph_lock)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_cap *cap, *ocap, *new_cap = NULL;\n\tint mds = session->s_mds;\n\tint issued;\n\tunsigned caps = le32_to_cpu(im->caps);\n\tunsigned wanted = le32_to_cpu(im->wanted);\n\tunsigned seq = le32_to_cpu(im->seq);\n\tunsigned mseq = le32_to_cpu(im->migrate_seq);\n\tu64 realmino = le64_to_cpu(im->realm);\n\tu64 cap_id = le64_to_cpu(im->cap_id);\n\tu64 p_cap_id;\n\tint peer;\n\n\tif (ph) {\n\t\tp_cap_id = le64_to_cpu(ph->cap_id);\n\t\tpeer = le32_to_cpu(ph->mds);\n\t} else {\n\t\tp_cap_id = 0;\n\t\tpeer = -1;\n\t}\n\n\tdout(\"handle_cap_import inode %p ci %p mds%d mseq %d peer %d\\n\",\n\t     inode, ci, mds, mseq, peer);\n\nretry:\n\tspin_lock(&ci->i_ceph_lock);\n\tcap = __get_cap_for_mds(ci, mds);\n\tif (!cap) {\n\t\tif (!new_cap) {\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\tnew_cap = ceph_get_cap(mdsc, NULL);\n\t\t\tgoto retry;\n\t\t}\n\t\tcap = new_cap;\n\t} else {\n\t\tif (new_cap) {\n\t\t\tceph_put_cap(mdsc, new_cap);\n\t\t\tnew_cap = NULL;\n\t\t}\n\t}\n\n\t__ceph_caps_issued(ci, &issued);\n\tissued |= __ceph_caps_dirty(ci);\n\n\tceph_add_cap(inode, session, cap_id, -1, caps, wanted, seq, mseq,\n\t\t     realmino, CEPH_CAP_FLAG_AUTH, &new_cap);\n\n\tocap = peer >= 0 ? __get_cap_for_mds(ci, peer) : NULL;\n\tif (ocap && ocap->cap_id == p_cap_id) {\n\t\tdout(\" remove export cap %p mds%d flags %d\\n\",\n\t\t     ocap, peer, ph->flags);\n\t\tif ((ph->flags & CEPH_CAP_FLAG_AUTH) &&\n\t\t    (ocap->seq != le32_to_cpu(ph->seq) ||\n\t\t     ocap->mseq != le32_to_cpu(ph->mseq))) {\n\t\t\tpr_err(\"handle_cap_import: mismatched seq/mseq: \"\n\t\t\t       \"ino (%llx.%llx) mds%d seq %d mseq %d \"\n\t\t\t       \"importer mds%d has peer seq %d mseq %d\\n\",\n\t\t\t       ceph_vinop(inode), peer, ocap->seq,\n\t\t\t       ocap->mseq, mds, le32_to_cpu(ph->seq),\n\t\t\t       le32_to_cpu(ph->mseq));\n\t\t}\n\t\t__ceph_remove_cap(ocap, (ph->flags & CEPH_CAP_FLAG_RELEASE));\n\t}\n\n\t/* make sure we re-request max_size, if necessary */\n\tci->i_wanted_max_size = 0;\n\tci->i_requested_max_size = 0;\n\n\t*old_issued = issued;\n\t*target_cap = cap;\n}"
  },
  {
    "function_name": "handle_cap_export",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "2850-2961",
    "snippet": "static void handle_cap_export(struct inode *inode, struct ceph_mds_caps *ex,\n\t\t\t      struct ceph_mds_cap_peer *ph,\n\t\t\t      struct ceph_mds_session *session)\n{\n\tstruct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;\n\tstruct ceph_mds_session *tsession = NULL;\n\tstruct ceph_cap *cap, *tcap, *new_cap = NULL;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tu64 t_cap_id;\n\tunsigned mseq = le32_to_cpu(ex->migrate_seq);\n\tunsigned t_seq, t_mseq;\n\tint target, issued;\n\tint mds = session->s_mds;\n\n\tif (ph) {\n\t\tt_cap_id = le64_to_cpu(ph->cap_id);\n\t\tt_seq = le32_to_cpu(ph->seq);\n\t\tt_mseq = le32_to_cpu(ph->mseq);\n\t\ttarget = le32_to_cpu(ph->mds);\n\t} else {\n\t\tt_cap_id = t_seq = t_mseq = 0;\n\t\ttarget = -1;\n\t}\n\n\tdout(\"handle_cap_export inode %p ci %p mds%d mseq %d target %d\\n\",\n\t     inode, ci, mds, mseq, target);\nretry:\n\tspin_lock(&ci->i_ceph_lock);\n\tcap = __get_cap_for_mds(ci, mds);\n\tif (!cap || cap->cap_id != le64_to_cpu(ex->cap_id))\n\t\tgoto out_unlock;\n\n\tif (target < 0) {\n\t\t__ceph_remove_cap(cap, false);\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * now we know we haven't received the cap import message yet\n\t * because the exported cap still exist.\n\t */\n\n\tissued = cap->issued;\n\tWARN_ON(issued != cap->implemented);\n\n\ttcap = __get_cap_for_mds(ci, target);\n\tif (tcap) {\n\t\t/* already have caps from the target */\n\t\tif (tcap->cap_id != t_cap_id ||\n\t\t    ceph_seq_cmp(tcap->seq, t_seq) < 0) {\n\t\t\tdout(\" updating import cap %p mds%d\\n\", tcap, target);\n\t\t\ttcap->cap_id = t_cap_id;\n\t\t\ttcap->seq = t_seq - 1;\n\t\t\ttcap->issue_seq = t_seq - 1;\n\t\t\ttcap->mseq = t_mseq;\n\t\t\ttcap->issued |= issued;\n\t\t\ttcap->implemented |= issued;\n\t\t\tif (cap == ci->i_auth_cap)\n\t\t\t\tci->i_auth_cap = tcap;\n\t\t\tif (ci->i_flushing_caps && ci->i_auth_cap == tcap) {\n\t\t\t\tspin_lock(&mdsc->cap_dirty_lock);\n\t\t\t\tlist_move_tail(&ci->i_flushing_item,\n\t\t\t\t\t       &tcap->session->s_cap_flushing);\n\t\t\t\tspin_unlock(&mdsc->cap_dirty_lock);\n\t\t\t}\n\t\t}\n\t\t__ceph_remove_cap(cap, false);\n\t\tgoto out_unlock;\n\t} else if (tsession) {\n\t\t/* add placeholder for the export tagert */\n\t\tint flag = (cap == ci->i_auth_cap) ? CEPH_CAP_FLAG_AUTH : 0;\n\t\tceph_add_cap(inode, tsession, t_cap_id, -1, issued, 0,\n\t\t\t     t_seq - 1, t_mseq, (u64)-1, flag, &new_cap);\n\n\t\t__ceph_remove_cap(cap, false);\n\t\tgoto out_unlock;\n\t}\n\n\tspin_unlock(&ci->i_ceph_lock);\n\tmutex_unlock(&session->s_mutex);\n\n\t/* open target session */\n\ttsession = ceph_mdsc_open_export_target_session(mdsc, target);\n\tif (!IS_ERR(tsession)) {\n\t\tif (mds > target) {\n\t\t\tmutex_lock(&session->s_mutex);\n\t\t\tmutex_lock_nested(&tsession->s_mutex,\n\t\t\t\t\t  SINGLE_DEPTH_NESTING);\n\t\t} else {\n\t\t\tmutex_lock(&tsession->s_mutex);\n\t\t\tmutex_lock_nested(&session->s_mutex,\n\t\t\t\t\t  SINGLE_DEPTH_NESTING);\n\t\t}\n\t\tceph_add_cap_releases(mdsc, tsession);\n\t\tnew_cap = ceph_get_cap(mdsc, NULL);\n\t} else {\n\t\tWARN_ON(1);\n\t\ttsession = NULL;\n\t\ttarget = -1;\n\t}\n\tgoto retry;\n\nout_unlock:\n\tspin_unlock(&ci->i_ceph_lock);\n\tmutex_unlock(&session->s_mutex);\n\tif (tsession) {\n\t\tmutex_unlock(&tsession->s_mutex);\n\t\tceph_put_mds_session(tsession);\n\t}\n\tif (new_cap)\n\t\tceph_put_cap(mdsc, new_cap);\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_put_cap",
          "args": [
            "mdsc",
            "new_cap"
          ],
          "line": 2960
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_put_cap_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "2274-2326",
          "snippet": "void ceph_put_cap_refs(struct ceph_inode_info *ci, int had)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint last = 0, put = 0, flushsnaps = 0, wake = 0;\n\tstruct ceph_cap_snap *capsnap;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (had & CEPH_CAP_PIN)\n\t\t--ci->i_pin_ref;\n\tif (had & CEPH_CAP_FILE_RD)\n\t\tif (--ci->i_rd_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_CACHE)\n\t\tif (--ci->i_rdcache_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_BUFFER) {\n\t\tif (--ci->i_wb_ref == 0) {\n\t\t\tlast++;\n\t\t\tput++;\n\t\t}\n\t\tdout(\"put_cap_refs %p wb %d -> %d (?)\\n\",\n\t\t     inode, ci->i_wb_ref+1, ci->i_wb_ref);\n\t}\n\tif (had & CEPH_CAP_FILE_WR)\n\t\tif (--ci->i_wr_ref == 0) {\n\t\t\tlast++;\n\t\t\tif (!list_empty(&ci->i_cap_snaps)) {\n\t\t\t\tcapsnap = list_first_entry(&ci->i_cap_snaps,\n\t\t\t\t\t\t     struct ceph_cap_snap,\n\t\t\t\t\t\t     ci_item);\n\t\t\t\tif (capsnap->writing) {\n\t\t\t\t\tcapsnap->writing = 0;\n\t\t\t\t\tflushsnaps =\n\t\t\t\t\t\t__ceph_finish_cap_snap(ci,\n\t\t\t\t\t\t\t\t       capsnap);\n\t\t\t\t\twake = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tdout(\"put_cap_refs %p had %s%s%s\\n\", inode, ceph_cap_string(had),\n\t     last ? \" last\" : \"\", put ? \" put\" : \"\");\n\n\tif (last && !flushsnaps)\n\t\tceph_check_caps(ci, 0, NULL);\n\telse if (flushsnaps)\n\t\tceph_flush_snaps(ci);\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\tif (put)\n\t\tiput(inode);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_put_cap_refs(struct ceph_inode_info *ci, int had)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint last = 0, put = 0, flushsnaps = 0, wake = 0;\n\tstruct ceph_cap_snap *capsnap;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (had & CEPH_CAP_PIN)\n\t\t--ci->i_pin_ref;\n\tif (had & CEPH_CAP_FILE_RD)\n\t\tif (--ci->i_rd_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_CACHE)\n\t\tif (--ci->i_rdcache_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_BUFFER) {\n\t\tif (--ci->i_wb_ref == 0) {\n\t\t\tlast++;\n\t\t\tput++;\n\t\t}\n\t\tdout(\"put_cap_refs %p wb %d -> %d (?)\\n\",\n\t\t     inode, ci->i_wb_ref+1, ci->i_wb_ref);\n\t}\n\tif (had & CEPH_CAP_FILE_WR)\n\t\tif (--ci->i_wr_ref == 0) {\n\t\t\tlast++;\n\t\t\tif (!list_empty(&ci->i_cap_snaps)) {\n\t\t\t\tcapsnap = list_first_entry(&ci->i_cap_snaps,\n\t\t\t\t\t\t     struct ceph_cap_snap,\n\t\t\t\t\t\t     ci_item);\n\t\t\t\tif (capsnap->writing) {\n\t\t\t\t\tcapsnap->writing = 0;\n\t\t\t\t\tflushsnaps =\n\t\t\t\t\t\t__ceph_finish_cap_snap(ci,\n\t\t\t\t\t\t\t\t       capsnap);\n\t\t\t\t\twake = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tdout(\"put_cap_refs %p had %s%s%s\\n\", inode, ceph_cap_string(had),\n\t     last ? \" last\" : \"\", put ? \" put\" : \"\");\n\n\tif (last && !flushsnaps)\n\t\tceph_check_caps(ci, 0, NULL);\n\telse if (flushsnaps)\n\t\tceph_flush_snaps(ci);\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\tif (put)\n\t\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_put_mds_session",
          "args": [
            "tsession"
          ],
          "line": 2957
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_put_mds_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "374-385",
          "snippet": "void ceph_put_mds_session(struct ceph_mds_session *s)\n{\n\tdout(\"mdsc put_session %p %d -> %d\\n\", s,\n\t     atomic_read(&s->s_ref), atomic_read(&s->s_ref)-1);\n\tif (atomic_dec_and_test(&s->s_ref)) {\n\t\tif (s->s_auth.authorizer)\n\t\t\tceph_auth_destroy_authorizer(\n\t\t\t\ts->s_mdsc->fsc->client->monc.auth,\n\t\t\t\ts->s_auth.authorizer);\n\t\tkfree(s);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_put_mds_session(struct ceph_mds_session *s)\n{\n\tdout(\"mdsc put_session %p %d -> %d\\n\", s,\n\t     atomic_read(&s->s_ref), atomic_read(&s->s_ref)-1);\n\tif (atomic_dec_and_test(&s->s_ref)) {\n\t\tif (s->s_auth.authorizer)\n\t\t\tceph_auth_destroy_authorizer(\n\t\t\t\ts->s_mdsc->fsc->client->monc.auth,\n\t\t\t\ts->s_auth.authorizer);\n\t\tkfree(s);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&tsession->s_mutex"
          ],
          "line": 2956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&session->s_mutex"
          ],
          "line": 2954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 2953
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 2946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_get_cap",
          "args": [
            "mdsc",
            "NULL"
          ],
          "line": 2944
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_get_cap_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "2258-2263",
          "snippet": "void ceph_get_cap_refs(struct ceph_inode_info *ci, int caps)\n{\n\tspin_lock(&ci->i_ceph_lock);\n\t__take_cap_refs(ci, caps);\n\tspin_unlock(&ci->i_ceph_lock);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_get_cap_refs(struct ceph_inode_info *ci, int caps)\n{\n\tspin_lock(&ci->i_ceph_lock);\n\t__take_cap_refs(ci, caps);\n\tspin_unlock(&ci->i_ceph_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_add_cap_releases",
          "args": [
            "mdsc",
            "tsession"
          ],
          "line": 2943
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_add_cap_releases",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1412-1468",
          "snippet": "int ceph_add_cap_releases(struct ceph_mds_client *mdsc,\n\t\t\t  struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *msg, *partial = NULL;\n\tstruct ceph_mds_cap_release *head;\n\tint err = -ENOMEM;\n\tint extra = mdsc->fsc->mount_options->cap_release_safety;\n\tint num;\n\n\tdout(\"add_cap_releases %p mds%d extra %d\\n\", session, session->s_mds,\n\t     extra);\n\n\tspin_lock(&session->s_cap_lock);\n\n\tif (!list_empty(&session->s_cap_releases)) {\n\t\tmsg = list_first_entry(&session->s_cap_releases,\n\t\t\t\t       struct ceph_msg,\n\t\t\t\t list_head);\n\t\thead = msg->front.iov_base;\n\t\tnum = le32_to_cpu(head->num);\n\t\tif (num) {\n\t\t\tdout(\" partial %p with (%d/%d)\\n\", msg, num,\n\t\t\t     (int)CEPH_CAPS_PER_RELEASE);\n\t\t\textra += CEPH_CAPS_PER_RELEASE - num;\n\t\t\tpartial = msg;\n\t\t}\n\t}\n\twhile (session->s_num_cap_releases < session->s_nr_caps + extra) {\n\t\tspin_unlock(&session->s_cap_lock);\n\t\tmsg = ceph_msg_new(CEPH_MSG_CLIENT_CAPRELEASE, PAGE_CACHE_SIZE,\n\t\t\t\t   GFP_NOFS, false);\n\t\tif (!msg)\n\t\t\tgoto out_unlocked;\n\t\tdout(\"add_cap_releases %p msg %p now %d\\n\", session, msg,\n\t\t     (int)msg->front.iov_len);\n\t\thead = msg->front.iov_base;\n\t\thead->num = cpu_to_le32(0);\n\t\tmsg->front.iov_len = sizeof(*head);\n\t\tspin_lock(&session->s_cap_lock);\n\t\tlist_add(&msg->list_head, &session->s_cap_releases);\n\t\tsession->s_num_cap_releases += CEPH_CAPS_PER_RELEASE;\n\t}\n\n\tif (partial) {\n\t\thead = partial->front.iov_base;\n\t\tnum = le32_to_cpu(head->num);\n\t\tdout(\" queueing partial %p with %d/%d\\n\", partial, num,\n\t\t     (int)CEPH_CAPS_PER_RELEASE);\n\t\tlist_move_tail(&partial->list_head,\n\t\t\t       &session->s_cap_releases_done);\n\t\tsession->s_num_cap_releases -= CEPH_CAPS_PER_RELEASE - num;\n\t}\n\terr = 0;\n\tspin_unlock(&session->s_cap_lock);\nout_unlocked:\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);\n\nint ceph_add_cap_releases(struct ceph_mds_client *mdsc,\n\t\t\t  struct ceph_mds_session *session)\n{\n\tstruct ceph_msg *msg, *partial = NULL;\n\tstruct ceph_mds_cap_release *head;\n\tint err = -ENOMEM;\n\tint extra = mdsc->fsc->mount_options->cap_release_safety;\n\tint num;\n\n\tdout(\"add_cap_releases %p mds%d extra %d\\n\", session, session->s_mds,\n\t     extra);\n\n\tspin_lock(&session->s_cap_lock);\n\n\tif (!list_empty(&session->s_cap_releases)) {\n\t\tmsg = list_first_entry(&session->s_cap_releases,\n\t\t\t\t       struct ceph_msg,\n\t\t\t\t list_head);\n\t\thead = msg->front.iov_base;\n\t\tnum = le32_to_cpu(head->num);\n\t\tif (num) {\n\t\t\tdout(\" partial %p with (%d/%d)\\n\", msg, num,\n\t\t\t     (int)CEPH_CAPS_PER_RELEASE);\n\t\t\textra += CEPH_CAPS_PER_RELEASE - num;\n\t\t\tpartial = msg;\n\t\t}\n\t}\n\twhile (session->s_num_cap_releases < session->s_nr_caps + extra) {\n\t\tspin_unlock(&session->s_cap_lock);\n\t\tmsg = ceph_msg_new(CEPH_MSG_CLIENT_CAPRELEASE, PAGE_CACHE_SIZE,\n\t\t\t\t   GFP_NOFS, false);\n\t\tif (!msg)\n\t\t\tgoto out_unlocked;\n\t\tdout(\"add_cap_releases %p msg %p now %d\\n\", session, msg,\n\t\t     (int)msg->front.iov_len);\n\t\thead = msg->front.iov_base;\n\t\thead->num = cpu_to_le32(0);\n\t\tmsg->front.iov_len = sizeof(*head);\n\t\tspin_lock(&session->s_cap_lock);\n\t\tlist_add(&msg->list_head, &session->s_cap_releases);\n\t\tsession->s_num_cap_releases += CEPH_CAPS_PER_RELEASE;\n\t}\n\n\tif (partial) {\n\t\thead = partial->front.iov_base;\n\t\tnum = le32_to_cpu(head->num);\n\t\tdout(\" queueing partial %p with %d/%d\\n\", partial, num,\n\t\t     (int)CEPH_CAPS_PER_RELEASE);\n\t\tlist_move_tail(&partial->list_head,\n\t\t\t       &session->s_cap_releases_done);\n\t\tsession->s_num_cap_releases -= CEPH_CAPS_PER_RELEASE - num;\n\t}\n\terr = 0;\n\tspin_unlock(&session->s_cap_lock);\nout_unlocked:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&session->s_mutex",
            "SINGLE_DEPTH_NESTING"
          ],
          "line": 2940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&tsession->s_mutex"
          ],
          "line": 2939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&tsession->s_mutex",
            "SINGLE_DEPTH_NESTING"
          ],
          "line": 2936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&session->s_mutex"
          ],
          "line": 2935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tsession"
          ],
          "line": 2933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_open_export_target_session",
          "args": [
            "mdsc",
            "target"
          ],
          "line": 2932
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_open_export_target_sessions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "989-995",
          "snippet": "void ceph_mdsc_open_export_target_sessions(struct ceph_mds_client *mdsc,\n\t\t\t\t\t   struct ceph_mds_session *session)\n{\n\tmutex_lock(&mdsc->mutex);\n\t__open_export_target_sessions(mdsc, session);\n\tmutex_unlock(&mdsc->mutex);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_mdsc_open_export_target_sessions(struct ceph_mds_client *mdsc,\n\t\t\t\t\t   struct ceph_mds_session *session)\n{\n\tmutex_lock(&mdsc->mutex);\n\t__open_export_target_sessions(mdsc, session);\n\tmutex_unlock(&mdsc->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&session->s_mutex"
          ],
          "line": 2929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ceph_remove_cap",
          "args": [
            "cap",
            "false"
          ],
          "line": 2924
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_remove_cap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "905-960",
          "snippet": "void __ceph_remove_cap(struct ceph_cap *cap, bool queue_release)\n{\n\tstruct ceph_mds_session *session = cap->session;\n\tstruct ceph_inode_info *ci = cap->ci;\n\tstruct ceph_mds_client *mdsc =\n\t\tceph_sb_to_client(ci->vfs_inode.i_sb)->mdsc;\n\tint removed = 0;\n\n\tdout(\"__ceph_remove_cap %p from %p\\n\", cap, &ci->vfs_inode);\n\n\t/* remove from session list */\n\tspin_lock(&session->s_cap_lock);\n\t/*\n\t * s_cap_reconnect is protected by s_cap_lock. no one changes\n\t * s_cap_gen while session is in the reconnect state.\n\t */\n\tif (queue_release &&\n\t    (!session->s_cap_reconnect ||\n\t     cap->cap_gen == session->s_cap_gen))\n\t\t__queue_cap_release(session, ci->i_vino.ino, cap->cap_id,\n\t\t\t\t    cap->mseq, cap->issue_seq);\n\n\tif (session->s_cap_iterator == cap) {\n\t\t/* not yet, we are iterating over this very cap */\n\t\tdout(\"__ceph_remove_cap  delaying %p removal from session %p\\n\",\n\t\t     cap, cap->session);\n\t} else {\n\t\tlist_del_init(&cap->session_caps);\n\t\tsession->s_nr_caps--;\n\t\tcap->session = NULL;\n\t\tremoved = 1;\n\t}\n\t/* protect backpointer with s_cap_lock: see iterate_session_caps */\n\tcap->ci = NULL;\n\tspin_unlock(&session->s_cap_lock);\n\n\t/* remove from inode list */\n\trb_erase(&cap->ci_node, &ci->i_caps);\n\tif (ci->i_auth_cap == cap)\n\t\tci->i_auth_cap = NULL;\n\n\tif (removed)\n\t\tceph_put_cap(mdsc, cap);\n\n\tif (!__ceph_is_any_caps(ci) && ci->i_snap_realm) {\n\t\tstruct ceph_snap_realm *realm = ci->i_snap_realm;\n\t\tspin_lock(&realm->inodes_with_caps_lock);\n\t\tlist_del_init(&ci->i_snap_realm_item);\n\t\tci->i_snap_realm_counter++;\n\t\tci->i_snap_realm = NULL;\n\t\tspin_unlock(&realm->inodes_with_caps_lock);\n\t\tceph_put_snap_realm(mdsc, realm);\n\t}\n\tif (!__ceph_is_any_real_caps(ci))\n\t\t__cap_delay_cancel(mdsc, ci);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid __ceph_remove_cap(struct ceph_cap *cap, bool queue_release)\n{\n\tstruct ceph_mds_session *session = cap->session;\n\tstruct ceph_inode_info *ci = cap->ci;\n\tstruct ceph_mds_client *mdsc =\n\t\tceph_sb_to_client(ci->vfs_inode.i_sb)->mdsc;\n\tint removed = 0;\n\n\tdout(\"__ceph_remove_cap %p from %p\\n\", cap, &ci->vfs_inode);\n\n\t/* remove from session list */\n\tspin_lock(&session->s_cap_lock);\n\t/*\n\t * s_cap_reconnect is protected by s_cap_lock. no one changes\n\t * s_cap_gen while session is in the reconnect state.\n\t */\n\tif (queue_release &&\n\t    (!session->s_cap_reconnect ||\n\t     cap->cap_gen == session->s_cap_gen))\n\t\t__queue_cap_release(session, ci->i_vino.ino, cap->cap_id,\n\t\t\t\t    cap->mseq, cap->issue_seq);\n\n\tif (session->s_cap_iterator == cap) {\n\t\t/* not yet, we are iterating over this very cap */\n\t\tdout(\"__ceph_remove_cap  delaying %p removal from session %p\\n\",\n\t\t     cap, cap->session);\n\t} else {\n\t\tlist_del_init(&cap->session_caps);\n\t\tsession->s_nr_caps--;\n\t\tcap->session = NULL;\n\t\tremoved = 1;\n\t}\n\t/* protect backpointer with s_cap_lock: see iterate_session_caps */\n\tcap->ci = NULL;\n\tspin_unlock(&session->s_cap_lock);\n\n\t/* remove from inode list */\n\trb_erase(&cap->ci_node, &ci->i_caps);\n\tif (ci->i_auth_cap == cap)\n\t\tci->i_auth_cap = NULL;\n\n\tif (removed)\n\t\tceph_put_cap(mdsc, cap);\n\n\tif (!__ceph_is_any_caps(ci) && ci->i_snap_realm) {\n\t\tstruct ceph_snap_realm *realm = ci->i_snap_realm;\n\t\tspin_lock(&realm->inodes_with_caps_lock);\n\t\tlist_del_init(&ci->i_snap_realm_item);\n\t\tci->i_snap_realm_counter++;\n\t\tci->i_snap_realm = NULL;\n\t\tspin_unlock(&realm->inodes_with_caps_lock);\n\t\tceph_put_snap_realm(mdsc, realm);\n\t}\n\tif (!__ceph_is_any_real_caps(ci))\n\t\t__cap_delay_cancel(mdsc, ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_add_cap",
          "args": [
            "inode",
            "tsession",
            "t_cap_id",
            "-1",
            "issued",
            "0",
            "t_seq - 1",
            "t_mseq",
            "(u64)-1",
            "flag",
            "&new_cap"
          ],
          "line": 2921
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_add_cap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "511-635",
          "snippet": "void ceph_add_cap(struct inode *inode,\n\t\t  struct ceph_mds_session *session, u64 cap_id,\n\t\t  int fmode, unsigned issued, unsigned wanted,\n\t\t  unsigned seq, unsigned mseq, u64 realmino, int flags,\n\t\t  struct ceph_cap **new_cap)\n{\n\tstruct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_cap *cap;\n\tint mds = session->s_mds;\n\tint actual_wanted;\n\n\tdout(\"add_cap %p mds%d cap %llx %s seq %d\\n\", inode,\n\t     session->s_mds, cap_id, ceph_cap_string(issued), seq);\n\n\t/*\n\t * If we are opening the file, include file mode wanted bits\n\t * in wanted.\n\t */\n\tif (fmode >= 0)\n\t\twanted |= ceph_caps_for_mode(fmode);\n\n\tcap = __get_cap_for_mds(ci, mds);\n\tif (!cap) {\n\t\tcap = *new_cap;\n\t\t*new_cap = NULL;\n\n\t\tcap->issued = 0;\n\t\tcap->implemented = 0;\n\t\tcap->mds = mds;\n\t\tcap->mds_wanted = 0;\n\t\tcap->mseq = 0;\n\n\t\tcap->ci = ci;\n\t\t__insert_cap_node(ci, cap);\n\n\t\t/* add to session cap list */\n\t\tcap->session = session;\n\t\tspin_lock(&session->s_cap_lock);\n\t\tlist_add_tail(&cap->session_caps, &session->s_caps);\n\t\tsession->s_nr_caps++;\n\t\tspin_unlock(&session->s_cap_lock);\n\t} else {\n\t\t/*\n\t\t * auth mds of the inode changed. we received the cap export\n\t\t * message, but still haven't received the cap import message.\n\t\t * handle_cap_export() updated the new auth MDS' cap.\n\t\t *\n\t\t * \"ceph_seq_cmp(seq, cap->seq) <= 0\" means we are processing\n\t\t * a message that was send before the cap import message. So\n\t\t * don't remove caps.\n\t\t */\n\t\tif (ceph_seq_cmp(seq, cap->seq) <= 0) {\n\t\t\tWARN_ON(cap != ci->i_auth_cap);\n\t\t\tWARN_ON(cap->cap_id != cap_id);\n\t\t\tseq = cap->seq;\n\t\t\tmseq = cap->mseq;\n\t\t\tissued |= cap->issued;\n\t\t\tflags |= CEPH_CAP_FLAG_AUTH;\n\t\t}\n\t}\n\n\tif (!ci->i_snap_realm) {\n\t\t/*\n\t\t * add this inode to the appropriate snap realm\n\t\t */\n\t\tstruct ceph_snap_realm *realm = ceph_lookup_snap_realm(mdsc,\n\t\t\t\t\t\t\t       realmino);\n\t\tif (realm) {\n\t\t\tspin_lock(&realm->inodes_with_caps_lock);\n\t\t\tci->i_snap_realm = realm;\n\t\t\tlist_add(&ci->i_snap_realm_item,\n\t\t\t\t &realm->inodes_with_caps);\n\t\t\tspin_unlock(&realm->inodes_with_caps_lock);\n\t\t} else {\n\t\t\tpr_err(\"ceph_add_cap: couldn't find snap realm %llx\\n\",\n\t\t\t       realmino);\n\t\t\tWARN_ON(!realm);\n\t\t}\n\t}\n\n\t__check_cap_issue(ci, cap, issued);\n\n\t/*\n\t * If we are issued caps we don't want, or the mds' wanted\n\t * value appears to be off, queue a check so we'll release\n\t * later and/or update the mds wanted value.\n\t */\n\tactual_wanted = __ceph_caps_wanted(ci);\n\tif ((wanted & ~actual_wanted) ||\n\t    (issued & ~actual_wanted & CEPH_CAP_ANY_WR)) {\n\t\tdout(\" issued %s, mds wanted %s, actual %s, queueing\\n\",\n\t\t     ceph_cap_string(issued), ceph_cap_string(wanted),\n\t\t     ceph_cap_string(actual_wanted));\n\t\t__cap_delay_requeue(mdsc, ci);\n\t}\n\n\tif (flags & CEPH_CAP_FLAG_AUTH) {\n\t\tif (ci->i_auth_cap == NULL ||\n\t\t    ceph_seq_cmp(ci->i_auth_cap->mseq, mseq) < 0) {\n\t\t\tci->i_auth_cap = cap;\n\t\t\tcap->mds_wanted = wanted;\n\t\t}\n\t} else {\n\t\tWARN_ON(ci->i_auth_cap == cap);\n\t}\n\n\tdout(\"add_cap inode %p (%llx.%llx) cap %p %s now %s seq %d mds%d\\n\",\n\t     inode, ceph_vinop(inode), cap, ceph_cap_string(issued),\n\t     ceph_cap_string(issued|cap->issued), seq, mds);\n\tcap->cap_id = cap_id;\n\tcap->issued = issued;\n\tcap->implemented |= issued;\n\tif (ceph_seq_cmp(mseq, cap->mseq) > 0)\n\t\tcap->mds_wanted = wanted;\n\telse\n\t\tcap->mds_wanted |= wanted;\n\tcap->seq = seq;\n\tcap->issue_seq = seq;\n\tcap->mseq = mseq;\n\tcap->cap_gen = session->s_cap_gen;\n\n\tif (fmode >= 0)\n\t\t__ceph_get_fmode(ci, fmode);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_add_cap(struct inode *inode,\n\t\t  struct ceph_mds_session *session, u64 cap_id,\n\t\t  int fmode, unsigned issued, unsigned wanted,\n\t\t  unsigned seq, unsigned mseq, u64 realmino, int flags,\n\t\t  struct ceph_cap **new_cap)\n{\n\tstruct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_cap *cap;\n\tint mds = session->s_mds;\n\tint actual_wanted;\n\n\tdout(\"add_cap %p mds%d cap %llx %s seq %d\\n\", inode,\n\t     session->s_mds, cap_id, ceph_cap_string(issued), seq);\n\n\t/*\n\t * If we are opening the file, include file mode wanted bits\n\t * in wanted.\n\t */\n\tif (fmode >= 0)\n\t\twanted |= ceph_caps_for_mode(fmode);\n\n\tcap = __get_cap_for_mds(ci, mds);\n\tif (!cap) {\n\t\tcap = *new_cap;\n\t\t*new_cap = NULL;\n\n\t\tcap->issued = 0;\n\t\tcap->implemented = 0;\n\t\tcap->mds = mds;\n\t\tcap->mds_wanted = 0;\n\t\tcap->mseq = 0;\n\n\t\tcap->ci = ci;\n\t\t__insert_cap_node(ci, cap);\n\n\t\t/* add to session cap list */\n\t\tcap->session = session;\n\t\tspin_lock(&session->s_cap_lock);\n\t\tlist_add_tail(&cap->session_caps, &session->s_caps);\n\t\tsession->s_nr_caps++;\n\t\tspin_unlock(&session->s_cap_lock);\n\t} else {\n\t\t/*\n\t\t * auth mds of the inode changed. we received the cap export\n\t\t * message, but still haven't received the cap import message.\n\t\t * handle_cap_export() updated the new auth MDS' cap.\n\t\t *\n\t\t * \"ceph_seq_cmp(seq, cap->seq) <= 0\" means we are processing\n\t\t * a message that was send before the cap import message. So\n\t\t * don't remove caps.\n\t\t */\n\t\tif (ceph_seq_cmp(seq, cap->seq) <= 0) {\n\t\t\tWARN_ON(cap != ci->i_auth_cap);\n\t\t\tWARN_ON(cap->cap_id != cap_id);\n\t\t\tseq = cap->seq;\n\t\t\tmseq = cap->mseq;\n\t\t\tissued |= cap->issued;\n\t\t\tflags |= CEPH_CAP_FLAG_AUTH;\n\t\t}\n\t}\n\n\tif (!ci->i_snap_realm) {\n\t\t/*\n\t\t * add this inode to the appropriate snap realm\n\t\t */\n\t\tstruct ceph_snap_realm *realm = ceph_lookup_snap_realm(mdsc,\n\t\t\t\t\t\t\t       realmino);\n\t\tif (realm) {\n\t\t\tspin_lock(&realm->inodes_with_caps_lock);\n\t\t\tci->i_snap_realm = realm;\n\t\t\tlist_add(&ci->i_snap_realm_item,\n\t\t\t\t &realm->inodes_with_caps);\n\t\t\tspin_unlock(&realm->inodes_with_caps_lock);\n\t\t} else {\n\t\t\tpr_err(\"ceph_add_cap: couldn't find snap realm %llx\\n\",\n\t\t\t       realmino);\n\t\t\tWARN_ON(!realm);\n\t\t}\n\t}\n\n\t__check_cap_issue(ci, cap, issued);\n\n\t/*\n\t * If we are issued caps we don't want, or the mds' wanted\n\t * value appears to be off, queue a check so we'll release\n\t * later and/or update the mds wanted value.\n\t */\n\tactual_wanted = __ceph_caps_wanted(ci);\n\tif ((wanted & ~actual_wanted) ||\n\t    (issued & ~actual_wanted & CEPH_CAP_ANY_WR)) {\n\t\tdout(\" issued %s, mds wanted %s, actual %s, queueing\\n\",\n\t\t     ceph_cap_string(issued), ceph_cap_string(wanted),\n\t\t     ceph_cap_string(actual_wanted));\n\t\t__cap_delay_requeue(mdsc, ci);\n\t}\n\n\tif (flags & CEPH_CAP_FLAG_AUTH) {\n\t\tif (ci->i_auth_cap == NULL ||\n\t\t    ceph_seq_cmp(ci->i_auth_cap->mseq, mseq) < 0) {\n\t\t\tci->i_auth_cap = cap;\n\t\t\tcap->mds_wanted = wanted;\n\t\t}\n\t} else {\n\t\tWARN_ON(ci->i_auth_cap == cap);\n\t}\n\n\tdout(\"add_cap inode %p (%llx.%llx) cap %p %s now %s seq %d mds%d\\n\",\n\t     inode, ceph_vinop(inode), cap, ceph_cap_string(issued),\n\t     ceph_cap_string(issued|cap->issued), seq, mds);\n\tcap->cap_id = cap_id;\n\tcap->issued = issued;\n\tcap->implemented |= issued;\n\tif (ceph_seq_cmp(mseq, cap->mseq) > 0)\n\t\tcap->mds_wanted = wanted;\n\telse\n\t\tcap->mds_wanted |= wanted;\n\tcap->seq = seq;\n\tcap->issue_seq = seq;\n\tcap->mseq = mseq;\n\tcap->cap_gen = session->s_cap_gen;\n\n\tif (fmode >= 0)\n\t\t__ceph_get_fmode(ci, fmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&ci->i_flushing_item",
            "&tcap->session->s_cap_flushing"
          ],
          "line": 2911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mdsc->cap_dirty_lock"
          ],
          "line": 2910
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" updating import cap %p mds%d\\n\"",
            "tcap",
            "target"
          ],
          "line": 2900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_seq_cmp",
          "args": [
            "tcap->seq",
            "t_seq"
          ],
          "line": 2899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_cap_for_mds",
          "args": [
            "ci",
            "target"
          ],
          "line": 2895
        },
        "resolved": true,
        "details": {
          "function_name": "__get_cap_for_mds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "310-325",
          "snippet": "static struct ceph_cap *__get_cap_for_mds(struct ceph_inode_info *ci, int mds)\n{\n\tstruct ceph_cap *cap;\n\tstruct rb_node *n = ci->i_caps.rb_node;\n\n\twhile (n) {\n\t\tcap = rb_entry(n, struct ceph_cap, ci_node);\n\t\tif (mds < cap->mds)\n\t\t\tn = n->rb_left;\n\t\telse if (mds > cap->mds)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn cap;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_cap *__get_cap_for_mds(struct ceph_inode_info *ci, int mds)\n{\n\tstruct ceph_cap *cap;\n\tstruct rb_node *n = ci->i_caps.rb_node;\n\n\twhile (n) {\n\t\tcap = rb_entry(n, struct ceph_cap, ci_node);\n\t\tif (mds < cap->mds)\n\t\t\tn = n->rb_left;\n\t\telse if (mds > cap->mds)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn cap;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "issued != cap->implemented"
          ],
          "line": 2893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "ex->cap_id"
          ],
          "line": 2879
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"handle_cap_export inode %p ci %p mds%d mseq %d target %d\\n\"",
            "inode",
            "ci",
            "mds",
            "mseq",
            "target"
          ],
          "line": 2874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ph->mds"
          ],
          "line": 2868
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 2857
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void handle_cap_export(struct inode *inode, struct ceph_mds_caps *ex,\n\t\t\t      struct ceph_mds_cap_peer *ph,\n\t\t\t      struct ceph_mds_session *session)\n{\n\tstruct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;\n\tstruct ceph_mds_session *tsession = NULL;\n\tstruct ceph_cap *cap, *tcap, *new_cap = NULL;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tu64 t_cap_id;\n\tunsigned mseq = le32_to_cpu(ex->migrate_seq);\n\tunsigned t_seq, t_mseq;\n\tint target, issued;\n\tint mds = session->s_mds;\n\n\tif (ph) {\n\t\tt_cap_id = le64_to_cpu(ph->cap_id);\n\t\tt_seq = le32_to_cpu(ph->seq);\n\t\tt_mseq = le32_to_cpu(ph->mseq);\n\t\ttarget = le32_to_cpu(ph->mds);\n\t} else {\n\t\tt_cap_id = t_seq = t_mseq = 0;\n\t\ttarget = -1;\n\t}\n\n\tdout(\"handle_cap_export inode %p ci %p mds%d mseq %d target %d\\n\",\n\t     inode, ci, mds, mseq, target);\nretry:\n\tspin_lock(&ci->i_ceph_lock);\n\tcap = __get_cap_for_mds(ci, mds);\n\tif (!cap || cap->cap_id != le64_to_cpu(ex->cap_id))\n\t\tgoto out_unlock;\n\n\tif (target < 0) {\n\t\t__ceph_remove_cap(cap, false);\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * now we know we haven't received the cap import message yet\n\t * because the exported cap still exist.\n\t */\n\n\tissued = cap->issued;\n\tWARN_ON(issued != cap->implemented);\n\n\ttcap = __get_cap_for_mds(ci, target);\n\tif (tcap) {\n\t\t/* already have caps from the target */\n\t\tif (tcap->cap_id != t_cap_id ||\n\t\t    ceph_seq_cmp(tcap->seq, t_seq) < 0) {\n\t\t\tdout(\" updating import cap %p mds%d\\n\", tcap, target);\n\t\t\ttcap->cap_id = t_cap_id;\n\t\t\ttcap->seq = t_seq - 1;\n\t\t\ttcap->issue_seq = t_seq - 1;\n\t\t\ttcap->mseq = t_mseq;\n\t\t\ttcap->issued |= issued;\n\t\t\ttcap->implemented |= issued;\n\t\t\tif (cap == ci->i_auth_cap)\n\t\t\t\tci->i_auth_cap = tcap;\n\t\t\tif (ci->i_flushing_caps && ci->i_auth_cap == tcap) {\n\t\t\t\tspin_lock(&mdsc->cap_dirty_lock);\n\t\t\t\tlist_move_tail(&ci->i_flushing_item,\n\t\t\t\t\t       &tcap->session->s_cap_flushing);\n\t\t\t\tspin_unlock(&mdsc->cap_dirty_lock);\n\t\t\t}\n\t\t}\n\t\t__ceph_remove_cap(cap, false);\n\t\tgoto out_unlock;\n\t} else if (tsession) {\n\t\t/* add placeholder for the export tagert */\n\t\tint flag = (cap == ci->i_auth_cap) ? CEPH_CAP_FLAG_AUTH : 0;\n\t\tceph_add_cap(inode, tsession, t_cap_id, -1, issued, 0,\n\t\t\t     t_seq - 1, t_mseq, (u64)-1, flag, &new_cap);\n\n\t\t__ceph_remove_cap(cap, false);\n\t\tgoto out_unlock;\n\t}\n\n\tspin_unlock(&ci->i_ceph_lock);\n\tmutex_unlock(&session->s_mutex);\n\n\t/* open target session */\n\ttsession = ceph_mdsc_open_export_target_session(mdsc, target);\n\tif (!IS_ERR(tsession)) {\n\t\tif (mds > target) {\n\t\t\tmutex_lock(&session->s_mutex);\n\t\t\tmutex_lock_nested(&tsession->s_mutex,\n\t\t\t\t\t  SINGLE_DEPTH_NESTING);\n\t\t} else {\n\t\t\tmutex_lock(&tsession->s_mutex);\n\t\t\tmutex_lock_nested(&session->s_mutex,\n\t\t\t\t\t  SINGLE_DEPTH_NESTING);\n\t\t}\n\t\tceph_add_cap_releases(mdsc, tsession);\n\t\tnew_cap = ceph_get_cap(mdsc, NULL);\n\t} else {\n\t\tWARN_ON(1);\n\t\ttsession = NULL;\n\t\ttarget = -1;\n\t}\n\tgoto retry;\n\nout_unlock:\n\tspin_unlock(&ci->i_ceph_lock);\n\tmutex_unlock(&session->s_mutex);\n\tif (tsession) {\n\t\tmutex_unlock(&tsession->s_mutex);\n\t\tceph_put_mds_session(tsession);\n\t}\n\tif (new_cap)\n\t\tceph_put_cap(mdsc, new_cap);\n}"
  },
  {
    "function_name": "handle_cap_trunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "2812-2840",
    "snippet": "static void handle_cap_trunc(struct inode *inode,\n\t\t\t     struct ceph_mds_caps *trunc,\n\t\t\t     struct ceph_mds_session *session)\n\t__releases(ci->i_ceph_lock)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint mds = session->s_mds;\n\tint seq = le32_to_cpu(trunc->seq);\n\tu32 truncate_seq = le32_to_cpu(trunc->truncate_seq);\n\tu64 truncate_size = le64_to_cpu(trunc->truncate_size);\n\tu64 size = le64_to_cpu(trunc->size);\n\tint implemented = 0;\n\tint dirty = __ceph_caps_dirty(ci);\n\tint issued = __ceph_caps_issued(ceph_inode(inode), &implemented);\n\tint queue_trunc = 0;\n\n\tissued |= implemented | dirty;\n\n\tdout(\"handle_cap_trunc inode %p mds%d seq %d to %lld seq %d\\n\",\n\t     inode, mds, seq, truncate_size, truncate_seq);\n\tqueue_trunc = ceph_fill_file_size(inode, issued,\n\t\t\t\t\t  truncate_seq, truncate_size, size);\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (queue_trunc) {\n\t\tceph_queue_vmtruncate(inode);\n\t\tceph_fscache_invalidate(inode);\n\t}\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_fscache_invalidate",
          "args": [
            "inode"
          ],
          "line": 2838
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_fscache_invalidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.h",
          "lines": "148-150",
          "snippet": "static inline void ceph_fscache_invalidate(struct inode *inode)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void ceph_fscache_invalidate(struct inode *inode)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_queue_vmtruncate",
          "args": [
            "inode"
          ],
          "line": 2837
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_queue_vmtruncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "1614-1628",
          "snippet": "void ceph_queue_vmtruncate(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tihold(inode);\n\n\tif (queue_work(ceph_sb_to_client(inode->i_sb)->trunc_wq,\n\t\t       &ci->i_vmtruncate_work)) {\n\t\tdout(\"ceph_queue_vmtruncate %p\\n\", inode);\n\t} else {\n\t\tdout(\"ceph_queue_vmtruncate %p failed, pending=%d\\n\",\n\t\t     inode, ci->i_truncate_pending);\n\t\tiput(inode);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_queue_vmtruncate(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tihold(inode);\n\n\tif (queue_work(ceph_sb_to_client(inode->i_sb)->trunc_wq,\n\t\t       &ci->i_vmtruncate_work)) {\n\t\tdout(\"ceph_queue_vmtruncate %p\\n\", inode);\n\t} else {\n\t\tdout(\"ceph_queue_vmtruncate %p failed, pending=%d\\n\",\n\t\t     inode, ci->i_truncate_pending);\n\t\tiput(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 2834
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_fill_file_size",
          "args": [
            "inode",
            "issued",
            "truncate_seq",
            "truncate_size",
            "size"
          ],
          "line": 2832
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_fill_file_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "542-590",
          "snippet": "int ceph_fill_file_size(struct inode *inode, int issued,\n\t\t\tu32 truncate_seq, u64 truncate_size, u64 size)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint queue_trunc = 0;\n\n\tif (ceph_seq_cmp(truncate_seq, ci->i_truncate_seq) > 0 ||\n\t    (truncate_seq == ci->i_truncate_seq && size > inode->i_size)) {\n\t\tdout(\"size %lld -> %llu\\n\", inode->i_size, size);\n\t\tinode->i_size = size;\n\t\tinode->i_blocks = (size + (1<<9) - 1) >> 9;\n\t\tci->i_reported_size = size;\n\t\tif (truncate_seq != ci->i_truncate_seq) {\n\t\t\tdout(\"truncate_seq %u -> %u\\n\",\n\t\t\t     ci->i_truncate_seq, truncate_seq);\n\t\t\tci->i_truncate_seq = truncate_seq;\n\n\t\t\t/* the MDS should have revoked these caps */\n\t\t\tWARN_ON_ONCE(issued & (CEPH_CAP_FILE_EXCL |\n\t\t\t\t\t       CEPH_CAP_FILE_RD |\n\t\t\t\t\t       CEPH_CAP_FILE_WR |\n\t\t\t\t\t       CEPH_CAP_FILE_LAZYIO));\n\t\t\t/*\n\t\t\t * If we hold relevant caps, or in the case where we're\n\t\t\t * not the only client referencing this file and we\n\t\t\t * don't hold those caps, then we need to check whether\n\t\t\t * the file is either opened or mmaped\n\t\t\t */\n\t\t\tif ((issued & (CEPH_CAP_FILE_CACHE|\n\t\t\t\t       CEPH_CAP_FILE_BUFFER)) ||\n\t\t\t    mapping_mapped(inode->i_mapping) ||\n\t\t\t    __ceph_caps_file_wanted(ci)) {\n\t\t\t\tci->i_truncate_pending++;\n\t\t\t\tqueue_trunc = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (ceph_seq_cmp(truncate_seq, ci->i_truncate_seq) >= 0 &&\n\t    ci->i_truncate_size != truncate_size) {\n\t\tdout(\"truncate_size %lld -> %llu\\n\", ci->i_truncate_size,\n\t\t     truncate_size);\n\t\tci->i_truncate_size = truncate_size;\n\t}\n\n\tif (queue_trunc)\n\t\tceph_fscache_invalidate(inode);\n\n\treturn queue_trunc;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_fill_file_size(struct inode *inode, int issued,\n\t\t\tu32 truncate_seq, u64 truncate_size, u64 size)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint queue_trunc = 0;\n\n\tif (ceph_seq_cmp(truncate_seq, ci->i_truncate_seq) > 0 ||\n\t    (truncate_seq == ci->i_truncate_seq && size > inode->i_size)) {\n\t\tdout(\"size %lld -> %llu\\n\", inode->i_size, size);\n\t\tinode->i_size = size;\n\t\tinode->i_blocks = (size + (1<<9) - 1) >> 9;\n\t\tci->i_reported_size = size;\n\t\tif (truncate_seq != ci->i_truncate_seq) {\n\t\t\tdout(\"truncate_seq %u -> %u\\n\",\n\t\t\t     ci->i_truncate_seq, truncate_seq);\n\t\t\tci->i_truncate_seq = truncate_seq;\n\n\t\t\t/* the MDS should have revoked these caps */\n\t\t\tWARN_ON_ONCE(issued & (CEPH_CAP_FILE_EXCL |\n\t\t\t\t\t       CEPH_CAP_FILE_RD |\n\t\t\t\t\t       CEPH_CAP_FILE_WR |\n\t\t\t\t\t       CEPH_CAP_FILE_LAZYIO));\n\t\t\t/*\n\t\t\t * If we hold relevant caps, or in the case where we're\n\t\t\t * not the only client referencing this file and we\n\t\t\t * don't hold those caps, then we need to check whether\n\t\t\t * the file is either opened or mmaped\n\t\t\t */\n\t\t\tif ((issued & (CEPH_CAP_FILE_CACHE|\n\t\t\t\t       CEPH_CAP_FILE_BUFFER)) ||\n\t\t\t    mapping_mapped(inode->i_mapping) ||\n\t\t\t    __ceph_caps_file_wanted(ci)) {\n\t\t\t\tci->i_truncate_pending++;\n\t\t\t\tqueue_trunc = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (ceph_seq_cmp(truncate_seq, ci->i_truncate_seq) >= 0 &&\n\t    ci->i_truncate_size != truncate_size) {\n\t\tdout(\"truncate_size %lld -> %llu\\n\", ci->i_truncate_size,\n\t\t     truncate_size);\n\t\tci->i_truncate_size = truncate_size;\n\t}\n\n\tif (queue_trunc)\n\t\tceph_fscache_invalidate(inode);\n\n\treturn queue_trunc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"handle_cap_trunc inode %p mds%d seq %d to %lld seq %d\\n\"",
            "inode",
            "mds",
            "seq",
            "truncate_size",
            "truncate_seq"
          ],
          "line": 2830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ceph_caps_issued",
          "args": [
            "ceph_inode(inode)",
            "&implemented"
          ],
          "line": 2825
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_caps_issued_other",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "700-715",
          "snippet": "int __ceph_caps_issued_other(struct ceph_inode_info *ci, struct ceph_cap *ocap)\n{\n\tint have = ci->i_snap_caps;\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (cap == ocap)\n\t\t\tcontinue;\n\t\tif (!__cap_is_valid(cap))\n\t\t\tcontinue;\n\t\thave |= cap->issued;\n\t}\n\treturn have;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_caps_issued_other(struct ceph_inode_info *ci, struct ceph_cap *ocap)\n{\n\tint have = ci->i_snap_caps;\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (cap == ocap)\n\t\t\tcontinue;\n\t\tif (!__cap_is_valid(cap))\n\t\t\tcontinue;\n\t\thave |= cap->issued;\n\t}\n\treturn have;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 2825
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_caps_dirty",
          "args": [
            "ci"
          ],
          "line": 2824
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_caps_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "550-553",
          "snippet": "static inline int __ceph_caps_dirty(struct ceph_inode_info *ci)\n{\n\treturn ci->i_dirty_caps | ci->i_flushing_caps;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline int __ceph_caps_dirty(struct ceph_inode_info *ci)\n{\n\treturn ci->i_dirty_caps | ci->i_flushing_caps;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "trunc->size"
          ],
          "line": 2822
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "trunc->truncate_seq"
          ],
          "line": 2820
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "ci->i_ceph_lock"
          ],
          "line": 2815
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void handle_cap_trunc(struct inode *inode,\n\t\t\t     struct ceph_mds_caps *trunc,\n\t\t\t     struct ceph_mds_session *session)\n\t__releases(ci->i_ceph_lock)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint mds = session->s_mds;\n\tint seq = le32_to_cpu(trunc->seq);\n\tu32 truncate_seq = le32_to_cpu(trunc->truncate_seq);\n\tu64 truncate_size = le64_to_cpu(trunc->truncate_size);\n\tu64 size = le64_to_cpu(trunc->size);\n\tint implemented = 0;\n\tint dirty = __ceph_caps_dirty(ci);\n\tint issued = __ceph_caps_issued(ceph_inode(inode), &implemented);\n\tint queue_trunc = 0;\n\n\tissued |= implemented | dirty;\n\n\tdout(\"handle_cap_trunc inode %p mds%d seq %d to %lld seq %d\\n\",\n\t     inode, mds, seq, truncate_size, truncate_seq);\n\tqueue_trunc = ceph_fill_file_size(inode, issued,\n\t\t\t\t\t  truncate_seq, truncate_size, size);\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (queue_trunc) {\n\t\tceph_queue_vmtruncate(inode);\n\t\tceph_fscache_invalidate(inode);\n\t}\n}"
  },
  {
    "function_name": "handle_cap_flushsnap_ack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "2767-2805",
    "snippet": "static void handle_cap_flushsnap_ack(struct inode *inode, u64 flush_tid,\n\t\t\t\t     struct ceph_mds_caps *m,\n\t\t\t\t     struct ceph_mds_session *session)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tu64 follows = le64_to_cpu(m->snap_follows);\n\tstruct ceph_cap_snap *capsnap;\n\tint drop = 0;\n\n\tdout(\"handle_cap_flushsnap_ack inode %p ci %p mds%d follows %lld\\n\",\n\t     inode, ci, session->s_mds, follows);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tlist_for_each_entry(capsnap, &ci->i_cap_snaps, ci_item) {\n\t\tif (capsnap->follows == follows) {\n\t\t\tif (capsnap->flush_tid != flush_tid) {\n\t\t\t\tdout(\" cap_snap %p follows %lld tid %lld !=\"\n\t\t\t\t     \" %lld\\n\", capsnap, follows,\n\t\t\t\t     flush_tid, capsnap->flush_tid);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tWARN_ON(capsnap->dirty_pages || capsnap->writing);\n\t\t\tdout(\" removing %p cap_snap %p follows %lld\\n\",\n\t\t\t     inode, capsnap, follows);\n\t\t\tceph_put_snap_context(capsnap->context);\n\t\t\tlist_del(&capsnap->ci_item);\n\t\t\tlist_del(&capsnap->flushing_item);\n\t\t\tceph_put_cap_snap(capsnap);\n\t\t\tdrop = 1;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tdout(\" skipping cap_snap %p follows %lld\\n\",\n\t\t\t     capsnap, capsnap->follows);\n\t\t}\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\tif (drop)\n\t\tiput(inode);\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 2804
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 2802
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" skipping cap_snap %p follows %lld\\n\"",
            "capsnap",
            "capsnap->follows"
          ],
          "line": 2798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_put_cap_snap",
          "args": [
            "capsnap"
          ],
          "line": 2794
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_put_cap_snap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "167-174",
          "snippet": "static inline void ceph_put_cap_snap(struct ceph_cap_snap *capsnap)\n{\n\tif (atomic_dec_and_test(&capsnap->nref)) {\n\t\tif (capsnap->xattr_blob)\n\t\t\tceph_buffer_put(capsnap->xattr_blob);\n\t\tkfree(capsnap);\n\t}\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline void ceph_put_cap_snap(struct ceph_cap_snap *capsnap)\n{\n\tif (atomic_dec_and_test(&capsnap->nref)) {\n\t\tif (capsnap->xattr_blob)\n\t\t\tceph_buffer_put(capsnap->xattr_blob);\n\t\tkfree(capsnap);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&capsnap->flushing_item"
          ],
          "line": 2793
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_put_snap_context",
          "args": [
            "capsnap->context"
          ],
          "line": 2791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" removing %p cap_snap %p follows %lld\\n\"",
            "inode",
            "capsnap",
            "follows"
          ],
          "line": 2789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "capsnap->dirty_pages || capsnap->writing"
          ],
          "line": 2788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" cap_snap %p follows %lld tid %lld !=\"\n\t\t\t\t     \" %lld\\n\"",
            "capsnap",
            "follows",
            "flush_tid",
            "capsnap->flush_tid"
          ],
          "line": 2783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "capsnap",
            "&ci->i_cap_snaps",
            "ci_item"
          ],
          "line": 2780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 2779
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"handle_cap_flushsnap_ack inode %p ci %p mds%d follows %lld\\n\"",
            "inode",
            "ci",
            "session->s_mds",
            "follows"
          ],
          "line": 2776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "m->snap_follows"
          ],
          "line": 2772
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 2771
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void handle_cap_flushsnap_ack(struct inode *inode, u64 flush_tid,\n\t\t\t\t     struct ceph_mds_caps *m,\n\t\t\t\t     struct ceph_mds_session *session)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tu64 follows = le64_to_cpu(m->snap_follows);\n\tstruct ceph_cap_snap *capsnap;\n\tint drop = 0;\n\n\tdout(\"handle_cap_flushsnap_ack inode %p ci %p mds%d follows %lld\\n\",\n\t     inode, ci, session->s_mds, follows);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tlist_for_each_entry(capsnap, &ci->i_cap_snaps, ci_item) {\n\t\tif (capsnap->follows == follows) {\n\t\t\tif (capsnap->flush_tid != flush_tid) {\n\t\t\t\tdout(\" cap_snap %p follows %lld tid %lld !=\"\n\t\t\t\t     \" %lld\\n\", capsnap, follows,\n\t\t\t\t     flush_tid, capsnap->flush_tid);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tWARN_ON(capsnap->dirty_pages || capsnap->writing);\n\t\t\tdout(\" removing %p cap_snap %p follows %lld\\n\",\n\t\t\t     inode, capsnap, follows);\n\t\t\tceph_put_snap_context(capsnap->context);\n\t\t\tlist_del(&capsnap->ci_item);\n\t\t\tlist_del(&capsnap->flushing_item);\n\t\t\tceph_put_cap_snap(capsnap);\n\t\t\tdrop = 1;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tdout(\" skipping cap_snap %p follows %lld\\n\",\n\t\t\t     capsnap, capsnap->follows);\n\t\t}\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\tif (drop)\n\t\tiput(inode);\n}"
  },
  {
    "function_name": "handle_cap_flush_ack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "2696-2759",
    "snippet": "static void handle_cap_flush_ack(struct inode *inode, u64 flush_tid,\n\t\t\t\t struct ceph_mds_caps *m,\n\t\t\t\t struct ceph_mds_session *session,\n\t\t\t\t struct ceph_cap *cap)\n\t__releases(ci->i_ceph_lock)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;\n\tunsigned seq = le32_to_cpu(m->seq);\n\tint dirty = le32_to_cpu(m->dirty);\n\tint cleaned = 0;\n\tint drop = 0;\n\tint i;\n\n\tfor (i = 0; i < CEPH_CAP_BITS; i++)\n\t\tif ((dirty & (1 << i)) &&\n\t\t    (u16)flush_tid == ci->i_cap_flush_tid[i])\n\t\t\tcleaned |= 1 << i;\n\n\tdout(\"handle_cap_flush_ack inode %p mds%d seq %d on %s cleaned %s,\"\n\t     \" flushing %s -> %s\\n\",\n\t     inode, session->s_mds, seq, ceph_cap_string(dirty),\n\t     ceph_cap_string(cleaned), ceph_cap_string(ci->i_flushing_caps),\n\t     ceph_cap_string(ci->i_flushing_caps & ~cleaned));\n\n\tif (ci->i_flushing_caps == (ci->i_flushing_caps & ~cleaned))\n\t\tgoto out;\n\n\tci->i_flushing_caps &= ~cleaned;\n\n\tspin_lock(&mdsc->cap_dirty_lock);\n\tif (ci->i_flushing_caps == 0) {\n\t\tlist_del_init(&ci->i_flushing_item);\n\t\tif (!list_empty(&session->s_cap_flushing))\n\t\t\tdout(\" mds%d still flushing cap on %p\\n\",\n\t\t\t     session->s_mds,\n\t\t\t     &list_entry(session->s_cap_flushing.next,\n\t\t\t\t\t struct ceph_inode_info,\n\t\t\t\t\t i_flushing_item)->vfs_inode);\n\t\tmdsc->num_cap_flushing--;\n\t\twake_up_all(&mdsc->cap_flushing_wq);\n\t\tdout(\" inode %p now !flushing\\n\", inode);\n\n\t\tif (ci->i_dirty_caps == 0) {\n\t\t\tdout(\" inode %p now clean\\n\", inode);\n\t\t\tBUG_ON(!list_empty(&ci->i_dirty_item));\n\t\t\tdrop = 1;\n\t\t\tif (ci->i_wrbuffer_ref_head == 0) {\n\t\t\t\tBUG_ON(!ci->i_head_snapc);\n\t\t\t\tceph_put_snap_context(ci->i_head_snapc);\n\t\t\t\tci->i_head_snapc = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tBUG_ON(list_empty(&ci->i_dirty_item));\n\t\t}\n\t}\n\tspin_unlock(&mdsc->cap_dirty_lock);\n\twake_up_all(&ci->i_cap_wq);\n\nout:\n\tspin_unlock(&ci->i_ceph_lock);\n\tif (drop)\n\t\tiput(inode);\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 2758
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 2756
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&ci->i_cap_wq"
          ],
          "line": 2753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "list_empty(&ci->i_dirty_item)"
          ],
          "line": 2749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ci->i_dirty_item"
          ],
          "line": 2749
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_put_snap_context",
          "args": [
            "ci->i_head_snapc"
          ],
          "line": 2745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ci->i_head_snapc"
          ],
          "line": 2744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&ci->i_dirty_item)"
          ],
          "line": 2741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" inode %p now clean\\n\"",
            "inode"
          ],
          "line": 2740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" inode %p now !flushing\\n\"",
            "inode"
          ],
          "line": 2737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&mdsc->cap_flushing_wq"
          ],
          "line": 2736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" mds%d still flushing cap on %p\\n\"",
            "session->s_mds",
            "&list_entry(session->s_cap_flushing.next,\n\t\t\t\t\t struct ceph_inode_info,\n\t\t\t\t\t i_flushing_item)->vfs_inode"
          ],
          "line": 2730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "session->s_cap_flushing.next",
            "structceph_inode_info",
            "i_flushing_item"
          ],
          "line": 2732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&ci->i_flushing_item"
          ],
          "line": 2728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mdsc->cap_dirty_lock"
          ],
          "line": 2726
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"handle_cap_flush_ack inode %p mds%d seq %d on %s cleaned %s,\"\n\t     \" flushing %s -> %s\\n\"",
            "inode",
            "session->s_mds",
            "seq",
            "ceph_cap_string(dirty)",
            "ceph_cap_string(cleaned)",
            "ceph_cap_string(ci->i_flushing_caps)",
            "ceph_cap_string(ci->i_flushing_caps & ~cleaned)"
          ],
          "line": 2715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_cap_string",
          "args": [
            "ci->i_flushing_caps & ~cleaned"
          ],
          "line": 2719
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_cap_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "71-116",
          "snippet": "const char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [
            "#define MAX_CAP_STR 20"
          ],
          "globals_used": [
            "static char cap_str[MAX_CAP_STR][40];",
            "static DEFINE_SPINLOCK(cap_str_lock);",
            "static int last_cap_str;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\n#define MAX_CAP_STR 20\n\nstatic char cap_str[MAX_CAP_STR][40];\nstatic DEFINE_SPINLOCK(cap_str_lock);\nstatic int last_cap_str;\n\nconst char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "m->dirty"
          ],
          "line": 2705
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_sb_to_client",
          "args": [
            "inode->i_sb"
          ],
          "line": 2703
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_sb_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "352-355",
          "snippet": "static inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 2702
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "ci->i_ceph_lock"
          ],
          "line": 2700
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void handle_cap_flush_ack(struct inode *inode, u64 flush_tid,\n\t\t\t\t struct ceph_mds_caps *m,\n\t\t\t\t struct ceph_mds_session *session,\n\t\t\t\t struct ceph_cap *cap)\n\t__releases(ci->i_ceph_lock)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;\n\tunsigned seq = le32_to_cpu(m->seq);\n\tint dirty = le32_to_cpu(m->dirty);\n\tint cleaned = 0;\n\tint drop = 0;\n\tint i;\n\n\tfor (i = 0; i < CEPH_CAP_BITS; i++)\n\t\tif ((dirty & (1 << i)) &&\n\t\t    (u16)flush_tid == ci->i_cap_flush_tid[i])\n\t\t\tcleaned |= 1 << i;\n\n\tdout(\"handle_cap_flush_ack inode %p mds%d seq %d on %s cleaned %s,\"\n\t     \" flushing %s -> %s\\n\",\n\t     inode, session->s_mds, seq, ceph_cap_string(dirty),\n\t     ceph_cap_string(cleaned), ceph_cap_string(ci->i_flushing_caps),\n\t     ceph_cap_string(ci->i_flushing_caps & ~cleaned));\n\n\tif (ci->i_flushing_caps == (ci->i_flushing_caps & ~cleaned))\n\t\tgoto out;\n\n\tci->i_flushing_caps &= ~cleaned;\n\n\tspin_lock(&mdsc->cap_dirty_lock);\n\tif (ci->i_flushing_caps == 0) {\n\t\tlist_del_init(&ci->i_flushing_item);\n\t\tif (!list_empty(&session->s_cap_flushing))\n\t\t\tdout(\" mds%d still flushing cap on %p\\n\",\n\t\t\t     session->s_mds,\n\t\t\t     &list_entry(session->s_cap_flushing.next,\n\t\t\t\t\t struct ceph_inode_info,\n\t\t\t\t\t i_flushing_item)->vfs_inode);\n\t\tmdsc->num_cap_flushing--;\n\t\twake_up_all(&mdsc->cap_flushing_wq);\n\t\tdout(\" inode %p now !flushing\\n\", inode);\n\n\t\tif (ci->i_dirty_caps == 0) {\n\t\t\tdout(\" inode %p now clean\\n\", inode);\n\t\t\tBUG_ON(!list_empty(&ci->i_dirty_item));\n\t\t\tdrop = 1;\n\t\t\tif (ci->i_wrbuffer_ref_head == 0) {\n\t\t\t\tBUG_ON(!ci->i_head_snapc);\n\t\t\t\tceph_put_snap_context(ci->i_head_snapc);\n\t\t\t\tci->i_head_snapc = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tBUG_ON(list_empty(&ci->i_dirty_item));\n\t\t}\n\t}\n\tspin_unlock(&mdsc->cap_dirty_lock);\n\twake_up_all(&ci->i_cap_wq);\n\nout:\n\tspin_unlock(&ci->i_ceph_lock);\n\tif (drop)\n\t\tiput(inode);\n}"
  },
  {
    "function_name": "handle_cap_grant",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "2445-2690",
    "snippet": "static void handle_cap_grant(struct ceph_mds_client *mdsc,\n\t\t\t     struct inode *inode, struct ceph_mds_caps *grant,\n\t\t\t     u64 inline_version,\n\t\t\t     void *inline_data, int inline_len,\n\t\t\t     struct ceph_buffer *xattr_buf,\n\t\t\t     struct ceph_mds_session *session,\n\t\t\t     struct ceph_cap *cap, int issued)\n\t__releases(ci->i_ceph_lock)\n\t__releases(mdsc->snap_rwsem)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint mds = session->s_mds;\n\tint seq = le32_to_cpu(grant->seq);\n\tint newcaps = le32_to_cpu(grant->caps);\n\tint used, wanted, dirty;\n\tu64 size = le64_to_cpu(grant->size);\n\tu64 max_size = le64_to_cpu(grant->max_size);\n\tstruct timespec mtime, atime, ctime;\n\tint check_caps = 0;\n\tbool wake = false;\n\tbool writeback = false;\n\tbool queue_trunc = false;\n\tbool queue_invalidate = false;\n\tbool queue_revalidate = false;\n\tbool deleted_inode = false;\n\tbool fill_inline = false;\n\n\tdout(\"handle_cap_grant inode %p cap %p mds%d seq %d %s\\n\",\n\t     inode, cap, mds, seq, ceph_cap_string(newcaps));\n\tdout(\" size %llu max_size %llu, i_size %llu\\n\", size, max_size,\n\t\tinode->i_size);\n\n\n\t/*\n\t * auth mds of the inode changed. we received the cap export message,\n\t * but still haven't received the cap import message. handle_cap_export\n\t * updated the new auth MDS' cap.\n\t *\n\t * \"ceph_seq_cmp(seq, cap->seq) <= 0\" means we are processing a message\n\t * that was sent before the cap import message. So don't remove caps.\n\t */\n\tif (ceph_seq_cmp(seq, cap->seq) <= 0) {\n\t\tWARN_ON(cap != ci->i_auth_cap);\n\t\tWARN_ON(cap->cap_id != le64_to_cpu(grant->cap_id));\n\t\tseq = cap->seq;\n\t\tnewcaps |= cap->issued;\n\t}\n\n\t/*\n\t * If CACHE is being revoked, and we have no dirty buffers,\n\t * try to invalidate (once).  (If there are dirty buffers, we\n\t * will invalidate _after_ writeback.)\n\t */\n\tif (((cap->issued & ~newcaps) & CEPH_CAP_FILE_CACHE) &&\n\t    (newcaps & CEPH_CAP_FILE_LAZYIO) == 0 &&\n\t    !ci->i_wrbuffer_ref) {\n\t\tif (try_nonblocking_invalidate(inode)) {\n\t\t\t/* there were locked pages.. invalidate later\n\t\t\t   in a separate thread. */\n\t\t\tif (ci->i_rdcache_revoking != ci->i_rdcache_gen) {\n\t\t\t\tqueue_invalidate = true;\n\t\t\t\tci->i_rdcache_revoking = ci->i_rdcache_gen;\n\t\t\t}\n\t\t}\n\n\t\tceph_fscache_invalidate(inode);\n\t}\n\n\t/* side effects now are allowed */\n\tcap->cap_gen = session->s_cap_gen;\n\tcap->seq = seq;\n\n\t__check_cap_issue(ci, cap, newcaps);\n\n\tif ((newcaps & CEPH_CAP_AUTH_SHARED) &&\n\t    (issued & CEPH_CAP_AUTH_EXCL) == 0) {\n\t\tinode->i_mode = le32_to_cpu(grant->mode);\n\t\tinode->i_uid = make_kuid(&init_user_ns, le32_to_cpu(grant->uid));\n\t\tinode->i_gid = make_kgid(&init_user_ns, le32_to_cpu(grant->gid));\n\t\tdout(\"%p mode 0%o uid.gid %d.%d\\n\", inode, inode->i_mode,\n\t\t     from_kuid(&init_user_ns, inode->i_uid),\n\t\t     from_kgid(&init_user_ns, inode->i_gid));\n\t}\n\n\tif ((newcaps & CEPH_CAP_AUTH_SHARED) &&\n\t    (issued & CEPH_CAP_LINK_EXCL) == 0) {\n\t\tset_nlink(inode, le32_to_cpu(grant->nlink));\n\t\tif (inode->i_nlink == 0 &&\n\t\t    (newcaps & (CEPH_CAP_LINK_SHARED | CEPH_CAP_LINK_EXCL)))\n\t\t\tdeleted_inode = true;\n\t}\n\n\tif ((issued & CEPH_CAP_XATTR_EXCL) == 0 && grant->xattr_len) {\n\t\tint len = le32_to_cpu(grant->xattr_len);\n\t\tu64 version = le64_to_cpu(grant->xattr_version);\n\n\t\tif (version > ci->i_xattrs.version) {\n\t\t\tdout(\" got new xattrs v%llu on %p len %d\\n\",\n\t\t\t     version, inode, len);\n\t\t\tif (ci->i_xattrs.blob)\n\t\t\t\tceph_buffer_put(ci->i_xattrs.blob);\n\t\t\tci->i_xattrs.blob = ceph_buffer_get(xattr_buf);\n\t\t\tci->i_xattrs.version = version;\n\t\t\tceph_forget_all_cached_acls(inode);\n\t\t}\n\t}\n\n\t/* Do we need to revalidate our fscache cookie. Don't bother on the\n\t * first cache cap as we already validate at cookie creation time. */\n\tif ((issued & CEPH_CAP_FILE_CACHE) && ci->i_rdcache_gen > 1)\n\t\tqueue_revalidate = true;\n\n\tif (newcaps & CEPH_CAP_ANY_RD) {\n\t\t/* ctime/mtime/atime? */\n\t\tceph_decode_timespec(&mtime, &grant->mtime);\n\t\tceph_decode_timespec(&atime, &grant->atime);\n\t\tceph_decode_timespec(&ctime, &grant->ctime);\n\t\tceph_fill_file_time(inode, issued,\n\t\t\t\t    le32_to_cpu(grant->time_warp_seq),\n\t\t\t\t    &ctime, &mtime, &atime);\n\t}\n\n\tif (newcaps & (CEPH_CAP_ANY_FILE_RD | CEPH_CAP_ANY_FILE_WR)) {\n\t\t/* file layout may have changed */\n\t\tci->i_layout = grant->layout;\n\t\t/* size/truncate_seq? */\n\t\tqueue_trunc = ceph_fill_file_size(inode, issued,\n\t\t\t\t\tle32_to_cpu(grant->truncate_seq),\n\t\t\t\t\tle64_to_cpu(grant->truncate_size),\n\t\t\t\t\tsize);\n\t\t/* max size increase? */\n\t\tif (ci->i_auth_cap == cap && max_size != ci->i_max_size) {\n\t\t\tdout(\"max_size %lld -> %llu\\n\",\n\t\t\t     ci->i_max_size, max_size);\n\t\t\tci->i_max_size = max_size;\n\t\t\tif (max_size >= ci->i_wanted_max_size) {\n\t\t\t\tci->i_wanted_max_size = 0;  /* reset */\n\t\t\t\tci->i_requested_max_size = 0;\n\t\t\t}\n\t\t\twake = true;\n\t\t}\n\t}\n\n\t/* check cap bits */\n\twanted = __ceph_caps_wanted(ci);\n\tused = __ceph_caps_used(ci);\n\tdirty = __ceph_caps_dirty(ci);\n\tdout(\" my wanted = %s, used = %s, dirty %s\\n\",\n\t     ceph_cap_string(wanted),\n\t     ceph_cap_string(used),\n\t     ceph_cap_string(dirty));\n\tif (wanted != le32_to_cpu(grant->wanted)) {\n\t\tdout(\"mds wanted %s -> %s\\n\",\n\t\t     ceph_cap_string(le32_to_cpu(grant->wanted)),\n\t\t     ceph_cap_string(wanted));\n\t\t/* imported cap may not have correct mds_wanted */\n\t\tif (le32_to_cpu(grant->op) == CEPH_CAP_OP_IMPORT)\n\t\t\tcheck_caps = 1;\n\t}\n\n\t/* revocation, grant, or no-op? */\n\tif (cap->issued & ~newcaps) {\n\t\tint revoking = cap->issued & ~newcaps;\n\n\t\tdout(\"revocation: %s -> %s (revoking %s)\\n\",\n\t\t     ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(newcaps),\n\t\t     ceph_cap_string(revoking));\n\t\tif (revoking & used & CEPH_CAP_FILE_BUFFER)\n\t\t\twriteback = true;  /* initiate writeback; will delay ack */\n\t\telse if (revoking == CEPH_CAP_FILE_CACHE &&\n\t\t\t (newcaps & CEPH_CAP_FILE_LAZYIO) == 0 &&\n\t\t\t queue_invalidate)\n\t\t\t; /* do nothing yet, invalidation will be queued */\n\t\telse if (cap == ci->i_auth_cap)\n\t\t\tcheck_caps = 1; /* check auth cap only */\n\t\telse\n\t\t\tcheck_caps = 2; /* check all caps */\n\t\tcap->issued = newcaps;\n\t\tcap->implemented |= newcaps;\n\t} else if (cap->issued == newcaps) {\n\t\tdout(\"caps unchanged: %s -> %s\\n\",\n\t\t     ceph_cap_string(cap->issued), ceph_cap_string(newcaps));\n\t} else {\n\t\tdout(\"grant: %s -> %s\\n\", ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(newcaps));\n\t\t/* non-auth MDS is revoking the newly grant caps ? */\n\t\tif (cap == ci->i_auth_cap &&\n\t\t    __ceph_caps_revoking_other(ci, cap, newcaps))\n\t\t    check_caps = 2;\n\n\t\tcap->issued = newcaps;\n\t\tcap->implemented |= newcaps; /* add bits only, to\n\t\t\t\t\t      * avoid stepping on a\n\t\t\t\t\t      * pending revocation */\n\t\twake = true;\n\t}\n\tBUG_ON(cap->issued & ~cap->implemented);\n\n\tif (inline_version > 0 && inline_version >= ci->i_inline_version) {\n\t\tci->i_inline_version = inline_version;\n\t\tif (ci->i_inline_version != CEPH_INLINE_NONE &&\n\t\t    (newcaps & (CEPH_CAP_FILE_CACHE|CEPH_CAP_FILE_LAZYIO)))\n\t\t\tfill_inline = true;\n\t}\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (le32_to_cpu(grant->op) == CEPH_CAP_OP_IMPORT) {\n\t\tkick_flushing_inode_caps(mdsc, session, inode);\n\t\tup_read(&mdsc->snap_rwsem);\n\t\tif (newcaps & ~issued)\n\t\t\twake = true;\n\t}\n\n\tif (fill_inline)\n\t\tceph_fill_inline_data(inode, NULL, inline_data, inline_len);\n\n\tif (queue_trunc) {\n\t\tceph_queue_vmtruncate(inode);\n\t\tceph_queue_revalidate(inode);\n\t} else if (queue_revalidate)\n\t\tceph_queue_revalidate(inode);\n\n\tif (writeback)\n\t\t/*\n\t\t * queue inode for writeback: we can't actually call\n\t\t * filemap_write_and_wait, etc. from message handler\n\t\t * context.\n\t\t */\n\t\tceph_queue_writeback(inode);\n\tif (queue_invalidate)\n\t\tceph_queue_invalidate(inode);\n\tif (deleted_inode)\n\t\tinvalidate_aliases(inode);\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\n\tif (check_caps == 1)\n\t\tceph_check_caps(ci, CHECK_CAPS_NODELAY|CHECK_CAPS_AUTHONLY,\n\t\t\t\tsession);\n\telse if (check_caps == 2)\n\t\tceph_check_caps(ci, CHECK_CAPS_NODELAY, session);\n\telse\n\t\tmutex_unlock(&session->s_mutex);\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&session->s_mutex"
          ],
          "line": 2689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_check_caps",
          "args": [
            "ci",
            "CHECK_CAPS_NODELAY",
            "session"
          ],
          "line": 2687
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_check_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "1504-1751",
          "snippet": "void ceph_check_caps(struct ceph_inode_info *ci, int flags,\n\t\t     struct ceph_mds_session *session)\n{\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(&ci->vfs_inode);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct inode *inode = &ci->vfs_inode;\n\tstruct ceph_cap *cap;\n\tint file_wanted, used, cap_used;\n\tint took_snap_rwsem = 0;             /* true if mdsc->snap_rwsem held */\n\tint issued, implemented, want, retain, revoking, flushing = 0;\n\tint mds = -1;   /* keep track of how far we've gone through i_caps list\n\t\t\t   to avoid an infinite loop on retry */\n\tstruct rb_node *p;\n\tint tried_invalidate = 0;\n\tint delayed = 0, sent = 0, force_requeue = 0, num;\n\tint queue_invalidate = 0;\n\tint is_delayed = flags & CHECK_CAPS_NODELAY;\n\n\t/* if we are unmounting, flush any unused caps immediately. */\n\tif (mdsc->stopping)\n\t\tis_delayed = 1;\n\n\tspin_lock(&ci->i_ceph_lock);\n\n\tif (ci->i_ceph_flags & CEPH_I_FLUSH)\n\t\tflags |= CHECK_CAPS_FLUSH;\n\n\t/* flush snaps first time around only */\n\tif (!list_empty(&ci->i_cap_snaps))\n\t\t__ceph_flush_snaps(ci, &session, 0);\n\tgoto retry_locked;\nretry:\n\tspin_lock(&ci->i_ceph_lock);\nretry_locked:\n\tfile_wanted = __ceph_caps_file_wanted(ci);\n\tused = __ceph_caps_used(ci);\n\twant = file_wanted | used;\n\tissued = __ceph_caps_issued(ci, &implemented);\n\trevoking = implemented & ~issued;\n\n\tretain = want | CEPH_CAP_PIN;\n\tif (!mdsc->stopping && inode->i_nlink > 0) {\n\t\tif (want) {\n\t\t\tretain |= CEPH_CAP_ANY;       /* be greedy */\n\t\t} else {\n\t\t\tretain |= CEPH_CAP_ANY_SHARED;\n\t\t\t/*\n\t\t\t * keep RD only if we didn't have the file open RW,\n\t\t\t * because then the mds would revoke it anyway to\n\t\t\t * journal max_size=0.\n\t\t\t */\n\t\t\tif (ci->i_max_size == 0)\n\t\t\t\tretain |= CEPH_CAP_ANY_RD;\n\t\t}\n\t}\n\n\tdout(\"check_caps %p file_want %s used %s dirty %s flushing %s\"\n\t     \" issued %s revoking %s retain %s %s%s%s\\n\", inode,\n\t     ceph_cap_string(file_wanted),\n\t     ceph_cap_string(used), ceph_cap_string(ci->i_dirty_caps),\n\t     ceph_cap_string(ci->i_flushing_caps),\n\t     ceph_cap_string(issued), ceph_cap_string(revoking),\n\t     ceph_cap_string(retain),\n\t     (flags & CHECK_CAPS_AUTHONLY) ? \" AUTHONLY\" : \"\",\n\t     (flags & CHECK_CAPS_NODELAY) ? \" NODELAY\" : \"\",\n\t     (flags & CHECK_CAPS_FLUSH) ? \" FLUSH\" : \"\");\n\n\t/*\n\t * If we no longer need to hold onto old our caps, and we may\n\t * have cached pages, but don't want them, then try to invalidate.\n\t * If we fail, it's because pages are locked.... try again later.\n\t */\n\tif ((!is_delayed || mdsc->stopping) &&\n\t    ci->i_wrbuffer_ref == 0 &&               /* no dirty pages... */\n\t    inode->i_data.nrpages &&                 /* have cached pages */\n\t    (file_wanted == 0 ||                     /* no open files */\n\t     (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t  CEPH_CAP_FILE_LAZYIO))) && /*  or revoking cache */\n\t    !tried_invalidate) {\n\t\tdout(\"check_caps trying to invalidate on %p\\n\", inode);\n\t\tif (try_nonblocking_invalidate(inode) < 0) {\n\t\t\tif (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t\t\tCEPH_CAP_FILE_LAZYIO)) {\n\t\t\t\tdout(\"check_caps queuing invalidate\\n\");\n\t\t\t\tqueue_invalidate = 1;\n\t\t\t\tci->i_rdcache_revoking = ci->i_rdcache_gen;\n\t\t\t} else {\n\t\t\t\tdout(\"check_caps failed to invalidate pages\\n\");\n\t\t\t\t/* we failed to invalidate pages.  check these\n\t\t\t\t   caps again later. */\n\t\t\t\tforce_requeue = 1;\n\t\t\t\t__cap_set_timeouts(mdsc, ci);\n\t\t\t}\n\t\t}\n\t\ttried_invalidate = 1;\n\t\tgoto retry_locked;\n\t}\n\n\tnum = 0;\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tnum++;\n\n\t\t/* avoid looping forever */\n\t\tif (mds >= cap->mds ||\n\t\t    ((flags & CHECK_CAPS_AUTHONLY) && cap != ci->i_auth_cap))\n\t\t\tcontinue;\n\n\t\t/* NOTE: no side-effects allowed, until we take s_mutex */\n\n\t\tcap_used = used;\n\t\tif (ci->i_auth_cap && cap != ci->i_auth_cap)\n\t\t\tcap_used &= ~ci->i_auth_cap->issued;\n\n\t\trevoking = cap->implemented & ~cap->issued;\n\t\tdout(\" mds%d cap %p used %s issued %s implemented %s revoking %s\\n\",\n\t\t     cap->mds, cap, ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(cap_used),\n\t\t     ceph_cap_string(cap->implemented),\n\t\t     ceph_cap_string(revoking));\n\n\t\tif (cap == ci->i_auth_cap &&\n\t\t    (cap->issued & CEPH_CAP_FILE_WR)) {\n\t\t\t/* request larger max_size from MDS? */\n\t\t\tif (ci->i_wanted_max_size > ci->i_max_size &&\n\t\t\t    ci->i_wanted_max_size > ci->i_requested_max_size) {\n\t\t\t\tdout(\"requesting new max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\n\t\t\t/* approaching file_max? */\n\t\t\tif ((inode->i_size << 1) >= ci->i_max_size &&\n\t\t\t    (ci->i_reported_size << 1) < ci->i_max_size) {\n\t\t\t\tdout(\"i_size approaching max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\t\t}\n\t\t/* flush anything dirty? */\n\t\tif (cap == ci->i_auth_cap && (flags & CHECK_CAPS_FLUSH) &&\n\t\t    ci->i_dirty_caps) {\n\t\t\tdout(\"flushing dirty caps\\n\");\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* completed revocation? going down and there are no caps? */\n\t\tif (revoking && (revoking & cap_used) == 0) {\n\t\t\tdout(\"completed revocation of %s\\n\",\n\t\t\t     ceph_cap_string(cap->implemented & ~cap->issued));\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* want more caps from mds? */\n\t\tif (want & ~(cap->mds_wanted | cap->issued))\n\t\t\tgoto ack;\n\n\t\t/* things we might delay */\n\t\tif ((cap->issued & ~retain) == 0 &&\n\t\t    cap->mds_wanted == want)\n\t\t\tcontinue;     /* nope, all good */\n\n\t\tif (is_delayed)\n\t\t\tgoto ack;\n\n\t\t/* delay? */\n\t\tif ((ci->i_ceph_flags & CEPH_I_NODELAY) == 0 &&\n\t\t    time_before(jiffies, ci->i_hold_caps_max)) {\n\t\t\tdout(\" delaying issued %s -> %s, wanted %s -> %s\\n\",\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(cap->issued & retain),\n\t\t\t     ceph_cap_string(cap->mds_wanted),\n\t\t\t     ceph_cap_string(want));\n\t\t\tdelayed++;\n\t\t\tcontinue;\n\t\t}\n\nack:\n\t\tif (ci->i_ceph_flags & CEPH_I_NOFLUSH) {\n\t\t\tdout(\" skipping %p I_NOFLUSH set\\n\", inode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (session && session != cap->session) {\n\t\t\tdout(\"oops, wrong session %p mutex\\n\", session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tsession = NULL;\n\t\t}\n\t\tif (!session) {\n\t\t\tsession = cap->session;\n\t\t\tif (mutex_trylock(&session->s_mutex) == 0) {\n\t\t\t\tdout(\"inverting session/ino locks on %p\\n\",\n\t\t\t\t     session);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tif (took_snap_rwsem) {\n\t\t\t\t\tup_read(&mdsc->snap_rwsem);\n\t\t\t\t\ttook_snap_rwsem = 0;\n\t\t\t\t}\n\t\t\t\tmutex_lock(&session->s_mutex);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t\t/* take snap_rwsem after session mutex */\n\t\tif (!took_snap_rwsem) {\n\t\t\tif (down_read_trylock(&mdsc->snap_rwsem) == 0) {\n\t\t\t\tdout(\"inverting snap/in locks on %p\\n\",\n\t\t\t\t     inode);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tdown_read(&mdsc->snap_rwsem);\n\t\t\t\ttook_snap_rwsem = 1;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\ttook_snap_rwsem = 1;\n\t\t}\n\n\t\tif (cap == ci->i_auth_cap && ci->i_dirty_caps)\n\t\t\tflushing = __mark_caps_flushing(inode, session);\n\t\telse\n\t\t\tflushing = 0;\n\n\t\tmds = cap->mds;  /* remember mds, so we don't repeat */\n\t\tsent++;\n\n\t\t/* __send_cap drops i_ceph_lock */\n\t\tdelayed += __send_cap(mdsc, cap, CEPH_CAP_OP_UPDATE, cap_used,\n\t\t\t\t      want, retain, flushing, NULL);\n\t\tgoto retry; /* retake i_ceph_lock and restart our cap scan. */\n\t}\n\n\t/*\n\t * Reschedule delayed caps release if we delayed anything,\n\t * otherwise cancel.\n\t */\n\tif (delayed && is_delayed)\n\t\tforce_requeue = 1;   /* __send_cap delayed release; requeue */\n\tif (!delayed && !is_delayed)\n\t\t__cap_delay_cancel(mdsc, ci);\n\telse if (!is_delayed || force_requeue)\n\t\t__cap_delay_requeue(mdsc, ci);\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (queue_invalidate)\n\t\tceph_queue_invalidate(inode);\n\n\tif (session)\n\t\tmutex_unlock(&session->s_mutex);\n\tif (took_snap_rwsem)\n\t\tup_read(&mdsc->snap_rwsem);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_check_caps(struct ceph_inode_info *ci, int flags,\n\t\t     struct ceph_mds_session *session)\n{\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(&ci->vfs_inode);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct inode *inode = &ci->vfs_inode;\n\tstruct ceph_cap *cap;\n\tint file_wanted, used, cap_used;\n\tint took_snap_rwsem = 0;             /* true if mdsc->snap_rwsem held */\n\tint issued, implemented, want, retain, revoking, flushing = 0;\n\tint mds = -1;   /* keep track of how far we've gone through i_caps list\n\t\t\t   to avoid an infinite loop on retry */\n\tstruct rb_node *p;\n\tint tried_invalidate = 0;\n\tint delayed = 0, sent = 0, force_requeue = 0, num;\n\tint queue_invalidate = 0;\n\tint is_delayed = flags & CHECK_CAPS_NODELAY;\n\n\t/* if we are unmounting, flush any unused caps immediately. */\n\tif (mdsc->stopping)\n\t\tis_delayed = 1;\n\n\tspin_lock(&ci->i_ceph_lock);\n\n\tif (ci->i_ceph_flags & CEPH_I_FLUSH)\n\t\tflags |= CHECK_CAPS_FLUSH;\n\n\t/* flush snaps first time around only */\n\tif (!list_empty(&ci->i_cap_snaps))\n\t\t__ceph_flush_snaps(ci, &session, 0);\n\tgoto retry_locked;\nretry:\n\tspin_lock(&ci->i_ceph_lock);\nretry_locked:\n\tfile_wanted = __ceph_caps_file_wanted(ci);\n\tused = __ceph_caps_used(ci);\n\twant = file_wanted | used;\n\tissued = __ceph_caps_issued(ci, &implemented);\n\trevoking = implemented & ~issued;\n\n\tretain = want | CEPH_CAP_PIN;\n\tif (!mdsc->stopping && inode->i_nlink > 0) {\n\t\tif (want) {\n\t\t\tretain |= CEPH_CAP_ANY;       /* be greedy */\n\t\t} else {\n\t\t\tretain |= CEPH_CAP_ANY_SHARED;\n\t\t\t/*\n\t\t\t * keep RD only if we didn't have the file open RW,\n\t\t\t * because then the mds would revoke it anyway to\n\t\t\t * journal max_size=0.\n\t\t\t */\n\t\t\tif (ci->i_max_size == 0)\n\t\t\t\tretain |= CEPH_CAP_ANY_RD;\n\t\t}\n\t}\n\n\tdout(\"check_caps %p file_want %s used %s dirty %s flushing %s\"\n\t     \" issued %s revoking %s retain %s %s%s%s\\n\", inode,\n\t     ceph_cap_string(file_wanted),\n\t     ceph_cap_string(used), ceph_cap_string(ci->i_dirty_caps),\n\t     ceph_cap_string(ci->i_flushing_caps),\n\t     ceph_cap_string(issued), ceph_cap_string(revoking),\n\t     ceph_cap_string(retain),\n\t     (flags & CHECK_CAPS_AUTHONLY) ? \" AUTHONLY\" : \"\",\n\t     (flags & CHECK_CAPS_NODELAY) ? \" NODELAY\" : \"\",\n\t     (flags & CHECK_CAPS_FLUSH) ? \" FLUSH\" : \"\");\n\n\t/*\n\t * If we no longer need to hold onto old our caps, and we may\n\t * have cached pages, but don't want them, then try to invalidate.\n\t * If we fail, it's because pages are locked.... try again later.\n\t */\n\tif ((!is_delayed || mdsc->stopping) &&\n\t    ci->i_wrbuffer_ref == 0 &&               /* no dirty pages... */\n\t    inode->i_data.nrpages &&                 /* have cached pages */\n\t    (file_wanted == 0 ||                     /* no open files */\n\t     (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t  CEPH_CAP_FILE_LAZYIO))) && /*  or revoking cache */\n\t    !tried_invalidate) {\n\t\tdout(\"check_caps trying to invalidate on %p\\n\", inode);\n\t\tif (try_nonblocking_invalidate(inode) < 0) {\n\t\t\tif (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t\t\tCEPH_CAP_FILE_LAZYIO)) {\n\t\t\t\tdout(\"check_caps queuing invalidate\\n\");\n\t\t\t\tqueue_invalidate = 1;\n\t\t\t\tci->i_rdcache_revoking = ci->i_rdcache_gen;\n\t\t\t} else {\n\t\t\t\tdout(\"check_caps failed to invalidate pages\\n\");\n\t\t\t\t/* we failed to invalidate pages.  check these\n\t\t\t\t   caps again later. */\n\t\t\t\tforce_requeue = 1;\n\t\t\t\t__cap_set_timeouts(mdsc, ci);\n\t\t\t}\n\t\t}\n\t\ttried_invalidate = 1;\n\t\tgoto retry_locked;\n\t}\n\n\tnum = 0;\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tnum++;\n\n\t\t/* avoid looping forever */\n\t\tif (mds >= cap->mds ||\n\t\t    ((flags & CHECK_CAPS_AUTHONLY) && cap != ci->i_auth_cap))\n\t\t\tcontinue;\n\n\t\t/* NOTE: no side-effects allowed, until we take s_mutex */\n\n\t\tcap_used = used;\n\t\tif (ci->i_auth_cap && cap != ci->i_auth_cap)\n\t\t\tcap_used &= ~ci->i_auth_cap->issued;\n\n\t\trevoking = cap->implemented & ~cap->issued;\n\t\tdout(\" mds%d cap %p used %s issued %s implemented %s revoking %s\\n\",\n\t\t     cap->mds, cap, ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(cap_used),\n\t\t     ceph_cap_string(cap->implemented),\n\t\t     ceph_cap_string(revoking));\n\n\t\tif (cap == ci->i_auth_cap &&\n\t\t    (cap->issued & CEPH_CAP_FILE_WR)) {\n\t\t\t/* request larger max_size from MDS? */\n\t\t\tif (ci->i_wanted_max_size > ci->i_max_size &&\n\t\t\t    ci->i_wanted_max_size > ci->i_requested_max_size) {\n\t\t\t\tdout(\"requesting new max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\n\t\t\t/* approaching file_max? */\n\t\t\tif ((inode->i_size << 1) >= ci->i_max_size &&\n\t\t\t    (ci->i_reported_size << 1) < ci->i_max_size) {\n\t\t\t\tdout(\"i_size approaching max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\t\t}\n\t\t/* flush anything dirty? */\n\t\tif (cap == ci->i_auth_cap && (flags & CHECK_CAPS_FLUSH) &&\n\t\t    ci->i_dirty_caps) {\n\t\t\tdout(\"flushing dirty caps\\n\");\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* completed revocation? going down and there are no caps? */\n\t\tif (revoking && (revoking & cap_used) == 0) {\n\t\t\tdout(\"completed revocation of %s\\n\",\n\t\t\t     ceph_cap_string(cap->implemented & ~cap->issued));\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* want more caps from mds? */\n\t\tif (want & ~(cap->mds_wanted | cap->issued))\n\t\t\tgoto ack;\n\n\t\t/* things we might delay */\n\t\tif ((cap->issued & ~retain) == 0 &&\n\t\t    cap->mds_wanted == want)\n\t\t\tcontinue;     /* nope, all good */\n\n\t\tif (is_delayed)\n\t\t\tgoto ack;\n\n\t\t/* delay? */\n\t\tif ((ci->i_ceph_flags & CEPH_I_NODELAY) == 0 &&\n\t\t    time_before(jiffies, ci->i_hold_caps_max)) {\n\t\t\tdout(\" delaying issued %s -> %s, wanted %s -> %s\\n\",\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(cap->issued & retain),\n\t\t\t     ceph_cap_string(cap->mds_wanted),\n\t\t\t     ceph_cap_string(want));\n\t\t\tdelayed++;\n\t\t\tcontinue;\n\t\t}\n\nack:\n\t\tif (ci->i_ceph_flags & CEPH_I_NOFLUSH) {\n\t\t\tdout(\" skipping %p I_NOFLUSH set\\n\", inode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (session && session != cap->session) {\n\t\t\tdout(\"oops, wrong session %p mutex\\n\", session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tsession = NULL;\n\t\t}\n\t\tif (!session) {\n\t\t\tsession = cap->session;\n\t\t\tif (mutex_trylock(&session->s_mutex) == 0) {\n\t\t\t\tdout(\"inverting session/ino locks on %p\\n\",\n\t\t\t\t     session);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tif (took_snap_rwsem) {\n\t\t\t\t\tup_read(&mdsc->snap_rwsem);\n\t\t\t\t\ttook_snap_rwsem = 0;\n\t\t\t\t}\n\t\t\t\tmutex_lock(&session->s_mutex);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t\t/* take snap_rwsem after session mutex */\n\t\tif (!took_snap_rwsem) {\n\t\t\tif (down_read_trylock(&mdsc->snap_rwsem) == 0) {\n\t\t\t\tdout(\"inverting snap/in locks on %p\\n\",\n\t\t\t\t     inode);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tdown_read(&mdsc->snap_rwsem);\n\t\t\t\ttook_snap_rwsem = 1;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\ttook_snap_rwsem = 1;\n\t\t}\n\n\t\tif (cap == ci->i_auth_cap && ci->i_dirty_caps)\n\t\t\tflushing = __mark_caps_flushing(inode, session);\n\t\telse\n\t\t\tflushing = 0;\n\n\t\tmds = cap->mds;  /* remember mds, so we don't repeat */\n\t\tsent++;\n\n\t\t/* __send_cap drops i_ceph_lock */\n\t\tdelayed += __send_cap(mdsc, cap, CEPH_CAP_OP_UPDATE, cap_used,\n\t\t\t\t      want, retain, flushing, NULL);\n\t\tgoto retry; /* retake i_ceph_lock and restart our cap scan. */\n\t}\n\n\t/*\n\t * Reschedule delayed caps release if we delayed anything,\n\t * otherwise cancel.\n\t */\n\tif (delayed && is_delayed)\n\t\tforce_requeue = 1;   /* __send_cap delayed release; requeue */\n\tif (!delayed && !is_delayed)\n\t\t__cap_delay_cancel(mdsc, ci);\n\telse if (!is_delayed || force_requeue)\n\t\t__cap_delay_requeue(mdsc, ci);\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (queue_invalidate)\n\t\tceph_queue_invalidate(inode);\n\n\tif (session)\n\t\tmutex_unlock(&session->s_mutex);\n\tif (took_snap_rwsem)\n\t\tup_read(&mdsc->snap_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&ci->i_cap_wq"
          ],
          "line": 2681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalidate_aliases",
          "args": [
            "inode"
          ],
          "line": 2679
        },
        "resolved": true,
        "details": {
          "function_name": "invalidate_aliases",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "2410-2437",
          "snippet": "static void invalidate_aliases(struct inode *inode)\n{\n\tstruct dentry *dn, *prev = NULL;\n\n\tdout(\"invalidate_aliases inode %p\\n\", inode);\n\td_prune_aliases(inode);\n\t/*\n\t * For non-directory inode, d_find_alias() only returns\n\t * hashed dentry. After calling d_invalidate(), the\n\t * dentry becomes unhashed.\n\t *\n\t * For directory inode, d_find_alias() can return\n\t * unhashed dentry. But directory inode should have\n\t * one alias at most.\n\t */\n\twhile ((dn = d_find_alias(inode))) {\n\t\tif (dn == prev) {\n\t\t\tdput(dn);\n\t\t\tbreak;\n\t\t}\n\t\td_invalidate(dn);\n\t\tif (prev)\n\t\t\tdput(prev);\n\t\tprev = dn;\n\t}\n\tif (prev)\n\t\tdput(prev);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void invalidate_aliases(struct inode *inode)\n{\n\tstruct dentry *dn, *prev = NULL;\n\n\tdout(\"invalidate_aliases inode %p\\n\", inode);\n\td_prune_aliases(inode);\n\t/*\n\t * For non-directory inode, d_find_alias() only returns\n\t * hashed dentry. After calling d_invalidate(), the\n\t * dentry becomes unhashed.\n\t *\n\t * For directory inode, d_find_alias() can return\n\t * unhashed dentry. But directory inode should have\n\t * one alias at most.\n\t */\n\twhile ((dn = d_find_alias(inode))) {\n\t\tif (dn == prev) {\n\t\t\tdput(dn);\n\t\t\tbreak;\n\t\t}\n\t\td_invalidate(dn);\n\t\tif (prev)\n\t\t\tdput(prev);\n\t\tprev = dn;\n\t}\n\tif (prev)\n\t\tdput(prev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_queue_invalidate",
          "args": [
            "inode"
          ],
          "line": 2677
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_queue_invalidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "1531-1541",
          "snippet": "void ceph_queue_invalidate(struct inode *inode)\n{\n\tihold(inode);\n\tif (queue_work(ceph_inode_to_client(inode)->pg_inv_wq,\n\t\t       &ceph_inode(inode)->i_pg_inv_work)) {\n\t\tdout(\"ceph_queue_invalidate %p\\n\", inode);\n\t} else {\n\t\tdout(\"ceph_queue_invalidate %p failed\\n\", inode);\n\t\tiput(inode);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_queue_invalidate(struct inode *inode)\n{\n\tihold(inode);\n\tif (queue_work(ceph_inode_to_client(inode)->pg_inv_wq,\n\t\t       &ceph_inode(inode)->i_pg_inv_work)) {\n\t\tdout(\"ceph_queue_invalidate %p\\n\", inode);\n\t} else {\n\t\tdout(\"ceph_queue_invalidate %p failed\\n\", inode);\n\t\tiput(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_queue_writeback",
          "args": [
            "inode"
          ],
          "line": 2675
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_queue_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "1505-1515",
          "snippet": "void ceph_queue_writeback(struct inode *inode)\n{\n\tihold(inode);\n\tif (queue_work(ceph_inode_to_client(inode)->wb_wq,\n\t\t       &ceph_inode(inode)->i_wb_work)) {\n\t\tdout(\"ceph_queue_writeback %p\\n\", inode);\n\t} else {\n\t\tdout(\"ceph_queue_writeback %p failed\\n\", inode);\n\t\tiput(inode);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_queue_writeback(struct inode *inode)\n{\n\tihold(inode);\n\tif (queue_work(ceph_inode_to_client(inode)->wb_wq,\n\t\t       &ceph_inode(inode)->i_wb_work)) {\n\t\tdout(\"ceph_queue_writeback %p\\n\", inode);\n\t} else {\n\t\tdout(\"ceph_queue_writeback %p failed\\n\", inode);\n\t\tiput(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_queue_revalidate",
          "args": [
            "inode"
          ],
          "line": 2667
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_queue_revalidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.c",
          "lines": "377-394",
          "snippet": "void ceph_queue_revalidate(struct inode *inode)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(inode->i_sb);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tif (fsc->revalidate_wq == NULL || ci->fscache == NULL)\n\t\treturn;\n\n\tihold(inode);\n\n\tif (queue_work(ceph_sb_to_client(inode->i_sb)->revalidate_wq,\n\t\t       &ci->i_revalidate_work)) {\n\t\tdout(\"ceph_queue_revalidate %p\\n\", inode);\n\t} else {\n\t\tdout(\"ceph_queue_revalidate %p failed\\n)\", inode);\n\t\tiput(inode);\n\t}\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"super.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"super.h\"\n\nvoid ceph_queue_revalidate(struct inode *inode)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(inode->i_sb);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tif (fsc->revalidate_wq == NULL || ci->fscache == NULL)\n\t\treturn;\n\n\tihold(inode);\n\n\tif (queue_work(ceph_sb_to_client(inode->i_sb)->revalidate_wq,\n\t\t       &ci->i_revalidate_work)) {\n\t\tdout(\"ceph_queue_revalidate %p\\n\", inode);\n\t} else {\n\t\tdout(\"ceph_queue_revalidate %p failed\\n)\", inode);\n\t\tiput(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_queue_vmtruncate",
          "args": [
            "inode"
          ],
          "line": 2664
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_queue_vmtruncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "1614-1628",
          "snippet": "void ceph_queue_vmtruncate(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tihold(inode);\n\n\tif (queue_work(ceph_sb_to_client(inode->i_sb)->trunc_wq,\n\t\t       &ci->i_vmtruncate_work)) {\n\t\tdout(\"ceph_queue_vmtruncate %p\\n\", inode);\n\t} else {\n\t\tdout(\"ceph_queue_vmtruncate %p failed, pending=%d\\n\",\n\t\t     inode, ci->i_truncate_pending);\n\t\tiput(inode);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_queue_vmtruncate(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tihold(inode);\n\n\tif (queue_work(ceph_sb_to_client(inode->i_sb)->trunc_wq,\n\t\t       &ci->i_vmtruncate_work)) {\n\t\tdout(\"ceph_queue_vmtruncate %p\\n\", inode);\n\t} else {\n\t\tdout(\"ceph_queue_vmtruncate %p failed, pending=%d\\n\",\n\t\t     inode, ci->i_truncate_pending);\n\t\tiput(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_fill_inline_data",
          "args": [
            "inode",
            "NULL",
            "inline_data",
            "inline_len"
          ],
          "line": 2661
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_fill_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
          "lines": "1402-1443",
          "snippet": "void ceph_fill_inline_data(struct inode *inode, struct page *locked_page,\n\t\t\t   char\t*data, size_t len)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page;\n\n\tif (locked_page) {\n\t\tpage = locked_page;\n\t} else {\n\t\tif (i_size_read(inode) == 0)\n\t\t\treturn;\n\t\tpage = find_or_create_page(mapping, 0,\n\t\t\t\t\t   mapping_gfp_mask(mapping) & ~__GFP_FS);\n\t\tif (!page)\n\t\t\treturn;\n\t\tif (PageUptodate(page)) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tdout(\"fill_inline_data %p %llx.%llx len %zu locked_page %p\\n\",\n\t     inode, ceph_vinop(inode), len, locked_page);\n\n\tif (len > 0) {\n\t\tvoid *kaddr = kmap_atomic(page);\n\t\tmemcpy(kaddr, data, len);\n\t\tkunmap_atomic(kaddr);\n\t}\n\n\tif (page != locked_page) {\n\t\tif (len < PAGE_CACHE_SIZE)\n\t\t\tzero_user_segment(page, len, PAGE_CACHE_SIZE);\n\t\telse\n\t\t\tflush_dcache_page(page);\n\n\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/osd_client.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>\t/* generic_writepages */",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_fill_inline_data(struct inode *inode, struct page *locked_page,\n\t\t\t   char\t*data, size_t len)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page;\n\n\tif (locked_page) {\n\t\tpage = locked_page;\n\t} else {\n\t\tif (i_size_read(inode) == 0)\n\t\t\treturn;\n\t\tpage = find_or_create_page(mapping, 0,\n\t\t\t\t\t   mapping_gfp_mask(mapping) & ~__GFP_FS);\n\t\tif (!page)\n\t\t\treturn;\n\t\tif (PageUptodate(page)) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tdout(\"fill_inline_data %p %llx.%llx len %zu locked_page %p\\n\",\n\t     inode, ceph_vinop(inode), len, locked_page);\n\n\tif (len > 0) {\n\t\tvoid *kaddr = kmap_atomic(page);\n\t\tmemcpy(kaddr, data, len);\n\t\tkunmap_atomic(kaddr);\n\t}\n\n\tif (page != locked_page) {\n\t\tif (len < PAGE_CACHE_SIZE)\n\t\t\tzero_user_segment(page, len, PAGE_CACHE_SIZE);\n\t\telse\n\t\t\tflush_dcache_page(page);\n\n\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mdsc->snap_rwsem"
          ],
          "line": 2655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kick_flushing_inode_caps",
          "args": [
            "mdsc",
            "session",
            "inode"
          ],
          "line": 2654
        },
        "resolved": true,
        "details": {
          "function_name": "kick_flushing_inode_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "2005-2039",
          "snippet": "static void kick_flushing_inode_caps(struct ceph_mds_client *mdsc,\n\t\t\t\t     struct ceph_mds_session *session,\n\t\t\t\t     struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_cap *cap;\n\tint delayed = 0;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tcap = ci->i_auth_cap;\n\tdout(\"kick_flushing_inode_caps %p flushing %s flush_seq %lld\\n\", inode,\n\t     ceph_cap_string(ci->i_flushing_caps), ci->i_cap_flush_seq);\n\n\t__ceph_flush_snaps(ci, &session, 1);\n\n\tif (ci->i_flushing_caps) {\n\t\tspin_lock(&mdsc->cap_dirty_lock);\n\t\tlist_move_tail(&ci->i_flushing_item,\n\t\t\t       &cap->session->s_cap_flushing);\n\t\tspin_unlock(&mdsc->cap_dirty_lock);\n\n\t\tdelayed = __send_cap(mdsc, cap, CEPH_CAP_OP_FLUSH,\n\t\t\t\t     __ceph_caps_used(ci),\n\t\t\t\t     __ceph_caps_wanted(ci),\n\t\t\t\t     cap->issued | cap->implemented,\n\t\t\t\t     ci->i_flushing_caps, NULL);\n\t\tif (delayed) {\n\t\t\tspin_lock(&ci->i_ceph_lock);\n\t\t\t__cap_delay_requeue(mdsc, ci);\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void kick_flushing_inode_caps(struct ceph_mds_client *mdsc,\n\t\t\t\t     struct ceph_mds_session *session,\n\t\t\t\t     struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_cap *cap;\n\tint delayed = 0;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tcap = ci->i_auth_cap;\n\tdout(\"kick_flushing_inode_caps %p flushing %s flush_seq %lld\\n\", inode,\n\t     ceph_cap_string(ci->i_flushing_caps), ci->i_cap_flush_seq);\n\n\t__ceph_flush_snaps(ci, &session, 1);\n\n\tif (ci->i_flushing_caps) {\n\t\tspin_lock(&mdsc->cap_dirty_lock);\n\t\tlist_move_tail(&ci->i_flushing_item,\n\t\t\t       &cap->session->s_cap_flushing);\n\t\tspin_unlock(&mdsc->cap_dirty_lock);\n\n\t\tdelayed = __send_cap(mdsc, cap, CEPH_CAP_OP_FLUSH,\n\t\t\t\t     __ceph_caps_used(ci),\n\t\t\t\t     __ceph_caps_wanted(ci),\n\t\t\t\t     cap->issued | cap->implemented,\n\t\t\t\t     ci->i_flushing_caps, NULL);\n\t\tif (delayed) {\n\t\t\tspin_lock(&ci->i_ceph_lock);\n\t\t\t__cap_delay_requeue(mdsc, ci);\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "grant->op"
          ],
          "line": 2653
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 2651
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cap->issued & ~cap->implemented"
          ],
          "line": 2642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ceph_caps_revoking_other",
          "args": [
            "ci",
            "cap",
            "newcaps"
          ],
          "line": 2633
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_caps_revoking_other",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "801-814",
          "snippet": "int __ceph_caps_revoking_other(struct ceph_inode_info *ci,\n\t\t\t       struct ceph_cap *ocap, int mask)\n{\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (cap != ocap &&\n\t\t    (cap->implemented & ~cap->issued & mask))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_caps_revoking_other(struct ceph_inode_info *ci,\n\t\t\t       struct ceph_cap *ocap, int mask)\n{\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (cap != ocap &&\n\t\t    (cap->implemented & ~cap->issued & mask))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"grant: %s -> %s\\n\"",
            "ceph_cap_string(cap->issued)",
            "ceph_cap_string(newcaps)"
          ],
          "line": 2629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_cap_string",
          "args": [
            "newcaps"
          ],
          "line": 2630
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_cap_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "71-116",
          "snippet": "const char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [
            "#define MAX_CAP_STR 20"
          ],
          "globals_used": [
            "static char cap_str[MAX_CAP_STR][40];",
            "static DEFINE_SPINLOCK(cap_str_lock);",
            "static int last_cap_str;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\n#define MAX_CAP_STR 20\n\nstatic char cap_str[MAX_CAP_STR][40];\nstatic DEFINE_SPINLOCK(cap_str_lock);\nstatic int last_cap_str;\n\nconst char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"caps unchanged: %s -> %s\\n\"",
            "ceph_cap_string(cap->issued)",
            "ceph_cap_string(newcaps)"
          ],
          "line": 2626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"revocation: %s -> %s (revoking %s)\\n\"",
            "ceph_cap_string(cap->issued)",
            "ceph_cap_string(newcaps)",
            "ceph_cap_string(revoking)"
          ],
          "line": 2609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"mds wanted %s -> %s\\n\"",
            "ceph_cap_string(le32_to_cpu(grant->wanted))",
            "ceph_cap_string(wanted)"
          ],
          "line": 2597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" my wanted = %s, used = %s, dirty %s\\n\"",
            "ceph_cap_string(wanted)",
            "ceph_cap_string(used)",
            "ceph_cap_string(dirty)"
          ],
          "line": 2592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ceph_caps_dirty",
          "args": [
            "ci"
          ],
          "line": 2591
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_caps_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "550-553",
          "snippet": "static inline int __ceph_caps_dirty(struct ceph_inode_info *ci)\n{\n\treturn ci->i_dirty_caps | ci->i_flushing_caps;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline int __ceph_caps_dirty(struct ceph_inode_info *ci)\n{\n\treturn ci->i_dirty_caps | ci->i_flushing_caps;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_caps_used",
          "args": [
            "ci"
          ],
          "line": 2590
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_caps_used",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "829-843",
          "snippet": "int __ceph_caps_used(struct ceph_inode_info *ci)\n{\n\tint used = 0;\n\tif (ci->i_pin_ref)\n\t\tused |= CEPH_CAP_PIN;\n\tif (ci->i_rd_ref)\n\t\tused |= CEPH_CAP_FILE_RD;\n\tif (ci->i_rdcache_ref || ci->vfs_inode.i_data.nrpages)\n\t\tused |= CEPH_CAP_FILE_CACHE;\n\tif (ci->i_wr_ref)\n\t\tused |= CEPH_CAP_FILE_WR;\n\tif (ci->i_wb_ref || ci->i_wrbuffer_ref)\n\t\tused |= CEPH_CAP_FILE_BUFFER;\n\treturn used;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_caps_used(struct ceph_inode_info *ci)\n{\n\tint used = 0;\n\tif (ci->i_pin_ref)\n\t\tused |= CEPH_CAP_PIN;\n\tif (ci->i_rd_ref)\n\t\tused |= CEPH_CAP_FILE_RD;\n\tif (ci->i_rdcache_ref || ci->vfs_inode.i_data.nrpages)\n\t\tused |= CEPH_CAP_FILE_CACHE;\n\tif (ci->i_wr_ref)\n\t\tused |= CEPH_CAP_FILE_WR;\n\tif (ci->i_wb_ref || ci->i_wrbuffer_ref)\n\t\tused |= CEPH_CAP_FILE_BUFFER;\n\treturn used;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_caps_wanted",
          "args": [
            "ci"
          ],
          "line": 2589
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_caps_wanted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "566-572",
          "snippet": "static inline int __ceph_caps_wanted(struct ceph_inode_info *ci)\n{\n\tint w = __ceph_caps_file_wanted(ci) | __ceph_caps_used(ci);\n\tif (w & CEPH_CAP_FILE_BUFFER)\n\t\tw |= CEPH_CAP_FILE_EXCL;  /* we want EXCL if dirty data */\n\treturn w;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline int __ceph_caps_wanted(struct ceph_inode_info *ci)\n{\n\tint w = __ceph_caps_file_wanted(ci) | __ceph_caps_used(ci);\n\tif (w & CEPH_CAP_FILE_BUFFER)\n\t\tw |= CEPH_CAP_FILE_EXCL;  /* we want EXCL if dirty data */\n\treturn w;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"max_size %lld -> %llu\\n\"",
            "ci->i_max_size",
            "max_size"
          ],
          "line": 2577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_fill_file_size",
          "args": [
            "inode",
            "issued",
            "le32_to_cpu(grant->truncate_seq)",
            "le64_to_cpu(grant->truncate_size)",
            "size"
          ],
          "line": 2571
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_fill_file_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "542-590",
          "snippet": "int ceph_fill_file_size(struct inode *inode, int issued,\n\t\t\tu32 truncate_seq, u64 truncate_size, u64 size)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint queue_trunc = 0;\n\n\tif (ceph_seq_cmp(truncate_seq, ci->i_truncate_seq) > 0 ||\n\t    (truncate_seq == ci->i_truncate_seq && size > inode->i_size)) {\n\t\tdout(\"size %lld -> %llu\\n\", inode->i_size, size);\n\t\tinode->i_size = size;\n\t\tinode->i_blocks = (size + (1<<9) - 1) >> 9;\n\t\tci->i_reported_size = size;\n\t\tif (truncate_seq != ci->i_truncate_seq) {\n\t\t\tdout(\"truncate_seq %u -> %u\\n\",\n\t\t\t     ci->i_truncate_seq, truncate_seq);\n\t\t\tci->i_truncate_seq = truncate_seq;\n\n\t\t\t/* the MDS should have revoked these caps */\n\t\t\tWARN_ON_ONCE(issued & (CEPH_CAP_FILE_EXCL |\n\t\t\t\t\t       CEPH_CAP_FILE_RD |\n\t\t\t\t\t       CEPH_CAP_FILE_WR |\n\t\t\t\t\t       CEPH_CAP_FILE_LAZYIO));\n\t\t\t/*\n\t\t\t * If we hold relevant caps, or in the case where we're\n\t\t\t * not the only client referencing this file and we\n\t\t\t * don't hold those caps, then we need to check whether\n\t\t\t * the file is either opened or mmaped\n\t\t\t */\n\t\t\tif ((issued & (CEPH_CAP_FILE_CACHE|\n\t\t\t\t       CEPH_CAP_FILE_BUFFER)) ||\n\t\t\t    mapping_mapped(inode->i_mapping) ||\n\t\t\t    __ceph_caps_file_wanted(ci)) {\n\t\t\t\tci->i_truncate_pending++;\n\t\t\t\tqueue_trunc = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (ceph_seq_cmp(truncate_seq, ci->i_truncate_seq) >= 0 &&\n\t    ci->i_truncate_size != truncate_size) {\n\t\tdout(\"truncate_size %lld -> %llu\\n\", ci->i_truncate_size,\n\t\t     truncate_size);\n\t\tci->i_truncate_size = truncate_size;\n\t}\n\n\tif (queue_trunc)\n\t\tceph_fscache_invalidate(inode);\n\n\treturn queue_trunc;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_fill_file_size(struct inode *inode, int issued,\n\t\t\tu32 truncate_seq, u64 truncate_size, u64 size)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint queue_trunc = 0;\n\n\tif (ceph_seq_cmp(truncate_seq, ci->i_truncate_seq) > 0 ||\n\t    (truncate_seq == ci->i_truncate_seq && size > inode->i_size)) {\n\t\tdout(\"size %lld -> %llu\\n\", inode->i_size, size);\n\t\tinode->i_size = size;\n\t\tinode->i_blocks = (size + (1<<9) - 1) >> 9;\n\t\tci->i_reported_size = size;\n\t\tif (truncate_seq != ci->i_truncate_seq) {\n\t\t\tdout(\"truncate_seq %u -> %u\\n\",\n\t\t\t     ci->i_truncate_seq, truncate_seq);\n\t\t\tci->i_truncate_seq = truncate_seq;\n\n\t\t\t/* the MDS should have revoked these caps */\n\t\t\tWARN_ON_ONCE(issued & (CEPH_CAP_FILE_EXCL |\n\t\t\t\t\t       CEPH_CAP_FILE_RD |\n\t\t\t\t\t       CEPH_CAP_FILE_WR |\n\t\t\t\t\t       CEPH_CAP_FILE_LAZYIO));\n\t\t\t/*\n\t\t\t * If we hold relevant caps, or in the case where we're\n\t\t\t * not the only client referencing this file and we\n\t\t\t * don't hold those caps, then we need to check whether\n\t\t\t * the file is either opened or mmaped\n\t\t\t */\n\t\t\tif ((issued & (CEPH_CAP_FILE_CACHE|\n\t\t\t\t       CEPH_CAP_FILE_BUFFER)) ||\n\t\t\t    mapping_mapped(inode->i_mapping) ||\n\t\t\t    __ceph_caps_file_wanted(ci)) {\n\t\t\t\tci->i_truncate_pending++;\n\t\t\t\tqueue_trunc = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (ceph_seq_cmp(truncate_seq, ci->i_truncate_seq) >= 0 &&\n\t    ci->i_truncate_size != truncate_size) {\n\t\tdout(\"truncate_size %lld -> %llu\\n\", ci->i_truncate_size,\n\t\t     truncate_size);\n\t\tci->i_truncate_size = truncate_size;\n\t}\n\n\tif (queue_trunc)\n\t\tceph_fscache_invalidate(inode);\n\n\treturn queue_trunc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "grant->truncate_size"
          ],
          "line": 2573
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_fill_file_time",
          "args": [
            "inode",
            "issued",
            "le32_to_cpu(grant->time_warp_seq)",
            "&ctime",
            "&mtime",
            "&atime"
          ],
          "line": 2562
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_fill_file_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "592-656",
          "snippet": "void ceph_fill_file_time(struct inode *inode, int issued,\n\t\t\t u64 time_warp_seq, struct timespec *ctime,\n\t\t\t struct timespec *mtime, struct timespec *atime)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint warn = 0;\n\n\tif (issued & (CEPH_CAP_FILE_EXCL|\n\t\t      CEPH_CAP_FILE_WR|\n\t\t      CEPH_CAP_FILE_BUFFER|\n\t\t      CEPH_CAP_AUTH_EXCL|\n\t\t      CEPH_CAP_XATTR_EXCL)) {\n\t\tif (timespec_compare(ctime, &inode->i_ctime) > 0) {\n\t\t\tdout(\"ctime %ld.%09ld -> %ld.%09ld inc w/ cap\\n\",\n\t\t\t     inode->i_ctime.tv_sec, inode->i_ctime.tv_nsec,\n\t\t\t     ctime->tv_sec, ctime->tv_nsec);\n\t\t\tinode->i_ctime = *ctime;\n\t\t}\n\t\tif (ceph_seq_cmp(time_warp_seq, ci->i_time_warp_seq) > 0) {\n\t\t\t/* the MDS did a utimes() */\n\t\t\tdout(\"mtime %ld.%09ld -> %ld.%09ld \"\n\t\t\t     \"tw %d -> %d\\n\",\n\t\t\t     inode->i_mtime.tv_sec, inode->i_mtime.tv_nsec,\n\t\t\t     mtime->tv_sec, mtime->tv_nsec,\n\t\t\t     ci->i_time_warp_seq, (int)time_warp_seq);\n\n\t\t\tinode->i_mtime = *mtime;\n\t\t\tinode->i_atime = *atime;\n\t\t\tci->i_time_warp_seq = time_warp_seq;\n\t\t} else if (time_warp_seq == ci->i_time_warp_seq) {\n\t\t\t/* nobody did utimes(); take the max */\n\t\t\tif (timespec_compare(mtime, &inode->i_mtime) > 0) {\n\t\t\t\tdout(\"mtime %ld.%09ld -> %ld.%09ld inc\\n\",\n\t\t\t\t     inode->i_mtime.tv_sec,\n\t\t\t\t     inode->i_mtime.tv_nsec,\n\t\t\t\t     mtime->tv_sec, mtime->tv_nsec);\n\t\t\t\tinode->i_mtime = *mtime;\n\t\t\t}\n\t\t\tif (timespec_compare(atime, &inode->i_atime) > 0) {\n\t\t\t\tdout(\"atime %ld.%09ld -> %ld.%09ld inc\\n\",\n\t\t\t\t     inode->i_atime.tv_sec,\n\t\t\t\t     inode->i_atime.tv_nsec,\n\t\t\t\t     atime->tv_sec, atime->tv_nsec);\n\t\t\t\tinode->i_atime = *atime;\n\t\t\t}\n\t\t} else if (issued & CEPH_CAP_FILE_EXCL) {\n\t\t\t/* we did a utimes(); ignore mds values */\n\t\t} else {\n\t\t\twarn = 1;\n\t\t}\n\t} else {\n\t\t/* we have no write|excl caps; whatever the MDS says is true */\n\t\tif (ceph_seq_cmp(time_warp_seq, ci->i_time_warp_seq) >= 0) {\n\t\t\tinode->i_ctime = *ctime;\n\t\t\tinode->i_mtime = *mtime;\n\t\t\tinode->i_atime = *atime;\n\t\t\tci->i_time_warp_seq = time_warp_seq;\n\t\t} else {\n\t\t\twarn = 1;\n\t\t}\n\t}\n\tif (warn) /* time_warp_seq shouldn't go backwards */\n\t\tdout(\"%p mds time_warp_seq %llu < %u\\n\",\n\t\t     inode, time_warp_seq, ci->i_time_warp_seq);\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_fill_file_time(struct inode *inode, int issued,\n\t\t\t u64 time_warp_seq, struct timespec *ctime,\n\t\t\t struct timespec *mtime, struct timespec *atime)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint warn = 0;\n\n\tif (issued & (CEPH_CAP_FILE_EXCL|\n\t\t      CEPH_CAP_FILE_WR|\n\t\t      CEPH_CAP_FILE_BUFFER|\n\t\t      CEPH_CAP_AUTH_EXCL|\n\t\t      CEPH_CAP_XATTR_EXCL)) {\n\t\tif (timespec_compare(ctime, &inode->i_ctime) > 0) {\n\t\t\tdout(\"ctime %ld.%09ld -> %ld.%09ld inc w/ cap\\n\",\n\t\t\t     inode->i_ctime.tv_sec, inode->i_ctime.tv_nsec,\n\t\t\t     ctime->tv_sec, ctime->tv_nsec);\n\t\t\tinode->i_ctime = *ctime;\n\t\t}\n\t\tif (ceph_seq_cmp(time_warp_seq, ci->i_time_warp_seq) > 0) {\n\t\t\t/* the MDS did a utimes() */\n\t\t\tdout(\"mtime %ld.%09ld -> %ld.%09ld \"\n\t\t\t     \"tw %d -> %d\\n\",\n\t\t\t     inode->i_mtime.tv_sec, inode->i_mtime.tv_nsec,\n\t\t\t     mtime->tv_sec, mtime->tv_nsec,\n\t\t\t     ci->i_time_warp_seq, (int)time_warp_seq);\n\n\t\t\tinode->i_mtime = *mtime;\n\t\t\tinode->i_atime = *atime;\n\t\t\tci->i_time_warp_seq = time_warp_seq;\n\t\t} else if (time_warp_seq == ci->i_time_warp_seq) {\n\t\t\t/* nobody did utimes(); take the max */\n\t\t\tif (timespec_compare(mtime, &inode->i_mtime) > 0) {\n\t\t\t\tdout(\"mtime %ld.%09ld -> %ld.%09ld inc\\n\",\n\t\t\t\t     inode->i_mtime.tv_sec,\n\t\t\t\t     inode->i_mtime.tv_nsec,\n\t\t\t\t     mtime->tv_sec, mtime->tv_nsec);\n\t\t\t\tinode->i_mtime = *mtime;\n\t\t\t}\n\t\t\tif (timespec_compare(atime, &inode->i_atime) > 0) {\n\t\t\t\tdout(\"atime %ld.%09ld -> %ld.%09ld inc\\n\",\n\t\t\t\t     inode->i_atime.tv_sec,\n\t\t\t\t     inode->i_atime.tv_nsec,\n\t\t\t\t     atime->tv_sec, atime->tv_nsec);\n\t\t\t\tinode->i_atime = *atime;\n\t\t\t}\n\t\t} else if (issued & CEPH_CAP_FILE_EXCL) {\n\t\t\t/* we did a utimes(); ignore mds values */\n\t\t} else {\n\t\t\twarn = 1;\n\t\t}\n\t} else {\n\t\t/* we have no write|excl caps; whatever the MDS says is true */\n\t\tif (ceph_seq_cmp(time_warp_seq, ci->i_time_warp_seq) >= 0) {\n\t\t\tinode->i_ctime = *ctime;\n\t\t\tinode->i_mtime = *mtime;\n\t\t\tinode->i_atime = *atime;\n\t\t\tci->i_time_warp_seq = time_warp_seq;\n\t\t} else {\n\t\t\twarn = 1;\n\t\t}\n\t}\n\tif (warn) /* time_warp_seq shouldn't go backwards */\n\t\tdout(\"%p mds time_warp_seq %llu < %u\\n\",\n\t\t     inode, time_warp_seq, ci->i_time_warp_seq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_decode_timespec",
          "args": [
            "&ctime",
            "&grant->ctime"
          ],
          "line": 2561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_timespec",
          "args": [
            "&atime",
            "&grant->atime"
          ],
          "line": 2560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_timespec",
          "args": [
            "&mtime",
            "&grant->mtime"
          ],
          "line": 2559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_forget_all_cached_acls",
          "args": [
            "inode"
          ],
          "line": 2548
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_forget_all_cached_acls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "818-820",
          "snippet": "static inline void ceph_forget_all_cached_acls(struct inode *inode)\n{\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline void ceph_forget_all_cached_acls(struct inode *inode)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_buffer_get",
          "args": [
            "xattr_buf"
          ],
          "line": 2546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_buffer_put",
          "args": [
            "ci->i_xattrs.blob"
          ],
          "line": 2545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" got new xattrs v%llu on %p len %d\\n\"",
            "version",
            "inode",
            "len"
          ],
          "line": 2542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "le32_to_cpu(grant->nlink)"
          ],
          "line": 2531
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"%p mode 0%o uid.gid %d.%d\\n\"",
            "inode",
            "inode->i_mode",
            "from_kuid(&init_user_ns, inode->i_uid)",
            "from_kgid(&init_user_ns, inode->i_gid)"
          ],
          "line": 2524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "inode->i_gid"
          ],
          "line": 2526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "inode->i_uid"
          ],
          "line": 2525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "&init_user_ns",
            "le32_to_cpu(grant->gid)"
          ],
          "line": 2523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "&init_user_ns",
            "le32_to_cpu(grant->uid)"
          ],
          "line": 2522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__check_cap_issue",
          "args": [
            "ci",
            "cap",
            "newcaps"
          ],
          "line": 2517
        },
        "resolved": true,
        "details": {
          "function_name": "__check_cap_issue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "473-500",
          "snippet": "static void __check_cap_issue(struct ceph_inode_info *ci, struct ceph_cap *cap,\n\t\t\t      unsigned issued)\n{\n\tunsigned had = __ceph_caps_issued(ci, NULL);\n\n\t/*\n\t * Each time we receive FILE_CACHE anew, we increment\n\t * i_rdcache_gen.\n\t */\n\tif ((issued & (CEPH_CAP_FILE_CACHE|CEPH_CAP_FILE_LAZYIO)) &&\n\t    (had & (CEPH_CAP_FILE_CACHE|CEPH_CAP_FILE_LAZYIO)) == 0) {\n\t\tci->i_rdcache_gen++;\n\t}\n\n\t/*\n\t * if we are newly issued FILE_SHARED, mark dir not complete; we\n\t * don't know what happened to this directory while we didn't\n\t * have the cap.\n\t */\n\tif ((issued & CEPH_CAP_FILE_SHARED) &&\n\t    (had & CEPH_CAP_FILE_SHARED) == 0) {\n\t\tci->i_shared_gen++;\n\t\tif (S_ISDIR(ci->vfs_inode.i_mode)) {\n\t\t\tdout(\" marking %p NOT complete\\n\", &ci->vfs_inode);\n\t\t\t__ceph_dir_clear_complete(ci);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __check_cap_issue(struct ceph_inode_info *ci, struct ceph_cap *cap,\n\t\t\t      unsigned issued)\n{\n\tunsigned had = __ceph_caps_issued(ci, NULL);\n\n\t/*\n\t * Each time we receive FILE_CACHE anew, we increment\n\t * i_rdcache_gen.\n\t */\n\tif ((issued & (CEPH_CAP_FILE_CACHE|CEPH_CAP_FILE_LAZYIO)) &&\n\t    (had & (CEPH_CAP_FILE_CACHE|CEPH_CAP_FILE_LAZYIO)) == 0) {\n\t\tci->i_rdcache_gen++;\n\t}\n\n\t/*\n\t * if we are newly issued FILE_SHARED, mark dir not complete; we\n\t * don't know what happened to this directory while we didn't\n\t * have the cap.\n\t */\n\tif ((issued & CEPH_CAP_FILE_SHARED) &&\n\t    (had & CEPH_CAP_FILE_SHARED) == 0) {\n\t\tci->i_shared_gen++;\n\t\tif (S_ISDIR(ci->vfs_inode.i_mode)) {\n\t\t\tdout(\" marking %p NOT complete\\n\", &ci->vfs_inode);\n\t\t\t__ceph_dir_clear_complete(ci);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_fscache_invalidate",
          "args": [
            "inode"
          ],
          "line": 2510
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_fscache_invalidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.h",
          "lines": "148-150",
          "snippet": "static inline void ceph_fscache_invalidate(struct inode *inode)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void ceph_fscache_invalidate(struct inode *inode)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_nonblocking_invalidate",
          "args": [
            "inode"
          ],
          "line": 2501
        },
        "resolved": true,
        "details": {
          "function_name": "try_nonblocking_invalidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "1472-1491",
          "snippet": "static int try_nonblocking_invalidate(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tu32 invalidating_gen = ci->i_rdcache_gen;\n\n\tspin_unlock(&ci->i_ceph_lock);\n\tinvalidate_mapping_pages(&inode->i_data, 0, -1);\n\tspin_lock(&ci->i_ceph_lock);\n\n\tif (inode->i_data.nrpages == 0 &&\n\t    invalidating_gen == ci->i_rdcache_gen) {\n\t\t/* success. */\n\t\tdout(\"try_nonblocking_invalidate %p success\\n\", inode);\n\t\t/* save any racing async invalidate some trouble */\n\t\tci->i_rdcache_revoking = ci->i_rdcache_gen - 1;\n\t\treturn 0;\n\t}\n\tdout(\"try_nonblocking_invalidate %p failed\\n\", inode);\n\treturn -1;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int try_nonblocking_invalidate(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tu32 invalidating_gen = ci->i_rdcache_gen;\n\n\tspin_unlock(&ci->i_ceph_lock);\n\tinvalidate_mapping_pages(&inode->i_data, 0, -1);\n\tspin_lock(&ci->i_ceph_lock);\n\n\tif (inode->i_data.nrpages == 0 &&\n\t    invalidating_gen == ci->i_rdcache_gen) {\n\t\t/* success. */\n\t\tdout(\"try_nonblocking_invalidate %p success\\n\", inode);\n\t\t/* save any racing async invalidate some trouble */\n\t\tci->i_rdcache_revoking = ci->i_rdcache_gen - 1;\n\t\treturn 0;\n\t}\n\tdout(\"try_nonblocking_invalidate %p failed\\n\", inode);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "cap->cap_id != le64_to_cpu(grant->cap_id)"
          ],
          "line": 2488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "cap != ci->i_auth_cap"
          ],
          "line": 2487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_seq_cmp",
          "args": [
            "seq",
            "cap->seq"
          ],
          "line": 2486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" size %llu max_size %llu, i_size %llu\\n\"",
            "size",
            "max_size",
            "inode->i_size"
          ],
          "line": 2474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"handle_cap_grant inode %p cap %p mds%d seq %d %s\\n\"",
            "inode",
            "cap",
            "mds",
            "seq",
            "ceph_cap_string(newcaps)"
          ],
          "line": 2472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 2455
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "mdsc->snap_rwsem"
          ],
          "line": 2453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "ci->i_ceph_lock"
          ],
          "line": 2452
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void handle_cap_grant(struct ceph_mds_client *mdsc,\n\t\t\t     struct inode *inode, struct ceph_mds_caps *grant,\n\t\t\t     u64 inline_version,\n\t\t\t     void *inline_data, int inline_len,\n\t\t\t     struct ceph_buffer *xattr_buf,\n\t\t\t     struct ceph_mds_session *session,\n\t\t\t     struct ceph_cap *cap, int issued)\n\t__releases(ci->i_ceph_lock)\n\t__releases(mdsc->snap_rwsem)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint mds = session->s_mds;\n\tint seq = le32_to_cpu(grant->seq);\n\tint newcaps = le32_to_cpu(grant->caps);\n\tint used, wanted, dirty;\n\tu64 size = le64_to_cpu(grant->size);\n\tu64 max_size = le64_to_cpu(grant->max_size);\n\tstruct timespec mtime, atime, ctime;\n\tint check_caps = 0;\n\tbool wake = false;\n\tbool writeback = false;\n\tbool queue_trunc = false;\n\tbool queue_invalidate = false;\n\tbool queue_revalidate = false;\n\tbool deleted_inode = false;\n\tbool fill_inline = false;\n\n\tdout(\"handle_cap_grant inode %p cap %p mds%d seq %d %s\\n\",\n\t     inode, cap, mds, seq, ceph_cap_string(newcaps));\n\tdout(\" size %llu max_size %llu, i_size %llu\\n\", size, max_size,\n\t\tinode->i_size);\n\n\n\t/*\n\t * auth mds of the inode changed. we received the cap export message,\n\t * but still haven't received the cap import message. handle_cap_export\n\t * updated the new auth MDS' cap.\n\t *\n\t * \"ceph_seq_cmp(seq, cap->seq) <= 0\" means we are processing a message\n\t * that was sent before the cap import message. So don't remove caps.\n\t */\n\tif (ceph_seq_cmp(seq, cap->seq) <= 0) {\n\t\tWARN_ON(cap != ci->i_auth_cap);\n\t\tWARN_ON(cap->cap_id != le64_to_cpu(grant->cap_id));\n\t\tseq = cap->seq;\n\t\tnewcaps |= cap->issued;\n\t}\n\n\t/*\n\t * If CACHE is being revoked, and we have no dirty buffers,\n\t * try to invalidate (once).  (If there are dirty buffers, we\n\t * will invalidate _after_ writeback.)\n\t */\n\tif (((cap->issued & ~newcaps) & CEPH_CAP_FILE_CACHE) &&\n\t    (newcaps & CEPH_CAP_FILE_LAZYIO) == 0 &&\n\t    !ci->i_wrbuffer_ref) {\n\t\tif (try_nonblocking_invalidate(inode)) {\n\t\t\t/* there were locked pages.. invalidate later\n\t\t\t   in a separate thread. */\n\t\t\tif (ci->i_rdcache_revoking != ci->i_rdcache_gen) {\n\t\t\t\tqueue_invalidate = true;\n\t\t\t\tci->i_rdcache_revoking = ci->i_rdcache_gen;\n\t\t\t}\n\t\t}\n\n\t\tceph_fscache_invalidate(inode);\n\t}\n\n\t/* side effects now are allowed */\n\tcap->cap_gen = session->s_cap_gen;\n\tcap->seq = seq;\n\n\t__check_cap_issue(ci, cap, newcaps);\n\n\tif ((newcaps & CEPH_CAP_AUTH_SHARED) &&\n\t    (issued & CEPH_CAP_AUTH_EXCL) == 0) {\n\t\tinode->i_mode = le32_to_cpu(grant->mode);\n\t\tinode->i_uid = make_kuid(&init_user_ns, le32_to_cpu(grant->uid));\n\t\tinode->i_gid = make_kgid(&init_user_ns, le32_to_cpu(grant->gid));\n\t\tdout(\"%p mode 0%o uid.gid %d.%d\\n\", inode, inode->i_mode,\n\t\t     from_kuid(&init_user_ns, inode->i_uid),\n\t\t     from_kgid(&init_user_ns, inode->i_gid));\n\t}\n\n\tif ((newcaps & CEPH_CAP_AUTH_SHARED) &&\n\t    (issued & CEPH_CAP_LINK_EXCL) == 0) {\n\t\tset_nlink(inode, le32_to_cpu(grant->nlink));\n\t\tif (inode->i_nlink == 0 &&\n\t\t    (newcaps & (CEPH_CAP_LINK_SHARED | CEPH_CAP_LINK_EXCL)))\n\t\t\tdeleted_inode = true;\n\t}\n\n\tif ((issued & CEPH_CAP_XATTR_EXCL) == 0 && grant->xattr_len) {\n\t\tint len = le32_to_cpu(grant->xattr_len);\n\t\tu64 version = le64_to_cpu(grant->xattr_version);\n\n\t\tif (version > ci->i_xattrs.version) {\n\t\t\tdout(\" got new xattrs v%llu on %p len %d\\n\",\n\t\t\t     version, inode, len);\n\t\t\tif (ci->i_xattrs.blob)\n\t\t\t\tceph_buffer_put(ci->i_xattrs.blob);\n\t\t\tci->i_xattrs.blob = ceph_buffer_get(xattr_buf);\n\t\t\tci->i_xattrs.version = version;\n\t\t\tceph_forget_all_cached_acls(inode);\n\t\t}\n\t}\n\n\t/* Do we need to revalidate our fscache cookie. Don't bother on the\n\t * first cache cap as we already validate at cookie creation time. */\n\tif ((issued & CEPH_CAP_FILE_CACHE) && ci->i_rdcache_gen > 1)\n\t\tqueue_revalidate = true;\n\n\tif (newcaps & CEPH_CAP_ANY_RD) {\n\t\t/* ctime/mtime/atime? */\n\t\tceph_decode_timespec(&mtime, &grant->mtime);\n\t\tceph_decode_timespec(&atime, &grant->atime);\n\t\tceph_decode_timespec(&ctime, &grant->ctime);\n\t\tceph_fill_file_time(inode, issued,\n\t\t\t\t    le32_to_cpu(grant->time_warp_seq),\n\t\t\t\t    &ctime, &mtime, &atime);\n\t}\n\n\tif (newcaps & (CEPH_CAP_ANY_FILE_RD | CEPH_CAP_ANY_FILE_WR)) {\n\t\t/* file layout may have changed */\n\t\tci->i_layout = grant->layout;\n\t\t/* size/truncate_seq? */\n\t\tqueue_trunc = ceph_fill_file_size(inode, issued,\n\t\t\t\t\tle32_to_cpu(grant->truncate_seq),\n\t\t\t\t\tle64_to_cpu(grant->truncate_size),\n\t\t\t\t\tsize);\n\t\t/* max size increase? */\n\t\tif (ci->i_auth_cap == cap && max_size != ci->i_max_size) {\n\t\t\tdout(\"max_size %lld -> %llu\\n\",\n\t\t\t     ci->i_max_size, max_size);\n\t\t\tci->i_max_size = max_size;\n\t\t\tif (max_size >= ci->i_wanted_max_size) {\n\t\t\t\tci->i_wanted_max_size = 0;  /* reset */\n\t\t\t\tci->i_requested_max_size = 0;\n\t\t\t}\n\t\t\twake = true;\n\t\t}\n\t}\n\n\t/* check cap bits */\n\twanted = __ceph_caps_wanted(ci);\n\tused = __ceph_caps_used(ci);\n\tdirty = __ceph_caps_dirty(ci);\n\tdout(\" my wanted = %s, used = %s, dirty %s\\n\",\n\t     ceph_cap_string(wanted),\n\t     ceph_cap_string(used),\n\t     ceph_cap_string(dirty));\n\tif (wanted != le32_to_cpu(grant->wanted)) {\n\t\tdout(\"mds wanted %s -> %s\\n\",\n\t\t     ceph_cap_string(le32_to_cpu(grant->wanted)),\n\t\t     ceph_cap_string(wanted));\n\t\t/* imported cap may not have correct mds_wanted */\n\t\tif (le32_to_cpu(grant->op) == CEPH_CAP_OP_IMPORT)\n\t\t\tcheck_caps = 1;\n\t}\n\n\t/* revocation, grant, or no-op? */\n\tif (cap->issued & ~newcaps) {\n\t\tint revoking = cap->issued & ~newcaps;\n\n\t\tdout(\"revocation: %s -> %s (revoking %s)\\n\",\n\t\t     ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(newcaps),\n\t\t     ceph_cap_string(revoking));\n\t\tif (revoking & used & CEPH_CAP_FILE_BUFFER)\n\t\t\twriteback = true;  /* initiate writeback; will delay ack */\n\t\telse if (revoking == CEPH_CAP_FILE_CACHE &&\n\t\t\t (newcaps & CEPH_CAP_FILE_LAZYIO) == 0 &&\n\t\t\t queue_invalidate)\n\t\t\t; /* do nothing yet, invalidation will be queued */\n\t\telse if (cap == ci->i_auth_cap)\n\t\t\tcheck_caps = 1; /* check auth cap only */\n\t\telse\n\t\t\tcheck_caps = 2; /* check all caps */\n\t\tcap->issued = newcaps;\n\t\tcap->implemented |= newcaps;\n\t} else if (cap->issued == newcaps) {\n\t\tdout(\"caps unchanged: %s -> %s\\n\",\n\t\t     ceph_cap_string(cap->issued), ceph_cap_string(newcaps));\n\t} else {\n\t\tdout(\"grant: %s -> %s\\n\", ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(newcaps));\n\t\t/* non-auth MDS is revoking the newly grant caps ? */\n\t\tif (cap == ci->i_auth_cap &&\n\t\t    __ceph_caps_revoking_other(ci, cap, newcaps))\n\t\t    check_caps = 2;\n\n\t\tcap->issued = newcaps;\n\t\tcap->implemented |= newcaps; /* add bits only, to\n\t\t\t\t\t      * avoid stepping on a\n\t\t\t\t\t      * pending revocation */\n\t\twake = true;\n\t}\n\tBUG_ON(cap->issued & ~cap->implemented);\n\n\tif (inline_version > 0 && inline_version >= ci->i_inline_version) {\n\t\tci->i_inline_version = inline_version;\n\t\tif (ci->i_inline_version != CEPH_INLINE_NONE &&\n\t\t    (newcaps & (CEPH_CAP_FILE_CACHE|CEPH_CAP_FILE_LAZYIO)))\n\t\t\tfill_inline = true;\n\t}\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (le32_to_cpu(grant->op) == CEPH_CAP_OP_IMPORT) {\n\t\tkick_flushing_inode_caps(mdsc, session, inode);\n\t\tup_read(&mdsc->snap_rwsem);\n\t\tif (newcaps & ~issued)\n\t\t\twake = true;\n\t}\n\n\tif (fill_inline)\n\t\tceph_fill_inline_data(inode, NULL, inline_data, inline_len);\n\n\tif (queue_trunc) {\n\t\tceph_queue_vmtruncate(inode);\n\t\tceph_queue_revalidate(inode);\n\t} else if (queue_revalidate)\n\t\tceph_queue_revalidate(inode);\n\n\tif (writeback)\n\t\t/*\n\t\t * queue inode for writeback: we can't actually call\n\t\t * filemap_write_and_wait, etc. from message handler\n\t\t * context.\n\t\t */\n\t\tceph_queue_writeback(inode);\n\tif (queue_invalidate)\n\t\tceph_queue_invalidate(inode);\n\tif (deleted_inode)\n\t\tinvalidate_aliases(inode);\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\n\tif (check_caps == 1)\n\t\tceph_check_caps(ci, CHECK_CAPS_NODELAY|CHECK_CAPS_AUTHONLY,\n\t\t\t\tsession);\n\telse if (check_caps == 2)\n\t\tceph_check_caps(ci, CHECK_CAPS_NODELAY, session);\n\telse\n\t\tmutex_unlock(&session->s_mutex);\n}"
  },
  {
    "function_name": "invalidate_aliases",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "2410-2437",
    "snippet": "static void invalidate_aliases(struct inode *inode)\n{\n\tstruct dentry *dn, *prev = NULL;\n\n\tdout(\"invalidate_aliases inode %p\\n\", inode);\n\td_prune_aliases(inode);\n\t/*\n\t * For non-directory inode, d_find_alias() only returns\n\t * hashed dentry. After calling d_invalidate(), the\n\t * dentry becomes unhashed.\n\t *\n\t * For directory inode, d_find_alias() can return\n\t * unhashed dentry. But directory inode should have\n\t * one alias at most.\n\t */\n\twhile ((dn = d_find_alias(inode))) {\n\t\tif (dn == prev) {\n\t\t\tdput(dn);\n\t\t\tbreak;\n\t\t}\n\t\td_invalidate(dn);\n\t\tif (prev)\n\t\t\tdput(prev);\n\t\tprev = dn;\n\t}\n\tif (prev)\n\t\tdput(prev);\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "prev"
          ],
          "line": 2436
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_invalidate",
          "args": [
            "dn"
          ],
          "line": 2430
        },
        "resolved": true,
        "details": {
          "function_name": "d_invalidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1465-1506",
          "snippet": "void d_invalidate(struct dentry *dentry)\n{\n\t/*\n\t * If it's already been dropped, return OK.\n\t */\n\tspin_lock(&dentry->d_lock);\n\tif (d_unhashed(dentry)) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\treturn;\n\t}\n\tspin_unlock(&dentry->d_lock);\n\n\t/* Negative dentries can be dropped without further checks */\n\tif (!dentry->d_inode) {\n\t\td_drop(dentry);\n\t\treturn;\n\t}\n\n\tfor (;;) {\n\t\tstruct detach_data data;\n\n\t\tdata.mountpoint = NULL;\n\t\tINIT_LIST_HEAD(&data.select.dispose);\n\t\tdata.select.start = dentry;\n\t\tdata.select.found = 0;\n\n\t\td_walk(dentry, &data, detach_and_collect, check_and_drop);\n\n\t\tif (data.select.found)\n\t\t\tshrink_dentry_list(&data.select.dispose);\n\n\t\tif (data.mountpoint) {\n\t\t\tdetach_mounts(data.mountpoint);\n\t\t\tdput(data.mountpoint);\n\t\t}\n\n\t\tif (!data.mountpoint && !data.select.found)\n\t\t\tbreak;\n\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid d_invalidate(struct dentry *dentry)\n{\n\t/*\n\t * If it's already been dropped, return OK.\n\t */\n\tspin_lock(&dentry->d_lock);\n\tif (d_unhashed(dentry)) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\treturn;\n\t}\n\tspin_unlock(&dentry->d_lock);\n\n\t/* Negative dentries can be dropped without further checks */\n\tif (!dentry->d_inode) {\n\t\td_drop(dentry);\n\t\treturn;\n\t}\n\n\tfor (;;) {\n\t\tstruct detach_data data;\n\n\t\tdata.mountpoint = NULL;\n\t\tINIT_LIST_HEAD(&data.select.dispose);\n\t\tdata.select.start = dentry;\n\t\tdata.select.found = 0;\n\n\t\td_walk(dentry, &data, detach_and_collect, check_and_drop);\n\n\t\tif (data.select.found)\n\t\t\tshrink_dentry_list(&data.select.dispose);\n\n\t\tif (data.mountpoint) {\n\t\t\tdetach_mounts(data.mountpoint);\n\t\t\tdput(data.mountpoint);\n\t\t}\n\n\t\tif (!data.mountpoint && !data.select.found)\n\t\t\tbreak;\n\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_find_alias",
          "args": [
            "inode"
          ],
          "line": 2425
        },
        "resolved": true,
        "details": {
          "function_name": "d_find_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "865-875",
          "snippet": "struct dentry *d_find_alias(struct inode *inode)\n{\n\tstruct dentry *de = NULL;\n\n\tif (!hlist_empty(&inode->i_dentry)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tde = __d_find_alias(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\treturn de;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_find_alias(struct inode *inode)\n{\n\tstruct dentry *de = NULL;\n\n\tif (!hlist_empty(&inode->i_dentry)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tde = __d_find_alias(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\treturn de;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_prune_aliases",
          "args": [
            "inode"
          ],
          "line": 2415
        },
        "resolved": true,
        "details": {
          "function_name": "d_prune_aliases",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "882-902",
          "snippet": "void d_prune_aliases(struct inode *inode)\n{\n\tstruct dentry *dentry;\nrestart:\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry(dentry, &inode->i_dentry, d_u.d_alias) {\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (!dentry->d_lockref.count) {\n\t\t\tstruct dentry *parent = lock_parent(dentry);\n\t\t\tif (likely(!dentry->d_lockref.count)) {\n\t\t\t\t__dentry_kill(dentry);\n\t\t\t\tdput(parent);\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t\tif (parent)\n\t\t\t\tspin_unlock(&parent->d_lock);\n\t\t}\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid d_prune_aliases(struct inode *inode)\n{\n\tstruct dentry *dentry;\nrestart:\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry(dentry, &inode->i_dentry, d_u.d_alias) {\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (!dentry->d_lockref.count) {\n\t\t\tstruct dentry *parent = lock_parent(dentry);\n\t\t\tif (likely(!dentry->d_lockref.count)) {\n\t\t\t\t__dentry_kill(dentry);\n\t\t\t\tdput(parent);\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t\tif (parent)\n\t\t\t\tspin_unlock(&parent->d_lock);\n\t\t}\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"invalidate_aliases inode %p\\n\"",
            "inode"
          ],
          "line": 2414
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void invalidate_aliases(struct inode *inode)\n{\n\tstruct dentry *dn, *prev = NULL;\n\n\tdout(\"invalidate_aliases inode %p\\n\", inode);\n\td_prune_aliases(inode);\n\t/*\n\t * For non-directory inode, d_find_alias() only returns\n\t * hashed dentry. After calling d_invalidate(), the\n\t * dentry becomes unhashed.\n\t *\n\t * For directory inode, d_find_alias() can return\n\t * unhashed dentry. But directory inode should have\n\t * one alias at most.\n\t */\n\twhile ((dn = d_find_alias(inode))) {\n\t\tif (dn == prev) {\n\t\t\tdput(dn);\n\t\t\tbreak;\n\t\t}\n\t\td_invalidate(dn);\n\t\tif (prev)\n\t\t\tdput(prev);\n\t\tprev = dn;\n\t}\n\tif (prev)\n\t\tdput(prev);\n}"
  },
  {
    "function_name": "ceph_put_wrbuffer_cap_refs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "2335-2405",
    "snippet": "void ceph_put_wrbuffer_cap_refs(struct ceph_inode_info *ci, int nr,\n\t\t\t\tstruct ceph_snap_context *snapc)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint last = 0;\n\tint complete_capsnap = 0;\n\tint drop_capsnap = 0;\n\tint found = 0;\n\tstruct ceph_cap_snap *capsnap = NULL;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tci->i_wrbuffer_ref -= nr;\n\tlast = !ci->i_wrbuffer_ref;\n\n\tif (ci->i_head_snapc == snapc) {\n\t\tci->i_wrbuffer_ref_head -= nr;\n\t\tif (ci->i_wrbuffer_ref_head == 0 &&\n\t\t    ci->i_dirty_caps == 0 && ci->i_flushing_caps == 0) {\n\t\t\tBUG_ON(!ci->i_head_snapc);\n\t\t\tceph_put_snap_context(ci->i_head_snapc);\n\t\t\tci->i_head_snapc = NULL;\n\t\t}\n\t\tdout(\"put_wrbuffer_cap_refs on %p head %d/%d -> %d/%d %s\\n\",\n\t\t     inode,\n\t\t     ci->i_wrbuffer_ref+nr, ci->i_wrbuffer_ref_head+nr,\n\t\t     ci->i_wrbuffer_ref, ci->i_wrbuffer_ref_head,\n\t\t     last ? \" LAST\" : \"\");\n\t} else {\n\t\tlist_for_each_entry(capsnap, &ci->i_cap_snaps, ci_item) {\n\t\t\tif (capsnap->context == snapc) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tBUG_ON(!found);\n\t\tcapsnap->dirty_pages -= nr;\n\t\tif (capsnap->dirty_pages == 0) {\n\t\t\tcomplete_capsnap = 1;\n\t\t\tif (capsnap->dirty == 0)\n\t\t\t\t/* cap writeback completed before we created\n\t\t\t\t * the cap_snap; no FLUSHSNAP is needed */\n\t\t\t\tdrop_capsnap = 1;\n\t\t}\n\t\tdout(\"put_wrbuffer_cap_refs on %p cap_snap %p \"\n\t\t     \" snap %lld %d/%d -> %d/%d %s%s%s\\n\",\n\t\t     inode, capsnap, capsnap->context->seq,\n\t\t     ci->i_wrbuffer_ref+nr, capsnap->dirty_pages + nr,\n\t\t     ci->i_wrbuffer_ref, capsnap->dirty_pages,\n\t\t     last ? \" (wrbuffer last)\" : \"\",\n\t\t     complete_capsnap ? \" (complete capsnap)\" : \"\",\n\t\t     drop_capsnap ? \" (drop capsnap)\" : \"\");\n\t\tif (drop_capsnap) {\n\t\t\tceph_put_snap_context(capsnap->context);\n\t\t\tlist_del(&capsnap->ci_item);\n\t\t\tlist_del(&capsnap->flushing_item);\n\t\t\tceph_put_cap_snap(capsnap);\n\t\t}\n\t}\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (last) {\n\t\tceph_check_caps(ci, CHECK_CAPS_AUTHONLY, NULL);\n\t\tiput(inode);\n\t} else if (complete_capsnap) {\n\t\tceph_flush_snaps(ci);\n\t\twake_up_all(&ci->i_cap_wq);\n\t}\n\tif (drop_capsnap)\n\t\tiput(inode);\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 2404
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&ci->i_cap_wq"
          ],
          "line": 2401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_flush_snaps",
          "args": [
            "ci"
          ],
          "line": 2400
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_flush_snaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "1377-1382",
          "snippet": "static void ceph_flush_snaps(struct ceph_inode_info *ci)\n{\n\tspin_lock(&ci->i_ceph_lock);\n\t__ceph_flush_snaps(ci, NULL, 0);\n\tspin_unlock(&ci->i_ceph_lock);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void ceph_flush_snaps(struct ceph_inode_info *ci)\n{\n\tspin_lock(&ci->i_ceph_lock);\n\t__ceph_flush_snaps(ci, NULL, 0);\n\tspin_unlock(&ci->i_ceph_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_check_caps",
          "args": [
            "ci",
            "CHECK_CAPS_AUTHONLY",
            "NULL"
          ],
          "line": 2397
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_check_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "1504-1751",
          "snippet": "void ceph_check_caps(struct ceph_inode_info *ci, int flags,\n\t\t     struct ceph_mds_session *session)\n{\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(&ci->vfs_inode);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct inode *inode = &ci->vfs_inode;\n\tstruct ceph_cap *cap;\n\tint file_wanted, used, cap_used;\n\tint took_snap_rwsem = 0;             /* true if mdsc->snap_rwsem held */\n\tint issued, implemented, want, retain, revoking, flushing = 0;\n\tint mds = -1;   /* keep track of how far we've gone through i_caps list\n\t\t\t   to avoid an infinite loop on retry */\n\tstruct rb_node *p;\n\tint tried_invalidate = 0;\n\tint delayed = 0, sent = 0, force_requeue = 0, num;\n\tint queue_invalidate = 0;\n\tint is_delayed = flags & CHECK_CAPS_NODELAY;\n\n\t/* if we are unmounting, flush any unused caps immediately. */\n\tif (mdsc->stopping)\n\t\tis_delayed = 1;\n\n\tspin_lock(&ci->i_ceph_lock);\n\n\tif (ci->i_ceph_flags & CEPH_I_FLUSH)\n\t\tflags |= CHECK_CAPS_FLUSH;\n\n\t/* flush snaps first time around only */\n\tif (!list_empty(&ci->i_cap_snaps))\n\t\t__ceph_flush_snaps(ci, &session, 0);\n\tgoto retry_locked;\nretry:\n\tspin_lock(&ci->i_ceph_lock);\nretry_locked:\n\tfile_wanted = __ceph_caps_file_wanted(ci);\n\tused = __ceph_caps_used(ci);\n\twant = file_wanted | used;\n\tissued = __ceph_caps_issued(ci, &implemented);\n\trevoking = implemented & ~issued;\n\n\tretain = want | CEPH_CAP_PIN;\n\tif (!mdsc->stopping && inode->i_nlink > 0) {\n\t\tif (want) {\n\t\t\tretain |= CEPH_CAP_ANY;       /* be greedy */\n\t\t} else {\n\t\t\tretain |= CEPH_CAP_ANY_SHARED;\n\t\t\t/*\n\t\t\t * keep RD only if we didn't have the file open RW,\n\t\t\t * because then the mds would revoke it anyway to\n\t\t\t * journal max_size=0.\n\t\t\t */\n\t\t\tif (ci->i_max_size == 0)\n\t\t\t\tretain |= CEPH_CAP_ANY_RD;\n\t\t}\n\t}\n\n\tdout(\"check_caps %p file_want %s used %s dirty %s flushing %s\"\n\t     \" issued %s revoking %s retain %s %s%s%s\\n\", inode,\n\t     ceph_cap_string(file_wanted),\n\t     ceph_cap_string(used), ceph_cap_string(ci->i_dirty_caps),\n\t     ceph_cap_string(ci->i_flushing_caps),\n\t     ceph_cap_string(issued), ceph_cap_string(revoking),\n\t     ceph_cap_string(retain),\n\t     (flags & CHECK_CAPS_AUTHONLY) ? \" AUTHONLY\" : \"\",\n\t     (flags & CHECK_CAPS_NODELAY) ? \" NODELAY\" : \"\",\n\t     (flags & CHECK_CAPS_FLUSH) ? \" FLUSH\" : \"\");\n\n\t/*\n\t * If we no longer need to hold onto old our caps, and we may\n\t * have cached pages, but don't want them, then try to invalidate.\n\t * If we fail, it's because pages are locked.... try again later.\n\t */\n\tif ((!is_delayed || mdsc->stopping) &&\n\t    ci->i_wrbuffer_ref == 0 &&               /* no dirty pages... */\n\t    inode->i_data.nrpages &&                 /* have cached pages */\n\t    (file_wanted == 0 ||                     /* no open files */\n\t     (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t  CEPH_CAP_FILE_LAZYIO))) && /*  or revoking cache */\n\t    !tried_invalidate) {\n\t\tdout(\"check_caps trying to invalidate on %p\\n\", inode);\n\t\tif (try_nonblocking_invalidate(inode) < 0) {\n\t\t\tif (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t\t\tCEPH_CAP_FILE_LAZYIO)) {\n\t\t\t\tdout(\"check_caps queuing invalidate\\n\");\n\t\t\t\tqueue_invalidate = 1;\n\t\t\t\tci->i_rdcache_revoking = ci->i_rdcache_gen;\n\t\t\t} else {\n\t\t\t\tdout(\"check_caps failed to invalidate pages\\n\");\n\t\t\t\t/* we failed to invalidate pages.  check these\n\t\t\t\t   caps again later. */\n\t\t\t\tforce_requeue = 1;\n\t\t\t\t__cap_set_timeouts(mdsc, ci);\n\t\t\t}\n\t\t}\n\t\ttried_invalidate = 1;\n\t\tgoto retry_locked;\n\t}\n\n\tnum = 0;\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tnum++;\n\n\t\t/* avoid looping forever */\n\t\tif (mds >= cap->mds ||\n\t\t    ((flags & CHECK_CAPS_AUTHONLY) && cap != ci->i_auth_cap))\n\t\t\tcontinue;\n\n\t\t/* NOTE: no side-effects allowed, until we take s_mutex */\n\n\t\tcap_used = used;\n\t\tif (ci->i_auth_cap && cap != ci->i_auth_cap)\n\t\t\tcap_used &= ~ci->i_auth_cap->issued;\n\n\t\trevoking = cap->implemented & ~cap->issued;\n\t\tdout(\" mds%d cap %p used %s issued %s implemented %s revoking %s\\n\",\n\t\t     cap->mds, cap, ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(cap_used),\n\t\t     ceph_cap_string(cap->implemented),\n\t\t     ceph_cap_string(revoking));\n\n\t\tif (cap == ci->i_auth_cap &&\n\t\t    (cap->issued & CEPH_CAP_FILE_WR)) {\n\t\t\t/* request larger max_size from MDS? */\n\t\t\tif (ci->i_wanted_max_size > ci->i_max_size &&\n\t\t\t    ci->i_wanted_max_size > ci->i_requested_max_size) {\n\t\t\t\tdout(\"requesting new max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\n\t\t\t/* approaching file_max? */\n\t\t\tif ((inode->i_size << 1) >= ci->i_max_size &&\n\t\t\t    (ci->i_reported_size << 1) < ci->i_max_size) {\n\t\t\t\tdout(\"i_size approaching max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\t\t}\n\t\t/* flush anything dirty? */\n\t\tif (cap == ci->i_auth_cap && (flags & CHECK_CAPS_FLUSH) &&\n\t\t    ci->i_dirty_caps) {\n\t\t\tdout(\"flushing dirty caps\\n\");\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* completed revocation? going down and there are no caps? */\n\t\tif (revoking && (revoking & cap_used) == 0) {\n\t\t\tdout(\"completed revocation of %s\\n\",\n\t\t\t     ceph_cap_string(cap->implemented & ~cap->issued));\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* want more caps from mds? */\n\t\tif (want & ~(cap->mds_wanted | cap->issued))\n\t\t\tgoto ack;\n\n\t\t/* things we might delay */\n\t\tif ((cap->issued & ~retain) == 0 &&\n\t\t    cap->mds_wanted == want)\n\t\t\tcontinue;     /* nope, all good */\n\n\t\tif (is_delayed)\n\t\t\tgoto ack;\n\n\t\t/* delay? */\n\t\tif ((ci->i_ceph_flags & CEPH_I_NODELAY) == 0 &&\n\t\t    time_before(jiffies, ci->i_hold_caps_max)) {\n\t\t\tdout(\" delaying issued %s -> %s, wanted %s -> %s\\n\",\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(cap->issued & retain),\n\t\t\t     ceph_cap_string(cap->mds_wanted),\n\t\t\t     ceph_cap_string(want));\n\t\t\tdelayed++;\n\t\t\tcontinue;\n\t\t}\n\nack:\n\t\tif (ci->i_ceph_flags & CEPH_I_NOFLUSH) {\n\t\t\tdout(\" skipping %p I_NOFLUSH set\\n\", inode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (session && session != cap->session) {\n\t\t\tdout(\"oops, wrong session %p mutex\\n\", session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tsession = NULL;\n\t\t}\n\t\tif (!session) {\n\t\t\tsession = cap->session;\n\t\t\tif (mutex_trylock(&session->s_mutex) == 0) {\n\t\t\t\tdout(\"inverting session/ino locks on %p\\n\",\n\t\t\t\t     session);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tif (took_snap_rwsem) {\n\t\t\t\t\tup_read(&mdsc->snap_rwsem);\n\t\t\t\t\ttook_snap_rwsem = 0;\n\t\t\t\t}\n\t\t\t\tmutex_lock(&session->s_mutex);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t\t/* take snap_rwsem after session mutex */\n\t\tif (!took_snap_rwsem) {\n\t\t\tif (down_read_trylock(&mdsc->snap_rwsem) == 0) {\n\t\t\t\tdout(\"inverting snap/in locks on %p\\n\",\n\t\t\t\t     inode);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tdown_read(&mdsc->snap_rwsem);\n\t\t\t\ttook_snap_rwsem = 1;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\ttook_snap_rwsem = 1;\n\t\t}\n\n\t\tif (cap == ci->i_auth_cap && ci->i_dirty_caps)\n\t\t\tflushing = __mark_caps_flushing(inode, session);\n\t\telse\n\t\t\tflushing = 0;\n\n\t\tmds = cap->mds;  /* remember mds, so we don't repeat */\n\t\tsent++;\n\n\t\t/* __send_cap drops i_ceph_lock */\n\t\tdelayed += __send_cap(mdsc, cap, CEPH_CAP_OP_UPDATE, cap_used,\n\t\t\t\t      want, retain, flushing, NULL);\n\t\tgoto retry; /* retake i_ceph_lock and restart our cap scan. */\n\t}\n\n\t/*\n\t * Reschedule delayed caps release if we delayed anything,\n\t * otherwise cancel.\n\t */\n\tif (delayed && is_delayed)\n\t\tforce_requeue = 1;   /* __send_cap delayed release; requeue */\n\tif (!delayed && !is_delayed)\n\t\t__cap_delay_cancel(mdsc, ci);\n\telse if (!is_delayed || force_requeue)\n\t\t__cap_delay_requeue(mdsc, ci);\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (queue_invalidate)\n\t\tceph_queue_invalidate(inode);\n\n\tif (session)\n\t\tmutex_unlock(&session->s_mutex);\n\tif (took_snap_rwsem)\n\t\tup_read(&mdsc->snap_rwsem);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_check_caps(struct ceph_inode_info *ci, int flags,\n\t\t     struct ceph_mds_session *session)\n{\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(&ci->vfs_inode);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct inode *inode = &ci->vfs_inode;\n\tstruct ceph_cap *cap;\n\tint file_wanted, used, cap_used;\n\tint took_snap_rwsem = 0;             /* true if mdsc->snap_rwsem held */\n\tint issued, implemented, want, retain, revoking, flushing = 0;\n\tint mds = -1;   /* keep track of how far we've gone through i_caps list\n\t\t\t   to avoid an infinite loop on retry */\n\tstruct rb_node *p;\n\tint tried_invalidate = 0;\n\tint delayed = 0, sent = 0, force_requeue = 0, num;\n\tint queue_invalidate = 0;\n\tint is_delayed = flags & CHECK_CAPS_NODELAY;\n\n\t/* if we are unmounting, flush any unused caps immediately. */\n\tif (mdsc->stopping)\n\t\tis_delayed = 1;\n\n\tspin_lock(&ci->i_ceph_lock);\n\n\tif (ci->i_ceph_flags & CEPH_I_FLUSH)\n\t\tflags |= CHECK_CAPS_FLUSH;\n\n\t/* flush snaps first time around only */\n\tif (!list_empty(&ci->i_cap_snaps))\n\t\t__ceph_flush_snaps(ci, &session, 0);\n\tgoto retry_locked;\nretry:\n\tspin_lock(&ci->i_ceph_lock);\nretry_locked:\n\tfile_wanted = __ceph_caps_file_wanted(ci);\n\tused = __ceph_caps_used(ci);\n\twant = file_wanted | used;\n\tissued = __ceph_caps_issued(ci, &implemented);\n\trevoking = implemented & ~issued;\n\n\tretain = want | CEPH_CAP_PIN;\n\tif (!mdsc->stopping && inode->i_nlink > 0) {\n\t\tif (want) {\n\t\t\tretain |= CEPH_CAP_ANY;       /* be greedy */\n\t\t} else {\n\t\t\tretain |= CEPH_CAP_ANY_SHARED;\n\t\t\t/*\n\t\t\t * keep RD only if we didn't have the file open RW,\n\t\t\t * because then the mds would revoke it anyway to\n\t\t\t * journal max_size=0.\n\t\t\t */\n\t\t\tif (ci->i_max_size == 0)\n\t\t\t\tretain |= CEPH_CAP_ANY_RD;\n\t\t}\n\t}\n\n\tdout(\"check_caps %p file_want %s used %s dirty %s flushing %s\"\n\t     \" issued %s revoking %s retain %s %s%s%s\\n\", inode,\n\t     ceph_cap_string(file_wanted),\n\t     ceph_cap_string(used), ceph_cap_string(ci->i_dirty_caps),\n\t     ceph_cap_string(ci->i_flushing_caps),\n\t     ceph_cap_string(issued), ceph_cap_string(revoking),\n\t     ceph_cap_string(retain),\n\t     (flags & CHECK_CAPS_AUTHONLY) ? \" AUTHONLY\" : \"\",\n\t     (flags & CHECK_CAPS_NODELAY) ? \" NODELAY\" : \"\",\n\t     (flags & CHECK_CAPS_FLUSH) ? \" FLUSH\" : \"\");\n\n\t/*\n\t * If we no longer need to hold onto old our caps, and we may\n\t * have cached pages, but don't want them, then try to invalidate.\n\t * If we fail, it's because pages are locked.... try again later.\n\t */\n\tif ((!is_delayed || mdsc->stopping) &&\n\t    ci->i_wrbuffer_ref == 0 &&               /* no dirty pages... */\n\t    inode->i_data.nrpages &&                 /* have cached pages */\n\t    (file_wanted == 0 ||                     /* no open files */\n\t     (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t  CEPH_CAP_FILE_LAZYIO))) && /*  or revoking cache */\n\t    !tried_invalidate) {\n\t\tdout(\"check_caps trying to invalidate on %p\\n\", inode);\n\t\tif (try_nonblocking_invalidate(inode) < 0) {\n\t\t\tif (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t\t\tCEPH_CAP_FILE_LAZYIO)) {\n\t\t\t\tdout(\"check_caps queuing invalidate\\n\");\n\t\t\t\tqueue_invalidate = 1;\n\t\t\t\tci->i_rdcache_revoking = ci->i_rdcache_gen;\n\t\t\t} else {\n\t\t\t\tdout(\"check_caps failed to invalidate pages\\n\");\n\t\t\t\t/* we failed to invalidate pages.  check these\n\t\t\t\t   caps again later. */\n\t\t\t\tforce_requeue = 1;\n\t\t\t\t__cap_set_timeouts(mdsc, ci);\n\t\t\t}\n\t\t}\n\t\ttried_invalidate = 1;\n\t\tgoto retry_locked;\n\t}\n\n\tnum = 0;\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tnum++;\n\n\t\t/* avoid looping forever */\n\t\tif (mds >= cap->mds ||\n\t\t    ((flags & CHECK_CAPS_AUTHONLY) && cap != ci->i_auth_cap))\n\t\t\tcontinue;\n\n\t\t/* NOTE: no side-effects allowed, until we take s_mutex */\n\n\t\tcap_used = used;\n\t\tif (ci->i_auth_cap && cap != ci->i_auth_cap)\n\t\t\tcap_used &= ~ci->i_auth_cap->issued;\n\n\t\trevoking = cap->implemented & ~cap->issued;\n\t\tdout(\" mds%d cap %p used %s issued %s implemented %s revoking %s\\n\",\n\t\t     cap->mds, cap, ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(cap_used),\n\t\t     ceph_cap_string(cap->implemented),\n\t\t     ceph_cap_string(revoking));\n\n\t\tif (cap == ci->i_auth_cap &&\n\t\t    (cap->issued & CEPH_CAP_FILE_WR)) {\n\t\t\t/* request larger max_size from MDS? */\n\t\t\tif (ci->i_wanted_max_size > ci->i_max_size &&\n\t\t\t    ci->i_wanted_max_size > ci->i_requested_max_size) {\n\t\t\t\tdout(\"requesting new max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\n\t\t\t/* approaching file_max? */\n\t\t\tif ((inode->i_size << 1) >= ci->i_max_size &&\n\t\t\t    (ci->i_reported_size << 1) < ci->i_max_size) {\n\t\t\t\tdout(\"i_size approaching max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\t\t}\n\t\t/* flush anything dirty? */\n\t\tif (cap == ci->i_auth_cap && (flags & CHECK_CAPS_FLUSH) &&\n\t\t    ci->i_dirty_caps) {\n\t\t\tdout(\"flushing dirty caps\\n\");\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* completed revocation? going down and there are no caps? */\n\t\tif (revoking && (revoking & cap_used) == 0) {\n\t\t\tdout(\"completed revocation of %s\\n\",\n\t\t\t     ceph_cap_string(cap->implemented & ~cap->issued));\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* want more caps from mds? */\n\t\tif (want & ~(cap->mds_wanted | cap->issued))\n\t\t\tgoto ack;\n\n\t\t/* things we might delay */\n\t\tif ((cap->issued & ~retain) == 0 &&\n\t\t    cap->mds_wanted == want)\n\t\t\tcontinue;     /* nope, all good */\n\n\t\tif (is_delayed)\n\t\t\tgoto ack;\n\n\t\t/* delay? */\n\t\tif ((ci->i_ceph_flags & CEPH_I_NODELAY) == 0 &&\n\t\t    time_before(jiffies, ci->i_hold_caps_max)) {\n\t\t\tdout(\" delaying issued %s -> %s, wanted %s -> %s\\n\",\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(cap->issued & retain),\n\t\t\t     ceph_cap_string(cap->mds_wanted),\n\t\t\t     ceph_cap_string(want));\n\t\t\tdelayed++;\n\t\t\tcontinue;\n\t\t}\n\nack:\n\t\tif (ci->i_ceph_flags & CEPH_I_NOFLUSH) {\n\t\t\tdout(\" skipping %p I_NOFLUSH set\\n\", inode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (session && session != cap->session) {\n\t\t\tdout(\"oops, wrong session %p mutex\\n\", session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tsession = NULL;\n\t\t}\n\t\tif (!session) {\n\t\t\tsession = cap->session;\n\t\t\tif (mutex_trylock(&session->s_mutex) == 0) {\n\t\t\t\tdout(\"inverting session/ino locks on %p\\n\",\n\t\t\t\t     session);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tif (took_snap_rwsem) {\n\t\t\t\t\tup_read(&mdsc->snap_rwsem);\n\t\t\t\t\ttook_snap_rwsem = 0;\n\t\t\t\t}\n\t\t\t\tmutex_lock(&session->s_mutex);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t\t/* take snap_rwsem after session mutex */\n\t\tif (!took_snap_rwsem) {\n\t\t\tif (down_read_trylock(&mdsc->snap_rwsem) == 0) {\n\t\t\t\tdout(\"inverting snap/in locks on %p\\n\",\n\t\t\t\t     inode);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tdown_read(&mdsc->snap_rwsem);\n\t\t\t\ttook_snap_rwsem = 1;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\ttook_snap_rwsem = 1;\n\t\t}\n\n\t\tif (cap == ci->i_auth_cap && ci->i_dirty_caps)\n\t\t\tflushing = __mark_caps_flushing(inode, session);\n\t\telse\n\t\t\tflushing = 0;\n\n\t\tmds = cap->mds;  /* remember mds, so we don't repeat */\n\t\tsent++;\n\n\t\t/* __send_cap drops i_ceph_lock */\n\t\tdelayed += __send_cap(mdsc, cap, CEPH_CAP_OP_UPDATE, cap_used,\n\t\t\t\t      want, retain, flushing, NULL);\n\t\tgoto retry; /* retake i_ceph_lock and restart our cap scan. */\n\t}\n\n\t/*\n\t * Reschedule delayed caps release if we delayed anything,\n\t * otherwise cancel.\n\t */\n\tif (delayed && is_delayed)\n\t\tforce_requeue = 1;   /* __send_cap delayed release; requeue */\n\tif (!delayed && !is_delayed)\n\t\t__cap_delay_cancel(mdsc, ci);\n\telse if (!is_delayed || force_requeue)\n\t\t__cap_delay_requeue(mdsc, ci);\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (queue_invalidate)\n\t\tceph_queue_invalidate(inode);\n\n\tif (session)\n\t\tmutex_unlock(&session->s_mutex);\n\tif (took_snap_rwsem)\n\t\tup_read(&mdsc->snap_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 2394
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_put_cap_snap",
          "args": [
            "capsnap"
          ],
          "line": 2390
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_put_cap_snap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "167-174",
          "snippet": "static inline void ceph_put_cap_snap(struct ceph_cap_snap *capsnap)\n{\n\tif (atomic_dec_and_test(&capsnap->nref)) {\n\t\tif (capsnap->xattr_blob)\n\t\t\tceph_buffer_put(capsnap->xattr_blob);\n\t\tkfree(capsnap);\n\t}\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline void ceph_put_cap_snap(struct ceph_cap_snap *capsnap)\n{\n\tif (atomic_dec_and_test(&capsnap->nref)) {\n\t\tif (capsnap->xattr_blob)\n\t\t\tceph_buffer_put(capsnap->xattr_blob);\n\t\tkfree(capsnap);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&capsnap->flushing_item"
          ],
          "line": 2389
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_put_snap_context",
          "args": [
            "capsnap->context"
          ],
          "line": 2387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"put_wrbuffer_cap_refs on %p cap_snap %p \"\n\t\t     \" snap %lld %d/%d -> %d/%d %s%s%s\\n\"",
            "inode",
            "capsnap",
            "capsnap->context->seq",
            "ci->i_wrbuffer_ref+nr",
            "capsnap->dirty_pages + nr",
            "ci->i_wrbuffer_ref",
            "capsnap->dirty_pages",
            "last ? \" (wrbuffer last)\" : \"\"",
            "complete_capsnap ? \" (complete capsnap)\" : \"\"",
            "drop_capsnap ? \" (drop capsnap)\" : \"\""
          ],
          "line": 2378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!found"
          ],
          "line": 2369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "capsnap",
            "&ci->i_cap_snaps",
            "ci_item"
          ],
          "line": 2363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"put_wrbuffer_cap_refs on %p head %d/%d -> %d/%d %s\\n\"",
            "inode",
            "ci->i_wrbuffer_ref+nr",
            "ci->i_wrbuffer_ref_head+nr",
            "ci->i_wrbuffer_ref",
            "ci->i_wrbuffer_ref_head",
            "last ? \" LAST\" : \"\""
          ],
          "line": 2357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_put_snap_context",
          "args": [
            "ci->i_head_snapc"
          ],
          "line": 2354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ci->i_head_snapc"
          ],
          "line": 2353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 2345
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_put_wrbuffer_cap_refs(struct ceph_inode_info *ci, int nr,\n\t\t\t\tstruct ceph_snap_context *snapc)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint last = 0;\n\tint complete_capsnap = 0;\n\tint drop_capsnap = 0;\n\tint found = 0;\n\tstruct ceph_cap_snap *capsnap = NULL;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tci->i_wrbuffer_ref -= nr;\n\tlast = !ci->i_wrbuffer_ref;\n\n\tif (ci->i_head_snapc == snapc) {\n\t\tci->i_wrbuffer_ref_head -= nr;\n\t\tif (ci->i_wrbuffer_ref_head == 0 &&\n\t\t    ci->i_dirty_caps == 0 && ci->i_flushing_caps == 0) {\n\t\t\tBUG_ON(!ci->i_head_snapc);\n\t\t\tceph_put_snap_context(ci->i_head_snapc);\n\t\t\tci->i_head_snapc = NULL;\n\t\t}\n\t\tdout(\"put_wrbuffer_cap_refs on %p head %d/%d -> %d/%d %s\\n\",\n\t\t     inode,\n\t\t     ci->i_wrbuffer_ref+nr, ci->i_wrbuffer_ref_head+nr,\n\t\t     ci->i_wrbuffer_ref, ci->i_wrbuffer_ref_head,\n\t\t     last ? \" LAST\" : \"\");\n\t} else {\n\t\tlist_for_each_entry(capsnap, &ci->i_cap_snaps, ci_item) {\n\t\t\tif (capsnap->context == snapc) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tBUG_ON(!found);\n\t\tcapsnap->dirty_pages -= nr;\n\t\tif (capsnap->dirty_pages == 0) {\n\t\t\tcomplete_capsnap = 1;\n\t\t\tif (capsnap->dirty == 0)\n\t\t\t\t/* cap writeback completed before we created\n\t\t\t\t * the cap_snap; no FLUSHSNAP is needed */\n\t\t\t\tdrop_capsnap = 1;\n\t\t}\n\t\tdout(\"put_wrbuffer_cap_refs on %p cap_snap %p \"\n\t\t     \" snap %lld %d/%d -> %d/%d %s%s%s\\n\",\n\t\t     inode, capsnap, capsnap->context->seq,\n\t\t     ci->i_wrbuffer_ref+nr, capsnap->dirty_pages + nr,\n\t\t     ci->i_wrbuffer_ref, capsnap->dirty_pages,\n\t\t     last ? \" (wrbuffer last)\" : \"\",\n\t\t     complete_capsnap ? \" (complete capsnap)\" : \"\",\n\t\t     drop_capsnap ? \" (drop capsnap)\" : \"\");\n\t\tif (drop_capsnap) {\n\t\t\tceph_put_snap_context(capsnap->context);\n\t\t\tlist_del(&capsnap->ci_item);\n\t\t\tlist_del(&capsnap->flushing_item);\n\t\t\tceph_put_cap_snap(capsnap);\n\t\t}\n\t}\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (last) {\n\t\tceph_check_caps(ci, CHECK_CAPS_AUTHONLY, NULL);\n\t\tiput(inode);\n\t} else if (complete_capsnap) {\n\t\tceph_flush_snaps(ci);\n\t\twake_up_all(&ci->i_cap_wq);\n\t}\n\tif (drop_capsnap)\n\t\tiput(inode);\n}"
  },
  {
    "function_name": "ceph_put_cap_refs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "2274-2326",
    "snippet": "void ceph_put_cap_refs(struct ceph_inode_info *ci, int had)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint last = 0, put = 0, flushsnaps = 0, wake = 0;\n\tstruct ceph_cap_snap *capsnap;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (had & CEPH_CAP_PIN)\n\t\t--ci->i_pin_ref;\n\tif (had & CEPH_CAP_FILE_RD)\n\t\tif (--ci->i_rd_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_CACHE)\n\t\tif (--ci->i_rdcache_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_BUFFER) {\n\t\tif (--ci->i_wb_ref == 0) {\n\t\t\tlast++;\n\t\t\tput++;\n\t\t}\n\t\tdout(\"put_cap_refs %p wb %d -> %d (?)\\n\",\n\t\t     inode, ci->i_wb_ref+1, ci->i_wb_ref);\n\t}\n\tif (had & CEPH_CAP_FILE_WR)\n\t\tif (--ci->i_wr_ref == 0) {\n\t\t\tlast++;\n\t\t\tif (!list_empty(&ci->i_cap_snaps)) {\n\t\t\t\tcapsnap = list_first_entry(&ci->i_cap_snaps,\n\t\t\t\t\t\t     struct ceph_cap_snap,\n\t\t\t\t\t\t     ci_item);\n\t\t\t\tif (capsnap->writing) {\n\t\t\t\t\tcapsnap->writing = 0;\n\t\t\t\t\tflushsnaps =\n\t\t\t\t\t\t__ceph_finish_cap_snap(ci,\n\t\t\t\t\t\t\t\t       capsnap);\n\t\t\t\t\twake = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tdout(\"put_cap_refs %p had %s%s%s\\n\", inode, ceph_cap_string(had),\n\t     last ? \" last\" : \"\", put ? \" put\" : \"\");\n\n\tif (last && !flushsnaps)\n\t\tceph_check_caps(ci, 0, NULL);\n\telse if (flushsnaps)\n\t\tceph_flush_snaps(ci);\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\tif (put)\n\t\tiput(inode);\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 2325
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&ci->i_cap_wq"
          ],
          "line": 2323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_flush_snaps",
          "args": [
            "ci"
          ],
          "line": 2321
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_flush_snaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "1377-1382",
          "snippet": "static void ceph_flush_snaps(struct ceph_inode_info *ci)\n{\n\tspin_lock(&ci->i_ceph_lock);\n\t__ceph_flush_snaps(ci, NULL, 0);\n\tspin_unlock(&ci->i_ceph_lock);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void ceph_flush_snaps(struct ceph_inode_info *ci)\n{\n\tspin_lock(&ci->i_ceph_lock);\n\t__ceph_flush_snaps(ci, NULL, 0);\n\tspin_unlock(&ci->i_ceph_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_check_caps",
          "args": [
            "ci",
            "0",
            "NULL"
          ],
          "line": 2319
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_check_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "1504-1751",
          "snippet": "void ceph_check_caps(struct ceph_inode_info *ci, int flags,\n\t\t     struct ceph_mds_session *session)\n{\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(&ci->vfs_inode);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct inode *inode = &ci->vfs_inode;\n\tstruct ceph_cap *cap;\n\tint file_wanted, used, cap_used;\n\tint took_snap_rwsem = 0;             /* true if mdsc->snap_rwsem held */\n\tint issued, implemented, want, retain, revoking, flushing = 0;\n\tint mds = -1;   /* keep track of how far we've gone through i_caps list\n\t\t\t   to avoid an infinite loop on retry */\n\tstruct rb_node *p;\n\tint tried_invalidate = 0;\n\tint delayed = 0, sent = 0, force_requeue = 0, num;\n\tint queue_invalidate = 0;\n\tint is_delayed = flags & CHECK_CAPS_NODELAY;\n\n\t/* if we are unmounting, flush any unused caps immediately. */\n\tif (mdsc->stopping)\n\t\tis_delayed = 1;\n\n\tspin_lock(&ci->i_ceph_lock);\n\n\tif (ci->i_ceph_flags & CEPH_I_FLUSH)\n\t\tflags |= CHECK_CAPS_FLUSH;\n\n\t/* flush snaps first time around only */\n\tif (!list_empty(&ci->i_cap_snaps))\n\t\t__ceph_flush_snaps(ci, &session, 0);\n\tgoto retry_locked;\nretry:\n\tspin_lock(&ci->i_ceph_lock);\nretry_locked:\n\tfile_wanted = __ceph_caps_file_wanted(ci);\n\tused = __ceph_caps_used(ci);\n\twant = file_wanted | used;\n\tissued = __ceph_caps_issued(ci, &implemented);\n\trevoking = implemented & ~issued;\n\n\tretain = want | CEPH_CAP_PIN;\n\tif (!mdsc->stopping && inode->i_nlink > 0) {\n\t\tif (want) {\n\t\t\tretain |= CEPH_CAP_ANY;       /* be greedy */\n\t\t} else {\n\t\t\tretain |= CEPH_CAP_ANY_SHARED;\n\t\t\t/*\n\t\t\t * keep RD only if we didn't have the file open RW,\n\t\t\t * because then the mds would revoke it anyway to\n\t\t\t * journal max_size=0.\n\t\t\t */\n\t\t\tif (ci->i_max_size == 0)\n\t\t\t\tretain |= CEPH_CAP_ANY_RD;\n\t\t}\n\t}\n\n\tdout(\"check_caps %p file_want %s used %s dirty %s flushing %s\"\n\t     \" issued %s revoking %s retain %s %s%s%s\\n\", inode,\n\t     ceph_cap_string(file_wanted),\n\t     ceph_cap_string(used), ceph_cap_string(ci->i_dirty_caps),\n\t     ceph_cap_string(ci->i_flushing_caps),\n\t     ceph_cap_string(issued), ceph_cap_string(revoking),\n\t     ceph_cap_string(retain),\n\t     (flags & CHECK_CAPS_AUTHONLY) ? \" AUTHONLY\" : \"\",\n\t     (flags & CHECK_CAPS_NODELAY) ? \" NODELAY\" : \"\",\n\t     (flags & CHECK_CAPS_FLUSH) ? \" FLUSH\" : \"\");\n\n\t/*\n\t * If we no longer need to hold onto old our caps, and we may\n\t * have cached pages, but don't want them, then try to invalidate.\n\t * If we fail, it's because pages are locked.... try again later.\n\t */\n\tif ((!is_delayed || mdsc->stopping) &&\n\t    ci->i_wrbuffer_ref == 0 &&               /* no dirty pages... */\n\t    inode->i_data.nrpages &&                 /* have cached pages */\n\t    (file_wanted == 0 ||                     /* no open files */\n\t     (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t  CEPH_CAP_FILE_LAZYIO))) && /*  or revoking cache */\n\t    !tried_invalidate) {\n\t\tdout(\"check_caps trying to invalidate on %p\\n\", inode);\n\t\tif (try_nonblocking_invalidate(inode) < 0) {\n\t\t\tif (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t\t\tCEPH_CAP_FILE_LAZYIO)) {\n\t\t\t\tdout(\"check_caps queuing invalidate\\n\");\n\t\t\t\tqueue_invalidate = 1;\n\t\t\t\tci->i_rdcache_revoking = ci->i_rdcache_gen;\n\t\t\t} else {\n\t\t\t\tdout(\"check_caps failed to invalidate pages\\n\");\n\t\t\t\t/* we failed to invalidate pages.  check these\n\t\t\t\t   caps again later. */\n\t\t\t\tforce_requeue = 1;\n\t\t\t\t__cap_set_timeouts(mdsc, ci);\n\t\t\t}\n\t\t}\n\t\ttried_invalidate = 1;\n\t\tgoto retry_locked;\n\t}\n\n\tnum = 0;\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tnum++;\n\n\t\t/* avoid looping forever */\n\t\tif (mds >= cap->mds ||\n\t\t    ((flags & CHECK_CAPS_AUTHONLY) && cap != ci->i_auth_cap))\n\t\t\tcontinue;\n\n\t\t/* NOTE: no side-effects allowed, until we take s_mutex */\n\n\t\tcap_used = used;\n\t\tif (ci->i_auth_cap && cap != ci->i_auth_cap)\n\t\t\tcap_used &= ~ci->i_auth_cap->issued;\n\n\t\trevoking = cap->implemented & ~cap->issued;\n\t\tdout(\" mds%d cap %p used %s issued %s implemented %s revoking %s\\n\",\n\t\t     cap->mds, cap, ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(cap_used),\n\t\t     ceph_cap_string(cap->implemented),\n\t\t     ceph_cap_string(revoking));\n\n\t\tif (cap == ci->i_auth_cap &&\n\t\t    (cap->issued & CEPH_CAP_FILE_WR)) {\n\t\t\t/* request larger max_size from MDS? */\n\t\t\tif (ci->i_wanted_max_size > ci->i_max_size &&\n\t\t\t    ci->i_wanted_max_size > ci->i_requested_max_size) {\n\t\t\t\tdout(\"requesting new max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\n\t\t\t/* approaching file_max? */\n\t\t\tif ((inode->i_size << 1) >= ci->i_max_size &&\n\t\t\t    (ci->i_reported_size << 1) < ci->i_max_size) {\n\t\t\t\tdout(\"i_size approaching max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\t\t}\n\t\t/* flush anything dirty? */\n\t\tif (cap == ci->i_auth_cap && (flags & CHECK_CAPS_FLUSH) &&\n\t\t    ci->i_dirty_caps) {\n\t\t\tdout(\"flushing dirty caps\\n\");\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* completed revocation? going down and there are no caps? */\n\t\tif (revoking && (revoking & cap_used) == 0) {\n\t\t\tdout(\"completed revocation of %s\\n\",\n\t\t\t     ceph_cap_string(cap->implemented & ~cap->issued));\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* want more caps from mds? */\n\t\tif (want & ~(cap->mds_wanted | cap->issued))\n\t\t\tgoto ack;\n\n\t\t/* things we might delay */\n\t\tif ((cap->issued & ~retain) == 0 &&\n\t\t    cap->mds_wanted == want)\n\t\t\tcontinue;     /* nope, all good */\n\n\t\tif (is_delayed)\n\t\t\tgoto ack;\n\n\t\t/* delay? */\n\t\tif ((ci->i_ceph_flags & CEPH_I_NODELAY) == 0 &&\n\t\t    time_before(jiffies, ci->i_hold_caps_max)) {\n\t\t\tdout(\" delaying issued %s -> %s, wanted %s -> %s\\n\",\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(cap->issued & retain),\n\t\t\t     ceph_cap_string(cap->mds_wanted),\n\t\t\t     ceph_cap_string(want));\n\t\t\tdelayed++;\n\t\t\tcontinue;\n\t\t}\n\nack:\n\t\tif (ci->i_ceph_flags & CEPH_I_NOFLUSH) {\n\t\t\tdout(\" skipping %p I_NOFLUSH set\\n\", inode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (session && session != cap->session) {\n\t\t\tdout(\"oops, wrong session %p mutex\\n\", session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tsession = NULL;\n\t\t}\n\t\tif (!session) {\n\t\t\tsession = cap->session;\n\t\t\tif (mutex_trylock(&session->s_mutex) == 0) {\n\t\t\t\tdout(\"inverting session/ino locks on %p\\n\",\n\t\t\t\t     session);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tif (took_snap_rwsem) {\n\t\t\t\t\tup_read(&mdsc->snap_rwsem);\n\t\t\t\t\ttook_snap_rwsem = 0;\n\t\t\t\t}\n\t\t\t\tmutex_lock(&session->s_mutex);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t\t/* take snap_rwsem after session mutex */\n\t\tif (!took_snap_rwsem) {\n\t\t\tif (down_read_trylock(&mdsc->snap_rwsem) == 0) {\n\t\t\t\tdout(\"inverting snap/in locks on %p\\n\",\n\t\t\t\t     inode);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tdown_read(&mdsc->snap_rwsem);\n\t\t\t\ttook_snap_rwsem = 1;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\ttook_snap_rwsem = 1;\n\t\t}\n\n\t\tif (cap == ci->i_auth_cap && ci->i_dirty_caps)\n\t\t\tflushing = __mark_caps_flushing(inode, session);\n\t\telse\n\t\t\tflushing = 0;\n\n\t\tmds = cap->mds;  /* remember mds, so we don't repeat */\n\t\tsent++;\n\n\t\t/* __send_cap drops i_ceph_lock */\n\t\tdelayed += __send_cap(mdsc, cap, CEPH_CAP_OP_UPDATE, cap_used,\n\t\t\t\t      want, retain, flushing, NULL);\n\t\tgoto retry; /* retake i_ceph_lock and restart our cap scan. */\n\t}\n\n\t/*\n\t * Reschedule delayed caps release if we delayed anything,\n\t * otherwise cancel.\n\t */\n\tif (delayed && is_delayed)\n\t\tforce_requeue = 1;   /* __send_cap delayed release; requeue */\n\tif (!delayed && !is_delayed)\n\t\t__cap_delay_cancel(mdsc, ci);\n\telse if (!is_delayed || force_requeue)\n\t\t__cap_delay_requeue(mdsc, ci);\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (queue_invalidate)\n\t\tceph_queue_invalidate(inode);\n\n\tif (session)\n\t\tmutex_unlock(&session->s_mutex);\n\tif (took_snap_rwsem)\n\t\tup_read(&mdsc->snap_rwsem);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_check_caps(struct ceph_inode_info *ci, int flags,\n\t\t     struct ceph_mds_session *session)\n{\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(&ci->vfs_inode);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct inode *inode = &ci->vfs_inode;\n\tstruct ceph_cap *cap;\n\tint file_wanted, used, cap_used;\n\tint took_snap_rwsem = 0;             /* true if mdsc->snap_rwsem held */\n\tint issued, implemented, want, retain, revoking, flushing = 0;\n\tint mds = -1;   /* keep track of how far we've gone through i_caps list\n\t\t\t   to avoid an infinite loop on retry */\n\tstruct rb_node *p;\n\tint tried_invalidate = 0;\n\tint delayed = 0, sent = 0, force_requeue = 0, num;\n\tint queue_invalidate = 0;\n\tint is_delayed = flags & CHECK_CAPS_NODELAY;\n\n\t/* if we are unmounting, flush any unused caps immediately. */\n\tif (mdsc->stopping)\n\t\tis_delayed = 1;\n\n\tspin_lock(&ci->i_ceph_lock);\n\n\tif (ci->i_ceph_flags & CEPH_I_FLUSH)\n\t\tflags |= CHECK_CAPS_FLUSH;\n\n\t/* flush snaps first time around only */\n\tif (!list_empty(&ci->i_cap_snaps))\n\t\t__ceph_flush_snaps(ci, &session, 0);\n\tgoto retry_locked;\nretry:\n\tspin_lock(&ci->i_ceph_lock);\nretry_locked:\n\tfile_wanted = __ceph_caps_file_wanted(ci);\n\tused = __ceph_caps_used(ci);\n\twant = file_wanted | used;\n\tissued = __ceph_caps_issued(ci, &implemented);\n\trevoking = implemented & ~issued;\n\n\tretain = want | CEPH_CAP_PIN;\n\tif (!mdsc->stopping && inode->i_nlink > 0) {\n\t\tif (want) {\n\t\t\tretain |= CEPH_CAP_ANY;       /* be greedy */\n\t\t} else {\n\t\t\tretain |= CEPH_CAP_ANY_SHARED;\n\t\t\t/*\n\t\t\t * keep RD only if we didn't have the file open RW,\n\t\t\t * because then the mds would revoke it anyway to\n\t\t\t * journal max_size=0.\n\t\t\t */\n\t\t\tif (ci->i_max_size == 0)\n\t\t\t\tretain |= CEPH_CAP_ANY_RD;\n\t\t}\n\t}\n\n\tdout(\"check_caps %p file_want %s used %s dirty %s flushing %s\"\n\t     \" issued %s revoking %s retain %s %s%s%s\\n\", inode,\n\t     ceph_cap_string(file_wanted),\n\t     ceph_cap_string(used), ceph_cap_string(ci->i_dirty_caps),\n\t     ceph_cap_string(ci->i_flushing_caps),\n\t     ceph_cap_string(issued), ceph_cap_string(revoking),\n\t     ceph_cap_string(retain),\n\t     (flags & CHECK_CAPS_AUTHONLY) ? \" AUTHONLY\" : \"\",\n\t     (flags & CHECK_CAPS_NODELAY) ? \" NODELAY\" : \"\",\n\t     (flags & CHECK_CAPS_FLUSH) ? \" FLUSH\" : \"\");\n\n\t/*\n\t * If we no longer need to hold onto old our caps, and we may\n\t * have cached pages, but don't want them, then try to invalidate.\n\t * If we fail, it's because pages are locked.... try again later.\n\t */\n\tif ((!is_delayed || mdsc->stopping) &&\n\t    ci->i_wrbuffer_ref == 0 &&               /* no dirty pages... */\n\t    inode->i_data.nrpages &&                 /* have cached pages */\n\t    (file_wanted == 0 ||                     /* no open files */\n\t     (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t  CEPH_CAP_FILE_LAZYIO))) && /*  or revoking cache */\n\t    !tried_invalidate) {\n\t\tdout(\"check_caps trying to invalidate on %p\\n\", inode);\n\t\tif (try_nonblocking_invalidate(inode) < 0) {\n\t\t\tif (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t\t\tCEPH_CAP_FILE_LAZYIO)) {\n\t\t\t\tdout(\"check_caps queuing invalidate\\n\");\n\t\t\t\tqueue_invalidate = 1;\n\t\t\t\tci->i_rdcache_revoking = ci->i_rdcache_gen;\n\t\t\t} else {\n\t\t\t\tdout(\"check_caps failed to invalidate pages\\n\");\n\t\t\t\t/* we failed to invalidate pages.  check these\n\t\t\t\t   caps again later. */\n\t\t\t\tforce_requeue = 1;\n\t\t\t\t__cap_set_timeouts(mdsc, ci);\n\t\t\t}\n\t\t}\n\t\ttried_invalidate = 1;\n\t\tgoto retry_locked;\n\t}\n\n\tnum = 0;\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tnum++;\n\n\t\t/* avoid looping forever */\n\t\tif (mds >= cap->mds ||\n\t\t    ((flags & CHECK_CAPS_AUTHONLY) && cap != ci->i_auth_cap))\n\t\t\tcontinue;\n\n\t\t/* NOTE: no side-effects allowed, until we take s_mutex */\n\n\t\tcap_used = used;\n\t\tif (ci->i_auth_cap && cap != ci->i_auth_cap)\n\t\t\tcap_used &= ~ci->i_auth_cap->issued;\n\n\t\trevoking = cap->implemented & ~cap->issued;\n\t\tdout(\" mds%d cap %p used %s issued %s implemented %s revoking %s\\n\",\n\t\t     cap->mds, cap, ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(cap_used),\n\t\t     ceph_cap_string(cap->implemented),\n\t\t     ceph_cap_string(revoking));\n\n\t\tif (cap == ci->i_auth_cap &&\n\t\t    (cap->issued & CEPH_CAP_FILE_WR)) {\n\t\t\t/* request larger max_size from MDS? */\n\t\t\tif (ci->i_wanted_max_size > ci->i_max_size &&\n\t\t\t    ci->i_wanted_max_size > ci->i_requested_max_size) {\n\t\t\t\tdout(\"requesting new max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\n\t\t\t/* approaching file_max? */\n\t\t\tif ((inode->i_size << 1) >= ci->i_max_size &&\n\t\t\t    (ci->i_reported_size << 1) < ci->i_max_size) {\n\t\t\t\tdout(\"i_size approaching max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\t\t}\n\t\t/* flush anything dirty? */\n\t\tif (cap == ci->i_auth_cap && (flags & CHECK_CAPS_FLUSH) &&\n\t\t    ci->i_dirty_caps) {\n\t\t\tdout(\"flushing dirty caps\\n\");\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* completed revocation? going down and there are no caps? */\n\t\tif (revoking && (revoking & cap_used) == 0) {\n\t\t\tdout(\"completed revocation of %s\\n\",\n\t\t\t     ceph_cap_string(cap->implemented & ~cap->issued));\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* want more caps from mds? */\n\t\tif (want & ~(cap->mds_wanted | cap->issued))\n\t\t\tgoto ack;\n\n\t\t/* things we might delay */\n\t\tif ((cap->issued & ~retain) == 0 &&\n\t\t    cap->mds_wanted == want)\n\t\t\tcontinue;     /* nope, all good */\n\n\t\tif (is_delayed)\n\t\t\tgoto ack;\n\n\t\t/* delay? */\n\t\tif ((ci->i_ceph_flags & CEPH_I_NODELAY) == 0 &&\n\t\t    time_before(jiffies, ci->i_hold_caps_max)) {\n\t\t\tdout(\" delaying issued %s -> %s, wanted %s -> %s\\n\",\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(cap->issued & retain),\n\t\t\t     ceph_cap_string(cap->mds_wanted),\n\t\t\t     ceph_cap_string(want));\n\t\t\tdelayed++;\n\t\t\tcontinue;\n\t\t}\n\nack:\n\t\tif (ci->i_ceph_flags & CEPH_I_NOFLUSH) {\n\t\t\tdout(\" skipping %p I_NOFLUSH set\\n\", inode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (session && session != cap->session) {\n\t\t\tdout(\"oops, wrong session %p mutex\\n\", session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tsession = NULL;\n\t\t}\n\t\tif (!session) {\n\t\t\tsession = cap->session;\n\t\t\tif (mutex_trylock(&session->s_mutex) == 0) {\n\t\t\t\tdout(\"inverting session/ino locks on %p\\n\",\n\t\t\t\t     session);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tif (took_snap_rwsem) {\n\t\t\t\t\tup_read(&mdsc->snap_rwsem);\n\t\t\t\t\ttook_snap_rwsem = 0;\n\t\t\t\t}\n\t\t\t\tmutex_lock(&session->s_mutex);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t\t/* take snap_rwsem after session mutex */\n\t\tif (!took_snap_rwsem) {\n\t\t\tif (down_read_trylock(&mdsc->snap_rwsem) == 0) {\n\t\t\t\tdout(\"inverting snap/in locks on %p\\n\",\n\t\t\t\t     inode);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tdown_read(&mdsc->snap_rwsem);\n\t\t\t\ttook_snap_rwsem = 1;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\ttook_snap_rwsem = 1;\n\t\t}\n\n\t\tif (cap == ci->i_auth_cap && ci->i_dirty_caps)\n\t\t\tflushing = __mark_caps_flushing(inode, session);\n\t\telse\n\t\t\tflushing = 0;\n\n\t\tmds = cap->mds;  /* remember mds, so we don't repeat */\n\t\tsent++;\n\n\t\t/* __send_cap drops i_ceph_lock */\n\t\tdelayed += __send_cap(mdsc, cap, CEPH_CAP_OP_UPDATE, cap_used,\n\t\t\t\t      want, retain, flushing, NULL);\n\t\tgoto retry; /* retake i_ceph_lock and restart our cap scan. */\n\t}\n\n\t/*\n\t * Reschedule delayed caps release if we delayed anything,\n\t * otherwise cancel.\n\t */\n\tif (delayed && is_delayed)\n\t\tforce_requeue = 1;   /* __send_cap delayed release; requeue */\n\tif (!delayed && !is_delayed)\n\t\t__cap_delay_cancel(mdsc, ci);\n\telse if (!is_delayed || force_requeue)\n\t\t__cap_delay_requeue(mdsc, ci);\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (queue_invalidate)\n\t\tceph_queue_invalidate(inode);\n\n\tif (session)\n\t\tmutex_unlock(&session->s_mutex);\n\tif (took_snap_rwsem)\n\t\tup_read(&mdsc->snap_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"put_cap_refs %p had %s%s%s\\n\"",
            "inode",
            "ceph_cap_string(had)",
            "last ? \" last\" : \"\"",
            "put ? \" put\" : \"\""
          ],
          "line": 2315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_cap_string",
          "args": [
            "had"
          ],
          "line": 2315
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_cap_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "71-116",
          "snippet": "const char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [
            "#define MAX_CAP_STR 20"
          ],
          "globals_used": [
            "static char cap_str[MAX_CAP_STR][40];",
            "static DEFINE_SPINLOCK(cap_str_lock);",
            "static int last_cap_str;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\n#define MAX_CAP_STR 20\n\nstatic char cap_str[MAX_CAP_STR][40];\nstatic DEFINE_SPINLOCK(cap_str_lock);\nstatic int last_cap_str;\n\nconst char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 2313
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_finish_cap_snap",
          "args": [
            "ci",
            "capsnap"
          ],
          "line": 2307
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_finish_cap_snap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
          "lines": "564-593",
          "snippet": "int __ceph_finish_cap_snap(struct ceph_inode_info *ci,\n\t\t\t    struct ceph_cap_snap *capsnap)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;\n\n\tBUG_ON(capsnap->writing);\n\tcapsnap->size = inode->i_size;\n\tcapsnap->mtime = inode->i_mtime;\n\tcapsnap->atime = inode->i_atime;\n\tcapsnap->ctime = inode->i_ctime;\n\tcapsnap->time_warp_seq = ci->i_time_warp_seq;\n\tif (capsnap->dirty_pages) {\n\t\tdout(\"finish_cap_snap %p cap_snap %p snapc %p %llu %s s=%llu \"\n\t\t     \"still has %d dirty pages\\n\", inode, capsnap,\n\t\t     capsnap->context, capsnap->context->seq,\n\t\t     ceph_cap_string(capsnap->dirty), capsnap->size,\n\t\t     capsnap->dirty_pages);\n\t\treturn 0;\n\t}\n\tdout(\"finish_cap_snap %p cap_snap %p snapc %p %llu %s s=%llu\\n\",\n\t     inode, capsnap, capsnap->context,\n\t     capsnap->context->seq, ceph_cap_string(capsnap->dirty),\n\t     capsnap->size);\n\n\tspin_lock(&mdsc->snap_flush_lock);\n\tlist_add_tail(&ci->i_snap_flush_item, &mdsc->snap_flush_list);\n\tspin_unlock(&mdsc->snap_flush_lock);\n\treturn 1;  /* caller may want to ceph_flush_snaps */\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_finish_cap_snap(struct ceph_inode_info *ci,\n\t\t\t    struct ceph_cap_snap *capsnap)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;\n\n\tBUG_ON(capsnap->writing);\n\tcapsnap->size = inode->i_size;\n\tcapsnap->mtime = inode->i_mtime;\n\tcapsnap->atime = inode->i_atime;\n\tcapsnap->ctime = inode->i_ctime;\n\tcapsnap->time_warp_seq = ci->i_time_warp_seq;\n\tif (capsnap->dirty_pages) {\n\t\tdout(\"finish_cap_snap %p cap_snap %p snapc %p %llu %s s=%llu \"\n\t\t     \"still has %d dirty pages\\n\", inode, capsnap,\n\t\t     capsnap->context, capsnap->context->seq,\n\t\t     ceph_cap_string(capsnap->dirty), capsnap->size,\n\t\t     capsnap->dirty_pages);\n\t\treturn 0;\n\t}\n\tdout(\"finish_cap_snap %p cap_snap %p snapc %p %llu %s s=%llu\\n\",\n\t     inode, capsnap, capsnap->context,\n\t     capsnap->context->seq, ceph_cap_string(capsnap->dirty),\n\t     capsnap->size);\n\n\tspin_lock(&mdsc->snap_flush_lock);\n\tlist_add_tail(&ci->i_snap_flush_item, &mdsc->snap_flush_list);\n\tspin_unlock(&mdsc->snap_flush_lock);\n\treturn 1;  /* caller may want to ceph_flush_snaps */\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&ci->i_cap_snaps",
            "structceph_cap_snap",
            "ci_item"
          ],
          "line": 2301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ci->i_cap_snaps"
          ],
          "line": 2300
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"put_cap_refs %p wb %d -> %d (?)\\n\"",
            "inode",
            "ci->i_wb_ref+1",
            "ci->i_wb_ref"
          ],
          "line": 2294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 2280
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_put_cap_refs(struct ceph_inode_info *ci, int had)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint last = 0, put = 0, flushsnaps = 0, wake = 0;\n\tstruct ceph_cap_snap *capsnap;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (had & CEPH_CAP_PIN)\n\t\t--ci->i_pin_ref;\n\tif (had & CEPH_CAP_FILE_RD)\n\t\tif (--ci->i_rd_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_CACHE)\n\t\tif (--ci->i_rdcache_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_BUFFER) {\n\t\tif (--ci->i_wb_ref == 0) {\n\t\t\tlast++;\n\t\t\tput++;\n\t\t}\n\t\tdout(\"put_cap_refs %p wb %d -> %d (?)\\n\",\n\t\t     inode, ci->i_wb_ref+1, ci->i_wb_ref);\n\t}\n\tif (had & CEPH_CAP_FILE_WR)\n\t\tif (--ci->i_wr_ref == 0) {\n\t\t\tlast++;\n\t\t\tif (!list_empty(&ci->i_cap_snaps)) {\n\t\t\t\tcapsnap = list_first_entry(&ci->i_cap_snaps,\n\t\t\t\t\t\t     struct ceph_cap_snap,\n\t\t\t\t\t\t     ci_item);\n\t\t\t\tif (capsnap->writing) {\n\t\t\t\t\tcapsnap->writing = 0;\n\t\t\t\t\tflushsnaps =\n\t\t\t\t\t\t__ceph_finish_cap_snap(ci,\n\t\t\t\t\t\t\t\t       capsnap);\n\t\t\t\t\twake = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tdout(\"put_cap_refs %p had %s%s%s\\n\", inode, ceph_cap_string(had),\n\t     last ? \" last\" : \"\", put ? \" put\" : \"\");\n\n\tif (last && !flushsnaps)\n\t\tceph_check_caps(ci, 0, NULL);\n\telse if (flushsnaps)\n\t\tceph_flush_snaps(ci);\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\tif (put)\n\t\tiput(inode);\n}"
  },
  {
    "function_name": "ceph_get_cap_refs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "2258-2263",
    "snippet": "void ceph_get_cap_refs(struct ceph_inode_info *ci, int caps)\n{\n\tspin_lock(&ci->i_ceph_lock);\n\t__take_cap_refs(ci, caps);\n\tspin_unlock(&ci->i_ceph_lock);\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 2262
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__take_cap_refs",
          "args": [
            "ci",
            "caps"
          ],
          "line": 2261
        },
        "resolved": true,
        "details": {
          "function_name": "__take_cap_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "2048-2065",
          "snippet": "static void __take_cap_refs(struct ceph_inode_info *ci, int got)\n{\n\tif (got & CEPH_CAP_PIN)\n\t\tci->i_pin_ref++;\n\tif (got & CEPH_CAP_FILE_RD)\n\t\tci->i_rd_ref++;\n\tif (got & CEPH_CAP_FILE_CACHE)\n\t\tci->i_rdcache_ref++;\n\tif (got & CEPH_CAP_FILE_WR)\n\t\tci->i_wr_ref++;\n\tif (got & CEPH_CAP_FILE_BUFFER) {\n\t\tif (ci->i_wb_ref == 0)\n\t\t\tihold(&ci->vfs_inode);\n\t\tci->i_wb_ref++;\n\t\tdout(\"__take_cap_refs %p wb %d -> %d (?)\\n\",\n\t\t     &ci->vfs_inode, ci->i_wb_ref-1, ci->i_wb_ref);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __take_cap_refs(struct ceph_inode_info *ci, int got)\n{\n\tif (got & CEPH_CAP_PIN)\n\t\tci->i_pin_ref++;\n\tif (got & CEPH_CAP_FILE_RD)\n\t\tci->i_rd_ref++;\n\tif (got & CEPH_CAP_FILE_CACHE)\n\t\tci->i_rdcache_ref++;\n\tif (got & CEPH_CAP_FILE_WR)\n\t\tci->i_wr_ref++;\n\tif (got & CEPH_CAP_FILE_BUFFER) {\n\t\tif (ci->i_wb_ref == 0)\n\t\t\tihold(&ci->vfs_inode);\n\t\tci->i_wb_ref++;\n\t\tdout(\"__take_cap_refs %p wb %d -> %d (?)\\n\",\n\t\t     &ci->vfs_inode, ci->i_wb_ref-1, ci->i_wb_ref);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 2260
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_get_cap_refs(struct ceph_inode_info *ci, int caps)\n{\n\tspin_lock(&ci->i_ceph_lock);\n\t__take_cap_refs(ci, caps);\n\tspin_unlock(&ci->i_ceph_lock);\n}"
  },
  {
    "function_name": "ceph_get_caps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "2203-2252",
    "snippet": "int ceph_get_caps(struct ceph_inode_info *ci, int need, int want,\n\t\t  loff_t endoff, int *got, struct page **pinned_page)\n{\n\tint _got, check_max, ret, err = 0;\n\nretry:\n\tif (endoff > 0)\n\t\tcheck_max_size(&ci->vfs_inode, endoff);\n\t_got = 0;\n\tcheck_max = 0;\n\tret = wait_event_interruptible(ci->i_cap_wq,\n\t\t\t\ttry_get_cap_refs(ci, need, want, endoff,\n\t\t\t\t\t\t &_got, &check_max, &err));\n\tif (err)\n\t\tret = err;\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (check_max)\n\t\tgoto retry;\n\n\tif (ci->i_inline_version != CEPH_INLINE_NONE &&\n\t    (_got & (CEPH_CAP_FILE_CACHE|CEPH_CAP_FILE_LAZYIO)) &&\n\t    i_size_read(&ci->vfs_inode) > 0) {\n\t\tstruct page *page = find_get_page(ci->vfs_inode.i_mapping, 0);\n\t\tif (page) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\t*pinned_page = page;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tpage_cache_release(page);\n\t\t}\n\t\t/*\n\t\t * drop cap refs first because getattr while holding\n\t\t * caps refs can cause deadlock.\n\t\t */\n\t\tceph_put_cap_refs(ci, _got);\n\t\t_got = 0;\n\n\t\t/* getattr request will bring inline data into page cache */\n\t\tret = __ceph_do_getattr(&ci->vfs_inode, NULL,\n\t\t\t\t\tCEPH_STAT_CAP_INLINE_DATA, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tgoto retry;\n\t}\nout:\n\t*got = _got;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ceph_do_getattr",
          "args": [
            "&ci->vfs_inode",
            "NULL",
            "CEPH_STAT_CAP_INLINE_DATA",
            "true"
          ],
          "line": 2243
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_do_getattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "1924-1965",
          "snippet": "int __ceph_do_getattr(struct inode *inode, struct page *locked_page,\n\t\t      int mask, bool force)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(inode->i_sb);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct ceph_mds_request *req;\n\tint err;\n\n\tif (ceph_snap(inode) == CEPH_SNAPDIR) {\n\t\tdout(\"do_getattr inode %p SNAPDIR\\n\", inode);\n\t\treturn 0;\n\t}\n\n\tdout(\"do_getattr inode %p mask %s mode 0%o\\n\",\n\t     inode, ceph_cap_string(mask), inode->i_mode);\n\tif (!force && ceph_caps_issued_mask(ceph_inode(inode), mask, 1))\n\t\treturn 0;\n\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_GETATTR, USE_ANY_MDS);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\treq->r_inode = inode;\n\tihold(inode);\n\treq->r_num_caps = 1;\n\treq->r_args.getattr.mask = cpu_to_le32(mask);\n\treq->r_locked_page = locked_page;\n\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\tif (locked_page && err == 0) {\n\t\tu64 inline_version = req->r_reply_info.targeti.inline_version;\n\t\tif (inline_version == 0) {\n\t\t\t/* the reply is supposed to contain inline data */\n\t\t\terr = -EINVAL;\n\t\t} else if (inline_version == CEPH_INLINE_NONE) {\n\t\t\terr = -ENODATA;\n\t\t} else {\n\t\t\terr = req->r_reply_info.targeti.inline_len;\n\t\t}\n\t}\n\tceph_mdsc_put_request(req);\n\tdout(\"do_getattr result=%d\\n\", err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_do_getattr(struct inode *inode, struct page *locked_page,\n\t\t      int mask, bool force)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(inode->i_sb);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct ceph_mds_request *req;\n\tint err;\n\n\tif (ceph_snap(inode) == CEPH_SNAPDIR) {\n\t\tdout(\"do_getattr inode %p SNAPDIR\\n\", inode);\n\t\treturn 0;\n\t}\n\n\tdout(\"do_getattr inode %p mask %s mode 0%o\\n\",\n\t     inode, ceph_cap_string(mask), inode->i_mode);\n\tif (!force && ceph_caps_issued_mask(ceph_inode(inode), mask, 1))\n\t\treturn 0;\n\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_GETATTR, USE_ANY_MDS);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\treq->r_inode = inode;\n\tihold(inode);\n\treq->r_num_caps = 1;\n\treq->r_args.getattr.mask = cpu_to_le32(mask);\n\treq->r_locked_page = locked_page;\n\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\tif (locked_page && err == 0) {\n\t\tu64 inline_version = req->r_reply_info.targeti.inline_version;\n\t\tif (inline_version == 0) {\n\t\t\t/* the reply is supposed to contain inline data */\n\t\t\terr = -EINVAL;\n\t\t} else if (inline_version == CEPH_INLINE_NONE) {\n\t\t\terr = -ENODATA;\n\t\t} else {\n\t\t\terr = req->r_reply_info.targeti.inline_len;\n\t\t}\n\t}\n\tceph_mdsc_put_request(req);\n\tdout(\"do_getattr result=%d\\n\", err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_put_cap_refs",
          "args": [
            "ci",
            "_got"
          ],
          "line": 2239
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_put_cap_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "2274-2326",
          "snippet": "void ceph_put_cap_refs(struct ceph_inode_info *ci, int had)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint last = 0, put = 0, flushsnaps = 0, wake = 0;\n\tstruct ceph_cap_snap *capsnap;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (had & CEPH_CAP_PIN)\n\t\t--ci->i_pin_ref;\n\tif (had & CEPH_CAP_FILE_RD)\n\t\tif (--ci->i_rd_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_CACHE)\n\t\tif (--ci->i_rdcache_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_BUFFER) {\n\t\tif (--ci->i_wb_ref == 0) {\n\t\t\tlast++;\n\t\t\tput++;\n\t\t}\n\t\tdout(\"put_cap_refs %p wb %d -> %d (?)\\n\",\n\t\t     inode, ci->i_wb_ref+1, ci->i_wb_ref);\n\t}\n\tif (had & CEPH_CAP_FILE_WR)\n\t\tif (--ci->i_wr_ref == 0) {\n\t\t\tlast++;\n\t\t\tif (!list_empty(&ci->i_cap_snaps)) {\n\t\t\t\tcapsnap = list_first_entry(&ci->i_cap_snaps,\n\t\t\t\t\t\t     struct ceph_cap_snap,\n\t\t\t\t\t\t     ci_item);\n\t\t\t\tif (capsnap->writing) {\n\t\t\t\t\tcapsnap->writing = 0;\n\t\t\t\t\tflushsnaps =\n\t\t\t\t\t\t__ceph_finish_cap_snap(ci,\n\t\t\t\t\t\t\t\t       capsnap);\n\t\t\t\t\twake = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tdout(\"put_cap_refs %p had %s%s%s\\n\", inode, ceph_cap_string(had),\n\t     last ? \" last\" : \"\", put ? \" put\" : \"\");\n\n\tif (last && !flushsnaps)\n\t\tceph_check_caps(ci, 0, NULL);\n\telse if (flushsnaps)\n\t\tceph_flush_snaps(ci);\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\tif (put)\n\t\tiput(inode);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_put_cap_refs(struct ceph_inode_info *ci, int had)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint last = 0, put = 0, flushsnaps = 0, wake = 0;\n\tstruct ceph_cap_snap *capsnap;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (had & CEPH_CAP_PIN)\n\t\t--ci->i_pin_ref;\n\tif (had & CEPH_CAP_FILE_RD)\n\t\tif (--ci->i_rd_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_CACHE)\n\t\tif (--ci->i_rdcache_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_BUFFER) {\n\t\tif (--ci->i_wb_ref == 0) {\n\t\t\tlast++;\n\t\t\tput++;\n\t\t}\n\t\tdout(\"put_cap_refs %p wb %d -> %d (?)\\n\",\n\t\t     inode, ci->i_wb_ref+1, ci->i_wb_ref);\n\t}\n\tif (had & CEPH_CAP_FILE_WR)\n\t\tif (--ci->i_wr_ref == 0) {\n\t\t\tlast++;\n\t\t\tif (!list_empty(&ci->i_cap_snaps)) {\n\t\t\t\tcapsnap = list_first_entry(&ci->i_cap_snaps,\n\t\t\t\t\t\t     struct ceph_cap_snap,\n\t\t\t\t\t\t     ci_item);\n\t\t\t\tif (capsnap->writing) {\n\t\t\t\t\tcapsnap->writing = 0;\n\t\t\t\t\tflushsnaps =\n\t\t\t\t\t\t__ceph_finish_cap_snap(ci,\n\t\t\t\t\t\t\t\t       capsnap);\n\t\t\t\t\twake = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tdout(\"put_cap_refs %p had %s%s%s\\n\", inode, ceph_cap_string(had),\n\t     last ? \" last\" : \"\", put ? \" put\" : \"\");\n\n\tif (last && !flushsnaps)\n\t\tceph_check_caps(ci, 0, NULL);\n\telse if (flushsnaps)\n\t\tceph_flush_snaps(ci);\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\tif (put)\n\t\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 2233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 2229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_page",
          "args": [
            "ci->vfs_inode.i_mapping",
            "0"
          ],
          "line": 2227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "&ci->vfs_inode"
          ],
          "line": 2226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible",
          "args": [
            "ci->i_cap_wq",
            "try_get_cap_refs(ci, need, want, endoff,\n\t\t\t\t\t\t &_got, &check_max, &err)"
          ],
          "line": 2213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_get_cap_refs",
          "args": [
            "ci",
            "need",
            "want",
            "endoff",
            "&_got",
            "&check_max",
            "&err"
          ],
          "line": 2214
        },
        "resolved": true,
        "details": {
          "function_name": "try_get_cap_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "2074-2168",
          "snippet": "static int try_get_cap_refs(struct ceph_inode_info *ci, int need, int want,\n\t\t\t    loff_t endoff, int *got, int *check_max, int *err)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint ret = 0;\n\tint have, implemented;\n\tint file_wanted;\n\n\tdout(\"get_cap_refs %p need %s want %s\\n\", inode,\n\t     ceph_cap_string(need), ceph_cap_string(want));\n\n\tspin_lock(&ci->i_ceph_lock);\n\n\t/* make sure file is actually open */\n\tfile_wanted = __ceph_caps_file_wanted(ci);\n\tif ((file_wanted & need) == 0) {\n\t\tdout(\"try_get_cap_refs need %s file_wanted %s, EBADF\\n\",\n\t\t     ceph_cap_string(need), ceph_cap_string(file_wanted));\n\t\t*err = -EBADF;\n\t\tret = 1;\n\t\tgoto out_unlock;\n\t}\n\n\t/* finish pending truncate */\n\twhile (ci->i_truncate_pending) {\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t__ceph_do_pending_vmtruncate(inode);\n\t\tspin_lock(&ci->i_ceph_lock);\n\t}\n\n\thave = __ceph_caps_issued(ci, &implemented);\n\n\tif (have & need & CEPH_CAP_FILE_WR) {\n\t\tif (endoff >= 0 && endoff > (loff_t)ci->i_max_size) {\n\t\t\tdout(\"get_cap_refs %p endoff %llu > maxsize %llu\\n\",\n\t\t\t     inode, endoff, ci->i_max_size);\n\t\t\tif (endoff > ci->i_requested_max_size) {\n\t\t\t\t*check_max = 1;\n\t\t\t\tret = 1;\n\t\t\t}\n\t\t\tgoto out_unlock;\n\t\t}\n\t\t/*\n\t\t * If a sync write is in progress, we must wait, so that we\n\t\t * can get a final snapshot value for size+mtime.\n\t\t */\n\t\tif (__ceph_have_pending_cap_snap(ci)) {\n\t\t\tdout(\"get_cap_refs %p cap_snap_pending\\n\", inode);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tif ((have & need) == need) {\n\t\t/*\n\t\t * Look at (implemented & ~have & not) so that we keep waiting\n\t\t * on transition from wanted -> needed caps.  This is needed\n\t\t * for WRBUFFER|WR -> WR to avoid a new WR sync write from\n\t\t * going before a prior buffered writeback happens.\n\t\t */\n\t\tint not = want & ~(have & need);\n\t\tint revoking = implemented & ~have;\n\t\tdout(\"get_cap_refs %p have %s but not %s (revoking %s)\\n\",\n\t\t     inode, ceph_cap_string(have), ceph_cap_string(not),\n\t\t     ceph_cap_string(revoking));\n\t\tif ((revoking & not) == 0) {\n\t\t\t*got = need | (have & want);\n\t\t\t__take_cap_refs(ci, *got);\n\t\t\tret = 1;\n\t\t}\n\t} else {\n\t\tint session_readonly = false;\n\t\tif ((need & CEPH_CAP_FILE_WR) && ci->i_auth_cap) {\n\t\t\tstruct ceph_mds_session *s = ci->i_auth_cap->session;\n\t\t\tspin_lock(&s->s_cap_lock);\n\t\t\tsession_readonly = s->s_readonly;\n\t\t\tspin_unlock(&s->s_cap_lock);\n\t\t}\n\t\tif (session_readonly) {\n\t\t\tdout(\"get_cap_refs %p needed %s but mds%d readonly\\n\",\n\t\t\t     inode, ceph_cap_string(need), ci->i_auth_cap->mds);\n\t\t\t*err = -EROFS;\n\t\t\tret = 1;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tdout(\"get_cap_refs %p have %s needed %s\\n\", inode,\n\t\t     ceph_cap_string(have), ceph_cap_string(need));\n\t}\nout_unlock:\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tdout(\"get_cap_refs %p ret %d got %s\\n\", inode,\n\t     ret, ceph_cap_string(*got));\n\treturn ret;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int try_get_cap_refs(struct ceph_inode_info *ci, int need, int want,\n\t\t\t    loff_t endoff, int *got, int *check_max, int *err)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint ret = 0;\n\tint have, implemented;\n\tint file_wanted;\n\n\tdout(\"get_cap_refs %p need %s want %s\\n\", inode,\n\t     ceph_cap_string(need), ceph_cap_string(want));\n\n\tspin_lock(&ci->i_ceph_lock);\n\n\t/* make sure file is actually open */\n\tfile_wanted = __ceph_caps_file_wanted(ci);\n\tif ((file_wanted & need) == 0) {\n\t\tdout(\"try_get_cap_refs need %s file_wanted %s, EBADF\\n\",\n\t\t     ceph_cap_string(need), ceph_cap_string(file_wanted));\n\t\t*err = -EBADF;\n\t\tret = 1;\n\t\tgoto out_unlock;\n\t}\n\n\t/* finish pending truncate */\n\twhile (ci->i_truncate_pending) {\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t__ceph_do_pending_vmtruncate(inode);\n\t\tspin_lock(&ci->i_ceph_lock);\n\t}\n\n\thave = __ceph_caps_issued(ci, &implemented);\n\n\tif (have & need & CEPH_CAP_FILE_WR) {\n\t\tif (endoff >= 0 && endoff > (loff_t)ci->i_max_size) {\n\t\t\tdout(\"get_cap_refs %p endoff %llu > maxsize %llu\\n\",\n\t\t\t     inode, endoff, ci->i_max_size);\n\t\t\tif (endoff > ci->i_requested_max_size) {\n\t\t\t\t*check_max = 1;\n\t\t\t\tret = 1;\n\t\t\t}\n\t\t\tgoto out_unlock;\n\t\t}\n\t\t/*\n\t\t * If a sync write is in progress, we must wait, so that we\n\t\t * can get a final snapshot value for size+mtime.\n\t\t */\n\t\tif (__ceph_have_pending_cap_snap(ci)) {\n\t\t\tdout(\"get_cap_refs %p cap_snap_pending\\n\", inode);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tif ((have & need) == need) {\n\t\t/*\n\t\t * Look at (implemented & ~have & not) so that we keep waiting\n\t\t * on transition from wanted -> needed caps.  This is needed\n\t\t * for WRBUFFER|WR -> WR to avoid a new WR sync write from\n\t\t * going before a prior buffered writeback happens.\n\t\t */\n\t\tint not = want & ~(have & need);\n\t\tint revoking = implemented & ~have;\n\t\tdout(\"get_cap_refs %p have %s but not %s (revoking %s)\\n\",\n\t\t     inode, ceph_cap_string(have), ceph_cap_string(not),\n\t\t     ceph_cap_string(revoking));\n\t\tif ((revoking & not) == 0) {\n\t\t\t*got = need | (have & want);\n\t\t\t__take_cap_refs(ci, *got);\n\t\t\tret = 1;\n\t\t}\n\t} else {\n\t\tint session_readonly = false;\n\t\tif ((need & CEPH_CAP_FILE_WR) && ci->i_auth_cap) {\n\t\t\tstruct ceph_mds_session *s = ci->i_auth_cap->session;\n\t\t\tspin_lock(&s->s_cap_lock);\n\t\t\tsession_readonly = s->s_readonly;\n\t\t\tspin_unlock(&s->s_cap_lock);\n\t\t}\n\t\tif (session_readonly) {\n\t\t\tdout(\"get_cap_refs %p needed %s but mds%d readonly\\n\",\n\t\t\t     inode, ceph_cap_string(need), ci->i_auth_cap->mds);\n\t\t\t*err = -EROFS;\n\t\t\tret = 1;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tdout(\"get_cap_refs %p have %s needed %s\\n\", inode,\n\t\t     ceph_cap_string(have), ceph_cap_string(need));\n\t}\nout_unlock:\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tdout(\"get_cap_refs %p ret %d got %s\\n\", inode,\n\t     ret, ceph_cap_string(*got));\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_max_size",
          "args": [
            "&ci->vfs_inode",
            "endoff"
          ],
          "line": 2210
        },
        "resolved": true,
        "details": {
          "function_name": "check_max_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "2175-2196",
          "snippet": "static void check_max_size(struct inode *inode, loff_t endoff)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint check = 0;\n\n\t/* do we need to explicitly request a larger max_size? */\n\tspin_lock(&ci->i_ceph_lock);\n\tif (endoff >= ci->i_max_size && endoff > ci->i_wanted_max_size) {\n\t\tdout(\"write %p at large endoff %llu, req max_size\\n\",\n\t\t     inode, endoff);\n\t\tci->i_wanted_max_size = endoff;\n\t}\n\t/* duplicate ceph_check_caps()'s logic */\n\tif (ci->i_auth_cap &&\n\t    (ci->i_auth_cap->issued & CEPH_CAP_FILE_WR) &&\n\t    ci->i_wanted_max_size > ci->i_max_size &&\n\t    ci->i_wanted_max_size > ci->i_requested_max_size)\n\t\tcheck = 1;\n\tspin_unlock(&ci->i_ceph_lock);\n\tif (check)\n\t\tceph_check_caps(ci, CHECK_CAPS_AUTHONLY, NULL);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void check_max_size(struct inode *inode, loff_t endoff)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint check = 0;\n\n\t/* do we need to explicitly request a larger max_size? */\n\tspin_lock(&ci->i_ceph_lock);\n\tif (endoff >= ci->i_max_size && endoff > ci->i_wanted_max_size) {\n\t\tdout(\"write %p at large endoff %llu, req max_size\\n\",\n\t\t     inode, endoff);\n\t\tci->i_wanted_max_size = endoff;\n\t}\n\t/* duplicate ceph_check_caps()'s logic */\n\tif (ci->i_auth_cap &&\n\t    (ci->i_auth_cap->issued & CEPH_CAP_FILE_WR) &&\n\t    ci->i_wanted_max_size > ci->i_max_size &&\n\t    ci->i_wanted_max_size > ci->i_requested_max_size)\n\t\tcheck = 1;\n\tspin_unlock(&ci->i_ceph_lock);\n\tif (check)\n\t\tceph_check_caps(ci, CHECK_CAPS_AUTHONLY, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_get_caps(struct ceph_inode_info *ci, int need, int want,\n\t\t  loff_t endoff, int *got, struct page **pinned_page)\n{\n\tint _got, check_max, ret, err = 0;\n\nretry:\n\tif (endoff > 0)\n\t\tcheck_max_size(&ci->vfs_inode, endoff);\n\t_got = 0;\n\tcheck_max = 0;\n\tret = wait_event_interruptible(ci->i_cap_wq,\n\t\t\t\ttry_get_cap_refs(ci, need, want, endoff,\n\t\t\t\t\t\t &_got, &check_max, &err));\n\tif (err)\n\t\tret = err;\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (check_max)\n\t\tgoto retry;\n\n\tif (ci->i_inline_version != CEPH_INLINE_NONE &&\n\t    (_got & (CEPH_CAP_FILE_CACHE|CEPH_CAP_FILE_LAZYIO)) &&\n\t    i_size_read(&ci->vfs_inode) > 0) {\n\t\tstruct page *page = find_get_page(ci->vfs_inode.i_mapping, 0);\n\t\tif (page) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\t*pinned_page = page;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tpage_cache_release(page);\n\t\t}\n\t\t/*\n\t\t * drop cap refs first because getattr while holding\n\t\t * caps refs can cause deadlock.\n\t\t */\n\t\tceph_put_cap_refs(ci, _got);\n\t\t_got = 0;\n\n\t\t/* getattr request will bring inline data into page cache */\n\t\tret = __ceph_do_getattr(&ci->vfs_inode, NULL,\n\t\t\t\t\tCEPH_STAT_CAP_INLINE_DATA, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tgoto retry;\n\t}\nout:\n\t*got = _got;\n\treturn 0;\n}"
  },
  {
    "function_name": "check_max_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "2175-2196",
    "snippet": "static void check_max_size(struct inode *inode, loff_t endoff)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint check = 0;\n\n\t/* do we need to explicitly request a larger max_size? */\n\tspin_lock(&ci->i_ceph_lock);\n\tif (endoff >= ci->i_max_size && endoff > ci->i_wanted_max_size) {\n\t\tdout(\"write %p at large endoff %llu, req max_size\\n\",\n\t\t     inode, endoff);\n\t\tci->i_wanted_max_size = endoff;\n\t}\n\t/* duplicate ceph_check_caps()'s logic */\n\tif (ci->i_auth_cap &&\n\t    (ci->i_auth_cap->issued & CEPH_CAP_FILE_WR) &&\n\t    ci->i_wanted_max_size > ci->i_max_size &&\n\t    ci->i_wanted_max_size > ci->i_requested_max_size)\n\t\tcheck = 1;\n\tspin_unlock(&ci->i_ceph_lock);\n\tif (check)\n\t\tceph_check_caps(ci, CHECK_CAPS_AUTHONLY, NULL);\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_check_caps",
          "args": [
            "ci",
            "CHECK_CAPS_AUTHONLY",
            "NULL"
          ],
          "line": 2195
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_check_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "1504-1751",
          "snippet": "void ceph_check_caps(struct ceph_inode_info *ci, int flags,\n\t\t     struct ceph_mds_session *session)\n{\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(&ci->vfs_inode);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct inode *inode = &ci->vfs_inode;\n\tstruct ceph_cap *cap;\n\tint file_wanted, used, cap_used;\n\tint took_snap_rwsem = 0;             /* true if mdsc->snap_rwsem held */\n\tint issued, implemented, want, retain, revoking, flushing = 0;\n\tint mds = -1;   /* keep track of how far we've gone through i_caps list\n\t\t\t   to avoid an infinite loop on retry */\n\tstruct rb_node *p;\n\tint tried_invalidate = 0;\n\tint delayed = 0, sent = 0, force_requeue = 0, num;\n\tint queue_invalidate = 0;\n\tint is_delayed = flags & CHECK_CAPS_NODELAY;\n\n\t/* if we are unmounting, flush any unused caps immediately. */\n\tif (mdsc->stopping)\n\t\tis_delayed = 1;\n\n\tspin_lock(&ci->i_ceph_lock);\n\n\tif (ci->i_ceph_flags & CEPH_I_FLUSH)\n\t\tflags |= CHECK_CAPS_FLUSH;\n\n\t/* flush snaps first time around only */\n\tif (!list_empty(&ci->i_cap_snaps))\n\t\t__ceph_flush_snaps(ci, &session, 0);\n\tgoto retry_locked;\nretry:\n\tspin_lock(&ci->i_ceph_lock);\nretry_locked:\n\tfile_wanted = __ceph_caps_file_wanted(ci);\n\tused = __ceph_caps_used(ci);\n\twant = file_wanted | used;\n\tissued = __ceph_caps_issued(ci, &implemented);\n\trevoking = implemented & ~issued;\n\n\tretain = want | CEPH_CAP_PIN;\n\tif (!mdsc->stopping && inode->i_nlink > 0) {\n\t\tif (want) {\n\t\t\tretain |= CEPH_CAP_ANY;       /* be greedy */\n\t\t} else {\n\t\t\tretain |= CEPH_CAP_ANY_SHARED;\n\t\t\t/*\n\t\t\t * keep RD only if we didn't have the file open RW,\n\t\t\t * because then the mds would revoke it anyway to\n\t\t\t * journal max_size=0.\n\t\t\t */\n\t\t\tif (ci->i_max_size == 0)\n\t\t\t\tretain |= CEPH_CAP_ANY_RD;\n\t\t}\n\t}\n\n\tdout(\"check_caps %p file_want %s used %s dirty %s flushing %s\"\n\t     \" issued %s revoking %s retain %s %s%s%s\\n\", inode,\n\t     ceph_cap_string(file_wanted),\n\t     ceph_cap_string(used), ceph_cap_string(ci->i_dirty_caps),\n\t     ceph_cap_string(ci->i_flushing_caps),\n\t     ceph_cap_string(issued), ceph_cap_string(revoking),\n\t     ceph_cap_string(retain),\n\t     (flags & CHECK_CAPS_AUTHONLY) ? \" AUTHONLY\" : \"\",\n\t     (flags & CHECK_CAPS_NODELAY) ? \" NODELAY\" : \"\",\n\t     (flags & CHECK_CAPS_FLUSH) ? \" FLUSH\" : \"\");\n\n\t/*\n\t * If we no longer need to hold onto old our caps, and we may\n\t * have cached pages, but don't want them, then try to invalidate.\n\t * If we fail, it's because pages are locked.... try again later.\n\t */\n\tif ((!is_delayed || mdsc->stopping) &&\n\t    ci->i_wrbuffer_ref == 0 &&               /* no dirty pages... */\n\t    inode->i_data.nrpages &&                 /* have cached pages */\n\t    (file_wanted == 0 ||                     /* no open files */\n\t     (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t  CEPH_CAP_FILE_LAZYIO))) && /*  or revoking cache */\n\t    !tried_invalidate) {\n\t\tdout(\"check_caps trying to invalidate on %p\\n\", inode);\n\t\tif (try_nonblocking_invalidate(inode) < 0) {\n\t\t\tif (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t\t\tCEPH_CAP_FILE_LAZYIO)) {\n\t\t\t\tdout(\"check_caps queuing invalidate\\n\");\n\t\t\t\tqueue_invalidate = 1;\n\t\t\t\tci->i_rdcache_revoking = ci->i_rdcache_gen;\n\t\t\t} else {\n\t\t\t\tdout(\"check_caps failed to invalidate pages\\n\");\n\t\t\t\t/* we failed to invalidate pages.  check these\n\t\t\t\t   caps again later. */\n\t\t\t\tforce_requeue = 1;\n\t\t\t\t__cap_set_timeouts(mdsc, ci);\n\t\t\t}\n\t\t}\n\t\ttried_invalidate = 1;\n\t\tgoto retry_locked;\n\t}\n\n\tnum = 0;\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tnum++;\n\n\t\t/* avoid looping forever */\n\t\tif (mds >= cap->mds ||\n\t\t    ((flags & CHECK_CAPS_AUTHONLY) && cap != ci->i_auth_cap))\n\t\t\tcontinue;\n\n\t\t/* NOTE: no side-effects allowed, until we take s_mutex */\n\n\t\tcap_used = used;\n\t\tif (ci->i_auth_cap && cap != ci->i_auth_cap)\n\t\t\tcap_used &= ~ci->i_auth_cap->issued;\n\n\t\trevoking = cap->implemented & ~cap->issued;\n\t\tdout(\" mds%d cap %p used %s issued %s implemented %s revoking %s\\n\",\n\t\t     cap->mds, cap, ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(cap_used),\n\t\t     ceph_cap_string(cap->implemented),\n\t\t     ceph_cap_string(revoking));\n\n\t\tif (cap == ci->i_auth_cap &&\n\t\t    (cap->issued & CEPH_CAP_FILE_WR)) {\n\t\t\t/* request larger max_size from MDS? */\n\t\t\tif (ci->i_wanted_max_size > ci->i_max_size &&\n\t\t\t    ci->i_wanted_max_size > ci->i_requested_max_size) {\n\t\t\t\tdout(\"requesting new max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\n\t\t\t/* approaching file_max? */\n\t\t\tif ((inode->i_size << 1) >= ci->i_max_size &&\n\t\t\t    (ci->i_reported_size << 1) < ci->i_max_size) {\n\t\t\t\tdout(\"i_size approaching max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\t\t}\n\t\t/* flush anything dirty? */\n\t\tif (cap == ci->i_auth_cap && (flags & CHECK_CAPS_FLUSH) &&\n\t\t    ci->i_dirty_caps) {\n\t\t\tdout(\"flushing dirty caps\\n\");\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* completed revocation? going down and there are no caps? */\n\t\tif (revoking && (revoking & cap_used) == 0) {\n\t\t\tdout(\"completed revocation of %s\\n\",\n\t\t\t     ceph_cap_string(cap->implemented & ~cap->issued));\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* want more caps from mds? */\n\t\tif (want & ~(cap->mds_wanted | cap->issued))\n\t\t\tgoto ack;\n\n\t\t/* things we might delay */\n\t\tif ((cap->issued & ~retain) == 0 &&\n\t\t    cap->mds_wanted == want)\n\t\t\tcontinue;     /* nope, all good */\n\n\t\tif (is_delayed)\n\t\t\tgoto ack;\n\n\t\t/* delay? */\n\t\tif ((ci->i_ceph_flags & CEPH_I_NODELAY) == 0 &&\n\t\t    time_before(jiffies, ci->i_hold_caps_max)) {\n\t\t\tdout(\" delaying issued %s -> %s, wanted %s -> %s\\n\",\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(cap->issued & retain),\n\t\t\t     ceph_cap_string(cap->mds_wanted),\n\t\t\t     ceph_cap_string(want));\n\t\t\tdelayed++;\n\t\t\tcontinue;\n\t\t}\n\nack:\n\t\tif (ci->i_ceph_flags & CEPH_I_NOFLUSH) {\n\t\t\tdout(\" skipping %p I_NOFLUSH set\\n\", inode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (session && session != cap->session) {\n\t\t\tdout(\"oops, wrong session %p mutex\\n\", session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tsession = NULL;\n\t\t}\n\t\tif (!session) {\n\t\t\tsession = cap->session;\n\t\t\tif (mutex_trylock(&session->s_mutex) == 0) {\n\t\t\t\tdout(\"inverting session/ino locks on %p\\n\",\n\t\t\t\t     session);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tif (took_snap_rwsem) {\n\t\t\t\t\tup_read(&mdsc->snap_rwsem);\n\t\t\t\t\ttook_snap_rwsem = 0;\n\t\t\t\t}\n\t\t\t\tmutex_lock(&session->s_mutex);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t\t/* take snap_rwsem after session mutex */\n\t\tif (!took_snap_rwsem) {\n\t\t\tif (down_read_trylock(&mdsc->snap_rwsem) == 0) {\n\t\t\t\tdout(\"inverting snap/in locks on %p\\n\",\n\t\t\t\t     inode);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tdown_read(&mdsc->snap_rwsem);\n\t\t\t\ttook_snap_rwsem = 1;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\ttook_snap_rwsem = 1;\n\t\t}\n\n\t\tif (cap == ci->i_auth_cap && ci->i_dirty_caps)\n\t\t\tflushing = __mark_caps_flushing(inode, session);\n\t\telse\n\t\t\tflushing = 0;\n\n\t\tmds = cap->mds;  /* remember mds, so we don't repeat */\n\t\tsent++;\n\n\t\t/* __send_cap drops i_ceph_lock */\n\t\tdelayed += __send_cap(mdsc, cap, CEPH_CAP_OP_UPDATE, cap_used,\n\t\t\t\t      want, retain, flushing, NULL);\n\t\tgoto retry; /* retake i_ceph_lock and restart our cap scan. */\n\t}\n\n\t/*\n\t * Reschedule delayed caps release if we delayed anything,\n\t * otherwise cancel.\n\t */\n\tif (delayed && is_delayed)\n\t\tforce_requeue = 1;   /* __send_cap delayed release; requeue */\n\tif (!delayed && !is_delayed)\n\t\t__cap_delay_cancel(mdsc, ci);\n\telse if (!is_delayed || force_requeue)\n\t\t__cap_delay_requeue(mdsc, ci);\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (queue_invalidate)\n\t\tceph_queue_invalidate(inode);\n\n\tif (session)\n\t\tmutex_unlock(&session->s_mutex);\n\tif (took_snap_rwsem)\n\t\tup_read(&mdsc->snap_rwsem);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_check_caps(struct ceph_inode_info *ci, int flags,\n\t\t     struct ceph_mds_session *session)\n{\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(&ci->vfs_inode);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct inode *inode = &ci->vfs_inode;\n\tstruct ceph_cap *cap;\n\tint file_wanted, used, cap_used;\n\tint took_snap_rwsem = 0;             /* true if mdsc->snap_rwsem held */\n\tint issued, implemented, want, retain, revoking, flushing = 0;\n\tint mds = -1;   /* keep track of how far we've gone through i_caps list\n\t\t\t   to avoid an infinite loop on retry */\n\tstruct rb_node *p;\n\tint tried_invalidate = 0;\n\tint delayed = 0, sent = 0, force_requeue = 0, num;\n\tint queue_invalidate = 0;\n\tint is_delayed = flags & CHECK_CAPS_NODELAY;\n\n\t/* if we are unmounting, flush any unused caps immediately. */\n\tif (mdsc->stopping)\n\t\tis_delayed = 1;\n\n\tspin_lock(&ci->i_ceph_lock);\n\n\tif (ci->i_ceph_flags & CEPH_I_FLUSH)\n\t\tflags |= CHECK_CAPS_FLUSH;\n\n\t/* flush snaps first time around only */\n\tif (!list_empty(&ci->i_cap_snaps))\n\t\t__ceph_flush_snaps(ci, &session, 0);\n\tgoto retry_locked;\nretry:\n\tspin_lock(&ci->i_ceph_lock);\nretry_locked:\n\tfile_wanted = __ceph_caps_file_wanted(ci);\n\tused = __ceph_caps_used(ci);\n\twant = file_wanted | used;\n\tissued = __ceph_caps_issued(ci, &implemented);\n\trevoking = implemented & ~issued;\n\n\tretain = want | CEPH_CAP_PIN;\n\tif (!mdsc->stopping && inode->i_nlink > 0) {\n\t\tif (want) {\n\t\t\tretain |= CEPH_CAP_ANY;       /* be greedy */\n\t\t} else {\n\t\t\tretain |= CEPH_CAP_ANY_SHARED;\n\t\t\t/*\n\t\t\t * keep RD only if we didn't have the file open RW,\n\t\t\t * because then the mds would revoke it anyway to\n\t\t\t * journal max_size=0.\n\t\t\t */\n\t\t\tif (ci->i_max_size == 0)\n\t\t\t\tretain |= CEPH_CAP_ANY_RD;\n\t\t}\n\t}\n\n\tdout(\"check_caps %p file_want %s used %s dirty %s flushing %s\"\n\t     \" issued %s revoking %s retain %s %s%s%s\\n\", inode,\n\t     ceph_cap_string(file_wanted),\n\t     ceph_cap_string(used), ceph_cap_string(ci->i_dirty_caps),\n\t     ceph_cap_string(ci->i_flushing_caps),\n\t     ceph_cap_string(issued), ceph_cap_string(revoking),\n\t     ceph_cap_string(retain),\n\t     (flags & CHECK_CAPS_AUTHONLY) ? \" AUTHONLY\" : \"\",\n\t     (flags & CHECK_CAPS_NODELAY) ? \" NODELAY\" : \"\",\n\t     (flags & CHECK_CAPS_FLUSH) ? \" FLUSH\" : \"\");\n\n\t/*\n\t * If we no longer need to hold onto old our caps, and we may\n\t * have cached pages, but don't want them, then try to invalidate.\n\t * If we fail, it's because pages are locked.... try again later.\n\t */\n\tif ((!is_delayed || mdsc->stopping) &&\n\t    ci->i_wrbuffer_ref == 0 &&               /* no dirty pages... */\n\t    inode->i_data.nrpages &&                 /* have cached pages */\n\t    (file_wanted == 0 ||                     /* no open files */\n\t     (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t  CEPH_CAP_FILE_LAZYIO))) && /*  or revoking cache */\n\t    !tried_invalidate) {\n\t\tdout(\"check_caps trying to invalidate on %p\\n\", inode);\n\t\tif (try_nonblocking_invalidate(inode) < 0) {\n\t\t\tif (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t\t\tCEPH_CAP_FILE_LAZYIO)) {\n\t\t\t\tdout(\"check_caps queuing invalidate\\n\");\n\t\t\t\tqueue_invalidate = 1;\n\t\t\t\tci->i_rdcache_revoking = ci->i_rdcache_gen;\n\t\t\t} else {\n\t\t\t\tdout(\"check_caps failed to invalidate pages\\n\");\n\t\t\t\t/* we failed to invalidate pages.  check these\n\t\t\t\t   caps again later. */\n\t\t\t\tforce_requeue = 1;\n\t\t\t\t__cap_set_timeouts(mdsc, ci);\n\t\t\t}\n\t\t}\n\t\ttried_invalidate = 1;\n\t\tgoto retry_locked;\n\t}\n\n\tnum = 0;\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tnum++;\n\n\t\t/* avoid looping forever */\n\t\tif (mds >= cap->mds ||\n\t\t    ((flags & CHECK_CAPS_AUTHONLY) && cap != ci->i_auth_cap))\n\t\t\tcontinue;\n\n\t\t/* NOTE: no side-effects allowed, until we take s_mutex */\n\n\t\tcap_used = used;\n\t\tif (ci->i_auth_cap && cap != ci->i_auth_cap)\n\t\t\tcap_used &= ~ci->i_auth_cap->issued;\n\n\t\trevoking = cap->implemented & ~cap->issued;\n\t\tdout(\" mds%d cap %p used %s issued %s implemented %s revoking %s\\n\",\n\t\t     cap->mds, cap, ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(cap_used),\n\t\t     ceph_cap_string(cap->implemented),\n\t\t     ceph_cap_string(revoking));\n\n\t\tif (cap == ci->i_auth_cap &&\n\t\t    (cap->issued & CEPH_CAP_FILE_WR)) {\n\t\t\t/* request larger max_size from MDS? */\n\t\t\tif (ci->i_wanted_max_size > ci->i_max_size &&\n\t\t\t    ci->i_wanted_max_size > ci->i_requested_max_size) {\n\t\t\t\tdout(\"requesting new max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\n\t\t\t/* approaching file_max? */\n\t\t\tif ((inode->i_size << 1) >= ci->i_max_size &&\n\t\t\t    (ci->i_reported_size << 1) < ci->i_max_size) {\n\t\t\t\tdout(\"i_size approaching max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\t\t}\n\t\t/* flush anything dirty? */\n\t\tif (cap == ci->i_auth_cap && (flags & CHECK_CAPS_FLUSH) &&\n\t\t    ci->i_dirty_caps) {\n\t\t\tdout(\"flushing dirty caps\\n\");\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* completed revocation? going down and there are no caps? */\n\t\tif (revoking && (revoking & cap_used) == 0) {\n\t\t\tdout(\"completed revocation of %s\\n\",\n\t\t\t     ceph_cap_string(cap->implemented & ~cap->issued));\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* want more caps from mds? */\n\t\tif (want & ~(cap->mds_wanted | cap->issued))\n\t\t\tgoto ack;\n\n\t\t/* things we might delay */\n\t\tif ((cap->issued & ~retain) == 0 &&\n\t\t    cap->mds_wanted == want)\n\t\t\tcontinue;     /* nope, all good */\n\n\t\tif (is_delayed)\n\t\t\tgoto ack;\n\n\t\t/* delay? */\n\t\tif ((ci->i_ceph_flags & CEPH_I_NODELAY) == 0 &&\n\t\t    time_before(jiffies, ci->i_hold_caps_max)) {\n\t\t\tdout(\" delaying issued %s -> %s, wanted %s -> %s\\n\",\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(cap->issued & retain),\n\t\t\t     ceph_cap_string(cap->mds_wanted),\n\t\t\t     ceph_cap_string(want));\n\t\t\tdelayed++;\n\t\t\tcontinue;\n\t\t}\n\nack:\n\t\tif (ci->i_ceph_flags & CEPH_I_NOFLUSH) {\n\t\t\tdout(\" skipping %p I_NOFLUSH set\\n\", inode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (session && session != cap->session) {\n\t\t\tdout(\"oops, wrong session %p mutex\\n\", session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tsession = NULL;\n\t\t}\n\t\tif (!session) {\n\t\t\tsession = cap->session;\n\t\t\tif (mutex_trylock(&session->s_mutex) == 0) {\n\t\t\t\tdout(\"inverting session/ino locks on %p\\n\",\n\t\t\t\t     session);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tif (took_snap_rwsem) {\n\t\t\t\t\tup_read(&mdsc->snap_rwsem);\n\t\t\t\t\ttook_snap_rwsem = 0;\n\t\t\t\t}\n\t\t\t\tmutex_lock(&session->s_mutex);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t\t/* take snap_rwsem after session mutex */\n\t\tif (!took_snap_rwsem) {\n\t\t\tif (down_read_trylock(&mdsc->snap_rwsem) == 0) {\n\t\t\t\tdout(\"inverting snap/in locks on %p\\n\",\n\t\t\t\t     inode);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tdown_read(&mdsc->snap_rwsem);\n\t\t\t\ttook_snap_rwsem = 1;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\ttook_snap_rwsem = 1;\n\t\t}\n\n\t\tif (cap == ci->i_auth_cap && ci->i_dirty_caps)\n\t\t\tflushing = __mark_caps_flushing(inode, session);\n\t\telse\n\t\t\tflushing = 0;\n\n\t\tmds = cap->mds;  /* remember mds, so we don't repeat */\n\t\tsent++;\n\n\t\t/* __send_cap drops i_ceph_lock */\n\t\tdelayed += __send_cap(mdsc, cap, CEPH_CAP_OP_UPDATE, cap_used,\n\t\t\t\t      want, retain, flushing, NULL);\n\t\tgoto retry; /* retake i_ceph_lock and restart our cap scan. */\n\t}\n\n\t/*\n\t * Reschedule delayed caps release if we delayed anything,\n\t * otherwise cancel.\n\t */\n\tif (delayed && is_delayed)\n\t\tforce_requeue = 1;   /* __send_cap delayed release; requeue */\n\tif (!delayed && !is_delayed)\n\t\t__cap_delay_cancel(mdsc, ci);\n\telse if (!is_delayed || force_requeue)\n\t\t__cap_delay_requeue(mdsc, ci);\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (queue_invalidate)\n\t\tceph_queue_invalidate(inode);\n\n\tif (session)\n\t\tmutex_unlock(&session->s_mutex);\n\tif (took_snap_rwsem)\n\t\tup_read(&mdsc->snap_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 2193
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"write %p at large endoff %llu, req max_size\\n\"",
            "inode",
            "endoff"
          ],
          "line": 2183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 2181
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 2177
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void check_max_size(struct inode *inode, loff_t endoff)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint check = 0;\n\n\t/* do we need to explicitly request a larger max_size? */\n\tspin_lock(&ci->i_ceph_lock);\n\tif (endoff >= ci->i_max_size && endoff > ci->i_wanted_max_size) {\n\t\tdout(\"write %p at large endoff %llu, req max_size\\n\",\n\t\t     inode, endoff);\n\t\tci->i_wanted_max_size = endoff;\n\t}\n\t/* duplicate ceph_check_caps()'s logic */\n\tif (ci->i_auth_cap &&\n\t    (ci->i_auth_cap->issued & CEPH_CAP_FILE_WR) &&\n\t    ci->i_wanted_max_size > ci->i_max_size &&\n\t    ci->i_wanted_max_size > ci->i_requested_max_size)\n\t\tcheck = 1;\n\tspin_unlock(&ci->i_ceph_lock);\n\tif (check)\n\t\tceph_check_caps(ci, CHECK_CAPS_AUTHONLY, NULL);\n}"
  },
  {
    "function_name": "try_get_cap_refs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "2074-2168",
    "snippet": "static int try_get_cap_refs(struct ceph_inode_info *ci, int need, int want,\n\t\t\t    loff_t endoff, int *got, int *check_max, int *err)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint ret = 0;\n\tint have, implemented;\n\tint file_wanted;\n\n\tdout(\"get_cap_refs %p need %s want %s\\n\", inode,\n\t     ceph_cap_string(need), ceph_cap_string(want));\n\n\tspin_lock(&ci->i_ceph_lock);\n\n\t/* make sure file is actually open */\n\tfile_wanted = __ceph_caps_file_wanted(ci);\n\tif ((file_wanted & need) == 0) {\n\t\tdout(\"try_get_cap_refs need %s file_wanted %s, EBADF\\n\",\n\t\t     ceph_cap_string(need), ceph_cap_string(file_wanted));\n\t\t*err = -EBADF;\n\t\tret = 1;\n\t\tgoto out_unlock;\n\t}\n\n\t/* finish pending truncate */\n\twhile (ci->i_truncate_pending) {\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t__ceph_do_pending_vmtruncate(inode);\n\t\tspin_lock(&ci->i_ceph_lock);\n\t}\n\n\thave = __ceph_caps_issued(ci, &implemented);\n\n\tif (have & need & CEPH_CAP_FILE_WR) {\n\t\tif (endoff >= 0 && endoff > (loff_t)ci->i_max_size) {\n\t\t\tdout(\"get_cap_refs %p endoff %llu > maxsize %llu\\n\",\n\t\t\t     inode, endoff, ci->i_max_size);\n\t\t\tif (endoff > ci->i_requested_max_size) {\n\t\t\t\t*check_max = 1;\n\t\t\t\tret = 1;\n\t\t\t}\n\t\t\tgoto out_unlock;\n\t\t}\n\t\t/*\n\t\t * If a sync write is in progress, we must wait, so that we\n\t\t * can get a final snapshot value for size+mtime.\n\t\t */\n\t\tif (__ceph_have_pending_cap_snap(ci)) {\n\t\t\tdout(\"get_cap_refs %p cap_snap_pending\\n\", inode);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tif ((have & need) == need) {\n\t\t/*\n\t\t * Look at (implemented & ~have & not) so that we keep waiting\n\t\t * on transition from wanted -> needed caps.  This is needed\n\t\t * for WRBUFFER|WR -> WR to avoid a new WR sync write from\n\t\t * going before a prior buffered writeback happens.\n\t\t */\n\t\tint not = want & ~(have & need);\n\t\tint revoking = implemented & ~have;\n\t\tdout(\"get_cap_refs %p have %s but not %s (revoking %s)\\n\",\n\t\t     inode, ceph_cap_string(have), ceph_cap_string(not),\n\t\t     ceph_cap_string(revoking));\n\t\tif ((revoking & not) == 0) {\n\t\t\t*got = need | (have & want);\n\t\t\t__take_cap_refs(ci, *got);\n\t\t\tret = 1;\n\t\t}\n\t} else {\n\t\tint session_readonly = false;\n\t\tif ((need & CEPH_CAP_FILE_WR) && ci->i_auth_cap) {\n\t\t\tstruct ceph_mds_session *s = ci->i_auth_cap->session;\n\t\t\tspin_lock(&s->s_cap_lock);\n\t\t\tsession_readonly = s->s_readonly;\n\t\t\tspin_unlock(&s->s_cap_lock);\n\t\t}\n\t\tif (session_readonly) {\n\t\t\tdout(\"get_cap_refs %p needed %s but mds%d readonly\\n\",\n\t\t\t     inode, ceph_cap_string(need), ci->i_auth_cap->mds);\n\t\t\t*err = -EROFS;\n\t\t\tret = 1;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tdout(\"get_cap_refs %p have %s needed %s\\n\", inode,\n\t\t     ceph_cap_string(have), ceph_cap_string(need));\n\t}\nout_unlock:\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tdout(\"get_cap_refs %p ret %d got %s\\n\", inode,\n\t     ret, ceph_cap_string(*got));\n\treturn ret;\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"get_cap_refs %p ret %d got %s\\n\"",
            "inode",
            "ret",
            "ceph_cap_string(*got)"
          ],
          "line": 2165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_cap_string",
          "args": [
            "*got"
          ],
          "line": 2166
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_cap_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "71-116",
          "snippet": "const char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [
            "#define MAX_CAP_STR 20"
          ],
          "globals_used": [
            "static char cap_str[MAX_CAP_STR][40];",
            "static DEFINE_SPINLOCK(cap_str_lock);",
            "static int last_cap_str;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\n#define MAX_CAP_STR 20\n\nstatic char cap_str[MAX_CAP_STR][40];\nstatic DEFINE_SPINLOCK(cap_str_lock);\nstatic int last_cap_str;\n\nconst char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 2163
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"get_cap_refs %p have %s needed %s\\n\"",
            "inode",
            "ceph_cap_string(have)",
            "ceph_cap_string(need)"
          ],
          "line": 2159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"get_cap_refs %p needed %s but mds%d readonly\\n\"",
            "inode",
            "ceph_cap_string(need)",
            "ci->i_auth_cap->mds"
          ],
          "line": 2152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&s->s_cap_lock"
          ],
          "line": 2147
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__take_cap_refs",
          "args": [
            "ci",
            "*got"
          ],
          "line": 2140
        },
        "resolved": true,
        "details": {
          "function_name": "__take_cap_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "2048-2065",
          "snippet": "static void __take_cap_refs(struct ceph_inode_info *ci, int got)\n{\n\tif (got & CEPH_CAP_PIN)\n\t\tci->i_pin_ref++;\n\tif (got & CEPH_CAP_FILE_RD)\n\t\tci->i_rd_ref++;\n\tif (got & CEPH_CAP_FILE_CACHE)\n\t\tci->i_rdcache_ref++;\n\tif (got & CEPH_CAP_FILE_WR)\n\t\tci->i_wr_ref++;\n\tif (got & CEPH_CAP_FILE_BUFFER) {\n\t\tif (ci->i_wb_ref == 0)\n\t\t\tihold(&ci->vfs_inode);\n\t\tci->i_wb_ref++;\n\t\tdout(\"__take_cap_refs %p wb %d -> %d (?)\\n\",\n\t\t     &ci->vfs_inode, ci->i_wb_ref-1, ci->i_wb_ref);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __take_cap_refs(struct ceph_inode_info *ci, int got)\n{\n\tif (got & CEPH_CAP_PIN)\n\t\tci->i_pin_ref++;\n\tif (got & CEPH_CAP_FILE_RD)\n\t\tci->i_rd_ref++;\n\tif (got & CEPH_CAP_FILE_CACHE)\n\t\tci->i_rdcache_ref++;\n\tif (got & CEPH_CAP_FILE_WR)\n\t\tci->i_wr_ref++;\n\tif (got & CEPH_CAP_FILE_BUFFER) {\n\t\tif (ci->i_wb_ref == 0)\n\t\t\tihold(&ci->vfs_inode);\n\t\tci->i_wb_ref++;\n\t\tdout(\"__take_cap_refs %p wb %d -> %d (?)\\n\",\n\t\t     &ci->vfs_inode, ci->i_wb_ref-1, ci->i_wb_ref);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"get_cap_refs %p have %s but not %s (revoking %s)\\n\"",
            "inode",
            "ceph_cap_string(have)",
            "ceph_cap_string(not)",
            "ceph_cap_string(revoking)"
          ],
          "line": 2135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"get_cap_refs %p cap_snap_pending\\n\"",
            "inode"
          ],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ceph_have_pending_cap_snap",
          "args": [
            "ci"
          ],
          "line": 2120
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_have_pending_cap_snap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "712-717",
          "snippet": "static inline bool __ceph_have_pending_cap_snap(struct ceph_inode_info *ci)\n{\n\treturn !list_empty(&ci->i_cap_snaps) &&\n\t\tlist_entry(ci->i_cap_snaps.prev, struct ceph_cap_snap,\n\t\t\t   ci_item)->writing;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline bool __ceph_have_pending_cap_snap(struct ceph_inode_info *ci)\n{\n\treturn !list_empty(&ci->i_cap_snaps) &&\n\t\tlist_entry(ci->i_cap_snaps.prev, struct ceph_cap_snap,\n\t\t\t   ci_item)->writing;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"get_cap_refs %p endoff %llu > maxsize %llu\\n\"",
            "inode",
            "endoff",
            "ci->i_max_size"
          ],
          "line": 2108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ceph_caps_issued",
          "args": [
            "ci",
            "&implemented"
          ],
          "line": 2104
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_caps_issued_other",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "700-715",
          "snippet": "int __ceph_caps_issued_other(struct ceph_inode_info *ci, struct ceph_cap *ocap)\n{\n\tint have = ci->i_snap_caps;\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (cap == ocap)\n\t\t\tcontinue;\n\t\tif (!__cap_is_valid(cap))\n\t\t\tcontinue;\n\t\thave |= cap->issued;\n\t}\n\treturn have;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_caps_issued_other(struct ceph_inode_info *ci, struct ceph_cap *ocap)\n{\n\tint have = ci->i_snap_caps;\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (cap == ocap)\n\t\t\tcontinue;\n\t\tif (!__cap_is_valid(cap))\n\t\t\tcontinue;\n\t\thave |= cap->issued;\n\t}\n\treturn have;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_do_pending_vmtruncate",
          "args": [
            "inode"
          ],
          "line": 2100
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_do_pending_vmtruncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "1634-1689",
          "snippet": "void __ceph_do_pending_vmtruncate(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tu64 to;\n\tint wrbuffer_refs, finish = 0;\n\n\tmutex_lock(&ci->i_truncate_mutex);\nretry:\n\tspin_lock(&ci->i_ceph_lock);\n\tif (ci->i_truncate_pending == 0) {\n\t\tdout(\"__do_pending_vmtruncate %p none pending\\n\", inode);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tmutex_unlock(&ci->i_truncate_mutex);\n\t\treturn;\n\t}\n\n\t/*\n\t * make sure any dirty snapped pages are flushed before we\n\t * possibly truncate them.. so write AND block!\n\t */\n\tif (ci->i_wrbuffer_ref_head < ci->i_wrbuffer_ref) {\n\t\tdout(\"__do_pending_vmtruncate %p flushing snaps first\\n\",\n\t\t     inode);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tfilemap_write_and_wait_range(&inode->i_data, 0,\n\t\t\t\t\t     inode->i_sb->s_maxbytes);\n\t\tgoto retry;\n\t}\n\n\t/* there should be no reader or writer */\n\tWARN_ON_ONCE(ci->i_rd_ref || ci->i_wr_ref);\n\n\tto = ci->i_truncate_size;\n\twrbuffer_refs = ci->i_wrbuffer_ref;\n\tdout(\"__do_pending_vmtruncate %p (%d) to %lld\\n\", inode,\n\t     ci->i_truncate_pending, to);\n\tspin_unlock(&ci->i_ceph_lock);\n\n\ttruncate_pagecache(inode, to);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (to == ci->i_truncate_size) {\n\t\tci->i_truncate_pending = 0;\n\t\tfinish = 1;\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\tif (!finish)\n\t\tgoto retry;\n\n\tmutex_unlock(&ci->i_truncate_mutex);\n\n\tif (wrbuffer_refs == 0)\n\t\tceph_check_caps(ci, CHECK_CAPS_AUTHONLY, NULL);\n\n\twake_up_all(&ci->i_cap_wq);\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid __ceph_do_pending_vmtruncate(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tu64 to;\n\tint wrbuffer_refs, finish = 0;\n\n\tmutex_lock(&ci->i_truncate_mutex);\nretry:\n\tspin_lock(&ci->i_ceph_lock);\n\tif (ci->i_truncate_pending == 0) {\n\t\tdout(\"__do_pending_vmtruncate %p none pending\\n\", inode);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tmutex_unlock(&ci->i_truncate_mutex);\n\t\treturn;\n\t}\n\n\t/*\n\t * make sure any dirty snapped pages are flushed before we\n\t * possibly truncate them.. so write AND block!\n\t */\n\tif (ci->i_wrbuffer_ref_head < ci->i_wrbuffer_ref) {\n\t\tdout(\"__do_pending_vmtruncate %p flushing snaps first\\n\",\n\t\t     inode);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tfilemap_write_and_wait_range(&inode->i_data, 0,\n\t\t\t\t\t     inode->i_sb->s_maxbytes);\n\t\tgoto retry;\n\t}\n\n\t/* there should be no reader or writer */\n\tWARN_ON_ONCE(ci->i_rd_ref || ci->i_wr_ref);\n\n\tto = ci->i_truncate_size;\n\twrbuffer_refs = ci->i_wrbuffer_ref;\n\tdout(\"__do_pending_vmtruncate %p (%d) to %lld\\n\", inode,\n\t     ci->i_truncate_pending, to);\n\tspin_unlock(&ci->i_ceph_lock);\n\n\ttruncate_pagecache(inode, to);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (to == ci->i_truncate_size) {\n\t\tci->i_truncate_pending = 0;\n\t\tfinish = 1;\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\tif (!finish)\n\t\tgoto retry;\n\n\tmutex_unlock(&ci->i_truncate_mutex);\n\n\tif (wrbuffer_refs == 0)\n\t\tceph_check_caps(ci, CHECK_CAPS_AUTHONLY, NULL);\n\n\twake_up_all(&ci->i_cap_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"try_get_cap_refs need %s file_wanted %s, EBADF\\n\"",
            "ceph_cap_string(need)",
            "ceph_cap_string(file_wanted)"
          ],
          "line": 2090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ceph_caps_file_wanted",
          "args": [
            "ci"
          ],
          "line": 2088
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_caps_file_wanted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "848-856",
          "snippet": "int __ceph_caps_file_wanted(struct ceph_inode_info *ci)\n{\n\tint want = 0;\n\tint mode;\n\tfor (mode = 0; mode < CEPH_FILE_MODE_NUM; mode++)\n\t\tif (ci->i_nr_by_mode[mode])\n\t\t\twant |= ceph_caps_for_mode(mode);\n\treturn want;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_caps_file_wanted(struct ceph_inode_info *ci)\n{\n\tint want = 0;\n\tint mode;\n\tfor (mode = 0; mode < CEPH_FILE_MODE_NUM; mode++)\n\t\tif (ci->i_nr_by_mode[mode])\n\t\t\twant |= ceph_caps_for_mode(mode);\n\treturn want;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"get_cap_refs %p need %s want %s\\n\"",
            "inode",
            "ceph_cap_string(need)",
            "ceph_cap_string(want)"
          ],
          "line": 2082
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int try_get_cap_refs(struct ceph_inode_info *ci, int need, int want,\n\t\t\t    loff_t endoff, int *got, int *check_max, int *err)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint ret = 0;\n\tint have, implemented;\n\tint file_wanted;\n\n\tdout(\"get_cap_refs %p need %s want %s\\n\", inode,\n\t     ceph_cap_string(need), ceph_cap_string(want));\n\n\tspin_lock(&ci->i_ceph_lock);\n\n\t/* make sure file is actually open */\n\tfile_wanted = __ceph_caps_file_wanted(ci);\n\tif ((file_wanted & need) == 0) {\n\t\tdout(\"try_get_cap_refs need %s file_wanted %s, EBADF\\n\",\n\t\t     ceph_cap_string(need), ceph_cap_string(file_wanted));\n\t\t*err = -EBADF;\n\t\tret = 1;\n\t\tgoto out_unlock;\n\t}\n\n\t/* finish pending truncate */\n\twhile (ci->i_truncate_pending) {\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t__ceph_do_pending_vmtruncate(inode);\n\t\tspin_lock(&ci->i_ceph_lock);\n\t}\n\n\thave = __ceph_caps_issued(ci, &implemented);\n\n\tif (have & need & CEPH_CAP_FILE_WR) {\n\t\tif (endoff >= 0 && endoff > (loff_t)ci->i_max_size) {\n\t\t\tdout(\"get_cap_refs %p endoff %llu > maxsize %llu\\n\",\n\t\t\t     inode, endoff, ci->i_max_size);\n\t\t\tif (endoff > ci->i_requested_max_size) {\n\t\t\t\t*check_max = 1;\n\t\t\t\tret = 1;\n\t\t\t}\n\t\t\tgoto out_unlock;\n\t\t}\n\t\t/*\n\t\t * If a sync write is in progress, we must wait, so that we\n\t\t * can get a final snapshot value for size+mtime.\n\t\t */\n\t\tif (__ceph_have_pending_cap_snap(ci)) {\n\t\t\tdout(\"get_cap_refs %p cap_snap_pending\\n\", inode);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tif ((have & need) == need) {\n\t\t/*\n\t\t * Look at (implemented & ~have & not) so that we keep waiting\n\t\t * on transition from wanted -> needed caps.  This is needed\n\t\t * for WRBUFFER|WR -> WR to avoid a new WR sync write from\n\t\t * going before a prior buffered writeback happens.\n\t\t */\n\t\tint not = want & ~(have & need);\n\t\tint revoking = implemented & ~have;\n\t\tdout(\"get_cap_refs %p have %s but not %s (revoking %s)\\n\",\n\t\t     inode, ceph_cap_string(have), ceph_cap_string(not),\n\t\t     ceph_cap_string(revoking));\n\t\tif ((revoking & not) == 0) {\n\t\t\t*got = need | (have & want);\n\t\t\t__take_cap_refs(ci, *got);\n\t\t\tret = 1;\n\t\t}\n\t} else {\n\t\tint session_readonly = false;\n\t\tif ((need & CEPH_CAP_FILE_WR) && ci->i_auth_cap) {\n\t\t\tstruct ceph_mds_session *s = ci->i_auth_cap->session;\n\t\t\tspin_lock(&s->s_cap_lock);\n\t\t\tsession_readonly = s->s_readonly;\n\t\t\tspin_unlock(&s->s_cap_lock);\n\t\t}\n\t\tif (session_readonly) {\n\t\t\tdout(\"get_cap_refs %p needed %s but mds%d readonly\\n\",\n\t\t\t     inode, ceph_cap_string(need), ci->i_auth_cap->mds);\n\t\t\t*err = -EROFS;\n\t\t\tret = 1;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tdout(\"get_cap_refs %p have %s needed %s\\n\", inode,\n\t\t     ceph_cap_string(have), ceph_cap_string(need));\n\t}\nout_unlock:\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tdout(\"get_cap_refs %p ret %d got %s\\n\", inode,\n\t     ret, ceph_cap_string(*got));\n\treturn ret;\n}"
  },
  {
    "function_name": "__take_cap_refs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "2048-2065",
    "snippet": "static void __take_cap_refs(struct ceph_inode_info *ci, int got)\n{\n\tif (got & CEPH_CAP_PIN)\n\t\tci->i_pin_ref++;\n\tif (got & CEPH_CAP_FILE_RD)\n\t\tci->i_rd_ref++;\n\tif (got & CEPH_CAP_FILE_CACHE)\n\t\tci->i_rdcache_ref++;\n\tif (got & CEPH_CAP_FILE_WR)\n\t\tci->i_wr_ref++;\n\tif (got & CEPH_CAP_FILE_BUFFER) {\n\t\tif (ci->i_wb_ref == 0)\n\t\t\tihold(&ci->vfs_inode);\n\t\tci->i_wb_ref++;\n\t\tdout(\"__take_cap_refs %p wb %d -> %d (?)\\n\",\n\t\t     &ci->vfs_inode, ci->i_wb_ref-1, ci->i_wb_ref);\n\t}\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"__take_cap_refs %p wb %d -> %d (?)\\n\"",
            "&ci->vfs_inode",
            "ci->i_wb_ref-1",
            "ci->i_wb_ref"
          ],
          "line": 2062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "&ci->vfs_inode"
          ],
          "line": 2060
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __take_cap_refs(struct ceph_inode_info *ci, int got)\n{\n\tif (got & CEPH_CAP_PIN)\n\t\tci->i_pin_ref++;\n\tif (got & CEPH_CAP_FILE_RD)\n\t\tci->i_rd_ref++;\n\tif (got & CEPH_CAP_FILE_CACHE)\n\t\tci->i_rdcache_ref++;\n\tif (got & CEPH_CAP_FILE_WR)\n\t\tci->i_wr_ref++;\n\tif (got & CEPH_CAP_FILE_BUFFER) {\n\t\tif (ci->i_wb_ref == 0)\n\t\t\tihold(&ci->vfs_inode);\n\t\tci->i_wb_ref++;\n\t\tdout(\"__take_cap_refs %p wb %d -> %d (?)\\n\",\n\t\t     &ci->vfs_inode, ci->i_wb_ref-1, ci->i_wb_ref);\n\t}\n}"
  },
  {
    "function_name": "kick_flushing_inode_caps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "2005-2039",
    "snippet": "static void kick_flushing_inode_caps(struct ceph_mds_client *mdsc,\n\t\t\t\t     struct ceph_mds_session *session,\n\t\t\t\t     struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_cap *cap;\n\tint delayed = 0;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tcap = ci->i_auth_cap;\n\tdout(\"kick_flushing_inode_caps %p flushing %s flush_seq %lld\\n\", inode,\n\t     ceph_cap_string(ci->i_flushing_caps), ci->i_cap_flush_seq);\n\n\t__ceph_flush_snaps(ci, &session, 1);\n\n\tif (ci->i_flushing_caps) {\n\t\tspin_lock(&mdsc->cap_dirty_lock);\n\t\tlist_move_tail(&ci->i_flushing_item,\n\t\t\t       &cap->session->s_cap_flushing);\n\t\tspin_unlock(&mdsc->cap_dirty_lock);\n\n\t\tdelayed = __send_cap(mdsc, cap, CEPH_CAP_OP_FLUSH,\n\t\t\t\t     __ceph_caps_used(ci),\n\t\t\t\t     __ceph_caps_wanted(ci),\n\t\t\t\t     cap->issued | cap->implemented,\n\t\t\t\t     ci->i_flushing_caps, NULL);\n\t\tif (delayed) {\n\t\t\tspin_lock(&ci->i_ceph_lock);\n\t\t\t__cap_delay_requeue(mdsc, ci);\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t}\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 2037
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__cap_delay_requeue",
          "args": [
            "mdsc",
            "ci"
          ],
          "line": 2033
        },
        "resolved": true,
        "details": {
          "function_name": "__cap_delay_requeue_front",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "442-452",
          "snippet": "static void __cap_delay_requeue_front(struct ceph_mds_client *mdsc,\n\t\t\t\t      struct ceph_inode_info *ci)\n{\n\tdout(\"__cap_delay_requeue_front %p\\n\", &ci->vfs_inode);\n\tspin_lock(&mdsc->cap_delay_lock);\n\tci->i_ceph_flags |= CEPH_I_FLUSH;\n\tif (!list_empty(&ci->i_cap_delay_list))\n\t\tlist_del_init(&ci->i_cap_delay_list);\n\tlist_add(&ci->i_cap_delay_list, &mdsc->cap_delay_list);\n\tspin_unlock(&mdsc->cap_delay_lock);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __cap_delay_requeue_front(struct ceph_mds_client *mdsc,\n\t\t\t\t      struct ceph_inode_info *ci)\n{\n\tdout(\"__cap_delay_requeue_front %p\\n\", &ci->vfs_inode);\n\tspin_lock(&mdsc->cap_delay_lock);\n\tci->i_ceph_flags |= CEPH_I_FLUSH;\n\tif (!list_empty(&ci->i_cap_delay_list))\n\t\tlist_del_init(&ci->i_cap_delay_list);\n\tlist_add(&ci->i_cap_delay_list, &mdsc->cap_delay_list);\n\tspin_unlock(&mdsc->cap_delay_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 2032
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__send_cap",
          "args": [
            "mdsc",
            "cap",
            "CEPH_CAP_OP_FLUSH",
            "__ceph_caps_used(ci)",
            "__ceph_caps_wanted(ci)",
            "cap->issued | cap->implemented",
            "ci->i_flushing_caps",
            "NULL"
          ],
          "line": 2026
        },
        "resolved": true,
        "details": {
          "function_name": "__send_cap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "1118-1243",
          "snippet": "static int __send_cap(struct ceph_mds_client *mdsc, struct ceph_cap *cap,\n\t\t      int op, int used, int want, int retain, int flushing,\n\t\t      unsigned *pflush_tid)\n\t__releases(cap->ci->i_ceph_lock)\n{\n\tstruct ceph_inode_info *ci = cap->ci;\n\tstruct inode *inode = &ci->vfs_inode;\n\tu64 cap_id = cap->cap_id;\n\tint held, revoking, dropping, keep;\n\tu64 seq, issue_seq, mseq, time_warp_seq, follows;\n\tu64 size, max_size;\n\tstruct timespec mtime, atime;\n\tint wake = 0;\n\tumode_t mode;\n\tkuid_t uid;\n\tkgid_t gid;\n\tstruct ceph_mds_session *session;\n\tu64 xattr_version = 0;\n\tstruct ceph_buffer *xattr_blob = NULL;\n\tint delayed = 0;\n\tu64 flush_tid = 0;\n\tint i;\n\tint ret;\n\tbool inline_data;\n\n\theld = cap->issued | cap->implemented;\n\trevoking = cap->implemented & ~cap->issued;\n\tretain &= ~revoking;\n\tdropping = cap->issued & ~retain;\n\n\tdout(\"__send_cap %p cap %p session %p %s -> %s (revoking %s)\\n\",\n\t     inode, cap, cap->session,\n\t     ceph_cap_string(held), ceph_cap_string(held & retain),\n\t     ceph_cap_string(revoking));\n\tBUG_ON((retain & CEPH_CAP_PIN) == 0);\n\n\tsession = cap->session;\n\n\t/* don't release wanted unless we've waited a bit. */\n\tif ((ci->i_ceph_flags & CEPH_I_NODELAY) == 0 &&\n\t    time_before(jiffies, ci->i_hold_caps_min)) {\n\t\tdout(\" delaying issued %s -> %s, wanted %s -> %s on send\\n\",\n\t\t     ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(cap->issued & retain),\n\t\t     ceph_cap_string(cap->mds_wanted),\n\t\t     ceph_cap_string(want));\n\t\twant |= cap->mds_wanted;\n\t\tretain |= cap->issued;\n\t\tdelayed = 1;\n\t}\n\tci->i_ceph_flags &= ~(CEPH_I_NODELAY | CEPH_I_FLUSH);\n\n\tcap->issued &= retain;  /* drop bits we don't want */\n\tif (cap->implemented & ~cap->issued) {\n\t\t/*\n\t\t * Wake up any waiters on wanted -> needed transition.\n\t\t * This is due to the weird transition from buffered\n\t\t * to sync IO... we need to flush dirty pages _before_\n\t\t * allowing sync writes to avoid reordering.\n\t\t */\n\t\twake = 1;\n\t}\n\tcap->implemented &= cap->issued | used;\n\tcap->mds_wanted = want;\n\n\tif (flushing) {\n\t\t/*\n\t\t * assign a tid for flush operations so we can avoid\n\t\t * flush1 -> dirty1 -> flush2 -> flushack1 -> mark\n\t\t * clean type races.  track latest tid for every bit\n\t\t * so we can handle flush AxFw, flush Fw, and have the\n\t\t * first ack clean Ax.\n\t\t */\n\t\tflush_tid = ++ci->i_cap_flush_last_tid;\n\t\tif (pflush_tid)\n\t\t\t*pflush_tid = flush_tid;\n\t\tdout(\" cap_flush_tid %d\\n\", (int)flush_tid);\n\t\tfor (i = 0; i < CEPH_CAP_BITS; i++)\n\t\t\tif (flushing & (1 << i))\n\t\t\t\tci->i_cap_flush_tid[i] = flush_tid;\n\n\t\tfollows = ci->i_head_snapc->seq;\n\t} else {\n\t\tfollows = 0;\n\t}\n\n\tkeep = cap->implemented;\n\tseq = cap->seq;\n\tissue_seq = cap->issue_seq;\n\tmseq = cap->mseq;\n\tsize = inode->i_size;\n\tci->i_reported_size = size;\n\tmax_size = ci->i_wanted_max_size;\n\tci->i_requested_max_size = max_size;\n\tmtime = inode->i_mtime;\n\tatime = inode->i_atime;\n\ttime_warp_seq = ci->i_time_warp_seq;\n\tuid = inode->i_uid;\n\tgid = inode->i_gid;\n\tmode = inode->i_mode;\n\n\tif (flushing & CEPH_CAP_XATTR_EXCL) {\n\t\t__ceph_build_xattrs_blob(ci);\n\t\txattr_blob = ci->i_xattrs.blob;\n\t\txattr_version = ci->i_xattrs.version;\n\t}\n\n\tinline_data = ci->i_inline_version != CEPH_INLINE_NONE;\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tret = send_cap_msg(session, ceph_vino(inode).ino, cap_id,\n\t\top, keep, want, flushing, seq, flush_tid, issue_seq, mseq,\n\t\tsize, max_size, &mtime, &atime, time_warp_seq,\n\t\tuid, gid, mode, xattr_version, xattr_blob,\n\t\tfollows, inline_data);\n\tif (ret < 0) {\n\t\tdout(\"error sending cap msg, must requeue %p\\n\", inode);\n\t\tdelayed = 1;\n\t}\n\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\n\treturn delayed;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __send_cap(struct ceph_mds_client *mdsc, struct ceph_cap *cap,\n\t\t      int op, int used, int want, int retain, int flushing,\n\t\t      unsigned *pflush_tid)\n\t__releases(cap->ci->i_ceph_lock)\n{\n\tstruct ceph_inode_info *ci = cap->ci;\n\tstruct inode *inode = &ci->vfs_inode;\n\tu64 cap_id = cap->cap_id;\n\tint held, revoking, dropping, keep;\n\tu64 seq, issue_seq, mseq, time_warp_seq, follows;\n\tu64 size, max_size;\n\tstruct timespec mtime, atime;\n\tint wake = 0;\n\tumode_t mode;\n\tkuid_t uid;\n\tkgid_t gid;\n\tstruct ceph_mds_session *session;\n\tu64 xattr_version = 0;\n\tstruct ceph_buffer *xattr_blob = NULL;\n\tint delayed = 0;\n\tu64 flush_tid = 0;\n\tint i;\n\tint ret;\n\tbool inline_data;\n\n\theld = cap->issued | cap->implemented;\n\trevoking = cap->implemented & ~cap->issued;\n\tretain &= ~revoking;\n\tdropping = cap->issued & ~retain;\n\n\tdout(\"__send_cap %p cap %p session %p %s -> %s (revoking %s)\\n\",\n\t     inode, cap, cap->session,\n\t     ceph_cap_string(held), ceph_cap_string(held & retain),\n\t     ceph_cap_string(revoking));\n\tBUG_ON((retain & CEPH_CAP_PIN) == 0);\n\n\tsession = cap->session;\n\n\t/* don't release wanted unless we've waited a bit. */\n\tif ((ci->i_ceph_flags & CEPH_I_NODELAY) == 0 &&\n\t    time_before(jiffies, ci->i_hold_caps_min)) {\n\t\tdout(\" delaying issued %s -> %s, wanted %s -> %s on send\\n\",\n\t\t     ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(cap->issued & retain),\n\t\t     ceph_cap_string(cap->mds_wanted),\n\t\t     ceph_cap_string(want));\n\t\twant |= cap->mds_wanted;\n\t\tretain |= cap->issued;\n\t\tdelayed = 1;\n\t}\n\tci->i_ceph_flags &= ~(CEPH_I_NODELAY | CEPH_I_FLUSH);\n\n\tcap->issued &= retain;  /* drop bits we don't want */\n\tif (cap->implemented & ~cap->issued) {\n\t\t/*\n\t\t * Wake up any waiters on wanted -> needed transition.\n\t\t * This is due to the weird transition from buffered\n\t\t * to sync IO... we need to flush dirty pages _before_\n\t\t * allowing sync writes to avoid reordering.\n\t\t */\n\t\twake = 1;\n\t}\n\tcap->implemented &= cap->issued | used;\n\tcap->mds_wanted = want;\n\n\tif (flushing) {\n\t\t/*\n\t\t * assign a tid for flush operations so we can avoid\n\t\t * flush1 -> dirty1 -> flush2 -> flushack1 -> mark\n\t\t * clean type races.  track latest tid for every bit\n\t\t * so we can handle flush AxFw, flush Fw, and have the\n\t\t * first ack clean Ax.\n\t\t */\n\t\tflush_tid = ++ci->i_cap_flush_last_tid;\n\t\tif (pflush_tid)\n\t\t\t*pflush_tid = flush_tid;\n\t\tdout(\" cap_flush_tid %d\\n\", (int)flush_tid);\n\t\tfor (i = 0; i < CEPH_CAP_BITS; i++)\n\t\t\tif (flushing & (1 << i))\n\t\t\t\tci->i_cap_flush_tid[i] = flush_tid;\n\n\t\tfollows = ci->i_head_snapc->seq;\n\t} else {\n\t\tfollows = 0;\n\t}\n\n\tkeep = cap->implemented;\n\tseq = cap->seq;\n\tissue_seq = cap->issue_seq;\n\tmseq = cap->mseq;\n\tsize = inode->i_size;\n\tci->i_reported_size = size;\n\tmax_size = ci->i_wanted_max_size;\n\tci->i_requested_max_size = max_size;\n\tmtime = inode->i_mtime;\n\tatime = inode->i_atime;\n\ttime_warp_seq = ci->i_time_warp_seq;\n\tuid = inode->i_uid;\n\tgid = inode->i_gid;\n\tmode = inode->i_mode;\n\n\tif (flushing & CEPH_CAP_XATTR_EXCL) {\n\t\t__ceph_build_xattrs_blob(ci);\n\t\txattr_blob = ci->i_xattrs.blob;\n\t\txattr_version = ci->i_xattrs.version;\n\t}\n\n\tinline_data = ci->i_inline_version != CEPH_INLINE_NONE;\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tret = send_cap_msg(session, ceph_vino(inode).ino, cap_id,\n\t\top, keep, want, flushing, seq, flush_tid, issue_seq, mseq,\n\t\tsize, max_size, &mtime, &atime, time_warp_seq,\n\t\tuid, gid, mode, xattr_version, xattr_blob,\n\t\tfollows, inline_data);\n\tif (ret < 0) {\n\t\tdout(\"error sending cap msg, must requeue %p\\n\", inode);\n\t\tdelayed = 1;\n\t}\n\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\n\treturn delayed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_caps_wanted",
          "args": [
            "ci"
          ],
          "line": 2028
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_caps_wanted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "566-572",
          "snippet": "static inline int __ceph_caps_wanted(struct ceph_inode_info *ci)\n{\n\tint w = __ceph_caps_file_wanted(ci) | __ceph_caps_used(ci);\n\tif (w & CEPH_CAP_FILE_BUFFER)\n\t\tw |= CEPH_CAP_FILE_EXCL;  /* we want EXCL if dirty data */\n\treturn w;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline int __ceph_caps_wanted(struct ceph_inode_info *ci)\n{\n\tint w = __ceph_caps_file_wanted(ci) | __ceph_caps_used(ci);\n\tif (w & CEPH_CAP_FILE_BUFFER)\n\t\tw |= CEPH_CAP_FILE_EXCL;  /* we want EXCL if dirty data */\n\treturn w;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_caps_used",
          "args": [
            "ci"
          ],
          "line": 2027
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_caps_used",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "829-843",
          "snippet": "int __ceph_caps_used(struct ceph_inode_info *ci)\n{\n\tint used = 0;\n\tif (ci->i_pin_ref)\n\t\tused |= CEPH_CAP_PIN;\n\tif (ci->i_rd_ref)\n\t\tused |= CEPH_CAP_FILE_RD;\n\tif (ci->i_rdcache_ref || ci->vfs_inode.i_data.nrpages)\n\t\tused |= CEPH_CAP_FILE_CACHE;\n\tif (ci->i_wr_ref)\n\t\tused |= CEPH_CAP_FILE_WR;\n\tif (ci->i_wb_ref || ci->i_wrbuffer_ref)\n\t\tused |= CEPH_CAP_FILE_BUFFER;\n\treturn used;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_caps_used(struct ceph_inode_info *ci)\n{\n\tint used = 0;\n\tif (ci->i_pin_ref)\n\t\tused |= CEPH_CAP_PIN;\n\tif (ci->i_rd_ref)\n\t\tused |= CEPH_CAP_FILE_RD;\n\tif (ci->i_rdcache_ref || ci->vfs_inode.i_data.nrpages)\n\t\tused |= CEPH_CAP_FILE_CACHE;\n\tif (ci->i_wr_ref)\n\t\tused |= CEPH_CAP_FILE_WR;\n\tif (ci->i_wb_ref || ci->i_wrbuffer_ref)\n\t\tused |= CEPH_CAP_FILE_BUFFER;\n\treturn used;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&ci->i_flushing_item",
            "&cap->session->s_cap_flushing"
          ],
          "line": 2022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ceph_flush_snaps",
          "args": [
            "ci",
            "&session",
            "1"
          ],
          "line": 2018
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_flush_snaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "1257-1375",
          "snippet": "void __ceph_flush_snaps(struct ceph_inode_info *ci,\n\t\t\tstruct ceph_mds_session **psession,\n\t\t\tint again)\n\t\t__releases(ci->i_ceph_lock)\n\t\t__acquires(ci->i_ceph_lock)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint mds;\n\tstruct ceph_cap_snap *capsnap;\n\tu32 mseq;\n\tstruct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;\n\tstruct ceph_mds_session *session = NULL; /* if session != NULL, we hold\n\t\t\t\t\t\t    session->s_mutex */\n\tu64 next_follows = 0;  /* keep track of how far we've gotten through the\n\t\t\t     i_cap_snaps list, and skip these entries next time\n\t\t\t     around to avoid an infinite loop */\n\n\tif (psession)\n\t\tsession = *psession;\n\n\tdout(\"__flush_snaps %p\\n\", inode);\nretry:\n\tlist_for_each_entry(capsnap, &ci->i_cap_snaps, ci_item) {\n\t\t/* avoid an infiniute loop after retry */\n\t\tif (capsnap->follows < next_follows)\n\t\t\tcontinue;\n\t\t/*\n\t\t * we need to wait for sync writes to complete and for dirty\n\t\t * pages to be written out.\n\t\t */\n\t\tif (capsnap->dirty_pages || capsnap->writing)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * if cap writeback already occurred, we should have dropped\n\t\t * the capsnap in ceph_put_wrbuffer_cap_refs.\n\t\t */\n\t\tBUG_ON(capsnap->dirty == 0);\n\n\t\t/* pick mds, take s_mutex */\n\t\tif (ci->i_auth_cap == NULL) {\n\t\t\tdout(\"no auth cap (migrating?), doing nothing\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* only flush each capsnap once */\n\t\tif (!again && !list_empty(&capsnap->flushing_item)) {\n\t\t\tdout(\"already flushed %p, skipping\\n\", capsnap);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmds = ci->i_auth_cap->session->s_mds;\n\t\tmseq = ci->i_auth_cap->mseq;\n\n\t\tif (session && session->s_mds != mds) {\n\t\t\tdout(\"oops, wrong session %p mutex\\n\", session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tceph_put_mds_session(session);\n\t\t\tsession = NULL;\n\t\t}\n\t\tif (!session) {\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\tmutex_lock(&mdsc->mutex);\n\t\t\tsession = __ceph_lookup_mds_session(mdsc, mds);\n\t\t\tmutex_unlock(&mdsc->mutex);\n\t\t\tif (session) {\n\t\t\t\tdout(\"inverting session/ino locks on %p\\n\",\n\t\t\t\t     session);\n\t\t\t\tmutex_lock(&session->s_mutex);\n\t\t\t}\n\t\t\t/*\n\t\t\t * if session == NULL, we raced against a cap\n\t\t\t * deletion or migration.  retry, and we'll\n\t\t\t * get a better @mds value next time.\n\t\t\t */\n\t\t\tspin_lock(&ci->i_ceph_lock);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tcapsnap->flush_tid = ++ci->i_cap_flush_last_tid;\n\t\tatomic_inc(&capsnap->nref);\n\t\tif (!list_empty(&capsnap->flushing_item))\n\t\t\tlist_del_init(&capsnap->flushing_item);\n\t\tlist_add_tail(&capsnap->flushing_item,\n\t\t\t      &session->s_cap_snaps_flushing);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\n\t\tdout(\"flush_snaps %p cap_snap %p follows %lld tid %llu\\n\",\n\t\t     inode, capsnap, capsnap->follows, capsnap->flush_tid);\n\t\tsend_cap_msg(session, ceph_vino(inode).ino, 0,\n\t\t\t     CEPH_CAP_OP_FLUSHSNAP, capsnap->issued, 0,\n\t\t\t     capsnap->dirty, 0, capsnap->flush_tid, 0, mseq,\n\t\t\t     capsnap->size, 0,\n\t\t\t     &capsnap->mtime, &capsnap->atime,\n\t\t\t     capsnap->time_warp_seq,\n\t\t\t     capsnap->uid, capsnap->gid, capsnap->mode,\n\t\t\t     capsnap->xattr_version, capsnap->xattr_blob,\n\t\t\t     capsnap->follows, capsnap->inline_data);\n\n\t\tnext_follows = capsnap->follows + 1;\n\t\tceph_put_cap_snap(capsnap);\n\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tgoto retry;\n\t}\n\n\t/* we flushed them all; remove this inode from the queue */\n\tspin_lock(&mdsc->snap_flush_lock);\n\tlist_del_init(&ci->i_snap_flush_item);\n\tspin_unlock(&mdsc->snap_flush_lock);\n\nout:\n\tif (psession)\n\t\t*psession = session;\n\telse if (session) {\n\t\tmutex_unlock(&session->s_mutex);\n\t\tceph_put_mds_session(session);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid __ceph_flush_snaps(struct ceph_inode_info *ci,\n\t\t\tstruct ceph_mds_session **psession,\n\t\t\tint again)\n\t\t__releases(ci->i_ceph_lock)\n\t\t__acquires(ci->i_ceph_lock)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint mds;\n\tstruct ceph_cap_snap *capsnap;\n\tu32 mseq;\n\tstruct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;\n\tstruct ceph_mds_session *session = NULL; /* if session != NULL, we hold\n\t\t\t\t\t\t    session->s_mutex */\n\tu64 next_follows = 0;  /* keep track of how far we've gotten through the\n\t\t\t     i_cap_snaps list, and skip these entries next time\n\t\t\t     around to avoid an infinite loop */\n\n\tif (psession)\n\t\tsession = *psession;\n\n\tdout(\"__flush_snaps %p\\n\", inode);\nretry:\n\tlist_for_each_entry(capsnap, &ci->i_cap_snaps, ci_item) {\n\t\t/* avoid an infiniute loop after retry */\n\t\tif (capsnap->follows < next_follows)\n\t\t\tcontinue;\n\t\t/*\n\t\t * we need to wait for sync writes to complete and for dirty\n\t\t * pages to be written out.\n\t\t */\n\t\tif (capsnap->dirty_pages || capsnap->writing)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * if cap writeback already occurred, we should have dropped\n\t\t * the capsnap in ceph_put_wrbuffer_cap_refs.\n\t\t */\n\t\tBUG_ON(capsnap->dirty == 0);\n\n\t\t/* pick mds, take s_mutex */\n\t\tif (ci->i_auth_cap == NULL) {\n\t\t\tdout(\"no auth cap (migrating?), doing nothing\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* only flush each capsnap once */\n\t\tif (!again && !list_empty(&capsnap->flushing_item)) {\n\t\t\tdout(\"already flushed %p, skipping\\n\", capsnap);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmds = ci->i_auth_cap->session->s_mds;\n\t\tmseq = ci->i_auth_cap->mseq;\n\n\t\tif (session && session->s_mds != mds) {\n\t\t\tdout(\"oops, wrong session %p mutex\\n\", session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tceph_put_mds_session(session);\n\t\t\tsession = NULL;\n\t\t}\n\t\tif (!session) {\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\tmutex_lock(&mdsc->mutex);\n\t\t\tsession = __ceph_lookup_mds_session(mdsc, mds);\n\t\t\tmutex_unlock(&mdsc->mutex);\n\t\t\tif (session) {\n\t\t\t\tdout(\"inverting session/ino locks on %p\\n\",\n\t\t\t\t     session);\n\t\t\t\tmutex_lock(&session->s_mutex);\n\t\t\t}\n\t\t\t/*\n\t\t\t * if session == NULL, we raced against a cap\n\t\t\t * deletion or migration.  retry, and we'll\n\t\t\t * get a better @mds value next time.\n\t\t\t */\n\t\t\tspin_lock(&ci->i_ceph_lock);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tcapsnap->flush_tid = ++ci->i_cap_flush_last_tid;\n\t\tatomic_inc(&capsnap->nref);\n\t\tif (!list_empty(&capsnap->flushing_item))\n\t\t\tlist_del_init(&capsnap->flushing_item);\n\t\tlist_add_tail(&capsnap->flushing_item,\n\t\t\t      &session->s_cap_snaps_flushing);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\n\t\tdout(\"flush_snaps %p cap_snap %p follows %lld tid %llu\\n\",\n\t\t     inode, capsnap, capsnap->follows, capsnap->flush_tid);\n\t\tsend_cap_msg(session, ceph_vino(inode).ino, 0,\n\t\t\t     CEPH_CAP_OP_FLUSHSNAP, capsnap->issued, 0,\n\t\t\t     capsnap->dirty, 0, capsnap->flush_tid, 0, mseq,\n\t\t\t     capsnap->size, 0,\n\t\t\t     &capsnap->mtime, &capsnap->atime,\n\t\t\t     capsnap->time_warp_seq,\n\t\t\t     capsnap->uid, capsnap->gid, capsnap->mode,\n\t\t\t     capsnap->xattr_version, capsnap->xattr_blob,\n\t\t\t     capsnap->follows, capsnap->inline_data);\n\n\t\tnext_follows = capsnap->follows + 1;\n\t\tceph_put_cap_snap(capsnap);\n\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tgoto retry;\n\t}\n\n\t/* we flushed them all; remove this inode from the queue */\n\tspin_lock(&mdsc->snap_flush_lock);\n\tlist_del_init(&ci->i_snap_flush_item);\n\tspin_unlock(&mdsc->snap_flush_lock);\n\nout:\n\tif (psession)\n\t\t*psession = session;\n\telse if (session) {\n\t\tmutex_unlock(&session->s_mutex);\n\t\tceph_put_mds_session(session);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"kick_flushing_inode_caps %p flushing %s flush_seq %lld\\n\"",
            "inode",
            "ceph_cap_string(ci->i_flushing_caps)",
            "ci->i_cap_flush_seq"
          ],
          "line": 2015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_cap_string",
          "args": [
            "ci->i_flushing_caps"
          ],
          "line": 2016
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_cap_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "71-116",
          "snippet": "const char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [
            "#define MAX_CAP_STR 20"
          ],
          "globals_used": [
            "static char cap_str[MAX_CAP_STR][40];",
            "static DEFINE_SPINLOCK(cap_str_lock);",
            "static int last_cap_str;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\n#define MAX_CAP_STR 20\n\nstatic char cap_str[MAX_CAP_STR][40];\nstatic DEFINE_SPINLOCK(cap_str_lock);\nstatic int last_cap_str;\n\nconst char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 2009
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void kick_flushing_inode_caps(struct ceph_mds_client *mdsc,\n\t\t\t\t     struct ceph_mds_session *session,\n\t\t\t\t     struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_cap *cap;\n\tint delayed = 0;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tcap = ci->i_auth_cap;\n\tdout(\"kick_flushing_inode_caps %p flushing %s flush_seq %lld\\n\", inode,\n\t     ceph_cap_string(ci->i_flushing_caps), ci->i_cap_flush_seq);\n\n\t__ceph_flush_snaps(ci, &session, 1);\n\n\tif (ci->i_flushing_caps) {\n\t\tspin_lock(&mdsc->cap_dirty_lock);\n\t\tlist_move_tail(&ci->i_flushing_item,\n\t\t\t       &cap->session->s_cap_flushing);\n\t\tspin_unlock(&mdsc->cap_dirty_lock);\n\n\t\tdelayed = __send_cap(mdsc, cap, CEPH_CAP_OP_FLUSH,\n\t\t\t\t     __ceph_caps_used(ci),\n\t\t\t\t     __ceph_caps_wanted(ci),\n\t\t\t\t     cap->issued | cap->implemented,\n\t\t\t\t     ci->i_flushing_caps, NULL);\n\t\tif (delayed) {\n\t\t\tspin_lock(&ci->i_ceph_lock);\n\t\t\t__cap_delay_requeue(mdsc, ci);\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t}\n}"
  },
  {
    "function_name": "ceph_kick_flushing_caps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "1969-2003",
    "snippet": "void ceph_kick_flushing_caps(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_mds_session *session)\n{\n\tstruct ceph_inode_info *ci;\n\n\tkick_flushing_capsnaps(mdsc, session);\n\n\tdout(\"kick_flushing_caps mds%d\\n\", session->s_mds);\n\tlist_for_each_entry(ci, &session->s_cap_flushing, i_flushing_item) {\n\t\tstruct inode *inode = &ci->vfs_inode;\n\t\tstruct ceph_cap *cap;\n\t\tint delayed = 0;\n\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tcap = ci->i_auth_cap;\n\t\tif (cap && cap->session == session) {\n\t\t\tdout(\"kick_flushing_caps %p cap %p %s\\n\", inode,\n\t\t\t     cap, ceph_cap_string(ci->i_flushing_caps));\n\t\t\tdelayed = __send_cap(mdsc, cap, CEPH_CAP_OP_FLUSH,\n\t\t\t\t\t     __ceph_caps_used(ci),\n\t\t\t\t\t     __ceph_caps_wanted(ci),\n\t\t\t\t\t     cap->issued | cap->implemented,\n\t\t\t\t\t     ci->i_flushing_caps, NULL);\n\t\t\tif (delayed) {\n\t\t\t\tspin_lock(&ci->i_ceph_lock);\n\t\t\t\t__cap_delay_requeue(mdsc, ci);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t}\n\t\t} else {\n\t\t\tpr_err(\"%p auth cap %p not mds%d ???\\n\", inode,\n\t\t\t       cap, session->s_mds);\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 2000
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%p auth cap %p not mds%d ???\\n\"",
            "inode",
            "cap",
            "session->s_mds"
          ],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__cap_delay_requeue",
          "args": [
            "mdsc",
            "ci"
          ],
          "line": 1994
        },
        "resolved": true,
        "details": {
          "function_name": "__cap_delay_requeue_front",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "442-452",
          "snippet": "static void __cap_delay_requeue_front(struct ceph_mds_client *mdsc,\n\t\t\t\t      struct ceph_inode_info *ci)\n{\n\tdout(\"__cap_delay_requeue_front %p\\n\", &ci->vfs_inode);\n\tspin_lock(&mdsc->cap_delay_lock);\n\tci->i_ceph_flags |= CEPH_I_FLUSH;\n\tif (!list_empty(&ci->i_cap_delay_list))\n\t\tlist_del_init(&ci->i_cap_delay_list);\n\tlist_add(&ci->i_cap_delay_list, &mdsc->cap_delay_list);\n\tspin_unlock(&mdsc->cap_delay_lock);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __cap_delay_requeue_front(struct ceph_mds_client *mdsc,\n\t\t\t\t      struct ceph_inode_info *ci)\n{\n\tdout(\"__cap_delay_requeue_front %p\\n\", &ci->vfs_inode);\n\tspin_lock(&mdsc->cap_delay_lock);\n\tci->i_ceph_flags |= CEPH_I_FLUSH;\n\tif (!list_empty(&ci->i_cap_delay_list))\n\t\tlist_del_init(&ci->i_cap_delay_list);\n\tlist_add(&ci->i_cap_delay_list, &mdsc->cap_delay_list);\n\tspin_unlock(&mdsc->cap_delay_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 1993
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__send_cap",
          "args": [
            "mdsc",
            "cap",
            "CEPH_CAP_OP_FLUSH",
            "__ceph_caps_used(ci)",
            "__ceph_caps_wanted(ci)",
            "cap->issued | cap->implemented",
            "ci->i_flushing_caps",
            "NULL"
          ],
          "line": 1987
        },
        "resolved": true,
        "details": {
          "function_name": "__send_cap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "1118-1243",
          "snippet": "static int __send_cap(struct ceph_mds_client *mdsc, struct ceph_cap *cap,\n\t\t      int op, int used, int want, int retain, int flushing,\n\t\t      unsigned *pflush_tid)\n\t__releases(cap->ci->i_ceph_lock)\n{\n\tstruct ceph_inode_info *ci = cap->ci;\n\tstruct inode *inode = &ci->vfs_inode;\n\tu64 cap_id = cap->cap_id;\n\tint held, revoking, dropping, keep;\n\tu64 seq, issue_seq, mseq, time_warp_seq, follows;\n\tu64 size, max_size;\n\tstruct timespec mtime, atime;\n\tint wake = 0;\n\tumode_t mode;\n\tkuid_t uid;\n\tkgid_t gid;\n\tstruct ceph_mds_session *session;\n\tu64 xattr_version = 0;\n\tstruct ceph_buffer *xattr_blob = NULL;\n\tint delayed = 0;\n\tu64 flush_tid = 0;\n\tint i;\n\tint ret;\n\tbool inline_data;\n\n\theld = cap->issued | cap->implemented;\n\trevoking = cap->implemented & ~cap->issued;\n\tretain &= ~revoking;\n\tdropping = cap->issued & ~retain;\n\n\tdout(\"__send_cap %p cap %p session %p %s -> %s (revoking %s)\\n\",\n\t     inode, cap, cap->session,\n\t     ceph_cap_string(held), ceph_cap_string(held & retain),\n\t     ceph_cap_string(revoking));\n\tBUG_ON((retain & CEPH_CAP_PIN) == 0);\n\n\tsession = cap->session;\n\n\t/* don't release wanted unless we've waited a bit. */\n\tif ((ci->i_ceph_flags & CEPH_I_NODELAY) == 0 &&\n\t    time_before(jiffies, ci->i_hold_caps_min)) {\n\t\tdout(\" delaying issued %s -> %s, wanted %s -> %s on send\\n\",\n\t\t     ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(cap->issued & retain),\n\t\t     ceph_cap_string(cap->mds_wanted),\n\t\t     ceph_cap_string(want));\n\t\twant |= cap->mds_wanted;\n\t\tretain |= cap->issued;\n\t\tdelayed = 1;\n\t}\n\tci->i_ceph_flags &= ~(CEPH_I_NODELAY | CEPH_I_FLUSH);\n\n\tcap->issued &= retain;  /* drop bits we don't want */\n\tif (cap->implemented & ~cap->issued) {\n\t\t/*\n\t\t * Wake up any waiters on wanted -> needed transition.\n\t\t * This is due to the weird transition from buffered\n\t\t * to sync IO... we need to flush dirty pages _before_\n\t\t * allowing sync writes to avoid reordering.\n\t\t */\n\t\twake = 1;\n\t}\n\tcap->implemented &= cap->issued | used;\n\tcap->mds_wanted = want;\n\n\tif (flushing) {\n\t\t/*\n\t\t * assign a tid for flush operations so we can avoid\n\t\t * flush1 -> dirty1 -> flush2 -> flushack1 -> mark\n\t\t * clean type races.  track latest tid for every bit\n\t\t * so we can handle flush AxFw, flush Fw, and have the\n\t\t * first ack clean Ax.\n\t\t */\n\t\tflush_tid = ++ci->i_cap_flush_last_tid;\n\t\tif (pflush_tid)\n\t\t\t*pflush_tid = flush_tid;\n\t\tdout(\" cap_flush_tid %d\\n\", (int)flush_tid);\n\t\tfor (i = 0; i < CEPH_CAP_BITS; i++)\n\t\t\tif (flushing & (1 << i))\n\t\t\t\tci->i_cap_flush_tid[i] = flush_tid;\n\n\t\tfollows = ci->i_head_snapc->seq;\n\t} else {\n\t\tfollows = 0;\n\t}\n\n\tkeep = cap->implemented;\n\tseq = cap->seq;\n\tissue_seq = cap->issue_seq;\n\tmseq = cap->mseq;\n\tsize = inode->i_size;\n\tci->i_reported_size = size;\n\tmax_size = ci->i_wanted_max_size;\n\tci->i_requested_max_size = max_size;\n\tmtime = inode->i_mtime;\n\tatime = inode->i_atime;\n\ttime_warp_seq = ci->i_time_warp_seq;\n\tuid = inode->i_uid;\n\tgid = inode->i_gid;\n\tmode = inode->i_mode;\n\n\tif (flushing & CEPH_CAP_XATTR_EXCL) {\n\t\t__ceph_build_xattrs_blob(ci);\n\t\txattr_blob = ci->i_xattrs.blob;\n\t\txattr_version = ci->i_xattrs.version;\n\t}\n\n\tinline_data = ci->i_inline_version != CEPH_INLINE_NONE;\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tret = send_cap_msg(session, ceph_vino(inode).ino, cap_id,\n\t\top, keep, want, flushing, seq, flush_tid, issue_seq, mseq,\n\t\tsize, max_size, &mtime, &atime, time_warp_seq,\n\t\tuid, gid, mode, xattr_version, xattr_blob,\n\t\tfollows, inline_data);\n\tif (ret < 0) {\n\t\tdout(\"error sending cap msg, must requeue %p\\n\", inode);\n\t\tdelayed = 1;\n\t}\n\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\n\treturn delayed;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __send_cap(struct ceph_mds_client *mdsc, struct ceph_cap *cap,\n\t\t      int op, int used, int want, int retain, int flushing,\n\t\t      unsigned *pflush_tid)\n\t__releases(cap->ci->i_ceph_lock)\n{\n\tstruct ceph_inode_info *ci = cap->ci;\n\tstruct inode *inode = &ci->vfs_inode;\n\tu64 cap_id = cap->cap_id;\n\tint held, revoking, dropping, keep;\n\tu64 seq, issue_seq, mseq, time_warp_seq, follows;\n\tu64 size, max_size;\n\tstruct timespec mtime, atime;\n\tint wake = 0;\n\tumode_t mode;\n\tkuid_t uid;\n\tkgid_t gid;\n\tstruct ceph_mds_session *session;\n\tu64 xattr_version = 0;\n\tstruct ceph_buffer *xattr_blob = NULL;\n\tint delayed = 0;\n\tu64 flush_tid = 0;\n\tint i;\n\tint ret;\n\tbool inline_data;\n\n\theld = cap->issued | cap->implemented;\n\trevoking = cap->implemented & ~cap->issued;\n\tretain &= ~revoking;\n\tdropping = cap->issued & ~retain;\n\n\tdout(\"__send_cap %p cap %p session %p %s -> %s (revoking %s)\\n\",\n\t     inode, cap, cap->session,\n\t     ceph_cap_string(held), ceph_cap_string(held & retain),\n\t     ceph_cap_string(revoking));\n\tBUG_ON((retain & CEPH_CAP_PIN) == 0);\n\n\tsession = cap->session;\n\n\t/* don't release wanted unless we've waited a bit. */\n\tif ((ci->i_ceph_flags & CEPH_I_NODELAY) == 0 &&\n\t    time_before(jiffies, ci->i_hold_caps_min)) {\n\t\tdout(\" delaying issued %s -> %s, wanted %s -> %s on send\\n\",\n\t\t     ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(cap->issued & retain),\n\t\t     ceph_cap_string(cap->mds_wanted),\n\t\t     ceph_cap_string(want));\n\t\twant |= cap->mds_wanted;\n\t\tretain |= cap->issued;\n\t\tdelayed = 1;\n\t}\n\tci->i_ceph_flags &= ~(CEPH_I_NODELAY | CEPH_I_FLUSH);\n\n\tcap->issued &= retain;  /* drop bits we don't want */\n\tif (cap->implemented & ~cap->issued) {\n\t\t/*\n\t\t * Wake up any waiters on wanted -> needed transition.\n\t\t * This is due to the weird transition from buffered\n\t\t * to sync IO... we need to flush dirty pages _before_\n\t\t * allowing sync writes to avoid reordering.\n\t\t */\n\t\twake = 1;\n\t}\n\tcap->implemented &= cap->issued | used;\n\tcap->mds_wanted = want;\n\n\tif (flushing) {\n\t\t/*\n\t\t * assign a tid for flush operations so we can avoid\n\t\t * flush1 -> dirty1 -> flush2 -> flushack1 -> mark\n\t\t * clean type races.  track latest tid for every bit\n\t\t * so we can handle flush AxFw, flush Fw, and have the\n\t\t * first ack clean Ax.\n\t\t */\n\t\tflush_tid = ++ci->i_cap_flush_last_tid;\n\t\tif (pflush_tid)\n\t\t\t*pflush_tid = flush_tid;\n\t\tdout(\" cap_flush_tid %d\\n\", (int)flush_tid);\n\t\tfor (i = 0; i < CEPH_CAP_BITS; i++)\n\t\t\tif (flushing & (1 << i))\n\t\t\t\tci->i_cap_flush_tid[i] = flush_tid;\n\n\t\tfollows = ci->i_head_snapc->seq;\n\t} else {\n\t\tfollows = 0;\n\t}\n\n\tkeep = cap->implemented;\n\tseq = cap->seq;\n\tissue_seq = cap->issue_seq;\n\tmseq = cap->mseq;\n\tsize = inode->i_size;\n\tci->i_reported_size = size;\n\tmax_size = ci->i_wanted_max_size;\n\tci->i_requested_max_size = max_size;\n\tmtime = inode->i_mtime;\n\tatime = inode->i_atime;\n\ttime_warp_seq = ci->i_time_warp_seq;\n\tuid = inode->i_uid;\n\tgid = inode->i_gid;\n\tmode = inode->i_mode;\n\n\tif (flushing & CEPH_CAP_XATTR_EXCL) {\n\t\t__ceph_build_xattrs_blob(ci);\n\t\txattr_blob = ci->i_xattrs.blob;\n\t\txattr_version = ci->i_xattrs.version;\n\t}\n\n\tinline_data = ci->i_inline_version != CEPH_INLINE_NONE;\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tret = send_cap_msg(session, ceph_vino(inode).ino, cap_id,\n\t\top, keep, want, flushing, seq, flush_tid, issue_seq, mseq,\n\t\tsize, max_size, &mtime, &atime, time_warp_seq,\n\t\tuid, gid, mode, xattr_version, xattr_blob,\n\t\tfollows, inline_data);\n\tif (ret < 0) {\n\t\tdout(\"error sending cap msg, must requeue %p\\n\", inode);\n\t\tdelayed = 1;\n\t}\n\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\n\treturn delayed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_caps_wanted",
          "args": [
            "ci"
          ],
          "line": 1989
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_caps_wanted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "566-572",
          "snippet": "static inline int __ceph_caps_wanted(struct ceph_inode_info *ci)\n{\n\tint w = __ceph_caps_file_wanted(ci) | __ceph_caps_used(ci);\n\tif (w & CEPH_CAP_FILE_BUFFER)\n\t\tw |= CEPH_CAP_FILE_EXCL;  /* we want EXCL if dirty data */\n\treturn w;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline int __ceph_caps_wanted(struct ceph_inode_info *ci)\n{\n\tint w = __ceph_caps_file_wanted(ci) | __ceph_caps_used(ci);\n\tif (w & CEPH_CAP_FILE_BUFFER)\n\t\tw |= CEPH_CAP_FILE_EXCL;  /* we want EXCL if dirty data */\n\treturn w;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_caps_used",
          "args": [
            "ci"
          ],
          "line": 1988
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_caps_used",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "829-843",
          "snippet": "int __ceph_caps_used(struct ceph_inode_info *ci)\n{\n\tint used = 0;\n\tif (ci->i_pin_ref)\n\t\tused |= CEPH_CAP_PIN;\n\tif (ci->i_rd_ref)\n\t\tused |= CEPH_CAP_FILE_RD;\n\tif (ci->i_rdcache_ref || ci->vfs_inode.i_data.nrpages)\n\t\tused |= CEPH_CAP_FILE_CACHE;\n\tif (ci->i_wr_ref)\n\t\tused |= CEPH_CAP_FILE_WR;\n\tif (ci->i_wb_ref || ci->i_wrbuffer_ref)\n\t\tused |= CEPH_CAP_FILE_BUFFER;\n\treturn used;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_caps_used(struct ceph_inode_info *ci)\n{\n\tint used = 0;\n\tif (ci->i_pin_ref)\n\t\tused |= CEPH_CAP_PIN;\n\tif (ci->i_rd_ref)\n\t\tused |= CEPH_CAP_FILE_RD;\n\tif (ci->i_rdcache_ref || ci->vfs_inode.i_data.nrpages)\n\t\tused |= CEPH_CAP_FILE_CACHE;\n\tif (ci->i_wr_ref)\n\t\tused |= CEPH_CAP_FILE_WR;\n\tif (ci->i_wb_ref || ci->i_wrbuffer_ref)\n\t\tused |= CEPH_CAP_FILE_BUFFER;\n\treturn used;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"kick_flushing_caps %p cap %p %s\\n\"",
            "inode",
            "cap",
            "ceph_cap_string(ci->i_flushing_caps)"
          ],
          "line": 1985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_cap_string",
          "args": [
            "ci->i_flushing_caps"
          ],
          "line": 1986
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_cap_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "71-116",
          "snippet": "const char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [
            "#define MAX_CAP_STR 20"
          ],
          "globals_used": [
            "static char cap_str[MAX_CAP_STR][40];",
            "static DEFINE_SPINLOCK(cap_str_lock);",
            "static int last_cap_str;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\n#define MAX_CAP_STR 20\n\nstatic char cap_str[MAX_CAP_STR][40];\nstatic DEFINE_SPINLOCK(cap_str_lock);\nstatic int last_cap_str;\n\nconst char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ci",
            "&session->s_cap_flushing",
            "i_flushing_item"
          ],
          "line": 1977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"kick_flushing_caps mds%d\\n\"",
            "session->s_mds"
          ],
          "line": 1976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kick_flushing_capsnaps",
          "args": [
            "mdsc",
            "session"
          ],
          "line": 1974
        },
        "resolved": true,
        "details": {
          "function_name": "kick_flushing_capsnaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "1943-1967",
          "snippet": "static void kick_flushing_capsnaps(struct ceph_mds_client *mdsc,\n\t\t\t\t   struct ceph_mds_session *session)\n{\n\tstruct ceph_cap_snap *capsnap;\n\n\tdout(\"kick_flushing_capsnaps mds%d\\n\", session->s_mds);\n\tlist_for_each_entry(capsnap, &session->s_cap_snaps_flushing,\n\t\t\t    flushing_item) {\n\t\tstruct ceph_inode_info *ci = capsnap->ci;\n\t\tstruct inode *inode = &ci->vfs_inode;\n\t\tstruct ceph_cap *cap;\n\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tcap = ci->i_auth_cap;\n\t\tif (cap && cap->session == session) {\n\t\t\tdout(\"kick_flushing_caps %p cap %p capsnap %p\\n\", inode,\n\t\t\t     cap, capsnap);\n\t\t\t__ceph_flush_snaps(ci, &session, 1);\n\t\t} else {\n\t\t\tpr_err(\"%p auth cap %p not mds%d ???\\n\", inode,\n\t\t\t       cap, session->s_mds);\n\t\t}\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void kick_flushing_capsnaps(struct ceph_mds_client *mdsc,\n\t\t\t\t   struct ceph_mds_session *session)\n{\n\tstruct ceph_cap_snap *capsnap;\n\n\tdout(\"kick_flushing_capsnaps mds%d\\n\", session->s_mds);\n\tlist_for_each_entry(capsnap, &session->s_cap_snaps_flushing,\n\t\t\t    flushing_item) {\n\t\tstruct ceph_inode_info *ci = capsnap->ci;\n\t\tstruct inode *inode = &ci->vfs_inode;\n\t\tstruct ceph_cap *cap;\n\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tcap = ci->i_auth_cap;\n\t\tif (cap && cap->session == session) {\n\t\t\tdout(\"kick_flushing_caps %p cap %p capsnap %p\\n\", inode,\n\t\t\t     cap, capsnap);\n\t\t\t__ceph_flush_snaps(ci, &session, 1);\n\t\t} else {\n\t\t\tpr_err(\"%p auth cap %p not mds%d ???\\n\", inode,\n\t\t\t       cap, session->s_mds);\n\t\t}\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_kick_flushing_caps(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_mds_session *session)\n{\n\tstruct ceph_inode_info *ci;\n\n\tkick_flushing_capsnaps(mdsc, session);\n\n\tdout(\"kick_flushing_caps mds%d\\n\", session->s_mds);\n\tlist_for_each_entry(ci, &session->s_cap_flushing, i_flushing_item) {\n\t\tstruct inode *inode = &ci->vfs_inode;\n\t\tstruct ceph_cap *cap;\n\t\tint delayed = 0;\n\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tcap = ci->i_auth_cap;\n\t\tif (cap && cap->session == session) {\n\t\t\tdout(\"kick_flushing_caps %p cap %p %s\\n\", inode,\n\t\t\t     cap, ceph_cap_string(ci->i_flushing_caps));\n\t\t\tdelayed = __send_cap(mdsc, cap, CEPH_CAP_OP_FLUSH,\n\t\t\t\t\t     __ceph_caps_used(ci),\n\t\t\t\t\t     __ceph_caps_wanted(ci),\n\t\t\t\t\t     cap->issued | cap->implemented,\n\t\t\t\t\t     ci->i_flushing_caps, NULL);\n\t\t\tif (delayed) {\n\t\t\t\tspin_lock(&ci->i_ceph_lock);\n\t\t\t\t__cap_delay_requeue(mdsc, ci);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t}\n\t\t} else {\n\t\t\tpr_err(\"%p auth cap %p not mds%d ???\\n\", inode,\n\t\t\t       cap, session->s_mds);\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "kick_flushing_capsnaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "1943-1967",
    "snippet": "static void kick_flushing_capsnaps(struct ceph_mds_client *mdsc,\n\t\t\t\t   struct ceph_mds_session *session)\n{\n\tstruct ceph_cap_snap *capsnap;\n\n\tdout(\"kick_flushing_capsnaps mds%d\\n\", session->s_mds);\n\tlist_for_each_entry(capsnap, &session->s_cap_snaps_flushing,\n\t\t\t    flushing_item) {\n\t\tstruct ceph_inode_info *ci = capsnap->ci;\n\t\tstruct inode *inode = &ci->vfs_inode;\n\t\tstruct ceph_cap *cap;\n\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tcap = ci->i_auth_cap;\n\t\tif (cap && cap->session == session) {\n\t\t\tdout(\"kick_flushing_caps %p cap %p capsnap %p\\n\", inode,\n\t\t\t     cap, capsnap);\n\t\t\t__ceph_flush_snaps(ci, &session, 1);\n\t\t} else {\n\t\t\tpr_err(\"%p auth cap %p not mds%d ???\\n\", inode,\n\t\t\t       cap, session->s_mds);\n\t\t}\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t}\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 1965
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%p auth cap %p not mds%d ???\\n\"",
            "inode",
            "cap",
            "session->s_mds"
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ceph_flush_snaps",
          "args": [
            "ci",
            "&session",
            "1"
          ],
          "line": 1960
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_flush_snaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "1257-1375",
          "snippet": "void __ceph_flush_snaps(struct ceph_inode_info *ci,\n\t\t\tstruct ceph_mds_session **psession,\n\t\t\tint again)\n\t\t__releases(ci->i_ceph_lock)\n\t\t__acquires(ci->i_ceph_lock)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint mds;\n\tstruct ceph_cap_snap *capsnap;\n\tu32 mseq;\n\tstruct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;\n\tstruct ceph_mds_session *session = NULL; /* if session != NULL, we hold\n\t\t\t\t\t\t    session->s_mutex */\n\tu64 next_follows = 0;  /* keep track of how far we've gotten through the\n\t\t\t     i_cap_snaps list, and skip these entries next time\n\t\t\t     around to avoid an infinite loop */\n\n\tif (psession)\n\t\tsession = *psession;\n\n\tdout(\"__flush_snaps %p\\n\", inode);\nretry:\n\tlist_for_each_entry(capsnap, &ci->i_cap_snaps, ci_item) {\n\t\t/* avoid an infiniute loop after retry */\n\t\tif (capsnap->follows < next_follows)\n\t\t\tcontinue;\n\t\t/*\n\t\t * we need to wait for sync writes to complete and for dirty\n\t\t * pages to be written out.\n\t\t */\n\t\tif (capsnap->dirty_pages || capsnap->writing)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * if cap writeback already occurred, we should have dropped\n\t\t * the capsnap in ceph_put_wrbuffer_cap_refs.\n\t\t */\n\t\tBUG_ON(capsnap->dirty == 0);\n\n\t\t/* pick mds, take s_mutex */\n\t\tif (ci->i_auth_cap == NULL) {\n\t\t\tdout(\"no auth cap (migrating?), doing nothing\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* only flush each capsnap once */\n\t\tif (!again && !list_empty(&capsnap->flushing_item)) {\n\t\t\tdout(\"already flushed %p, skipping\\n\", capsnap);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmds = ci->i_auth_cap->session->s_mds;\n\t\tmseq = ci->i_auth_cap->mseq;\n\n\t\tif (session && session->s_mds != mds) {\n\t\t\tdout(\"oops, wrong session %p mutex\\n\", session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tceph_put_mds_session(session);\n\t\t\tsession = NULL;\n\t\t}\n\t\tif (!session) {\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\tmutex_lock(&mdsc->mutex);\n\t\t\tsession = __ceph_lookup_mds_session(mdsc, mds);\n\t\t\tmutex_unlock(&mdsc->mutex);\n\t\t\tif (session) {\n\t\t\t\tdout(\"inverting session/ino locks on %p\\n\",\n\t\t\t\t     session);\n\t\t\t\tmutex_lock(&session->s_mutex);\n\t\t\t}\n\t\t\t/*\n\t\t\t * if session == NULL, we raced against a cap\n\t\t\t * deletion or migration.  retry, and we'll\n\t\t\t * get a better @mds value next time.\n\t\t\t */\n\t\t\tspin_lock(&ci->i_ceph_lock);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tcapsnap->flush_tid = ++ci->i_cap_flush_last_tid;\n\t\tatomic_inc(&capsnap->nref);\n\t\tif (!list_empty(&capsnap->flushing_item))\n\t\t\tlist_del_init(&capsnap->flushing_item);\n\t\tlist_add_tail(&capsnap->flushing_item,\n\t\t\t      &session->s_cap_snaps_flushing);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\n\t\tdout(\"flush_snaps %p cap_snap %p follows %lld tid %llu\\n\",\n\t\t     inode, capsnap, capsnap->follows, capsnap->flush_tid);\n\t\tsend_cap_msg(session, ceph_vino(inode).ino, 0,\n\t\t\t     CEPH_CAP_OP_FLUSHSNAP, capsnap->issued, 0,\n\t\t\t     capsnap->dirty, 0, capsnap->flush_tid, 0, mseq,\n\t\t\t     capsnap->size, 0,\n\t\t\t     &capsnap->mtime, &capsnap->atime,\n\t\t\t     capsnap->time_warp_seq,\n\t\t\t     capsnap->uid, capsnap->gid, capsnap->mode,\n\t\t\t     capsnap->xattr_version, capsnap->xattr_blob,\n\t\t\t     capsnap->follows, capsnap->inline_data);\n\n\t\tnext_follows = capsnap->follows + 1;\n\t\tceph_put_cap_snap(capsnap);\n\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tgoto retry;\n\t}\n\n\t/* we flushed them all; remove this inode from the queue */\n\tspin_lock(&mdsc->snap_flush_lock);\n\tlist_del_init(&ci->i_snap_flush_item);\n\tspin_unlock(&mdsc->snap_flush_lock);\n\nout:\n\tif (psession)\n\t\t*psession = session;\n\telse if (session) {\n\t\tmutex_unlock(&session->s_mutex);\n\t\tceph_put_mds_session(session);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid __ceph_flush_snaps(struct ceph_inode_info *ci,\n\t\t\tstruct ceph_mds_session **psession,\n\t\t\tint again)\n\t\t__releases(ci->i_ceph_lock)\n\t\t__acquires(ci->i_ceph_lock)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint mds;\n\tstruct ceph_cap_snap *capsnap;\n\tu32 mseq;\n\tstruct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;\n\tstruct ceph_mds_session *session = NULL; /* if session != NULL, we hold\n\t\t\t\t\t\t    session->s_mutex */\n\tu64 next_follows = 0;  /* keep track of how far we've gotten through the\n\t\t\t     i_cap_snaps list, and skip these entries next time\n\t\t\t     around to avoid an infinite loop */\n\n\tif (psession)\n\t\tsession = *psession;\n\n\tdout(\"__flush_snaps %p\\n\", inode);\nretry:\n\tlist_for_each_entry(capsnap, &ci->i_cap_snaps, ci_item) {\n\t\t/* avoid an infiniute loop after retry */\n\t\tif (capsnap->follows < next_follows)\n\t\t\tcontinue;\n\t\t/*\n\t\t * we need to wait for sync writes to complete and for dirty\n\t\t * pages to be written out.\n\t\t */\n\t\tif (capsnap->dirty_pages || capsnap->writing)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * if cap writeback already occurred, we should have dropped\n\t\t * the capsnap in ceph_put_wrbuffer_cap_refs.\n\t\t */\n\t\tBUG_ON(capsnap->dirty == 0);\n\n\t\t/* pick mds, take s_mutex */\n\t\tif (ci->i_auth_cap == NULL) {\n\t\t\tdout(\"no auth cap (migrating?), doing nothing\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* only flush each capsnap once */\n\t\tif (!again && !list_empty(&capsnap->flushing_item)) {\n\t\t\tdout(\"already flushed %p, skipping\\n\", capsnap);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmds = ci->i_auth_cap->session->s_mds;\n\t\tmseq = ci->i_auth_cap->mseq;\n\n\t\tif (session && session->s_mds != mds) {\n\t\t\tdout(\"oops, wrong session %p mutex\\n\", session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tceph_put_mds_session(session);\n\t\t\tsession = NULL;\n\t\t}\n\t\tif (!session) {\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\tmutex_lock(&mdsc->mutex);\n\t\t\tsession = __ceph_lookup_mds_session(mdsc, mds);\n\t\t\tmutex_unlock(&mdsc->mutex);\n\t\t\tif (session) {\n\t\t\t\tdout(\"inverting session/ino locks on %p\\n\",\n\t\t\t\t     session);\n\t\t\t\tmutex_lock(&session->s_mutex);\n\t\t\t}\n\t\t\t/*\n\t\t\t * if session == NULL, we raced against a cap\n\t\t\t * deletion or migration.  retry, and we'll\n\t\t\t * get a better @mds value next time.\n\t\t\t */\n\t\t\tspin_lock(&ci->i_ceph_lock);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tcapsnap->flush_tid = ++ci->i_cap_flush_last_tid;\n\t\tatomic_inc(&capsnap->nref);\n\t\tif (!list_empty(&capsnap->flushing_item))\n\t\t\tlist_del_init(&capsnap->flushing_item);\n\t\tlist_add_tail(&capsnap->flushing_item,\n\t\t\t      &session->s_cap_snaps_flushing);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\n\t\tdout(\"flush_snaps %p cap_snap %p follows %lld tid %llu\\n\",\n\t\t     inode, capsnap, capsnap->follows, capsnap->flush_tid);\n\t\tsend_cap_msg(session, ceph_vino(inode).ino, 0,\n\t\t\t     CEPH_CAP_OP_FLUSHSNAP, capsnap->issued, 0,\n\t\t\t     capsnap->dirty, 0, capsnap->flush_tid, 0, mseq,\n\t\t\t     capsnap->size, 0,\n\t\t\t     &capsnap->mtime, &capsnap->atime,\n\t\t\t     capsnap->time_warp_seq,\n\t\t\t     capsnap->uid, capsnap->gid, capsnap->mode,\n\t\t\t     capsnap->xattr_version, capsnap->xattr_blob,\n\t\t\t     capsnap->follows, capsnap->inline_data);\n\n\t\tnext_follows = capsnap->follows + 1;\n\t\tceph_put_cap_snap(capsnap);\n\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tgoto retry;\n\t}\n\n\t/* we flushed them all; remove this inode from the queue */\n\tspin_lock(&mdsc->snap_flush_lock);\n\tlist_del_init(&ci->i_snap_flush_item);\n\tspin_unlock(&mdsc->snap_flush_lock);\n\nout:\n\tif (psession)\n\t\t*psession = session;\n\telse if (session) {\n\t\tmutex_unlock(&session->s_mutex);\n\t\tceph_put_mds_session(session);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"kick_flushing_caps %p cap %p capsnap %p\\n\"",
            "inode",
            "cap",
            "capsnap"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 1955
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "capsnap",
            "&session->s_cap_snaps_flushing",
            "flushing_item"
          ],
          "line": 1949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"kick_flushing_capsnaps mds%d\\n\"",
            "session->s_mds"
          ],
          "line": 1948
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void kick_flushing_capsnaps(struct ceph_mds_client *mdsc,\n\t\t\t\t   struct ceph_mds_session *session)\n{\n\tstruct ceph_cap_snap *capsnap;\n\n\tdout(\"kick_flushing_capsnaps mds%d\\n\", session->s_mds);\n\tlist_for_each_entry(capsnap, &session->s_cap_snaps_flushing,\n\t\t\t    flushing_item) {\n\t\tstruct ceph_inode_info *ci = capsnap->ci;\n\t\tstruct inode *inode = &ci->vfs_inode;\n\t\tstruct ceph_cap *cap;\n\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tcap = ci->i_auth_cap;\n\t\tif (cap && cap->session == session) {\n\t\t\tdout(\"kick_flushing_caps %p cap %p capsnap %p\\n\", inode,\n\t\t\t     cap, capsnap);\n\t\t\t__ceph_flush_snaps(ci, &session, 1);\n\t\t} else {\n\t\t\tpr_err(\"%p auth cap %p not mds%d ???\\n\", inode,\n\t\t\t       cap, session->s_mds);\n\t\t}\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t}\n}"
  },
  {
    "function_name": "ceph_write_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "1911-1935",
    "snippet": "int ceph_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tunsigned flush_tid;\n\tint err = 0;\n\tint dirty;\n\tint wait = wbc->sync_mode == WB_SYNC_ALL;\n\n\tdout(\"write_inode %p wait=%d\\n\", inode, wait);\n\tif (wait) {\n\t\tdirty = try_flush_caps(inode, &flush_tid);\n\t\tif (dirty)\n\t\t\terr = wait_event_interruptible(ci->i_cap_wq,\n\t\t\t\t       caps_are_flushed(inode, flush_tid));\n\t} else {\n\t\tstruct ceph_mds_client *mdsc =\n\t\t\tceph_sb_to_client(inode->i_sb)->mdsc;\n\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tif (__ceph_caps_dirty(ci))\n\t\t\t__cap_delay_requeue_front(mdsc, ci);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 1932
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__cap_delay_requeue_front",
          "args": [
            "mdsc",
            "ci"
          ],
          "line": 1931
        },
        "resolved": true,
        "details": {
          "function_name": "__cap_delay_requeue_front",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "442-452",
          "snippet": "static void __cap_delay_requeue_front(struct ceph_mds_client *mdsc,\n\t\t\t\t      struct ceph_inode_info *ci)\n{\n\tdout(\"__cap_delay_requeue_front %p\\n\", &ci->vfs_inode);\n\tspin_lock(&mdsc->cap_delay_lock);\n\tci->i_ceph_flags |= CEPH_I_FLUSH;\n\tif (!list_empty(&ci->i_cap_delay_list))\n\t\tlist_del_init(&ci->i_cap_delay_list);\n\tlist_add(&ci->i_cap_delay_list, &mdsc->cap_delay_list);\n\tspin_unlock(&mdsc->cap_delay_lock);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __cap_delay_requeue_front(struct ceph_mds_client *mdsc,\n\t\t\t\t      struct ceph_inode_info *ci)\n{\n\tdout(\"__cap_delay_requeue_front %p\\n\", &ci->vfs_inode);\n\tspin_lock(&mdsc->cap_delay_lock);\n\tci->i_ceph_flags |= CEPH_I_FLUSH;\n\tif (!list_empty(&ci->i_cap_delay_list))\n\t\tlist_del_init(&ci->i_cap_delay_list);\n\tlist_add(&ci->i_cap_delay_list, &mdsc->cap_delay_list);\n\tspin_unlock(&mdsc->cap_delay_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_caps_dirty",
          "args": [
            "ci"
          ],
          "line": 1930
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_caps_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "550-553",
          "snippet": "static inline int __ceph_caps_dirty(struct ceph_inode_info *ci)\n{\n\treturn ci->i_dirty_caps | ci->i_flushing_caps;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline int __ceph_caps_dirty(struct ceph_inode_info *ci)\n{\n\treturn ci->i_dirty_caps | ci->i_flushing_caps;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 1929
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_sb_to_client",
          "args": [
            "inode->i_sb"
          ],
          "line": 1927
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_sb_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "352-355",
          "snippet": "static inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible",
          "args": [
            "ci->i_cap_wq",
            "caps_are_flushed(inode, flush_tid)"
          ],
          "line": 1923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "caps_are_flushed",
          "args": [
            "inode",
            "flush_tid"
          ],
          "line": 1924
        },
        "resolved": true,
        "details": {
          "function_name": "caps_are_flushed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "1809-1824",
          "snippet": "static int caps_are_flushed(struct inode *inode, unsigned tid)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint i, ret = 1;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tfor (i = 0; i < CEPH_CAP_BITS; i++)\n\t\tif ((ci->i_flushing_caps & (1 << i)) &&\n\t\t    ci->i_cap_flush_tid[i] <= tid) {\n\t\t\t/* still flushing this bit */\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int caps_are_flushed(struct inode *inode, unsigned tid)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint i, ret = 1;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tfor (i = 0; i < CEPH_CAP_BITS; i++)\n\t\tif ((ci->i_flushing_caps & (1 << i)) &&\n\t\t    ci->i_cap_flush_tid[i] <= tid) {\n\t\t\t/* still flushing this bit */\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_flush_caps",
          "args": [
            "inode",
            "&flush_tid"
          ],
          "line": 1921
        },
        "resolved": true,
        "details": {
          "function_name": "try_flush_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "1756-1804",
          "snippet": "static int try_flush_caps(struct inode *inode, unsigned *flush_tid)\n{\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint flushing = 0;\n\tstruct ceph_mds_session *session = NULL;\n\nretry:\n\tspin_lock(&ci->i_ceph_lock);\n\tif (ci->i_ceph_flags & CEPH_I_NOFLUSH) {\n\t\tdout(\"try_flush_caps skipping %p I_NOFLUSH set\\n\", inode);\n\t\tgoto out;\n\t}\n\tif (ci->i_dirty_caps && ci->i_auth_cap) {\n\t\tstruct ceph_cap *cap = ci->i_auth_cap;\n\t\tint used = __ceph_caps_used(ci);\n\t\tint want = __ceph_caps_wanted(ci);\n\t\tint delayed;\n\n\t\tif (!session || session != cap->session) {\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\tif (session)\n\t\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tsession = cap->session;\n\t\t\tmutex_lock(&session->s_mutex);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (cap->session->s_state < CEPH_MDS_SESSION_OPEN)\n\t\t\tgoto out;\n\n\t\tflushing = __mark_caps_flushing(inode, session);\n\n\t\t/* __send_cap drops i_ceph_lock */\n\t\tdelayed = __send_cap(mdsc, cap, CEPH_CAP_OP_FLUSH, used, want,\n\t\t\t\t     cap->issued | cap->implemented, flushing,\n\t\t\t\t     flush_tid);\n\t\tif (!delayed)\n\t\t\tgoto out_unlocked;\n\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\t__cap_delay_requeue(mdsc, ci);\n\t}\nout:\n\tspin_unlock(&ci->i_ceph_lock);\nout_unlocked:\n\tif (session)\n\t\tmutex_unlock(&session->s_mutex);\n\treturn flushing;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int try_flush_caps(struct inode *inode, unsigned *flush_tid)\n{\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint flushing = 0;\n\tstruct ceph_mds_session *session = NULL;\n\nretry:\n\tspin_lock(&ci->i_ceph_lock);\n\tif (ci->i_ceph_flags & CEPH_I_NOFLUSH) {\n\t\tdout(\"try_flush_caps skipping %p I_NOFLUSH set\\n\", inode);\n\t\tgoto out;\n\t}\n\tif (ci->i_dirty_caps && ci->i_auth_cap) {\n\t\tstruct ceph_cap *cap = ci->i_auth_cap;\n\t\tint used = __ceph_caps_used(ci);\n\t\tint want = __ceph_caps_wanted(ci);\n\t\tint delayed;\n\n\t\tif (!session || session != cap->session) {\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\tif (session)\n\t\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tsession = cap->session;\n\t\t\tmutex_lock(&session->s_mutex);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (cap->session->s_state < CEPH_MDS_SESSION_OPEN)\n\t\t\tgoto out;\n\n\t\tflushing = __mark_caps_flushing(inode, session);\n\n\t\t/* __send_cap drops i_ceph_lock */\n\t\tdelayed = __send_cap(mdsc, cap, CEPH_CAP_OP_FLUSH, used, want,\n\t\t\t\t     cap->issued | cap->implemented, flushing,\n\t\t\t\t     flush_tid);\n\t\tif (!delayed)\n\t\t\tgoto out_unlocked;\n\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\t__cap_delay_requeue(mdsc, ci);\n\t}\nout:\n\tspin_unlock(&ci->i_ceph_lock);\nout_unlocked:\n\tif (session)\n\t\tmutex_unlock(&session->s_mutex);\n\treturn flushing;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"write_inode %p wait=%d\\n\"",
            "inode",
            "wait"
          ],
          "line": 1919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 1913
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tunsigned flush_tid;\n\tint err = 0;\n\tint dirty;\n\tint wait = wbc->sync_mode == WB_SYNC_ALL;\n\n\tdout(\"write_inode %p wait=%d\\n\", inode, wait);\n\tif (wait) {\n\t\tdirty = try_flush_caps(inode, &flush_tid);\n\t\tif (dirty)\n\t\t\terr = wait_event_interruptible(ci->i_cap_wq,\n\t\t\t\t       caps_are_flushed(inode, flush_tid));\n\t} else {\n\t\tstruct ceph_mds_client *mdsc =\n\t\t\tceph_sb_to_client(inode->i_sb)->mdsc;\n\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tif (__ceph_caps_dirty(ci))\n\t\t\t__cap_delay_requeue_front(mdsc, ci);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "ceph_fsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "1870-1903",
    "snippet": "int ceph_fsync(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tunsigned flush_tid;\n\tint ret;\n\tint dirty;\n\n\tdout(\"fsync %p%s\\n\", inode, datasync ? \" datasync\" : \"\");\n\tsync_write_wait(inode);\n\n\tret = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\tif (ret < 0)\n\t\treturn ret;\n\tmutex_lock(&inode->i_mutex);\n\n\tdirty = try_flush_caps(inode, &flush_tid);\n\tdout(\"fsync dirty caps are %s\\n\", ceph_cap_string(dirty));\n\n\t/*\n\t * only wait on non-file metadata writeback (the mds\n\t * can recover size and mtime, so we don't need to\n\t * wait for that)\n\t */\n\tif (!datasync && (dirty & ~CEPH_CAP_ANY_FILE_WR)) {\n\t\tdout(\"fsync waiting for flush_tid %u\\n\", flush_tid);\n\t\tret = wait_event_interruptible(ci->i_cap_wq,\n\t\t\t\t       caps_are_flushed(inode, flush_tid));\n\t}\n\n\tdout(\"fsync %p%s done\\n\", inode, datasync ? \" datasync\" : \"\");\n\tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 1901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"fsync %p%s done\\n\"",
            "inode",
            "datasync ? \" datasync\" : \"\""
          ],
          "line": 1900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible",
          "args": [
            "ci->i_cap_wq",
            "caps_are_flushed(inode, flush_tid)"
          ],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "caps_are_flushed",
          "args": [
            "inode",
            "flush_tid"
          ],
          "line": 1897
        },
        "resolved": true,
        "details": {
          "function_name": "caps_are_flushed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "1809-1824",
          "snippet": "static int caps_are_flushed(struct inode *inode, unsigned tid)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint i, ret = 1;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tfor (i = 0; i < CEPH_CAP_BITS; i++)\n\t\tif ((ci->i_flushing_caps & (1 << i)) &&\n\t\t    ci->i_cap_flush_tid[i] <= tid) {\n\t\t\t/* still flushing this bit */\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int caps_are_flushed(struct inode *inode, unsigned tid)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint i, ret = 1;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tfor (i = 0; i < CEPH_CAP_BITS; i++)\n\t\tif ((ci->i_flushing_caps & (1 << i)) &&\n\t\t    ci->i_cap_flush_tid[i] <= tid) {\n\t\t\t/* still flushing this bit */\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"fsync waiting for flush_tid %u\\n\"",
            "flush_tid"
          ],
          "line": 1895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"fsync dirty caps are %s\\n\"",
            "ceph_cap_string(dirty)"
          ],
          "line": 1887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_cap_string",
          "args": [
            "dirty"
          ],
          "line": 1887
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_cap_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "71-116",
          "snippet": "const char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [
            "#define MAX_CAP_STR 20"
          ],
          "globals_used": [
            "static char cap_str[MAX_CAP_STR][40];",
            "static DEFINE_SPINLOCK(cap_str_lock);",
            "static int last_cap_str;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\n#define MAX_CAP_STR 20\n\nstatic char cap_str[MAX_CAP_STR][40];\nstatic DEFINE_SPINLOCK(cap_str_lock);\nstatic int last_cap_str;\n\nconst char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_flush_caps",
          "args": [
            "inode",
            "&flush_tid"
          ],
          "line": 1886
        },
        "resolved": true,
        "details": {
          "function_name": "try_flush_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "1756-1804",
          "snippet": "static int try_flush_caps(struct inode *inode, unsigned *flush_tid)\n{\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint flushing = 0;\n\tstruct ceph_mds_session *session = NULL;\n\nretry:\n\tspin_lock(&ci->i_ceph_lock);\n\tif (ci->i_ceph_flags & CEPH_I_NOFLUSH) {\n\t\tdout(\"try_flush_caps skipping %p I_NOFLUSH set\\n\", inode);\n\t\tgoto out;\n\t}\n\tif (ci->i_dirty_caps && ci->i_auth_cap) {\n\t\tstruct ceph_cap *cap = ci->i_auth_cap;\n\t\tint used = __ceph_caps_used(ci);\n\t\tint want = __ceph_caps_wanted(ci);\n\t\tint delayed;\n\n\t\tif (!session || session != cap->session) {\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\tif (session)\n\t\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tsession = cap->session;\n\t\t\tmutex_lock(&session->s_mutex);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (cap->session->s_state < CEPH_MDS_SESSION_OPEN)\n\t\t\tgoto out;\n\n\t\tflushing = __mark_caps_flushing(inode, session);\n\n\t\t/* __send_cap drops i_ceph_lock */\n\t\tdelayed = __send_cap(mdsc, cap, CEPH_CAP_OP_FLUSH, used, want,\n\t\t\t\t     cap->issued | cap->implemented, flushing,\n\t\t\t\t     flush_tid);\n\t\tif (!delayed)\n\t\t\tgoto out_unlocked;\n\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\t__cap_delay_requeue(mdsc, ci);\n\t}\nout:\n\tspin_unlock(&ci->i_ceph_lock);\nout_unlocked:\n\tif (session)\n\t\tmutex_unlock(&session->s_mutex);\n\treturn flushing;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int try_flush_caps(struct inode *inode, unsigned *flush_tid)\n{\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint flushing = 0;\n\tstruct ceph_mds_session *session = NULL;\n\nretry:\n\tspin_lock(&ci->i_ceph_lock);\n\tif (ci->i_ceph_flags & CEPH_I_NOFLUSH) {\n\t\tdout(\"try_flush_caps skipping %p I_NOFLUSH set\\n\", inode);\n\t\tgoto out;\n\t}\n\tif (ci->i_dirty_caps && ci->i_auth_cap) {\n\t\tstruct ceph_cap *cap = ci->i_auth_cap;\n\t\tint used = __ceph_caps_used(ci);\n\t\tint want = __ceph_caps_wanted(ci);\n\t\tint delayed;\n\n\t\tif (!session || session != cap->session) {\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\tif (session)\n\t\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tsession = cap->session;\n\t\t\tmutex_lock(&session->s_mutex);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (cap->session->s_state < CEPH_MDS_SESSION_OPEN)\n\t\t\tgoto out;\n\n\t\tflushing = __mark_caps_flushing(inode, session);\n\n\t\t/* __send_cap drops i_ceph_lock */\n\t\tdelayed = __send_cap(mdsc, cap, CEPH_CAP_OP_FLUSH, used, want,\n\t\t\t\t     cap->issued | cap->implemented, flushing,\n\t\t\t\t     flush_tid);\n\t\tif (!delayed)\n\t\t\tgoto out_unlocked;\n\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\t__cap_delay_requeue(mdsc, ci);\n\t}\nout:\n\tspin_unlock(&ci->i_ceph_lock);\nout_unlocked:\n\tif (session)\n\t\tmutex_unlock(&session->s_mutex);\n\treturn flushing;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 1884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait_range",
          "args": [
            "inode->i_mapping",
            "start",
            "end"
          ],
          "line": 1881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_write_wait",
          "args": [
            "inode"
          ],
          "line": 1879
        },
        "resolved": true,
        "details": {
          "function_name": "sync_write_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "1832-1868",
          "snippet": "static void sync_write_wait(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct list_head *head = &ci->i_unsafe_writes;\n\tstruct ceph_osd_request *req;\n\tu64 last_tid;\n\n\tspin_lock(&ci->i_unsafe_lock);\n\tif (list_empty(head))\n\t\tgoto out;\n\n\t/* set upper bound as _last_ entry in chain */\n\treq = list_entry(head->prev, struct ceph_osd_request,\n\t\t\t r_unsafe_item);\n\tlast_tid = req->r_tid;\n\n\tdo {\n\t\tceph_osdc_get_request(req);\n\t\tspin_unlock(&ci->i_unsafe_lock);\n\t\tdout(\"sync_write_wait on tid %llu (until %llu)\\n\",\n\t\t     req->r_tid, last_tid);\n\t\twait_for_completion(&req->r_safe_completion);\n\t\tspin_lock(&ci->i_unsafe_lock);\n\t\tceph_osdc_put_request(req);\n\n\t\t/*\n\t\t * from here on look at first entry in chain, since we\n\t\t * only want to wait for anything older than last_tid\n\t\t */\n\t\tif (list_empty(head))\n\t\t\tbreak;\n\t\treq = list_entry(head->next, struct ceph_osd_request,\n\t\t\t\t r_unsafe_item);\n\t} while (req->r_tid < last_tid);\nout:\n\tspin_unlock(&ci->i_unsafe_lock);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void sync_write_wait(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct list_head *head = &ci->i_unsafe_writes;\n\tstruct ceph_osd_request *req;\n\tu64 last_tid;\n\n\tspin_lock(&ci->i_unsafe_lock);\n\tif (list_empty(head))\n\t\tgoto out;\n\n\t/* set upper bound as _last_ entry in chain */\n\treq = list_entry(head->prev, struct ceph_osd_request,\n\t\t\t r_unsafe_item);\n\tlast_tid = req->r_tid;\n\n\tdo {\n\t\tceph_osdc_get_request(req);\n\t\tspin_unlock(&ci->i_unsafe_lock);\n\t\tdout(\"sync_write_wait on tid %llu (until %llu)\\n\",\n\t\t     req->r_tid, last_tid);\n\t\twait_for_completion(&req->r_safe_completion);\n\t\tspin_lock(&ci->i_unsafe_lock);\n\t\tceph_osdc_put_request(req);\n\n\t\t/*\n\t\t * from here on look at first entry in chain, since we\n\t\t * only want to wait for anything older than last_tid\n\t\t */\n\t\tif (list_empty(head))\n\t\t\tbreak;\n\t\treq = list_entry(head->next, struct ceph_osd_request,\n\t\t\t\t r_unsafe_item);\n\t} while (req->r_tid < last_tid);\nout:\n\tspin_unlock(&ci->i_unsafe_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"fsync %p%s\\n\"",
            "inode",
            "datasync ? \" datasync\" : \"\""
          ],
          "line": 1878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 1873
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_fsync(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tunsigned flush_tid;\n\tint ret;\n\tint dirty;\n\n\tdout(\"fsync %p%s\\n\", inode, datasync ? \" datasync\" : \"\");\n\tsync_write_wait(inode);\n\n\tret = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\tif (ret < 0)\n\t\treturn ret;\n\tmutex_lock(&inode->i_mutex);\n\n\tdirty = try_flush_caps(inode, &flush_tid);\n\tdout(\"fsync dirty caps are %s\\n\", ceph_cap_string(dirty));\n\n\t/*\n\t * only wait on non-file metadata writeback (the mds\n\t * can recover size and mtime, so we don't need to\n\t * wait for that)\n\t */\n\tif (!datasync && (dirty & ~CEPH_CAP_ANY_FILE_WR)) {\n\t\tdout(\"fsync waiting for flush_tid %u\\n\", flush_tid);\n\t\tret = wait_event_interruptible(ci->i_cap_wq,\n\t\t\t\t       caps_are_flushed(inode, flush_tid));\n\t}\n\n\tdout(\"fsync %p%s done\\n\", inode, datasync ? \" datasync\" : \"\");\n\tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "sync_write_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "1832-1868",
    "snippet": "static void sync_write_wait(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct list_head *head = &ci->i_unsafe_writes;\n\tstruct ceph_osd_request *req;\n\tu64 last_tid;\n\n\tspin_lock(&ci->i_unsafe_lock);\n\tif (list_empty(head))\n\t\tgoto out;\n\n\t/* set upper bound as _last_ entry in chain */\n\treq = list_entry(head->prev, struct ceph_osd_request,\n\t\t\t r_unsafe_item);\n\tlast_tid = req->r_tid;\n\n\tdo {\n\t\tceph_osdc_get_request(req);\n\t\tspin_unlock(&ci->i_unsafe_lock);\n\t\tdout(\"sync_write_wait on tid %llu (until %llu)\\n\",\n\t\t     req->r_tid, last_tid);\n\t\twait_for_completion(&req->r_safe_completion);\n\t\tspin_lock(&ci->i_unsafe_lock);\n\t\tceph_osdc_put_request(req);\n\n\t\t/*\n\t\t * from here on look at first entry in chain, since we\n\t\t * only want to wait for anything older than last_tid\n\t\t */\n\t\tif (list_empty(head))\n\t\t\tbreak;\n\t\treq = list_entry(head->next, struct ceph_osd_request,\n\t\t\t\t r_unsafe_item);\n\t} while (req->r_tid < last_tid);\nout:\n\tspin_unlock(&ci->i_unsafe_lock);\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_unsafe_lock"
          ],
          "line": 1867
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "head->next",
            "structceph_osd_request",
            "r_unsafe_item"
          ],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "head"
          ],
          "line": 1861
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_osdc_put_request",
          "args": [
            "req"
          ],
          "line": 1855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_unsafe_lock"
          ],
          "line": 1854
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&req->r_safe_completion"
          ],
          "line": 1853
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_wait_for_completion_rpc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "1116-1122",
          "snippet": "static int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nstatic int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"sync_write_wait on tid %llu (until %llu)\\n\"",
            "req->r_tid",
            "last_tid"
          ],
          "line": 1851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_osdc_get_request",
          "args": [
            "req"
          ],
          "line": 1849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "head->prev",
            "structceph_osd_request",
            "r_unsafe_item"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 1834
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void sync_write_wait(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct list_head *head = &ci->i_unsafe_writes;\n\tstruct ceph_osd_request *req;\n\tu64 last_tid;\n\n\tspin_lock(&ci->i_unsafe_lock);\n\tif (list_empty(head))\n\t\tgoto out;\n\n\t/* set upper bound as _last_ entry in chain */\n\treq = list_entry(head->prev, struct ceph_osd_request,\n\t\t\t r_unsafe_item);\n\tlast_tid = req->r_tid;\n\n\tdo {\n\t\tceph_osdc_get_request(req);\n\t\tspin_unlock(&ci->i_unsafe_lock);\n\t\tdout(\"sync_write_wait on tid %llu (until %llu)\\n\",\n\t\t     req->r_tid, last_tid);\n\t\twait_for_completion(&req->r_safe_completion);\n\t\tspin_lock(&ci->i_unsafe_lock);\n\t\tceph_osdc_put_request(req);\n\n\t\t/*\n\t\t * from here on look at first entry in chain, since we\n\t\t * only want to wait for anything older than last_tid\n\t\t */\n\t\tif (list_empty(head))\n\t\t\tbreak;\n\t\treq = list_entry(head->next, struct ceph_osd_request,\n\t\t\t\t r_unsafe_item);\n\t} while (req->r_tid < last_tid);\nout:\n\tspin_unlock(&ci->i_unsafe_lock);\n}"
  },
  {
    "function_name": "caps_are_flushed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "1809-1824",
    "snippet": "static int caps_are_flushed(struct inode *inode, unsigned tid)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint i, ret = 1;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tfor (i = 0; i < CEPH_CAP_BITS; i++)\n\t\tif ((ci->i_flushing_caps & (1 << i)) &&\n\t\t    ci->i_cap_flush_tid[i] <= tid) {\n\t\t\t/* still flushing this bit */\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 1822
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 1814
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 1811
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int caps_are_flushed(struct inode *inode, unsigned tid)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint i, ret = 1;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tfor (i = 0; i < CEPH_CAP_BITS; i++)\n\t\tif ((ci->i_flushing_caps & (1 << i)) &&\n\t\t    ci->i_cap_flush_tid[i] <= tid) {\n\t\t\t/* still flushing this bit */\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "try_flush_caps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "1756-1804",
    "snippet": "static int try_flush_caps(struct inode *inode, unsigned *flush_tid)\n{\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint flushing = 0;\n\tstruct ceph_mds_session *session = NULL;\n\nretry:\n\tspin_lock(&ci->i_ceph_lock);\n\tif (ci->i_ceph_flags & CEPH_I_NOFLUSH) {\n\t\tdout(\"try_flush_caps skipping %p I_NOFLUSH set\\n\", inode);\n\t\tgoto out;\n\t}\n\tif (ci->i_dirty_caps && ci->i_auth_cap) {\n\t\tstruct ceph_cap *cap = ci->i_auth_cap;\n\t\tint used = __ceph_caps_used(ci);\n\t\tint want = __ceph_caps_wanted(ci);\n\t\tint delayed;\n\n\t\tif (!session || session != cap->session) {\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\tif (session)\n\t\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tsession = cap->session;\n\t\t\tmutex_lock(&session->s_mutex);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (cap->session->s_state < CEPH_MDS_SESSION_OPEN)\n\t\t\tgoto out;\n\n\t\tflushing = __mark_caps_flushing(inode, session);\n\n\t\t/* __send_cap drops i_ceph_lock */\n\t\tdelayed = __send_cap(mdsc, cap, CEPH_CAP_OP_FLUSH, used, want,\n\t\t\t\t     cap->issued | cap->implemented, flushing,\n\t\t\t\t     flush_tid);\n\t\tif (!delayed)\n\t\t\tgoto out_unlocked;\n\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\t__cap_delay_requeue(mdsc, ci);\n\t}\nout:\n\tspin_unlock(&ci->i_ceph_lock);\nout_unlocked:\n\tif (session)\n\t\tmutex_unlock(&session->s_mutex);\n\treturn flushing;\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&session->s_mutex"
          ],
          "line": 1802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 1799
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__cap_delay_requeue",
          "args": [
            "mdsc",
            "ci"
          ],
          "line": 1796
        },
        "resolved": true,
        "details": {
          "function_name": "__cap_delay_requeue_front",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "442-452",
          "snippet": "static void __cap_delay_requeue_front(struct ceph_mds_client *mdsc,\n\t\t\t\t      struct ceph_inode_info *ci)\n{\n\tdout(\"__cap_delay_requeue_front %p\\n\", &ci->vfs_inode);\n\tspin_lock(&mdsc->cap_delay_lock);\n\tci->i_ceph_flags |= CEPH_I_FLUSH;\n\tif (!list_empty(&ci->i_cap_delay_list))\n\t\tlist_del_init(&ci->i_cap_delay_list);\n\tlist_add(&ci->i_cap_delay_list, &mdsc->cap_delay_list);\n\tspin_unlock(&mdsc->cap_delay_lock);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __cap_delay_requeue_front(struct ceph_mds_client *mdsc,\n\t\t\t\t      struct ceph_inode_info *ci)\n{\n\tdout(\"__cap_delay_requeue_front %p\\n\", &ci->vfs_inode);\n\tspin_lock(&mdsc->cap_delay_lock);\n\tci->i_ceph_flags |= CEPH_I_FLUSH;\n\tif (!list_empty(&ci->i_cap_delay_list))\n\t\tlist_del_init(&ci->i_cap_delay_list);\n\tlist_add(&ci->i_cap_delay_list, &mdsc->cap_delay_list);\n\tspin_unlock(&mdsc->cap_delay_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 1795
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__send_cap",
          "args": [
            "mdsc",
            "cap",
            "CEPH_CAP_OP_FLUSH",
            "used",
            "want",
            "cap->issued | cap->implemented",
            "flushing",
            "flush_tid"
          ],
          "line": 1789
        },
        "resolved": true,
        "details": {
          "function_name": "__send_cap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "1118-1243",
          "snippet": "static int __send_cap(struct ceph_mds_client *mdsc, struct ceph_cap *cap,\n\t\t      int op, int used, int want, int retain, int flushing,\n\t\t      unsigned *pflush_tid)\n\t__releases(cap->ci->i_ceph_lock)\n{\n\tstruct ceph_inode_info *ci = cap->ci;\n\tstruct inode *inode = &ci->vfs_inode;\n\tu64 cap_id = cap->cap_id;\n\tint held, revoking, dropping, keep;\n\tu64 seq, issue_seq, mseq, time_warp_seq, follows;\n\tu64 size, max_size;\n\tstruct timespec mtime, atime;\n\tint wake = 0;\n\tumode_t mode;\n\tkuid_t uid;\n\tkgid_t gid;\n\tstruct ceph_mds_session *session;\n\tu64 xattr_version = 0;\n\tstruct ceph_buffer *xattr_blob = NULL;\n\tint delayed = 0;\n\tu64 flush_tid = 0;\n\tint i;\n\tint ret;\n\tbool inline_data;\n\n\theld = cap->issued | cap->implemented;\n\trevoking = cap->implemented & ~cap->issued;\n\tretain &= ~revoking;\n\tdropping = cap->issued & ~retain;\n\n\tdout(\"__send_cap %p cap %p session %p %s -> %s (revoking %s)\\n\",\n\t     inode, cap, cap->session,\n\t     ceph_cap_string(held), ceph_cap_string(held & retain),\n\t     ceph_cap_string(revoking));\n\tBUG_ON((retain & CEPH_CAP_PIN) == 0);\n\n\tsession = cap->session;\n\n\t/* don't release wanted unless we've waited a bit. */\n\tif ((ci->i_ceph_flags & CEPH_I_NODELAY) == 0 &&\n\t    time_before(jiffies, ci->i_hold_caps_min)) {\n\t\tdout(\" delaying issued %s -> %s, wanted %s -> %s on send\\n\",\n\t\t     ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(cap->issued & retain),\n\t\t     ceph_cap_string(cap->mds_wanted),\n\t\t     ceph_cap_string(want));\n\t\twant |= cap->mds_wanted;\n\t\tretain |= cap->issued;\n\t\tdelayed = 1;\n\t}\n\tci->i_ceph_flags &= ~(CEPH_I_NODELAY | CEPH_I_FLUSH);\n\n\tcap->issued &= retain;  /* drop bits we don't want */\n\tif (cap->implemented & ~cap->issued) {\n\t\t/*\n\t\t * Wake up any waiters on wanted -> needed transition.\n\t\t * This is due to the weird transition from buffered\n\t\t * to sync IO... we need to flush dirty pages _before_\n\t\t * allowing sync writes to avoid reordering.\n\t\t */\n\t\twake = 1;\n\t}\n\tcap->implemented &= cap->issued | used;\n\tcap->mds_wanted = want;\n\n\tif (flushing) {\n\t\t/*\n\t\t * assign a tid for flush operations so we can avoid\n\t\t * flush1 -> dirty1 -> flush2 -> flushack1 -> mark\n\t\t * clean type races.  track latest tid for every bit\n\t\t * so we can handle flush AxFw, flush Fw, and have the\n\t\t * first ack clean Ax.\n\t\t */\n\t\tflush_tid = ++ci->i_cap_flush_last_tid;\n\t\tif (pflush_tid)\n\t\t\t*pflush_tid = flush_tid;\n\t\tdout(\" cap_flush_tid %d\\n\", (int)flush_tid);\n\t\tfor (i = 0; i < CEPH_CAP_BITS; i++)\n\t\t\tif (flushing & (1 << i))\n\t\t\t\tci->i_cap_flush_tid[i] = flush_tid;\n\n\t\tfollows = ci->i_head_snapc->seq;\n\t} else {\n\t\tfollows = 0;\n\t}\n\n\tkeep = cap->implemented;\n\tseq = cap->seq;\n\tissue_seq = cap->issue_seq;\n\tmseq = cap->mseq;\n\tsize = inode->i_size;\n\tci->i_reported_size = size;\n\tmax_size = ci->i_wanted_max_size;\n\tci->i_requested_max_size = max_size;\n\tmtime = inode->i_mtime;\n\tatime = inode->i_atime;\n\ttime_warp_seq = ci->i_time_warp_seq;\n\tuid = inode->i_uid;\n\tgid = inode->i_gid;\n\tmode = inode->i_mode;\n\n\tif (flushing & CEPH_CAP_XATTR_EXCL) {\n\t\t__ceph_build_xattrs_blob(ci);\n\t\txattr_blob = ci->i_xattrs.blob;\n\t\txattr_version = ci->i_xattrs.version;\n\t}\n\n\tinline_data = ci->i_inline_version != CEPH_INLINE_NONE;\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tret = send_cap_msg(session, ceph_vino(inode).ino, cap_id,\n\t\top, keep, want, flushing, seq, flush_tid, issue_seq, mseq,\n\t\tsize, max_size, &mtime, &atime, time_warp_seq,\n\t\tuid, gid, mode, xattr_version, xattr_blob,\n\t\tfollows, inline_data);\n\tif (ret < 0) {\n\t\tdout(\"error sending cap msg, must requeue %p\\n\", inode);\n\t\tdelayed = 1;\n\t}\n\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\n\treturn delayed;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __send_cap(struct ceph_mds_client *mdsc, struct ceph_cap *cap,\n\t\t      int op, int used, int want, int retain, int flushing,\n\t\t      unsigned *pflush_tid)\n\t__releases(cap->ci->i_ceph_lock)\n{\n\tstruct ceph_inode_info *ci = cap->ci;\n\tstruct inode *inode = &ci->vfs_inode;\n\tu64 cap_id = cap->cap_id;\n\tint held, revoking, dropping, keep;\n\tu64 seq, issue_seq, mseq, time_warp_seq, follows;\n\tu64 size, max_size;\n\tstruct timespec mtime, atime;\n\tint wake = 0;\n\tumode_t mode;\n\tkuid_t uid;\n\tkgid_t gid;\n\tstruct ceph_mds_session *session;\n\tu64 xattr_version = 0;\n\tstruct ceph_buffer *xattr_blob = NULL;\n\tint delayed = 0;\n\tu64 flush_tid = 0;\n\tint i;\n\tint ret;\n\tbool inline_data;\n\n\theld = cap->issued | cap->implemented;\n\trevoking = cap->implemented & ~cap->issued;\n\tretain &= ~revoking;\n\tdropping = cap->issued & ~retain;\n\n\tdout(\"__send_cap %p cap %p session %p %s -> %s (revoking %s)\\n\",\n\t     inode, cap, cap->session,\n\t     ceph_cap_string(held), ceph_cap_string(held & retain),\n\t     ceph_cap_string(revoking));\n\tBUG_ON((retain & CEPH_CAP_PIN) == 0);\n\n\tsession = cap->session;\n\n\t/* don't release wanted unless we've waited a bit. */\n\tif ((ci->i_ceph_flags & CEPH_I_NODELAY) == 0 &&\n\t    time_before(jiffies, ci->i_hold_caps_min)) {\n\t\tdout(\" delaying issued %s -> %s, wanted %s -> %s on send\\n\",\n\t\t     ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(cap->issued & retain),\n\t\t     ceph_cap_string(cap->mds_wanted),\n\t\t     ceph_cap_string(want));\n\t\twant |= cap->mds_wanted;\n\t\tretain |= cap->issued;\n\t\tdelayed = 1;\n\t}\n\tci->i_ceph_flags &= ~(CEPH_I_NODELAY | CEPH_I_FLUSH);\n\n\tcap->issued &= retain;  /* drop bits we don't want */\n\tif (cap->implemented & ~cap->issued) {\n\t\t/*\n\t\t * Wake up any waiters on wanted -> needed transition.\n\t\t * This is due to the weird transition from buffered\n\t\t * to sync IO... we need to flush dirty pages _before_\n\t\t * allowing sync writes to avoid reordering.\n\t\t */\n\t\twake = 1;\n\t}\n\tcap->implemented &= cap->issued | used;\n\tcap->mds_wanted = want;\n\n\tif (flushing) {\n\t\t/*\n\t\t * assign a tid for flush operations so we can avoid\n\t\t * flush1 -> dirty1 -> flush2 -> flushack1 -> mark\n\t\t * clean type races.  track latest tid for every bit\n\t\t * so we can handle flush AxFw, flush Fw, and have the\n\t\t * first ack clean Ax.\n\t\t */\n\t\tflush_tid = ++ci->i_cap_flush_last_tid;\n\t\tif (pflush_tid)\n\t\t\t*pflush_tid = flush_tid;\n\t\tdout(\" cap_flush_tid %d\\n\", (int)flush_tid);\n\t\tfor (i = 0; i < CEPH_CAP_BITS; i++)\n\t\t\tif (flushing & (1 << i))\n\t\t\t\tci->i_cap_flush_tid[i] = flush_tid;\n\n\t\tfollows = ci->i_head_snapc->seq;\n\t} else {\n\t\tfollows = 0;\n\t}\n\n\tkeep = cap->implemented;\n\tseq = cap->seq;\n\tissue_seq = cap->issue_seq;\n\tmseq = cap->mseq;\n\tsize = inode->i_size;\n\tci->i_reported_size = size;\n\tmax_size = ci->i_wanted_max_size;\n\tci->i_requested_max_size = max_size;\n\tmtime = inode->i_mtime;\n\tatime = inode->i_atime;\n\ttime_warp_seq = ci->i_time_warp_seq;\n\tuid = inode->i_uid;\n\tgid = inode->i_gid;\n\tmode = inode->i_mode;\n\n\tif (flushing & CEPH_CAP_XATTR_EXCL) {\n\t\t__ceph_build_xattrs_blob(ci);\n\t\txattr_blob = ci->i_xattrs.blob;\n\t\txattr_version = ci->i_xattrs.version;\n\t}\n\n\tinline_data = ci->i_inline_version != CEPH_INLINE_NONE;\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tret = send_cap_msg(session, ceph_vino(inode).ino, cap_id,\n\t\top, keep, want, flushing, seq, flush_tid, issue_seq, mseq,\n\t\tsize, max_size, &mtime, &atime, time_warp_seq,\n\t\tuid, gid, mode, xattr_version, xattr_blob,\n\t\tfollows, inline_data);\n\tif (ret < 0) {\n\t\tdout(\"error sending cap msg, must requeue %p\\n\", inode);\n\t\tdelayed = 1;\n\t}\n\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\n\treturn delayed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__mark_caps_flushing",
          "args": [
            "inode",
            "session"
          ],
          "line": 1786
        },
        "resolved": true,
        "details": {
          "function_name": "__mark_caps_flushing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "1431-1467",
          "snippet": "static int __mark_caps_flushing(struct inode *inode,\n\t\t\t\t struct ceph_mds_session *session)\n{\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint flushing;\n\n\tBUG_ON(ci->i_dirty_caps == 0);\n\tBUG_ON(list_empty(&ci->i_dirty_item));\n\n\tflushing = ci->i_dirty_caps;\n\tdout(\"__mark_caps_flushing flushing %s, flushing_caps %s -> %s\\n\",\n\t     ceph_cap_string(flushing),\n\t     ceph_cap_string(ci->i_flushing_caps),\n\t     ceph_cap_string(ci->i_flushing_caps | flushing));\n\tci->i_flushing_caps |= flushing;\n\tci->i_dirty_caps = 0;\n\tdout(\" inode %p now !dirty\\n\", inode);\n\n\tspin_lock(&mdsc->cap_dirty_lock);\n\tlist_del_init(&ci->i_dirty_item);\n\n\tif (list_empty(&ci->i_flushing_item)) {\n\t\tci->i_cap_flush_seq = ++mdsc->cap_flush_seq;\n\t\tlist_add_tail(&ci->i_flushing_item, &session->s_cap_flushing);\n\t\tmdsc->num_cap_flushing++;\n\t\tdout(\" inode %p now flushing seq %lld\\n\", inode,\n\t\t     ci->i_cap_flush_seq);\n\t} else {\n\t\tlist_move_tail(&ci->i_flushing_item, &session->s_cap_flushing);\n\t\tdout(\" inode %p now flushing (more) seq %lld\\n\", inode,\n\t\t     ci->i_cap_flush_seq);\n\t}\n\tspin_unlock(&mdsc->cap_dirty_lock);\n\n\treturn flushing;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __mark_caps_flushing(struct inode *inode,\n\t\t\t\t struct ceph_mds_session *session)\n{\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint flushing;\n\n\tBUG_ON(ci->i_dirty_caps == 0);\n\tBUG_ON(list_empty(&ci->i_dirty_item));\n\n\tflushing = ci->i_dirty_caps;\n\tdout(\"__mark_caps_flushing flushing %s, flushing_caps %s -> %s\\n\",\n\t     ceph_cap_string(flushing),\n\t     ceph_cap_string(ci->i_flushing_caps),\n\t     ceph_cap_string(ci->i_flushing_caps | flushing));\n\tci->i_flushing_caps |= flushing;\n\tci->i_dirty_caps = 0;\n\tdout(\" inode %p now !dirty\\n\", inode);\n\n\tspin_lock(&mdsc->cap_dirty_lock);\n\tlist_del_init(&ci->i_dirty_item);\n\n\tif (list_empty(&ci->i_flushing_item)) {\n\t\tci->i_cap_flush_seq = ++mdsc->cap_flush_seq;\n\t\tlist_add_tail(&ci->i_flushing_item, &session->s_cap_flushing);\n\t\tmdsc->num_cap_flushing++;\n\t\tdout(\" inode %p now flushing seq %lld\\n\", inode,\n\t\t     ci->i_cap_flush_seq);\n\t} else {\n\t\tlist_move_tail(&ci->i_flushing_item, &session->s_cap_flushing);\n\t\tdout(\" inode %p now flushing (more) seq %lld\\n\", inode,\n\t\t     ci->i_cap_flush_seq);\n\t}\n\tspin_unlock(&mdsc->cap_dirty_lock);\n\n\treturn flushing;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&session->s_mutex"
          ],
          "line": 1780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&session->s_mutex"
          ],
          "line": 1778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ceph_caps_wanted",
          "args": [
            "ci"
          ],
          "line": 1772
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_caps_wanted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "566-572",
          "snippet": "static inline int __ceph_caps_wanted(struct ceph_inode_info *ci)\n{\n\tint w = __ceph_caps_file_wanted(ci) | __ceph_caps_used(ci);\n\tif (w & CEPH_CAP_FILE_BUFFER)\n\t\tw |= CEPH_CAP_FILE_EXCL;  /* we want EXCL if dirty data */\n\treturn w;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline int __ceph_caps_wanted(struct ceph_inode_info *ci)\n{\n\tint w = __ceph_caps_file_wanted(ci) | __ceph_caps_used(ci);\n\tif (w & CEPH_CAP_FILE_BUFFER)\n\t\tw |= CEPH_CAP_FILE_EXCL;  /* we want EXCL if dirty data */\n\treturn w;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_caps_used",
          "args": [
            "ci"
          ],
          "line": 1771
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_caps_used",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "829-843",
          "snippet": "int __ceph_caps_used(struct ceph_inode_info *ci)\n{\n\tint used = 0;\n\tif (ci->i_pin_ref)\n\t\tused |= CEPH_CAP_PIN;\n\tif (ci->i_rd_ref)\n\t\tused |= CEPH_CAP_FILE_RD;\n\tif (ci->i_rdcache_ref || ci->vfs_inode.i_data.nrpages)\n\t\tused |= CEPH_CAP_FILE_CACHE;\n\tif (ci->i_wr_ref)\n\t\tused |= CEPH_CAP_FILE_WR;\n\tif (ci->i_wb_ref || ci->i_wrbuffer_ref)\n\t\tused |= CEPH_CAP_FILE_BUFFER;\n\treturn used;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_caps_used(struct ceph_inode_info *ci)\n{\n\tint used = 0;\n\tif (ci->i_pin_ref)\n\t\tused |= CEPH_CAP_PIN;\n\tif (ci->i_rd_ref)\n\t\tused |= CEPH_CAP_FILE_RD;\n\tif (ci->i_rdcache_ref || ci->vfs_inode.i_data.nrpages)\n\t\tused |= CEPH_CAP_FILE_CACHE;\n\tif (ci->i_wr_ref)\n\t\tused |= CEPH_CAP_FILE_WR;\n\tif (ci->i_wb_ref || ci->i_wrbuffer_ref)\n\t\tused |= CEPH_CAP_FILE_BUFFER;\n\treturn used;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"try_flush_caps skipping %p I_NOFLUSH set\\n\"",
            "inode"
          ],
          "line": 1766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 1759
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_sb_to_client",
          "args": [
            "inode->i_sb"
          ],
          "line": 1758
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_sb_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "352-355",
          "snippet": "static inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int try_flush_caps(struct inode *inode, unsigned *flush_tid)\n{\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint flushing = 0;\n\tstruct ceph_mds_session *session = NULL;\n\nretry:\n\tspin_lock(&ci->i_ceph_lock);\n\tif (ci->i_ceph_flags & CEPH_I_NOFLUSH) {\n\t\tdout(\"try_flush_caps skipping %p I_NOFLUSH set\\n\", inode);\n\t\tgoto out;\n\t}\n\tif (ci->i_dirty_caps && ci->i_auth_cap) {\n\t\tstruct ceph_cap *cap = ci->i_auth_cap;\n\t\tint used = __ceph_caps_used(ci);\n\t\tint want = __ceph_caps_wanted(ci);\n\t\tint delayed;\n\n\t\tif (!session || session != cap->session) {\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\tif (session)\n\t\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tsession = cap->session;\n\t\t\tmutex_lock(&session->s_mutex);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (cap->session->s_state < CEPH_MDS_SESSION_OPEN)\n\t\t\tgoto out;\n\n\t\tflushing = __mark_caps_flushing(inode, session);\n\n\t\t/* __send_cap drops i_ceph_lock */\n\t\tdelayed = __send_cap(mdsc, cap, CEPH_CAP_OP_FLUSH, used, want,\n\t\t\t\t     cap->issued | cap->implemented, flushing,\n\t\t\t\t     flush_tid);\n\t\tif (!delayed)\n\t\t\tgoto out_unlocked;\n\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\t__cap_delay_requeue(mdsc, ci);\n\t}\nout:\n\tspin_unlock(&ci->i_ceph_lock);\nout_unlocked:\n\tif (session)\n\t\tmutex_unlock(&session->s_mutex);\n\treturn flushing;\n}"
  },
  {
    "function_name": "ceph_check_caps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "1504-1751",
    "snippet": "void ceph_check_caps(struct ceph_inode_info *ci, int flags,\n\t\t     struct ceph_mds_session *session)\n{\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(&ci->vfs_inode);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct inode *inode = &ci->vfs_inode;\n\tstruct ceph_cap *cap;\n\tint file_wanted, used, cap_used;\n\tint took_snap_rwsem = 0;             /* true if mdsc->snap_rwsem held */\n\tint issued, implemented, want, retain, revoking, flushing = 0;\n\tint mds = -1;   /* keep track of how far we've gone through i_caps list\n\t\t\t   to avoid an infinite loop on retry */\n\tstruct rb_node *p;\n\tint tried_invalidate = 0;\n\tint delayed = 0, sent = 0, force_requeue = 0, num;\n\tint queue_invalidate = 0;\n\tint is_delayed = flags & CHECK_CAPS_NODELAY;\n\n\t/* if we are unmounting, flush any unused caps immediately. */\n\tif (mdsc->stopping)\n\t\tis_delayed = 1;\n\n\tspin_lock(&ci->i_ceph_lock);\n\n\tif (ci->i_ceph_flags & CEPH_I_FLUSH)\n\t\tflags |= CHECK_CAPS_FLUSH;\n\n\t/* flush snaps first time around only */\n\tif (!list_empty(&ci->i_cap_snaps))\n\t\t__ceph_flush_snaps(ci, &session, 0);\n\tgoto retry_locked;\nretry:\n\tspin_lock(&ci->i_ceph_lock);\nretry_locked:\n\tfile_wanted = __ceph_caps_file_wanted(ci);\n\tused = __ceph_caps_used(ci);\n\twant = file_wanted | used;\n\tissued = __ceph_caps_issued(ci, &implemented);\n\trevoking = implemented & ~issued;\n\n\tretain = want | CEPH_CAP_PIN;\n\tif (!mdsc->stopping && inode->i_nlink > 0) {\n\t\tif (want) {\n\t\t\tretain |= CEPH_CAP_ANY;       /* be greedy */\n\t\t} else {\n\t\t\tretain |= CEPH_CAP_ANY_SHARED;\n\t\t\t/*\n\t\t\t * keep RD only if we didn't have the file open RW,\n\t\t\t * because then the mds would revoke it anyway to\n\t\t\t * journal max_size=0.\n\t\t\t */\n\t\t\tif (ci->i_max_size == 0)\n\t\t\t\tretain |= CEPH_CAP_ANY_RD;\n\t\t}\n\t}\n\n\tdout(\"check_caps %p file_want %s used %s dirty %s flushing %s\"\n\t     \" issued %s revoking %s retain %s %s%s%s\\n\", inode,\n\t     ceph_cap_string(file_wanted),\n\t     ceph_cap_string(used), ceph_cap_string(ci->i_dirty_caps),\n\t     ceph_cap_string(ci->i_flushing_caps),\n\t     ceph_cap_string(issued), ceph_cap_string(revoking),\n\t     ceph_cap_string(retain),\n\t     (flags & CHECK_CAPS_AUTHONLY) ? \" AUTHONLY\" : \"\",\n\t     (flags & CHECK_CAPS_NODELAY) ? \" NODELAY\" : \"\",\n\t     (flags & CHECK_CAPS_FLUSH) ? \" FLUSH\" : \"\");\n\n\t/*\n\t * If we no longer need to hold onto old our caps, and we may\n\t * have cached pages, but don't want them, then try to invalidate.\n\t * If we fail, it's because pages are locked.... try again later.\n\t */\n\tif ((!is_delayed || mdsc->stopping) &&\n\t    ci->i_wrbuffer_ref == 0 &&               /* no dirty pages... */\n\t    inode->i_data.nrpages &&                 /* have cached pages */\n\t    (file_wanted == 0 ||                     /* no open files */\n\t     (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t  CEPH_CAP_FILE_LAZYIO))) && /*  or revoking cache */\n\t    !tried_invalidate) {\n\t\tdout(\"check_caps trying to invalidate on %p\\n\", inode);\n\t\tif (try_nonblocking_invalidate(inode) < 0) {\n\t\t\tif (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t\t\tCEPH_CAP_FILE_LAZYIO)) {\n\t\t\t\tdout(\"check_caps queuing invalidate\\n\");\n\t\t\t\tqueue_invalidate = 1;\n\t\t\t\tci->i_rdcache_revoking = ci->i_rdcache_gen;\n\t\t\t} else {\n\t\t\t\tdout(\"check_caps failed to invalidate pages\\n\");\n\t\t\t\t/* we failed to invalidate pages.  check these\n\t\t\t\t   caps again later. */\n\t\t\t\tforce_requeue = 1;\n\t\t\t\t__cap_set_timeouts(mdsc, ci);\n\t\t\t}\n\t\t}\n\t\ttried_invalidate = 1;\n\t\tgoto retry_locked;\n\t}\n\n\tnum = 0;\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tnum++;\n\n\t\t/* avoid looping forever */\n\t\tif (mds >= cap->mds ||\n\t\t    ((flags & CHECK_CAPS_AUTHONLY) && cap != ci->i_auth_cap))\n\t\t\tcontinue;\n\n\t\t/* NOTE: no side-effects allowed, until we take s_mutex */\n\n\t\tcap_used = used;\n\t\tif (ci->i_auth_cap && cap != ci->i_auth_cap)\n\t\t\tcap_used &= ~ci->i_auth_cap->issued;\n\n\t\trevoking = cap->implemented & ~cap->issued;\n\t\tdout(\" mds%d cap %p used %s issued %s implemented %s revoking %s\\n\",\n\t\t     cap->mds, cap, ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(cap_used),\n\t\t     ceph_cap_string(cap->implemented),\n\t\t     ceph_cap_string(revoking));\n\n\t\tif (cap == ci->i_auth_cap &&\n\t\t    (cap->issued & CEPH_CAP_FILE_WR)) {\n\t\t\t/* request larger max_size from MDS? */\n\t\t\tif (ci->i_wanted_max_size > ci->i_max_size &&\n\t\t\t    ci->i_wanted_max_size > ci->i_requested_max_size) {\n\t\t\t\tdout(\"requesting new max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\n\t\t\t/* approaching file_max? */\n\t\t\tif ((inode->i_size << 1) >= ci->i_max_size &&\n\t\t\t    (ci->i_reported_size << 1) < ci->i_max_size) {\n\t\t\t\tdout(\"i_size approaching max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\t\t}\n\t\t/* flush anything dirty? */\n\t\tif (cap == ci->i_auth_cap && (flags & CHECK_CAPS_FLUSH) &&\n\t\t    ci->i_dirty_caps) {\n\t\t\tdout(\"flushing dirty caps\\n\");\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* completed revocation? going down and there are no caps? */\n\t\tif (revoking && (revoking & cap_used) == 0) {\n\t\t\tdout(\"completed revocation of %s\\n\",\n\t\t\t     ceph_cap_string(cap->implemented & ~cap->issued));\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* want more caps from mds? */\n\t\tif (want & ~(cap->mds_wanted | cap->issued))\n\t\t\tgoto ack;\n\n\t\t/* things we might delay */\n\t\tif ((cap->issued & ~retain) == 0 &&\n\t\t    cap->mds_wanted == want)\n\t\t\tcontinue;     /* nope, all good */\n\n\t\tif (is_delayed)\n\t\t\tgoto ack;\n\n\t\t/* delay? */\n\t\tif ((ci->i_ceph_flags & CEPH_I_NODELAY) == 0 &&\n\t\t    time_before(jiffies, ci->i_hold_caps_max)) {\n\t\t\tdout(\" delaying issued %s -> %s, wanted %s -> %s\\n\",\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(cap->issued & retain),\n\t\t\t     ceph_cap_string(cap->mds_wanted),\n\t\t\t     ceph_cap_string(want));\n\t\t\tdelayed++;\n\t\t\tcontinue;\n\t\t}\n\nack:\n\t\tif (ci->i_ceph_flags & CEPH_I_NOFLUSH) {\n\t\t\tdout(\" skipping %p I_NOFLUSH set\\n\", inode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (session && session != cap->session) {\n\t\t\tdout(\"oops, wrong session %p mutex\\n\", session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tsession = NULL;\n\t\t}\n\t\tif (!session) {\n\t\t\tsession = cap->session;\n\t\t\tif (mutex_trylock(&session->s_mutex) == 0) {\n\t\t\t\tdout(\"inverting session/ino locks on %p\\n\",\n\t\t\t\t     session);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tif (took_snap_rwsem) {\n\t\t\t\t\tup_read(&mdsc->snap_rwsem);\n\t\t\t\t\ttook_snap_rwsem = 0;\n\t\t\t\t}\n\t\t\t\tmutex_lock(&session->s_mutex);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t\t/* take snap_rwsem after session mutex */\n\t\tif (!took_snap_rwsem) {\n\t\t\tif (down_read_trylock(&mdsc->snap_rwsem) == 0) {\n\t\t\t\tdout(\"inverting snap/in locks on %p\\n\",\n\t\t\t\t     inode);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tdown_read(&mdsc->snap_rwsem);\n\t\t\t\ttook_snap_rwsem = 1;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\ttook_snap_rwsem = 1;\n\t\t}\n\n\t\tif (cap == ci->i_auth_cap && ci->i_dirty_caps)\n\t\t\tflushing = __mark_caps_flushing(inode, session);\n\t\telse\n\t\t\tflushing = 0;\n\n\t\tmds = cap->mds;  /* remember mds, so we don't repeat */\n\t\tsent++;\n\n\t\t/* __send_cap drops i_ceph_lock */\n\t\tdelayed += __send_cap(mdsc, cap, CEPH_CAP_OP_UPDATE, cap_used,\n\t\t\t\t      want, retain, flushing, NULL);\n\t\tgoto retry; /* retake i_ceph_lock and restart our cap scan. */\n\t}\n\n\t/*\n\t * Reschedule delayed caps release if we delayed anything,\n\t * otherwise cancel.\n\t */\n\tif (delayed && is_delayed)\n\t\tforce_requeue = 1;   /* __send_cap delayed release; requeue */\n\tif (!delayed && !is_delayed)\n\t\t__cap_delay_cancel(mdsc, ci);\n\telse if (!is_delayed || force_requeue)\n\t\t__cap_delay_requeue(mdsc, ci);\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (queue_invalidate)\n\t\tceph_queue_invalidate(inode);\n\n\tif (session)\n\t\tmutex_unlock(&session->s_mutex);\n\tif (took_snap_rwsem)\n\t\tup_read(&mdsc->snap_rwsem);\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mdsc->snap_rwsem"
          ],
          "line": 1750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&session->s_mutex"
          ],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_queue_invalidate",
          "args": [
            "inode"
          ],
          "line": 1745
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_queue_invalidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "1531-1541",
          "snippet": "void ceph_queue_invalidate(struct inode *inode)\n{\n\tihold(inode);\n\tif (queue_work(ceph_inode_to_client(inode)->pg_inv_wq,\n\t\t       &ceph_inode(inode)->i_pg_inv_work)) {\n\t\tdout(\"ceph_queue_invalidate %p\\n\", inode);\n\t} else {\n\t\tdout(\"ceph_queue_invalidate %p failed\\n\", inode);\n\t\tiput(inode);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_queue_invalidate(struct inode *inode)\n{\n\tihold(inode);\n\tif (queue_work(ceph_inode_to_client(inode)->pg_inv_wq,\n\t\t       &ceph_inode(inode)->i_pg_inv_work)) {\n\t\tdout(\"ceph_queue_invalidate %p\\n\", inode);\n\t} else {\n\t\tdout(\"ceph_queue_invalidate %p failed\\n\", inode);\n\t\tiput(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 1742
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__cap_delay_requeue",
          "args": [
            "mdsc",
            "ci"
          ],
          "line": 1740
        },
        "resolved": true,
        "details": {
          "function_name": "__cap_delay_requeue_front",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "442-452",
          "snippet": "static void __cap_delay_requeue_front(struct ceph_mds_client *mdsc,\n\t\t\t\t      struct ceph_inode_info *ci)\n{\n\tdout(\"__cap_delay_requeue_front %p\\n\", &ci->vfs_inode);\n\tspin_lock(&mdsc->cap_delay_lock);\n\tci->i_ceph_flags |= CEPH_I_FLUSH;\n\tif (!list_empty(&ci->i_cap_delay_list))\n\t\tlist_del_init(&ci->i_cap_delay_list);\n\tlist_add(&ci->i_cap_delay_list, &mdsc->cap_delay_list);\n\tspin_unlock(&mdsc->cap_delay_lock);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __cap_delay_requeue_front(struct ceph_mds_client *mdsc,\n\t\t\t\t      struct ceph_inode_info *ci)\n{\n\tdout(\"__cap_delay_requeue_front %p\\n\", &ci->vfs_inode);\n\tspin_lock(&mdsc->cap_delay_lock);\n\tci->i_ceph_flags |= CEPH_I_FLUSH;\n\tif (!list_empty(&ci->i_cap_delay_list))\n\t\tlist_del_init(&ci->i_cap_delay_list);\n\tlist_add(&ci->i_cap_delay_list, &mdsc->cap_delay_list);\n\tspin_unlock(&mdsc->cap_delay_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__cap_delay_cancel",
          "args": [
            "mdsc",
            "ci"
          ],
          "line": 1738
        },
        "resolved": true,
        "details": {
          "function_name": "__cap_delay_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "459-468",
          "snippet": "static void __cap_delay_cancel(struct ceph_mds_client *mdsc,\n\t\t\t       struct ceph_inode_info *ci)\n{\n\tdout(\"__cap_delay_cancel %p\\n\", &ci->vfs_inode);\n\tif (list_empty(&ci->i_cap_delay_list))\n\t\treturn;\n\tspin_lock(&mdsc->cap_delay_lock);\n\tlist_del_init(&ci->i_cap_delay_list);\n\tspin_unlock(&mdsc->cap_delay_lock);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __cap_delay_cancel(struct ceph_mds_client *mdsc,\n\t\t\t       struct ceph_inode_info *ci)\n{\n\tdout(\"__cap_delay_cancel %p\\n\", &ci->vfs_inode);\n\tif (list_empty(&ci->i_cap_delay_list))\n\t\treturn;\n\tspin_lock(&mdsc->cap_delay_lock);\n\tlist_del_init(&ci->i_cap_delay_list);\n\tspin_unlock(&mdsc->cap_delay_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__send_cap",
          "args": [
            "mdsc",
            "cap",
            "CEPH_CAP_OP_UPDATE",
            "cap_used",
            "want",
            "retain",
            "flushing",
            "NULL"
          ],
          "line": 1726
        },
        "resolved": true,
        "details": {
          "function_name": "__send_cap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "1118-1243",
          "snippet": "static int __send_cap(struct ceph_mds_client *mdsc, struct ceph_cap *cap,\n\t\t      int op, int used, int want, int retain, int flushing,\n\t\t      unsigned *pflush_tid)\n\t__releases(cap->ci->i_ceph_lock)\n{\n\tstruct ceph_inode_info *ci = cap->ci;\n\tstruct inode *inode = &ci->vfs_inode;\n\tu64 cap_id = cap->cap_id;\n\tint held, revoking, dropping, keep;\n\tu64 seq, issue_seq, mseq, time_warp_seq, follows;\n\tu64 size, max_size;\n\tstruct timespec mtime, atime;\n\tint wake = 0;\n\tumode_t mode;\n\tkuid_t uid;\n\tkgid_t gid;\n\tstruct ceph_mds_session *session;\n\tu64 xattr_version = 0;\n\tstruct ceph_buffer *xattr_blob = NULL;\n\tint delayed = 0;\n\tu64 flush_tid = 0;\n\tint i;\n\tint ret;\n\tbool inline_data;\n\n\theld = cap->issued | cap->implemented;\n\trevoking = cap->implemented & ~cap->issued;\n\tretain &= ~revoking;\n\tdropping = cap->issued & ~retain;\n\n\tdout(\"__send_cap %p cap %p session %p %s -> %s (revoking %s)\\n\",\n\t     inode, cap, cap->session,\n\t     ceph_cap_string(held), ceph_cap_string(held & retain),\n\t     ceph_cap_string(revoking));\n\tBUG_ON((retain & CEPH_CAP_PIN) == 0);\n\n\tsession = cap->session;\n\n\t/* don't release wanted unless we've waited a bit. */\n\tif ((ci->i_ceph_flags & CEPH_I_NODELAY) == 0 &&\n\t    time_before(jiffies, ci->i_hold_caps_min)) {\n\t\tdout(\" delaying issued %s -> %s, wanted %s -> %s on send\\n\",\n\t\t     ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(cap->issued & retain),\n\t\t     ceph_cap_string(cap->mds_wanted),\n\t\t     ceph_cap_string(want));\n\t\twant |= cap->mds_wanted;\n\t\tretain |= cap->issued;\n\t\tdelayed = 1;\n\t}\n\tci->i_ceph_flags &= ~(CEPH_I_NODELAY | CEPH_I_FLUSH);\n\n\tcap->issued &= retain;  /* drop bits we don't want */\n\tif (cap->implemented & ~cap->issued) {\n\t\t/*\n\t\t * Wake up any waiters on wanted -> needed transition.\n\t\t * This is due to the weird transition from buffered\n\t\t * to sync IO... we need to flush dirty pages _before_\n\t\t * allowing sync writes to avoid reordering.\n\t\t */\n\t\twake = 1;\n\t}\n\tcap->implemented &= cap->issued | used;\n\tcap->mds_wanted = want;\n\n\tif (flushing) {\n\t\t/*\n\t\t * assign a tid for flush operations so we can avoid\n\t\t * flush1 -> dirty1 -> flush2 -> flushack1 -> mark\n\t\t * clean type races.  track latest tid for every bit\n\t\t * so we can handle flush AxFw, flush Fw, and have the\n\t\t * first ack clean Ax.\n\t\t */\n\t\tflush_tid = ++ci->i_cap_flush_last_tid;\n\t\tif (pflush_tid)\n\t\t\t*pflush_tid = flush_tid;\n\t\tdout(\" cap_flush_tid %d\\n\", (int)flush_tid);\n\t\tfor (i = 0; i < CEPH_CAP_BITS; i++)\n\t\t\tif (flushing & (1 << i))\n\t\t\t\tci->i_cap_flush_tid[i] = flush_tid;\n\n\t\tfollows = ci->i_head_snapc->seq;\n\t} else {\n\t\tfollows = 0;\n\t}\n\n\tkeep = cap->implemented;\n\tseq = cap->seq;\n\tissue_seq = cap->issue_seq;\n\tmseq = cap->mseq;\n\tsize = inode->i_size;\n\tci->i_reported_size = size;\n\tmax_size = ci->i_wanted_max_size;\n\tci->i_requested_max_size = max_size;\n\tmtime = inode->i_mtime;\n\tatime = inode->i_atime;\n\ttime_warp_seq = ci->i_time_warp_seq;\n\tuid = inode->i_uid;\n\tgid = inode->i_gid;\n\tmode = inode->i_mode;\n\n\tif (flushing & CEPH_CAP_XATTR_EXCL) {\n\t\t__ceph_build_xattrs_blob(ci);\n\t\txattr_blob = ci->i_xattrs.blob;\n\t\txattr_version = ci->i_xattrs.version;\n\t}\n\n\tinline_data = ci->i_inline_version != CEPH_INLINE_NONE;\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tret = send_cap_msg(session, ceph_vino(inode).ino, cap_id,\n\t\top, keep, want, flushing, seq, flush_tid, issue_seq, mseq,\n\t\tsize, max_size, &mtime, &atime, time_warp_seq,\n\t\tuid, gid, mode, xattr_version, xattr_blob,\n\t\tfollows, inline_data);\n\tif (ret < 0) {\n\t\tdout(\"error sending cap msg, must requeue %p\\n\", inode);\n\t\tdelayed = 1;\n\t}\n\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\n\treturn delayed;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __send_cap(struct ceph_mds_client *mdsc, struct ceph_cap *cap,\n\t\t      int op, int used, int want, int retain, int flushing,\n\t\t      unsigned *pflush_tid)\n\t__releases(cap->ci->i_ceph_lock)\n{\n\tstruct ceph_inode_info *ci = cap->ci;\n\tstruct inode *inode = &ci->vfs_inode;\n\tu64 cap_id = cap->cap_id;\n\tint held, revoking, dropping, keep;\n\tu64 seq, issue_seq, mseq, time_warp_seq, follows;\n\tu64 size, max_size;\n\tstruct timespec mtime, atime;\n\tint wake = 0;\n\tumode_t mode;\n\tkuid_t uid;\n\tkgid_t gid;\n\tstruct ceph_mds_session *session;\n\tu64 xattr_version = 0;\n\tstruct ceph_buffer *xattr_blob = NULL;\n\tint delayed = 0;\n\tu64 flush_tid = 0;\n\tint i;\n\tint ret;\n\tbool inline_data;\n\n\theld = cap->issued | cap->implemented;\n\trevoking = cap->implemented & ~cap->issued;\n\tretain &= ~revoking;\n\tdropping = cap->issued & ~retain;\n\n\tdout(\"__send_cap %p cap %p session %p %s -> %s (revoking %s)\\n\",\n\t     inode, cap, cap->session,\n\t     ceph_cap_string(held), ceph_cap_string(held & retain),\n\t     ceph_cap_string(revoking));\n\tBUG_ON((retain & CEPH_CAP_PIN) == 0);\n\n\tsession = cap->session;\n\n\t/* don't release wanted unless we've waited a bit. */\n\tif ((ci->i_ceph_flags & CEPH_I_NODELAY) == 0 &&\n\t    time_before(jiffies, ci->i_hold_caps_min)) {\n\t\tdout(\" delaying issued %s -> %s, wanted %s -> %s on send\\n\",\n\t\t     ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(cap->issued & retain),\n\t\t     ceph_cap_string(cap->mds_wanted),\n\t\t     ceph_cap_string(want));\n\t\twant |= cap->mds_wanted;\n\t\tretain |= cap->issued;\n\t\tdelayed = 1;\n\t}\n\tci->i_ceph_flags &= ~(CEPH_I_NODELAY | CEPH_I_FLUSH);\n\n\tcap->issued &= retain;  /* drop bits we don't want */\n\tif (cap->implemented & ~cap->issued) {\n\t\t/*\n\t\t * Wake up any waiters on wanted -> needed transition.\n\t\t * This is due to the weird transition from buffered\n\t\t * to sync IO... we need to flush dirty pages _before_\n\t\t * allowing sync writes to avoid reordering.\n\t\t */\n\t\twake = 1;\n\t}\n\tcap->implemented &= cap->issued | used;\n\tcap->mds_wanted = want;\n\n\tif (flushing) {\n\t\t/*\n\t\t * assign a tid for flush operations so we can avoid\n\t\t * flush1 -> dirty1 -> flush2 -> flushack1 -> mark\n\t\t * clean type races.  track latest tid for every bit\n\t\t * so we can handle flush AxFw, flush Fw, and have the\n\t\t * first ack clean Ax.\n\t\t */\n\t\tflush_tid = ++ci->i_cap_flush_last_tid;\n\t\tif (pflush_tid)\n\t\t\t*pflush_tid = flush_tid;\n\t\tdout(\" cap_flush_tid %d\\n\", (int)flush_tid);\n\t\tfor (i = 0; i < CEPH_CAP_BITS; i++)\n\t\t\tif (flushing & (1 << i))\n\t\t\t\tci->i_cap_flush_tid[i] = flush_tid;\n\n\t\tfollows = ci->i_head_snapc->seq;\n\t} else {\n\t\tfollows = 0;\n\t}\n\n\tkeep = cap->implemented;\n\tseq = cap->seq;\n\tissue_seq = cap->issue_seq;\n\tmseq = cap->mseq;\n\tsize = inode->i_size;\n\tci->i_reported_size = size;\n\tmax_size = ci->i_wanted_max_size;\n\tci->i_requested_max_size = max_size;\n\tmtime = inode->i_mtime;\n\tatime = inode->i_atime;\n\ttime_warp_seq = ci->i_time_warp_seq;\n\tuid = inode->i_uid;\n\tgid = inode->i_gid;\n\tmode = inode->i_mode;\n\n\tif (flushing & CEPH_CAP_XATTR_EXCL) {\n\t\t__ceph_build_xattrs_blob(ci);\n\t\txattr_blob = ci->i_xattrs.blob;\n\t\txattr_version = ci->i_xattrs.version;\n\t}\n\n\tinline_data = ci->i_inline_version != CEPH_INLINE_NONE;\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tret = send_cap_msg(session, ceph_vino(inode).ino, cap_id,\n\t\top, keep, want, flushing, seq, flush_tid, issue_seq, mseq,\n\t\tsize, max_size, &mtime, &atime, time_warp_seq,\n\t\tuid, gid, mode, xattr_version, xattr_blob,\n\t\tfollows, inline_data);\n\tif (ret < 0) {\n\t\tdout(\"error sending cap msg, must requeue %p\\n\", inode);\n\t\tdelayed = 1;\n\t}\n\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\n\treturn delayed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__mark_caps_flushing",
          "args": [
            "inode",
            "session"
          ],
          "line": 1718
        },
        "resolved": true,
        "details": {
          "function_name": "__mark_caps_flushing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "1431-1467",
          "snippet": "static int __mark_caps_flushing(struct inode *inode,\n\t\t\t\t struct ceph_mds_session *session)\n{\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint flushing;\n\n\tBUG_ON(ci->i_dirty_caps == 0);\n\tBUG_ON(list_empty(&ci->i_dirty_item));\n\n\tflushing = ci->i_dirty_caps;\n\tdout(\"__mark_caps_flushing flushing %s, flushing_caps %s -> %s\\n\",\n\t     ceph_cap_string(flushing),\n\t     ceph_cap_string(ci->i_flushing_caps),\n\t     ceph_cap_string(ci->i_flushing_caps | flushing));\n\tci->i_flushing_caps |= flushing;\n\tci->i_dirty_caps = 0;\n\tdout(\" inode %p now !dirty\\n\", inode);\n\n\tspin_lock(&mdsc->cap_dirty_lock);\n\tlist_del_init(&ci->i_dirty_item);\n\n\tif (list_empty(&ci->i_flushing_item)) {\n\t\tci->i_cap_flush_seq = ++mdsc->cap_flush_seq;\n\t\tlist_add_tail(&ci->i_flushing_item, &session->s_cap_flushing);\n\t\tmdsc->num_cap_flushing++;\n\t\tdout(\" inode %p now flushing seq %lld\\n\", inode,\n\t\t     ci->i_cap_flush_seq);\n\t} else {\n\t\tlist_move_tail(&ci->i_flushing_item, &session->s_cap_flushing);\n\t\tdout(\" inode %p now flushing (more) seq %lld\\n\", inode,\n\t\t     ci->i_cap_flush_seq);\n\t}\n\tspin_unlock(&mdsc->cap_dirty_lock);\n\n\treturn flushing;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __mark_caps_flushing(struct inode *inode,\n\t\t\t\t struct ceph_mds_session *session)\n{\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint flushing;\n\n\tBUG_ON(ci->i_dirty_caps == 0);\n\tBUG_ON(list_empty(&ci->i_dirty_item));\n\n\tflushing = ci->i_dirty_caps;\n\tdout(\"__mark_caps_flushing flushing %s, flushing_caps %s -> %s\\n\",\n\t     ceph_cap_string(flushing),\n\t     ceph_cap_string(ci->i_flushing_caps),\n\t     ceph_cap_string(ci->i_flushing_caps | flushing));\n\tci->i_flushing_caps |= flushing;\n\tci->i_dirty_caps = 0;\n\tdout(\" inode %p now !dirty\\n\", inode);\n\n\tspin_lock(&mdsc->cap_dirty_lock);\n\tlist_del_init(&ci->i_dirty_item);\n\n\tif (list_empty(&ci->i_flushing_item)) {\n\t\tci->i_cap_flush_seq = ++mdsc->cap_flush_seq;\n\t\tlist_add_tail(&ci->i_flushing_item, &session->s_cap_flushing);\n\t\tmdsc->num_cap_flushing++;\n\t\tdout(\" inode %p now flushing seq %lld\\n\", inode,\n\t\t     ci->i_cap_flush_seq);\n\t} else {\n\t\tlist_move_tail(&ci->i_flushing_item, &session->s_cap_flushing);\n\t\tdout(\" inode %p now flushing (more) seq %lld\\n\", inode,\n\t\t     ci->i_cap_flush_seq);\n\t}\n\tspin_unlock(&mdsc->cap_dirty_lock);\n\n\treturn flushing;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&mdsc->snap_rwsem"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"inverting snap/in locks on %p\\n\"",
            "inode"
          ],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read_trylock",
          "args": [
            "&mdsc->snap_rwsem"
          ],
          "line": 1706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&session->s_mutex"
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mdsc->snap_rwsem"
          ],
          "line": 1697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"inverting session/ino locks on %p\\n\"",
            "session"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_trylock",
          "args": [
            "&session->s_mutex"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&session->s_mutex"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"oops, wrong session %p mutex\\n\"",
            "session"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" skipping %p I_NOFLUSH set\\n\"",
            "inode"
          ],
          "line": 1681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" delaying issued %s -> %s, wanted %s -> %s\\n\"",
            "ceph_cap_string(cap->issued)",
            "ceph_cap_string(cap->issued & retain)",
            "ceph_cap_string(cap->mds_wanted)",
            "ceph_cap_string(want)"
          ],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_cap_string",
          "args": [
            "want"
          ],
          "line": 1674
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_cap_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "71-116",
          "snippet": "const char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [
            "#define MAX_CAP_STR 20"
          ],
          "globals_used": [
            "static char cap_str[MAX_CAP_STR][40];",
            "static DEFINE_SPINLOCK(cap_str_lock);",
            "static int last_cap_str;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\n#define MAX_CAP_STR 20\n\nstatic char cap_str[MAX_CAP_STR][40];\nstatic DEFINE_SPINLOCK(cap_str_lock);\nstatic int last_cap_str;\n\nconst char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "jiffies",
            "ci->i_hold_caps_max"
          ],
          "line": 1669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"completed revocation of %s\\n\"",
            "ceph_cap_string(cap->implemented & ~cap->issued)"
          ],
          "line": 1650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"flushing dirty caps\\n\""
          ],
          "line": 1644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"i_size approaching max_size\\n\""
          ],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"requesting new max_size\\n\""
          ],
          "line": 1630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" mds%d cap %p used %s issued %s implemented %s revoking %s\\n\"",
            "cap->mds",
            "cap",
            "ceph_cap_string(cap->issued)",
            "ceph_cap_string(cap_used)",
            "ceph_cap_string(cap->implemented)",
            "ceph_cap_string(revoking)"
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "p",
            "structceph_cap",
            "ci_node"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "p"
          ],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&ci->i_caps"
          ],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__cap_set_timeouts",
          "args": [
            "mdsc",
            "ci"
          ],
          "line": 1595
        },
        "resolved": true,
        "details": {
          "function_name": "__cap_set_timeouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "397-408",
          "snippet": "static void __cap_set_timeouts(struct ceph_mds_client *mdsc,\n\t\t\t       struct ceph_inode_info *ci)\n{\n\tstruct ceph_mount_options *ma = mdsc->fsc->mount_options;\n\n\tci->i_hold_caps_min = round_jiffies(jiffies +\n\t\t\t\t\t    ma->caps_wanted_delay_min * HZ);\n\tci->i_hold_caps_max = round_jiffies(jiffies +\n\t\t\t\t\t    ma->caps_wanted_delay_max * HZ);\n\tdout(\"__cap_set_timeouts %p min %lu max %lu\\n\", &ci->vfs_inode,\n\t     ci->i_hold_caps_min - jiffies, ci->i_hold_caps_max - jiffies);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __cap_set_timeouts(struct ceph_mds_client *mdsc,\n\t\t\t       struct ceph_inode_info *ci)\n{\n\tstruct ceph_mount_options *ma = mdsc->fsc->mount_options;\n\n\tci->i_hold_caps_min = round_jiffies(jiffies +\n\t\t\t\t\t    ma->caps_wanted_delay_min * HZ);\n\tci->i_hold_caps_max = round_jiffies(jiffies +\n\t\t\t\t\t    ma->caps_wanted_delay_max * HZ);\n\tdout(\"__cap_set_timeouts %p min %lu max %lu\\n\", &ci->vfs_inode,\n\t     ci->i_hold_caps_min - jiffies, ci->i_hold_caps_max - jiffies);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"check_caps failed to invalidate pages\\n\""
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"check_caps queuing invalidate\\n\""
          ],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_nonblocking_invalidate",
          "args": [
            "inode"
          ],
          "line": 1584
        },
        "resolved": true,
        "details": {
          "function_name": "try_nonblocking_invalidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "1472-1491",
          "snippet": "static int try_nonblocking_invalidate(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tu32 invalidating_gen = ci->i_rdcache_gen;\n\n\tspin_unlock(&ci->i_ceph_lock);\n\tinvalidate_mapping_pages(&inode->i_data, 0, -1);\n\tspin_lock(&ci->i_ceph_lock);\n\n\tif (inode->i_data.nrpages == 0 &&\n\t    invalidating_gen == ci->i_rdcache_gen) {\n\t\t/* success. */\n\t\tdout(\"try_nonblocking_invalidate %p success\\n\", inode);\n\t\t/* save any racing async invalidate some trouble */\n\t\tci->i_rdcache_revoking = ci->i_rdcache_gen - 1;\n\t\treturn 0;\n\t}\n\tdout(\"try_nonblocking_invalidate %p failed\\n\", inode);\n\treturn -1;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int try_nonblocking_invalidate(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tu32 invalidating_gen = ci->i_rdcache_gen;\n\n\tspin_unlock(&ci->i_ceph_lock);\n\tinvalidate_mapping_pages(&inode->i_data, 0, -1);\n\tspin_lock(&ci->i_ceph_lock);\n\n\tif (inode->i_data.nrpages == 0 &&\n\t    invalidating_gen == ci->i_rdcache_gen) {\n\t\t/* success. */\n\t\tdout(\"try_nonblocking_invalidate %p success\\n\", inode);\n\t\t/* save any racing async invalidate some trouble */\n\t\tci->i_rdcache_revoking = ci->i_rdcache_gen - 1;\n\t\treturn 0;\n\t}\n\tdout(\"try_nonblocking_invalidate %p failed\\n\", inode);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"check_caps trying to invalidate on %p\\n\"",
            "inode"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"check_caps %p file_want %s used %s dirty %s flushing %s\"\n\t     \" issued %s revoking %s retain %s %s%s%s\\n\"",
            "inode",
            "ceph_cap_string(file_wanted)",
            "ceph_cap_string(used)",
            "ceph_cap_string(ci->i_dirty_caps)",
            "ceph_cap_string(ci->i_flushing_caps)",
            "ceph_cap_string(issued)",
            "ceph_cap_string(revoking)",
            "ceph_cap_string(retain)",
            "(flags & CHECK_CAPS_AUTHONLY) ? \" AUTHONLY\" : \"\"",
            "(flags & CHECK_CAPS_NODELAY) ? \" NODELAY\" : \"\"",
            "(flags & CHECK_CAPS_FLUSH) ? \" FLUSH\" : \"\""
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ceph_caps_issued",
          "args": [
            "ci",
            "&implemented"
          ],
          "line": 1541
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_caps_issued_other",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "700-715",
          "snippet": "int __ceph_caps_issued_other(struct ceph_inode_info *ci, struct ceph_cap *ocap)\n{\n\tint have = ci->i_snap_caps;\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (cap == ocap)\n\t\t\tcontinue;\n\t\tif (!__cap_is_valid(cap))\n\t\t\tcontinue;\n\t\thave |= cap->issued;\n\t}\n\treturn have;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_caps_issued_other(struct ceph_inode_info *ci, struct ceph_cap *ocap)\n{\n\tint have = ci->i_snap_caps;\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (cap == ocap)\n\t\t\tcontinue;\n\t\tif (!__cap_is_valid(cap))\n\t\t\tcontinue;\n\t\thave |= cap->issued;\n\t}\n\treturn have;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_caps_used",
          "args": [
            "ci"
          ],
          "line": 1539
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_caps_used",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "829-843",
          "snippet": "int __ceph_caps_used(struct ceph_inode_info *ci)\n{\n\tint used = 0;\n\tif (ci->i_pin_ref)\n\t\tused |= CEPH_CAP_PIN;\n\tif (ci->i_rd_ref)\n\t\tused |= CEPH_CAP_FILE_RD;\n\tif (ci->i_rdcache_ref || ci->vfs_inode.i_data.nrpages)\n\t\tused |= CEPH_CAP_FILE_CACHE;\n\tif (ci->i_wr_ref)\n\t\tused |= CEPH_CAP_FILE_WR;\n\tif (ci->i_wb_ref || ci->i_wrbuffer_ref)\n\t\tused |= CEPH_CAP_FILE_BUFFER;\n\treturn used;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_caps_used(struct ceph_inode_info *ci)\n{\n\tint used = 0;\n\tif (ci->i_pin_ref)\n\t\tused |= CEPH_CAP_PIN;\n\tif (ci->i_rd_ref)\n\t\tused |= CEPH_CAP_FILE_RD;\n\tif (ci->i_rdcache_ref || ci->vfs_inode.i_data.nrpages)\n\t\tused |= CEPH_CAP_FILE_CACHE;\n\tif (ci->i_wr_ref)\n\t\tused |= CEPH_CAP_FILE_WR;\n\tif (ci->i_wb_ref || ci->i_wrbuffer_ref)\n\t\tused |= CEPH_CAP_FILE_BUFFER;\n\treturn used;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_caps_file_wanted",
          "args": [
            "ci"
          ],
          "line": 1538
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_caps_file_wanted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "848-856",
          "snippet": "int __ceph_caps_file_wanted(struct ceph_inode_info *ci)\n{\n\tint want = 0;\n\tint mode;\n\tfor (mode = 0; mode < CEPH_FILE_MODE_NUM; mode++)\n\t\tif (ci->i_nr_by_mode[mode])\n\t\t\twant |= ceph_caps_for_mode(mode);\n\treturn want;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_caps_file_wanted(struct ceph_inode_info *ci)\n{\n\tint want = 0;\n\tint mode;\n\tfor (mode = 0; mode < CEPH_FILE_MODE_NUM; mode++)\n\t\tif (ci->i_nr_by_mode[mode])\n\t\t\twant |= ceph_caps_for_mode(mode);\n\treturn want;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_flush_snaps",
          "args": [
            "ci",
            "&session",
            "0"
          ],
          "line": 1533
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_flush_snaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "1257-1375",
          "snippet": "void __ceph_flush_snaps(struct ceph_inode_info *ci,\n\t\t\tstruct ceph_mds_session **psession,\n\t\t\tint again)\n\t\t__releases(ci->i_ceph_lock)\n\t\t__acquires(ci->i_ceph_lock)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint mds;\n\tstruct ceph_cap_snap *capsnap;\n\tu32 mseq;\n\tstruct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;\n\tstruct ceph_mds_session *session = NULL; /* if session != NULL, we hold\n\t\t\t\t\t\t    session->s_mutex */\n\tu64 next_follows = 0;  /* keep track of how far we've gotten through the\n\t\t\t     i_cap_snaps list, and skip these entries next time\n\t\t\t     around to avoid an infinite loop */\n\n\tif (psession)\n\t\tsession = *psession;\n\n\tdout(\"__flush_snaps %p\\n\", inode);\nretry:\n\tlist_for_each_entry(capsnap, &ci->i_cap_snaps, ci_item) {\n\t\t/* avoid an infiniute loop after retry */\n\t\tif (capsnap->follows < next_follows)\n\t\t\tcontinue;\n\t\t/*\n\t\t * we need to wait for sync writes to complete and for dirty\n\t\t * pages to be written out.\n\t\t */\n\t\tif (capsnap->dirty_pages || capsnap->writing)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * if cap writeback already occurred, we should have dropped\n\t\t * the capsnap in ceph_put_wrbuffer_cap_refs.\n\t\t */\n\t\tBUG_ON(capsnap->dirty == 0);\n\n\t\t/* pick mds, take s_mutex */\n\t\tif (ci->i_auth_cap == NULL) {\n\t\t\tdout(\"no auth cap (migrating?), doing nothing\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* only flush each capsnap once */\n\t\tif (!again && !list_empty(&capsnap->flushing_item)) {\n\t\t\tdout(\"already flushed %p, skipping\\n\", capsnap);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmds = ci->i_auth_cap->session->s_mds;\n\t\tmseq = ci->i_auth_cap->mseq;\n\n\t\tif (session && session->s_mds != mds) {\n\t\t\tdout(\"oops, wrong session %p mutex\\n\", session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tceph_put_mds_session(session);\n\t\t\tsession = NULL;\n\t\t}\n\t\tif (!session) {\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\tmutex_lock(&mdsc->mutex);\n\t\t\tsession = __ceph_lookup_mds_session(mdsc, mds);\n\t\t\tmutex_unlock(&mdsc->mutex);\n\t\t\tif (session) {\n\t\t\t\tdout(\"inverting session/ino locks on %p\\n\",\n\t\t\t\t     session);\n\t\t\t\tmutex_lock(&session->s_mutex);\n\t\t\t}\n\t\t\t/*\n\t\t\t * if session == NULL, we raced against a cap\n\t\t\t * deletion or migration.  retry, and we'll\n\t\t\t * get a better @mds value next time.\n\t\t\t */\n\t\t\tspin_lock(&ci->i_ceph_lock);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tcapsnap->flush_tid = ++ci->i_cap_flush_last_tid;\n\t\tatomic_inc(&capsnap->nref);\n\t\tif (!list_empty(&capsnap->flushing_item))\n\t\t\tlist_del_init(&capsnap->flushing_item);\n\t\tlist_add_tail(&capsnap->flushing_item,\n\t\t\t      &session->s_cap_snaps_flushing);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\n\t\tdout(\"flush_snaps %p cap_snap %p follows %lld tid %llu\\n\",\n\t\t     inode, capsnap, capsnap->follows, capsnap->flush_tid);\n\t\tsend_cap_msg(session, ceph_vino(inode).ino, 0,\n\t\t\t     CEPH_CAP_OP_FLUSHSNAP, capsnap->issued, 0,\n\t\t\t     capsnap->dirty, 0, capsnap->flush_tid, 0, mseq,\n\t\t\t     capsnap->size, 0,\n\t\t\t     &capsnap->mtime, &capsnap->atime,\n\t\t\t     capsnap->time_warp_seq,\n\t\t\t     capsnap->uid, capsnap->gid, capsnap->mode,\n\t\t\t     capsnap->xattr_version, capsnap->xattr_blob,\n\t\t\t     capsnap->follows, capsnap->inline_data);\n\n\t\tnext_follows = capsnap->follows + 1;\n\t\tceph_put_cap_snap(capsnap);\n\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tgoto retry;\n\t}\n\n\t/* we flushed them all; remove this inode from the queue */\n\tspin_lock(&mdsc->snap_flush_lock);\n\tlist_del_init(&ci->i_snap_flush_item);\n\tspin_unlock(&mdsc->snap_flush_lock);\n\nout:\n\tif (psession)\n\t\t*psession = session;\n\telse if (session) {\n\t\tmutex_unlock(&session->s_mutex);\n\t\tceph_put_mds_session(session);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid __ceph_flush_snaps(struct ceph_inode_info *ci,\n\t\t\tstruct ceph_mds_session **psession,\n\t\t\tint again)\n\t\t__releases(ci->i_ceph_lock)\n\t\t__acquires(ci->i_ceph_lock)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint mds;\n\tstruct ceph_cap_snap *capsnap;\n\tu32 mseq;\n\tstruct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;\n\tstruct ceph_mds_session *session = NULL; /* if session != NULL, we hold\n\t\t\t\t\t\t    session->s_mutex */\n\tu64 next_follows = 0;  /* keep track of how far we've gotten through the\n\t\t\t     i_cap_snaps list, and skip these entries next time\n\t\t\t     around to avoid an infinite loop */\n\n\tif (psession)\n\t\tsession = *psession;\n\n\tdout(\"__flush_snaps %p\\n\", inode);\nretry:\n\tlist_for_each_entry(capsnap, &ci->i_cap_snaps, ci_item) {\n\t\t/* avoid an infiniute loop after retry */\n\t\tif (capsnap->follows < next_follows)\n\t\t\tcontinue;\n\t\t/*\n\t\t * we need to wait for sync writes to complete and for dirty\n\t\t * pages to be written out.\n\t\t */\n\t\tif (capsnap->dirty_pages || capsnap->writing)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * if cap writeback already occurred, we should have dropped\n\t\t * the capsnap in ceph_put_wrbuffer_cap_refs.\n\t\t */\n\t\tBUG_ON(capsnap->dirty == 0);\n\n\t\t/* pick mds, take s_mutex */\n\t\tif (ci->i_auth_cap == NULL) {\n\t\t\tdout(\"no auth cap (migrating?), doing nothing\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* only flush each capsnap once */\n\t\tif (!again && !list_empty(&capsnap->flushing_item)) {\n\t\t\tdout(\"already flushed %p, skipping\\n\", capsnap);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmds = ci->i_auth_cap->session->s_mds;\n\t\tmseq = ci->i_auth_cap->mseq;\n\n\t\tif (session && session->s_mds != mds) {\n\t\t\tdout(\"oops, wrong session %p mutex\\n\", session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tceph_put_mds_session(session);\n\t\t\tsession = NULL;\n\t\t}\n\t\tif (!session) {\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\tmutex_lock(&mdsc->mutex);\n\t\t\tsession = __ceph_lookup_mds_session(mdsc, mds);\n\t\t\tmutex_unlock(&mdsc->mutex);\n\t\t\tif (session) {\n\t\t\t\tdout(\"inverting session/ino locks on %p\\n\",\n\t\t\t\t     session);\n\t\t\t\tmutex_lock(&session->s_mutex);\n\t\t\t}\n\t\t\t/*\n\t\t\t * if session == NULL, we raced against a cap\n\t\t\t * deletion or migration.  retry, and we'll\n\t\t\t * get a better @mds value next time.\n\t\t\t */\n\t\t\tspin_lock(&ci->i_ceph_lock);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tcapsnap->flush_tid = ++ci->i_cap_flush_last_tid;\n\t\tatomic_inc(&capsnap->nref);\n\t\tif (!list_empty(&capsnap->flushing_item))\n\t\t\tlist_del_init(&capsnap->flushing_item);\n\t\tlist_add_tail(&capsnap->flushing_item,\n\t\t\t      &session->s_cap_snaps_flushing);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\n\t\tdout(\"flush_snaps %p cap_snap %p follows %lld tid %llu\\n\",\n\t\t     inode, capsnap, capsnap->follows, capsnap->flush_tid);\n\t\tsend_cap_msg(session, ceph_vino(inode).ino, 0,\n\t\t\t     CEPH_CAP_OP_FLUSHSNAP, capsnap->issued, 0,\n\t\t\t     capsnap->dirty, 0, capsnap->flush_tid, 0, mseq,\n\t\t\t     capsnap->size, 0,\n\t\t\t     &capsnap->mtime, &capsnap->atime,\n\t\t\t     capsnap->time_warp_seq,\n\t\t\t     capsnap->uid, capsnap->gid, capsnap->mode,\n\t\t\t     capsnap->xattr_version, capsnap->xattr_blob,\n\t\t\t     capsnap->follows, capsnap->inline_data);\n\n\t\tnext_follows = capsnap->follows + 1;\n\t\tceph_put_cap_snap(capsnap);\n\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tgoto retry;\n\t}\n\n\t/* we flushed them all; remove this inode from the queue */\n\tspin_lock(&mdsc->snap_flush_lock);\n\tlist_del_init(&ci->i_snap_flush_item);\n\tspin_unlock(&mdsc->snap_flush_lock);\n\nout:\n\tif (psession)\n\t\t*psession = session;\n\telse if (session) {\n\t\tmutex_unlock(&session->s_mutex);\n\t\tceph_put_mds_session(session);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ci->i_cap_snaps"
          ],
          "line": 1532
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode_to_client",
          "args": [
            "&ci->vfs_inode"
          ],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_check_caps(struct ceph_inode_info *ci, int flags,\n\t\t     struct ceph_mds_session *session)\n{\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(&ci->vfs_inode);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct inode *inode = &ci->vfs_inode;\n\tstruct ceph_cap *cap;\n\tint file_wanted, used, cap_used;\n\tint took_snap_rwsem = 0;             /* true if mdsc->snap_rwsem held */\n\tint issued, implemented, want, retain, revoking, flushing = 0;\n\tint mds = -1;   /* keep track of how far we've gone through i_caps list\n\t\t\t   to avoid an infinite loop on retry */\n\tstruct rb_node *p;\n\tint tried_invalidate = 0;\n\tint delayed = 0, sent = 0, force_requeue = 0, num;\n\tint queue_invalidate = 0;\n\tint is_delayed = flags & CHECK_CAPS_NODELAY;\n\n\t/* if we are unmounting, flush any unused caps immediately. */\n\tif (mdsc->stopping)\n\t\tis_delayed = 1;\n\n\tspin_lock(&ci->i_ceph_lock);\n\n\tif (ci->i_ceph_flags & CEPH_I_FLUSH)\n\t\tflags |= CHECK_CAPS_FLUSH;\n\n\t/* flush snaps first time around only */\n\tif (!list_empty(&ci->i_cap_snaps))\n\t\t__ceph_flush_snaps(ci, &session, 0);\n\tgoto retry_locked;\nretry:\n\tspin_lock(&ci->i_ceph_lock);\nretry_locked:\n\tfile_wanted = __ceph_caps_file_wanted(ci);\n\tused = __ceph_caps_used(ci);\n\twant = file_wanted | used;\n\tissued = __ceph_caps_issued(ci, &implemented);\n\trevoking = implemented & ~issued;\n\n\tretain = want | CEPH_CAP_PIN;\n\tif (!mdsc->stopping && inode->i_nlink > 0) {\n\t\tif (want) {\n\t\t\tretain |= CEPH_CAP_ANY;       /* be greedy */\n\t\t} else {\n\t\t\tretain |= CEPH_CAP_ANY_SHARED;\n\t\t\t/*\n\t\t\t * keep RD only if we didn't have the file open RW,\n\t\t\t * because then the mds would revoke it anyway to\n\t\t\t * journal max_size=0.\n\t\t\t */\n\t\t\tif (ci->i_max_size == 0)\n\t\t\t\tretain |= CEPH_CAP_ANY_RD;\n\t\t}\n\t}\n\n\tdout(\"check_caps %p file_want %s used %s dirty %s flushing %s\"\n\t     \" issued %s revoking %s retain %s %s%s%s\\n\", inode,\n\t     ceph_cap_string(file_wanted),\n\t     ceph_cap_string(used), ceph_cap_string(ci->i_dirty_caps),\n\t     ceph_cap_string(ci->i_flushing_caps),\n\t     ceph_cap_string(issued), ceph_cap_string(revoking),\n\t     ceph_cap_string(retain),\n\t     (flags & CHECK_CAPS_AUTHONLY) ? \" AUTHONLY\" : \"\",\n\t     (flags & CHECK_CAPS_NODELAY) ? \" NODELAY\" : \"\",\n\t     (flags & CHECK_CAPS_FLUSH) ? \" FLUSH\" : \"\");\n\n\t/*\n\t * If we no longer need to hold onto old our caps, and we may\n\t * have cached pages, but don't want them, then try to invalidate.\n\t * If we fail, it's because pages are locked.... try again later.\n\t */\n\tif ((!is_delayed || mdsc->stopping) &&\n\t    ci->i_wrbuffer_ref == 0 &&               /* no dirty pages... */\n\t    inode->i_data.nrpages &&                 /* have cached pages */\n\t    (file_wanted == 0 ||                     /* no open files */\n\t     (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t  CEPH_CAP_FILE_LAZYIO))) && /*  or revoking cache */\n\t    !tried_invalidate) {\n\t\tdout(\"check_caps trying to invalidate on %p\\n\", inode);\n\t\tif (try_nonblocking_invalidate(inode) < 0) {\n\t\t\tif (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t\t\tCEPH_CAP_FILE_LAZYIO)) {\n\t\t\t\tdout(\"check_caps queuing invalidate\\n\");\n\t\t\t\tqueue_invalidate = 1;\n\t\t\t\tci->i_rdcache_revoking = ci->i_rdcache_gen;\n\t\t\t} else {\n\t\t\t\tdout(\"check_caps failed to invalidate pages\\n\");\n\t\t\t\t/* we failed to invalidate pages.  check these\n\t\t\t\t   caps again later. */\n\t\t\t\tforce_requeue = 1;\n\t\t\t\t__cap_set_timeouts(mdsc, ci);\n\t\t\t}\n\t\t}\n\t\ttried_invalidate = 1;\n\t\tgoto retry_locked;\n\t}\n\n\tnum = 0;\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tnum++;\n\n\t\t/* avoid looping forever */\n\t\tif (mds >= cap->mds ||\n\t\t    ((flags & CHECK_CAPS_AUTHONLY) && cap != ci->i_auth_cap))\n\t\t\tcontinue;\n\n\t\t/* NOTE: no side-effects allowed, until we take s_mutex */\n\n\t\tcap_used = used;\n\t\tif (ci->i_auth_cap && cap != ci->i_auth_cap)\n\t\t\tcap_used &= ~ci->i_auth_cap->issued;\n\n\t\trevoking = cap->implemented & ~cap->issued;\n\t\tdout(\" mds%d cap %p used %s issued %s implemented %s revoking %s\\n\",\n\t\t     cap->mds, cap, ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(cap_used),\n\t\t     ceph_cap_string(cap->implemented),\n\t\t     ceph_cap_string(revoking));\n\n\t\tif (cap == ci->i_auth_cap &&\n\t\t    (cap->issued & CEPH_CAP_FILE_WR)) {\n\t\t\t/* request larger max_size from MDS? */\n\t\t\tif (ci->i_wanted_max_size > ci->i_max_size &&\n\t\t\t    ci->i_wanted_max_size > ci->i_requested_max_size) {\n\t\t\t\tdout(\"requesting new max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\n\t\t\t/* approaching file_max? */\n\t\t\tif ((inode->i_size << 1) >= ci->i_max_size &&\n\t\t\t    (ci->i_reported_size << 1) < ci->i_max_size) {\n\t\t\t\tdout(\"i_size approaching max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\t\t}\n\t\t/* flush anything dirty? */\n\t\tif (cap == ci->i_auth_cap && (flags & CHECK_CAPS_FLUSH) &&\n\t\t    ci->i_dirty_caps) {\n\t\t\tdout(\"flushing dirty caps\\n\");\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* completed revocation? going down and there are no caps? */\n\t\tif (revoking && (revoking & cap_used) == 0) {\n\t\t\tdout(\"completed revocation of %s\\n\",\n\t\t\t     ceph_cap_string(cap->implemented & ~cap->issued));\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* want more caps from mds? */\n\t\tif (want & ~(cap->mds_wanted | cap->issued))\n\t\t\tgoto ack;\n\n\t\t/* things we might delay */\n\t\tif ((cap->issued & ~retain) == 0 &&\n\t\t    cap->mds_wanted == want)\n\t\t\tcontinue;     /* nope, all good */\n\n\t\tif (is_delayed)\n\t\t\tgoto ack;\n\n\t\t/* delay? */\n\t\tif ((ci->i_ceph_flags & CEPH_I_NODELAY) == 0 &&\n\t\t    time_before(jiffies, ci->i_hold_caps_max)) {\n\t\t\tdout(\" delaying issued %s -> %s, wanted %s -> %s\\n\",\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(cap->issued & retain),\n\t\t\t     ceph_cap_string(cap->mds_wanted),\n\t\t\t     ceph_cap_string(want));\n\t\t\tdelayed++;\n\t\t\tcontinue;\n\t\t}\n\nack:\n\t\tif (ci->i_ceph_flags & CEPH_I_NOFLUSH) {\n\t\t\tdout(\" skipping %p I_NOFLUSH set\\n\", inode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (session && session != cap->session) {\n\t\t\tdout(\"oops, wrong session %p mutex\\n\", session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tsession = NULL;\n\t\t}\n\t\tif (!session) {\n\t\t\tsession = cap->session;\n\t\t\tif (mutex_trylock(&session->s_mutex) == 0) {\n\t\t\t\tdout(\"inverting session/ino locks on %p\\n\",\n\t\t\t\t     session);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tif (took_snap_rwsem) {\n\t\t\t\t\tup_read(&mdsc->snap_rwsem);\n\t\t\t\t\ttook_snap_rwsem = 0;\n\t\t\t\t}\n\t\t\t\tmutex_lock(&session->s_mutex);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t\t/* take snap_rwsem after session mutex */\n\t\tif (!took_snap_rwsem) {\n\t\t\tif (down_read_trylock(&mdsc->snap_rwsem) == 0) {\n\t\t\t\tdout(\"inverting snap/in locks on %p\\n\",\n\t\t\t\t     inode);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tdown_read(&mdsc->snap_rwsem);\n\t\t\t\ttook_snap_rwsem = 1;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\ttook_snap_rwsem = 1;\n\t\t}\n\n\t\tif (cap == ci->i_auth_cap && ci->i_dirty_caps)\n\t\t\tflushing = __mark_caps_flushing(inode, session);\n\t\telse\n\t\t\tflushing = 0;\n\n\t\tmds = cap->mds;  /* remember mds, so we don't repeat */\n\t\tsent++;\n\n\t\t/* __send_cap drops i_ceph_lock */\n\t\tdelayed += __send_cap(mdsc, cap, CEPH_CAP_OP_UPDATE, cap_used,\n\t\t\t\t      want, retain, flushing, NULL);\n\t\tgoto retry; /* retake i_ceph_lock and restart our cap scan. */\n\t}\n\n\t/*\n\t * Reschedule delayed caps release if we delayed anything,\n\t * otherwise cancel.\n\t */\n\tif (delayed && is_delayed)\n\t\tforce_requeue = 1;   /* __send_cap delayed release; requeue */\n\tif (!delayed && !is_delayed)\n\t\t__cap_delay_cancel(mdsc, ci);\n\telse if (!is_delayed || force_requeue)\n\t\t__cap_delay_requeue(mdsc, ci);\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (queue_invalidate)\n\t\tceph_queue_invalidate(inode);\n\n\tif (session)\n\t\tmutex_unlock(&session->s_mutex);\n\tif (took_snap_rwsem)\n\t\tup_read(&mdsc->snap_rwsem);\n}"
  },
  {
    "function_name": "try_nonblocking_invalidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "1472-1491",
    "snippet": "static int try_nonblocking_invalidate(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tu32 invalidating_gen = ci->i_rdcache_gen;\n\n\tspin_unlock(&ci->i_ceph_lock);\n\tinvalidate_mapping_pages(&inode->i_data, 0, -1);\n\tspin_lock(&ci->i_ceph_lock);\n\n\tif (inode->i_data.nrpages == 0 &&\n\t    invalidating_gen == ci->i_rdcache_gen) {\n\t\t/* success. */\n\t\tdout(\"try_nonblocking_invalidate %p success\\n\", inode);\n\t\t/* save any racing async invalidate some trouble */\n\t\tci->i_rdcache_revoking = ci->i_rdcache_gen - 1;\n\t\treturn 0;\n\t}\n\tdout(\"try_nonblocking_invalidate %p failed\\n\", inode);\n\treturn -1;\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"try_nonblocking_invalidate %p failed\\n\"",
            "inode"
          ],
          "line": 1489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"try_nonblocking_invalidate %p success\\n\"",
            "inode"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 1479
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "invalidate_mapping_pages",
          "args": [
            "&inode->i_data",
            "0",
            "-1"
          ],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 1477
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 1474
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int try_nonblocking_invalidate(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tu32 invalidating_gen = ci->i_rdcache_gen;\n\n\tspin_unlock(&ci->i_ceph_lock);\n\tinvalidate_mapping_pages(&inode->i_data, 0, -1);\n\tspin_lock(&ci->i_ceph_lock);\n\n\tif (inode->i_data.nrpages == 0 &&\n\t    invalidating_gen == ci->i_rdcache_gen) {\n\t\t/* success. */\n\t\tdout(\"try_nonblocking_invalidate %p success\\n\", inode);\n\t\t/* save any racing async invalidate some trouble */\n\t\tci->i_rdcache_revoking = ci->i_rdcache_gen - 1;\n\t\treturn 0;\n\t}\n\tdout(\"try_nonblocking_invalidate %p failed\\n\", inode);\n\treturn -1;\n}"
  },
  {
    "function_name": "__mark_caps_flushing",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "1431-1467",
    "snippet": "static int __mark_caps_flushing(struct inode *inode,\n\t\t\t\t struct ceph_mds_session *session)\n{\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint flushing;\n\n\tBUG_ON(ci->i_dirty_caps == 0);\n\tBUG_ON(list_empty(&ci->i_dirty_item));\n\n\tflushing = ci->i_dirty_caps;\n\tdout(\"__mark_caps_flushing flushing %s, flushing_caps %s -> %s\\n\",\n\t     ceph_cap_string(flushing),\n\t     ceph_cap_string(ci->i_flushing_caps),\n\t     ceph_cap_string(ci->i_flushing_caps | flushing));\n\tci->i_flushing_caps |= flushing;\n\tci->i_dirty_caps = 0;\n\tdout(\" inode %p now !dirty\\n\", inode);\n\n\tspin_lock(&mdsc->cap_dirty_lock);\n\tlist_del_init(&ci->i_dirty_item);\n\n\tif (list_empty(&ci->i_flushing_item)) {\n\t\tci->i_cap_flush_seq = ++mdsc->cap_flush_seq;\n\t\tlist_add_tail(&ci->i_flushing_item, &session->s_cap_flushing);\n\t\tmdsc->num_cap_flushing++;\n\t\tdout(\" inode %p now flushing seq %lld\\n\", inode,\n\t\t     ci->i_cap_flush_seq);\n\t} else {\n\t\tlist_move_tail(&ci->i_flushing_item, &session->s_cap_flushing);\n\t\tdout(\" inode %p now flushing (more) seq %lld\\n\", inode,\n\t\t     ci->i_cap_flush_seq);\n\t}\n\tspin_unlock(&mdsc->cap_dirty_lock);\n\n\treturn flushing;\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mdsc->cap_dirty_lock"
          ],
          "line": 1464
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" inode %p now flushing (more) seq %lld\\n\"",
            "inode",
            "ci->i_cap_flush_seq"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&ci->i_flushing_item",
            "&session->s_cap_flushing"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" inode %p now flushing seq %lld\\n\"",
            "inode",
            "ci->i_cap_flush_seq"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&ci->i_flushing_item",
            "&session->s_cap_flushing"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ci->i_flushing_item"
          ],
          "line": 1453
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&ci->i_dirty_item"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mdsc->cap_dirty_lock"
          ],
          "line": 1450
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" inode %p now !dirty\\n\"",
            "inode"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"__mark_caps_flushing flushing %s, flushing_caps %s -> %s\\n\"",
            "ceph_cap_string(flushing)",
            "ceph_cap_string(ci->i_flushing_caps)",
            "ceph_cap_string(ci->i_flushing_caps | flushing)"
          ],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_cap_string",
          "args": [
            "ci->i_flushing_caps | flushing"
          ],
          "line": 1445
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_cap_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "71-116",
          "snippet": "const char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [
            "#define MAX_CAP_STR 20"
          ],
          "globals_used": [
            "static char cap_str[MAX_CAP_STR][40];",
            "static DEFINE_SPINLOCK(cap_str_lock);",
            "static int last_cap_str;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\n#define MAX_CAP_STR 20\n\nstatic char cap_str[MAX_CAP_STR][40];\nstatic DEFINE_SPINLOCK(cap_str_lock);\nstatic int last_cap_str;\n\nconst char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "list_empty(&ci->i_dirty_item)"
          ],
          "line": 1439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ci->i_dirty_caps == 0"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 1435
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_sb_to_client",
          "args": [
            "inode->i_sb"
          ],
          "line": 1434
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_sb_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "352-355",
          "snippet": "static inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __mark_caps_flushing(struct inode *inode,\n\t\t\t\t struct ceph_mds_session *session)\n{\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint flushing;\n\n\tBUG_ON(ci->i_dirty_caps == 0);\n\tBUG_ON(list_empty(&ci->i_dirty_item));\n\n\tflushing = ci->i_dirty_caps;\n\tdout(\"__mark_caps_flushing flushing %s, flushing_caps %s -> %s\\n\",\n\t     ceph_cap_string(flushing),\n\t     ceph_cap_string(ci->i_flushing_caps),\n\t     ceph_cap_string(ci->i_flushing_caps | flushing));\n\tci->i_flushing_caps |= flushing;\n\tci->i_dirty_caps = 0;\n\tdout(\" inode %p now !dirty\\n\", inode);\n\n\tspin_lock(&mdsc->cap_dirty_lock);\n\tlist_del_init(&ci->i_dirty_item);\n\n\tif (list_empty(&ci->i_flushing_item)) {\n\t\tci->i_cap_flush_seq = ++mdsc->cap_flush_seq;\n\t\tlist_add_tail(&ci->i_flushing_item, &session->s_cap_flushing);\n\t\tmdsc->num_cap_flushing++;\n\t\tdout(\" inode %p now flushing seq %lld\\n\", inode,\n\t\t     ci->i_cap_flush_seq);\n\t} else {\n\t\tlist_move_tail(&ci->i_flushing_item, &session->s_cap_flushing);\n\t\tdout(\" inode %p now flushing (more) seq %lld\\n\", inode,\n\t\t     ci->i_cap_flush_seq);\n\t}\n\tspin_unlock(&mdsc->cap_dirty_lock);\n\n\treturn flushing;\n}"
  },
  {
    "function_name": "__ceph_mark_dirty_caps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "1389-1423",
    "snippet": "int __ceph_mark_dirty_caps(struct ceph_inode_info *ci, int mask)\n{\n\tstruct ceph_mds_client *mdsc =\n\t\tceph_sb_to_client(ci->vfs_inode.i_sb)->mdsc;\n\tstruct inode *inode = &ci->vfs_inode;\n\tint was = ci->i_dirty_caps;\n\tint dirty = 0;\n\n\tdout(\"__mark_dirty_caps %p %s dirty %s -> %s\\n\", &ci->vfs_inode,\n\t     ceph_cap_string(mask), ceph_cap_string(was),\n\t     ceph_cap_string(was | mask));\n\tci->i_dirty_caps |= mask;\n\tif (was == 0) {\n\t\tif (!ci->i_head_snapc)\n\t\t\tci->i_head_snapc = ceph_get_snap_context(\n\t\t\t\tci->i_snap_realm->cached_context);\n\t\tdout(\" inode %p now dirty snapc %p auth cap %p\\n\",\n\t\t     &ci->vfs_inode, ci->i_head_snapc, ci->i_auth_cap);\n\t\tWARN_ON(!ci->i_auth_cap);\n\t\tBUG_ON(!list_empty(&ci->i_dirty_item));\n\t\tspin_lock(&mdsc->cap_dirty_lock);\n\t\tlist_add(&ci->i_dirty_item, &mdsc->cap_dirty);\n\t\tspin_unlock(&mdsc->cap_dirty_lock);\n\t\tif (ci->i_flushing_caps == 0) {\n\t\t\tihold(inode);\n\t\t\tdirty |= I_DIRTY_SYNC;\n\t\t}\n\t}\n\tBUG_ON(list_empty(&ci->i_dirty_item));\n\tif (((was | ci->i_flushing_caps) & CEPH_CAP_FILE_BUFFER) &&\n\t    (mask & CEPH_CAP_FILE_BUFFER))\n\t\tdirty |= I_DIRTY_DATASYNC;\n\t__cap_delay_requeue(mdsc, ci);\n\treturn dirty;\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__cap_delay_requeue",
          "args": [
            "mdsc",
            "ci"
          ],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "__cap_delay_requeue_front",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "442-452",
          "snippet": "static void __cap_delay_requeue_front(struct ceph_mds_client *mdsc,\n\t\t\t\t      struct ceph_inode_info *ci)\n{\n\tdout(\"__cap_delay_requeue_front %p\\n\", &ci->vfs_inode);\n\tspin_lock(&mdsc->cap_delay_lock);\n\tci->i_ceph_flags |= CEPH_I_FLUSH;\n\tif (!list_empty(&ci->i_cap_delay_list))\n\t\tlist_del_init(&ci->i_cap_delay_list);\n\tlist_add(&ci->i_cap_delay_list, &mdsc->cap_delay_list);\n\tspin_unlock(&mdsc->cap_delay_lock);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __cap_delay_requeue_front(struct ceph_mds_client *mdsc,\n\t\t\t\t      struct ceph_inode_info *ci)\n{\n\tdout(\"__cap_delay_requeue_front %p\\n\", &ci->vfs_inode);\n\tspin_lock(&mdsc->cap_delay_lock);\n\tci->i_ceph_flags |= CEPH_I_FLUSH;\n\tif (!list_empty(&ci->i_cap_delay_list))\n\t\tlist_del_init(&ci->i_cap_delay_list);\n\tlist_add(&ci->i_cap_delay_list, &mdsc->cap_delay_list);\n\tspin_unlock(&mdsc->cap_delay_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "list_empty(&ci->i_dirty_item)"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ci->i_dirty_item"
          ],
          "line": 1417
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "inode"
          ],
          "line": 1413
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mdsc->cap_dirty_lock"
          ],
          "line": 1411
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&ci->i_dirty_item",
            "&mdsc->cap_dirty"
          ],
          "line": 1410
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mdsc->cap_dirty_lock"
          ],
          "line": 1409
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&ci->i_dirty_item)"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!ci->i_auth_cap"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" inode %p now dirty snapc %p auth cap %p\\n\"",
            "&ci->vfs_inode",
            "ci->i_head_snapc",
            "ci->i_auth_cap"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_get_snap_context",
          "args": [
            "ci->i_snap_realm->cached_context"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"__mark_dirty_caps %p %s dirty %s -> %s\\n\"",
            "&ci->vfs_inode",
            "ceph_cap_string(mask)",
            "ceph_cap_string(was)",
            "ceph_cap_string(was | mask)"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_cap_string",
          "args": [
            "was | mask"
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_cap_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "71-116",
          "snippet": "const char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [
            "#define MAX_CAP_STR 20"
          ],
          "globals_used": [
            "static char cap_str[MAX_CAP_STR][40];",
            "static DEFINE_SPINLOCK(cap_str_lock);",
            "static int last_cap_str;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\n#define MAX_CAP_STR 20\n\nstatic char cap_str[MAX_CAP_STR][40];\nstatic DEFINE_SPINLOCK(cap_str_lock);\nstatic int last_cap_str;\n\nconst char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_sb_to_client",
          "args": [
            "ci->vfs_inode.i_sb"
          ],
          "line": 1392
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_sb_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "352-355",
          "snippet": "static inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_mark_dirty_caps(struct ceph_inode_info *ci, int mask)\n{\n\tstruct ceph_mds_client *mdsc =\n\t\tceph_sb_to_client(ci->vfs_inode.i_sb)->mdsc;\n\tstruct inode *inode = &ci->vfs_inode;\n\tint was = ci->i_dirty_caps;\n\tint dirty = 0;\n\n\tdout(\"__mark_dirty_caps %p %s dirty %s -> %s\\n\", &ci->vfs_inode,\n\t     ceph_cap_string(mask), ceph_cap_string(was),\n\t     ceph_cap_string(was | mask));\n\tci->i_dirty_caps |= mask;\n\tif (was == 0) {\n\t\tif (!ci->i_head_snapc)\n\t\t\tci->i_head_snapc = ceph_get_snap_context(\n\t\t\t\tci->i_snap_realm->cached_context);\n\t\tdout(\" inode %p now dirty snapc %p auth cap %p\\n\",\n\t\t     &ci->vfs_inode, ci->i_head_snapc, ci->i_auth_cap);\n\t\tWARN_ON(!ci->i_auth_cap);\n\t\tBUG_ON(!list_empty(&ci->i_dirty_item));\n\t\tspin_lock(&mdsc->cap_dirty_lock);\n\t\tlist_add(&ci->i_dirty_item, &mdsc->cap_dirty);\n\t\tspin_unlock(&mdsc->cap_dirty_lock);\n\t\tif (ci->i_flushing_caps == 0) {\n\t\t\tihold(inode);\n\t\t\tdirty |= I_DIRTY_SYNC;\n\t\t}\n\t}\n\tBUG_ON(list_empty(&ci->i_dirty_item));\n\tif (((was | ci->i_flushing_caps) & CEPH_CAP_FILE_BUFFER) &&\n\t    (mask & CEPH_CAP_FILE_BUFFER))\n\t\tdirty |= I_DIRTY_DATASYNC;\n\t__cap_delay_requeue(mdsc, ci);\n\treturn dirty;\n}"
  },
  {
    "function_name": "ceph_flush_snaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "1377-1382",
    "snippet": "static void ceph_flush_snaps(struct ceph_inode_info *ci)\n{\n\tspin_lock(&ci->i_ceph_lock);\n\t__ceph_flush_snaps(ci, NULL, 0);\n\tspin_unlock(&ci->i_ceph_lock);\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 1381
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_flush_snaps",
          "args": [
            "ci",
            "NULL",
            "0"
          ],
          "line": 1380
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_flush_snaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "1257-1375",
          "snippet": "void __ceph_flush_snaps(struct ceph_inode_info *ci,\n\t\t\tstruct ceph_mds_session **psession,\n\t\t\tint again)\n\t\t__releases(ci->i_ceph_lock)\n\t\t__acquires(ci->i_ceph_lock)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint mds;\n\tstruct ceph_cap_snap *capsnap;\n\tu32 mseq;\n\tstruct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;\n\tstruct ceph_mds_session *session = NULL; /* if session != NULL, we hold\n\t\t\t\t\t\t    session->s_mutex */\n\tu64 next_follows = 0;  /* keep track of how far we've gotten through the\n\t\t\t     i_cap_snaps list, and skip these entries next time\n\t\t\t     around to avoid an infinite loop */\n\n\tif (psession)\n\t\tsession = *psession;\n\n\tdout(\"__flush_snaps %p\\n\", inode);\nretry:\n\tlist_for_each_entry(capsnap, &ci->i_cap_snaps, ci_item) {\n\t\t/* avoid an infiniute loop after retry */\n\t\tif (capsnap->follows < next_follows)\n\t\t\tcontinue;\n\t\t/*\n\t\t * we need to wait for sync writes to complete and for dirty\n\t\t * pages to be written out.\n\t\t */\n\t\tif (capsnap->dirty_pages || capsnap->writing)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * if cap writeback already occurred, we should have dropped\n\t\t * the capsnap in ceph_put_wrbuffer_cap_refs.\n\t\t */\n\t\tBUG_ON(capsnap->dirty == 0);\n\n\t\t/* pick mds, take s_mutex */\n\t\tif (ci->i_auth_cap == NULL) {\n\t\t\tdout(\"no auth cap (migrating?), doing nothing\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* only flush each capsnap once */\n\t\tif (!again && !list_empty(&capsnap->flushing_item)) {\n\t\t\tdout(\"already flushed %p, skipping\\n\", capsnap);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmds = ci->i_auth_cap->session->s_mds;\n\t\tmseq = ci->i_auth_cap->mseq;\n\n\t\tif (session && session->s_mds != mds) {\n\t\t\tdout(\"oops, wrong session %p mutex\\n\", session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tceph_put_mds_session(session);\n\t\t\tsession = NULL;\n\t\t}\n\t\tif (!session) {\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\tmutex_lock(&mdsc->mutex);\n\t\t\tsession = __ceph_lookup_mds_session(mdsc, mds);\n\t\t\tmutex_unlock(&mdsc->mutex);\n\t\t\tif (session) {\n\t\t\t\tdout(\"inverting session/ino locks on %p\\n\",\n\t\t\t\t     session);\n\t\t\t\tmutex_lock(&session->s_mutex);\n\t\t\t}\n\t\t\t/*\n\t\t\t * if session == NULL, we raced against a cap\n\t\t\t * deletion or migration.  retry, and we'll\n\t\t\t * get a better @mds value next time.\n\t\t\t */\n\t\t\tspin_lock(&ci->i_ceph_lock);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tcapsnap->flush_tid = ++ci->i_cap_flush_last_tid;\n\t\tatomic_inc(&capsnap->nref);\n\t\tif (!list_empty(&capsnap->flushing_item))\n\t\t\tlist_del_init(&capsnap->flushing_item);\n\t\tlist_add_tail(&capsnap->flushing_item,\n\t\t\t      &session->s_cap_snaps_flushing);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\n\t\tdout(\"flush_snaps %p cap_snap %p follows %lld tid %llu\\n\",\n\t\t     inode, capsnap, capsnap->follows, capsnap->flush_tid);\n\t\tsend_cap_msg(session, ceph_vino(inode).ino, 0,\n\t\t\t     CEPH_CAP_OP_FLUSHSNAP, capsnap->issued, 0,\n\t\t\t     capsnap->dirty, 0, capsnap->flush_tid, 0, mseq,\n\t\t\t     capsnap->size, 0,\n\t\t\t     &capsnap->mtime, &capsnap->atime,\n\t\t\t     capsnap->time_warp_seq,\n\t\t\t     capsnap->uid, capsnap->gid, capsnap->mode,\n\t\t\t     capsnap->xattr_version, capsnap->xattr_blob,\n\t\t\t     capsnap->follows, capsnap->inline_data);\n\n\t\tnext_follows = capsnap->follows + 1;\n\t\tceph_put_cap_snap(capsnap);\n\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tgoto retry;\n\t}\n\n\t/* we flushed them all; remove this inode from the queue */\n\tspin_lock(&mdsc->snap_flush_lock);\n\tlist_del_init(&ci->i_snap_flush_item);\n\tspin_unlock(&mdsc->snap_flush_lock);\n\nout:\n\tif (psession)\n\t\t*psession = session;\n\telse if (session) {\n\t\tmutex_unlock(&session->s_mutex);\n\t\tceph_put_mds_session(session);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid __ceph_flush_snaps(struct ceph_inode_info *ci,\n\t\t\tstruct ceph_mds_session **psession,\n\t\t\tint again)\n\t\t__releases(ci->i_ceph_lock)\n\t\t__acquires(ci->i_ceph_lock)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint mds;\n\tstruct ceph_cap_snap *capsnap;\n\tu32 mseq;\n\tstruct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;\n\tstruct ceph_mds_session *session = NULL; /* if session != NULL, we hold\n\t\t\t\t\t\t    session->s_mutex */\n\tu64 next_follows = 0;  /* keep track of how far we've gotten through the\n\t\t\t     i_cap_snaps list, and skip these entries next time\n\t\t\t     around to avoid an infinite loop */\n\n\tif (psession)\n\t\tsession = *psession;\n\n\tdout(\"__flush_snaps %p\\n\", inode);\nretry:\n\tlist_for_each_entry(capsnap, &ci->i_cap_snaps, ci_item) {\n\t\t/* avoid an infiniute loop after retry */\n\t\tif (capsnap->follows < next_follows)\n\t\t\tcontinue;\n\t\t/*\n\t\t * we need to wait for sync writes to complete and for dirty\n\t\t * pages to be written out.\n\t\t */\n\t\tif (capsnap->dirty_pages || capsnap->writing)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * if cap writeback already occurred, we should have dropped\n\t\t * the capsnap in ceph_put_wrbuffer_cap_refs.\n\t\t */\n\t\tBUG_ON(capsnap->dirty == 0);\n\n\t\t/* pick mds, take s_mutex */\n\t\tif (ci->i_auth_cap == NULL) {\n\t\t\tdout(\"no auth cap (migrating?), doing nothing\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* only flush each capsnap once */\n\t\tif (!again && !list_empty(&capsnap->flushing_item)) {\n\t\t\tdout(\"already flushed %p, skipping\\n\", capsnap);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmds = ci->i_auth_cap->session->s_mds;\n\t\tmseq = ci->i_auth_cap->mseq;\n\n\t\tif (session && session->s_mds != mds) {\n\t\t\tdout(\"oops, wrong session %p mutex\\n\", session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tceph_put_mds_session(session);\n\t\t\tsession = NULL;\n\t\t}\n\t\tif (!session) {\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\tmutex_lock(&mdsc->mutex);\n\t\t\tsession = __ceph_lookup_mds_session(mdsc, mds);\n\t\t\tmutex_unlock(&mdsc->mutex);\n\t\t\tif (session) {\n\t\t\t\tdout(\"inverting session/ino locks on %p\\n\",\n\t\t\t\t     session);\n\t\t\t\tmutex_lock(&session->s_mutex);\n\t\t\t}\n\t\t\t/*\n\t\t\t * if session == NULL, we raced against a cap\n\t\t\t * deletion or migration.  retry, and we'll\n\t\t\t * get a better @mds value next time.\n\t\t\t */\n\t\t\tspin_lock(&ci->i_ceph_lock);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tcapsnap->flush_tid = ++ci->i_cap_flush_last_tid;\n\t\tatomic_inc(&capsnap->nref);\n\t\tif (!list_empty(&capsnap->flushing_item))\n\t\t\tlist_del_init(&capsnap->flushing_item);\n\t\tlist_add_tail(&capsnap->flushing_item,\n\t\t\t      &session->s_cap_snaps_flushing);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\n\t\tdout(\"flush_snaps %p cap_snap %p follows %lld tid %llu\\n\",\n\t\t     inode, capsnap, capsnap->follows, capsnap->flush_tid);\n\t\tsend_cap_msg(session, ceph_vino(inode).ino, 0,\n\t\t\t     CEPH_CAP_OP_FLUSHSNAP, capsnap->issued, 0,\n\t\t\t     capsnap->dirty, 0, capsnap->flush_tid, 0, mseq,\n\t\t\t     capsnap->size, 0,\n\t\t\t     &capsnap->mtime, &capsnap->atime,\n\t\t\t     capsnap->time_warp_seq,\n\t\t\t     capsnap->uid, capsnap->gid, capsnap->mode,\n\t\t\t     capsnap->xattr_version, capsnap->xattr_blob,\n\t\t\t     capsnap->follows, capsnap->inline_data);\n\n\t\tnext_follows = capsnap->follows + 1;\n\t\tceph_put_cap_snap(capsnap);\n\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tgoto retry;\n\t}\n\n\t/* we flushed them all; remove this inode from the queue */\n\tspin_lock(&mdsc->snap_flush_lock);\n\tlist_del_init(&ci->i_snap_flush_item);\n\tspin_unlock(&mdsc->snap_flush_lock);\n\nout:\n\tif (psession)\n\t\t*psession = session;\n\telse if (session) {\n\t\tmutex_unlock(&session->s_mutex);\n\t\tceph_put_mds_session(session);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void ceph_flush_snaps(struct ceph_inode_info *ci)\n{\n\tspin_lock(&ci->i_ceph_lock);\n\t__ceph_flush_snaps(ci, NULL, 0);\n\tspin_unlock(&ci->i_ceph_lock);\n}"
  },
  {
    "function_name": "__ceph_flush_snaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "1257-1375",
    "snippet": "void __ceph_flush_snaps(struct ceph_inode_info *ci,\n\t\t\tstruct ceph_mds_session **psession,\n\t\t\tint again)\n\t\t__releases(ci->i_ceph_lock)\n\t\t__acquires(ci->i_ceph_lock)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint mds;\n\tstruct ceph_cap_snap *capsnap;\n\tu32 mseq;\n\tstruct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;\n\tstruct ceph_mds_session *session = NULL; /* if session != NULL, we hold\n\t\t\t\t\t\t    session->s_mutex */\n\tu64 next_follows = 0;  /* keep track of how far we've gotten through the\n\t\t\t     i_cap_snaps list, and skip these entries next time\n\t\t\t     around to avoid an infinite loop */\n\n\tif (psession)\n\t\tsession = *psession;\n\n\tdout(\"__flush_snaps %p\\n\", inode);\nretry:\n\tlist_for_each_entry(capsnap, &ci->i_cap_snaps, ci_item) {\n\t\t/* avoid an infiniute loop after retry */\n\t\tif (capsnap->follows < next_follows)\n\t\t\tcontinue;\n\t\t/*\n\t\t * we need to wait for sync writes to complete and for dirty\n\t\t * pages to be written out.\n\t\t */\n\t\tif (capsnap->dirty_pages || capsnap->writing)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * if cap writeback already occurred, we should have dropped\n\t\t * the capsnap in ceph_put_wrbuffer_cap_refs.\n\t\t */\n\t\tBUG_ON(capsnap->dirty == 0);\n\n\t\t/* pick mds, take s_mutex */\n\t\tif (ci->i_auth_cap == NULL) {\n\t\t\tdout(\"no auth cap (migrating?), doing nothing\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* only flush each capsnap once */\n\t\tif (!again && !list_empty(&capsnap->flushing_item)) {\n\t\t\tdout(\"already flushed %p, skipping\\n\", capsnap);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmds = ci->i_auth_cap->session->s_mds;\n\t\tmseq = ci->i_auth_cap->mseq;\n\n\t\tif (session && session->s_mds != mds) {\n\t\t\tdout(\"oops, wrong session %p mutex\\n\", session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tceph_put_mds_session(session);\n\t\t\tsession = NULL;\n\t\t}\n\t\tif (!session) {\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\tmutex_lock(&mdsc->mutex);\n\t\t\tsession = __ceph_lookup_mds_session(mdsc, mds);\n\t\t\tmutex_unlock(&mdsc->mutex);\n\t\t\tif (session) {\n\t\t\t\tdout(\"inverting session/ino locks on %p\\n\",\n\t\t\t\t     session);\n\t\t\t\tmutex_lock(&session->s_mutex);\n\t\t\t}\n\t\t\t/*\n\t\t\t * if session == NULL, we raced against a cap\n\t\t\t * deletion or migration.  retry, and we'll\n\t\t\t * get a better @mds value next time.\n\t\t\t */\n\t\t\tspin_lock(&ci->i_ceph_lock);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tcapsnap->flush_tid = ++ci->i_cap_flush_last_tid;\n\t\tatomic_inc(&capsnap->nref);\n\t\tif (!list_empty(&capsnap->flushing_item))\n\t\t\tlist_del_init(&capsnap->flushing_item);\n\t\tlist_add_tail(&capsnap->flushing_item,\n\t\t\t      &session->s_cap_snaps_flushing);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\n\t\tdout(\"flush_snaps %p cap_snap %p follows %lld tid %llu\\n\",\n\t\t     inode, capsnap, capsnap->follows, capsnap->flush_tid);\n\t\tsend_cap_msg(session, ceph_vino(inode).ino, 0,\n\t\t\t     CEPH_CAP_OP_FLUSHSNAP, capsnap->issued, 0,\n\t\t\t     capsnap->dirty, 0, capsnap->flush_tid, 0, mseq,\n\t\t\t     capsnap->size, 0,\n\t\t\t     &capsnap->mtime, &capsnap->atime,\n\t\t\t     capsnap->time_warp_seq,\n\t\t\t     capsnap->uid, capsnap->gid, capsnap->mode,\n\t\t\t     capsnap->xattr_version, capsnap->xattr_blob,\n\t\t\t     capsnap->follows, capsnap->inline_data);\n\n\t\tnext_follows = capsnap->follows + 1;\n\t\tceph_put_cap_snap(capsnap);\n\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tgoto retry;\n\t}\n\n\t/* we flushed them all; remove this inode from the queue */\n\tspin_lock(&mdsc->snap_flush_lock);\n\tlist_del_init(&ci->i_snap_flush_item);\n\tspin_unlock(&mdsc->snap_flush_lock);\n\nout:\n\tif (psession)\n\t\t*psession = session;\n\telse if (session) {\n\t\tmutex_unlock(&session->s_mutex);\n\t\tceph_put_mds_session(session);\n\t}\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_put_mds_session",
          "args": [
            "session"
          ],
          "line": 1373
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_put_mds_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "374-385",
          "snippet": "void ceph_put_mds_session(struct ceph_mds_session *s)\n{\n\tdout(\"mdsc put_session %p %d -> %d\\n\", s,\n\t     atomic_read(&s->s_ref), atomic_read(&s->s_ref)-1);\n\tif (atomic_dec_and_test(&s->s_ref)) {\n\t\tif (s->s_auth.authorizer)\n\t\t\tceph_auth_destroy_authorizer(\n\t\t\t\ts->s_mdsc->fsc->client->monc.auth,\n\t\t\t\ts->s_auth.authorizer);\n\t\tkfree(s);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_put_mds_session(struct ceph_mds_session *s)\n{\n\tdout(\"mdsc put_session %p %d -> %d\\n\", s,\n\t     atomic_read(&s->s_ref), atomic_read(&s->s_ref)-1);\n\tif (atomic_dec_and_test(&s->s_ref)) {\n\t\tif (s->s_auth.authorizer)\n\t\t\tceph_auth_destroy_authorizer(\n\t\t\t\ts->s_mdsc->fsc->client->monc.auth,\n\t\t\t\ts->s_auth.authorizer);\n\t\tkfree(s);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&session->s_mutex"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mdsc->snap_flush_lock"
          ],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&ci->i_snap_flush_item"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mdsc->snap_flush_lock"
          ],
          "line": 1364
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_put_cap_snap",
          "args": [
            "capsnap"
          ],
          "line": 1357
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_put_cap_snap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "167-174",
          "snippet": "static inline void ceph_put_cap_snap(struct ceph_cap_snap *capsnap)\n{\n\tif (atomic_dec_and_test(&capsnap->nref)) {\n\t\tif (capsnap->xattr_blob)\n\t\t\tceph_buffer_put(capsnap->xattr_blob);\n\t\tkfree(capsnap);\n\t}\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline void ceph_put_cap_snap(struct ceph_cap_snap *capsnap)\n{\n\tif (atomic_dec_and_test(&capsnap->nref)) {\n\t\tif (capsnap->xattr_blob)\n\t\t\tceph_buffer_put(capsnap->xattr_blob);\n\t\tkfree(capsnap);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_cap_msg",
          "args": [
            "session",
            "ceph_vino(inode).ino",
            "0",
            "CEPH_CAP_OP_FLUSHSNAP",
            "capsnap->issued",
            "0",
            "capsnap->dirty",
            "0",
            "capsnap->flush_tid",
            "0",
            "mseq",
            "capsnap->size",
            "0",
            "&capsnap->mtime",
            "&capsnap->atime",
            "capsnap->time_warp_seq",
            "capsnap->uid",
            "capsnap->gid",
            "capsnap->mode",
            "capsnap->xattr_version",
            "capsnap->xattr_blob",
            "capsnap->follows",
            "capsnap->inline_data"
          ],
          "line": 1346
        },
        "resolved": true,
        "details": {
          "function_name": "send_cap_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "967-1044",
          "snippet": "static int send_cap_msg(struct ceph_mds_session *session,\n\t\t\tu64 ino, u64 cid, int op,\n\t\t\tint caps, int wanted, int dirty,\n\t\t\tu32 seq, u64 flush_tid, u32 issue_seq, u32 mseq,\n\t\t\tu64 size, u64 max_size,\n\t\t\tstruct timespec *mtime, struct timespec *atime,\n\t\t\tu64 time_warp_seq,\n\t\t\tkuid_t uid, kgid_t gid, umode_t mode,\n\t\t\tu64 xattr_version,\n\t\t\tstruct ceph_buffer *xattrs_buf,\n\t\t\tu64 follows, bool inline_data)\n{\n\tstruct ceph_mds_caps *fc;\n\tstruct ceph_msg *msg;\n\tvoid *p;\n\tsize_t extra_len;\n\n\tdout(\"send_cap_msg %s %llx %llx caps %s wanted %s dirty %s\"\n\t     \" seq %u/%u mseq %u follows %lld size %llu/%llu\"\n\t     \" xattr_ver %llu xattr_len %d\\n\", ceph_cap_op_name(op),\n\t     cid, ino, ceph_cap_string(caps), ceph_cap_string(wanted),\n\t     ceph_cap_string(dirty),\n\t     seq, issue_seq, mseq, follows, size, max_size,\n\t     xattr_version, xattrs_buf ? (int)xattrs_buf->vec.iov_len : 0);\n\n\t/* flock buffer size + inline version + inline data size */\n\textra_len = 4 + 8 + 4;\n\tmsg = ceph_msg_new(CEPH_MSG_CLIENT_CAPS, sizeof(*fc) + extra_len,\n\t\t\t   GFP_NOFS, false);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tmsg->hdr.tid = cpu_to_le64(flush_tid);\n\n\tfc = msg->front.iov_base;\n\tmemset(fc, 0, sizeof(*fc));\n\n\tfc->cap_id = cpu_to_le64(cid);\n\tfc->op = cpu_to_le32(op);\n\tfc->seq = cpu_to_le32(seq);\n\tfc->issue_seq = cpu_to_le32(issue_seq);\n\tfc->migrate_seq = cpu_to_le32(mseq);\n\tfc->caps = cpu_to_le32(caps);\n\tfc->wanted = cpu_to_le32(wanted);\n\tfc->dirty = cpu_to_le32(dirty);\n\tfc->ino = cpu_to_le64(ino);\n\tfc->snap_follows = cpu_to_le64(follows);\n\n\tfc->size = cpu_to_le64(size);\n\tfc->max_size = cpu_to_le64(max_size);\n\tif (mtime)\n\t\tceph_encode_timespec(&fc->mtime, mtime);\n\tif (atime)\n\t\tceph_encode_timespec(&fc->atime, atime);\n\tfc->time_warp_seq = cpu_to_le32(time_warp_seq);\n\n\tfc->uid = cpu_to_le32(from_kuid(&init_user_ns, uid));\n\tfc->gid = cpu_to_le32(from_kgid(&init_user_ns, gid));\n\tfc->mode = cpu_to_le32(mode);\n\n\tp = fc + 1;\n\t/* flock buffer size */\n\tceph_encode_32(&p, 0);\n\t/* inline version */\n\tceph_encode_64(&p, inline_data ? 0 : CEPH_INLINE_NONE);\n\t/* inline data size */\n\tceph_encode_32(&p, 0);\n\n\tfc->xattr_version = cpu_to_le64(xattr_version);\n\tif (xattrs_buf) {\n\t\tmsg->middle = ceph_buffer_get(xattrs_buf);\n\t\tfc->xattr_len = cpu_to_le32(xattrs_buf->vec.iov_len);\n\t\tmsg->hdr.middle_len = cpu_to_le32(xattrs_buf->vec.iov_len);\n\t}\n\n\tceph_con_send(&session->s_con, msg);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int send_cap_msg(struct ceph_mds_session *session,\n\t\t\tu64 ino, u64 cid, int op,\n\t\t\tint caps, int wanted, int dirty,\n\t\t\tu32 seq, u64 flush_tid, u32 issue_seq, u32 mseq,\n\t\t\tu64 size, u64 max_size,\n\t\t\tstruct timespec *mtime, struct timespec *atime,\n\t\t\tu64 time_warp_seq,\n\t\t\tkuid_t uid, kgid_t gid, umode_t mode,\n\t\t\tu64 xattr_version,\n\t\t\tstruct ceph_buffer *xattrs_buf,\n\t\t\tu64 follows, bool inline_data)\n{\n\tstruct ceph_mds_caps *fc;\n\tstruct ceph_msg *msg;\n\tvoid *p;\n\tsize_t extra_len;\n\n\tdout(\"send_cap_msg %s %llx %llx caps %s wanted %s dirty %s\"\n\t     \" seq %u/%u mseq %u follows %lld size %llu/%llu\"\n\t     \" xattr_ver %llu xattr_len %d\\n\", ceph_cap_op_name(op),\n\t     cid, ino, ceph_cap_string(caps), ceph_cap_string(wanted),\n\t     ceph_cap_string(dirty),\n\t     seq, issue_seq, mseq, follows, size, max_size,\n\t     xattr_version, xattrs_buf ? (int)xattrs_buf->vec.iov_len : 0);\n\n\t/* flock buffer size + inline version + inline data size */\n\textra_len = 4 + 8 + 4;\n\tmsg = ceph_msg_new(CEPH_MSG_CLIENT_CAPS, sizeof(*fc) + extra_len,\n\t\t\t   GFP_NOFS, false);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tmsg->hdr.tid = cpu_to_le64(flush_tid);\n\n\tfc = msg->front.iov_base;\n\tmemset(fc, 0, sizeof(*fc));\n\n\tfc->cap_id = cpu_to_le64(cid);\n\tfc->op = cpu_to_le32(op);\n\tfc->seq = cpu_to_le32(seq);\n\tfc->issue_seq = cpu_to_le32(issue_seq);\n\tfc->migrate_seq = cpu_to_le32(mseq);\n\tfc->caps = cpu_to_le32(caps);\n\tfc->wanted = cpu_to_le32(wanted);\n\tfc->dirty = cpu_to_le32(dirty);\n\tfc->ino = cpu_to_le64(ino);\n\tfc->snap_follows = cpu_to_le64(follows);\n\n\tfc->size = cpu_to_le64(size);\n\tfc->max_size = cpu_to_le64(max_size);\n\tif (mtime)\n\t\tceph_encode_timespec(&fc->mtime, mtime);\n\tif (atime)\n\t\tceph_encode_timespec(&fc->atime, atime);\n\tfc->time_warp_seq = cpu_to_le32(time_warp_seq);\n\n\tfc->uid = cpu_to_le32(from_kuid(&init_user_ns, uid));\n\tfc->gid = cpu_to_le32(from_kgid(&init_user_ns, gid));\n\tfc->mode = cpu_to_le32(mode);\n\n\tp = fc + 1;\n\t/* flock buffer size */\n\tceph_encode_32(&p, 0);\n\t/* inline version */\n\tceph_encode_64(&p, inline_data ? 0 : CEPH_INLINE_NONE);\n\t/* inline data size */\n\tceph_encode_32(&p, 0);\n\n\tfc->xattr_version = cpu_to_le64(xattr_version);\n\tif (xattrs_buf) {\n\t\tmsg->middle = ceph_buffer_get(xattrs_buf);\n\t\tfc->xattr_len = cpu_to_le32(xattrs_buf->vec.iov_len);\n\t\tmsg->hdr.middle_len = cpu_to_le32(xattrs_buf->vec.iov_len);\n\t}\n\n\tceph_con_send(&session->s_con, msg);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_vino",
          "args": [
            "inode"
          ],
          "line": 1346
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_vino_to_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "382-389",
          "snippet": "static inline ino_t ceph_vino_to_ino(struct ceph_vino vino)\n{\n#if BITS_PER_LONG == 32\n\treturn ceph_ino_to_ino32(vino.ino);\n#else\n\treturn (ino_t)vino.ino;\n#endif\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline ino_t ceph_vino_to_ino(struct ceph_vino vino)\n{\n#if BITS_PER_LONG == 32\n\treturn ceph_ino_to_ino32(vino.ino);\n#else\n\treturn (ino_t)vino.ino;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"flush_snaps %p cap_snap %p follows %lld tid %llu\\n\"",
            "inode",
            "capsnap",
            "capsnap->follows",
            "capsnap->flush_tid"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&capsnap->flushing_item",
            "&session->s_cap_snaps_flushing"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&capsnap->flushing_item"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&capsnap->flushing_item"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&capsnap->nref"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&session->s_mutex"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"inverting session/ino locks on %p\\n\"",
            "session"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ceph_lookup_mds_session",
          "args": [
            "mdsc",
            "mds"
          ],
          "line": 1320
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_lookup_mds_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "390-402",
          "snippet": "struct ceph_mds_session *__ceph_lookup_mds_session(struct ceph_mds_client *mdsc,\n\t\t\t\t\t\t   int mds)\n{\n\tstruct ceph_mds_session *session;\n\n\tif (mds >= mdsc->max_sessions || mdsc->sessions[mds] == NULL)\n\t\treturn NULL;\n\tsession = mdsc->sessions[mds];\n\tdout(\"lookup_mds_session %p %d\\n\", session,\n\t     atomic_read(&session->s_ref));\n\tget_session(session);\n\treturn session;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct ceph_mds_session *__ceph_lookup_mds_session(struct ceph_mds_client *mdsc,\n\t\t\t\t\t\t   int mds)\n{\n\tstruct ceph_mds_session *session;\n\n\tif (mds >= mdsc->max_sessions || mdsc->sessions[mds] == NULL)\n\t\treturn NULL;\n\tsession = mdsc->sessions[mds];\n\tdout(\"lookup_mds_session %p %d\\n\", session,\n\t     atomic_read(&session->s_ref));\n\tget_session(session);\n\treturn session;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&session->s_mutex"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"oops, wrong session %p mutex\\n\"",
            "session"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"already flushed %p, skipping\\n\"",
            "capsnap"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"no auth cap (migrating?), doing nothing\\n\""
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "capsnap->dirty == 0"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "capsnap",
            "&ci->i_cap_snaps",
            "ci_item"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"__flush_snaps %p\\n\"",
            "inode"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_inode_to_client",
          "args": [
            "inode"
          ],
          "line": 1267
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "ci->i_ceph_lock"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "ci->i_ceph_lock"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid __ceph_flush_snaps(struct ceph_inode_info *ci,\n\t\t\tstruct ceph_mds_session **psession,\n\t\t\tint again)\n\t\t__releases(ci->i_ceph_lock)\n\t\t__acquires(ci->i_ceph_lock)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint mds;\n\tstruct ceph_cap_snap *capsnap;\n\tu32 mseq;\n\tstruct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;\n\tstruct ceph_mds_session *session = NULL; /* if session != NULL, we hold\n\t\t\t\t\t\t    session->s_mutex */\n\tu64 next_follows = 0;  /* keep track of how far we've gotten through the\n\t\t\t     i_cap_snaps list, and skip these entries next time\n\t\t\t     around to avoid an infinite loop */\n\n\tif (psession)\n\t\tsession = *psession;\n\n\tdout(\"__flush_snaps %p\\n\", inode);\nretry:\n\tlist_for_each_entry(capsnap, &ci->i_cap_snaps, ci_item) {\n\t\t/* avoid an infiniute loop after retry */\n\t\tif (capsnap->follows < next_follows)\n\t\t\tcontinue;\n\t\t/*\n\t\t * we need to wait for sync writes to complete and for dirty\n\t\t * pages to be written out.\n\t\t */\n\t\tif (capsnap->dirty_pages || capsnap->writing)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * if cap writeback already occurred, we should have dropped\n\t\t * the capsnap in ceph_put_wrbuffer_cap_refs.\n\t\t */\n\t\tBUG_ON(capsnap->dirty == 0);\n\n\t\t/* pick mds, take s_mutex */\n\t\tif (ci->i_auth_cap == NULL) {\n\t\t\tdout(\"no auth cap (migrating?), doing nothing\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* only flush each capsnap once */\n\t\tif (!again && !list_empty(&capsnap->flushing_item)) {\n\t\t\tdout(\"already flushed %p, skipping\\n\", capsnap);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmds = ci->i_auth_cap->session->s_mds;\n\t\tmseq = ci->i_auth_cap->mseq;\n\n\t\tif (session && session->s_mds != mds) {\n\t\t\tdout(\"oops, wrong session %p mutex\\n\", session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tceph_put_mds_session(session);\n\t\t\tsession = NULL;\n\t\t}\n\t\tif (!session) {\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\tmutex_lock(&mdsc->mutex);\n\t\t\tsession = __ceph_lookup_mds_session(mdsc, mds);\n\t\t\tmutex_unlock(&mdsc->mutex);\n\t\t\tif (session) {\n\t\t\t\tdout(\"inverting session/ino locks on %p\\n\",\n\t\t\t\t     session);\n\t\t\t\tmutex_lock(&session->s_mutex);\n\t\t\t}\n\t\t\t/*\n\t\t\t * if session == NULL, we raced against a cap\n\t\t\t * deletion or migration.  retry, and we'll\n\t\t\t * get a better @mds value next time.\n\t\t\t */\n\t\t\tspin_lock(&ci->i_ceph_lock);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tcapsnap->flush_tid = ++ci->i_cap_flush_last_tid;\n\t\tatomic_inc(&capsnap->nref);\n\t\tif (!list_empty(&capsnap->flushing_item))\n\t\t\tlist_del_init(&capsnap->flushing_item);\n\t\tlist_add_tail(&capsnap->flushing_item,\n\t\t\t      &session->s_cap_snaps_flushing);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\n\t\tdout(\"flush_snaps %p cap_snap %p follows %lld tid %llu\\n\",\n\t\t     inode, capsnap, capsnap->follows, capsnap->flush_tid);\n\t\tsend_cap_msg(session, ceph_vino(inode).ino, 0,\n\t\t\t     CEPH_CAP_OP_FLUSHSNAP, capsnap->issued, 0,\n\t\t\t     capsnap->dirty, 0, capsnap->flush_tid, 0, mseq,\n\t\t\t     capsnap->size, 0,\n\t\t\t     &capsnap->mtime, &capsnap->atime,\n\t\t\t     capsnap->time_warp_seq,\n\t\t\t     capsnap->uid, capsnap->gid, capsnap->mode,\n\t\t\t     capsnap->xattr_version, capsnap->xattr_blob,\n\t\t\t     capsnap->follows, capsnap->inline_data);\n\n\t\tnext_follows = capsnap->follows + 1;\n\t\tceph_put_cap_snap(capsnap);\n\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tgoto retry;\n\t}\n\n\t/* we flushed them all; remove this inode from the queue */\n\tspin_lock(&mdsc->snap_flush_lock);\n\tlist_del_init(&ci->i_snap_flush_item);\n\tspin_unlock(&mdsc->snap_flush_lock);\n\nout:\n\tif (psession)\n\t\t*psession = session;\n\telse if (session) {\n\t\tmutex_unlock(&session->s_mutex);\n\t\tceph_put_mds_session(session);\n\t}\n}"
  },
  {
    "function_name": "__send_cap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "1118-1243",
    "snippet": "static int __send_cap(struct ceph_mds_client *mdsc, struct ceph_cap *cap,\n\t\t      int op, int used, int want, int retain, int flushing,\n\t\t      unsigned *pflush_tid)\n\t__releases(cap->ci->i_ceph_lock)\n{\n\tstruct ceph_inode_info *ci = cap->ci;\n\tstruct inode *inode = &ci->vfs_inode;\n\tu64 cap_id = cap->cap_id;\n\tint held, revoking, dropping, keep;\n\tu64 seq, issue_seq, mseq, time_warp_seq, follows;\n\tu64 size, max_size;\n\tstruct timespec mtime, atime;\n\tint wake = 0;\n\tumode_t mode;\n\tkuid_t uid;\n\tkgid_t gid;\n\tstruct ceph_mds_session *session;\n\tu64 xattr_version = 0;\n\tstruct ceph_buffer *xattr_blob = NULL;\n\tint delayed = 0;\n\tu64 flush_tid = 0;\n\tint i;\n\tint ret;\n\tbool inline_data;\n\n\theld = cap->issued | cap->implemented;\n\trevoking = cap->implemented & ~cap->issued;\n\tretain &= ~revoking;\n\tdropping = cap->issued & ~retain;\n\n\tdout(\"__send_cap %p cap %p session %p %s -> %s (revoking %s)\\n\",\n\t     inode, cap, cap->session,\n\t     ceph_cap_string(held), ceph_cap_string(held & retain),\n\t     ceph_cap_string(revoking));\n\tBUG_ON((retain & CEPH_CAP_PIN) == 0);\n\n\tsession = cap->session;\n\n\t/* don't release wanted unless we've waited a bit. */\n\tif ((ci->i_ceph_flags & CEPH_I_NODELAY) == 0 &&\n\t    time_before(jiffies, ci->i_hold_caps_min)) {\n\t\tdout(\" delaying issued %s -> %s, wanted %s -> %s on send\\n\",\n\t\t     ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(cap->issued & retain),\n\t\t     ceph_cap_string(cap->mds_wanted),\n\t\t     ceph_cap_string(want));\n\t\twant |= cap->mds_wanted;\n\t\tretain |= cap->issued;\n\t\tdelayed = 1;\n\t}\n\tci->i_ceph_flags &= ~(CEPH_I_NODELAY | CEPH_I_FLUSH);\n\n\tcap->issued &= retain;  /* drop bits we don't want */\n\tif (cap->implemented & ~cap->issued) {\n\t\t/*\n\t\t * Wake up any waiters on wanted -> needed transition.\n\t\t * This is due to the weird transition from buffered\n\t\t * to sync IO... we need to flush dirty pages _before_\n\t\t * allowing sync writes to avoid reordering.\n\t\t */\n\t\twake = 1;\n\t}\n\tcap->implemented &= cap->issued | used;\n\tcap->mds_wanted = want;\n\n\tif (flushing) {\n\t\t/*\n\t\t * assign a tid for flush operations so we can avoid\n\t\t * flush1 -> dirty1 -> flush2 -> flushack1 -> mark\n\t\t * clean type races.  track latest tid for every bit\n\t\t * so we can handle flush AxFw, flush Fw, and have the\n\t\t * first ack clean Ax.\n\t\t */\n\t\tflush_tid = ++ci->i_cap_flush_last_tid;\n\t\tif (pflush_tid)\n\t\t\t*pflush_tid = flush_tid;\n\t\tdout(\" cap_flush_tid %d\\n\", (int)flush_tid);\n\t\tfor (i = 0; i < CEPH_CAP_BITS; i++)\n\t\t\tif (flushing & (1 << i))\n\t\t\t\tci->i_cap_flush_tid[i] = flush_tid;\n\n\t\tfollows = ci->i_head_snapc->seq;\n\t} else {\n\t\tfollows = 0;\n\t}\n\n\tkeep = cap->implemented;\n\tseq = cap->seq;\n\tissue_seq = cap->issue_seq;\n\tmseq = cap->mseq;\n\tsize = inode->i_size;\n\tci->i_reported_size = size;\n\tmax_size = ci->i_wanted_max_size;\n\tci->i_requested_max_size = max_size;\n\tmtime = inode->i_mtime;\n\tatime = inode->i_atime;\n\ttime_warp_seq = ci->i_time_warp_seq;\n\tuid = inode->i_uid;\n\tgid = inode->i_gid;\n\tmode = inode->i_mode;\n\n\tif (flushing & CEPH_CAP_XATTR_EXCL) {\n\t\t__ceph_build_xattrs_blob(ci);\n\t\txattr_blob = ci->i_xattrs.blob;\n\t\txattr_version = ci->i_xattrs.version;\n\t}\n\n\tinline_data = ci->i_inline_version != CEPH_INLINE_NONE;\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tret = send_cap_msg(session, ceph_vino(inode).ino, cap_id,\n\t\top, keep, want, flushing, seq, flush_tid, issue_seq, mseq,\n\t\tsize, max_size, &mtime, &atime, time_warp_seq,\n\t\tuid, gid, mode, xattr_version, xattr_blob,\n\t\tfollows, inline_data);\n\tif (ret < 0) {\n\t\tdout(\"error sending cap msg, must requeue %p\\n\", inode);\n\t\tdelayed = 1;\n\t}\n\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\n\treturn delayed;\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&ci->i_cap_wq"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"error sending cap msg, must requeue %p\\n\"",
            "inode"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_cap_msg",
          "args": [
            "session",
            "ceph_vino(inode).ino",
            "cap_id",
            "op",
            "keep",
            "want",
            "flushing",
            "seq",
            "flush_tid",
            "issue_seq",
            "mseq",
            "size",
            "max_size",
            "&mtime",
            "&atime",
            "time_warp_seq",
            "uid",
            "gid",
            "mode",
            "xattr_version",
            "xattr_blob",
            "follows",
            "inline_data"
          ],
          "line": 1229
        },
        "resolved": true,
        "details": {
          "function_name": "send_cap_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "967-1044",
          "snippet": "static int send_cap_msg(struct ceph_mds_session *session,\n\t\t\tu64 ino, u64 cid, int op,\n\t\t\tint caps, int wanted, int dirty,\n\t\t\tu32 seq, u64 flush_tid, u32 issue_seq, u32 mseq,\n\t\t\tu64 size, u64 max_size,\n\t\t\tstruct timespec *mtime, struct timespec *atime,\n\t\t\tu64 time_warp_seq,\n\t\t\tkuid_t uid, kgid_t gid, umode_t mode,\n\t\t\tu64 xattr_version,\n\t\t\tstruct ceph_buffer *xattrs_buf,\n\t\t\tu64 follows, bool inline_data)\n{\n\tstruct ceph_mds_caps *fc;\n\tstruct ceph_msg *msg;\n\tvoid *p;\n\tsize_t extra_len;\n\n\tdout(\"send_cap_msg %s %llx %llx caps %s wanted %s dirty %s\"\n\t     \" seq %u/%u mseq %u follows %lld size %llu/%llu\"\n\t     \" xattr_ver %llu xattr_len %d\\n\", ceph_cap_op_name(op),\n\t     cid, ino, ceph_cap_string(caps), ceph_cap_string(wanted),\n\t     ceph_cap_string(dirty),\n\t     seq, issue_seq, mseq, follows, size, max_size,\n\t     xattr_version, xattrs_buf ? (int)xattrs_buf->vec.iov_len : 0);\n\n\t/* flock buffer size + inline version + inline data size */\n\textra_len = 4 + 8 + 4;\n\tmsg = ceph_msg_new(CEPH_MSG_CLIENT_CAPS, sizeof(*fc) + extra_len,\n\t\t\t   GFP_NOFS, false);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tmsg->hdr.tid = cpu_to_le64(flush_tid);\n\n\tfc = msg->front.iov_base;\n\tmemset(fc, 0, sizeof(*fc));\n\n\tfc->cap_id = cpu_to_le64(cid);\n\tfc->op = cpu_to_le32(op);\n\tfc->seq = cpu_to_le32(seq);\n\tfc->issue_seq = cpu_to_le32(issue_seq);\n\tfc->migrate_seq = cpu_to_le32(mseq);\n\tfc->caps = cpu_to_le32(caps);\n\tfc->wanted = cpu_to_le32(wanted);\n\tfc->dirty = cpu_to_le32(dirty);\n\tfc->ino = cpu_to_le64(ino);\n\tfc->snap_follows = cpu_to_le64(follows);\n\n\tfc->size = cpu_to_le64(size);\n\tfc->max_size = cpu_to_le64(max_size);\n\tif (mtime)\n\t\tceph_encode_timespec(&fc->mtime, mtime);\n\tif (atime)\n\t\tceph_encode_timespec(&fc->atime, atime);\n\tfc->time_warp_seq = cpu_to_le32(time_warp_seq);\n\n\tfc->uid = cpu_to_le32(from_kuid(&init_user_ns, uid));\n\tfc->gid = cpu_to_le32(from_kgid(&init_user_ns, gid));\n\tfc->mode = cpu_to_le32(mode);\n\n\tp = fc + 1;\n\t/* flock buffer size */\n\tceph_encode_32(&p, 0);\n\t/* inline version */\n\tceph_encode_64(&p, inline_data ? 0 : CEPH_INLINE_NONE);\n\t/* inline data size */\n\tceph_encode_32(&p, 0);\n\n\tfc->xattr_version = cpu_to_le64(xattr_version);\n\tif (xattrs_buf) {\n\t\tmsg->middle = ceph_buffer_get(xattrs_buf);\n\t\tfc->xattr_len = cpu_to_le32(xattrs_buf->vec.iov_len);\n\t\tmsg->hdr.middle_len = cpu_to_le32(xattrs_buf->vec.iov_len);\n\t}\n\n\tceph_con_send(&session->s_con, msg);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int send_cap_msg(struct ceph_mds_session *session,\n\t\t\tu64 ino, u64 cid, int op,\n\t\t\tint caps, int wanted, int dirty,\n\t\t\tu32 seq, u64 flush_tid, u32 issue_seq, u32 mseq,\n\t\t\tu64 size, u64 max_size,\n\t\t\tstruct timespec *mtime, struct timespec *atime,\n\t\t\tu64 time_warp_seq,\n\t\t\tkuid_t uid, kgid_t gid, umode_t mode,\n\t\t\tu64 xattr_version,\n\t\t\tstruct ceph_buffer *xattrs_buf,\n\t\t\tu64 follows, bool inline_data)\n{\n\tstruct ceph_mds_caps *fc;\n\tstruct ceph_msg *msg;\n\tvoid *p;\n\tsize_t extra_len;\n\n\tdout(\"send_cap_msg %s %llx %llx caps %s wanted %s dirty %s\"\n\t     \" seq %u/%u mseq %u follows %lld size %llu/%llu\"\n\t     \" xattr_ver %llu xattr_len %d\\n\", ceph_cap_op_name(op),\n\t     cid, ino, ceph_cap_string(caps), ceph_cap_string(wanted),\n\t     ceph_cap_string(dirty),\n\t     seq, issue_seq, mseq, follows, size, max_size,\n\t     xattr_version, xattrs_buf ? (int)xattrs_buf->vec.iov_len : 0);\n\n\t/* flock buffer size + inline version + inline data size */\n\textra_len = 4 + 8 + 4;\n\tmsg = ceph_msg_new(CEPH_MSG_CLIENT_CAPS, sizeof(*fc) + extra_len,\n\t\t\t   GFP_NOFS, false);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tmsg->hdr.tid = cpu_to_le64(flush_tid);\n\n\tfc = msg->front.iov_base;\n\tmemset(fc, 0, sizeof(*fc));\n\n\tfc->cap_id = cpu_to_le64(cid);\n\tfc->op = cpu_to_le32(op);\n\tfc->seq = cpu_to_le32(seq);\n\tfc->issue_seq = cpu_to_le32(issue_seq);\n\tfc->migrate_seq = cpu_to_le32(mseq);\n\tfc->caps = cpu_to_le32(caps);\n\tfc->wanted = cpu_to_le32(wanted);\n\tfc->dirty = cpu_to_le32(dirty);\n\tfc->ino = cpu_to_le64(ino);\n\tfc->snap_follows = cpu_to_le64(follows);\n\n\tfc->size = cpu_to_le64(size);\n\tfc->max_size = cpu_to_le64(max_size);\n\tif (mtime)\n\t\tceph_encode_timespec(&fc->mtime, mtime);\n\tif (atime)\n\t\tceph_encode_timespec(&fc->atime, atime);\n\tfc->time_warp_seq = cpu_to_le32(time_warp_seq);\n\n\tfc->uid = cpu_to_le32(from_kuid(&init_user_ns, uid));\n\tfc->gid = cpu_to_le32(from_kgid(&init_user_ns, gid));\n\tfc->mode = cpu_to_le32(mode);\n\n\tp = fc + 1;\n\t/* flock buffer size */\n\tceph_encode_32(&p, 0);\n\t/* inline version */\n\tceph_encode_64(&p, inline_data ? 0 : CEPH_INLINE_NONE);\n\t/* inline data size */\n\tceph_encode_32(&p, 0);\n\n\tfc->xattr_version = cpu_to_le64(xattr_version);\n\tif (xattrs_buf) {\n\t\tmsg->middle = ceph_buffer_get(xattrs_buf);\n\t\tfc->xattr_len = cpu_to_le32(xattrs_buf->vec.iov_len);\n\t\tmsg->hdr.middle_len = cpu_to_le32(xattrs_buf->vec.iov_len);\n\t}\n\n\tceph_con_send(&session->s_con, msg);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_vino",
          "args": [
            "inode"
          ],
          "line": 1229
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_vino_to_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "382-389",
          "snippet": "static inline ino_t ceph_vino_to_ino(struct ceph_vino vino)\n{\n#if BITS_PER_LONG == 32\n\treturn ceph_ino_to_ino32(vino.ino);\n#else\n\treturn (ino_t)vino.ino;\n#endif\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline ino_t ceph_vino_to_ino(struct ceph_vino vino)\n{\n#if BITS_PER_LONG == 32\n\treturn ceph_ino_to_ino32(vino.ino);\n#else\n\treturn (ino_t)vino.ino;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 1227
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_build_xattrs_blob",
          "args": [
            "ci"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_build_xattrs_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "675-715",
          "snippet": "void __ceph_build_xattrs_blob(struct ceph_inode_info *ci)\n{\n\tstruct rb_node *p;\n\tstruct ceph_inode_xattr *xattr = NULL;\n\tvoid *dest;\n\n\tdout(\"__build_xattrs_blob %p\\n\", &ci->vfs_inode);\n\tif (ci->i_xattrs.dirty) {\n\t\tint need = __get_required_blob_size(ci, 0, 0);\n\n\t\tBUG_ON(need > ci->i_xattrs.prealloc_blob->alloc_len);\n\n\t\tp = rb_first(&ci->i_xattrs.index);\n\t\tdest = ci->i_xattrs.prealloc_blob->vec.iov_base;\n\n\t\tceph_encode_32(&dest, ci->i_xattrs.count);\n\t\twhile (p) {\n\t\t\txattr = rb_entry(p, struct ceph_inode_xattr, node);\n\n\t\t\tceph_encode_32(&dest, xattr->name_len);\n\t\t\tmemcpy(dest, xattr->name, xattr->name_len);\n\t\t\tdest += xattr->name_len;\n\t\t\tceph_encode_32(&dest, xattr->val_len);\n\t\t\tmemcpy(dest, xattr->val, xattr->val_len);\n\t\t\tdest += xattr->val_len;\n\n\t\t\tp = rb_next(p);\n\t\t}\n\n\t\t/* adjust buffer len; it may be larger than we need */\n\t\tci->i_xattrs.prealloc_blob->vec.iov_len =\n\t\t\tdest - ci->i_xattrs.prealloc_blob->vec.iov_base;\n\n\t\tif (ci->i_xattrs.blob)\n\t\t\tceph_buffer_put(ci->i_xattrs.blob);\n\t\tci->i_xattrs.blob = ci->i_xattrs.prealloc_blob;\n\t\tci->i_xattrs.prealloc_blob = NULL;\n\t\tci->i_xattrs.dirty = false;\n\t\tci->i_xattrs.version++;\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);\n\nvoid __ceph_build_xattrs_blob(struct ceph_inode_info *ci)\n{\n\tstruct rb_node *p;\n\tstruct ceph_inode_xattr *xattr = NULL;\n\tvoid *dest;\n\n\tdout(\"__build_xattrs_blob %p\\n\", &ci->vfs_inode);\n\tif (ci->i_xattrs.dirty) {\n\t\tint need = __get_required_blob_size(ci, 0, 0);\n\n\t\tBUG_ON(need > ci->i_xattrs.prealloc_blob->alloc_len);\n\n\t\tp = rb_first(&ci->i_xattrs.index);\n\t\tdest = ci->i_xattrs.prealloc_blob->vec.iov_base;\n\n\t\tceph_encode_32(&dest, ci->i_xattrs.count);\n\t\twhile (p) {\n\t\t\txattr = rb_entry(p, struct ceph_inode_xattr, node);\n\n\t\t\tceph_encode_32(&dest, xattr->name_len);\n\t\t\tmemcpy(dest, xattr->name, xattr->name_len);\n\t\t\tdest += xattr->name_len;\n\t\t\tceph_encode_32(&dest, xattr->val_len);\n\t\t\tmemcpy(dest, xattr->val, xattr->val_len);\n\t\t\tdest += xattr->val_len;\n\n\t\t\tp = rb_next(p);\n\t\t}\n\n\t\t/* adjust buffer len; it may be larger than we need */\n\t\tci->i_xattrs.prealloc_blob->vec.iov_len =\n\t\t\tdest - ci->i_xattrs.prealloc_blob->vec.iov_base;\n\n\t\tif (ci->i_xattrs.blob)\n\t\t\tceph_buffer_put(ci->i_xattrs.blob);\n\t\tci->i_xattrs.blob = ci->i_xattrs.prealloc_blob;\n\t\tci->i_xattrs.prealloc_blob = NULL;\n\t\tci->i_xattrs.dirty = false;\n\t\tci->i_xattrs.version++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" cap_flush_tid %d\\n\"",
            "(int)flush_tid"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" delaying issued %s -> %s, wanted %s -> %s on send\\n\"",
            "ceph_cap_string(cap->issued)",
            "ceph_cap_string(cap->issued & retain)",
            "ceph_cap_string(cap->mds_wanted)",
            "ceph_cap_string(want)"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_cap_string",
          "args": [
            "want"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_cap_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "71-116",
          "snippet": "const char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [
            "#define MAX_CAP_STR 20"
          ],
          "globals_used": [
            "static char cap_str[MAX_CAP_STR][40];",
            "static DEFINE_SPINLOCK(cap_str_lock);",
            "static int last_cap_str;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\n#define MAX_CAP_STR 20\n\nstatic char cap_str[MAX_CAP_STR][40];\nstatic DEFINE_SPINLOCK(cap_str_lock);\nstatic int last_cap_str;\n\nconst char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "jiffies",
            "ci->i_hold_caps_min"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "(retain & CEPH_CAP_PIN) == 0"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"__send_cap %p cap %p session %p %s -> %s (revoking %s)\\n\"",
            "inode",
            "cap",
            "cap->session",
            "ceph_cap_string(held)",
            "ceph_cap_string(held & retain)",
            "ceph_cap_string(revoking)"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "cap->ci->i_ceph_lock"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __send_cap(struct ceph_mds_client *mdsc, struct ceph_cap *cap,\n\t\t      int op, int used, int want, int retain, int flushing,\n\t\t      unsigned *pflush_tid)\n\t__releases(cap->ci->i_ceph_lock)\n{\n\tstruct ceph_inode_info *ci = cap->ci;\n\tstruct inode *inode = &ci->vfs_inode;\n\tu64 cap_id = cap->cap_id;\n\tint held, revoking, dropping, keep;\n\tu64 seq, issue_seq, mseq, time_warp_seq, follows;\n\tu64 size, max_size;\n\tstruct timespec mtime, atime;\n\tint wake = 0;\n\tumode_t mode;\n\tkuid_t uid;\n\tkgid_t gid;\n\tstruct ceph_mds_session *session;\n\tu64 xattr_version = 0;\n\tstruct ceph_buffer *xattr_blob = NULL;\n\tint delayed = 0;\n\tu64 flush_tid = 0;\n\tint i;\n\tint ret;\n\tbool inline_data;\n\n\theld = cap->issued | cap->implemented;\n\trevoking = cap->implemented & ~cap->issued;\n\tretain &= ~revoking;\n\tdropping = cap->issued & ~retain;\n\n\tdout(\"__send_cap %p cap %p session %p %s -> %s (revoking %s)\\n\",\n\t     inode, cap, cap->session,\n\t     ceph_cap_string(held), ceph_cap_string(held & retain),\n\t     ceph_cap_string(revoking));\n\tBUG_ON((retain & CEPH_CAP_PIN) == 0);\n\n\tsession = cap->session;\n\n\t/* don't release wanted unless we've waited a bit. */\n\tif ((ci->i_ceph_flags & CEPH_I_NODELAY) == 0 &&\n\t    time_before(jiffies, ci->i_hold_caps_min)) {\n\t\tdout(\" delaying issued %s -> %s, wanted %s -> %s on send\\n\",\n\t\t     ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(cap->issued & retain),\n\t\t     ceph_cap_string(cap->mds_wanted),\n\t\t     ceph_cap_string(want));\n\t\twant |= cap->mds_wanted;\n\t\tretain |= cap->issued;\n\t\tdelayed = 1;\n\t}\n\tci->i_ceph_flags &= ~(CEPH_I_NODELAY | CEPH_I_FLUSH);\n\n\tcap->issued &= retain;  /* drop bits we don't want */\n\tif (cap->implemented & ~cap->issued) {\n\t\t/*\n\t\t * Wake up any waiters on wanted -> needed transition.\n\t\t * This is due to the weird transition from buffered\n\t\t * to sync IO... we need to flush dirty pages _before_\n\t\t * allowing sync writes to avoid reordering.\n\t\t */\n\t\twake = 1;\n\t}\n\tcap->implemented &= cap->issued | used;\n\tcap->mds_wanted = want;\n\n\tif (flushing) {\n\t\t/*\n\t\t * assign a tid for flush operations so we can avoid\n\t\t * flush1 -> dirty1 -> flush2 -> flushack1 -> mark\n\t\t * clean type races.  track latest tid for every bit\n\t\t * so we can handle flush AxFw, flush Fw, and have the\n\t\t * first ack clean Ax.\n\t\t */\n\t\tflush_tid = ++ci->i_cap_flush_last_tid;\n\t\tif (pflush_tid)\n\t\t\t*pflush_tid = flush_tid;\n\t\tdout(\" cap_flush_tid %d\\n\", (int)flush_tid);\n\t\tfor (i = 0; i < CEPH_CAP_BITS; i++)\n\t\t\tif (flushing & (1 << i))\n\t\t\t\tci->i_cap_flush_tid[i] = flush_tid;\n\n\t\tfollows = ci->i_head_snapc->seq;\n\t} else {\n\t\tfollows = 0;\n\t}\n\n\tkeep = cap->implemented;\n\tseq = cap->seq;\n\tissue_seq = cap->issue_seq;\n\tmseq = cap->mseq;\n\tsize = inode->i_size;\n\tci->i_reported_size = size;\n\tmax_size = ci->i_wanted_max_size;\n\tci->i_requested_max_size = max_size;\n\tmtime = inode->i_mtime;\n\tatime = inode->i_atime;\n\ttime_warp_seq = ci->i_time_warp_seq;\n\tuid = inode->i_uid;\n\tgid = inode->i_gid;\n\tmode = inode->i_mode;\n\n\tif (flushing & CEPH_CAP_XATTR_EXCL) {\n\t\t__ceph_build_xattrs_blob(ci);\n\t\txattr_blob = ci->i_xattrs.blob;\n\t\txattr_version = ci->i_xattrs.version;\n\t}\n\n\tinline_data = ci->i_inline_version != CEPH_INLINE_NONE;\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tret = send_cap_msg(session, ceph_vino(inode).ino, cap_id,\n\t\top, keep, want, flushing, seq, flush_tid, issue_seq, mseq,\n\t\tsize, max_size, &mtime, &atime, time_warp_seq,\n\t\tuid, gid, mode, xattr_version, xattr_blob,\n\t\tfollows, inline_data);\n\tif (ret < 0) {\n\t\tdout(\"error sending cap msg, must requeue %p\\n\", inode);\n\t\tdelayed = 1;\n\t}\n\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\n\treturn delayed;\n}"
  },
  {
    "function_name": "ceph_queue_caps_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "1088-1099",
    "snippet": "void ceph_queue_caps_release(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct rb_node *p;\n\n\tp = rb_first(&ci->i_caps);\n\twhile (p) {\n\t\tstruct ceph_cap *cap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tp = rb_next(p);\n\t\t__ceph_remove_cap(cap, true);\n\t}\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ceph_remove_cap",
          "args": [
            "cap",
            "true"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_remove_cap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "905-960",
          "snippet": "void __ceph_remove_cap(struct ceph_cap *cap, bool queue_release)\n{\n\tstruct ceph_mds_session *session = cap->session;\n\tstruct ceph_inode_info *ci = cap->ci;\n\tstruct ceph_mds_client *mdsc =\n\t\tceph_sb_to_client(ci->vfs_inode.i_sb)->mdsc;\n\tint removed = 0;\n\n\tdout(\"__ceph_remove_cap %p from %p\\n\", cap, &ci->vfs_inode);\n\n\t/* remove from session list */\n\tspin_lock(&session->s_cap_lock);\n\t/*\n\t * s_cap_reconnect is protected by s_cap_lock. no one changes\n\t * s_cap_gen while session is in the reconnect state.\n\t */\n\tif (queue_release &&\n\t    (!session->s_cap_reconnect ||\n\t     cap->cap_gen == session->s_cap_gen))\n\t\t__queue_cap_release(session, ci->i_vino.ino, cap->cap_id,\n\t\t\t\t    cap->mseq, cap->issue_seq);\n\n\tif (session->s_cap_iterator == cap) {\n\t\t/* not yet, we are iterating over this very cap */\n\t\tdout(\"__ceph_remove_cap  delaying %p removal from session %p\\n\",\n\t\t     cap, cap->session);\n\t} else {\n\t\tlist_del_init(&cap->session_caps);\n\t\tsession->s_nr_caps--;\n\t\tcap->session = NULL;\n\t\tremoved = 1;\n\t}\n\t/* protect backpointer with s_cap_lock: see iterate_session_caps */\n\tcap->ci = NULL;\n\tspin_unlock(&session->s_cap_lock);\n\n\t/* remove from inode list */\n\trb_erase(&cap->ci_node, &ci->i_caps);\n\tif (ci->i_auth_cap == cap)\n\t\tci->i_auth_cap = NULL;\n\n\tif (removed)\n\t\tceph_put_cap(mdsc, cap);\n\n\tif (!__ceph_is_any_caps(ci) && ci->i_snap_realm) {\n\t\tstruct ceph_snap_realm *realm = ci->i_snap_realm;\n\t\tspin_lock(&realm->inodes_with_caps_lock);\n\t\tlist_del_init(&ci->i_snap_realm_item);\n\t\tci->i_snap_realm_counter++;\n\t\tci->i_snap_realm = NULL;\n\t\tspin_unlock(&realm->inodes_with_caps_lock);\n\t\tceph_put_snap_realm(mdsc, realm);\n\t}\n\tif (!__ceph_is_any_real_caps(ci))\n\t\t__cap_delay_cancel(mdsc, ci);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid __ceph_remove_cap(struct ceph_cap *cap, bool queue_release)\n{\n\tstruct ceph_mds_session *session = cap->session;\n\tstruct ceph_inode_info *ci = cap->ci;\n\tstruct ceph_mds_client *mdsc =\n\t\tceph_sb_to_client(ci->vfs_inode.i_sb)->mdsc;\n\tint removed = 0;\n\n\tdout(\"__ceph_remove_cap %p from %p\\n\", cap, &ci->vfs_inode);\n\n\t/* remove from session list */\n\tspin_lock(&session->s_cap_lock);\n\t/*\n\t * s_cap_reconnect is protected by s_cap_lock. no one changes\n\t * s_cap_gen while session is in the reconnect state.\n\t */\n\tif (queue_release &&\n\t    (!session->s_cap_reconnect ||\n\t     cap->cap_gen == session->s_cap_gen))\n\t\t__queue_cap_release(session, ci->i_vino.ino, cap->cap_id,\n\t\t\t\t    cap->mseq, cap->issue_seq);\n\n\tif (session->s_cap_iterator == cap) {\n\t\t/* not yet, we are iterating over this very cap */\n\t\tdout(\"__ceph_remove_cap  delaying %p removal from session %p\\n\",\n\t\t     cap, cap->session);\n\t} else {\n\t\tlist_del_init(&cap->session_caps);\n\t\tsession->s_nr_caps--;\n\t\tcap->session = NULL;\n\t\tremoved = 1;\n\t}\n\t/* protect backpointer with s_cap_lock: see iterate_session_caps */\n\tcap->ci = NULL;\n\tspin_unlock(&session->s_cap_lock);\n\n\t/* remove from inode list */\n\trb_erase(&cap->ci_node, &ci->i_caps);\n\tif (ci->i_auth_cap == cap)\n\t\tci->i_auth_cap = NULL;\n\n\tif (removed)\n\t\tceph_put_cap(mdsc, cap);\n\n\tif (!__ceph_is_any_caps(ci) && ci->i_snap_realm) {\n\t\tstruct ceph_snap_realm *realm = ci->i_snap_realm;\n\t\tspin_lock(&realm->inodes_with_caps_lock);\n\t\tlist_del_init(&ci->i_snap_realm_item);\n\t\tci->i_snap_realm_counter++;\n\t\tci->i_snap_realm = NULL;\n\t\tspin_unlock(&realm->inodes_with_caps_lock);\n\t\tceph_put_snap_realm(mdsc, realm);\n\t}\n\tif (!__ceph_is_any_real_caps(ci))\n\t\t__cap_delay_cancel(mdsc, ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "p"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "p",
            "structceph_cap",
            "ci_node"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&ci->i_caps"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_queue_caps_release(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct rb_node *p;\n\n\tp = rb_first(&ci->i_caps);\n\twhile (p) {\n\t\tstruct ceph_cap *cap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tp = rb_next(p);\n\t\t__ceph_remove_cap(cap, true);\n\t}\n}"
  },
  {
    "function_name": "__queue_cap_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "1046-1082",
    "snippet": "void __queue_cap_release(struct ceph_mds_session *session,\n\t\t\t u64 ino, u64 cap_id, u32 migrate_seq,\n\t\t\t u32 issue_seq)\n{\n\tstruct ceph_msg *msg;\n\tstruct ceph_mds_cap_release *head;\n\tstruct ceph_mds_cap_item *item;\n\n\tBUG_ON(!session->s_num_cap_releases);\n\tmsg = list_first_entry(&session->s_cap_releases,\n\t\t\t       struct ceph_msg, list_head);\n\n\tdout(\" adding %llx release to mds%d msg %p (%d left)\\n\",\n\t     ino, session->s_mds, msg, session->s_num_cap_releases);\n\n\tBUG_ON(msg->front.iov_len + sizeof(*item) > PAGE_CACHE_SIZE);\n\thead = msg->front.iov_base;\n\tle32_add_cpu(&head->num, 1);\n\titem = msg->front.iov_base + msg->front.iov_len;\n\titem->ino = cpu_to_le64(ino);\n\titem->cap_id = cpu_to_le64(cap_id);\n\titem->migrate_seq = cpu_to_le32(migrate_seq);\n\titem->seq = cpu_to_le32(issue_seq);\n\n\tsession->s_num_cap_releases--;\n\n\tmsg->front.iov_len += sizeof(*item);\n\tif (le32_to_cpu(head->num) == CEPH_CAPS_PER_RELEASE) {\n\t\tdout(\" release msg %p full\\n\", msg);\n\t\tlist_move_tail(&msg->list_head, &session->s_cap_releases_done);\n\t} else {\n\t\tdout(\" release msg %p at %d/%d (%d)\\n\", msg,\n\t\t     (int)le32_to_cpu(head->num),\n\t\t     (int)CEPH_CAPS_PER_RELEASE,\n\t\t     (int)msg->front.iov_len);\n\t}\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" release msg %p at %d/%d (%d)\\n\"",
            "msg",
            "(int)le32_to_cpu(head->num)",
            "(int)CEPH_CAPS_PER_RELEASE",
            "(int)msg->front.iov_len"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "head->num"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&msg->list_head",
            "&session->s_cap_releases_done"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" release msg %p full\\n\"",
            "msg"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "issue_seq"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "migrate_seq"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "cap_id"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "ino"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&head->num",
            "1"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "msg->front.iov_len + sizeof(*item) > PAGE_CACHE_SIZE"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" adding %llx release to mds%d msg %p (%d left)\\n\"",
            "ino",
            "session->s_mds",
            "msg",
            "session->s_num_cap_releases"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&session->s_cap_releases",
            "structceph_msg",
            "list_head"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!session->s_num_cap_releases"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid __queue_cap_release(struct ceph_mds_session *session,\n\t\t\t u64 ino, u64 cap_id, u32 migrate_seq,\n\t\t\t u32 issue_seq)\n{\n\tstruct ceph_msg *msg;\n\tstruct ceph_mds_cap_release *head;\n\tstruct ceph_mds_cap_item *item;\n\n\tBUG_ON(!session->s_num_cap_releases);\n\tmsg = list_first_entry(&session->s_cap_releases,\n\t\t\t       struct ceph_msg, list_head);\n\n\tdout(\" adding %llx release to mds%d msg %p (%d left)\\n\",\n\t     ino, session->s_mds, msg, session->s_num_cap_releases);\n\n\tBUG_ON(msg->front.iov_len + sizeof(*item) > PAGE_CACHE_SIZE);\n\thead = msg->front.iov_base;\n\tle32_add_cpu(&head->num, 1);\n\titem = msg->front.iov_base + msg->front.iov_len;\n\titem->ino = cpu_to_le64(ino);\n\titem->cap_id = cpu_to_le64(cap_id);\n\titem->migrate_seq = cpu_to_le32(migrate_seq);\n\titem->seq = cpu_to_le32(issue_seq);\n\n\tsession->s_num_cap_releases--;\n\n\tmsg->front.iov_len += sizeof(*item);\n\tif (le32_to_cpu(head->num) == CEPH_CAPS_PER_RELEASE) {\n\t\tdout(\" release msg %p full\\n\", msg);\n\t\tlist_move_tail(&msg->list_head, &session->s_cap_releases_done);\n\t} else {\n\t\tdout(\" release msg %p at %d/%d (%d)\\n\", msg,\n\t\t     (int)le32_to_cpu(head->num),\n\t\t     (int)CEPH_CAPS_PER_RELEASE,\n\t\t     (int)msg->front.iov_len);\n\t}\n}"
  },
  {
    "function_name": "send_cap_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "967-1044",
    "snippet": "static int send_cap_msg(struct ceph_mds_session *session,\n\t\t\tu64 ino, u64 cid, int op,\n\t\t\tint caps, int wanted, int dirty,\n\t\t\tu32 seq, u64 flush_tid, u32 issue_seq, u32 mseq,\n\t\t\tu64 size, u64 max_size,\n\t\t\tstruct timespec *mtime, struct timespec *atime,\n\t\t\tu64 time_warp_seq,\n\t\t\tkuid_t uid, kgid_t gid, umode_t mode,\n\t\t\tu64 xattr_version,\n\t\t\tstruct ceph_buffer *xattrs_buf,\n\t\t\tu64 follows, bool inline_data)\n{\n\tstruct ceph_mds_caps *fc;\n\tstruct ceph_msg *msg;\n\tvoid *p;\n\tsize_t extra_len;\n\n\tdout(\"send_cap_msg %s %llx %llx caps %s wanted %s dirty %s\"\n\t     \" seq %u/%u mseq %u follows %lld size %llu/%llu\"\n\t     \" xattr_ver %llu xattr_len %d\\n\", ceph_cap_op_name(op),\n\t     cid, ino, ceph_cap_string(caps), ceph_cap_string(wanted),\n\t     ceph_cap_string(dirty),\n\t     seq, issue_seq, mseq, follows, size, max_size,\n\t     xattr_version, xattrs_buf ? (int)xattrs_buf->vec.iov_len : 0);\n\n\t/* flock buffer size + inline version + inline data size */\n\textra_len = 4 + 8 + 4;\n\tmsg = ceph_msg_new(CEPH_MSG_CLIENT_CAPS, sizeof(*fc) + extra_len,\n\t\t\t   GFP_NOFS, false);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tmsg->hdr.tid = cpu_to_le64(flush_tid);\n\n\tfc = msg->front.iov_base;\n\tmemset(fc, 0, sizeof(*fc));\n\n\tfc->cap_id = cpu_to_le64(cid);\n\tfc->op = cpu_to_le32(op);\n\tfc->seq = cpu_to_le32(seq);\n\tfc->issue_seq = cpu_to_le32(issue_seq);\n\tfc->migrate_seq = cpu_to_le32(mseq);\n\tfc->caps = cpu_to_le32(caps);\n\tfc->wanted = cpu_to_le32(wanted);\n\tfc->dirty = cpu_to_le32(dirty);\n\tfc->ino = cpu_to_le64(ino);\n\tfc->snap_follows = cpu_to_le64(follows);\n\n\tfc->size = cpu_to_le64(size);\n\tfc->max_size = cpu_to_le64(max_size);\n\tif (mtime)\n\t\tceph_encode_timespec(&fc->mtime, mtime);\n\tif (atime)\n\t\tceph_encode_timespec(&fc->atime, atime);\n\tfc->time_warp_seq = cpu_to_le32(time_warp_seq);\n\n\tfc->uid = cpu_to_le32(from_kuid(&init_user_ns, uid));\n\tfc->gid = cpu_to_le32(from_kgid(&init_user_ns, gid));\n\tfc->mode = cpu_to_le32(mode);\n\n\tp = fc + 1;\n\t/* flock buffer size */\n\tceph_encode_32(&p, 0);\n\t/* inline version */\n\tceph_encode_64(&p, inline_data ? 0 : CEPH_INLINE_NONE);\n\t/* inline data size */\n\tceph_encode_32(&p, 0);\n\n\tfc->xattr_version = cpu_to_le64(xattr_version);\n\tif (xattrs_buf) {\n\t\tmsg->middle = ceph_buffer_get(xattrs_buf);\n\t\tfc->xattr_len = cpu_to_le32(xattrs_buf->vec.iov_len);\n\t\tmsg->hdr.middle_len = cpu_to_le32(xattrs_buf->vec.iov_len);\n\t}\n\n\tceph_con_send(&session->s_con, msg);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_con_send",
          "args": [
            "&session->s_con",
            "msg"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "xattrs_buf->vec.iov_len"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "xattrs_buf->vec.iov_len"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_buffer_get",
          "args": [
            "xattrs_buf"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "xattr_version"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_encode_32",
          "args": [
            "&p",
            "0"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_encode_64",
          "args": [
            "&p",
            "inline_data ? 0 : CEPH_INLINE_NONE"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_encode_32",
          "args": [
            "&p",
            "0"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "mode"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "from_kgid(&init_user_ns, gid)"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "gid"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "from_kuid(&init_user_ns, uid)"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "uid"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "time_warp_seq"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_encode_timespec",
          "args": [
            "&fc->atime",
            "atime"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_encode_timespec",
          "args": [
            "&fc->mtime",
            "mtime"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "max_size"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "size"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "follows"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "ino"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "dirty"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "wanted"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "caps"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "mseq"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "issue_seq"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "seq"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "op"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "cid"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "fc",
            "0",
            "sizeof(*fc)"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "flush_tid"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_msg_new",
          "args": [
            "CEPH_MSG_CLIENT_CAPS",
            "sizeof(*fc) + extra_len",
            "GFP_NOFS",
            "false"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"send_cap_msg %s %llx %llx caps %s wanted %s dirty %s\"\n\t     \" seq %u/%u mseq %u follows %lld size %llu/%llu\"\n\t     \" xattr_ver %llu xattr_len %d\\n\"",
            "ceph_cap_op_name(op)",
            "cid",
            "ino",
            "ceph_cap_string(caps)",
            "ceph_cap_string(wanted)",
            "ceph_cap_string(dirty)",
            "seq",
            "issue_seq",
            "mseq",
            "follows",
            "size",
            "max_size",
            "xattr_version",
            "xattrs_buf ? (int)xattrs_buf->vec.iov_len : 0"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_cap_string",
          "args": [
            "dirty"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_cap_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "71-116",
          "snippet": "const char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [
            "#define MAX_CAP_STR 20"
          ],
          "globals_used": [
            "static char cap_str[MAX_CAP_STR][40];",
            "static DEFINE_SPINLOCK(cap_str_lock);",
            "static int last_cap_str;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\n#define MAX_CAP_STR 20\n\nstatic char cap_str[MAX_CAP_STR][40];\nstatic DEFINE_SPINLOCK(cap_str_lock);\nstatic int last_cap_str;\n\nconst char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_cap_op_name",
          "args": [
            "op"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_cap_op_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/strings.c",
          "lines": "84-102",
          "snippet": "const char *ceph_cap_op_name(int op)\n{\n\tswitch (op) {\n\tcase CEPH_CAP_OP_GRANT: return \"grant\";\n\tcase CEPH_CAP_OP_REVOKE: return \"revoke\";\n\tcase CEPH_CAP_OP_TRUNC: return \"trunc\";\n\tcase CEPH_CAP_OP_EXPORT: return \"export\";\n\tcase CEPH_CAP_OP_IMPORT: return \"import\";\n\tcase CEPH_CAP_OP_UPDATE: return \"update\";\n\tcase CEPH_CAP_OP_DROP: return \"drop\";\n\tcase CEPH_CAP_OP_FLUSH: return \"flush\";\n\tcase CEPH_CAP_OP_FLUSH_ACK: return \"flush_ack\";\n\tcase CEPH_CAP_OP_FLUSHSNAP: return \"flushsnap\";\n\tcase CEPH_CAP_OP_FLUSHSNAP_ACK: return \"flushsnap_ack\";\n\tcase CEPH_CAP_OP_RELEASE: return \"release\";\n\tcase CEPH_CAP_OP_RENEW: return \"renew\";\n\t}\n\treturn \"???\";\n}",
          "includes": [
            "#include <linux/ceph/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/types.h>\n#include <linux/module.h>\n\nconst char *ceph_cap_op_name(int op)\n{\n\tswitch (op) {\n\tcase CEPH_CAP_OP_GRANT: return \"grant\";\n\tcase CEPH_CAP_OP_REVOKE: return \"revoke\";\n\tcase CEPH_CAP_OP_TRUNC: return \"trunc\";\n\tcase CEPH_CAP_OP_EXPORT: return \"export\";\n\tcase CEPH_CAP_OP_IMPORT: return \"import\";\n\tcase CEPH_CAP_OP_UPDATE: return \"update\";\n\tcase CEPH_CAP_OP_DROP: return \"drop\";\n\tcase CEPH_CAP_OP_FLUSH: return \"flush\";\n\tcase CEPH_CAP_OP_FLUSH_ACK: return \"flush_ack\";\n\tcase CEPH_CAP_OP_FLUSHSNAP: return \"flushsnap\";\n\tcase CEPH_CAP_OP_FLUSHSNAP_ACK: return \"flushsnap_ack\";\n\tcase CEPH_CAP_OP_RELEASE: return \"release\";\n\tcase CEPH_CAP_OP_RENEW: return \"renew\";\n\t}\n\treturn \"???\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int send_cap_msg(struct ceph_mds_session *session,\n\t\t\tu64 ino, u64 cid, int op,\n\t\t\tint caps, int wanted, int dirty,\n\t\t\tu32 seq, u64 flush_tid, u32 issue_seq, u32 mseq,\n\t\t\tu64 size, u64 max_size,\n\t\t\tstruct timespec *mtime, struct timespec *atime,\n\t\t\tu64 time_warp_seq,\n\t\t\tkuid_t uid, kgid_t gid, umode_t mode,\n\t\t\tu64 xattr_version,\n\t\t\tstruct ceph_buffer *xattrs_buf,\n\t\t\tu64 follows, bool inline_data)\n{\n\tstruct ceph_mds_caps *fc;\n\tstruct ceph_msg *msg;\n\tvoid *p;\n\tsize_t extra_len;\n\n\tdout(\"send_cap_msg %s %llx %llx caps %s wanted %s dirty %s\"\n\t     \" seq %u/%u mseq %u follows %lld size %llu/%llu\"\n\t     \" xattr_ver %llu xattr_len %d\\n\", ceph_cap_op_name(op),\n\t     cid, ino, ceph_cap_string(caps), ceph_cap_string(wanted),\n\t     ceph_cap_string(dirty),\n\t     seq, issue_seq, mseq, follows, size, max_size,\n\t     xattr_version, xattrs_buf ? (int)xattrs_buf->vec.iov_len : 0);\n\n\t/* flock buffer size + inline version + inline data size */\n\textra_len = 4 + 8 + 4;\n\tmsg = ceph_msg_new(CEPH_MSG_CLIENT_CAPS, sizeof(*fc) + extra_len,\n\t\t\t   GFP_NOFS, false);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tmsg->hdr.tid = cpu_to_le64(flush_tid);\n\n\tfc = msg->front.iov_base;\n\tmemset(fc, 0, sizeof(*fc));\n\n\tfc->cap_id = cpu_to_le64(cid);\n\tfc->op = cpu_to_le32(op);\n\tfc->seq = cpu_to_le32(seq);\n\tfc->issue_seq = cpu_to_le32(issue_seq);\n\tfc->migrate_seq = cpu_to_le32(mseq);\n\tfc->caps = cpu_to_le32(caps);\n\tfc->wanted = cpu_to_le32(wanted);\n\tfc->dirty = cpu_to_le32(dirty);\n\tfc->ino = cpu_to_le64(ino);\n\tfc->snap_follows = cpu_to_le64(follows);\n\n\tfc->size = cpu_to_le64(size);\n\tfc->max_size = cpu_to_le64(max_size);\n\tif (mtime)\n\t\tceph_encode_timespec(&fc->mtime, mtime);\n\tif (atime)\n\t\tceph_encode_timespec(&fc->atime, atime);\n\tfc->time_warp_seq = cpu_to_le32(time_warp_seq);\n\n\tfc->uid = cpu_to_le32(from_kuid(&init_user_ns, uid));\n\tfc->gid = cpu_to_le32(from_kgid(&init_user_ns, gid));\n\tfc->mode = cpu_to_le32(mode);\n\n\tp = fc + 1;\n\t/* flock buffer size */\n\tceph_encode_32(&p, 0);\n\t/* inline version */\n\tceph_encode_64(&p, inline_data ? 0 : CEPH_INLINE_NONE);\n\t/* inline data size */\n\tceph_encode_32(&p, 0);\n\n\tfc->xattr_version = cpu_to_le64(xattr_version);\n\tif (xattrs_buf) {\n\t\tmsg->middle = ceph_buffer_get(xattrs_buf);\n\t\tfc->xattr_len = cpu_to_le32(xattrs_buf->vec.iov_len);\n\t\tmsg->hdr.middle_len = cpu_to_le32(xattrs_buf->vec.iov_len);\n\t}\n\n\tceph_con_send(&session->s_con, msg);\n\treturn 0;\n}"
  },
  {
    "function_name": "__ceph_remove_cap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "905-960",
    "snippet": "void __ceph_remove_cap(struct ceph_cap *cap, bool queue_release)\n{\n\tstruct ceph_mds_session *session = cap->session;\n\tstruct ceph_inode_info *ci = cap->ci;\n\tstruct ceph_mds_client *mdsc =\n\t\tceph_sb_to_client(ci->vfs_inode.i_sb)->mdsc;\n\tint removed = 0;\n\n\tdout(\"__ceph_remove_cap %p from %p\\n\", cap, &ci->vfs_inode);\n\n\t/* remove from session list */\n\tspin_lock(&session->s_cap_lock);\n\t/*\n\t * s_cap_reconnect is protected by s_cap_lock. no one changes\n\t * s_cap_gen while session is in the reconnect state.\n\t */\n\tif (queue_release &&\n\t    (!session->s_cap_reconnect ||\n\t     cap->cap_gen == session->s_cap_gen))\n\t\t__queue_cap_release(session, ci->i_vino.ino, cap->cap_id,\n\t\t\t\t    cap->mseq, cap->issue_seq);\n\n\tif (session->s_cap_iterator == cap) {\n\t\t/* not yet, we are iterating over this very cap */\n\t\tdout(\"__ceph_remove_cap  delaying %p removal from session %p\\n\",\n\t\t     cap, cap->session);\n\t} else {\n\t\tlist_del_init(&cap->session_caps);\n\t\tsession->s_nr_caps--;\n\t\tcap->session = NULL;\n\t\tremoved = 1;\n\t}\n\t/* protect backpointer with s_cap_lock: see iterate_session_caps */\n\tcap->ci = NULL;\n\tspin_unlock(&session->s_cap_lock);\n\n\t/* remove from inode list */\n\trb_erase(&cap->ci_node, &ci->i_caps);\n\tif (ci->i_auth_cap == cap)\n\t\tci->i_auth_cap = NULL;\n\n\tif (removed)\n\t\tceph_put_cap(mdsc, cap);\n\n\tif (!__ceph_is_any_caps(ci) && ci->i_snap_realm) {\n\t\tstruct ceph_snap_realm *realm = ci->i_snap_realm;\n\t\tspin_lock(&realm->inodes_with_caps_lock);\n\t\tlist_del_init(&ci->i_snap_realm_item);\n\t\tci->i_snap_realm_counter++;\n\t\tci->i_snap_realm = NULL;\n\t\tspin_unlock(&realm->inodes_with_caps_lock);\n\t\tceph_put_snap_realm(mdsc, realm);\n\t}\n\tif (!__ceph_is_any_real_caps(ci))\n\t\t__cap_delay_cancel(mdsc, ci);\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__cap_delay_cancel",
          "args": [
            "mdsc",
            "ci"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "__cap_delay_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "459-468",
          "snippet": "static void __cap_delay_cancel(struct ceph_mds_client *mdsc,\n\t\t\t       struct ceph_inode_info *ci)\n{\n\tdout(\"__cap_delay_cancel %p\\n\", &ci->vfs_inode);\n\tif (list_empty(&ci->i_cap_delay_list))\n\t\treturn;\n\tspin_lock(&mdsc->cap_delay_lock);\n\tlist_del_init(&ci->i_cap_delay_list);\n\tspin_unlock(&mdsc->cap_delay_lock);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __cap_delay_cancel(struct ceph_mds_client *mdsc,\n\t\t\t       struct ceph_inode_info *ci)\n{\n\tdout(\"__cap_delay_cancel %p\\n\", &ci->vfs_inode);\n\tif (list_empty(&ci->i_cap_delay_list))\n\t\treturn;\n\tspin_lock(&mdsc->cap_delay_lock);\n\tlist_del_init(&ci->i_cap_delay_list);\n\tspin_unlock(&mdsc->cap_delay_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_is_any_real_caps",
          "args": [
            "ci"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_is_any_real_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "521-524",
          "snippet": "static inline bool __ceph_is_any_real_caps(struct ceph_inode_info *ci)\n{\n\treturn !RB_EMPTY_ROOT(&ci->i_caps);\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline bool __ceph_is_any_real_caps(struct ceph_inode_info *ci)\n{\n\treturn !RB_EMPTY_ROOT(&ci->i_caps);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_put_snap_realm",
          "args": [
            "mdsc",
            "realm"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_put_snap_realm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
          "lines": "204-220",
          "snippet": "void ceph_put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t struct ceph_snap_realm *realm)\n{\n\tdout(\"put_snap_realm %llx %p %d -> %d\\n\", realm->ino, realm,\n\t     atomic_read(&realm->nref), atomic_read(&realm->nref)-1);\n\tif (!atomic_dec_and_test(&realm->nref))\n\t\treturn;\n\n\tif (down_write_trylock(&mdsc->snap_rwsem)) {\n\t\t__destroy_snap_realm(mdsc, realm);\n\t\tup_write(&mdsc->snap_rwsem);\n\t} else {\n\t\tspin_lock(&mdsc->snap_empty_lock);\n\t\tlist_add(&realm->empty_item, &mdsc->snap_empty);\n\t\tspin_unlock(&mdsc->snap_empty_lock);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);\n\nvoid ceph_put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t struct ceph_snap_realm *realm)\n{\n\tdout(\"put_snap_realm %llx %p %d -> %d\\n\", realm->ino, realm,\n\t     atomic_read(&realm->nref), atomic_read(&realm->nref)-1);\n\tif (!atomic_dec_and_test(&realm->nref))\n\t\treturn;\n\n\tif (down_write_trylock(&mdsc->snap_rwsem)) {\n\t\t__destroy_snap_realm(mdsc, realm);\n\t\tup_write(&mdsc->snap_rwsem);\n\t} else {\n\t\tspin_lock(&mdsc->snap_empty_lock);\n\t\tlist_add(&realm->empty_item, &mdsc->snap_empty);\n\t\tspin_unlock(&mdsc->snap_empty_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&realm->inodes_with_caps_lock"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&ci->i_snap_realm_item"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&realm->inodes_with_caps_lock"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_is_any_caps",
          "args": [
            "ci"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_is_any_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "882-885",
          "snippet": "static int __ceph_is_any_caps(struct ceph_inode_info *ci)\n{\n\treturn !RB_EMPTY_ROOT(&ci->i_caps);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __ceph_is_any_caps(struct ceph_inode_info *ci)\n{\n\treturn !RB_EMPTY_ROOT(&ci->i_caps);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_put_cap",
          "args": [
            "mdsc",
            "cap"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_put_cap_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "2274-2326",
          "snippet": "void ceph_put_cap_refs(struct ceph_inode_info *ci, int had)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint last = 0, put = 0, flushsnaps = 0, wake = 0;\n\tstruct ceph_cap_snap *capsnap;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (had & CEPH_CAP_PIN)\n\t\t--ci->i_pin_ref;\n\tif (had & CEPH_CAP_FILE_RD)\n\t\tif (--ci->i_rd_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_CACHE)\n\t\tif (--ci->i_rdcache_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_BUFFER) {\n\t\tif (--ci->i_wb_ref == 0) {\n\t\t\tlast++;\n\t\t\tput++;\n\t\t}\n\t\tdout(\"put_cap_refs %p wb %d -> %d (?)\\n\",\n\t\t     inode, ci->i_wb_ref+1, ci->i_wb_ref);\n\t}\n\tif (had & CEPH_CAP_FILE_WR)\n\t\tif (--ci->i_wr_ref == 0) {\n\t\t\tlast++;\n\t\t\tif (!list_empty(&ci->i_cap_snaps)) {\n\t\t\t\tcapsnap = list_first_entry(&ci->i_cap_snaps,\n\t\t\t\t\t\t     struct ceph_cap_snap,\n\t\t\t\t\t\t     ci_item);\n\t\t\t\tif (capsnap->writing) {\n\t\t\t\t\tcapsnap->writing = 0;\n\t\t\t\t\tflushsnaps =\n\t\t\t\t\t\t__ceph_finish_cap_snap(ci,\n\t\t\t\t\t\t\t\t       capsnap);\n\t\t\t\t\twake = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tdout(\"put_cap_refs %p had %s%s%s\\n\", inode, ceph_cap_string(had),\n\t     last ? \" last\" : \"\", put ? \" put\" : \"\");\n\n\tif (last && !flushsnaps)\n\t\tceph_check_caps(ci, 0, NULL);\n\telse if (flushsnaps)\n\t\tceph_flush_snaps(ci);\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\tif (put)\n\t\tiput(inode);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_put_cap_refs(struct ceph_inode_info *ci, int had)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint last = 0, put = 0, flushsnaps = 0, wake = 0;\n\tstruct ceph_cap_snap *capsnap;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (had & CEPH_CAP_PIN)\n\t\t--ci->i_pin_ref;\n\tif (had & CEPH_CAP_FILE_RD)\n\t\tif (--ci->i_rd_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_CACHE)\n\t\tif (--ci->i_rdcache_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_BUFFER) {\n\t\tif (--ci->i_wb_ref == 0) {\n\t\t\tlast++;\n\t\t\tput++;\n\t\t}\n\t\tdout(\"put_cap_refs %p wb %d -> %d (?)\\n\",\n\t\t     inode, ci->i_wb_ref+1, ci->i_wb_ref);\n\t}\n\tif (had & CEPH_CAP_FILE_WR)\n\t\tif (--ci->i_wr_ref == 0) {\n\t\t\tlast++;\n\t\t\tif (!list_empty(&ci->i_cap_snaps)) {\n\t\t\t\tcapsnap = list_first_entry(&ci->i_cap_snaps,\n\t\t\t\t\t\t     struct ceph_cap_snap,\n\t\t\t\t\t\t     ci_item);\n\t\t\t\tif (capsnap->writing) {\n\t\t\t\t\tcapsnap->writing = 0;\n\t\t\t\t\tflushsnaps =\n\t\t\t\t\t\t__ceph_finish_cap_snap(ci,\n\t\t\t\t\t\t\t\t       capsnap);\n\t\t\t\t\twake = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tdout(\"put_cap_refs %p had %s%s%s\\n\", inode, ceph_cap_string(had),\n\t     last ? \" last\" : \"\", put ? \" put\" : \"\");\n\n\tif (last && !flushsnaps)\n\t\tceph_check_caps(ci, 0, NULL);\n\telse if (flushsnaps)\n\t\tceph_flush_snaps(ci);\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\tif (put)\n\t\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&cap->ci_node",
            "&ci->i_caps"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&cap->session_caps"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"__ceph_remove_cap  delaying %p removal from session %p\\n\"",
            "cap",
            "cap->session"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__queue_cap_release",
          "args": [
            "session",
            "ci->i_vino.ino",
            "cap->cap_id",
            "cap->mseq",
            "cap->issue_seq"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "__queue_cap_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "1046-1082",
          "snippet": "void __queue_cap_release(struct ceph_mds_session *session,\n\t\t\t u64 ino, u64 cap_id, u32 migrate_seq,\n\t\t\t u32 issue_seq)\n{\n\tstruct ceph_msg *msg;\n\tstruct ceph_mds_cap_release *head;\n\tstruct ceph_mds_cap_item *item;\n\n\tBUG_ON(!session->s_num_cap_releases);\n\tmsg = list_first_entry(&session->s_cap_releases,\n\t\t\t       struct ceph_msg, list_head);\n\n\tdout(\" adding %llx release to mds%d msg %p (%d left)\\n\",\n\t     ino, session->s_mds, msg, session->s_num_cap_releases);\n\n\tBUG_ON(msg->front.iov_len + sizeof(*item) > PAGE_CACHE_SIZE);\n\thead = msg->front.iov_base;\n\tle32_add_cpu(&head->num, 1);\n\titem = msg->front.iov_base + msg->front.iov_len;\n\titem->ino = cpu_to_le64(ino);\n\titem->cap_id = cpu_to_le64(cap_id);\n\titem->migrate_seq = cpu_to_le32(migrate_seq);\n\titem->seq = cpu_to_le32(issue_seq);\n\n\tsession->s_num_cap_releases--;\n\n\tmsg->front.iov_len += sizeof(*item);\n\tif (le32_to_cpu(head->num) == CEPH_CAPS_PER_RELEASE) {\n\t\tdout(\" release msg %p full\\n\", msg);\n\t\tlist_move_tail(&msg->list_head, &session->s_cap_releases_done);\n\t} else {\n\t\tdout(\" release msg %p at %d/%d (%d)\\n\", msg,\n\t\t     (int)le32_to_cpu(head->num),\n\t\t     (int)CEPH_CAPS_PER_RELEASE,\n\t\t     (int)msg->front.iov_len);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid __queue_cap_release(struct ceph_mds_session *session,\n\t\t\t u64 ino, u64 cap_id, u32 migrate_seq,\n\t\t\t u32 issue_seq)\n{\n\tstruct ceph_msg *msg;\n\tstruct ceph_mds_cap_release *head;\n\tstruct ceph_mds_cap_item *item;\n\n\tBUG_ON(!session->s_num_cap_releases);\n\tmsg = list_first_entry(&session->s_cap_releases,\n\t\t\t       struct ceph_msg, list_head);\n\n\tdout(\" adding %llx release to mds%d msg %p (%d left)\\n\",\n\t     ino, session->s_mds, msg, session->s_num_cap_releases);\n\n\tBUG_ON(msg->front.iov_len + sizeof(*item) > PAGE_CACHE_SIZE);\n\thead = msg->front.iov_base;\n\tle32_add_cpu(&head->num, 1);\n\titem = msg->front.iov_base + msg->front.iov_len;\n\titem->ino = cpu_to_le64(ino);\n\titem->cap_id = cpu_to_le64(cap_id);\n\titem->migrate_seq = cpu_to_le32(migrate_seq);\n\titem->seq = cpu_to_le32(issue_seq);\n\n\tsession->s_num_cap_releases--;\n\n\tmsg->front.iov_len += sizeof(*item);\n\tif (le32_to_cpu(head->num) == CEPH_CAPS_PER_RELEASE) {\n\t\tdout(\" release msg %p full\\n\", msg);\n\t\tlist_move_tail(&msg->list_head, &session->s_cap_releases_done);\n\t} else {\n\t\tdout(\" release msg %p at %d/%d (%d)\\n\", msg,\n\t\t     (int)le32_to_cpu(head->num),\n\t\t     (int)CEPH_CAPS_PER_RELEASE,\n\t\t     (int)msg->front.iov_len);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"__ceph_remove_cap %p from %p\\n\"",
            "cap",
            "&ci->vfs_inode"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_sb_to_client",
          "args": [
            "ci->vfs_inode.i_sb"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_sb_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "352-355",
          "snippet": "static inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid __ceph_remove_cap(struct ceph_cap *cap, bool queue_release)\n{\n\tstruct ceph_mds_session *session = cap->session;\n\tstruct ceph_inode_info *ci = cap->ci;\n\tstruct ceph_mds_client *mdsc =\n\t\tceph_sb_to_client(ci->vfs_inode.i_sb)->mdsc;\n\tint removed = 0;\n\n\tdout(\"__ceph_remove_cap %p from %p\\n\", cap, &ci->vfs_inode);\n\n\t/* remove from session list */\n\tspin_lock(&session->s_cap_lock);\n\t/*\n\t * s_cap_reconnect is protected by s_cap_lock. no one changes\n\t * s_cap_gen while session is in the reconnect state.\n\t */\n\tif (queue_release &&\n\t    (!session->s_cap_reconnect ||\n\t     cap->cap_gen == session->s_cap_gen))\n\t\t__queue_cap_release(session, ci->i_vino.ino, cap->cap_id,\n\t\t\t\t    cap->mseq, cap->issue_seq);\n\n\tif (session->s_cap_iterator == cap) {\n\t\t/* not yet, we are iterating over this very cap */\n\t\tdout(\"__ceph_remove_cap  delaying %p removal from session %p\\n\",\n\t\t     cap, cap->session);\n\t} else {\n\t\tlist_del_init(&cap->session_caps);\n\t\tsession->s_nr_caps--;\n\t\tcap->session = NULL;\n\t\tremoved = 1;\n\t}\n\t/* protect backpointer with s_cap_lock: see iterate_session_caps */\n\tcap->ci = NULL;\n\tspin_unlock(&session->s_cap_lock);\n\n\t/* remove from inode list */\n\trb_erase(&cap->ci_node, &ci->i_caps);\n\tif (ci->i_auth_cap == cap)\n\t\tci->i_auth_cap = NULL;\n\n\tif (removed)\n\t\tceph_put_cap(mdsc, cap);\n\n\tif (!__ceph_is_any_caps(ci) && ci->i_snap_realm) {\n\t\tstruct ceph_snap_realm *realm = ci->i_snap_realm;\n\t\tspin_lock(&realm->inodes_with_caps_lock);\n\t\tlist_del_init(&ci->i_snap_realm_item);\n\t\tci->i_snap_realm_counter++;\n\t\tci->i_snap_realm = NULL;\n\t\tspin_unlock(&realm->inodes_with_caps_lock);\n\t\tceph_put_snap_realm(mdsc, realm);\n\t}\n\tif (!__ceph_is_any_real_caps(ci))\n\t\t__cap_delay_cancel(mdsc, ci);\n}"
  },
  {
    "function_name": "ceph_is_any_caps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "887-897",
    "snippet": "int ceph_is_any_caps(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint ret;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tret = __ceph_is_any_caps(ci);\n\tspin_unlock(&ci->i_ceph_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_is_any_caps",
          "args": [
            "ci"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_is_any_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "882-885",
          "snippet": "static int __ceph_is_any_caps(struct ceph_inode_info *ci)\n{\n\treturn !RB_EMPTY_ROOT(&ci->i_caps);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __ceph_is_any_caps(struct ceph_inode_info *ci)\n{\n\treturn !RB_EMPTY_ROOT(&ci->i_caps);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_is_any_caps(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint ret;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tret = __ceph_is_any_caps(ci);\n\tspin_unlock(&ci->i_ceph_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__ceph_is_any_caps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "882-885",
    "snippet": "static int __ceph_is_any_caps(struct ceph_inode_info *ci)\n{\n\treturn !RB_EMPTY_ROOT(&ci->i_caps);\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RB_EMPTY_ROOT",
          "args": [
            "&ci->i_caps"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __ceph_is_any_caps(struct ceph_inode_info *ci)\n{\n\treturn !RB_EMPTY_ROOT(&ci->i_caps);\n}"
  },
  {
    "function_name": "__ceph_caps_mds_wanted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "861-877",
    "snippet": "int __ceph_caps_mds_wanted(struct ceph_inode_info *ci)\n{\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\tint mds_wanted = 0;\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (!__cap_is_valid(cap))\n\t\t\tcontinue;\n\t\tif (cap == ci->i_auth_cap)\n\t\t\tmds_wanted |= cap->mds_wanted;\n\t\telse\n\t\t\tmds_wanted |= (cap->mds_wanted & ~CEPH_CAP_ANY_FILE_WR);\n\t}\n\treturn mds_wanted;\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__cap_is_valid",
          "args": [
            "cap"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "__cap_is_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "642-660",
          "snippet": "static int __cap_is_valid(struct ceph_cap *cap)\n{\n\tunsigned long ttl;\n\tu32 gen;\n\n\tspin_lock(&cap->session->s_gen_ttl_lock);\n\tgen = cap->session->s_cap_gen;\n\tttl = cap->session->s_cap_ttl;\n\tspin_unlock(&cap->session->s_gen_ttl_lock);\n\n\tif (cap->cap_gen < gen || time_after_eq(jiffies, ttl)) {\n\t\tdout(\"__cap_is_valid %p cap %p issued %s \"\n\t\t     \"but STALE (gen %u vs %u)\\n\", &cap->ci->vfs_inode,\n\t\t     cap, ceph_cap_string(cap->issued), cap->cap_gen, gen);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __cap_is_valid(struct ceph_cap *cap)\n{\n\tunsigned long ttl;\n\tu32 gen;\n\n\tspin_lock(&cap->session->s_gen_ttl_lock);\n\tgen = cap->session->s_cap_gen;\n\tttl = cap->session->s_cap_ttl;\n\tspin_unlock(&cap->session->s_gen_ttl_lock);\n\n\tif (cap->cap_gen < gen || time_after_eq(jiffies, ttl)) {\n\t\tdout(\"__cap_is_valid %p cap %p issued %s \"\n\t\t     \"but STALE (gen %u vs %u)\\n\", &cap->ci->vfs_inode,\n\t\t     cap, ceph_cap_string(cap->issued), cap->cap_gen, gen);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "p",
            "structceph_cap",
            "ci_node"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "p"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&ci->i_caps"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_caps_mds_wanted(struct ceph_inode_info *ci)\n{\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\tint mds_wanted = 0;\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (!__cap_is_valid(cap))\n\t\t\tcontinue;\n\t\tif (cap == ci->i_auth_cap)\n\t\t\tmds_wanted |= cap->mds_wanted;\n\t\telse\n\t\t\tmds_wanted |= (cap->mds_wanted & ~CEPH_CAP_ANY_FILE_WR);\n\t}\n\treturn mds_wanted;\n}"
  },
  {
    "function_name": "__ceph_caps_file_wanted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "848-856",
    "snippet": "int __ceph_caps_file_wanted(struct ceph_inode_info *ci)\n{\n\tint want = 0;\n\tint mode;\n\tfor (mode = 0; mode < CEPH_FILE_MODE_NUM; mode++)\n\t\tif (ci->i_nr_by_mode[mode])\n\t\t\twant |= ceph_caps_for_mode(mode);\n\treturn want;\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_caps_for_mode",
          "args": [
            "mode"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_caps_file_wanted(struct ceph_inode_info *ci)\n{\n\tint want = 0;\n\tint mode;\n\tfor (mode = 0; mode < CEPH_FILE_MODE_NUM; mode++)\n\t\tif (ci->i_nr_by_mode[mode])\n\t\t\twant |= ceph_caps_for_mode(mode);\n\treturn want;\n}"
  },
  {
    "function_name": "__ceph_caps_used",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "829-843",
    "snippet": "int __ceph_caps_used(struct ceph_inode_info *ci)\n{\n\tint used = 0;\n\tif (ci->i_pin_ref)\n\t\tused |= CEPH_CAP_PIN;\n\tif (ci->i_rd_ref)\n\t\tused |= CEPH_CAP_FILE_RD;\n\tif (ci->i_rdcache_ref || ci->vfs_inode.i_data.nrpages)\n\t\tused |= CEPH_CAP_FILE_CACHE;\n\tif (ci->i_wr_ref)\n\t\tused |= CEPH_CAP_FILE_WR;\n\tif (ci->i_wb_ref || ci->i_wrbuffer_ref)\n\t\tused |= CEPH_CAP_FILE_BUFFER;\n\treturn used;\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_caps_used(struct ceph_inode_info *ci)\n{\n\tint used = 0;\n\tif (ci->i_pin_ref)\n\t\tused |= CEPH_CAP_PIN;\n\tif (ci->i_rd_ref)\n\t\tused |= CEPH_CAP_FILE_RD;\n\tif (ci->i_rdcache_ref || ci->vfs_inode.i_data.nrpages)\n\t\tused |= CEPH_CAP_FILE_CACHE;\n\tif (ci->i_wr_ref)\n\t\tused |= CEPH_CAP_FILE_WR;\n\tif (ci->i_wb_ref || ci->i_wrbuffer_ref)\n\t\tused |= CEPH_CAP_FILE_BUFFER;\n\treturn used;\n}"
  },
  {
    "function_name": "ceph_caps_revoking",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "816-827",
    "snippet": "int ceph_caps_revoking(struct ceph_inode_info *ci, int mask)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint ret;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tret = __ceph_caps_revoking_other(ci, NULL, mask);\n\tspin_unlock(&ci->i_ceph_lock);\n\tdout(\"ceph_caps_revoking %p %s = %d\\n\", inode,\n\t     ceph_cap_string(mask), ret);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"ceph_caps_revoking %p %s = %d\\n\"",
            "inode",
            "ceph_cap_string(mask)",
            "ret"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_cap_string",
          "args": [
            "mask"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_cap_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "71-116",
          "snippet": "const char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [
            "#define MAX_CAP_STR 20"
          ],
          "globals_used": [
            "static char cap_str[MAX_CAP_STR][40];",
            "static DEFINE_SPINLOCK(cap_str_lock);",
            "static int last_cap_str;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\n#define MAX_CAP_STR 20\n\nstatic char cap_str[MAX_CAP_STR][40];\nstatic DEFINE_SPINLOCK(cap_str_lock);\nstatic int last_cap_str;\n\nconst char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_caps_revoking_other",
          "args": [
            "ci",
            "NULL",
            "mask"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_caps_revoking_other",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "801-814",
          "snippet": "int __ceph_caps_revoking_other(struct ceph_inode_info *ci,\n\t\t\t       struct ceph_cap *ocap, int mask)\n{\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (cap != ocap &&\n\t\t    (cap->implemented & ~cap->issued & mask))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_caps_revoking_other(struct ceph_inode_info *ci,\n\t\t\t       struct ceph_cap *ocap, int mask)\n{\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (cap != ocap &&\n\t\t    (cap->implemented & ~cap->issued & mask))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_caps_revoking(struct ceph_inode_info *ci, int mask)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint ret;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tret = __ceph_caps_revoking_other(ci, NULL, mask);\n\tspin_unlock(&ci->i_ceph_lock);\n\tdout(\"ceph_caps_revoking %p %s = %d\\n\", inode,\n\t     ceph_cap_string(mask), ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "__ceph_caps_revoking_other",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "801-814",
    "snippet": "int __ceph_caps_revoking_other(struct ceph_inode_info *ci,\n\t\t\t       struct ceph_cap *ocap, int mask)\n{\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (cap != ocap &&\n\t\t    (cap->implemented & ~cap->issued & mask))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "p",
            "structceph_cap",
            "ci_node"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "p"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&ci->i_caps"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_caps_revoking_other(struct ceph_inode_info *ci,\n\t\t\t       struct ceph_cap *ocap, int mask)\n{\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (cap != ocap &&\n\t\t    (cap->implemented & ~cap->issued & mask))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "__ceph_caps_issued_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "742-796",
    "snippet": "int __ceph_caps_issued_mask(struct ceph_inode_info *ci, int mask, int touch)\n{\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\tint have = ci->i_snap_caps;\n\n\tif ((have & mask) == mask) {\n\t\tdout(\"__ceph_caps_issued_mask %p snap issued %s\"\n\t\t     \" (mask %s)\\n\", &ci->vfs_inode,\n\t\t     ceph_cap_string(have),\n\t\t     ceph_cap_string(mask));\n\t\treturn 1;\n\t}\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (!__cap_is_valid(cap))\n\t\t\tcontinue;\n\t\tif ((cap->issued & mask) == mask) {\n\t\t\tdout(\"__ceph_caps_issued_mask %p cap %p issued %s\"\n\t\t\t     \" (mask %s)\\n\", &ci->vfs_inode, cap,\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(mask));\n\t\t\tif (touch)\n\t\t\t\t__touch_cap(cap);\n\t\t\treturn 1;\n\t\t}\n\n\t\t/* does a combination of caps satisfy mask? */\n\t\thave |= cap->issued;\n\t\tif ((have & mask) == mask) {\n\t\t\tdout(\"__ceph_caps_issued_mask %p combo issued %s\"\n\t\t\t     \" (mask %s)\\n\", &ci->vfs_inode,\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(mask));\n\t\t\tif (touch) {\n\t\t\t\tstruct rb_node *q;\n\n\t\t\t\t/* touch this + preceding caps */\n\t\t\t\t__touch_cap(cap);\n\t\t\t\tfor (q = rb_first(&ci->i_caps); q != p;\n\t\t\t\t     q = rb_next(q)) {\n\t\t\t\t\tcap = rb_entry(q, struct ceph_cap,\n\t\t\t\t\t\t       ci_node);\n\t\t\t\t\tif (!__cap_is_valid(cap))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t__touch_cap(cap);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__touch_cap",
          "args": [
            "cap"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "__touch_cap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "721-735",
          "snippet": "static void __touch_cap(struct ceph_cap *cap)\n{\n\tstruct ceph_mds_session *s = cap->session;\n\n\tspin_lock(&s->s_cap_lock);\n\tif (s->s_cap_iterator == NULL) {\n\t\tdout(\"__touch_cap %p cap %p mds%d\\n\", &cap->ci->vfs_inode, cap,\n\t\t     s->s_mds);\n\t\tlist_move_tail(&cap->session_caps, &s->s_caps);\n\t} else {\n\t\tdout(\"__touch_cap %p cap %p mds%d NOP, iterating over caps\\n\",\n\t\t     &cap->ci->vfs_inode, cap, s->s_mds);\n\t}\n\tspin_unlock(&s->s_cap_lock);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __touch_cap(struct ceph_cap *cap)\n{\n\tstruct ceph_mds_session *s = cap->session;\n\n\tspin_lock(&s->s_cap_lock);\n\tif (s->s_cap_iterator == NULL) {\n\t\tdout(\"__touch_cap %p cap %p mds%d\\n\", &cap->ci->vfs_inode, cap,\n\t\t     s->s_mds);\n\t\tlist_move_tail(&cap->session_caps, &s->s_caps);\n\t} else {\n\t\tdout(\"__touch_cap %p cap %p mds%d NOP, iterating over caps\\n\",\n\t\t     &cap->ci->vfs_inode, cap, s->s_mds);\n\t}\n\tspin_unlock(&s->s_cap_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__cap_is_valid",
          "args": [
            "cap"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "__cap_is_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "642-660",
          "snippet": "static int __cap_is_valid(struct ceph_cap *cap)\n{\n\tunsigned long ttl;\n\tu32 gen;\n\n\tspin_lock(&cap->session->s_gen_ttl_lock);\n\tgen = cap->session->s_cap_gen;\n\tttl = cap->session->s_cap_ttl;\n\tspin_unlock(&cap->session->s_gen_ttl_lock);\n\n\tif (cap->cap_gen < gen || time_after_eq(jiffies, ttl)) {\n\t\tdout(\"__cap_is_valid %p cap %p issued %s \"\n\t\t     \"but STALE (gen %u vs %u)\\n\", &cap->ci->vfs_inode,\n\t\t     cap, ceph_cap_string(cap->issued), cap->cap_gen, gen);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __cap_is_valid(struct ceph_cap *cap)\n{\n\tunsigned long ttl;\n\tu32 gen;\n\n\tspin_lock(&cap->session->s_gen_ttl_lock);\n\tgen = cap->session->s_cap_gen;\n\tttl = cap->session->s_cap_ttl;\n\tspin_unlock(&cap->session->s_gen_ttl_lock);\n\n\tif (cap->cap_gen < gen || time_after_eq(jiffies, ttl)) {\n\t\tdout(\"__cap_is_valid %p cap %p issued %s \"\n\t\t     \"but STALE (gen %u vs %u)\\n\", &cap->ci->vfs_inode,\n\t\t     cap, ceph_cap_string(cap->issued), cap->cap_gen, gen);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "q",
            "structceph_cap",
            "ci_node"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "q"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&ci->i_caps"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"__ceph_caps_issued_mask %p combo issued %s\"\n\t\t\t     \" (mask %s)\\n\"",
            "&ci->vfs_inode",
            "ceph_cap_string(cap->issued)",
            "ceph_cap_string(mask)"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_cap_string",
          "args": [
            "mask"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_cap_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "71-116",
          "snippet": "const char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [
            "#define MAX_CAP_STR 20"
          ],
          "globals_used": [
            "static char cap_str[MAX_CAP_STR][40];",
            "static DEFINE_SPINLOCK(cap_str_lock);",
            "static int last_cap_str;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\n#define MAX_CAP_STR 20\n\nstatic char cap_str[MAX_CAP_STR][40];\nstatic DEFINE_SPINLOCK(cap_str_lock);\nstatic int last_cap_str;\n\nconst char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"__ceph_caps_issued_mask %p cap %p issued %s\"\n\t\t\t     \" (mask %s)\\n\"",
            "&ci->vfs_inode",
            "cap",
            "ceph_cap_string(cap->issued)",
            "ceph_cap_string(mask)"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "p",
            "structceph_cap",
            "ci_node"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "p"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&ci->i_caps"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"__ceph_caps_issued_mask %p snap issued %s\"\n\t\t     \" (mask %s)\\n\"",
            "&ci->vfs_inode",
            "ceph_cap_string(have)",
            "ceph_cap_string(mask)"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_caps_issued_mask(struct ceph_inode_info *ci, int mask, int touch)\n{\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\tint have = ci->i_snap_caps;\n\n\tif ((have & mask) == mask) {\n\t\tdout(\"__ceph_caps_issued_mask %p snap issued %s\"\n\t\t     \" (mask %s)\\n\", &ci->vfs_inode,\n\t\t     ceph_cap_string(have),\n\t\t     ceph_cap_string(mask));\n\t\treturn 1;\n\t}\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (!__cap_is_valid(cap))\n\t\t\tcontinue;\n\t\tif ((cap->issued & mask) == mask) {\n\t\t\tdout(\"__ceph_caps_issued_mask %p cap %p issued %s\"\n\t\t\t     \" (mask %s)\\n\", &ci->vfs_inode, cap,\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(mask));\n\t\t\tif (touch)\n\t\t\t\t__touch_cap(cap);\n\t\t\treturn 1;\n\t\t}\n\n\t\t/* does a combination of caps satisfy mask? */\n\t\thave |= cap->issued;\n\t\tif ((have & mask) == mask) {\n\t\t\tdout(\"__ceph_caps_issued_mask %p combo issued %s\"\n\t\t\t     \" (mask %s)\\n\", &ci->vfs_inode,\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(mask));\n\t\t\tif (touch) {\n\t\t\t\tstruct rb_node *q;\n\n\t\t\t\t/* touch this + preceding caps */\n\t\t\t\t__touch_cap(cap);\n\t\t\t\tfor (q = rb_first(&ci->i_caps); q != p;\n\t\t\t\t     q = rb_next(q)) {\n\t\t\t\t\tcap = rb_entry(q, struct ceph_cap,\n\t\t\t\t\t\t       ci_node);\n\t\t\t\t\tif (!__cap_is_valid(cap))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t__touch_cap(cap);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__touch_cap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "721-735",
    "snippet": "static void __touch_cap(struct ceph_cap *cap)\n{\n\tstruct ceph_mds_session *s = cap->session;\n\n\tspin_lock(&s->s_cap_lock);\n\tif (s->s_cap_iterator == NULL) {\n\t\tdout(\"__touch_cap %p cap %p mds%d\\n\", &cap->ci->vfs_inode, cap,\n\t\t     s->s_mds);\n\t\tlist_move_tail(&cap->session_caps, &s->s_caps);\n\t} else {\n\t\tdout(\"__touch_cap %p cap %p mds%d NOP, iterating over caps\\n\",\n\t\t     &cap->ci->vfs_inode, cap, s->s_mds);\n\t}\n\tspin_unlock(&s->s_cap_lock);\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&s->s_cap_lock"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"__touch_cap %p cap %p mds%d NOP, iterating over caps\\n\"",
            "&cap->ci->vfs_inode",
            "cap",
            "s->s_mds"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&cap->session_caps",
            "&s->s_caps"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"__touch_cap %p cap %p mds%d\\n\"",
            "&cap->ci->vfs_inode",
            "cap",
            "s->s_mds"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&s->s_cap_lock"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __touch_cap(struct ceph_cap *cap)\n{\n\tstruct ceph_mds_session *s = cap->session;\n\n\tspin_lock(&s->s_cap_lock);\n\tif (s->s_cap_iterator == NULL) {\n\t\tdout(\"__touch_cap %p cap %p mds%d\\n\", &cap->ci->vfs_inode, cap,\n\t\t     s->s_mds);\n\t\tlist_move_tail(&cap->session_caps, &s->s_caps);\n\t} else {\n\t\tdout(\"__touch_cap %p cap %p mds%d NOP, iterating over caps\\n\",\n\t\t     &cap->ci->vfs_inode, cap, s->s_mds);\n\t}\n\tspin_unlock(&s->s_cap_lock);\n}"
  },
  {
    "function_name": "__ceph_caps_issued_other",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "700-715",
    "snippet": "int __ceph_caps_issued_other(struct ceph_inode_info *ci, struct ceph_cap *ocap)\n{\n\tint have = ci->i_snap_caps;\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (cap == ocap)\n\t\t\tcontinue;\n\t\tif (!__cap_is_valid(cap))\n\t\t\tcontinue;\n\t\thave |= cap->issued;\n\t}\n\treturn have;\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__cap_is_valid",
          "args": [
            "cap"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "__cap_is_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "642-660",
          "snippet": "static int __cap_is_valid(struct ceph_cap *cap)\n{\n\tunsigned long ttl;\n\tu32 gen;\n\n\tspin_lock(&cap->session->s_gen_ttl_lock);\n\tgen = cap->session->s_cap_gen;\n\tttl = cap->session->s_cap_ttl;\n\tspin_unlock(&cap->session->s_gen_ttl_lock);\n\n\tif (cap->cap_gen < gen || time_after_eq(jiffies, ttl)) {\n\t\tdout(\"__cap_is_valid %p cap %p issued %s \"\n\t\t     \"but STALE (gen %u vs %u)\\n\", &cap->ci->vfs_inode,\n\t\t     cap, ceph_cap_string(cap->issued), cap->cap_gen, gen);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __cap_is_valid(struct ceph_cap *cap)\n{\n\tunsigned long ttl;\n\tu32 gen;\n\n\tspin_lock(&cap->session->s_gen_ttl_lock);\n\tgen = cap->session->s_cap_gen;\n\tttl = cap->session->s_cap_ttl;\n\tspin_unlock(&cap->session->s_gen_ttl_lock);\n\n\tif (cap->cap_gen < gen || time_after_eq(jiffies, ttl)) {\n\t\tdout(\"__cap_is_valid %p cap %p issued %s \"\n\t\t     \"but STALE (gen %u vs %u)\\n\", &cap->ci->vfs_inode,\n\t\t     cap, ceph_cap_string(cap->issued), cap->cap_gen, gen);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "p",
            "structceph_cap",
            "ci_node"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "p"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&ci->i_caps"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_caps_issued_other(struct ceph_inode_info *ci, struct ceph_cap *ocap)\n{\n\tint have = ci->i_snap_caps;\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (cap == ocap)\n\t\t\tcontinue;\n\t\tif (!__cap_is_valid(cap))\n\t\t\tcontinue;\n\t\thave |= cap->issued;\n\t}\n\treturn have;\n}"
  },
  {
    "function_name": "__ceph_caps_issued",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "667-695",
    "snippet": "int __ceph_caps_issued(struct ceph_inode_info *ci, int *implemented)\n{\n\tint have = ci->i_snap_caps;\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\n\tif (implemented)\n\t\t*implemented = 0;\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (!__cap_is_valid(cap))\n\t\t\tcontinue;\n\t\tdout(\"__ceph_caps_issued %p cap %p issued %s\\n\",\n\t\t     &ci->vfs_inode, cap, ceph_cap_string(cap->issued));\n\t\thave |= cap->issued;\n\t\tif (implemented)\n\t\t\t*implemented |= cap->implemented;\n\t}\n\t/*\n\t * exclude caps issued by non-auth MDS, but are been revoking\n\t * by the auth MDS. The non-auth MDS should be revoking/exporting\n\t * these caps, but the message is delayed.\n\t */\n\tif (ci->i_auth_cap) {\n\t\tcap = ci->i_auth_cap;\n\t\thave &= ~cap->implemented | cap->issued;\n\t}\n\treturn have;\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"__ceph_caps_issued %p cap %p issued %s\\n\"",
            "&ci->vfs_inode",
            "cap",
            "ceph_cap_string(cap->issued)"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_cap_string",
          "args": [
            "cap->issued"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_cap_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "71-116",
          "snippet": "const char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [
            "#define MAX_CAP_STR 20"
          ],
          "globals_used": [
            "static char cap_str[MAX_CAP_STR][40];",
            "static DEFINE_SPINLOCK(cap_str_lock);",
            "static int last_cap_str;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\n#define MAX_CAP_STR 20\n\nstatic char cap_str[MAX_CAP_STR][40];\nstatic DEFINE_SPINLOCK(cap_str_lock);\nstatic int last_cap_str;\n\nconst char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "__cap_is_valid",
          "args": [
            "cap"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "__cap_is_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "642-660",
          "snippet": "static int __cap_is_valid(struct ceph_cap *cap)\n{\n\tunsigned long ttl;\n\tu32 gen;\n\n\tspin_lock(&cap->session->s_gen_ttl_lock);\n\tgen = cap->session->s_cap_gen;\n\tttl = cap->session->s_cap_ttl;\n\tspin_unlock(&cap->session->s_gen_ttl_lock);\n\n\tif (cap->cap_gen < gen || time_after_eq(jiffies, ttl)) {\n\t\tdout(\"__cap_is_valid %p cap %p issued %s \"\n\t\t     \"but STALE (gen %u vs %u)\\n\", &cap->ci->vfs_inode,\n\t\t     cap, ceph_cap_string(cap->issued), cap->cap_gen, gen);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __cap_is_valid(struct ceph_cap *cap)\n{\n\tunsigned long ttl;\n\tu32 gen;\n\n\tspin_lock(&cap->session->s_gen_ttl_lock);\n\tgen = cap->session->s_cap_gen;\n\tttl = cap->session->s_cap_ttl;\n\tspin_unlock(&cap->session->s_gen_ttl_lock);\n\n\tif (cap->cap_gen < gen || time_after_eq(jiffies, ttl)) {\n\t\tdout(\"__cap_is_valid %p cap %p issued %s \"\n\t\t     \"but STALE (gen %u vs %u)\\n\", &cap->ci->vfs_inode,\n\t\t     cap, ceph_cap_string(cap->issued), cap->cap_gen, gen);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "p",
            "structceph_cap",
            "ci_node"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "p"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&ci->i_caps"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_caps_issued(struct ceph_inode_info *ci, int *implemented)\n{\n\tint have = ci->i_snap_caps;\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\n\tif (implemented)\n\t\t*implemented = 0;\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (!__cap_is_valid(cap))\n\t\t\tcontinue;\n\t\tdout(\"__ceph_caps_issued %p cap %p issued %s\\n\",\n\t\t     &ci->vfs_inode, cap, ceph_cap_string(cap->issued));\n\t\thave |= cap->issued;\n\t\tif (implemented)\n\t\t\t*implemented |= cap->implemented;\n\t}\n\t/*\n\t * exclude caps issued by non-auth MDS, but are been revoking\n\t * by the auth MDS. The non-auth MDS should be revoking/exporting\n\t * these caps, but the message is delayed.\n\t */\n\tif (ci->i_auth_cap) {\n\t\tcap = ci->i_auth_cap;\n\t\thave &= ~cap->implemented | cap->issued;\n\t}\n\treturn have;\n}"
  },
  {
    "function_name": "__cap_is_valid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "642-660",
    "snippet": "static int __cap_is_valid(struct ceph_cap *cap)\n{\n\tunsigned long ttl;\n\tu32 gen;\n\n\tspin_lock(&cap->session->s_gen_ttl_lock);\n\tgen = cap->session->s_cap_gen;\n\tttl = cap->session->s_cap_ttl;\n\tspin_unlock(&cap->session->s_gen_ttl_lock);\n\n\tif (cap->cap_gen < gen || time_after_eq(jiffies, ttl)) {\n\t\tdout(\"__cap_is_valid %p cap %p issued %s \"\n\t\t     \"but STALE (gen %u vs %u)\\n\", &cap->ci->vfs_inode,\n\t\t     cap, ceph_cap_string(cap->issued), cap->cap_gen, gen);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"__cap_is_valid %p cap %p issued %s \"\n\t\t     \"but STALE (gen %u vs %u)\\n\"",
            "&cap->ci->vfs_inode",
            "cap",
            "ceph_cap_string(cap->issued)",
            "cap->cap_gen",
            "gen"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_cap_string",
          "args": [
            "cap->issued"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_cap_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "71-116",
          "snippet": "const char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [
            "#define MAX_CAP_STR 20"
          ],
          "globals_used": [
            "static char cap_str[MAX_CAP_STR][40];",
            "static DEFINE_SPINLOCK(cap_str_lock);",
            "static int last_cap_str;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\n#define MAX_CAP_STR 20\n\nstatic char cap_str[MAX_CAP_STR][40];\nstatic DEFINE_SPINLOCK(cap_str_lock);\nstatic int last_cap_str;\n\nconst char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_after_eq",
          "args": [
            "jiffies",
            "ttl"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cap->session->s_gen_ttl_lock"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cap->session->s_gen_ttl_lock"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __cap_is_valid(struct ceph_cap *cap)\n{\n\tunsigned long ttl;\n\tu32 gen;\n\n\tspin_lock(&cap->session->s_gen_ttl_lock);\n\tgen = cap->session->s_cap_gen;\n\tttl = cap->session->s_cap_ttl;\n\tspin_unlock(&cap->session->s_gen_ttl_lock);\n\n\tif (cap->cap_gen < gen || time_after_eq(jiffies, ttl)) {\n\t\tdout(\"__cap_is_valid %p cap %p issued %s \"\n\t\t     \"but STALE (gen %u vs %u)\\n\", &cap->ci->vfs_inode,\n\t\t     cap, ceph_cap_string(cap->issued), cap->cap_gen, gen);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "ceph_add_cap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "511-635",
    "snippet": "void ceph_add_cap(struct inode *inode,\n\t\t  struct ceph_mds_session *session, u64 cap_id,\n\t\t  int fmode, unsigned issued, unsigned wanted,\n\t\t  unsigned seq, unsigned mseq, u64 realmino, int flags,\n\t\t  struct ceph_cap **new_cap)\n{\n\tstruct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_cap *cap;\n\tint mds = session->s_mds;\n\tint actual_wanted;\n\n\tdout(\"add_cap %p mds%d cap %llx %s seq %d\\n\", inode,\n\t     session->s_mds, cap_id, ceph_cap_string(issued), seq);\n\n\t/*\n\t * If we are opening the file, include file mode wanted bits\n\t * in wanted.\n\t */\n\tif (fmode >= 0)\n\t\twanted |= ceph_caps_for_mode(fmode);\n\n\tcap = __get_cap_for_mds(ci, mds);\n\tif (!cap) {\n\t\tcap = *new_cap;\n\t\t*new_cap = NULL;\n\n\t\tcap->issued = 0;\n\t\tcap->implemented = 0;\n\t\tcap->mds = mds;\n\t\tcap->mds_wanted = 0;\n\t\tcap->mseq = 0;\n\n\t\tcap->ci = ci;\n\t\t__insert_cap_node(ci, cap);\n\n\t\t/* add to session cap list */\n\t\tcap->session = session;\n\t\tspin_lock(&session->s_cap_lock);\n\t\tlist_add_tail(&cap->session_caps, &session->s_caps);\n\t\tsession->s_nr_caps++;\n\t\tspin_unlock(&session->s_cap_lock);\n\t} else {\n\t\t/*\n\t\t * auth mds of the inode changed. we received the cap export\n\t\t * message, but still haven't received the cap import message.\n\t\t * handle_cap_export() updated the new auth MDS' cap.\n\t\t *\n\t\t * \"ceph_seq_cmp(seq, cap->seq) <= 0\" means we are processing\n\t\t * a message that was send before the cap import message. So\n\t\t * don't remove caps.\n\t\t */\n\t\tif (ceph_seq_cmp(seq, cap->seq) <= 0) {\n\t\t\tWARN_ON(cap != ci->i_auth_cap);\n\t\t\tWARN_ON(cap->cap_id != cap_id);\n\t\t\tseq = cap->seq;\n\t\t\tmseq = cap->mseq;\n\t\t\tissued |= cap->issued;\n\t\t\tflags |= CEPH_CAP_FLAG_AUTH;\n\t\t}\n\t}\n\n\tif (!ci->i_snap_realm) {\n\t\t/*\n\t\t * add this inode to the appropriate snap realm\n\t\t */\n\t\tstruct ceph_snap_realm *realm = ceph_lookup_snap_realm(mdsc,\n\t\t\t\t\t\t\t       realmino);\n\t\tif (realm) {\n\t\t\tspin_lock(&realm->inodes_with_caps_lock);\n\t\t\tci->i_snap_realm = realm;\n\t\t\tlist_add(&ci->i_snap_realm_item,\n\t\t\t\t &realm->inodes_with_caps);\n\t\t\tspin_unlock(&realm->inodes_with_caps_lock);\n\t\t} else {\n\t\t\tpr_err(\"ceph_add_cap: couldn't find snap realm %llx\\n\",\n\t\t\t       realmino);\n\t\t\tWARN_ON(!realm);\n\t\t}\n\t}\n\n\t__check_cap_issue(ci, cap, issued);\n\n\t/*\n\t * If we are issued caps we don't want, or the mds' wanted\n\t * value appears to be off, queue a check so we'll release\n\t * later and/or update the mds wanted value.\n\t */\n\tactual_wanted = __ceph_caps_wanted(ci);\n\tif ((wanted & ~actual_wanted) ||\n\t    (issued & ~actual_wanted & CEPH_CAP_ANY_WR)) {\n\t\tdout(\" issued %s, mds wanted %s, actual %s, queueing\\n\",\n\t\t     ceph_cap_string(issued), ceph_cap_string(wanted),\n\t\t     ceph_cap_string(actual_wanted));\n\t\t__cap_delay_requeue(mdsc, ci);\n\t}\n\n\tif (flags & CEPH_CAP_FLAG_AUTH) {\n\t\tif (ci->i_auth_cap == NULL ||\n\t\t    ceph_seq_cmp(ci->i_auth_cap->mseq, mseq) < 0) {\n\t\t\tci->i_auth_cap = cap;\n\t\t\tcap->mds_wanted = wanted;\n\t\t}\n\t} else {\n\t\tWARN_ON(ci->i_auth_cap == cap);\n\t}\n\n\tdout(\"add_cap inode %p (%llx.%llx) cap %p %s now %s seq %d mds%d\\n\",\n\t     inode, ceph_vinop(inode), cap, ceph_cap_string(issued),\n\t     ceph_cap_string(issued|cap->issued), seq, mds);\n\tcap->cap_id = cap_id;\n\tcap->issued = issued;\n\tcap->implemented |= issued;\n\tif (ceph_seq_cmp(mseq, cap->mseq) > 0)\n\t\tcap->mds_wanted = wanted;\n\telse\n\t\tcap->mds_wanted |= wanted;\n\tcap->seq = seq;\n\tcap->issue_seq = seq;\n\tcap->mseq = mseq;\n\tcap->cap_gen = session->s_cap_gen;\n\n\tif (fmode >= 0)\n\t\t__ceph_get_fmode(ci, fmode);\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ceph_get_fmode",
          "args": [
            "ci",
            "fmode"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_get_fmode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "872-875",
          "snippet": "static inline void __ceph_get_fmode(struct ceph_inode_info *ci, int mode)\n{\n\tci->i_nr_by_mode[mode]++;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline void __ceph_get_fmode(struct ceph_inode_info *ci, int mode)\n{\n\tci->i_nr_by_mode[mode]++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_seq_cmp",
          "args": [
            "mseq",
            "cap->mseq"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"add_cap inode %p (%llx.%llx) cap %p %s now %s seq %d mds%d\\n\"",
            "inode",
            "ceph_vinop(inode)",
            "cap",
            "ceph_cap_string(issued)",
            "ceph_cap_string(issued|cap->issued)",
            "seq",
            "mds"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_cap_string",
          "args": [
            "issued|cap->issued"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_cap_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "71-116",
          "snippet": "const char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [
            "#define MAX_CAP_STR 20"
          ],
          "globals_used": [
            "static char cap_str[MAX_CAP_STR][40];",
            "static DEFINE_SPINLOCK(cap_str_lock);",
            "static int last_cap_str;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\n#define MAX_CAP_STR 20\n\nstatic char cap_str[MAX_CAP_STR][40];\nstatic DEFINE_SPINLOCK(cap_str_lock);\nstatic int last_cap_str;\n\nconst char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_vinop",
          "args": [
            "inode"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ci->i_auth_cap == cap"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_seq_cmp",
          "args": [
            "ci->i_auth_cap->mseq",
            "mseq"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__cap_delay_requeue",
          "args": [
            "mdsc",
            "ci"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "__cap_delay_requeue_front",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "442-452",
          "snippet": "static void __cap_delay_requeue_front(struct ceph_mds_client *mdsc,\n\t\t\t\t      struct ceph_inode_info *ci)\n{\n\tdout(\"__cap_delay_requeue_front %p\\n\", &ci->vfs_inode);\n\tspin_lock(&mdsc->cap_delay_lock);\n\tci->i_ceph_flags |= CEPH_I_FLUSH;\n\tif (!list_empty(&ci->i_cap_delay_list))\n\t\tlist_del_init(&ci->i_cap_delay_list);\n\tlist_add(&ci->i_cap_delay_list, &mdsc->cap_delay_list);\n\tspin_unlock(&mdsc->cap_delay_lock);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __cap_delay_requeue_front(struct ceph_mds_client *mdsc,\n\t\t\t\t      struct ceph_inode_info *ci)\n{\n\tdout(\"__cap_delay_requeue_front %p\\n\", &ci->vfs_inode);\n\tspin_lock(&mdsc->cap_delay_lock);\n\tci->i_ceph_flags |= CEPH_I_FLUSH;\n\tif (!list_empty(&ci->i_cap_delay_list))\n\t\tlist_del_init(&ci->i_cap_delay_list);\n\tlist_add(&ci->i_cap_delay_list, &mdsc->cap_delay_list);\n\tspin_unlock(&mdsc->cap_delay_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" issued %s, mds wanted %s, actual %s, queueing\\n\"",
            "ceph_cap_string(issued)",
            "ceph_cap_string(wanted)",
            "ceph_cap_string(actual_wanted)"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ceph_caps_wanted",
          "args": [
            "ci"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_caps_wanted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "566-572",
          "snippet": "static inline int __ceph_caps_wanted(struct ceph_inode_info *ci)\n{\n\tint w = __ceph_caps_file_wanted(ci) | __ceph_caps_used(ci);\n\tif (w & CEPH_CAP_FILE_BUFFER)\n\t\tw |= CEPH_CAP_FILE_EXCL;  /* we want EXCL if dirty data */\n\treturn w;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline int __ceph_caps_wanted(struct ceph_inode_info *ci)\n{\n\tint w = __ceph_caps_file_wanted(ci) | __ceph_caps_used(ci);\n\tif (w & CEPH_CAP_FILE_BUFFER)\n\t\tw |= CEPH_CAP_FILE_EXCL;  /* we want EXCL if dirty data */\n\treturn w;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__check_cap_issue",
          "args": [
            "ci",
            "cap",
            "issued"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "__check_cap_issue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "473-500",
          "snippet": "static void __check_cap_issue(struct ceph_inode_info *ci, struct ceph_cap *cap,\n\t\t\t      unsigned issued)\n{\n\tunsigned had = __ceph_caps_issued(ci, NULL);\n\n\t/*\n\t * Each time we receive FILE_CACHE anew, we increment\n\t * i_rdcache_gen.\n\t */\n\tif ((issued & (CEPH_CAP_FILE_CACHE|CEPH_CAP_FILE_LAZYIO)) &&\n\t    (had & (CEPH_CAP_FILE_CACHE|CEPH_CAP_FILE_LAZYIO)) == 0) {\n\t\tci->i_rdcache_gen++;\n\t}\n\n\t/*\n\t * if we are newly issued FILE_SHARED, mark dir not complete; we\n\t * don't know what happened to this directory while we didn't\n\t * have the cap.\n\t */\n\tif ((issued & CEPH_CAP_FILE_SHARED) &&\n\t    (had & CEPH_CAP_FILE_SHARED) == 0) {\n\t\tci->i_shared_gen++;\n\t\tif (S_ISDIR(ci->vfs_inode.i_mode)) {\n\t\t\tdout(\" marking %p NOT complete\\n\", &ci->vfs_inode);\n\t\t\t__ceph_dir_clear_complete(ci);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __check_cap_issue(struct ceph_inode_info *ci, struct ceph_cap *cap,\n\t\t\t      unsigned issued)\n{\n\tunsigned had = __ceph_caps_issued(ci, NULL);\n\n\t/*\n\t * Each time we receive FILE_CACHE anew, we increment\n\t * i_rdcache_gen.\n\t */\n\tif ((issued & (CEPH_CAP_FILE_CACHE|CEPH_CAP_FILE_LAZYIO)) &&\n\t    (had & (CEPH_CAP_FILE_CACHE|CEPH_CAP_FILE_LAZYIO)) == 0) {\n\t\tci->i_rdcache_gen++;\n\t}\n\n\t/*\n\t * if we are newly issued FILE_SHARED, mark dir not complete; we\n\t * don't know what happened to this directory while we didn't\n\t * have the cap.\n\t */\n\tif ((issued & CEPH_CAP_FILE_SHARED) &&\n\t    (had & CEPH_CAP_FILE_SHARED) == 0) {\n\t\tci->i_shared_gen++;\n\t\tif (S_ISDIR(ci->vfs_inode.i_mode)) {\n\t\t\tdout(\" marking %p NOT complete\\n\", &ci->vfs_inode);\n\t\t\t__ceph_dir_clear_complete(ci);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!realm"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"ceph_add_cap: couldn't find snap realm %llx\\n\"",
            "realmino"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&realm->inodes_with_caps_lock"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&ci->i_snap_realm_item",
            "&realm->inodes_with_caps"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&realm->inodes_with_caps_lock"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_lookup_snap_realm",
          "args": [
            "mdsc",
            "realmino"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_lookup_snap_realm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
          "lines": "155-163",
          "snippet": "struct ceph_snap_realm *ceph_lookup_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t\t\t       u64 ino)\n{\n\tstruct ceph_snap_realm *r;\n\tr = __lookup_snap_realm(mdsc, ino);\n\tif (r)\n\t\tceph_get_snap_realm(mdsc, r);\n\treturn r;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct ceph_snap_realm *ceph_lookup_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t\t\t       u64 ino)\n{\n\tstruct ceph_snap_realm *r;\n\tr = __lookup_snap_realm(mdsc, ino);\n\tif (r)\n\t\tceph_get_snap_realm(mdsc, r);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "cap->cap_id != cap_id"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "cap != ci->i_auth_cap"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_seq_cmp",
          "args": [
            "seq",
            "cap->seq"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&cap->session_caps",
            "&session->s_caps"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__insert_cap_node",
          "args": [
            "ci",
            "cap"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "__insert_cap_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "371-391",
          "snippet": "static void __insert_cap_node(struct ceph_inode_info *ci,\n\t\t\t      struct ceph_cap *new)\n{\n\tstruct rb_node **p = &ci->i_caps.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct ceph_cap *cap = NULL;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tcap = rb_entry(parent, struct ceph_cap, ci_node);\n\t\tif (new->mds < cap->mds)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (new->mds > cap->mds)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tBUG();\n\t}\n\n\trb_link_node(&new->ci_node, parent, p);\n\trb_insert_color(&new->ci_node, &ci->i_caps);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __insert_cap_node(struct ceph_inode_info *ci,\n\t\t\t      struct ceph_cap *new)\n{\n\tstruct rb_node **p = &ci->i_caps.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct ceph_cap *cap = NULL;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tcap = rb_entry(parent, struct ceph_cap, ci_node);\n\t\tif (new->mds < cap->mds)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (new->mds > cap->mds)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tBUG();\n\t}\n\n\trb_link_node(&new->ci_node, parent, p);\n\trb_insert_color(&new->ci_node, &ci->i_caps);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_cap_for_mds",
          "args": [
            "ci",
            "mds"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "__get_cap_for_mds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "310-325",
          "snippet": "static struct ceph_cap *__get_cap_for_mds(struct ceph_inode_info *ci, int mds)\n{\n\tstruct ceph_cap *cap;\n\tstruct rb_node *n = ci->i_caps.rb_node;\n\n\twhile (n) {\n\t\tcap = rb_entry(n, struct ceph_cap, ci_node);\n\t\tif (mds < cap->mds)\n\t\t\tn = n->rb_left;\n\t\telse if (mds > cap->mds)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn cap;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_cap *__get_cap_for_mds(struct ceph_inode_info *ci, int mds)\n{\n\tstruct ceph_cap *cap;\n\tstruct rb_node *n = ci->i_caps.rb_node;\n\n\twhile (n) {\n\t\tcap = rb_entry(n, struct ceph_cap, ci_node);\n\t\tif (mds < cap->mds)\n\t\t\tn = n->rb_left;\n\t\telse if (mds > cap->mds)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn cap;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_caps_for_mode",
          "args": [
            "fmode"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"add_cap %p mds%d cap %llx %s seq %d\\n\"",
            "inode",
            "session->s_mds",
            "cap_id",
            "ceph_cap_string(issued)",
            "seq"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_add_cap(struct inode *inode,\n\t\t  struct ceph_mds_session *session, u64 cap_id,\n\t\t  int fmode, unsigned issued, unsigned wanted,\n\t\t  unsigned seq, unsigned mseq, u64 realmino, int flags,\n\t\t  struct ceph_cap **new_cap)\n{\n\tstruct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_cap *cap;\n\tint mds = session->s_mds;\n\tint actual_wanted;\n\n\tdout(\"add_cap %p mds%d cap %llx %s seq %d\\n\", inode,\n\t     session->s_mds, cap_id, ceph_cap_string(issued), seq);\n\n\t/*\n\t * If we are opening the file, include file mode wanted bits\n\t * in wanted.\n\t */\n\tif (fmode >= 0)\n\t\twanted |= ceph_caps_for_mode(fmode);\n\n\tcap = __get_cap_for_mds(ci, mds);\n\tif (!cap) {\n\t\tcap = *new_cap;\n\t\t*new_cap = NULL;\n\n\t\tcap->issued = 0;\n\t\tcap->implemented = 0;\n\t\tcap->mds = mds;\n\t\tcap->mds_wanted = 0;\n\t\tcap->mseq = 0;\n\n\t\tcap->ci = ci;\n\t\t__insert_cap_node(ci, cap);\n\n\t\t/* add to session cap list */\n\t\tcap->session = session;\n\t\tspin_lock(&session->s_cap_lock);\n\t\tlist_add_tail(&cap->session_caps, &session->s_caps);\n\t\tsession->s_nr_caps++;\n\t\tspin_unlock(&session->s_cap_lock);\n\t} else {\n\t\t/*\n\t\t * auth mds of the inode changed. we received the cap export\n\t\t * message, but still haven't received the cap import message.\n\t\t * handle_cap_export() updated the new auth MDS' cap.\n\t\t *\n\t\t * \"ceph_seq_cmp(seq, cap->seq) <= 0\" means we are processing\n\t\t * a message that was send before the cap import message. So\n\t\t * don't remove caps.\n\t\t */\n\t\tif (ceph_seq_cmp(seq, cap->seq) <= 0) {\n\t\t\tWARN_ON(cap != ci->i_auth_cap);\n\t\t\tWARN_ON(cap->cap_id != cap_id);\n\t\t\tseq = cap->seq;\n\t\t\tmseq = cap->mseq;\n\t\t\tissued |= cap->issued;\n\t\t\tflags |= CEPH_CAP_FLAG_AUTH;\n\t\t}\n\t}\n\n\tif (!ci->i_snap_realm) {\n\t\t/*\n\t\t * add this inode to the appropriate snap realm\n\t\t */\n\t\tstruct ceph_snap_realm *realm = ceph_lookup_snap_realm(mdsc,\n\t\t\t\t\t\t\t       realmino);\n\t\tif (realm) {\n\t\t\tspin_lock(&realm->inodes_with_caps_lock);\n\t\t\tci->i_snap_realm = realm;\n\t\t\tlist_add(&ci->i_snap_realm_item,\n\t\t\t\t &realm->inodes_with_caps);\n\t\t\tspin_unlock(&realm->inodes_with_caps_lock);\n\t\t} else {\n\t\t\tpr_err(\"ceph_add_cap: couldn't find snap realm %llx\\n\",\n\t\t\t       realmino);\n\t\t\tWARN_ON(!realm);\n\t\t}\n\t}\n\n\t__check_cap_issue(ci, cap, issued);\n\n\t/*\n\t * If we are issued caps we don't want, or the mds' wanted\n\t * value appears to be off, queue a check so we'll release\n\t * later and/or update the mds wanted value.\n\t */\n\tactual_wanted = __ceph_caps_wanted(ci);\n\tif ((wanted & ~actual_wanted) ||\n\t    (issued & ~actual_wanted & CEPH_CAP_ANY_WR)) {\n\t\tdout(\" issued %s, mds wanted %s, actual %s, queueing\\n\",\n\t\t     ceph_cap_string(issued), ceph_cap_string(wanted),\n\t\t     ceph_cap_string(actual_wanted));\n\t\t__cap_delay_requeue(mdsc, ci);\n\t}\n\n\tif (flags & CEPH_CAP_FLAG_AUTH) {\n\t\tif (ci->i_auth_cap == NULL ||\n\t\t    ceph_seq_cmp(ci->i_auth_cap->mseq, mseq) < 0) {\n\t\t\tci->i_auth_cap = cap;\n\t\t\tcap->mds_wanted = wanted;\n\t\t}\n\t} else {\n\t\tWARN_ON(ci->i_auth_cap == cap);\n\t}\n\n\tdout(\"add_cap inode %p (%llx.%llx) cap %p %s now %s seq %d mds%d\\n\",\n\t     inode, ceph_vinop(inode), cap, ceph_cap_string(issued),\n\t     ceph_cap_string(issued|cap->issued), seq, mds);\n\tcap->cap_id = cap_id;\n\tcap->issued = issued;\n\tcap->implemented |= issued;\n\tif (ceph_seq_cmp(mseq, cap->mseq) > 0)\n\t\tcap->mds_wanted = wanted;\n\telse\n\t\tcap->mds_wanted |= wanted;\n\tcap->seq = seq;\n\tcap->issue_seq = seq;\n\tcap->mseq = mseq;\n\tcap->cap_gen = session->s_cap_gen;\n\n\tif (fmode >= 0)\n\t\t__ceph_get_fmode(ci, fmode);\n}"
  },
  {
    "function_name": "__check_cap_issue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "473-500",
    "snippet": "static void __check_cap_issue(struct ceph_inode_info *ci, struct ceph_cap *cap,\n\t\t\t      unsigned issued)\n{\n\tunsigned had = __ceph_caps_issued(ci, NULL);\n\n\t/*\n\t * Each time we receive FILE_CACHE anew, we increment\n\t * i_rdcache_gen.\n\t */\n\tif ((issued & (CEPH_CAP_FILE_CACHE|CEPH_CAP_FILE_LAZYIO)) &&\n\t    (had & (CEPH_CAP_FILE_CACHE|CEPH_CAP_FILE_LAZYIO)) == 0) {\n\t\tci->i_rdcache_gen++;\n\t}\n\n\t/*\n\t * if we are newly issued FILE_SHARED, mark dir not complete; we\n\t * don't know what happened to this directory while we didn't\n\t * have the cap.\n\t */\n\tif ((issued & CEPH_CAP_FILE_SHARED) &&\n\t    (had & CEPH_CAP_FILE_SHARED) == 0) {\n\t\tci->i_shared_gen++;\n\t\tif (S_ISDIR(ci->vfs_inode.i_mode)) {\n\t\t\tdout(\" marking %p NOT complete\\n\", &ci->vfs_inode);\n\t\t\t__ceph_dir_clear_complete(ci);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ceph_dir_clear_complete",
          "args": [
            "ci"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_dir_clear_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "455-458",
          "snippet": "static inline void __ceph_dir_clear_complete(struct ceph_inode_info *ci)\n{\n\tatomic_inc(&ci->i_release_count);\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline void __ceph_dir_clear_complete(struct ceph_inode_info *ci)\n{\n\tatomic_inc(&ci->i_release_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" marking %p NOT complete\\n\"",
            "&ci->vfs_inode"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "ci->vfs_inode.i_mode"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ceph_caps_issued",
          "args": [
            "ci",
            "NULL"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_caps_issued_other",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "700-715",
          "snippet": "int __ceph_caps_issued_other(struct ceph_inode_info *ci, struct ceph_cap *ocap)\n{\n\tint have = ci->i_snap_caps;\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (cap == ocap)\n\t\t\tcontinue;\n\t\tif (!__cap_is_valid(cap))\n\t\t\tcontinue;\n\t\thave |= cap->issued;\n\t}\n\treturn have;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_caps_issued_other(struct ceph_inode_info *ci, struct ceph_cap *ocap)\n{\n\tint have = ci->i_snap_caps;\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (cap == ocap)\n\t\t\tcontinue;\n\t\tif (!__cap_is_valid(cap))\n\t\t\tcontinue;\n\t\thave |= cap->issued;\n\t}\n\treturn have;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __check_cap_issue(struct ceph_inode_info *ci, struct ceph_cap *cap,\n\t\t\t      unsigned issued)\n{\n\tunsigned had = __ceph_caps_issued(ci, NULL);\n\n\t/*\n\t * Each time we receive FILE_CACHE anew, we increment\n\t * i_rdcache_gen.\n\t */\n\tif ((issued & (CEPH_CAP_FILE_CACHE|CEPH_CAP_FILE_LAZYIO)) &&\n\t    (had & (CEPH_CAP_FILE_CACHE|CEPH_CAP_FILE_LAZYIO)) == 0) {\n\t\tci->i_rdcache_gen++;\n\t}\n\n\t/*\n\t * if we are newly issued FILE_SHARED, mark dir not complete; we\n\t * don't know what happened to this directory while we didn't\n\t * have the cap.\n\t */\n\tif ((issued & CEPH_CAP_FILE_SHARED) &&\n\t    (had & CEPH_CAP_FILE_SHARED) == 0) {\n\t\tci->i_shared_gen++;\n\t\tif (S_ISDIR(ci->vfs_inode.i_mode)) {\n\t\t\tdout(\" marking %p NOT complete\\n\", &ci->vfs_inode);\n\t\t\t__ceph_dir_clear_complete(ci);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "__cap_delay_cancel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "459-468",
    "snippet": "static void __cap_delay_cancel(struct ceph_mds_client *mdsc,\n\t\t\t       struct ceph_inode_info *ci)\n{\n\tdout(\"__cap_delay_cancel %p\\n\", &ci->vfs_inode);\n\tif (list_empty(&ci->i_cap_delay_list))\n\t\treturn;\n\tspin_lock(&mdsc->cap_delay_lock);\n\tlist_del_init(&ci->i_cap_delay_list);\n\tspin_unlock(&mdsc->cap_delay_lock);\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mdsc->cap_delay_lock"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&ci->i_cap_delay_list"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mdsc->cap_delay_lock"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ci->i_cap_delay_list"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"__cap_delay_cancel %p\\n\"",
            "&ci->vfs_inode"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __cap_delay_cancel(struct ceph_mds_client *mdsc,\n\t\t\t       struct ceph_inode_info *ci)\n{\n\tdout(\"__cap_delay_cancel %p\\n\", &ci->vfs_inode);\n\tif (list_empty(&ci->i_cap_delay_list))\n\t\treturn;\n\tspin_lock(&mdsc->cap_delay_lock);\n\tlist_del_init(&ci->i_cap_delay_list);\n\tspin_unlock(&mdsc->cap_delay_lock);\n}"
  },
  {
    "function_name": "__cap_delay_requeue_front",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "442-452",
    "snippet": "static void __cap_delay_requeue_front(struct ceph_mds_client *mdsc,\n\t\t\t\t      struct ceph_inode_info *ci)\n{\n\tdout(\"__cap_delay_requeue_front %p\\n\", &ci->vfs_inode);\n\tspin_lock(&mdsc->cap_delay_lock);\n\tci->i_ceph_flags |= CEPH_I_FLUSH;\n\tif (!list_empty(&ci->i_cap_delay_list))\n\t\tlist_del_init(&ci->i_cap_delay_list);\n\tlist_add(&ci->i_cap_delay_list, &mdsc->cap_delay_list);\n\tspin_unlock(&mdsc->cap_delay_lock);\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mdsc->cap_delay_lock"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&ci->i_cap_delay_list",
            "&mdsc->cap_delay_list"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&ci->i_cap_delay_list"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ci->i_cap_delay_list"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mdsc->cap_delay_lock"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"__cap_delay_requeue_front %p\\n\"",
            "&ci->vfs_inode"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __cap_delay_requeue_front(struct ceph_mds_client *mdsc,\n\t\t\t\t      struct ceph_inode_info *ci)\n{\n\tdout(\"__cap_delay_requeue_front %p\\n\", &ci->vfs_inode);\n\tspin_lock(&mdsc->cap_delay_lock);\n\tci->i_ceph_flags |= CEPH_I_FLUSH;\n\tif (!list_empty(&ci->i_cap_delay_list))\n\t\tlist_del_init(&ci->i_cap_delay_list);\n\tlist_add(&ci->i_cap_delay_list, &mdsc->cap_delay_list);\n\tspin_unlock(&mdsc->cap_delay_lock);\n}"
  },
  {
    "function_name": "__cap_delay_requeue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "418-435",
    "snippet": "static void __cap_delay_requeue(struct ceph_mds_client *mdsc,\n\t\t\t\tstruct ceph_inode_info *ci)\n{\n\t__cap_set_timeouts(mdsc, ci);\n\tdout(\"__cap_delay_requeue %p flags %d at %lu\\n\", &ci->vfs_inode,\n\t     ci->i_ceph_flags, ci->i_hold_caps_max);\n\tif (!mdsc->stopping) {\n\t\tspin_lock(&mdsc->cap_delay_lock);\n\t\tif (!list_empty(&ci->i_cap_delay_list)) {\n\t\t\tif (ci->i_ceph_flags & CEPH_I_FLUSH)\n\t\t\t\tgoto no_change;\n\t\t\tlist_del_init(&ci->i_cap_delay_list);\n\t\t}\n\t\tlist_add_tail(&ci->i_cap_delay_list, &mdsc->cap_delay_list);\nno_change:\n\t\tspin_unlock(&mdsc->cap_delay_lock);\n\t}\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mdsc->cap_delay_lock"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&ci->i_cap_delay_list",
            "&mdsc->cap_delay_list"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&ci->i_cap_delay_list"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ci->i_cap_delay_list"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mdsc->cap_delay_lock"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"__cap_delay_requeue %p flags %d at %lu\\n\"",
            "&ci->vfs_inode",
            "ci->i_ceph_flags",
            "ci->i_hold_caps_max"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__cap_set_timeouts",
          "args": [
            "mdsc",
            "ci"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "__cap_set_timeouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "397-408",
          "snippet": "static void __cap_set_timeouts(struct ceph_mds_client *mdsc,\n\t\t\t       struct ceph_inode_info *ci)\n{\n\tstruct ceph_mount_options *ma = mdsc->fsc->mount_options;\n\n\tci->i_hold_caps_min = round_jiffies(jiffies +\n\t\t\t\t\t    ma->caps_wanted_delay_min * HZ);\n\tci->i_hold_caps_max = round_jiffies(jiffies +\n\t\t\t\t\t    ma->caps_wanted_delay_max * HZ);\n\tdout(\"__cap_set_timeouts %p min %lu max %lu\\n\", &ci->vfs_inode,\n\t     ci->i_hold_caps_min - jiffies, ci->i_hold_caps_max - jiffies);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __cap_set_timeouts(struct ceph_mds_client *mdsc,\n\t\t\t       struct ceph_inode_info *ci)\n{\n\tstruct ceph_mount_options *ma = mdsc->fsc->mount_options;\n\n\tci->i_hold_caps_min = round_jiffies(jiffies +\n\t\t\t\t\t    ma->caps_wanted_delay_min * HZ);\n\tci->i_hold_caps_max = round_jiffies(jiffies +\n\t\t\t\t\t    ma->caps_wanted_delay_max * HZ);\n\tdout(\"__cap_set_timeouts %p min %lu max %lu\\n\", &ci->vfs_inode,\n\t     ci->i_hold_caps_min - jiffies, ci->i_hold_caps_max - jiffies);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __cap_delay_requeue(struct ceph_mds_client *mdsc,\n\t\t\t\tstruct ceph_inode_info *ci)\n{\n\t__cap_set_timeouts(mdsc, ci);\n\tdout(\"__cap_delay_requeue %p flags %d at %lu\\n\", &ci->vfs_inode,\n\t     ci->i_ceph_flags, ci->i_hold_caps_max);\n\tif (!mdsc->stopping) {\n\t\tspin_lock(&mdsc->cap_delay_lock);\n\t\tif (!list_empty(&ci->i_cap_delay_list)) {\n\t\t\tif (ci->i_ceph_flags & CEPH_I_FLUSH)\n\t\t\t\tgoto no_change;\n\t\t\tlist_del_init(&ci->i_cap_delay_list);\n\t\t}\n\t\tlist_add_tail(&ci->i_cap_delay_list, &mdsc->cap_delay_list);\nno_change:\n\t\tspin_unlock(&mdsc->cap_delay_lock);\n\t}\n}"
  },
  {
    "function_name": "__cap_set_timeouts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "397-408",
    "snippet": "static void __cap_set_timeouts(struct ceph_mds_client *mdsc,\n\t\t\t       struct ceph_inode_info *ci)\n{\n\tstruct ceph_mount_options *ma = mdsc->fsc->mount_options;\n\n\tci->i_hold_caps_min = round_jiffies(jiffies +\n\t\t\t\t\t    ma->caps_wanted_delay_min * HZ);\n\tci->i_hold_caps_max = round_jiffies(jiffies +\n\t\t\t\t\t    ma->caps_wanted_delay_max * HZ);\n\tdout(\"__cap_set_timeouts %p min %lu max %lu\\n\", &ci->vfs_inode,\n\t     ci->i_hold_caps_min - jiffies, ci->i_hold_caps_max - jiffies);\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"__cap_set_timeouts %p min %lu max %lu\\n\"",
            "&ci->vfs_inode",
            "ci->i_hold_caps_min - jiffies",
            "ci->i_hold_caps_max - jiffies"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_jiffies",
          "args": [
            "jiffies +\n\t\t\t\t\t    ma->caps_wanted_delay_max * HZ"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_jiffies",
          "args": [
            "jiffies +\n\t\t\t\t\t    ma->caps_wanted_delay_min * HZ"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __cap_set_timeouts(struct ceph_mds_client *mdsc,\n\t\t\t       struct ceph_inode_info *ci)\n{\n\tstruct ceph_mount_options *ma = mdsc->fsc->mount_options;\n\n\tci->i_hold_caps_min = round_jiffies(jiffies +\n\t\t\t\t\t    ma->caps_wanted_delay_min * HZ);\n\tci->i_hold_caps_max = round_jiffies(jiffies +\n\t\t\t\t\t    ma->caps_wanted_delay_max * HZ);\n\tdout(\"__cap_set_timeouts %p min %lu max %lu\\n\", &ci->vfs_inode,\n\t     ci->i_hold_caps_min - jiffies, ci->i_hold_caps_max - jiffies);\n}"
  },
  {
    "function_name": "__insert_cap_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "371-391",
    "snippet": "static void __insert_cap_node(struct ceph_inode_info *ci,\n\t\t\t      struct ceph_cap *new)\n{\n\tstruct rb_node **p = &ci->i_caps.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct ceph_cap *cap = NULL;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tcap = rb_entry(parent, struct ceph_cap, ci_node);\n\t\tif (new->mds < cap->mds)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (new->mds > cap->mds)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tBUG();\n\t}\n\n\trb_link_node(&new->ci_node, parent, p);\n\trb_insert_color(&new->ci_node, &ci->i_caps);\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&new->ci_node",
            "&ci->i_caps"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&new->ci_node",
            "parent",
            "p"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structceph_cap",
            "ci_node"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __insert_cap_node(struct ceph_inode_info *ci,\n\t\t\t      struct ceph_cap *new)\n{\n\tstruct rb_node **p = &ci->i_caps.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct ceph_cap *cap = NULL;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tcap = rb_entry(parent, struct ceph_cap, ci_node);\n\t\tif (new->mds < cap->mds)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (new->mds > cap->mds)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tBUG();\n\t}\n\n\trb_link_node(&new->ci_node, parent, p);\n\trb_insert_color(&new->ci_node, &ci->i_caps);\n}"
  },
  {
    "function_name": "ceph_get_cap_mds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "358-366",
    "snippet": "int ceph_get_cap_mds(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint mds;\n\tspin_lock(&ci->i_ceph_lock);\n\tmds = __ceph_get_cap_mds(ceph_inode(inode));\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn mds;\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_get_cap_mds",
          "args": [
            "ceph_inode(inode)"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_get_cap_mds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "340-356",
          "snippet": "static int __ceph_get_cap_mds(struct ceph_inode_info *ci)\n{\n\tstruct ceph_cap *cap;\n\tint mds = -1;\n\tstruct rb_node *p;\n\n\t/* prefer mds with WR|BUFFER|EXCL caps */\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tmds = cap->mds;\n\t\tif (cap->issued & (CEPH_CAP_FILE_WR |\n\t\t\t\t   CEPH_CAP_FILE_BUFFER |\n\t\t\t\t   CEPH_CAP_FILE_EXCL))\n\t\t\tbreak;\n\t}\n\treturn mds;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __ceph_get_cap_mds(struct ceph_inode_info *ci)\n{\n\tstruct ceph_cap *cap;\n\tint mds = -1;\n\tstruct rb_node *p;\n\n\t/* prefer mds with WR|BUFFER|EXCL caps */\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tmds = cap->mds;\n\t\tif (cap->issued & (CEPH_CAP_FILE_WR |\n\t\t\t\t   CEPH_CAP_FILE_BUFFER |\n\t\t\t\t   CEPH_CAP_FILE_EXCL))\n\t\t\tbreak;\n\t}\n\treturn mds;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_get_cap_mds(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint mds;\n\tspin_lock(&ci->i_ceph_lock);\n\tmds = __ceph_get_cap_mds(ceph_inode(inode));\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn mds;\n}"
  },
  {
    "function_name": "__ceph_get_cap_mds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "340-356",
    "snippet": "static int __ceph_get_cap_mds(struct ceph_inode_info *ci)\n{\n\tstruct ceph_cap *cap;\n\tint mds = -1;\n\tstruct rb_node *p;\n\n\t/* prefer mds with WR|BUFFER|EXCL caps */\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tmds = cap->mds;\n\t\tif (cap->issued & (CEPH_CAP_FILE_WR |\n\t\t\t\t   CEPH_CAP_FILE_BUFFER |\n\t\t\t\t   CEPH_CAP_FILE_EXCL))\n\t\t\tbreak;\n\t}\n\treturn mds;\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "p",
            "structceph_cap",
            "ci_node"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "p"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&ci->i_caps"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __ceph_get_cap_mds(struct ceph_inode_info *ci)\n{\n\tstruct ceph_cap *cap;\n\tint mds = -1;\n\tstruct rb_node *p;\n\n\t/* prefer mds with WR|BUFFER|EXCL caps */\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tmds = cap->mds;\n\t\tif (cap->issued & (CEPH_CAP_FILE_WR |\n\t\t\t\t   CEPH_CAP_FILE_BUFFER |\n\t\t\t\t   CEPH_CAP_FILE_EXCL))\n\t\t\tbreak;\n\t}\n\treturn mds;\n}"
  },
  {
    "function_name": "ceph_get_cap_for_mds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "327-335",
    "snippet": "struct ceph_cap *ceph_get_cap_for_mds(struct ceph_inode_info *ci, int mds)\n{\n\tstruct ceph_cap *cap;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tcap = __get_cap_for_mds(ci, mds);\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn cap;\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_cap_for_mds",
          "args": [
            "ci",
            "mds"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "__get_cap_for_mds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "310-325",
          "snippet": "static struct ceph_cap *__get_cap_for_mds(struct ceph_inode_info *ci, int mds)\n{\n\tstruct ceph_cap *cap;\n\tstruct rb_node *n = ci->i_caps.rb_node;\n\n\twhile (n) {\n\t\tcap = rb_entry(n, struct ceph_cap, ci_node);\n\t\tif (mds < cap->mds)\n\t\t\tn = n->rb_left;\n\t\telse if (mds > cap->mds)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn cap;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_cap *__get_cap_for_mds(struct ceph_inode_info *ci, int mds)\n{\n\tstruct ceph_cap *cap;\n\tstruct rb_node *n = ci->i_caps.rb_node;\n\n\twhile (n) {\n\t\tcap = rb_entry(n, struct ceph_cap, ci_node);\n\t\tif (mds < cap->mds)\n\t\t\tn = n->rb_left;\n\t\telse if (mds > cap->mds)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn cap;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct ceph_cap *ceph_get_cap_for_mds(struct ceph_inode_info *ci, int mds)\n{\n\tstruct ceph_cap *cap;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tcap = __get_cap_for_mds(ci, mds);\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn cap;\n}"
  },
  {
    "function_name": "__get_cap_for_mds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "310-325",
    "snippet": "static struct ceph_cap *__get_cap_for_mds(struct ceph_inode_info *ci, int mds)\n{\n\tstruct ceph_cap *cap;\n\tstruct rb_node *n = ci->i_caps.rb_node;\n\n\twhile (n) {\n\t\tcap = rb_entry(n, struct ceph_cap, ci_node);\n\t\tif (mds < cap->mds)\n\t\t\tn = n->rb_left;\n\t\telse if (mds > cap->mds)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn cap;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structceph_cap",
            "ci_node"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_cap *__get_cap_for_mds(struct ceph_inode_info *ci, int mds)\n{\n\tstruct ceph_cap *cap;\n\tstruct rb_node *n = ci->i_caps.rb_node;\n\n\twhile (n) {\n\t\tcap = rb_entry(n, struct ceph_cap, ci_node);\n\t\tif (mds < cap->mds)\n\t\t\tn = n->rb_left;\n\t\telse if (mds > cap->mds)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn cap;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "ceph_reservation_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "287-303",
    "snippet": "void ceph_reservation_status(struct ceph_fs_client *fsc,\n\t\t\t     int *total, int *avail, int *used, int *reserved,\n\t\t\t     int *min)\n{\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\n\tif (total)\n\t\t*total = mdsc->caps_total_count;\n\tif (avail)\n\t\t*avail = mdsc->caps_avail_count;\n\tif (used)\n\t\t*used = mdsc->caps_use_count;\n\tif (reserved)\n\t\t*reserved = mdsc->caps_reserve_count;\n\tif (min)\n\t\t*min = mdsc->caps_min_count;\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_reservation_status(struct ceph_fs_client *fsc,\n\t\t\t     int *total, int *avail, int *used, int *reserved,\n\t\t\t     int *min)\n{\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\n\tif (total)\n\t\t*total = mdsc->caps_total_count;\n\tif (avail)\n\t\t*avail = mdsc->caps_avail_count;\n\tif (used)\n\t\t*used = mdsc->caps_use_count;\n\tif (reserved)\n\t\t*reserved = mdsc->caps_reserve_count;\n\tif (min)\n\t\t*min = mdsc->caps_min_count;\n}"
  },
  {
    "function_name": "ceph_put_cap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "262-285",
    "snippet": "void ceph_put_cap(struct ceph_mds_client *mdsc, struct ceph_cap *cap)\n{\n\tspin_lock(&mdsc->caps_list_lock);\n\tdout(\"put_cap %p %d = %d used + %d resv + %d avail\\n\",\n\t     cap, mdsc->caps_total_count, mdsc->caps_use_count,\n\t     mdsc->caps_reserve_count, mdsc->caps_avail_count);\n\tmdsc->caps_use_count--;\n\t/*\n\t * Keep some preallocated caps around (ceph_min_count), to\n\t * avoid lots of free/alloc churn.\n\t */\n\tif (mdsc->caps_avail_count >= mdsc->caps_reserve_count +\n\t\t\t\t      mdsc->caps_min_count) {\n\t\tmdsc->caps_total_count--;\n\t\tkmem_cache_free(ceph_cap_cachep, cap);\n\t} else {\n\t\tmdsc->caps_avail_count++;\n\t\tlist_add(&cap->caps_item, &mdsc->caps_list);\n\t}\n\n\tBUG_ON(mdsc->caps_total_count != mdsc->caps_use_count +\n\t       mdsc->caps_reserve_count + mdsc->caps_avail_count);\n\tspin_unlock(&mdsc->caps_list_lock);\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mdsc->caps_list_lock"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "mdsc->caps_total_count != mdsc->caps_use_count +\n\t       mdsc->caps_reserve_count + mdsc->caps_avail_count"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&cap->caps_item",
            "&mdsc->caps_list"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ceph_cap_cachep",
            "cap"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"put_cap %p %d = %d used + %d resv + %d avail\\n\"",
            "cap",
            "mdsc->caps_total_count",
            "mdsc->caps_use_count",
            "mdsc->caps_reserve_count",
            "mdsc->caps_avail_count"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mdsc->caps_list_lock"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_put_cap(struct ceph_mds_client *mdsc, struct ceph_cap *cap)\n{\n\tspin_lock(&mdsc->caps_list_lock);\n\tdout(\"put_cap %p %d = %d used + %d resv + %d avail\\n\",\n\t     cap, mdsc->caps_total_count, mdsc->caps_use_count,\n\t     mdsc->caps_reserve_count, mdsc->caps_avail_count);\n\tmdsc->caps_use_count--;\n\t/*\n\t * Keep some preallocated caps around (ceph_min_count), to\n\t * avoid lots of free/alloc churn.\n\t */\n\tif (mdsc->caps_avail_count >= mdsc->caps_reserve_count +\n\t\t\t\t      mdsc->caps_min_count) {\n\t\tmdsc->caps_total_count--;\n\t\tkmem_cache_free(ceph_cap_cachep, cap);\n\t} else {\n\t\tmdsc->caps_avail_count++;\n\t\tlist_add(&cap->caps_item, &mdsc->caps_list);\n\t}\n\n\tBUG_ON(mdsc->caps_total_count != mdsc->caps_use_count +\n\t       mdsc->caps_reserve_count + mdsc->caps_avail_count);\n\tspin_unlock(&mdsc->caps_list_lock);\n}"
  },
  {
    "function_name": "ceph_get_cap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "224-260",
    "snippet": "struct ceph_cap *ceph_get_cap(struct ceph_mds_client *mdsc,\n\t\t\t      struct ceph_cap_reservation *ctx)\n{\n\tstruct ceph_cap *cap = NULL;\n\n\t/* temporary, until we do something about cap import/export */\n\tif (!ctx) {\n\t\tcap = kmem_cache_alloc(ceph_cap_cachep, GFP_NOFS);\n\t\tif (cap) {\n\t\t\tspin_lock(&mdsc->caps_list_lock);\n\t\t\tmdsc->caps_use_count++;\n\t\t\tmdsc->caps_total_count++;\n\t\t\tspin_unlock(&mdsc->caps_list_lock);\n\t\t}\n\t\treturn cap;\n\t}\n\n\tspin_lock(&mdsc->caps_list_lock);\n\tdout(\"get_cap ctx=%p (%d) %d = %d used + %d resv + %d avail\\n\",\n\t     ctx, ctx->count, mdsc->caps_total_count, mdsc->caps_use_count,\n\t     mdsc->caps_reserve_count, mdsc->caps_avail_count);\n\tBUG_ON(!ctx->count);\n\tBUG_ON(ctx->count > mdsc->caps_reserve_count);\n\tBUG_ON(list_empty(&mdsc->caps_list));\n\n\tctx->count--;\n\tmdsc->caps_reserve_count--;\n\tmdsc->caps_use_count++;\n\n\tcap = list_first_entry(&mdsc->caps_list, struct ceph_cap, caps_item);\n\tlist_del(&cap->caps_item);\n\n\tBUG_ON(mdsc->caps_total_count != mdsc->caps_use_count +\n\t       mdsc->caps_reserve_count + mdsc->caps_avail_count);\n\tspin_unlock(&mdsc->caps_list_lock);\n\treturn cap;\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mdsc->caps_list_lock"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "mdsc->caps_total_count != mdsc->caps_use_count +\n\t       mdsc->caps_reserve_count + mdsc->caps_avail_count"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&cap->caps_item"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&mdsc->caps_list",
            "structceph_cap",
            "caps_item"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "list_empty(&mdsc->caps_list)"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&mdsc->caps_list"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ctx->count > mdsc->caps_reserve_count"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ctx->count"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"get_cap ctx=%p (%d) %d = %d used + %d resv + %d avail\\n\"",
            "ctx",
            "ctx->count",
            "mdsc->caps_total_count",
            "mdsc->caps_use_count",
            "mdsc->caps_reserve_count",
            "mdsc->caps_avail_count"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mdsc->caps_list_lock"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "ceph_cap_cachep",
            "GFP_NOFS"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct ceph_cap *ceph_get_cap(struct ceph_mds_client *mdsc,\n\t\t\t      struct ceph_cap_reservation *ctx)\n{\n\tstruct ceph_cap *cap = NULL;\n\n\t/* temporary, until we do something about cap import/export */\n\tif (!ctx) {\n\t\tcap = kmem_cache_alloc(ceph_cap_cachep, GFP_NOFS);\n\t\tif (cap) {\n\t\t\tspin_lock(&mdsc->caps_list_lock);\n\t\t\tmdsc->caps_use_count++;\n\t\t\tmdsc->caps_total_count++;\n\t\t\tspin_unlock(&mdsc->caps_list_lock);\n\t\t}\n\t\treturn cap;\n\t}\n\n\tspin_lock(&mdsc->caps_list_lock);\n\tdout(\"get_cap ctx=%p (%d) %d = %d used + %d resv + %d avail\\n\",\n\t     ctx, ctx->count, mdsc->caps_total_count, mdsc->caps_use_count,\n\t     mdsc->caps_reserve_count, mdsc->caps_avail_count);\n\tBUG_ON(!ctx->count);\n\tBUG_ON(ctx->count > mdsc->caps_reserve_count);\n\tBUG_ON(list_empty(&mdsc->caps_list));\n\n\tctx->count--;\n\tmdsc->caps_reserve_count--;\n\tmdsc->caps_use_count++;\n\n\tcap = list_first_entry(&mdsc->caps_list, struct ceph_cap, caps_item);\n\tlist_del(&cap->caps_item);\n\n\tBUG_ON(mdsc->caps_total_count != mdsc->caps_use_count +\n\t       mdsc->caps_reserve_count + mdsc->caps_avail_count);\n\tspin_unlock(&mdsc->caps_list_lock);\n\treturn cap;\n}"
  },
  {
    "function_name": "ceph_unreserve_caps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "203-222",
    "snippet": "int ceph_unreserve_caps(struct ceph_mds_client *mdsc,\n\t\t\tstruct ceph_cap_reservation *ctx)\n{\n\tdout(\"unreserve caps ctx=%p count=%d\\n\", ctx, ctx->count);\n\tif (ctx->count) {\n\t\tspin_lock(&mdsc->caps_list_lock);\n\t\tBUG_ON(mdsc->caps_reserve_count < ctx->count);\n\t\tmdsc->caps_reserve_count -= ctx->count;\n\t\tmdsc->caps_avail_count += ctx->count;\n\t\tctx->count = 0;\n\t\tdout(\"unreserve caps %d = %d used + %d resv + %d avail\\n\",\n\t\t     mdsc->caps_total_count, mdsc->caps_use_count,\n\t\t     mdsc->caps_reserve_count, mdsc->caps_avail_count);\n\t\tBUG_ON(mdsc->caps_total_count != mdsc->caps_use_count +\n\t\t\t\t\t\t mdsc->caps_reserve_count +\n\t\t\t\t\t\t mdsc->caps_avail_count);\n\t\tspin_unlock(&mdsc->caps_list_lock);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mdsc->caps_list_lock"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "mdsc->caps_total_count != mdsc->caps_use_count +\n\t\t\t\t\t\t mdsc->caps_reserve_count +\n\t\t\t\t\t\t mdsc->caps_avail_count"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"unreserve caps %d = %d used + %d resv + %d avail\\n\"",
            "mdsc->caps_total_count",
            "mdsc->caps_use_count",
            "mdsc->caps_reserve_count",
            "mdsc->caps_avail_count"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "mdsc->caps_reserve_count < ctx->count"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mdsc->caps_list_lock"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"unreserve caps ctx=%p count=%d\\n\"",
            "ctx",
            "ctx->count"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_unreserve_caps(struct ceph_mds_client *mdsc,\n\t\t\tstruct ceph_cap_reservation *ctx)\n{\n\tdout(\"unreserve caps ctx=%p count=%d\\n\", ctx, ctx->count);\n\tif (ctx->count) {\n\t\tspin_lock(&mdsc->caps_list_lock);\n\t\tBUG_ON(mdsc->caps_reserve_count < ctx->count);\n\t\tmdsc->caps_reserve_count -= ctx->count;\n\t\tmdsc->caps_avail_count += ctx->count;\n\t\tctx->count = 0;\n\t\tdout(\"unreserve caps %d = %d used + %d resv + %d avail\\n\",\n\t\t     mdsc->caps_total_count, mdsc->caps_use_count,\n\t\t     mdsc->caps_reserve_count, mdsc->caps_avail_count);\n\t\tBUG_ON(mdsc->caps_total_count != mdsc->caps_use_count +\n\t\t\t\t\t\t mdsc->caps_reserve_count +\n\t\t\t\t\t\t mdsc->caps_avail_count);\n\t\tspin_unlock(&mdsc->caps_list_lock);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ceph_reserve_caps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "151-201",
    "snippet": "void ceph_reserve_caps(struct ceph_mds_client *mdsc,\n\t\t      struct ceph_cap_reservation *ctx, int need)\n{\n\tint i;\n\tstruct ceph_cap *cap;\n\tint have;\n\tint alloc = 0;\n\tLIST_HEAD(newcaps);\n\n\tdout(\"reserve caps ctx=%p need=%d\\n\", ctx, need);\n\n\t/* first reserve any caps that are already allocated */\n\tspin_lock(&mdsc->caps_list_lock);\n\tif (mdsc->caps_avail_count >= need)\n\t\thave = need;\n\telse\n\t\thave = mdsc->caps_avail_count;\n\tmdsc->caps_avail_count -= have;\n\tmdsc->caps_reserve_count += have;\n\tBUG_ON(mdsc->caps_total_count != mdsc->caps_use_count +\n\t\t\t\t\t mdsc->caps_reserve_count +\n\t\t\t\t\t mdsc->caps_avail_count);\n\tspin_unlock(&mdsc->caps_list_lock);\n\n\tfor (i = have; i < need; i++) {\n\t\tcap = kmem_cache_alloc(ceph_cap_cachep, GFP_NOFS);\n\t\tif (!cap)\n\t\t\tbreak;\n\t\tlist_add(&cap->caps_item, &newcaps);\n\t\talloc++;\n\t}\n\t/* we didn't manage to reserve as much as we needed */\n\tif (have + alloc != need)\n\t\tpr_warn(\"reserve caps ctx=%p ENOMEM need=%d got=%d\\n\",\n\t\t\tctx, need, have + alloc);\n\n\tspin_lock(&mdsc->caps_list_lock);\n\tmdsc->caps_total_count += alloc;\n\tmdsc->caps_reserve_count += alloc;\n\tlist_splice(&newcaps, &mdsc->caps_list);\n\n\tBUG_ON(mdsc->caps_total_count != mdsc->caps_use_count +\n\t\t\t\t\t mdsc->caps_reserve_count +\n\t\t\t\t\t mdsc->caps_avail_count);\n\tspin_unlock(&mdsc->caps_list_lock);\n\n\tctx->count = need;\n\tdout(\"reserve caps ctx=%p %d = %d used + %d resv + %d avail\\n\",\n\t     ctx, mdsc->caps_total_count, mdsc->caps_use_count,\n\t     mdsc->caps_reserve_count, mdsc->caps_avail_count);\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"reserve caps ctx=%p %d = %d used + %d resv + %d avail\\n\"",
            "ctx",
            "mdsc->caps_total_count",
            "mdsc->caps_use_count",
            "mdsc->caps_reserve_count",
            "mdsc->caps_avail_count"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mdsc->caps_list_lock"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "mdsc->caps_total_count != mdsc->caps_use_count +\n\t\t\t\t\t mdsc->caps_reserve_count +\n\t\t\t\t\t mdsc->caps_avail_count"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_splice",
          "args": [
            "&newcaps",
            "&mdsc->caps_list"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mdsc->caps_list_lock"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"reserve caps ctx=%p ENOMEM need=%d got=%d\\n\"",
            "ctx",
            "need",
            "have + alloc"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&cap->caps_item",
            "&newcaps"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "ceph_cap_cachep",
            "GFP_NOFS"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "mdsc->caps_total_count != mdsc->caps_use_count +\n\t\t\t\t\t mdsc->caps_reserve_count +\n\t\t\t\t\t mdsc->caps_avail_count"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"reserve caps ctx=%p need=%d\\n\"",
            "ctx",
            "need"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "newcaps"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_reserve_caps(struct ceph_mds_client *mdsc,\n\t\t      struct ceph_cap_reservation *ctx, int need)\n{\n\tint i;\n\tstruct ceph_cap *cap;\n\tint have;\n\tint alloc = 0;\n\tLIST_HEAD(newcaps);\n\n\tdout(\"reserve caps ctx=%p need=%d\\n\", ctx, need);\n\n\t/* first reserve any caps that are already allocated */\n\tspin_lock(&mdsc->caps_list_lock);\n\tif (mdsc->caps_avail_count >= need)\n\t\thave = need;\n\telse\n\t\thave = mdsc->caps_avail_count;\n\tmdsc->caps_avail_count -= have;\n\tmdsc->caps_reserve_count += have;\n\tBUG_ON(mdsc->caps_total_count != mdsc->caps_use_count +\n\t\t\t\t\t mdsc->caps_reserve_count +\n\t\t\t\t\t mdsc->caps_avail_count);\n\tspin_unlock(&mdsc->caps_list_lock);\n\n\tfor (i = have; i < need; i++) {\n\t\tcap = kmem_cache_alloc(ceph_cap_cachep, GFP_NOFS);\n\t\tif (!cap)\n\t\t\tbreak;\n\t\tlist_add(&cap->caps_item, &newcaps);\n\t\talloc++;\n\t}\n\t/* we didn't manage to reserve as much as we needed */\n\tif (have + alloc != need)\n\t\tpr_warn(\"reserve caps ctx=%p ENOMEM need=%d got=%d\\n\",\n\t\t\tctx, need, have + alloc);\n\n\tspin_lock(&mdsc->caps_list_lock);\n\tmdsc->caps_total_count += alloc;\n\tmdsc->caps_reserve_count += alloc;\n\tlist_splice(&newcaps, &mdsc->caps_list);\n\n\tBUG_ON(mdsc->caps_total_count != mdsc->caps_use_count +\n\t\t\t\t\t mdsc->caps_reserve_count +\n\t\t\t\t\t mdsc->caps_avail_count);\n\tspin_unlock(&mdsc->caps_list_lock);\n\n\tctx->count = need;\n\tdout(\"reserve caps ctx=%p %d = %d used + %d resv + %d avail\\n\",\n\t     ctx, mdsc->caps_total_count, mdsc->caps_use_count,\n\t     mdsc->caps_reserve_count, mdsc->caps_avail_count);\n}"
  },
  {
    "function_name": "ceph_adjust_min_caps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "143-149",
    "snippet": "void ceph_adjust_min_caps(struct ceph_mds_client *mdsc, int delta)\n{\n\tspin_lock(&mdsc->caps_list_lock);\n\tmdsc->caps_min_count += delta;\n\tBUG_ON(mdsc->caps_min_count < 0);\n\tspin_unlock(&mdsc->caps_list_lock);\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mdsc->caps_list_lock"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "mdsc->caps_min_count < 0"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mdsc->caps_list_lock"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_adjust_min_caps(struct ceph_mds_client *mdsc, int delta)\n{\n\tspin_lock(&mdsc->caps_list_lock);\n\tmdsc->caps_min_count += delta;\n\tBUG_ON(mdsc->caps_min_count < 0);\n\tspin_unlock(&mdsc->caps_list_lock);\n}"
  },
  {
    "function_name": "ceph_caps_finalize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "124-141",
    "snippet": "void ceph_caps_finalize(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_cap *cap;\n\n\tspin_lock(&mdsc->caps_list_lock);\n\twhile (!list_empty(&mdsc->caps_list)) {\n\t\tcap = list_first_entry(&mdsc->caps_list,\n\t\t\t\t       struct ceph_cap, caps_item);\n\t\tlist_del(&cap->caps_item);\n\t\tkmem_cache_free(ceph_cap_cachep, cap);\n\t}\n\tmdsc->caps_total_count = 0;\n\tmdsc->caps_avail_count = 0;\n\tmdsc->caps_use_count = 0;\n\tmdsc->caps_reserve_count = 0;\n\tmdsc->caps_min_count = 0;\n\tspin_unlock(&mdsc->caps_list_lock);\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mdsc->caps_list_lock"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ceph_cap_cachep",
            "cap"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&cap->caps_item"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&mdsc->caps_list",
            "structceph_cap",
            "caps_item"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&mdsc->caps_list"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mdsc->caps_list_lock"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_caps_finalize(struct ceph_mds_client *mdsc)\n{\n\tstruct ceph_cap *cap;\n\n\tspin_lock(&mdsc->caps_list_lock);\n\twhile (!list_empty(&mdsc->caps_list)) {\n\t\tcap = list_first_entry(&mdsc->caps_list,\n\t\t\t\t       struct ceph_cap, caps_item);\n\t\tlist_del(&cap->caps_item);\n\t\tkmem_cache_free(ceph_cap_cachep, cap);\n\t}\n\tmdsc->caps_total_count = 0;\n\tmdsc->caps_avail_count = 0;\n\tmdsc->caps_use_count = 0;\n\tmdsc->caps_reserve_count = 0;\n\tmdsc->caps_min_count = 0;\n\tspin_unlock(&mdsc->caps_list_lock);\n}"
  },
  {
    "function_name": "ceph_caps_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "118-122",
    "snippet": "void ceph_caps_init(struct ceph_mds_client *mdsc)\n{\n\tINIT_LIST_HEAD(&mdsc->caps_list);\n\tspin_lock_init(&mdsc->caps_list_lock);\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&mdsc->caps_list_lock"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&mdsc->caps_list"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_caps_init(struct ceph_mds_client *mdsc)\n{\n\tINIT_LIST_HEAD(&mdsc->caps_list);\n\tspin_lock_init(&mdsc->caps_list_lock);\n}"
  },
  {
    "function_name": "ceph_cap_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "71-116",
    "snippet": "const char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [
      "#define MAX_CAP_STR 20"
    ],
    "globals_used": [
      "static char cap_str[MAX_CAP_STR][40];",
      "static DEFINE_SPINLOCK(cap_str_lock);",
      "static int last_cap_str;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gcap_string",
          "args": [
            "s",
            "c"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "gcap_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "52-69",
          "snippet": "static char *gcap_string(char *s, int c)\n{\n\tif (c & CEPH_CAP_GSHARED)\n\t\t*s++ = 's';\n\tif (c & CEPH_CAP_GEXCL)\n\t\t*s++ = 'x';\n\tif (c & CEPH_CAP_GCACHE)\n\t\t*s++ = 'c';\n\tif (c & CEPH_CAP_GRD)\n\t\t*s++ = 'r';\n\tif (c & CEPH_CAP_GWR)\n\t\t*s++ = 'w';\n\tif (c & CEPH_CAP_GBUFFER)\n\t\t*s++ = 'b';\n\tif (c & CEPH_CAP_GLAZYIO)\n\t\t*s++ = 'l';\n\treturn s;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic char *gcap_string(char *s, int c)\n{\n\tif (c & CEPH_CAP_GSHARED)\n\t\t*s++ = 's';\n\tif (c & CEPH_CAP_GEXCL)\n\t\t*s++ = 'x';\n\tif (c & CEPH_CAP_GCACHE)\n\t\t*s++ = 'c';\n\tif (c & CEPH_CAP_GRD)\n\t\t*s++ = 'r';\n\tif (c & CEPH_CAP_GWR)\n\t\t*s++ = 'w';\n\tif (c & CEPH_CAP_GBUFFER)\n\t\t*s++ = 'b';\n\tif (c & CEPH_CAP_GLAZYIO)\n\t\t*s++ = 'l';\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cap_str_lock"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cap_str_lock"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\n#define MAX_CAP_STR 20\n\nstatic char cap_str[MAX_CAP_STR][40];\nstatic DEFINE_SPINLOCK(cap_str_lock);\nstatic int last_cap_str;\n\nconst char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}"
  },
  {
    "function_name": "gcap_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
    "lines": "52-69",
    "snippet": "static char *gcap_string(char *s, int c)\n{\n\tif (c & CEPH_CAP_GSHARED)\n\t\t*s++ = 's';\n\tif (c & CEPH_CAP_GEXCL)\n\t\t*s++ = 'x';\n\tif (c & CEPH_CAP_GCACHE)\n\t\t*s++ = 'c';\n\tif (c & CEPH_CAP_GRD)\n\t\t*s++ = 'r';\n\tif (c & CEPH_CAP_GWR)\n\t\t*s++ = 'w';\n\tif (c & CEPH_CAP_GBUFFER)\n\t\t*s++ = 'b';\n\tif (c & CEPH_CAP_GLAZYIO)\n\t\t*s++ = 'l';\n\treturn s;\n}",
    "includes": [
      "#include <linux/ceph/messenger.h>",
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/wait.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic char *gcap_string(char *s, int c)\n{\n\tif (c & CEPH_CAP_GSHARED)\n\t\t*s++ = 's';\n\tif (c & CEPH_CAP_GEXCL)\n\t\t*s++ = 'x';\n\tif (c & CEPH_CAP_GCACHE)\n\t\t*s++ = 'c';\n\tif (c & CEPH_CAP_GRD)\n\t\t*s++ = 'r';\n\tif (c & CEPH_CAP_GWR)\n\t\t*s++ = 'w';\n\tif (c & CEPH_CAP_GBUFFER)\n\t\t*s++ = 'b';\n\tif (c & CEPH_CAP_GLAZYIO)\n\t\t*s++ = 'l';\n\treturn s;\n}"
  }
]