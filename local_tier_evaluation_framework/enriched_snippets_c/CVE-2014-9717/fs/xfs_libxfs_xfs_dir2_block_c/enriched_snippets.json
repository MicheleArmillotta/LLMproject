[
  {
    "function_name": "xfs_dir2_sf_to_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
    "lines": "1042-1254",
    "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_sf_to_block(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\txfs_dir2_db_t\t\tblkno;\t\t/* dir-relative block # (0) */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* block leaf entries */\n\tstruct xfs_buf\t\t*bp;\t\t/* block buffer */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail pointer */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry pointer */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\tdummy;\t\t/* trash */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry pointer */\n\tint\t\t\tendoffset;\t/* end of data objects */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\ti;\t\t/* index */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tint\t\t\tneedlog;\t/* need to log block header */\n\tint\t\t\tneedscan;\t/* need to scan block freespc */\n\tint\t\t\tnewoffset;\t/* offset from current entry */\n\tint\t\t\toffset;\t\t/* target block offset */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* sf entry pointer */\n\txfs_dir2_sf_hdr_t\t*oldsfp;\t/* old shortform header  */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform header  */\n\t__be16\t\t\t*tagp;\t\t/* end of data entry */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tstruct xfs_name\t\tname;\n\tstruct xfs_ifork\t*ifp;\n\n\ttrace_xfs_dir2_sf_to_block(args);\n\n\tdp = args->dp;\n\ttp = args->trans;\n\tmp = dp->i_mount;\n\tifp = XFS_IFORK_PTR(dp, XFS_DATA_FORK);\n\tASSERT(ifp->if_flags & XFS_IFINLINE);\n\t/*\n\t * Bomb out if the shortform directory is way too short.\n\t */\n\tif (dp->i_d.di_size < offsetof(xfs_dir2_sf_hdr_t, parent)) {\n\t\tASSERT(XFS_FORCED_SHUTDOWN(mp));\n\t\treturn -EIO;\n\t}\n\n\toldsfp = (xfs_dir2_sf_hdr_t *)ifp->if_u1.if_data;\n\n\tASSERT(ifp->if_bytes == dp->i_d.di_size);\n\tASSERT(ifp->if_u1.if_data != NULL);\n\tASSERT(dp->i_d.di_size >= xfs_dir2_sf_hdr_size(oldsfp->i8count));\n\tASSERT(dp->i_d.di_nextents == 0);\n\n\t/*\n\t * Copy the directory into a temporary buffer.\n\t * Then pitch the incore inode data so we can make extents.\n\t */\n\tsfp = kmem_alloc(ifp->if_bytes, KM_SLEEP);\n\tmemcpy(sfp, oldsfp, ifp->if_bytes);\n\n\txfs_idata_realloc(dp, -ifp->if_bytes, XFS_DATA_FORK);\n\txfs_bmap_local_to_extents_empty(dp, XFS_DATA_FORK);\n\tdp->i_d.di_size = 0;\n\n\t/*\n\t * Add block 0 to the inode.\n\t */\n\terror = xfs_dir2_grow_inode(args, XFS_DIR2_DATA_SPACE, &blkno);\n\tif (error) {\n\t\tkmem_free(sfp);\n\t\treturn error;\n\t}\n\t/*\n\t * Initialize the data block, then convert it to block format.\n\t */\n\terror = xfs_dir3_data_init(args, blkno, &bp);\n\tif (error) {\n\t\tkmem_free(sfp);\n\t\treturn error;\n\t}\n\txfs_dir3_block_init(mp, tp, bp, dp);\n\thdr = bp->b_addr;\n\n\t/*\n\t * Compute size of block \"tail\" area.\n\t */\n\ti = (uint)sizeof(*btp) +\n\t    (sfp->count + 2) * (uint)sizeof(xfs_dir2_leaf_entry_t);\n\t/*\n\t * The whole thing is initialized to free by the init routine.\n\t * Say we're using the leaf and tail area.\n\t */\n\tdup = dp->d_ops->data_unused_p(hdr);\n\tneedlog = needscan = 0;\n\txfs_dir2_data_use_free(args, bp, dup, args->geo->blksize - i,\n\t\t\t       i, &needlog, &needscan);\n\tASSERT(needscan == 0);\n\t/*\n\t * Fill in the tail.\n\t */\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tbtp->count = cpu_to_be32(sfp->count + 2);\t/* ., .. */\n\tbtp->stale = 0;\n\tblp = xfs_dir2_block_leaf_p(btp);\n\tendoffset = (uint)((char *)blp - (char *)hdr);\n\t/*\n\t * Remove the freespace, we'll manage it.\n\t */\n\txfs_dir2_data_use_free(args, bp, dup,\n\t\t(xfs_dir2_data_aoff_t)((char *)dup - (char *)hdr),\n\t\tbe16_to_cpu(dup->length), &needlog, &needscan);\n\t/*\n\t * Create entry for .\n\t */\n\tdep = dp->d_ops->data_dot_entry_p(hdr);\n\tdep->inumber = cpu_to_be64(dp->i_ino);\n\tdep->namelen = 1;\n\tdep->name[0] = '.';\n\tdp->d_ops->data_put_ftype(dep, XFS_DIR3_FT_DIR);\n\ttagp = dp->d_ops->data_entry_tag_p(dep);\n\t*tagp = cpu_to_be16((char *)dep - (char *)hdr);\n\txfs_dir2_data_log_entry(args, bp, dep);\n\tblp[0].hashval = cpu_to_be32(xfs_dir_hash_dot);\n\tblp[0].address = cpu_to_be32(xfs_dir2_byte_to_dataptr(\n\t\t\t\t(char *)dep - (char *)hdr));\n\t/*\n\t * Create entry for ..\n\t */\n\tdep = dp->d_ops->data_dotdot_entry_p(hdr);\n\tdep->inumber = cpu_to_be64(dp->d_ops->sf_get_parent_ino(sfp));\n\tdep->namelen = 2;\n\tdep->name[0] = dep->name[1] = '.';\n\tdp->d_ops->data_put_ftype(dep, XFS_DIR3_FT_DIR);\n\ttagp = dp->d_ops->data_entry_tag_p(dep);\n\t*tagp = cpu_to_be16((char *)dep - (char *)hdr);\n\txfs_dir2_data_log_entry(args, bp, dep);\n\tblp[1].hashval = cpu_to_be32(xfs_dir_hash_dotdot);\n\tblp[1].address = cpu_to_be32(xfs_dir2_byte_to_dataptr(\n\t\t\t\t(char *)dep - (char *)hdr));\n\toffset = dp->d_ops->data_first_offset;\n\t/*\n\t * Loop over existing entries, stuff them in.\n\t */\n\ti = 0;\n\tif (!sfp->count)\n\t\tsfep = NULL;\n\telse\n\t\tsfep = xfs_dir2_sf_firstentry(sfp);\n\t/*\n\t * Need to preserve the existing offset values in the sf directory.\n\t * Insert holes (unused entries) where necessary.\n\t */\n\twhile (offset < endoffset) {\n\t\t/*\n\t\t * sfep is null when we reach the end of the list.\n\t\t */\n\t\tif (sfep == NULL)\n\t\t\tnewoffset = endoffset;\n\t\telse\n\t\t\tnewoffset = xfs_dir2_sf_get_offset(sfep);\n\t\t/*\n\t\t * There should be a hole here, make one.\n\t\t */\n\t\tif (offset < newoffset) {\n\t\t\tdup = (xfs_dir2_data_unused_t *)((char *)hdr + offset);\n\t\t\tdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\t\tdup->length = cpu_to_be16(newoffset - offset);\n\t\t\t*xfs_dir2_data_unused_tag_p(dup) = cpu_to_be16(\n\t\t\t\t((char *)dup - (char *)hdr));\n\t\t\txfs_dir2_data_log_unused(args, bp, dup);\n\t\t\txfs_dir2_data_freeinsert(hdr,\n\t\t\t\t\t\t dp->d_ops->data_bestfree_p(hdr),\n\t\t\t\t\t\t dup, &dummy);\n\t\t\toffset += be16_to_cpu(dup->length);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Copy a real entry.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)((char *)hdr + newoffset);\n\t\tdep->inumber = cpu_to_be64(dp->d_ops->sf_get_ino(sfp, sfep));\n\t\tdep->namelen = sfep->namelen;\n\t\tdp->d_ops->data_put_ftype(dep, dp->d_ops->sf_get_ftype(sfep));\n\t\tmemcpy(dep->name, sfep->name, dep->namelen);\n\t\ttagp = dp->d_ops->data_entry_tag_p(dep);\n\t\t*tagp = cpu_to_be16((char *)dep - (char *)hdr);\n\t\txfs_dir2_data_log_entry(args, bp, dep);\n\t\tname.name = sfep->name;\n\t\tname.len = sfep->namelen;\n\t\tblp[2 + i].hashval = cpu_to_be32(mp->m_dirnameops->\n\t\t\t\t\t\t\thashname(&name));\n\t\tblp[2 + i].address = cpu_to_be32(xfs_dir2_byte_to_dataptr(\n\t\t\t\t\t\t (char *)dep - (char *)hdr));\n\t\toffset = (int)((char *)(tagp + 1) - (char *)hdr);\n\t\tif (++i == sfp->count)\n\t\t\tsfep = NULL;\n\t\telse\n\t\t\tsfep = dp->d_ops->sf_nextentry(sfp, sfep);\n\t}\n\t/* Done with the temporary buffer */\n\tkmem_free(sfp);\n\t/*\n\t * Sort the leaf entries by hash value.\n\t */\n\txfs_sort(blp, be32_to_cpu(btp->count), sizeof(*blp), xfs_dir2_block_sort);\n\t/*\n\t * Log the leaf entry area and tail.\n\t * Already logged the header in data_init, ignore needlog.\n\t */\n\tASSERT(needscan == 0);\n\txfs_dir2_block_log_leaf(tp, bp, 0, be32_to_cpu(btp->count) - 1);\n\txfs_dir2_block_log_tail(tp, bp);\n\txfs_dir3_data_check(dp, bp);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);",
      "static xfs_dahash_t xfs_dir_hash_dot, xfs_dir_hash_dotdot;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_dir3_data_check",
          "args": [
            "dp",
            "bp"
          ],
          "line": 1252
        },
        "resolved": true,
        "details": {
          "function_name": "__xfs_dir3_data_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "40-210",
          "snippet": "int\n__xfs_dir3_data_check(\n\tstruct xfs_inode\t*dp,\t\t/* incore inode pointer */\n\tstruct xfs_buf\t\t*bp)\t\t/* data block's buffer */\n{\n\txfs_dir2_dataptr_t\taddr;\t\t/* addr for leaf lookup */\n\txfs_dir2_data_free_t\t*bf;\t\t/* bestfree table */\n\txfs_dir2_block_tail_t\t*btp=NULL;\t/* block tail */\n\tint\t\t\tcount;\t\t/* count of entries found */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry */\n\tchar\t\t\t*endp;\t\t/* end of useful data */\n\tint\t\t\tfreeseen;\t/* mask of bestfrees seen */\n\txfs_dahash_t\t\thash;\t\t/* hash of current name */\n\tint\t\t\ti;\t\t/* leaf index */\n\tint\t\t\tlastfree;\t/* last entry was unused */\n\txfs_dir2_leaf_entry_t\t*lep=NULL;\t/* block leaf entries */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tchar\t\t\t*p;\t\t/* current data position */\n\tint\t\t\tstale;\t\t/* count of stale leaves */\n\tstruct xfs_name\t\tname;\n\tconst struct xfs_dir_ops *ops;\n\tstruct xfs_da_geometry\t*geo;\n\n\tmp = bp->b_target->bt_mount;\n\tgeo = mp->m_dir_geo;\n\n\t/*\n\t * We can be passed a null dp here from a verifier, so we need to go the\n\t * hard way to get them.\n\t */\n\tops = xfs_dir_get_ops(mp, dp);\n\n\thdr = bp->b_addr;\n\tp = (char *)ops->data_entry_p(hdr);\n\n\tswitch (hdr->magic) {\n\tcase cpu_to_be32(XFS_DIR3_BLOCK_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_BLOCK_MAGIC):\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tlep = xfs_dir2_block_leaf_p(btp);\n\t\tendp = (char *)lep;\n\n\t\t/*\n\t\t * The number of leaf entries is limited by the size of the\n\t\t * block and the amount of space used by the data entries.\n\t\t * We don't know how much space is used by the data entries yet,\n\t\t * so just ensure that the count falls somewhere inside the\n\t\t * block right now.\n\t\t */\n\t\tXFS_WANT_CORRUPTED_RETURN(be32_to_cpu(btp->count) <\n\t\t\t((char *)btp - p) / sizeof(struct xfs_dir2_leaf_entry));\n\t\tbreak;\n\tcase cpu_to_be32(XFS_DIR3_DATA_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_DATA_MAGIC):\n\t\tendp = (char *)hdr + geo->blksize;\n\t\tbreak;\n\tdefault:\n\t\tXFS_ERROR_REPORT(\"Bad Magic\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/*\n\t * Account for zero bestfree entries.\n\t */\n\tbf = ops->data_bestfree_p(hdr);\n\tcount = lastfree = freeseen = 0;\n\tif (!bf[0].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[0].offset);\n\t\tfreeseen |= 1 << 0;\n\t}\n\tif (!bf[1].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[1].offset);\n\t\tfreeseen |= 1 << 1;\n\t}\n\tif (!bf[2].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[2].offset);\n\t\tfreeseen |= 1 << 2;\n\t}\n\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[0].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[1].length));\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[1].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t/*\n\t * Loop over the data/unused entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's unused, look for the space in the bestfree table.\n\t\t * If we find it, account for that, else make sure it\n\t\t * doesn't need to be there.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tXFS_WANT_CORRUPTED_RETURN(lastfree == 0);\n\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tbe16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)) ==\n\t\t\t\t\t       (char *)dup - (char *)hdr);\n\t\t\tdfp = xfs_dir2_data_freefind(hdr, bf, dup);\n\t\t\tif (dfp) {\n\t\t\t\ti = (int)(dfp - bf);\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\t(freeseen & (1 << i)) == 0);\n\t\t\t\tfreeseen |= 1 << i;\n\t\t\t} else {\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe16_to_cpu(dup->length) <=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t\t\t}\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t\tlastfree = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * It's a real entry.  Validate the fields.\n\t\t * If this is a block directory then make sure it's\n\t\t * in the leaf section of the block.\n\t\t * The linear search is crude but this is DEBUG code.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\tXFS_WANT_CORRUPTED_RETURN(dep->namelen != 0);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t!xfs_dir_ino_validate(mp, be64_to_cpu(dep->inumber)));\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\tbe16_to_cpu(*ops->data_entry_tag_p(dep)) ==\n\t\t\t\t\t       (char *)dep - (char *)hdr);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tops->data_get_ftype(dep) < XFS_DIR3_FT_MAX);\n\t\tcount++;\n\t\tlastfree = 0;\n\t\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\t\taddr = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,\n\t\t\t\t\t\t(xfs_dir2_data_aoff_t)\n\t\t\t\t\t\t((char *)dep - (char *)hdr));\n\t\t\tname.name = dep->name;\n\t\t\tname.len = dep->namelen;\n\t\t\thash = mp->m_dirnameops->hashname(&name);\n\t\t\tfor (i = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\t\tif (be32_to_cpu(lep[i].address) == addr &&\n\t\t\t\t    be32_to_cpu(lep[i].hashval) == hash)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i < be32_to_cpu(btp->count));\n\t\t}\n\t\tp += ops->data_entsize(dep->namelen);\n\t}\n\t/*\n\t * Need to have seen all the entries and all the bestfree slots.\n\t */\n\tXFS_WANT_CORRUPTED_RETURN(freeseen == 7);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tfor (i = stale = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\tif (lep[i].address ==\n\t\t\t    cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\t\tstale++;\n\t\t\tif (i > 0)\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe32_to_cpu(lep[i].hashval) >=\n\t\t\t\t\t\tbe32_to_cpu(lep[i - 1].hashval));\n\t\t}\n\t\tXFS_WANT_CORRUPTED_RETURN(count ==\n\t\t\tbe32_to_cpu(btp->count) - be32_to_cpu(btp->stale));\n\t\tXFS_WANT_CORRUPTED_RETURN(stale == be32_to_cpu(btp->stale));\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\n__xfs_dir3_data_check(\n\tstruct xfs_inode\t*dp,\t\t/* incore inode pointer */\n\tstruct xfs_buf\t\t*bp)\t\t/* data block's buffer */\n{\n\txfs_dir2_dataptr_t\taddr;\t\t/* addr for leaf lookup */\n\txfs_dir2_data_free_t\t*bf;\t\t/* bestfree table */\n\txfs_dir2_block_tail_t\t*btp=NULL;\t/* block tail */\n\tint\t\t\tcount;\t\t/* count of entries found */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry */\n\tchar\t\t\t*endp;\t\t/* end of useful data */\n\tint\t\t\tfreeseen;\t/* mask of bestfrees seen */\n\txfs_dahash_t\t\thash;\t\t/* hash of current name */\n\tint\t\t\ti;\t\t/* leaf index */\n\tint\t\t\tlastfree;\t/* last entry was unused */\n\txfs_dir2_leaf_entry_t\t*lep=NULL;\t/* block leaf entries */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tchar\t\t\t*p;\t\t/* current data position */\n\tint\t\t\tstale;\t\t/* count of stale leaves */\n\tstruct xfs_name\t\tname;\n\tconst struct xfs_dir_ops *ops;\n\tstruct xfs_da_geometry\t*geo;\n\n\tmp = bp->b_target->bt_mount;\n\tgeo = mp->m_dir_geo;\n\n\t/*\n\t * We can be passed a null dp here from a verifier, so we need to go the\n\t * hard way to get them.\n\t */\n\tops = xfs_dir_get_ops(mp, dp);\n\n\thdr = bp->b_addr;\n\tp = (char *)ops->data_entry_p(hdr);\n\n\tswitch (hdr->magic) {\n\tcase cpu_to_be32(XFS_DIR3_BLOCK_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_BLOCK_MAGIC):\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tlep = xfs_dir2_block_leaf_p(btp);\n\t\tendp = (char *)lep;\n\n\t\t/*\n\t\t * The number of leaf entries is limited by the size of the\n\t\t * block and the amount of space used by the data entries.\n\t\t * We don't know how much space is used by the data entries yet,\n\t\t * so just ensure that the count falls somewhere inside the\n\t\t * block right now.\n\t\t */\n\t\tXFS_WANT_CORRUPTED_RETURN(be32_to_cpu(btp->count) <\n\t\t\t((char *)btp - p) / sizeof(struct xfs_dir2_leaf_entry));\n\t\tbreak;\n\tcase cpu_to_be32(XFS_DIR3_DATA_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_DATA_MAGIC):\n\t\tendp = (char *)hdr + geo->blksize;\n\t\tbreak;\n\tdefault:\n\t\tXFS_ERROR_REPORT(\"Bad Magic\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/*\n\t * Account for zero bestfree entries.\n\t */\n\tbf = ops->data_bestfree_p(hdr);\n\tcount = lastfree = freeseen = 0;\n\tif (!bf[0].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[0].offset);\n\t\tfreeseen |= 1 << 0;\n\t}\n\tif (!bf[1].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[1].offset);\n\t\tfreeseen |= 1 << 1;\n\t}\n\tif (!bf[2].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[2].offset);\n\t\tfreeseen |= 1 << 2;\n\t}\n\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[0].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[1].length));\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[1].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t/*\n\t * Loop over the data/unused entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's unused, look for the space in the bestfree table.\n\t\t * If we find it, account for that, else make sure it\n\t\t * doesn't need to be there.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tXFS_WANT_CORRUPTED_RETURN(lastfree == 0);\n\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tbe16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)) ==\n\t\t\t\t\t       (char *)dup - (char *)hdr);\n\t\t\tdfp = xfs_dir2_data_freefind(hdr, bf, dup);\n\t\t\tif (dfp) {\n\t\t\t\ti = (int)(dfp - bf);\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\t(freeseen & (1 << i)) == 0);\n\t\t\t\tfreeseen |= 1 << i;\n\t\t\t} else {\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe16_to_cpu(dup->length) <=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t\t\t}\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t\tlastfree = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * It's a real entry.  Validate the fields.\n\t\t * If this is a block directory then make sure it's\n\t\t * in the leaf section of the block.\n\t\t * The linear search is crude but this is DEBUG code.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\tXFS_WANT_CORRUPTED_RETURN(dep->namelen != 0);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t!xfs_dir_ino_validate(mp, be64_to_cpu(dep->inumber)));\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\tbe16_to_cpu(*ops->data_entry_tag_p(dep)) ==\n\t\t\t\t\t       (char *)dep - (char *)hdr);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tops->data_get_ftype(dep) < XFS_DIR3_FT_MAX);\n\t\tcount++;\n\t\tlastfree = 0;\n\t\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\t\taddr = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,\n\t\t\t\t\t\t(xfs_dir2_data_aoff_t)\n\t\t\t\t\t\t((char *)dep - (char *)hdr));\n\t\t\tname.name = dep->name;\n\t\t\tname.len = dep->namelen;\n\t\t\thash = mp->m_dirnameops->hashname(&name);\n\t\t\tfor (i = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\t\tif (be32_to_cpu(lep[i].address) == addr &&\n\t\t\t\t    be32_to_cpu(lep[i].hashval) == hash)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i < be32_to_cpu(btp->count));\n\t\t}\n\t\tp += ops->data_entsize(dep->namelen);\n\t}\n\t/*\n\t * Need to have seen all the entries and all the bestfree slots.\n\t */\n\tXFS_WANT_CORRUPTED_RETURN(freeseen == 7);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tfor (i = stale = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\tif (lep[i].address ==\n\t\t\t    cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\t\tstale++;\n\t\t\tif (i > 0)\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe32_to_cpu(lep[i].hashval) >=\n\t\t\t\t\t\tbe32_to_cpu(lep[i - 1].hashval));\n\t\t}\n\t\tXFS_WANT_CORRUPTED_RETURN(count ==\n\t\t\tbe32_to_cpu(btp->count) - be32_to_cpu(btp->stale));\n\t\tXFS_WANT_CORRUPTED_RETURN(stale == be32_to_cpu(btp->stale));\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_log_tail",
          "args": [
            "tp",
            "bp"
          ],
          "line": 1251
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_log_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
          "lines": "587-598",
          "snippet": "static void\nxfs_dir2_block_log_tail(\n\txfs_trans_t\t\t*tp,\t\t/* transaction structure */\n\tstruct xfs_buf\t\t*bp)\t\t/* block buffer */\n{\n\txfs_dir2_data_hdr_t\t*hdr = bp->b_addr;\n\txfs_dir2_block_tail_t\t*btp;\n\n\tbtp = xfs_dir2_block_tail_p(tp->t_mountp->m_dir_geo, hdr);\n\txfs_trans_log_buf(tp, bp, (uint)((char *)btp - (char *)hdr),\n\t\t(uint)((char *)(btp + 1) - (char *)hdr - 1));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);\n\nstatic void\nxfs_dir2_block_log_tail(\n\txfs_trans_t\t\t*tp,\t\t/* transaction structure */\n\tstruct xfs_buf\t\t*bp)\t\t/* block buffer */\n{\n\txfs_dir2_data_hdr_t\t*hdr = bp->b_addr;\n\txfs_dir2_block_tail_t\t*btp;\n\n\tbtp = xfs_dir2_block_tail_p(tp->t_mountp->m_dir_geo, hdr);\n\txfs_trans_log_buf(tp, bp, (uint)((char *)btp - (char *)hdr),\n\t\t(uint)((char *)(btp + 1) - (char *)hdr - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_log_leaf",
          "args": [
            "tp",
            "bp",
            "0",
            "be32_to_cpu(btp->count) - 1"
          ],
          "line": 1250
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_log_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
          "lines": "567-582",
          "snippet": "static void\nxfs_dir2_block_log_leaf(\n\txfs_trans_t\t\t*tp,\t\t/* transaction structure */\n\tstruct xfs_buf\t\t*bp,\t\t/* block buffer */\n\tint\t\t\tfirst,\t\t/* index of first logged leaf */\n\tint\t\t\tlast)\t\t/* index of last logged leaf */\n{\n\txfs_dir2_data_hdr_t\t*hdr = bp->b_addr;\n\txfs_dir2_leaf_entry_t\t*blp;\n\txfs_dir2_block_tail_t\t*btp;\n\n\tbtp = xfs_dir2_block_tail_p(tp->t_mountp->m_dir_geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\txfs_trans_log_buf(tp, bp, (uint)((char *)&blp[first] - (char *)hdr),\n\t\t(uint)((char *)&blp[last + 1] - (char *)hdr - 1));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir2_block_log_leaf(xfs_trans_t *tp, struct xfs_buf *bp,\n\t\t\t\t    int first, int last);",
            "static void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_block_log_leaf(xfs_trans_t *tp, struct xfs_buf *bp,\n\t\t\t\t    int first, int last);\nstatic void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);\n\nstatic void\nxfs_dir2_block_log_leaf(\n\txfs_trans_t\t\t*tp,\t\t/* transaction structure */\n\tstruct xfs_buf\t\t*bp,\t\t/* block buffer */\n\tint\t\t\tfirst,\t\t/* index of first logged leaf */\n\tint\t\t\tlast)\t\t/* index of last logged leaf */\n{\n\txfs_dir2_data_hdr_t\t*hdr = bp->b_addr;\n\txfs_dir2_leaf_entry_t\t*blp;\n\txfs_dir2_block_tail_t\t*btp;\n\n\tbtp = xfs_dir2_block_tail_p(tp->t_mountp->m_dir_geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\txfs_trans_log_buf(tp, bp, (uint)((char *)&blp[first] - (char *)hdr),\n\t\t(uint)((char *)&blp[last + 1] - (char *)hdr - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btp->count"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "needscan == 0"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sort",
          "args": [
            "blp",
            "be32_to_cpu(btp->count)",
            "sizeof(*blp)",
            "xfs_dir2_block_sort"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btp->count"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "sfp"
          ],
          "line": 1240
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_nextentry",
          "args": [
            "sfp",
            "sfep"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "xfs_dir2_byte_to_dataptr(\n\t\t\t\t\t\t (char *)dep - (char *)hdr)"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_byte_to_dataptr",
          "args": [
            "(char *)dep - (char *)hdr"
          ],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_byte_to_dataptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "204-208",
          "snippet": "static inline xfs_dir2_dataptr_t\nxfs_dir2_byte_to_dataptr(xfs_dir2_off_t by)\n{\n\treturn (xfs_dir2_dataptr_t)(by >> XFS_DIR2_DATA_ALIGN_LOG);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_dataptr_t\nxfs_dir2_byte_to_dataptr(xfs_dir2_off_t by)\n{\n\treturn (xfs_dir2_dataptr_t)(by >> XFS_DIR2_DATA_ALIGN_LOG);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "mp->m_dirnameops->\n\t\t\t\t\t\t\thashname(&name)"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mp->m_dirnameops->\n\t\t\t\t\t\t\thashname",
          "args": [
            "&name"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_log_entry",
          "args": [
            "args",
            "bp",
            "dep"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_log_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "640-656",
          "snippet": "void\nxfs_dir2_data_log_entry(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_entry_t\t*dep)\t\t/* data entry pointer */\n{\n\tstruct xfs_dir2_data_hdr *hdr = bp->b_addr;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\txfs_trans_log_buf(args->trans, bp, (uint)((char *)dep - (char *)hdr),\n\t\t(uint)((char *)(args->dp->d_ops->data_entry_tag_p(dep) + 1) -\n\t\t       (char *)hdr - 1));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dir2_data_log_entry(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_entry_t\t*dep)\t\t/* data entry pointer */\n{\n\tstruct xfs_dir2_data_hdr *hdr = bp->b_addr;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\txfs_trans_log_buf(args->trans, bp, (uint)((char *)dep - (char *)hdr),\n\t\t(uint)((char *)(args->dp->d_ops->data_entry_tag_p(dep) + 1) -\n\t\t       (char *)hdr - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "(char *)dep - (char *)hdr"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_entry_tag_p",
          "args": [
            "dep"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dep->name",
            "sfep->name",
            "dep->namelen"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_put_ftype",
          "args": [
            "dep",
            "dp->d_ops->sf_get_ftype(sfep)"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_get_ftype",
          "args": [
            "sfep"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "dp->d_ops->sf_get_ino(sfp, sfep)"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_get_ino",
          "args": [
            "sfp",
            "sfep"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dup->length"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_freeinsert",
          "args": [
            "hdr",
            "dp->d_ops->data_bestfree_p(hdr)",
            "dup",
            "&dummy"
          ],
          "line": 1210
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_freeinsert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "415-454",
          "snippet": "xfs_dir2_data_free_t *\t\t\t\t/* entry inserted */\nxfs_dir2_data_freeinsert(\n\tstruct xfs_dir2_data_hdr *hdr,\t\t/* data block pointer */\n\tstruct xfs_dir2_data_free *dfp,\t\t/* bestfree table pointer */\n\tstruct xfs_dir2_data_unused *dup,\t/* unused space */\n\tint\t\t\t*loghead)\t/* log the data header (out) */\n{\n\txfs_dir2_data_free_t\tnew;\t\t/* new bestfree entry */\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\tnew.length = dup->length;\n\tnew.offset = cpu_to_be16((char *)dup - (char *)hdr);\n\n\t/*\n\t * Insert at position 0, 1, or 2; or not at all.\n\t */\n\tif (be16_to_cpu(new.length) > be16_to_cpu(dfp[0].length)) {\n\t\tdfp[2] = dfp[1];\n\t\tdfp[1] = dfp[0];\n\t\tdfp[0] = new;\n\t\t*loghead = 1;\n\t\treturn &dfp[0];\n\t}\n\tif (be16_to_cpu(new.length) > be16_to_cpu(dfp[1].length)) {\n\t\tdfp[2] = dfp[1];\n\t\tdfp[1] = new;\n\t\t*loghead = 1;\n\t\treturn &dfp[1];\n\t}\n\tif (be16_to_cpu(new.length) > be16_to_cpu(dfp[2].length)) {\n\t\tdfp[2] = new;\n\t\t*loghead = 1;\n\t\treturn &dfp[2];\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_dir2_data_free_t *\t\t\t\t/* entry inserted */\nxfs_dir2_data_freeinsert(\n\tstruct xfs_dir2_data_hdr *hdr,\t\t/* data block pointer */\n\tstruct xfs_dir2_data_free *dfp,\t\t/* bestfree table pointer */\n\tstruct xfs_dir2_data_unused *dup,\t/* unused space */\n\tint\t\t\t*loghead)\t/* log the data header (out) */\n{\n\txfs_dir2_data_free_t\tnew;\t\t/* new bestfree entry */\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\tnew.length = dup->length;\n\tnew.offset = cpu_to_be16((char *)dup - (char *)hdr);\n\n\t/*\n\t * Insert at position 0, 1, or 2; or not at all.\n\t */\n\tif (be16_to_cpu(new.length) > be16_to_cpu(dfp[0].length)) {\n\t\tdfp[2] = dfp[1];\n\t\tdfp[1] = dfp[0];\n\t\tdfp[0] = new;\n\t\t*loghead = 1;\n\t\treturn &dfp[0];\n\t}\n\tif (be16_to_cpu(new.length) > be16_to_cpu(dfp[1].length)) {\n\t\tdfp[2] = dfp[1];\n\t\tdfp[1] = new;\n\t\t*loghead = 1;\n\t\treturn &dfp[1];\n\t}\n\tif (be16_to_cpu(new.length) > be16_to_cpu(dfp[2].length)) {\n\t\tdfp[2] = new;\n\t\t*loghead = 1;\n\t\treturn &dfp[2];\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_bestfree_p",
          "args": [
            "hdr"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_log_unused",
          "args": [
            "args",
            "bp",
            "dup"
          ],
          "line": 1209
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_log_unused",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "682-708",
          "snippet": "void\nxfs_dir2_data_log_unused(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_unused_t\t*dup)\t\t/* data unused pointer */\n{\n\txfs_dir2_data_hdr_t\t*hdr = bp->b_addr;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\t/*\n\t * Log the first part of the unused entry.\n\t */\n\txfs_trans_log_buf(args->trans, bp, (uint)((char *)dup - (char *)hdr),\n\t\t(uint)((char *)&dup->length + sizeof(dup->length) -\n\t\t       1 - (char *)hdr));\n\t/*\n\t * Log the end (tag) of the unused entry.\n\t */\n\txfs_trans_log_buf(args->trans, bp,\n\t\t(uint)((char *)xfs_dir2_data_unused_tag_p(dup) - (char *)hdr),\n\t\t(uint)((char *)xfs_dir2_data_unused_tag_p(dup) - (char *)hdr +\n\t\t       sizeof(xfs_dir2_data_off_t) - 1));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dir2_data_log_unused(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_unused_t\t*dup)\t\t/* data unused pointer */\n{\n\txfs_dir2_data_hdr_t\t*hdr = bp->b_addr;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\t/*\n\t * Log the first part of the unused entry.\n\t */\n\txfs_trans_log_buf(args->trans, bp, (uint)((char *)dup - (char *)hdr),\n\t\t(uint)((char *)&dup->length + sizeof(dup->length) -\n\t\t       1 - (char *)hdr));\n\t/*\n\t * Log the end (tag) of the unused entry.\n\t */\n\txfs_trans_log_buf(args->trans, bp,\n\t\t(uint)((char *)xfs_dir2_data_unused_tag_p(dup) - (char *)hdr),\n\t\t(uint)((char *)xfs_dir2_data_unused_tag_p(dup) - (char *)hdr +\n\t\t       sizeof(xfs_dir2_data_off_t) - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "((char *)dup - (char *)hdr)"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_unused_tag_p",
          "args": [
            "dup"
          ],
          "line": 1207
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_unused_tag_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "407-412",
          "snippet": "static inline __be16 *\nxfs_dir2_data_unused_tag_p(struct xfs_dir2_data_unused *dup)\n{\n\treturn (__be16 *)((char *)dup +\n\t\t\tbe16_to_cpu(dup->length) - sizeof(__be16));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __be16 *\nxfs_dir2_data_unused_tag_p(struct xfs_dir2_data_unused *dup)\n{\n\treturn (__be16 *)((char *)dup +\n\t\t\tbe16_to_cpu(dup->length) - sizeof(__be16));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "newoffset - offset"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DIR2_DATA_FREE_TAG"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_get_offset",
          "args": [
            "sfep"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_get_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "272-276",
          "snippet": "static inline xfs_dir2_data_aoff_t\nxfs_dir2_sf_get_offset(xfs_dir2_sf_entry_t *sfep)\n{\n\treturn get_unaligned_be16(&sfep->offset.i);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_data_aoff_t\nxfs_dir2_sf_get_offset(xfs_dir2_sf_entry_t *sfep)\n{\n\treturn get_unaligned_be16(&sfep->offset.i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_firstentry",
          "args": [
            "sfp"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_firstentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "284-289",
          "snippet": "static inline struct xfs_dir2_sf_entry *\nxfs_dir2_sf_firstentry(struct xfs_dir2_sf_hdr *hdr)\n{\n\treturn (struct xfs_dir2_sf_entry *)\n\t\t((char *)hdr + xfs_dir2_sf_hdr_size(hdr->i8count));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_sf_entry *\nxfs_dir2_sf_firstentry(struct xfs_dir2_sf_hdr *hdr)\n{\n\treturn (struct xfs_dir2_sf_entry *)\n\t\t((char *)hdr + xfs_dir2_sf_hdr_size(hdr->i8count));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "xfs_dir2_byte_to_dataptr(\n\t\t\t\t(char *)dep - (char *)hdr)"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "xfs_dir_hash_dotdot"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "(char *)dep - (char *)hdr"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_entry_tag_p",
          "args": [
            "dep"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_put_ftype",
          "args": [
            "dep",
            "XFS_DIR3_FT_DIR"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "dp->d_ops->sf_get_parent_ino(sfp)"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_get_parent_ino",
          "args": [
            "sfp"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_dotdot_entry_p",
          "args": [
            "hdr"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "xfs_dir2_byte_to_dataptr(\n\t\t\t\t(char *)dep - (char *)hdr)"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "xfs_dir_hash_dot"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "(char *)dep - (char *)hdr"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_entry_tag_p",
          "args": [
            "dep"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_put_ftype",
          "args": [
            "dep",
            "XFS_DIR3_FT_DIR"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "dp->i_ino"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_dot_entry_p",
          "args": [
            "hdr"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_use_free",
          "args": [
            "args",
            "bp",
            "dup",
            "(xfs_dir2_data_aoff_t)((char *)dup - (char *)hdr)",
            "be16_to_cpu(dup->length)",
            "&needlog",
            "&needscan"
          ],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_use_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "899-1048",
          "snippet": "void\nxfs_dir2_data_use_free(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_unused_t\t*dup,\t\t/* unused entry */\n\txfs_dir2_data_aoff_t\toffset,\t\t/* starting offset to use */\n\txfs_dir2_data_aoff_t\tlen,\t\t/* length to use */\n\tint\t\t\t*needlogp,\t/* out: need to log header */\n\tint\t\t\t*needscanp)\t/* out: need regen bestfree */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree pointer */\n\tint\t\t\tmatchback;\t/* matches end of freespace */\n\tint\t\t\tmatchfront;\t/* matches start of freespace */\n\tint\t\t\tneedscan;\t/* need to regen bestfree */\n\txfs_dir2_data_unused_t\t*newdup;\t/* new unused entry */\n\txfs_dir2_data_unused_t\t*newdup2;\t/* another new unused entry */\n\tint\t\t\toldlen;\t\t/* old unused entry's length */\n\tstruct xfs_dir2_data_free *bf;\n\n\thdr = bp->b_addr;\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\tASSERT(be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG);\n\tASSERT(offset >= (char *)dup - (char *)hdr);\n\tASSERT(offset + len <= (char *)dup + be16_to_cpu(dup->length) - (char *)hdr);\n\tASSERT((char *)dup - (char *)hdr == be16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)));\n\t/*\n\t * Look up the entry in the bestfree table.\n\t */\n\toldlen = be16_to_cpu(dup->length);\n\tbf = args->dp->d_ops->data_bestfree_p(hdr);\n\tdfp = xfs_dir2_data_freefind(hdr, bf, dup);\n\tASSERT(dfp || oldlen <= be16_to_cpu(bf[2].length));\n\t/*\n\t * Check for alignment with front and back of the entry.\n\t */\n\tmatchfront = (char *)dup - (char *)hdr == offset;\n\tmatchback = (char *)dup + oldlen - (char *)hdr == offset + len;\n\tASSERT(*needscanp == 0);\n\tneedscan = 0;\n\t/*\n\t * If we matched it exactly we just need to get rid of it from\n\t * the bestfree table.\n\t */\n\tif (matchfront && matchback) {\n\t\tif (dfp) {\n\t\t\tneedscan = (bf[2].offset != 0);\n\t\t\tif (!needscan)\n\t\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp,\n\t\t\t\t\t\t\t needlogp);\n\t\t}\n\t}\n\t/*\n\t * We match the first part of the entry.\n\t * Make a new entry with the remaining freespace.\n\t */\n\telse if (matchfront) {\n\t\tnewdup = (xfs_dir2_data_unused_t *)((char *)hdr + offset + len);\n\t\tnewdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup->length = cpu_to_be16(oldlen - len);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\t/*\n\t\t * If it was in the table, remove it and add the new one.\n\t\t */\n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\tdfp = xfs_dir2_data_freeinsert(hdr, bf, newdup,\n\t\t\t\t\t\t       needlogp);\n\t\t\tASSERT(dfp != NULL);\n\t\t\tASSERT(dfp->length == newdup->length);\n\t\t\tASSERT(be16_to_cpu(dfp->offset) == (char *)newdup - (char *)hdr);\n\t\t\t/*\n\t\t\t * If we got inserted at the last slot,\n\t\t\t * that means we don't know if there was a better\n\t\t\t * choice for the last slot, or not.  Rescan.\n\t\t\t */\n\t\t\tneedscan = dfp == &bf[2];\n\t\t}\n\t}\n\t/*\n\t * We match the last part of the entry.\n\t * Trim the allocated space off the tail of the entry.\n\t */\n\telse if (matchback) {\n\t\tnewdup = dup;\n\t\tnewdup->length = cpu_to_be16(((char *)hdr + offset) - (char *)newdup);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\t/*\n\t\t * If it was in the table, remove it and add the new one.\n\t\t */\n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\tdfp = xfs_dir2_data_freeinsert(hdr, bf, newdup,\n\t\t\t\t\t\t       needlogp);\n\t\t\tASSERT(dfp != NULL);\n\t\t\tASSERT(dfp->length == newdup->length);\n\t\t\tASSERT(be16_to_cpu(dfp->offset) == (char *)newdup - (char *)hdr);\n\t\t\t/*\n\t\t\t * If we got inserted at the last slot,\n\t\t\t * that means we don't know if there was a better\n\t\t\t * choice for the last slot, or not.  Rescan.\n\t\t\t */\n\t\t\tneedscan = dfp == &bf[2];\n\t\t}\n\t}\n\t/*\n\t * Poking out the middle of an entry.\n\t * Make two new entries.\n\t */\n\telse {\n\t\tnewdup = dup;\n\t\tnewdup->length = cpu_to_be16(((char *)hdr + offset) - (char *)newdup);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\tnewdup2 = (xfs_dir2_data_unused_t *)((char *)hdr + offset + len);\n\t\tnewdup2->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup2->length = cpu_to_be16(oldlen - len - be16_to_cpu(newdup->length));\n\t\t*xfs_dir2_data_unused_tag_p(newdup2) =\n\t\t\tcpu_to_be16((char *)newdup2 - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup2);\n\t\t/*\n\t\t * If the old entry was in the table, we need to scan\n\t\t * if the 3rd entry was valid, since these entries\n\t\t * are smaller than the old one.\n\t\t * If we don't need to scan that means there were 1 or 2\n\t\t * entries in the table, and removing the old and adding\n\t\t * the 2 new will work.\n\t\t */\n\t\tif (dfp) {\n\t\t\tneedscan = (bf[2].length != 0);\n\t\t\tif (!needscan) {\n\t\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp,\n\t\t\t\t\t\t\t needlogp);\n\t\t\t\txfs_dir2_data_freeinsert(hdr, bf, newdup,\n\t\t\t\t\t\t\t needlogp);\n\t\t\t\txfs_dir2_data_freeinsert(hdr, bf, newdup2,\n\t\t\t\t\t\t\t needlogp);\n\t\t\t}\n\t\t}\n\t}\n\t*needscanp = needscan;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dir2_data_use_free(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_unused_t\t*dup,\t\t/* unused entry */\n\txfs_dir2_data_aoff_t\toffset,\t\t/* starting offset to use */\n\txfs_dir2_data_aoff_t\tlen,\t\t/* length to use */\n\tint\t\t\t*needlogp,\t/* out: need to log header */\n\tint\t\t\t*needscanp)\t/* out: need regen bestfree */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree pointer */\n\tint\t\t\tmatchback;\t/* matches end of freespace */\n\tint\t\t\tmatchfront;\t/* matches start of freespace */\n\tint\t\t\tneedscan;\t/* need to regen bestfree */\n\txfs_dir2_data_unused_t\t*newdup;\t/* new unused entry */\n\txfs_dir2_data_unused_t\t*newdup2;\t/* another new unused entry */\n\tint\t\t\toldlen;\t\t/* old unused entry's length */\n\tstruct xfs_dir2_data_free *bf;\n\n\thdr = bp->b_addr;\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\tASSERT(be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG);\n\tASSERT(offset >= (char *)dup - (char *)hdr);\n\tASSERT(offset + len <= (char *)dup + be16_to_cpu(dup->length) - (char *)hdr);\n\tASSERT((char *)dup - (char *)hdr == be16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)));\n\t/*\n\t * Look up the entry in the bestfree table.\n\t */\n\toldlen = be16_to_cpu(dup->length);\n\tbf = args->dp->d_ops->data_bestfree_p(hdr);\n\tdfp = xfs_dir2_data_freefind(hdr, bf, dup);\n\tASSERT(dfp || oldlen <= be16_to_cpu(bf[2].length));\n\t/*\n\t * Check for alignment with front and back of the entry.\n\t */\n\tmatchfront = (char *)dup - (char *)hdr == offset;\n\tmatchback = (char *)dup + oldlen - (char *)hdr == offset + len;\n\tASSERT(*needscanp == 0);\n\tneedscan = 0;\n\t/*\n\t * If we matched it exactly we just need to get rid of it from\n\t * the bestfree table.\n\t */\n\tif (matchfront && matchback) {\n\t\tif (dfp) {\n\t\t\tneedscan = (bf[2].offset != 0);\n\t\t\tif (!needscan)\n\t\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp,\n\t\t\t\t\t\t\t needlogp);\n\t\t}\n\t}\n\t/*\n\t * We match the first part of the entry.\n\t * Make a new entry with the remaining freespace.\n\t */\n\telse if (matchfront) {\n\t\tnewdup = (xfs_dir2_data_unused_t *)((char *)hdr + offset + len);\n\t\tnewdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup->length = cpu_to_be16(oldlen - len);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\t/*\n\t\t * If it was in the table, remove it and add the new one.\n\t\t */\n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\tdfp = xfs_dir2_data_freeinsert(hdr, bf, newdup,\n\t\t\t\t\t\t       needlogp);\n\t\t\tASSERT(dfp != NULL);\n\t\t\tASSERT(dfp->length == newdup->length);\n\t\t\tASSERT(be16_to_cpu(dfp->offset) == (char *)newdup - (char *)hdr);\n\t\t\t/*\n\t\t\t * If we got inserted at the last slot,\n\t\t\t * that means we don't know if there was a better\n\t\t\t * choice for the last slot, or not.  Rescan.\n\t\t\t */\n\t\t\tneedscan = dfp == &bf[2];\n\t\t}\n\t}\n\t/*\n\t * We match the last part of the entry.\n\t * Trim the allocated space off the tail of the entry.\n\t */\n\telse if (matchback) {\n\t\tnewdup = dup;\n\t\tnewdup->length = cpu_to_be16(((char *)hdr + offset) - (char *)newdup);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\t/*\n\t\t * If it was in the table, remove it and add the new one.\n\t\t */\n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\tdfp = xfs_dir2_data_freeinsert(hdr, bf, newdup,\n\t\t\t\t\t\t       needlogp);\n\t\t\tASSERT(dfp != NULL);\n\t\t\tASSERT(dfp->length == newdup->length);\n\t\t\tASSERT(be16_to_cpu(dfp->offset) == (char *)newdup - (char *)hdr);\n\t\t\t/*\n\t\t\t * If we got inserted at the last slot,\n\t\t\t * that means we don't know if there was a better\n\t\t\t * choice for the last slot, or not.  Rescan.\n\t\t\t */\n\t\t\tneedscan = dfp == &bf[2];\n\t\t}\n\t}\n\t/*\n\t * Poking out the middle of an entry.\n\t * Make two new entries.\n\t */\n\telse {\n\t\tnewdup = dup;\n\t\tnewdup->length = cpu_to_be16(((char *)hdr + offset) - (char *)newdup);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\tnewdup2 = (xfs_dir2_data_unused_t *)((char *)hdr + offset + len);\n\t\tnewdup2->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup2->length = cpu_to_be16(oldlen - len - be16_to_cpu(newdup->length));\n\t\t*xfs_dir2_data_unused_tag_p(newdup2) =\n\t\t\tcpu_to_be16((char *)newdup2 - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup2);\n\t\t/*\n\t\t * If the old entry was in the table, we need to scan\n\t\t * if the 3rd entry was valid, since these entries\n\t\t * are smaller than the old one.\n\t\t * If we don't need to scan that means there were 1 or 2\n\t\t * entries in the table, and removing the old and adding\n\t\t * the 2 new will work.\n\t\t */\n\t\tif (dfp) {\n\t\t\tneedscan = (bf[2].length != 0);\n\t\t\tif (!needscan) {\n\t\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp,\n\t\t\t\t\t\t\t needlogp);\n\t\t\t\txfs_dir2_data_freeinsert(hdr, bf, newdup,\n\t\t\t\t\t\t\t needlogp);\n\t\t\t\txfs_dir2_data_freeinsert(hdr, bf, newdup2,\n\t\t\t\t\t\t\t needlogp);\n\t\t\t}\n\t\t}\n\t}\n\t*needscanp = needscan;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dup->length"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(char *)dup - (char *)hdr"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(char *)blp - (char *)hdr"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_leaf_p",
          "args": [
            "btp"
          ],
          "line": 1143
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_leaf_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "601-605",
          "snippet": "static inline struct xfs_dir2_leaf_entry *\nxfs_dir2_block_leaf_p(struct xfs_dir2_block_tail *btp)\n{\n\treturn ((struct xfs_dir2_leaf_entry *)btp) - be32_to_cpu(btp->count);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_leaf_entry *\nxfs_dir2_block_leaf_p(struct xfs_dir2_block_tail *btp)\n{\n\treturn ((struct xfs_dir2_leaf_entry *)btp) - be32_to_cpu(btp->count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sfp->count + 2"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_tail_p",
          "args": [
            "args->geo",
            "hdr"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_tail_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "305-310",
          "snippet": "static inline struct xfs_dir2_block_tail *\nxfs_dir2_block_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_data_hdr *hdr)\n{\n\treturn ((struct xfs_dir2_block_tail *)\n\t\t((char *)hdr + geo->blksize)) - 1;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_block_tail *\nxfs_dir2_block_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_data_hdr *hdr)\n{\n\treturn ((struct xfs_dir2_block_tail *)\n\t\t((char *)hdr + geo->blksize)) - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "needscan == 0"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_unused_p",
          "args": [
            "hdr"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_block_init",
          "args": [
            "mp",
            "tp",
            "bp",
            "dp"
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_block_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
          "lines": "143-165",
          "snippet": "static void\nxfs_dir3_block_init(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_inode\t*dp)\n{\n\tstruct xfs_dir3_blk_hdr *hdr3 = bp->b_addr;\n\n\tbp->b_ops = &xfs_dir3_block_buf_ops;\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DIR_BLOCK_BUF);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tmemset(hdr3, 0, sizeof(*hdr3));\n\t\thdr3->magic = cpu_to_be32(XFS_DIR3_BLOCK_MAGIC);\n\t\thdr3->blkno = cpu_to_be64(bp->b_bn);\n\t\thdr3->owner = cpu_to_be64(dp->i_ino);\n\t\tuuid_copy(&hdr3->uuid, &mp->m_sb.sb_uuid);\n\t\treturn;\n\n\t}\n\thdr3->magic = cpu_to_be32(XFS_DIR2_BLOCK_MAGIC);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);",
            "const struct xfs_buf_ops xfs_dir3_block_buf_ops = {\n\t.verify_read = xfs_dir3_block_read_verify,\n\t.verify_write = xfs_dir3_block_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);\nconst struct xfs_buf_ops xfs_dir3_block_buf_ops = {\n\t.verify_read = xfs_dir3_block_read_verify,\n\t.verify_write = xfs_dir3_block_write_verify,\n};\n\nstatic void\nxfs_dir3_block_init(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_inode\t*dp)\n{\n\tstruct xfs_dir3_blk_hdr *hdr3 = bp->b_addr;\n\n\tbp->b_ops = &xfs_dir3_block_buf_ops;\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DIR_BLOCK_BUF);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tmemset(hdr3, 0, sizeof(*hdr3));\n\t\thdr3->magic = cpu_to_be32(XFS_DIR3_BLOCK_MAGIC);\n\t\thdr3->blkno = cpu_to_be64(bp->b_bn);\n\t\thdr3->owner = cpu_to_be64(dp->i_ino);\n\t\tuuid_copy(&hdr3->uuid, &mp->m_sb.sb_uuid);\n\t\treturn;\n\n\t}\n\thdr3->magic = cpu_to_be32(XFS_DIR2_BLOCK_MAGIC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir3_data_init",
          "args": [
            "args",
            "blkno",
            "&bp"
          ],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_data_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "565-635",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir3_data_init(\n\txfs_da_args_t\t\t*args,\t\t/* directory operation args */\n\txfs_dir2_db_t\t\tblkno,\t\t/* logical dir block number */\n\tstruct xfs_buf\t\t**bpp)\t\t/* output block buffer */\n{\n\tstruct xfs_buf\t\t*bp;\t\t/* block buffer */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry pointer */\n\tstruct xfs_dir2_data_free *bf;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\ti;\t\t/* bestfree index */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tint                     t;              /* temp */\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\ttp = args->trans;\n\t/*\n\t * Get the buffer set up for the block.\n\t */\n\terror = xfs_da_get_buf(tp, dp, xfs_dir2_db_to_da(args->geo, blkno),\n\t\t\t       -1, &bp, XFS_DATA_FORK);\n\tif (error)\n\t\treturn error;\n\tbp->b_ops = &xfs_dir3_data_buf_ops;\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DIR_DATA_BUF);\n\n\t/*\n\t * Initialize the header.\n\t */\n\thdr = bp->b_addr;\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_dir3_blk_hdr *hdr3 = bp->b_addr;\n\n\t\tmemset(hdr3, 0, sizeof(*hdr3));\n\t\thdr3->magic = cpu_to_be32(XFS_DIR3_DATA_MAGIC);\n\t\thdr3->blkno = cpu_to_be64(bp->b_bn);\n\t\thdr3->owner = cpu_to_be64(dp->i_ino);\n\t\tuuid_copy(&hdr3->uuid, &mp->m_sb.sb_uuid);\n\n\t} else\n\t\thdr->magic = cpu_to_be32(XFS_DIR2_DATA_MAGIC);\n\n\tbf = dp->d_ops->data_bestfree_p(hdr);\n\tbf[0].offset = cpu_to_be16(dp->d_ops->data_entry_offset);\n\tfor (i = 1; i < XFS_DIR2_DATA_FD_COUNT; i++) {\n\t\tbf[i].length = 0;\n\t\tbf[i].offset = 0;\n\t}\n\n\t/*\n\t * Set up an unused entry for the block's body.\n\t */\n\tdup = dp->d_ops->data_unused_p(hdr);\n\tdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\n\tt = args->geo->blksize - (uint)dp->d_ops->data_entry_offset;\n\tbf[0].length = cpu_to_be16(t);\n\tdup->length = cpu_to_be16(t);\n\t*xfs_dir2_data_unused_tag_p(dup) = cpu_to_be16((char *)dup - (char *)hdr);\n\t/*\n\t * Log it and return it.\n\t */\n\txfs_dir2_data_log_header(args, bp);\n\txfs_dir2_data_log_unused(args, bp, dup);\n\t*bpp = bp;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_dir3_data_buf_ops = {\n\t.verify_read = xfs_dir3_data_read_verify,\n\t.verify_write = xfs_dir3_data_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_dir3_data_buf_ops = {\n\t.verify_read = xfs_dir3_data_read_verify,\n\t.verify_write = xfs_dir3_data_write_verify,\n};\n\nint\t\t\t\t\t\t/* error */\nxfs_dir3_data_init(\n\txfs_da_args_t\t\t*args,\t\t/* directory operation args */\n\txfs_dir2_db_t\t\tblkno,\t\t/* logical dir block number */\n\tstruct xfs_buf\t\t**bpp)\t\t/* output block buffer */\n{\n\tstruct xfs_buf\t\t*bp;\t\t/* block buffer */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry pointer */\n\tstruct xfs_dir2_data_free *bf;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\ti;\t\t/* bestfree index */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tint                     t;              /* temp */\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\ttp = args->trans;\n\t/*\n\t * Get the buffer set up for the block.\n\t */\n\terror = xfs_da_get_buf(tp, dp, xfs_dir2_db_to_da(args->geo, blkno),\n\t\t\t       -1, &bp, XFS_DATA_FORK);\n\tif (error)\n\t\treturn error;\n\tbp->b_ops = &xfs_dir3_data_buf_ops;\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DIR_DATA_BUF);\n\n\t/*\n\t * Initialize the header.\n\t */\n\thdr = bp->b_addr;\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_dir3_blk_hdr *hdr3 = bp->b_addr;\n\n\t\tmemset(hdr3, 0, sizeof(*hdr3));\n\t\thdr3->magic = cpu_to_be32(XFS_DIR3_DATA_MAGIC);\n\t\thdr3->blkno = cpu_to_be64(bp->b_bn);\n\t\thdr3->owner = cpu_to_be64(dp->i_ino);\n\t\tuuid_copy(&hdr3->uuid, &mp->m_sb.sb_uuid);\n\n\t} else\n\t\thdr->magic = cpu_to_be32(XFS_DIR2_DATA_MAGIC);\n\n\tbf = dp->d_ops->data_bestfree_p(hdr);\n\tbf[0].offset = cpu_to_be16(dp->d_ops->data_entry_offset);\n\tfor (i = 1; i < XFS_DIR2_DATA_FD_COUNT; i++) {\n\t\tbf[i].length = 0;\n\t\tbf[i].offset = 0;\n\t}\n\n\t/*\n\t * Set up an unused entry for the block's body.\n\t */\n\tdup = dp->d_ops->data_unused_p(hdr);\n\tdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\n\tt = args->geo->blksize - (uint)dp->d_ops->data_entry_offset;\n\tbf[0].length = cpu_to_be16(t);\n\tdup->length = cpu_to_be16(t);\n\t*xfs_dir2_data_unused_tag_p(dup) = cpu_to_be16((char *)dup - (char *)hdr);\n\t/*\n\t * Log it and return it.\n\t */\n\txfs_dir2_data_log_header(args, bp);\n\txfs_dir2_data_log_unused(args, bp, dup);\n\t*bpp = bp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_grow_inode",
          "args": [
            "args",
            "XFS_DIR2_DATA_SPACE",
            "&blkno"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_grow_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
          "lines": "575-614",
          "snippet": "int\nxfs_dir2_grow_inode(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\tspace,\t/* v2 dir's space XFS_DIR2_xxx_SPACE */\n\txfs_dir2_db_t\t\t*dbp)\t/* out: block number added */\n{\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\txfs_fileoff_t\t\tbno;\t/* directory offset of new block */\n\tint\t\t\tcount;\t/* count of filesystem blocks */\n\tint\t\t\terror;\n\n\ttrace_xfs_dir2_grow_inode(args, space);\n\n\t/*\n\t * Set lowest possible block in the space requested.\n\t */\n\tbno = XFS_B_TO_FSBT(mp, space * XFS_DIR2_SPACE_SIZE);\n\tcount = args->geo->fsbcount;\n\n\terror = xfs_da_grow_inode_int(args, &bno, count);\n\tif (error)\n\t\treturn error;\n\n\t*dbp = xfs_dir2_da_to_db(args->geo, (xfs_dablk_t)bno);\n\n\t/*\n\t * Update file's size if this is the data space and it grew.\n\t */\n\tif (space == XFS_DIR2_DATA_SPACE) {\n\t\txfs_fsize_t\tsize;\t\t/* directory file (data) size */\n\n\t\tsize = XFS_FSB_TO_B(mp, bno + count);\n\t\tif (size > dp->i_d.di_size) {\n\t\t\tdp->i_d.di_size = size;\n\t\t\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE);\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir2_grow_inode(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\tspace,\t/* v2 dir's space XFS_DIR2_xxx_SPACE */\n\txfs_dir2_db_t\t\t*dbp)\t/* out: block number added */\n{\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\txfs_fileoff_t\t\tbno;\t/* directory offset of new block */\n\tint\t\t\tcount;\t/* count of filesystem blocks */\n\tint\t\t\terror;\n\n\ttrace_xfs_dir2_grow_inode(args, space);\n\n\t/*\n\t * Set lowest possible block in the space requested.\n\t */\n\tbno = XFS_B_TO_FSBT(mp, space * XFS_DIR2_SPACE_SIZE);\n\tcount = args->geo->fsbcount;\n\n\terror = xfs_da_grow_inode_int(args, &bno, count);\n\tif (error)\n\t\treturn error;\n\n\t*dbp = xfs_dir2_da_to_db(args->geo, (xfs_dablk_t)bno);\n\n\t/*\n\t * Update file's size if this is the data space and it grew.\n\t */\n\tif (space == XFS_DIR2_DATA_SPACE) {\n\t\txfs_fsize_t\tsize;\t\t/* directory file (data) size */\n\n\t\tsize = XFS_FSB_TO_B(mp, bno + count);\n\t\tif (size > dp->i_d.di_size) {\n\t\t\tdp->i_d.di_size = size;\n\t\t\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE);\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_local_to_extents_empty",
          "args": [
            "dp",
            "XFS_DATA_FORK"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_local_to_extents_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "893-908",
          "snippet": "void\nxfs_bmap_local_to_extents_empty(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL);\n\tASSERT(ifp->if_bytes == 0);\n\tASSERT(XFS_IFORK_NEXTENTS(ip, whichfork) == 0);\n\n\txfs_bmap_forkoff_reset(ip, whichfork);\n\tifp->if_flags &= ~XFS_IFINLINE;\n\tifp->if_flags |= XFS_IFEXTENTS;\n\tXFS_IFORK_FMT_SET(ip, whichfork, XFS_DINODE_FMT_EXTENTS);\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmap_local_to_extents_empty(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL);\n\tASSERT(ifp->if_bytes == 0);\n\tASSERT(XFS_IFORK_NEXTENTS(ip, whichfork) == 0);\n\n\txfs_bmap_forkoff_reset(ip, whichfork);\n\tifp->if_flags &= ~XFS_IFINLINE;\n\tifp->if_flags |= XFS_IFEXTENTS;\n\tXFS_IFORK_FMT_SET(ip, whichfork, XFS_DINODE_FMT_EXTENTS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_idata_realloc",
          "args": [
            "dp",
            "-ifp->if_bytes",
            "XFS_DATA_FORK"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_idata_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "601-676",
          "snippet": "void\nxfs_idata_realloc(\n\txfs_inode_t\t*ip,\n\tint\t\tbyte_diff,\n\tint\t\twhichfork)\n{\n\txfs_ifork_t\t*ifp;\n\tint\t\tnew_size;\n\tint\t\treal_size;\n\n\tif (byte_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tnew_size = (int)ifp->if_bytes + byte_diff;\n\tASSERT(new_size >= 0);\n\n\tif (new_size == 0) {\n\t\tif (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t}\n\t\tifp->if_u1.if_data = NULL;\n\t\treal_size = 0;\n\t} else if (new_size <= sizeof(ifp->if_u2.if_inline_data)) {\n\t\t/*\n\t\t * If the valid extents/data can fit in if_inline_ext/data,\n\t\t * copy them from the malloc'd vector and free it.\n\t\t */\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tASSERT(ifp->if_real_bytes != 0);\n\t\t\tmemcpy(ifp->if_u2.if_inline_data, ifp->if_u1.if_data,\n\t\t\t      new_size);\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t}\n\t\treal_size = 0;\n\t} else {\n\t\t/*\n\t\t * Stuck with malloc/realloc.\n\t\t * For inline data, the underlying buffer must be\n\t\t * a multiple of 4 bytes in size so that it can be\n\t\t * logged and stay on word boundaries.  We enforce\n\t\t * that here.\n\t\t */\n\t\treal_size = roundup(new_size, 4);\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\t/*\n\t\t\t * Only do the realloc if the underlying size\n\t\t\t * is really changing.\n\t\t\t */\n\t\t\tif (ifp->if_real_bytes != real_size) {\n\t\t\t\tifp->if_u1.if_data =\n\t\t\t\t\tkmem_realloc(ifp->if_u1.if_data,\n\t\t\t\t\t\t\treal_size,\n\t\t\t\t\t\t\tifp->if_real_bytes,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\t}\n\t\t} else {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\tmemcpy(ifp->if_u1.if_data, ifp->if_u2.if_inline_data,\n\t\t\t\tifp->if_bytes);\n\t\t}\n\t}\n\tifp->if_real_bytes = real_size;\n\tifp->if_bytes = new_size;\n\tASSERT(ifp->if_bytes <= XFS_IFORK_SIZE(ip, whichfork));\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_idata_realloc(\n\txfs_inode_t\t*ip,\n\tint\t\tbyte_diff,\n\tint\t\twhichfork)\n{\n\txfs_ifork_t\t*ifp;\n\tint\t\tnew_size;\n\tint\t\treal_size;\n\n\tif (byte_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tnew_size = (int)ifp->if_bytes + byte_diff;\n\tASSERT(new_size >= 0);\n\n\tif (new_size == 0) {\n\t\tif (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t}\n\t\tifp->if_u1.if_data = NULL;\n\t\treal_size = 0;\n\t} else if (new_size <= sizeof(ifp->if_u2.if_inline_data)) {\n\t\t/*\n\t\t * If the valid extents/data can fit in if_inline_ext/data,\n\t\t * copy them from the malloc'd vector and free it.\n\t\t */\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tASSERT(ifp->if_real_bytes != 0);\n\t\t\tmemcpy(ifp->if_u2.if_inline_data, ifp->if_u1.if_data,\n\t\t\t      new_size);\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t}\n\t\treal_size = 0;\n\t} else {\n\t\t/*\n\t\t * Stuck with malloc/realloc.\n\t\t * For inline data, the underlying buffer must be\n\t\t * a multiple of 4 bytes in size so that it can be\n\t\t * logged and stay on word boundaries.  We enforce\n\t\t * that here.\n\t\t */\n\t\treal_size = roundup(new_size, 4);\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\t/*\n\t\t\t * Only do the realloc if the underlying size\n\t\t\t * is really changing.\n\t\t\t */\n\t\t\tif (ifp->if_real_bytes != real_size) {\n\t\t\t\tifp->if_u1.if_data =\n\t\t\t\t\tkmem_realloc(ifp->if_u1.if_data,\n\t\t\t\t\t\t\treal_size,\n\t\t\t\t\t\t\tifp->if_real_bytes,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\t}\n\t\t} else {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\tmemcpy(ifp->if_u1.if_data, ifp->if_u2.if_inline_data,\n\t\t\t\tifp->if_bytes);\n\t\t}\n\t}\n\tifp->if_real_bytes = real_size;\n\tifp->if_bytes = new_size;\n\tASSERT(ifp->if_bytes <= XFS_IFORK_SIZE(ip, whichfork));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sfp",
            "oldsfp",
            "ifp->if_bytes"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_alloc",
          "args": [
            "ifp->if_bytes",
            "KM_SLEEP"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "45-62",
          "snippet": "void *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dp->i_d.di_nextents == 0"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dp->i_d.di_size >= xfs_dir2_sf_hdr_size(oldsfp->i8count)"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_hdr_size",
          "args": [
            "oldsfp->i8count"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_hdr_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "265-270",
          "snippet": "static inline int xfs_dir2_sf_hdr_size(int i8count)\n{\n\treturn sizeof(struct xfs_dir2_sf_hdr) -\n\t\t(i8count == 0) *\n\t\t(sizeof(xfs_dir2_ino8_t) - sizeof(xfs_dir2_ino4_t));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int xfs_dir2_sf_hdr_size(int i8count)\n{\n\treturn sizeof(struct xfs_dir2_sf_hdr) -\n\t\t(i8count == 0) *\n\t\t(sizeof(xfs_dir2_ino8_t) - sizeof(xfs_dir2_ino4_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ifp->if_u1.if_data != NULL"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ifp->if_bytes == dp->i_d.di_size"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_FORCED_SHUTDOWN(mp)"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ifp->if_flags & XFS_IFINLINE"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_PTR",
          "args": [
            "dp",
            "XFS_DATA_FORK"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_dir2_sf_to_block",
          "args": [
            "args"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);\nstatic xfs_dahash_t xfs_dir_hash_dot, xfs_dir_hash_dotdot;\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_sf_to_block(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\txfs_dir2_db_t\t\tblkno;\t\t/* dir-relative block # (0) */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* block leaf entries */\n\tstruct xfs_buf\t\t*bp;\t\t/* block buffer */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail pointer */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry pointer */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\tdummy;\t\t/* trash */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry pointer */\n\tint\t\t\tendoffset;\t/* end of data objects */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\ti;\t\t/* index */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tint\t\t\tneedlog;\t/* need to log block header */\n\tint\t\t\tneedscan;\t/* need to scan block freespc */\n\tint\t\t\tnewoffset;\t/* offset from current entry */\n\tint\t\t\toffset;\t\t/* target block offset */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* sf entry pointer */\n\txfs_dir2_sf_hdr_t\t*oldsfp;\t/* old shortform header  */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform header  */\n\t__be16\t\t\t*tagp;\t\t/* end of data entry */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tstruct xfs_name\t\tname;\n\tstruct xfs_ifork\t*ifp;\n\n\ttrace_xfs_dir2_sf_to_block(args);\n\n\tdp = args->dp;\n\ttp = args->trans;\n\tmp = dp->i_mount;\n\tifp = XFS_IFORK_PTR(dp, XFS_DATA_FORK);\n\tASSERT(ifp->if_flags & XFS_IFINLINE);\n\t/*\n\t * Bomb out if the shortform directory is way too short.\n\t */\n\tif (dp->i_d.di_size < offsetof(xfs_dir2_sf_hdr_t, parent)) {\n\t\tASSERT(XFS_FORCED_SHUTDOWN(mp));\n\t\treturn -EIO;\n\t}\n\n\toldsfp = (xfs_dir2_sf_hdr_t *)ifp->if_u1.if_data;\n\n\tASSERT(ifp->if_bytes == dp->i_d.di_size);\n\tASSERT(ifp->if_u1.if_data != NULL);\n\tASSERT(dp->i_d.di_size >= xfs_dir2_sf_hdr_size(oldsfp->i8count));\n\tASSERT(dp->i_d.di_nextents == 0);\n\n\t/*\n\t * Copy the directory into a temporary buffer.\n\t * Then pitch the incore inode data so we can make extents.\n\t */\n\tsfp = kmem_alloc(ifp->if_bytes, KM_SLEEP);\n\tmemcpy(sfp, oldsfp, ifp->if_bytes);\n\n\txfs_idata_realloc(dp, -ifp->if_bytes, XFS_DATA_FORK);\n\txfs_bmap_local_to_extents_empty(dp, XFS_DATA_FORK);\n\tdp->i_d.di_size = 0;\n\n\t/*\n\t * Add block 0 to the inode.\n\t */\n\terror = xfs_dir2_grow_inode(args, XFS_DIR2_DATA_SPACE, &blkno);\n\tif (error) {\n\t\tkmem_free(sfp);\n\t\treturn error;\n\t}\n\t/*\n\t * Initialize the data block, then convert it to block format.\n\t */\n\terror = xfs_dir3_data_init(args, blkno, &bp);\n\tif (error) {\n\t\tkmem_free(sfp);\n\t\treturn error;\n\t}\n\txfs_dir3_block_init(mp, tp, bp, dp);\n\thdr = bp->b_addr;\n\n\t/*\n\t * Compute size of block \"tail\" area.\n\t */\n\ti = (uint)sizeof(*btp) +\n\t    (sfp->count + 2) * (uint)sizeof(xfs_dir2_leaf_entry_t);\n\t/*\n\t * The whole thing is initialized to free by the init routine.\n\t * Say we're using the leaf and tail area.\n\t */\n\tdup = dp->d_ops->data_unused_p(hdr);\n\tneedlog = needscan = 0;\n\txfs_dir2_data_use_free(args, bp, dup, args->geo->blksize - i,\n\t\t\t       i, &needlog, &needscan);\n\tASSERT(needscan == 0);\n\t/*\n\t * Fill in the tail.\n\t */\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tbtp->count = cpu_to_be32(sfp->count + 2);\t/* ., .. */\n\tbtp->stale = 0;\n\tblp = xfs_dir2_block_leaf_p(btp);\n\tendoffset = (uint)((char *)blp - (char *)hdr);\n\t/*\n\t * Remove the freespace, we'll manage it.\n\t */\n\txfs_dir2_data_use_free(args, bp, dup,\n\t\t(xfs_dir2_data_aoff_t)((char *)dup - (char *)hdr),\n\t\tbe16_to_cpu(dup->length), &needlog, &needscan);\n\t/*\n\t * Create entry for .\n\t */\n\tdep = dp->d_ops->data_dot_entry_p(hdr);\n\tdep->inumber = cpu_to_be64(dp->i_ino);\n\tdep->namelen = 1;\n\tdep->name[0] = '.';\n\tdp->d_ops->data_put_ftype(dep, XFS_DIR3_FT_DIR);\n\ttagp = dp->d_ops->data_entry_tag_p(dep);\n\t*tagp = cpu_to_be16((char *)dep - (char *)hdr);\n\txfs_dir2_data_log_entry(args, bp, dep);\n\tblp[0].hashval = cpu_to_be32(xfs_dir_hash_dot);\n\tblp[0].address = cpu_to_be32(xfs_dir2_byte_to_dataptr(\n\t\t\t\t(char *)dep - (char *)hdr));\n\t/*\n\t * Create entry for ..\n\t */\n\tdep = dp->d_ops->data_dotdot_entry_p(hdr);\n\tdep->inumber = cpu_to_be64(dp->d_ops->sf_get_parent_ino(sfp));\n\tdep->namelen = 2;\n\tdep->name[0] = dep->name[1] = '.';\n\tdp->d_ops->data_put_ftype(dep, XFS_DIR3_FT_DIR);\n\ttagp = dp->d_ops->data_entry_tag_p(dep);\n\t*tagp = cpu_to_be16((char *)dep - (char *)hdr);\n\txfs_dir2_data_log_entry(args, bp, dep);\n\tblp[1].hashval = cpu_to_be32(xfs_dir_hash_dotdot);\n\tblp[1].address = cpu_to_be32(xfs_dir2_byte_to_dataptr(\n\t\t\t\t(char *)dep - (char *)hdr));\n\toffset = dp->d_ops->data_first_offset;\n\t/*\n\t * Loop over existing entries, stuff them in.\n\t */\n\ti = 0;\n\tif (!sfp->count)\n\t\tsfep = NULL;\n\telse\n\t\tsfep = xfs_dir2_sf_firstentry(sfp);\n\t/*\n\t * Need to preserve the existing offset values in the sf directory.\n\t * Insert holes (unused entries) where necessary.\n\t */\n\twhile (offset < endoffset) {\n\t\t/*\n\t\t * sfep is null when we reach the end of the list.\n\t\t */\n\t\tif (sfep == NULL)\n\t\t\tnewoffset = endoffset;\n\t\telse\n\t\t\tnewoffset = xfs_dir2_sf_get_offset(sfep);\n\t\t/*\n\t\t * There should be a hole here, make one.\n\t\t */\n\t\tif (offset < newoffset) {\n\t\t\tdup = (xfs_dir2_data_unused_t *)((char *)hdr + offset);\n\t\t\tdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\t\tdup->length = cpu_to_be16(newoffset - offset);\n\t\t\t*xfs_dir2_data_unused_tag_p(dup) = cpu_to_be16(\n\t\t\t\t((char *)dup - (char *)hdr));\n\t\t\txfs_dir2_data_log_unused(args, bp, dup);\n\t\t\txfs_dir2_data_freeinsert(hdr,\n\t\t\t\t\t\t dp->d_ops->data_bestfree_p(hdr),\n\t\t\t\t\t\t dup, &dummy);\n\t\t\toffset += be16_to_cpu(dup->length);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Copy a real entry.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)((char *)hdr + newoffset);\n\t\tdep->inumber = cpu_to_be64(dp->d_ops->sf_get_ino(sfp, sfep));\n\t\tdep->namelen = sfep->namelen;\n\t\tdp->d_ops->data_put_ftype(dep, dp->d_ops->sf_get_ftype(sfep));\n\t\tmemcpy(dep->name, sfep->name, dep->namelen);\n\t\ttagp = dp->d_ops->data_entry_tag_p(dep);\n\t\t*tagp = cpu_to_be16((char *)dep - (char *)hdr);\n\t\txfs_dir2_data_log_entry(args, bp, dep);\n\t\tname.name = sfep->name;\n\t\tname.len = sfep->namelen;\n\t\tblp[2 + i].hashval = cpu_to_be32(mp->m_dirnameops->\n\t\t\t\t\t\t\thashname(&name));\n\t\tblp[2 + i].address = cpu_to_be32(xfs_dir2_byte_to_dataptr(\n\t\t\t\t\t\t (char *)dep - (char *)hdr));\n\t\toffset = (int)((char *)(tagp + 1) - (char *)hdr);\n\t\tif (++i == sfp->count)\n\t\t\tsfep = NULL;\n\t\telse\n\t\t\tsfep = dp->d_ops->sf_nextentry(sfp, sfep);\n\t}\n\t/* Done with the temporary buffer */\n\tkmem_free(sfp);\n\t/*\n\t * Sort the leaf entries by hash value.\n\t */\n\txfs_sort(blp, be32_to_cpu(btp->count), sizeof(*blp), xfs_dir2_block_sort);\n\t/*\n\t * Log the leaf entry area and tail.\n\t * Already logged the header in data_init, ignore needlog.\n\t */\n\tASSERT(needscan == 0);\n\txfs_dir2_block_log_leaf(tp, bp, 0, be32_to_cpu(btp->count) - 1);\n\txfs_dir2_block_log_tail(tp, bp);\n\txfs_dir3_data_check(dp, bp);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_dir2_leaf_to_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
    "lines": "897-1037",
    "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_leaf_to_block(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tstruct xfs_buf\t\t*lbp,\t\t/* leaf buffer */\n\tstruct xfs_buf\t\t*dbp)\t\t/* data buffer */\n{\n\t__be16\t\t\t*bestsp;\t/* leaf bests table */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused data entry */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tfrom;\t\t/* leaf from index */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf tail structure */\n\txfs_mount_t\t\t*mp;\t\t/* file system mount point */\n\tint\t\t\tneedlog;\t/* need to log data header */\n\tint\t\t\tneedscan;\t/* need to scan for bestfree */\n\txfs_dir2_sf_hdr_t\tsfh;\t\t/* shortform header */\n\tint\t\t\tsize;\t\t/* bytes used */\n\t__be16\t\t\t*tagp;\t\t/* end of entry (tag) */\n\tint\t\t\tto;\t\t/* block/leaf to index */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\ttrace_xfs_dir2_leaf_to_block(args);\n\n\tdp = args->dp;\n\ttp = args->trans;\n\tmp = dp->i_mount;\n\tleaf = lbp->b_addr;\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\n\tASSERT(leafhdr.magic == XFS_DIR2_LEAF1_MAGIC ||\n\t       leafhdr.magic == XFS_DIR3_LEAF1_MAGIC);\n\t/*\n\t * If there are data blocks other than the first one, take this\n\t * opportunity to remove trailing empty data blocks that may have\n\t * been left behind during no-space-reservation operations.\n\t * These will show up in the leaf bests table.\n\t */\n\twhile (dp->i_d.di_size > args->geo->blksize) {\n\t\tint hdrsz;\n\n\t\thdrsz = dp->d_ops->data_entry_offset;\n\t\tbestsp = xfs_dir2_leaf_bests_p(ltp);\n\t\tif (be16_to_cpu(bestsp[be32_to_cpu(ltp->bestcount) - 1]) ==\n\t\t\t\t\t    args->geo->blksize - hdrsz) {\n\t\t\tif ((error =\n\t\t\t    xfs_dir2_leaf_trim_data(args, lbp,\n\t\t\t\t    (xfs_dir2_db_t)(be32_to_cpu(ltp->bestcount) - 1))))\n\t\t\t\treturn error;\n\t\t} else\n\t\t\treturn 0;\n\t}\n\t/*\n\t * Read the data block if we don't already have it, give up if it fails.\n\t */\n\tif (!dbp) {\n\t\terror = xfs_dir3_data_read(tp, dp, args->geo->datablk, -1, &dbp);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\thdr = dbp->b_addr;\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC));\n\n\t/*\n\t * Size of the \"leaf\" area in the block.\n\t */\n\tsize = (uint)sizeof(xfs_dir2_block_tail_t) +\n\t       (uint)sizeof(*lep) * (leafhdr.count - leafhdr.stale);\n\t/*\n\t * Look at the last data entry.\n\t */\n\ttagp = (__be16 *)((char *)hdr + args->geo->blksize) - 1;\n\tdup = (xfs_dir2_data_unused_t *)((char *)hdr + be16_to_cpu(*tagp));\n\t/*\n\t * If it's not free or is too short we can't do it.\n\t */\n\tif (be16_to_cpu(dup->freetag) != XFS_DIR2_DATA_FREE_TAG ||\n\t    be16_to_cpu(dup->length) < size)\n\t\treturn 0;\n\n\t/*\n\t * Start converting it to block form.\n\t */\n\txfs_dir3_block_init(mp, tp, dbp, dp);\n\n\tneedlog = 1;\n\tneedscan = 0;\n\t/*\n\t * Use up the space at the end of the block (blp/btp).\n\t */\n\txfs_dir2_data_use_free(args, dbp, dup, args->geo->blksize - size, size,\n\t\t&needlog, &needscan);\n\t/*\n\t * Initialize the block tail.\n\t */\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tbtp->count = cpu_to_be32(leafhdr.count - leafhdr.stale);\n\tbtp->stale = 0;\n\txfs_dir2_block_log_tail(tp, dbp);\n\t/*\n\t * Initialize the block leaf area.  We compact out stale entries.\n\t */\n\tlep = xfs_dir2_block_leaf_p(btp);\n\tfor (from = to = 0; from < leafhdr.count; from++) {\n\t\tif (ents[from].address == cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\tcontinue;\n\t\tlep[to++] = ents[from];\n\t}\n\tASSERT(to == be32_to_cpu(btp->count));\n\txfs_dir2_block_log_leaf(tp, dbp, 0, be32_to_cpu(btp->count) - 1);\n\t/*\n\t * Scan the bestfree if we need it and log the data block header.\n\t */\n\tif (needscan)\n\t\txfs_dir2_data_freescan(dp, hdr, &needlog);\n\tif (needlog)\n\t\txfs_dir2_data_log_header(args, dbp);\n\t/*\n\t * Pitch the old leaf block.\n\t */\n\terror = xfs_da_shrink_inode(args, args->geo->leafblk, lbp);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Now see if the resulting block can be shrunken to shortform.\n\t */\n\tsize = xfs_dir2_block_sfsize(dp, hdr, &sfh);\n\tif (size > XFS_IFORK_DSIZE(dp))\n\t\treturn 0;\n\n\treturn xfs_dir2_block_to_sf(args, dbp, size, &sfh);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xfs_dir2_block_log_leaf(xfs_trans_t *tp, struct xfs_buf *bp,\n\t\t\t\t    int first, int last);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_dir2_block_to_sf",
          "args": [
            "args",
            "dbp",
            "size",
            "&sfh"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_to_sf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_sf.c",
          "lines": "152-274",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_block_to_sf(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tsize,\t\t/* shortform directory size */\n\txfs_dir2_sf_hdr_t\t*sfhp)\t\t/* shortform directory hdr */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail pointer */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry pointer */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused data pointer */\n\tchar\t\t\t*endptr;\t/* end of data entries */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlogflags;\t/* inode logging flags */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tchar\t\t\t*ptr;\t\t/* current data pointer */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* shortform entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform directory header */\n\txfs_dir2_sf_hdr_t\t*dst;\t\t/* temporary data buffer */\n\n\ttrace_xfs_dir2_block_to_sf(args);\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\n\t/*\n\t * allocate a temporary destination buffer the size of the inode\n\t * to format the data into. Once we have formatted the data, we\n\t * can free the block and copy the formatted data into the inode literal\n\t * area.\n\t */\n\tdst = kmem_alloc(mp->m_sb.sb_inodesize, KM_SLEEP);\n\thdr = bp->b_addr;\n\n\t/*\n\t * Copy the header into the newly allocate local space.\n\t */\n\tsfp = (xfs_dir2_sf_hdr_t *)dst;\n\tmemcpy(sfp, sfhp, xfs_dir2_sf_hdr_size(sfhp->i8count));\n\n\t/*\n\t * Set up to loop over the block's entries.\n\t */\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tptr = (char *)dp->d_ops->data_entry_p(hdr);\n\tendptr = (char *)xfs_dir2_block_leaf_p(btp);\n\tsfep = xfs_dir2_sf_firstentry(sfp);\n\t/*\n\t * Loop over the active and unused entries.\n\t * Stop when we reach the leaf/tail portion of the block.\n\t */\n\twhile (ptr < endptr) {\n\t\t/*\n\t\t * If it's unused, just skip over it.\n\t\t */\n\t\tdup = (xfs_dir2_data_unused_t *)ptr;\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tptr += be16_to_cpu(dup->length);\n\t\t\tcontinue;\n\t\t}\n\t\tdep = (xfs_dir2_data_entry_t *)ptr;\n\t\t/*\n\t\t * Skip .\n\t\t */\n\t\tif (dep->namelen == 1 && dep->name[0] == '.')\n\t\t\tASSERT(be64_to_cpu(dep->inumber) == dp->i_ino);\n\t\t/*\n\t\t * Skip .., but make sure the inode number is right.\n\t\t */\n\t\telse if (dep->namelen == 2 &&\n\t\t\t dep->name[0] == '.' && dep->name[1] == '.')\n\t\t\tASSERT(be64_to_cpu(dep->inumber) ==\n\t\t\t       dp->d_ops->sf_get_parent_ino(sfp));\n\t\t/*\n\t\t * Normal entry, copy it into shortform.\n\t\t */\n\t\telse {\n\t\t\tsfep->namelen = dep->namelen;\n\t\t\txfs_dir2_sf_put_offset(sfep,\n\t\t\t\t(xfs_dir2_data_aoff_t)\n\t\t\t\t((char *)dep - (char *)hdr));\n\t\t\tmemcpy(sfep->name, dep->name, dep->namelen);\n\t\t\tdp->d_ops->sf_put_ino(sfp, sfep,\n\t\t\t\t\t      be64_to_cpu(dep->inumber));\n\t\t\tdp->d_ops->sf_put_ftype(sfep,\n\t\t\t\t\tdp->d_ops->data_get_ftype(dep));\n\n\t\t\tsfep = dp->d_ops->sf_nextentry(sfp, sfep);\n\t\t}\n\t\tptr += dp->d_ops->data_entsize(dep->namelen);\n\t}\n\tASSERT((char *)sfep - (char *)sfp == size);\n\n\t/* now we are done with the block, we can shrink the inode */\n\tlogflags = XFS_ILOG_CORE;\n\terror = xfs_dir2_shrink_inode(args, args->geo->datablk, bp);\n\tif (error) {\n\t\tASSERT(error != -ENOSPC);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The buffer is now unconditionally gone, whether\n\t * xfs_dir2_shrink_inode worked or not.\n\t *\n\t * Convert the inode to local format and copy the data in.\n\t */\n\tdp->i_df.if_flags &= ~XFS_IFEXTENTS;\n\tdp->i_df.if_flags |= XFS_IFINLINE;\n\tdp->i_d.di_format = XFS_DINODE_FMT_LOCAL;\n\tASSERT(dp->i_df.if_bytes == 0);\n\txfs_idata_realloc(dp, size, XFS_DATA_FORK);\n\n\tlogflags |= XFS_ILOG_DDATA;\n\tmemcpy(dp->i_df.if_u1.if_data, dst, size);\n\tdp->i_d.di_size = size;\n\txfs_dir2_sf_check(args);\nout:\n\txfs_trans_log_inode(args->trans, dp, logflags);\n\tkmem_free(dst);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir2_sf_toino4(xfs_da_args_t *args);",
            "static void xfs_dir2_sf_toino8(xfs_da_args_t *args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_sf_toino4(xfs_da_args_t *args);\nstatic void xfs_dir2_sf_toino8(xfs_da_args_t *args);\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_block_to_sf(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tsize,\t\t/* shortform directory size */\n\txfs_dir2_sf_hdr_t\t*sfhp)\t\t/* shortform directory hdr */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail pointer */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry pointer */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused data pointer */\n\tchar\t\t\t*endptr;\t/* end of data entries */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlogflags;\t/* inode logging flags */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tchar\t\t\t*ptr;\t\t/* current data pointer */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* shortform entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform directory header */\n\txfs_dir2_sf_hdr_t\t*dst;\t\t/* temporary data buffer */\n\n\ttrace_xfs_dir2_block_to_sf(args);\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\n\t/*\n\t * allocate a temporary destination buffer the size of the inode\n\t * to format the data into. Once we have formatted the data, we\n\t * can free the block and copy the formatted data into the inode literal\n\t * area.\n\t */\n\tdst = kmem_alloc(mp->m_sb.sb_inodesize, KM_SLEEP);\n\thdr = bp->b_addr;\n\n\t/*\n\t * Copy the header into the newly allocate local space.\n\t */\n\tsfp = (xfs_dir2_sf_hdr_t *)dst;\n\tmemcpy(sfp, sfhp, xfs_dir2_sf_hdr_size(sfhp->i8count));\n\n\t/*\n\t * Set up to loop over the block's entries.\n\t */\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tptr = (char *)dp->d_ops->data_entry_p(hdr);\n\tendptr = (char *)xfs_dir2_block_leaf_p(btp);\n\tsfep = xfs_dir2_sf_firstentry(sfp);\n\t/*\n\t * Loop over the active and unused entries.\n\t * Stop when we reach the leaf/tail portion of the block.\n\t */\n\twhile (ptr < endptr) {\n\t\t/*\n\t\t * If it's unused, just skip over it.\n\t\t */\n\t\tdup = (xfs_dir2_data_unused_t *)ptr;\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tptr += be16_to_cpu(dup->length);\n\t\t\tcontinue;\n\t\t}\n\t\tdep = (xfs_dir2_data_entry_t *)ptr;\n\t\t/*\n\t\t * Skip .\n\t\t */\n\t\tif (dep->namelen == 1 && dep->name[0] == '.')\n\t\t\tASSERT(be64_to_cpu(dep->inumber) == dp->i_ino);\n\t\t/*\n\t\t * Skip .., but make sure the inode number is right.\n\t\t */\n\t\telse if (dep->namelen == 2 &&\n\t\t\t dep->name[0] == '.' && dep->name[1] == '.')\n\t\t\tASSERT(be64_to_cpu(dep->inumber) ==\n\t\t\t       dp->d_ops->sf_get_parent_ino(sfp));\n\t\t/*\n\t\t * Normal entry, copy it into shortform.\n\t\t */\n\t\telse {\n\t\t\tsfep->namelen = dep->namelen;\n\t\t\txfs_dir2_sf_put_offset(sfep,\n\t\t\t\t(xfs_dir2_data_aoff_t)\n\t\t\t\t((char *)dep - (char *)hdr));\n\t\t\tmemcpy(sfep->name, dep->name, dep->namelen);\n\t\t\tdp->d_ops->sf_put_ino(sfp, sfep,\n\t\t\t\t\t      be64_to_cpu(dep->inumber));\n\t\t\tdp->d_ops->sf_put_ftype(sfep,\n\t\t\t\t\tdp->d_ops->data_get_ftype(dep));\n\n\t\t\tsfep = dp->d_ops->sf_nextentry(sfp, sfep);\n\t\t}\n\t\tptr += dp->d_ops->data_entsize(dep->namelen);\n\t}\n\tASSERT((char *)sfep - (char *)sfp == size);\n\n\t/* now we are done with the block, we can shrink the inode */\n\tlogflags = XFS_ILOG_CORE;\n\terror = xfs_dir2_shrink_inode(args, args->geo->datablk, bp);\n\tif (error) {\n\t\tASSERT(error != -ENOSPC);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The buffer is now unconditionally gone, whether\n\t * xfs_dir2_shrink_inode worked or not.\n\t *\n\t * Convert the inode to local format and copy the data in.\n\t */\n\tdp->i_df.if_flags &= ~XFS_IFEXTENTS;\n\tdp->i_df.if_flags |= XFS_IFINLINE;\n\tdp->i_d.di_format = XFS_DINODE_FMT_LOCAL;\n\tASSERT(dp->i_df.if_bytes == 0);\n\txfs_idata_realloc(dp, size, XFS_DATA_FORK);\n\n\tlogflags |= XFS_ILOG_DDATA;\n\tmemcpy(dp->i_df.if_u1.if_data, dst, size);\n\tdp->i_d.di_size = size;\n\txfs_dir2_sf_check(args);\nout:\n\txfs_trans_log_inode(args->trans, dp, logflags);\n\tkmem_free(dst);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_DSIZE",
          "args": [
            "dp"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_sfsize",
          "args": [
            "dp",
            "hdr",
            "&sfh"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_sfsize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_sf.c",
          "lines": "61-146",
          "snippet": "int\t\t\t\t\t\t/* size for sf form */\nxfs_dir2_block_sfsize(\n\txfs_inode_t\t\t*dp,\t\t/* incore inode pointer */\n\txfs_dir2_data_hdr_t\t*hdr,\t\t/* block directory data */\n\txfs_dir2_sf_hdr_t\t*sfhp)\t\t/* output: header for sf form */\n{\n\txfs_dir2_dataptr_t\taddr;\t\t/* data entry address */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* leaf area of the block */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* tail area of the block */\n\tint\t\t\tcount;\t\t/* shortform entry count */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry in the block */\n\tint\t\t\ti;\t\t/* block entry index */\n\tint\t\t\ti8count;\t/* count of big-inode entries */\n\tint\t\t\tisdot;\t\t/* entry is \".\" */\n\tint\t\t\tisdotdot;\t/* entry is \"..\" */\n\txfs_mount_t\t\t*mp;\t\t/* mount structure pointer */\n\tint\t\t\tnamelen;\t/* total name bytes */\n\txfs_ino_t\t\tparent = 0;\t/* parent inode number */\n\tint\t\t\tsize=0;\t\t/* total computed size */\n\tint\t\t\thas_ftype;\n\tstruct xfs_da_geometry\t*geo;\n\n\tmp = dp->i_mount;\n\tgeo = mp->m_dir_geo;\n\n\t/*\n\t * if there is a filetype field, add the extra byte to the namelen\n\t * for each entry that we see.\n\t */\n\thas_ftype = xfs_sb_version_hasftype(&mp->m_sb) ? 1 : 0;\n\n\tcount = i8count = namelen = 0;\n\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\n\t/*\n\t * Iterate over the block's data entries by using the leaf pointers.\n\t */\n\tfor (i = 0; i < be32_to_cpu(btp->count); i++) {\n\t\tif ((addr = be32_to_cpu(blp[i].address)) == XFS_DIR2_NULL_DATAPTR)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Calculate the pointer to the entry at hand.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)((char *)hdr +\n\t\t\t\txfs_dir2_dataptr_to_off(geo, addr));\n\t\t/*\n\t\t * Detect . and .., so we can special-case them.\n\t\t * . is not included in sf directories.\n\t\t * .. is included by just the parent inode number.\n\t\t */\n\t\tisdot = dep->namelen == 1 && dep->name[0] == '.';\n\t\tisdotdot =\n\t\t\tdep->namelen == 2 &&\n\t\t\tdep->name[0] == '.' && dep->name[1] == '.';\n\n\t\tif (!isdot)\n\t\t\ti8count += be64_to_cpu(dep->inumber) > XFS_DIR2_MAX_SHORT_INUM;\n\n\t\t/* take into account the file type field */\n\t\tif (!isdot && !isdotdot) {\n\t\t\tcount++;\n\t\t\tnamelen += dep->namelen + has_ftype;\n\t\t} else if (isdotdot)\n\t\t\tparent = be64_to_cpu(dep->inumber);\n\t\t/*\n\t\t * Calculate the new size, see if we should give up yet.\n\t\t */\n\t\tsize = xfs_dir2_sf_hdr_size(i8count) +\t\t/* header */\n\t\t       count +\t\t\t\t\t/* namelen */\n\t\t       count * (uint)sizeof(xfs_dir2_sf_off_t) + /* offset */\n\t\t       namelen +\t\t\t\t/* name */\n\t\t       (i8count ?\t\t\t\t/* inumber */\n\t\t\t\t(uint)sizeof(xfs_dir2_ino8_t) * count :\n\t\t\t\t(uint)sizeof(xfs_dir2_ino4_t) * count);\n\t\tif (size > XFS_IFORK_DSIZE(dp))\n\t\t\treturn size;\t\t/* size value is a failure */\n\t}\n\t/*\n\t * Create the output header, if it worked.\n\t */\n\tsfhp->count = count;\n\tsfhp->i8count = i8count;\n\tdp->d_ops->sf_put_parent_ino(sfhp, parent);\n\treturn size;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* size for sf form */\nxfs_dir2_block_sfsize(\n\txfs_inode_t\t\t*dp,\t\t/* incore inode pointer */\n\txfs_dir2_data_hdr_t\t*hdr,\t\t/* block directory data */\n\txfs_dir2_sf_hdr_t\t*sfhp)\t\t/* output: header for sf form */\n{\n\txfs_dir2_dataptr_t\taddr;\t\t/* data entry address */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* leaf area of the block */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* tail area of the block */\n\tint\t\t\tcount;\t\t/* shortform entry count */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry in the block */\n\tint\t\t\ti;\t\t/* block entry index */\n\tint\t\t\ti8count;\t/* count of big-inode entries */\n\tint\t\t\tisdot;\t\t/* entry is \".\" */\n\tint\t\t\tisdotdot;\t/* entry is \"..\" */\n\txfs_mount_t\t\t*mp;\t\t/* mount structure pointer */\n\tint\t\t\tnamelen;\t/* total name bytes */\n\txfs_ino_t\t\tparent = 0;\t/* parent inode number */\n\tint\t\t\tsize=0;\t\t/* total computed size */\n\tint\t\t\thas_ftype;\n\tstruct xfs_da_geometry\t*geo;\n\n\tmp = dp->i_mount;\n\tgeo = mp->m_dir_geo;\n\n\t/*\n\t * if there is a filetype field, add the extra byte to the namelen\n\t * for each entry that we see.\n\t */\n\thas_ftype = xfs_sb_version_hasftype(&mp->m_sb) ? 1 : 0;\n\n\tcount = i8count = namelen = 0;\n\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\n\t/*\n\t * Iterate over the block's data entries by using the leaf pointers.\n\t */\n\tfor (i = 0; i < be32_to_cpu(btp->count); i++) {\n\t\tif ((addr = be32_to_cpu(blp[i].address)) == XFS_DIR2_NULL_DATAPTR)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Calculate the pointer to the entry at hand.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)((char *)hdr +\n\t\t\t\txfs_dir2_dataptr_to_off(geo, addr));\n\t\t/*\n\t\t * Detect . and .., so we can special-case them.\n\t\t * . is not included in sf directories.\n\t\t * .. is included by just the parent inode number.\n\t\t */\n\t\tisdot = dep->namelen == 1 && dep->name[0] == '.';\n\t\tisdotdot =\n\t\t\tdep->namelen == 2 &&\n\t\t\tdep->name[0] == '.' && dep->name[1] == '.';\n\n\t\tif (!isdot)\n\t\t\ti8count += be64_to_cpu(dep->inumber) > XFS_DIR2_MAX_SHORT_INUM;\n\n\t\t/* take into account the file type field */\n\t\tif (!isdot && !isdotdot) {\n\t\t\tcount++;\n\t\t\tnamelen += dep->namelen + has_ftype;\n\t\t} else if (isdotdot)\n\t\t\tparent = be64_to_cpu(dep->inumber);\n\t\t/*\n\t\t * Calculate the new size, see if we should give up yet.\n\t\t */\n\t\tsize = xfs_dir2_sf_hdr_size(i8count) +\t\t/* header */\n\t\t       count +\t\t\t\t\t/* namelen */\n\t\t       count * (uint)sizeof(xfs_dir2_sf_off_t) + /* offset */\n\t\t       namelen +\t\t\t\t/* name */\n\t\t       (i8count ?\t\t\t\t/* inumber */\n\t\t\t\t(uint)sizeof(xfs_dir2_ino8_t) * count :\n\t\t\t\t(uint)sizeof(xfs_dir2_ino4_t) * count);\n\t\tif (size > XFS_IFORK_DSIZE(dp))\n\t\t\treturn size;\t\t/* size value is a failure */\n\t}\n\t/*\n\t * Create the output header, if it worked.\n\t */\n\tsfhp->count = count;\n\tsfhp->i8count = i8count;\n\tdp->d_ops->sf_put_parent_ino(sfhp, parent);\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da_shrink_inode",
          "args": [
            "args",
            "args->geo->leafblk",
            "lbp"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_shrink_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "2332-2369",
          "snippet": "int\nxfs_da_shrink_inode(\n\txfs_da_args_t\t*args,\n\txfs_dablk_t\tdead_blkno,\n\tstruct xfs_buf\t*dead_buf)\n{\n\txfs_inode_t *dp;\n\tint done, error, w, count;\n\txfs_trans_t *tp;\n\n\ttrace_xfs_da_shrink_inode(args);\n\n\tdp = args->dp;\n\tw = args->whichfork;\n\ttp = args->trans;\n\tcount = args->geo->fsbcount;\n\tfor (;;) {\n\t\t/*\n\t\t * Remove extents.  If we get ENOSPC for a dir we have to move\n\t\t * the last block to the place we want to kill.\n\t\t */\n\t\terror = xfs_bunmapi(tp, dp, dead_blkno, count,\n\t\t\t\t    xfs_bmapi_aflag(w)|XFS_BMAPI_METADATA,\n\t\t\t\t    0, args->firstblock, args->flist, &done);\n\t\tif (error == -ENOSPC) {\n\t\t\tif (w != XFS_DATA_FORK)\n\t\t\t\tbreak;\n\t\t\terror = xfs_da3_swap_lastblock(args, &dead_blkno,\n\t\t\t\t\t\t      &dead_buf);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\txfs_trans_binval(tp, dead_buf);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_da_shrink_inode(\n\txfs_da_args_t\t*args,\n\txfs_dablk_t\tdead_blkno,\n\tstruct xfs_buf\t*dead_buf)\n{\n\txfs_inode_t *dp;\n\tint done, error, w, count;\n\txfs_trans_t *tp;\n\n\ttrace_xfs_da_shrink_inode(args);\n\n\tdp = args->dp;\n\tw = args->whichfork;\n\ttp = args->trans;\n\tcount = args->geo->fsbcount;\n\tfor (;;) {\n\t\t/*\n\t\t * Remove extents.  If we get ENOSPC for a dir we have to move\n\t\t * the last block to the place we want to kill.\n\t\t */\n\t\terror = xfs_bunmapi(tp, dp, dead_blkno, count,\n\t\t\t\t    xfs_bmapi_aflag(w)|XFS_BMAPI_METADATA,\n\t\t\t\t    0, args->firstblock, args->flist, &done);\n\t\tif (error == -ENOSPC) {\n\t\t\tif (w != XFS_DATA_FORK)\n\t\t\t\tbreak;\n\t\t\terror = xfs_da3_swap_lastblock(args, &dead_blkno,\n\t\t\t\t\t\t      &dead_buf);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\txfs_trans_binval(tp, dead_buf);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_log_header",
          "args": [
            "args",
            "dbp"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_log_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "661-677",
          "snippet": "void\nxfs_dir2_data_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n#ifdef DEBUG\n\tstruct xfs_dir2_data_hdr *hdr = bp->b_addr;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n#endif\n\n\txfs_trans_log_buf(args->trans, bp, 0,\n\t\t\t  args->dp->d_ops->data_entry_offset - 1);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dir2_data_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n#ifdef DEBUG\n\tstruct xfs_dir2_data_hdr *hdr = bp->b_addr;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n#endif\n\n\txfs_trans_log_buf(args->trans, bp, 0,\n\t\t\t  args->dp->d_ops->data_entry_offset - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_freescan",
          "args": [
            "dp",
            "hdr",
            "&needlog"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_freescan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "500-559",
          "snippet": "void\nxfs_dir2_data_freescan(\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_dir2_data_hdr *hdr,\n\tint\t\t\t*loghead)\n{\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* active data entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused data entry */\n\tstruct xfs_dir2_data_free *bf;\n\tchar\t\t\t*endp;\t\t/* end of block's data */\n\tchar\t\t\t*p;\t\t/* current entry pointer */\n\tstruct xfs_da_geometry\t*geo = dp->i_mount->m_dir_geo;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\t/*\n\t * Start by clearing the table.\n\t */\n\tbf = dp->d_ops->data_bestfree_p(hdr);\n\tmemset(bf, 0, sizeof(*bf) * XFS_DIR2_DATA_FD_COUNT);\n\t*loghead = 1;\n\t/*\n\t * Set up pointers.\n\t */\n\tp = (char *)dp->d_ops->data_entry_p(hdr);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tendp = (char *)xfs_dir2_block_leaf_p(btp);\n\t} else\n\t\tendp = (char *)hdr + geo->blksize;\n\t/*\n\t * Loop over the block's entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's a free entry, insert it.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tASSERT((char *)dup - (char *)hdr ==\n\t\t\t       be16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)));\n\t\t\txfs_dir2_data_freeinsert(hdr, bf, dup, loghead);\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t}\n\t\t/*\n\t\t * For active entries, check their tags and skip them.\n\t\t */\n\t\telse {\n\t\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\t\tASSERT((char *)dep - (char *)hdr ==\n\t\t\t       be16_to_cpu(*dp->d_ops->data_entry_tag_p(dep)));\n\t\t\tp += dp->d_ops->data_entsize(dep->namelen);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dir2_data_freescan(\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_dir2_data_hdr *hdr,\n\tint\t\t\t*loghead)\n{\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* active data entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused data entry */\n\tstruct xfs_dir2_data_free *bf;\n\tchar\t\t\t*endp;\t\t/* end of block's data */\n\tchar\t\t\t*p;\t\t/* current entry pointer */\n\tstruct xfs_da_geometry\t*geo = dp->i_mount->m_dir_geo;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\t/*\n\t * Start by clearing the table.\n\t */\n\tbf = dp->d_ops->data_bestfree_p(hdr);\n\tmemset(bf, 0, sizeof(*bf) * XFS_DIR2_DATA_FD_COUNT);\n\t*loghead = 1;\n\t/*\n\t * Set up pointers.\n\t */\n\tp = (char *)dp->d_ops->data_entry_p(hdr);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tendp = (char *)xfs_dir2_block_leaf_p(btp);\n\t} else\n\t\tendp = (char *)hdr + geo->blksize;\n\t/*\n\t * Loop over the block's entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's a free entry, insert it.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tASSERT((char *)dup - (char *)hdr ==\n\t\t\t       be16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)));\n\t\t\txfs_dir2_data_freeinsert(hdr, bf, dup, loghead);\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t}\n\t\t/*\n\t\t * For active entries, check their tags and skip them.\n\t\t */\n\t\telse {\n\t\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\t\tASSERT((char *)dep - (char *)hdr ==\n\t\t\t       be16_to_cpu(*dp->d_ops->data_entry_tag_p(dep)));\n\t\t\tp += dp->d_ops->data_entsize(dep->namelen);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_log_leaf",
          "args": [
            "tp",
            "dbp",
            "0",
            "be32_to_cpu(btp->count) - 1"
          ],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_log_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
          "lines": "567-582",
          "snippet": "static void\nxfs_dir2_block_log_leaf(\n\txfs_trans_t\t\t*tp,\t\t/* transaction structure */\n\tstruct xfs_buf\t\t*bp,\t\t/* block buffer */\n\tint\t\t\tfirst,\t\t/* index of first logged leaf */\n\tint\t\t\tlast)\t\t/* index of last logged leaf */\n{\n\txfs_dir2_data_hdr_t\t*hdr = bp->b_addr;\n\txfs_dir2_leaf_entry_t\t*blp;\n\txfs_dir2_block_tail_t\t*btp;\n\n\tbtp = xfs_dir2_block_tail_p(tp->t_mountp->m_dir_geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\txfs_trans_log_buf(tp, bp, (uint)((char *)&blp[first] - (char *)hdr),\n\t\t(uint)((char *)&blp[last + 1] - (char *)hdr - 1));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir2_block_log_leaf(xfs_trans_t *tp, struct xfs_buf *bp,\n\t\t\t\t    int first, int last);",
            "static void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_block_log_leaf(xfs_trans_t *tp, struct xfs_buf *bp,\n\t\t\t\t    int first, int last);\nstatic void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);\n\nstatic void\nxfs_dir2_block_log_leaf(\n\txfs_trans_t\t\t*tp,\t\t/* transaction structure */\n\tstruct xfs_buf\t\t*bp,\t\t/* block buffer */\n\tint\t\t\tfirst,\t\t/* index of first logged leaf */\n\tint\t\t\tlast)\t\t/* index of last logged leaf */\n{\n\txfs_dir2_data_hdr_t\t*hdr = bp->b_addr;\n\txfs_dir2_leaf_entry_t\t*blp;\n\txfs_dir2_block_tail_t\t*btp;\n\n\tbtp = xfs_dir2_block_tail_p(tp->t_mountp->m_dir_geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\txfs_trans_log_buf(tp, bp, (uint)((char *)&blp[first] - (char *)hdr),\n\t\t(uint)((char *)&blp[last + 1] - (char *)hdr - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btp->count"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "to == be32_to_cpu(btp->count)"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btp->count"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_NULL_DATAPTR"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_leaf_p",
          "args": [
            "btp"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_leaf_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "601-605",
          "snippet": "static inline struct xfs_dir2_leaf_entry *\nxfs_dir2_block_leaf_p(struct xfs_dir2_block_tail *btp)\n{\n\treturn ((struct xfs_dir2_leaf_entry *)btp) - be32_to_cpu(btp->count);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_leaf_entry *\nxfs_dir2_block_leaf_p(struct xfs_dir2_block_tail *btp)\n{\n\treturn ((struct xfs_dir2_leaf_entry *)btp) - be32_to_cpu(btp->count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_log_tail",
          "args": [
            "tp",
            "dbp"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_log_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
          "lines": "587-598",
          "snippet": "static void\nxfs_dir2_block_log_tail(\n\txfs_trans_t\t\t*tp,\t\t/* transaction structure */\n\tstruct xfs_buf\t\t*bp)\t\t/* block buffer */\n{\n\txfs_dir2_data_hdr_t\t*hdr = bp->b_addr;\n\txfs_dir2_block_tail_t\t*btp;\n\n\tbtp = xfs_dir2_block_tail_p(tp->t_mountp->m_dir_geo, hdr);\n\txfs_trans_log_buf(tp, bp, (uint)((char *)btp - (char *)hdr),\n\t\t(uint)((char *)(btp + 1) - (char *)hdr - 1));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);\n\nstatic void\nxfs_dir2_block_log_tail(\n\txfs_trans_t\t\t*tp,\t\t/* transaction structure */\n\tstruct xfs_buf\t\t*bp)\t\t/* block buffer */\n{\n\txfs_dir2_data_hdr_t\t*hdr = bp->b_addr;\n\txfs_dir2_block_tail_t\t*btp;\n\n\tbtp = xfs_dir2_block_tail_p(tp->t_mountp->m_dir_geo, hdr);\n\txfs_trans_log_buf(tp, bp, (uint)((char *)btp - (char *)hdr),\n\t\t(uint)((char *)(btp + 1) - (char *)hdr - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "leafhdr.count - leafhdr.stale"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_tail_p",
          "args": [
            "args->geo",
            "hdr"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_tail_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "305-310",
          "snippet": "static inline struct xfs_dir2_block_tail *\nxfs_dir2_block_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_data_hdr *hdr)\n{\n\treturn ((struct xfs_dir2_block_tail *)\n\t\t((char *)hdr + geo->blksize)) - 1;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_block_tail *\nxfs_dir2_block_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_data_hdr *hdr)\n{\n\treturn ((struct xfs_dir2_block_tail *)\n\t\t((char *)hdr + geo->blksize)) - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_use_free",
          "args": [
            "args",
            "dbp",
            "dup",
            "args->geo->blksize - size",
            "size",
            "&needlog",
            "&needscan"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_use_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "899-1048",
          "snippet": "void\nxfs_dir2_data_use_free(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_unused_t\t*dup,\t\t/* unused entry */\n\txfs_dir2_data_aoff_t\toffset,\t\t/* starting offset to use */\n\txfs_dir2_data_aoff_t\tlen,\t\t/* length to use */\n\tint\t\t\t*needlogp,\t/* out: need to log header */\n\tint\t\t\t*needscanp)\t/* out: need regen bestfree */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree pointer */\n\tint\t\t\tmatchback;\t/* matches end of freespace */\n\tint\t\t\tmatchfront;\t/* matches start of freespace */\n\tint\t\t\tneedscan;\t/* need to regen bestfree */\n\txfs_dir2_data_unused_t\t*newdup;\t/* new unused entry */\n\txfs_dir2_data_unused_t\t*newdup2;\t/* another new unused entry */\n\tint\t\t\toldlen;\t\t/* old unused entry's length */\n\tstruct xfs_dir2_data_free *bf;\n\n\thdr = bp->b_addr;\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\tASSERT(be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG);\n\tASSERT(offset >= (char *)dup - (char *)hdr);\n\tASSERT(offset + len <= (char *)dup + be16_to_cpu(dup->length) - (char *)hdr);\n\tASSERT((char *)dup - (char *)hdr == be16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)));\n\t/*\n\t * Look up the entry in the bestfree table.\n\t */\n\toldlen = be16_to_cpu(dup->length);\n\tbf = args->dp->d_ops->data_bestfree_p(hdr);\n\tdfp = xfs_dir2_data_freefind(hdr, bf, dup);\n\tASSERT(dfp || oldlen <= be16_to_cpu(bf[2].length));\n\t/*\n\t * Check for alignment with front and back of the entry.\n\t */\n\tmatchfront = (char *)dup - (char *)hdr == offset;\n\tmatchback = (char *)dup + oldlen - (char *)hdr == offset + len;\n\tASSERT(*needscanp == 0);\n\tneedscan = 0;\n\t/*\n\t * If we matched it exactly we just need to get rid of it from\n\t * the bestfree table.\n\t */\n\tif (matchfront && matchback) {\n\t\tif (dfp) {\n\t\t\tneedscan = (bf[2].offset != 0);\n\t\t\tif (!needscan)\n\t\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp,\n\t\t\t\t\t\t\t needlogp);\n\t\t}\n\t}\n\t/*\n\t * We match the first part of the entry.\n\t * Make a new entry with the remaining freespace.\n\t */\n\telse if (matchfront) {\n\t\tnewdup = (xfs_dir2_data_unused_t *)((char *)hdr + offset + len);\n\t\tnewdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup->length = cpu_to_be16(oldlen - len);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\t/*\n\t\t * If it was in the table, remove it and add the new one.\n\t\t */\n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\tdfp = xfs_dir2_data_freeinsert(hdr, bf, newdup,\n\t\t\t\t\t\t       needlogp);\n\t\t\tASSERT(dfp != NULL);\n\t\t\tASSERT(dfp->length == newdup->length);\n\t\t\tASSERT(be16_to_cpu(dfp->offset) == (char *)newdup - (char *)hdr);\n\t\t\t/*\n\t\t\t * If we got inserted at the last slot,\n\t\t\t * that means we don't know if there was a better\n\t\t\t * choice for the last slot, or not.  Rescan.\n\t\t\t */\n\t\t\tneedscan = dfp == &bf[2];\n\t\t}\n\t}\n\t/*\n\t * We match the last part of the entry.\n\t * Trim the allocated space off the tail of the entry.\n\t */\n\telse if (matchback) {\n\t\tnewdup = dup;\n\t\tnewdup->length = cpu_to_be16(((char *)hdr + offset) - (char *)newdup);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\t/*\n\t\t * If it was in the table, remove it and add the new one.\n\t\t */\n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\tdfp = xfs_dir2_data_freeinsert(hdr, bf, newdup,\n\t\t\t\t\t\t       needlogp);\n\t\t\tASSERT(dfp != NULL);\n\t\t\tASSERT(dfp->length == newdup->length);\n\t\t\tASSERT(be16_to_cpu(dfp->offset) == (char *)newdup - (char *)hdr);\n\t\t\t/*\n\t\t\t * If we got inserted at the last slot,\n\t\t\t * that means we don't know if there was a better\n\t\t\t * choice for the last slot, or not.  Rescan.\n\t\t\t */\n\t\t\tneedscan = dfp == &bf[2];\n\t\t}\n\t}\n\t/*\n\t * Poking out the middle of an entry.\n\t * Make two new entries.\n\t */\n\telse {\n\t\tnewdup = dup;\n\t\tnewdup->length = cpu_to_be16(((char *)hdr + offset) - (char *)newdup);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\tnewdup2 = (xfs_dir2_data_unused_t *)((char *)hdr + offset + len);\n\t\tnewdup2->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup2->length = cpu_to_be16(oldlen - len - be16_to_cpu(newdup->length));\n\t\t*xfs_dir2_data_unused_tag_p(newdup2) =\n\t\t\tcpu_to_be16((char *)newdup2 - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup2);\n\t\t/*\n\t\t * If the old entry was in the table, we need to scan\n\t\t * if the 3rd entry was valid, since these entries\n\t\t * are smaller than the old one.\n\t\t * If we don't need to scan that means there were 1 or 2\n\t\t * entries in the table, and removing the old and adding\n\t\t * the 2 new will work.\n\t\t */\n\t\tif (dfp) {\n\t\t\tneedscan = (bf[2].length != 0);\n\t\t\tif (!needscan) {\n\t\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp,\n\t\t\t\t\t\t\t needlogp);\n\t\t\t\txfs_dir2_data_freeinsert(hdr, bf, newdup,\n\t\t\t\t\t\t\t needlogp);\n\t\t\t\txfs_dir2_data_freeinsert(hdr, bf, newdup2,\n\t\t\t\t\t\t\t needlogp);\n\t\t\t}\n\t\t}\n\t}\n\t*needscanp = needscan;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dir2_data_use_free(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_unused_t\t*dup,\t\t/* unused entry */\n\txfs_dir2_data_aoff_t\toffset,\t\t/* starting offset to use */\n\txfs_dir2_data_aoff_t\tlen,\t\t/* length to use */\n\tint\t\t\t*needlogp,\t/* out: need to log header */\n\tint\t\t\t*needscanp)\t/* out: need regen bestfree */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree pointer */\n\tint\t\t\tmatchback;\t/* matches end of freespace */\n\tint\t\t\tmatchfront;\t/* matches start of freespace */\n\tint\t\t\tneedscan;\t/* need to regen bestfree */\n\txfs_dir2_data_unused_t\t*newdup;\t/* new unused entry */\n\txfs_dir2_data_unused_t\t*newdup2;\t/* another new unused entry */\n\tint\t\t\toldlen;\t\t/* old unused entry's length */\n\tstruct xfs_dir2_data_free *bf;\n\n\thdr = bp->b_addr;\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\tASSERT(be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG);\n\tASSERT(offset >= (char *)dup - (char *)hdr);\n\tASSERT(offset + len <= (char *)dup + be16_to_cpu(dup->length) - (char *)hdr);\n\tASSERT((char *)dup - (char *)hdr == be16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)));\n\t/*\n\t * Look up the entry in the bestfree table.\n\t */\n\toldlen = be16_to_cpu(dup->length);\n\tbf = args->dp->d_ops->data_bestfree_p(hdr);\n\tdfp = xfs_dir2_data_freefind(hdr, bf, dup);\n\tASSERT(dfp || oldlen <= be16_to_cpu(bf[2].length));\n\t/*\n\t * Check for alignment with front and back of the entry.\n\t */\n\tmatchfront = (char *)dup - (char *)hdr == offset;\n\tmatchback = (char *)dup + oldlen - (char *)hdr == offset + len;\n\tASSERT(*needscanp == 0);\n\tneedscan = 0;\n\t/*\n\t * If we matched it exactly we just need to get rid of it from\n\t * the bestfree table.\n\t */\n\tif (matchfront && matchback) {\n\t\tif (dfp) {\n\t\t\tneedscan = (bf[2].offset != 0);\n\t\t\tif (!needscan)\n\t\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp,\n\t\t\t\t\t\t\t needlogp);\n\t\t}\n\t}\n\t/*\n\t * We match the first part of the entry.\n\t * Make a new entry with the remaining freespace.\n\t */\n\telse if (matchfront) {\n\t\tnewdup = (xfs_dir2_data_unused_t *)((char *)hdr + offset + len);\n\t\tnewdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup->length = cpu_to_be16(oldlen - len);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\t/*\n\t\t * If it was in the table, remove it and add the new one.\n\t\t */\n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\tdfp = xfs_dir2_data_freeinsert(hdr, bf, newdup,\n\t\t\t\t\t\t       needlogp);\n\t\t\tASSERT(dfp != NULL);\n\t\t\tASSERT(dfp->length == newdup->length);\n\t\t\tASSERT(be16_to_cpu(dfp->offset) == (char *)newdup - (char *)hdr);\n\t\t\t/*\n\t\t\t * If we got inserted at the last slot,\n\t\t\t * that means we don't know if there was a better\n\t\t\t * choice for the last slot, or not.  Rescan.\n\t\t\t */\n\t\t\tneedscan = dfp == &bf[2];\n\t\t}\n\t}\n\t/*\n\t * We match the last part of the entry.\n\t * Trim the allocated space off the tail of the entry.\n\t */\n\telse if (matchback) {\n\t\tnewdup = dup;\n\t\tnewdup->length = cpu_to_be16(((char *)hdr + offset) - (char *)newdup);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\t/*\n\t\t * If it was in the table, remove it and add the new one.\n\t\t */\n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\tdfp = xfs_dir2_data_freeinsert(hdr, bf, newdup,\n\t\t\t\t\t\t       needlogp);\n\t\t\tASSERT(dfp != NULL);\n\t\t\tASSERT(dfp->length == newdup->length);\n\t\t\tASSERT(be16_to_cpu(dfp->offset) == (char *)newdup - (char *)hdr);\n\t\t\t/*\n\t\t\t * If we got inserted at the last slot,\n\t\t\t * that means we don't know if there was a better\n\t\t\t * choice for the last slot, or not.  Rescan.\n\t\t\t */\n\t\t\tneedscan = dfp == &bf[2];\n\t\t}\n\t}\n\t/*\n\t * Poking out the middle of an entry.\n\t * Make two new entries.\n\t */\n\telse {\n\t\tnewdup = dup;\n\t\tnewdup->length = cpu_to_be16(((char *)hdr + offset) - (char *)newdup);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\tnewdup2 = (xfs_dir2_data_unused_t *)((char *)hdr + offset + len);\n\t\tnewdup2->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup2->length = cpu_to_be16(oldlen - len - be16_to_cpu(newdup->length));\n\t\t*xfs_dir2_data_unused_tag_p(newdup2) =\n\t\t\tcpu_to_be16((char *)newdup2 - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup2);\n\t\t/*\n\t\t * If the old entry was in the table, we need to scan\n\t\t * if the 3rd entry was valid, since these entries\n\t\t * are smaller than the old one.\n\t\t * If we don't need to scan that means there were 1 or 2\n\t\t * entries in the table, and removing the old and adding\n\t\t * the 2 new will work.\n\t\t */\n\t\tif (dfp) {\n\t\t\tneedscan = (bf[2].length != 0);\n\t\t\tif (!needscan) {\n\t\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp,\n\t\t\t\t\t\t\t needlogp);\n\t\t\t\txfs_dir2_data_freeinsert(hdr, bf, newdup,\n\t\t\t\t\t\t\t needlogp);\n\t\t\t\txfs_dir2_data_freeinsert(hdr, bf, newdup2,\n\t\t\t\t\t\t\t needlogp);\n\t\t\t}\n\t\t}\n\t}\n\t*needscanp = needscan;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir3_block_init",
          "args": [
            "mp",
            "tp",
            "dbp",
            "dp"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_block_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
          "lines": "143-165",
          "snippet": "static void\nxfs_dir3_block_init(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_inode\t*dp)\n{\n\tstruct xfs_dir3_blk_hdr *hdr3 = bp->b_addr;\n\n\tbp->b_ops = &xfs_dir3_block_buf_ops;\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DIR_BLOCK_BUF);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tmemset(hdr3, 0, sizeof(*hdr3));\n\t\thdr3->magic = cpu_to_be32(XFS_DIR3_BLOCK_MAGIC);\n\t\thdr3->blkno = cpu_to_be64(bp->b_bn);\n\t\thdr3->owner = cpu_to_be64(dp->i_ino);\n\t\tuuid_copy(&hdr3->uuid, &mp->m_sb.sb_uuid);\n\t\treturn;\n\n\t}\n\thdr3->magic = cpu_to_be32(XFS_DIR2_BLOCK_MAGIC);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);",
            "const struct xfs_buf_ops xfs_dir3_block_buf_ops = {\n\t.verify_read = xfs_dir3_block_read_verify,\n\t.verify_write = xfs_dir3_block_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);\nconst struct xfs_buf_ops xfs_dir3_block_buf_ops = {\n\t.verify_read = xfs_dir3_block_read_verify,\n\t.verify_write = xfs_dir3_block_write_verify,\n};\n\nstatic void\nxfs_dir3_block_init(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_inode\t*dp)\n{\n\tstruct xfs_dir3_blk_hdr *hdr3 = bp->b_addr;\n\n\tbp->b_ops = &xfs_dir3_block_buf_ops;\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DIR_BLOCK_BUF);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tmemset(hdr3, 0, sizeof(*hdr3));\n\t\thdr3->magic = cpu_to_be32(XFS_DIR3_BLOCK_MAGIC);\n\t\thdr3->blkno = cpu_to_be64(bp->b_bn);\n\t\thdr3->owner = cpu_to_be64(dp->i_ino);\n\t\tuuid_copy(&hdr3->uuid, &mp->m_sb.sb_uuid);\n\t\treturn;\n\n\t}\n\thdr3->magic = cpu_to_be32(XFS_DIR2_BLOCK_MAGIC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dup->length"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dup->freetag"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "*tagp"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC)"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR3_DATA_MAGIC"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_DATA_MAGIC"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_data_read",
          "args": [
            "tp",
            "dp",
            "args->geo->datablk",
            "-1",
            "&dbp"
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_data_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "313-328",
          "snippet": "int\nxfs_dir3_data_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmapped_bno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mapped_bno, bpp,\n\t\t\t\tXFS_DATA_FORK, &xfs_dir3_data_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_DIR_DATA_BUF);\n\treturn err;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_dir3_data_buf_ops = {\n\t.verify_read = xfs_dir3_data_read_verify,\n\t.verify_write = xfs_dir3_data_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_dir3_data_buf_ops = {\n\t.verify_read = xfs_dir3_data_read_verify,\n\t.verify_write = xfs_dir3_data_write_verify,\n};\n\nint\nxfs_dir3_data_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmapped_bno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mapped_bno, bpp,\n\t\t\t\tXFS_DATA_FORK, &xfs_dir3_data_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_DIR_DATA_BUF);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leaf_trim_data",
          "args": [
            "args",
            "lbp",
            "(xfs_dir2_db_t)(be32_to_cpu(ltp->bestcount) - 1)"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leaf_trim_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "1588-1645",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_leaf_trim_data(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tstruct xfs_buf\t\t*lbp,\t\t/* leaf buffer */\n\txfs_dir2_db_t\t\tdb)\t\t/* data block number */\n{\n\t__be16\t\t\t*bestsp;\t/* leaf bests table */\n\tstruct xfs_buf\t\t*dbp;\t\t/* data block buffer */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf tail structure */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\n\tdp = args->dp;\n\ttp = args->trans;\n\t/*\n\t * Read the offending data block.  We need its buffer.\n\t */\n\terror = xfs_dir3_data_read(tp, dp, xfs_dir2_db_to_da(args->geo, db),\n\t\t\t\t   -1, &dbp);\n\tif (error)\n\t\treturn error;\n\n\tleaf = lbp->b_addr;\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\n#ifdef DEBUG\n{\n\tstruct xfs_dir2_data_hdr *hdr = dbp->b_addr;\n\tstruct xfs_dir2_data_free *bf = dp->d_ops->data_bestfree_p(hdr);\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC));\n\tASSERT(be16_to_cpu(bf[0].length) ==\n\t       args->geo->blksize - dp->d_ops->data_entry_offset);\n\tASSERT(db == be32_to_cpu(ltp->bestcount) - 1);\n}\n#endif\n\n\t/*\n\t * Get rid of the data block.\n\t */\n\tif ((error = xfs_dir2_shrink_inode(args, db, dbp))) {\n\t\tASSERT(error != -ENOSPC);\n\t\txfs_trans_brelse(tp, dbp);\n\t\treturn error;\n\t}\n\t/*\n\t * Eliminate the last bests entry from the table.\n\t */\n\tbestsp = xfs_dir2_leaf_bests_p(ltp);\n\tbe32_add_cpu(&ltp->bestcount, -1);\n\tmemmove(&bestsp[1], &bestsp[0], be32_to_cpu(ltp->bestcount) * sizeof(*bestsp));\n\txfs_dir3_leaf_log_tail(args, lbp);\n\txfs_dir3_leaf_log_bests(args, lbp, 0, be32_to_cpu(ltp->bestcount) - 1);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_leaf_trim_data(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tstruct xfs_buf\t\t*lbp,\t\t/* leaf buffer */\n\txfs_dir2_db_t\t\tdb)\t\t/* data block number */\n{\n\t__be16\t\t\t*bestsp;\t/* leaf bests table */\n\tstruct xfs_buf\t\t*dbp;\t\t/* data block buffer */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf tail structure */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\n\tdp = args->dp;\n\ttp = args->trans;\n\t/*\n\t * Read the offending data block.  We need its buffer.\n\t */\n\terror = xfs_dir3_data_read(tp, dp, xfs_dir2_db_to_da(args->geo, db),\n\t\t\t\t   -1, &dbp);\n\tif (error)\n\t\treturn error;\n\n\tleaf = lbp->b_addr;\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\n#ifdef DEBUG\n{\n\tstruct xfs_dir2_data_hdr *hdr = dbp->b_addr;\n\tstruct xfs_dir2_data_free *bf = dp->d_ops->data_bestfree_p(hdr);\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC));\n\tASSERT(be16_to_cpu(bf[0].length) ==\n\t       args->geo->blksize - dp->d_ops->data_entry_offset);\n\tASSERT(db == be32_to_cpu(ltp->bestcount) - 1);\n}\n#endif\n\n\t/*\n\t * Get rid of the data block.\n\t */\n\tif ((error = xfs_dir2_shrink_inode(args, db, dbp))) {\n\t\tASSERT(error != -ENOSPC);\n\t\txfs_trans_brelse(tp, dbp);\n\t\treturn error;\n\t}\n\t/*\n\t * Eliminate the last bests entry from the table.\n\t */\n\tbestsp = xfs_dir2_leaf_bests_p(ltp);\n\tbe32_add_cpu(&ltp->bestcount, -1);\n\tmemmove(&bestsp[1], &bestsp[0], be32_to_cpu(ltp->bestcount) * sizeof(*bestsp));\n\txfs_dir3_leaf_log_tail(args, lbp);\n\txfs_dir3_leaf_log_bests(args, lbp, 0, be32_to_cpu(ltp->bestcount) - 1);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "be32_to_cpu(ltp->bestcount) - 1"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ltp->bestcount"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "bestsp[be32_to_cpu(ltp->bestcount) - 1]"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ltp->bestcount"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leaf_bests_p",
          "args": [
            "ltp"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leaf_bests_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "509-513",
          "snippet": "static inline __be16 *\nxfs_dir2_leaf_bests_p(struct xfs_dir2_leaf_tail *ltp)\n{\n\treturn (__be16 *)ltp - be32_to_cpu(ltp->bestcount);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __be16 *\nxfs_dir2_leaf_bests_p(struct xfs_dir2_leaf_tail *ltp)\n{\n\treturn (__be16 *)ltp - be32_to_cpu(ltp->bestcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "leafhdr.magic == XFS_DIR2_LEAF1_MAGIC ||\n\t       leafhdr.magic == XFS_DIR3_LEAF1_MAGIC"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leaf_tail_p",
          "args": [
            "args->geo",
            "leaf"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leaf_tail_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "312-318",
          "snippet": "static inline struct xfs_dir2_leaf_tail *\nxfs_dir2_leaf_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_leaf *lp)\n{\n\treturn (struct xfs_dir2_leaf_tail *)\n\t\t((char *)lp + geo->blksize -\n\t\t  sizeof(struct xfs_dir2_leaf_tail));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_leaf_tail *\nxfs_dir2_leaf_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_leaf *lp)\n{\n\treturn (struct xfs_dir2_leaf_tail *)\n\t\t((char *)lp + geo->blksize -\n\t\t  sizeof(struct xfs_dir2_leaf_tail));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_ents_p",
          "args": [
            "leaf"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_hdr_from_disk",
          "args": [
            "&leafhdr",
            "leaf"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_dir2_leaf_to_block",
          "args": [
            "args"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_block_log_leaf(xfs_trans_t *tp, struct xfs_buf *bp,\n\t\t\t\t    int first, int last);\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_leaf_to_block(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tstruct xfs_buf\t\t*lbp,\t\t/* leaf buffer */\n\tstruct xfs_buf\t\t*dbp)\t\t/* data buffer */\n{\n\t__be16\t\t\t*bestsp;\t/* leaf bests table */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused data entry */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tfrom;\t\t/* leaf from index */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf tail structure */\n\txfs_mount_t\t\t*mp;\t\t/* file system mount point */\n\tint\t\t\tneedlog;\t/* need to log data header */\n\tint\t\t\tneedscan;\t/* need to scan for bestfree */\n\txfs_dir2_sf_hdr_t\tsfh;\t\t/* shortform header */\n\tint\t\t\tsize;\t\t/* bytes used */\n\t__be16\t\t\t*tagp;\t\t/* end of entry (tag) */\n\tint\t\t\tto;\t\t/* block/leaf to index */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\ttrace_xfs_dir2_leaf_to_block(args);\n\n\tdp = args->dp;\n\ttp = args->trans;\n\tmp = dp->i_mount;\n\tleaf = lbp->b_addr;\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\n\tASSERT(leafhdr.magic == XFS_DIR2_LEAF1_MAGIC ||\n\t       leafhdr.magic == XFS_DIR3_LEAF1_MAGIC);\n\t/*\n\t * If there are data blocks other than the first one, take this\n\t * opportunity to remove trailing empty data blocks that may have\n\t * been left behind during no-space-reservation operations.\n\t * These will show up in the leaf bests table.\n\t */\n\twhile (dp->i_d.di_size > args->geo->blksize) {\n\t\tint hdrsz;\n\n\t\thdrsz = dp->d_ops->data_entry_offset;\n\t\tbestsp = xfs_dir2_leaf_bests_p(ltp);\n\t\tif (be16_to_cpu(bestsp[be32_to_cpu(ltp->bestcount) - 1]) ==\n\t\t\t\t\t    args->geo->blksize - hdrsz) {\n\t\t\tif ((error =\n\t\t\t    xfs_dir2_leaf_trim_data(args, lbp,\n\t\t\t\t    (xfs_dir2_db_t)(be32_to_cpu(ltp->bestcount) - 1))))\n\t\t\t\treturn error;\n\t\t} else\n\t\t\treturn 0;\n\t}\n\t/*\n\t * Read the data block if we don't already have it, give up if it fails.\n\t */\n\tif (!dbp) {\n\t\terror = xfs_dir3_data_read(tp, dp, args->geo->datablk, -1, &dbp);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\thdr = dbp->b_addr;\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC));\n\n\t/*\n\t * Size of the \"leaf\" area in the block.\n\t */\n\tsize = (uint)sizeof(xfs_dir2_block_tail_t) +\n\t       (uint)sizeof(*lep) * (leafhdr.count - leafhdr.stale);\n\t/*\n\t * Look at the last data entry.\n\t */\n\ttagp = (__be16 *)((char *)hdr + args->geo->blksize) - 1;\n\tdup = (xfs_dir2_data_unused_t *)((char *)hdr + be16_to_cpu(*tagp));\n\t/*\n\t * If it's not free or is too short we can't do it.\n\t */\n\tif (be16_to_cpu(dup->freetag) != XFS_DIR2_DATA_FREE_TAG ||\n\t    be16_to_cpu(dup->length) < size)\n\t\treturn 0;\n\n\t/*\n\t * Start converting it to block form.\n\t */\n\txfs_dir3_block_init(mp, tp, dbp, dp);\n\n\tneedlog = 1;\n\tneedscan = 0;\n\t/*\n\t * Use up the space at the end of the block (blp/btp).\n\t */\n\txfs_dir2_data_use_free(args, dbp, dup, args->geo->blksize - size, size,\n\t\t&needlog, &needscan);\n\t/*\n\t * Initialize the block tail.\n\t */\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tbtp->count = cpu_to_be32(leafhdr.count - leafhdr.stale);\n\tbtp->stale = 0;\n\txfs_dir2_block_log_tail(tp, dbp);\n\t/*\n\t * Initialize the block leaf area.  We compact out stale entries.\n\t */\n\tlep = xfs_dir2_block_leaf_p(btp);\n\tfor (from = to = 0; from < leafhdr.count; from++) {\n\t\tif (ents[from].address == cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\tcontinue;\n\t\tlep[to++] = ents[from];\n\t}\n\tASSERT(to == be32_to_cpu(btp->count));\n\txfs_dir2_block_log_leaf(tp, dbp, 0, be32_to_cpu(btp->count) - 1);\n\t/*\n\t * Scan the bestfree if we need it and log the data block header.\n\t */\n\tif (needscan)\n\t\txfs_dir2_data_freescan(dp, hdr, &needlog);\n\tif (needlog)\n\t\txfs_dir2_data_log_header(args, dbp);\n\t/*\n\t * Pitch the old leaf block.\n\t */\n\terror = xfs_da_shrink_inode(args, args->geo->leafblk, lbp);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Now see if the resulting block can be shrunken to shortform.\n\t */\n\tsize = xfs_dir2_block_sfsize(dp, hdr, &sfh);\n\tif (size > XFS_IFORK_DSIZE(dp))\n\t\treturn 0;\n\n\treturn xfs_dir2_block_to_sf(args, dbp, size, &sfh);\n}"
  },
  {
    "function_name": "xfs_dir2_block_sort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
    "lines": "880-892",
    "snippet": "static int\t\t\t\t\t/* sort order */\nxfs_dir2_block_sort(\n\tconst void\t\t\t*a,\t/* first leaf entry */\n\tconst void\t\t\t*b)\t/* second leaf entry */\n{\n\tconst xfs_dir2_leaf_entry_t\t*la;\t/* first leaf entry */\n\tconst xfs_dir2_leaf_entry_t\t*lb;\t/* second leaf entry */\n\n\tla = a;\n\tlb = b;\n\treturn be32_to_cpu(la->hashval) < be32_to_cpu(lb->hashval) ? -1 :\n\t\t(be32_to_cpu(la->hashval) > be32_to_cpu(lb->hashval) ? 1 : 0);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int xfs_dir2_block_sort(const void *a, const void *b);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "lb->hashval"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "la->hashval"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "lb->hashval"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "la->hashval"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int xfs_dir2_block_sort(const void *a, const void *b);\n\nstatic int\t\t\t\t\t/* sort order */\nxfs_dir2_block_sort(\n\tconst void\t\t\t*a,\t/* first leaf entry */\n\tconst void\t\t\t*b)\t/* second leaf entry */\n{\n\tconst xfs_dir2_leaf_entry_t\t*la;\t/* first leaf entry */\n\tconst xfs_dir2_leaf_entry_t\t*lb;\t/* second leaf entry */\n\n\tla = a;\n\tlb = b;\n\treturn be32_to_cpu(la->hashval) < be32_to_cpu(lb->hashval) ? -1 :\n\t\t(be32_to_cpu(la->hashval) > be32_to_cpu(lb->hashval) ? 1 : 0);\n}"
  },
  {
    "function_name": "xfs_dir2_block_replace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
    "lines": "834-875",
    "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_block_replace(\n\txfs_da_args_t\t\t*args)\t\t/* directory operation args */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* block leaf entries */\n\tstruct xfs_buf\t\t*bp;\t\t/* block buffer */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* block data entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore inode */\n\tint\t\t\tent;\t\t/* leaf entry index */\n\tint\t\t\terror;\t\t/* error return value */\n\n\ttrace_xfs_dir2_block_replace(args);\n\n\t/*\n\t * Lookup the entry in the directory.  Get buffer and entry index.\n\t * This will always succeed since the caller has already done a lookup.\n\t */\n\tif ((error = xfs_dir2_block_lookup_int(args, &bp, &ent))) {\n\t\treturn error;\n\t}\n\tdp = args->dp;\n\thdr = bp->b_addr;\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\t/*\n\t * Point to the data entry we need to change.\n\t */\n\tdep = (xfs_dir2_data_entry_t *)((char *)hdr +\n\t\t\txfs_dir2_dataptr_to_off(args->geo,\n\t\t\t\t\t\tbe32_to_cpu(blp[ent].address)));\n\tASSERT(be64_to_cpu(dep->inumber) != args->inumber);\n\t/*\n\t * Change the inode number to the new value.\n\t */\n\tdep->inumber = cpu_to_be64(args->inumber);\n\tdp->d_ops->data_put_ftype(dep, args->filetype);\n\txfs_dir2_data_log_entry(args, bp, dep);\n\txfs_dir3_data_check(dp, bp);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_dir3_data_check",
          "args": [
            "dp",
            "bp"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "__xfs_dir3_data_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "40-210",
          "snippet": "int\n__xfs_dir3_data_check(\n\tstruct xfs_inode\t*dp,\t\t/* incore inode pointer */\n\tstruct xfs_buf\t\t*bp)\t\t/* data block's buffer */\n{\n\txfs_dir2_dataptr_t\taddr;\t\t/* addr for leaf lookup */\n\txfs_dir2_data_free_t\t*bf;\t\t/* bestfree table */\n\txfs_dir2_block_tail_t\t*btp=NULL;\t/* block tail */\n\tint\t\t\tcount;\t\t/* count of entries found */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry */\n\tchar\t\t\t*endp;\t\t/* end of useful data */\n\tint\t\t\tfreeseen;\t/* mask of bestfrees seen */\n\txfs_dahash_t\t\thash;\t\t/* hash of current name */\n\tint\t\t\ti;\t\t/* leaf index */\n\tint\t\t\tlastfree;\t/* last entry was unused */\n\txfs_dir2_leaf_entry_t\t*lep=NULL;\t/* block leaf entries */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tchar\t\t\t*p;\t\t/* current data position */\n\tint\t\t\tstale;\t\t/* count of stale leaves */\n\tstruct xfs_name\t\tname;\n\tconst struct xfs_dir_ops *ops;\n\tstruct xfs_da_geometry\t*geo;\n\n\tmp = bp->b_target->bt_mount;\n\tgeo = mp->m_dir_geo;\n\n\t/*\n\t * We can be passed a null dp here from a verifier, so we need to go the\n\t * hard way to get them.\n\t */\n\tops = xfs_dir_get_ops(mp, dp);\n\n\thdr = bp->b_addr;\n\tp = (char *)ops->data_entry_p(hdr);\n\n\tswitch (hdr->magic) {\n\tcase cpu_to_be32(XFS_DIR3_BLOCK_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_BLOCK_MAGIC):\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tlep = xfs_dir2_block_leaf_p(btp);\n\t\tendp = (char *)lep;\n\n\t\t/*\n\t\t * The number of leaf entries is limited by the size of the\n\t\t * block and the amount of space used by the data entries.\n\t\t * We don't know how much space is used by the data entries yet,\n\t\t * so just ensure that the count falls somewhere inside the\n\t\t * block right now.\n\t\t */\n\t\tXFS_WANT_CORRUPTED_RETURN(be32_to_cpu(btp->count) <\n\t\t\t((char *)btp - p) / sizeof(struct xfs_dir2_leaf_entry));\n\t\tbreak;\n\tcase cpu_to_be32(XFS_DIR3_DATA_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_DATA_MAGIC):\n\t\tendp = (char *)hdr + geo->blksize;\n\t\tbreak;\n\tdefault:\n\t\tXFS_ERROR_REPORT(\"Bad Magic\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/*\n\t * Account for zero bestfree entries.\n\t */\n\tbf = ops->data_bestfree_p(hdr);\n\tcount = lastfree = freeseen = 0;\n\tif (!bf[0].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[0].offset);\n\t\tfreeseen |= 1 << 0;\n\t}\n\tif (!bf[1].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[1].offset);\n\t\tfreeseen |= 1 << 1;\n\t}\n\tif (!bf[2].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[2].offset);\n\t\tfreeseen |= 1 << 2;\n\t}\n\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[0].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[1].length));\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[1].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t/*\n\t * Loop over the data/unused entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's unused, look for the space in the bestfree table.\n\t\t * If we find it, account for that, else make sure it\n\t\t * doesn't need to be there.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tXFS_WANT_CORRUPTED_RETURN(lastfree == 0);\n\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tbe16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)) ==\n\t\t\t\t\t       (char *)dup - (char *)hdr);\n\t\t\tdfp = xfs_dir2_data_freefind(hdr, bf, dup);\n\t\t\tif (dfp) {\n\t\t\t\ti = (int)(dfp - bf);\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\t(freeseen & (1 << i)) == 0);\n\t\t\t\tfreeseen |= 1 << i;\n\t\t\t} else {\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe16_to_cpu(dup->length) <=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t\t\t}\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t\tlastfree = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * It's a real entry.  Validate the fields.\n\t\t * If this is a block directory then make sure it's\n\t\t * in the leaf section of the block.\n\t\t * The linear search is crude but this is DEBUG code.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\tXFS_WANT_CORRUPTED_RETURN(dep->namelen != 0);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t!xfs_dir_ino_validate(mp, be64_to_cpu(dep->inumber)));\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\tbe16_to_cpu(*ops->data_entry_tag_p(dep)) ==\n\t\t\t\t\t       (char *)dep - (char *)hdr);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tops->data_get_ftype(dep) < XFS_DIR3_FT_MAX);\n\t\tcount++;\n\t\tlastfree = 0;\n\t\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\t\taddr = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,\n\t\t\t\t\t\t(xfs_dir2_data_aoff_t)\n\t\t\t\t\t\t((char *)dep - (char *)hdr));\n\t\t\tname.name = dep->name;\n\t\t\tname.len = dep->namelen;\n\t\t\thash = mp->m_dirnameops->hashname(&name);\n\t\t\tfor (i = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\t\tif (be32_to_cpu(lep[i].address) == addr &&\n\t\t\t\t    be32_to_cpu(lep[i].hashval) == hash)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i < be32_to_cpu(btp->count));\n\t\t}\n\t\tp += ops->data_entsize(dep->namelen);\n\t}\n\t/*\n\t * Need to have seen all the entries and all the bestfree slots.\n\t */\n\tXFS_WANT_CORRUPTED_RETURN(freeseen == 7);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tfor (i = stale = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\tif (lep[i].address ==\n\t\t\t    cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\t\tstale++;\n\t\t\tif (i > 0)\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe32_to_cpu(lep[i].hashval) >=\n\t\t\t\t\t\tbe32_to_cpu(lep[i - 1].hashval));\n\t\t}\n\t\tXFS_WANT_CORRUPTED_RETURN(count ==\n\t\t\tbe32_to_cpu(btp->count) - be32_to_cpu(btp->stale));\n\t\tXFS_WANT_CORRUPTED_RETURN(stale == be32_to_cpu(btp->stale));\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\n__xfs_dir3_data_check(\n\tstruct xfs_inode\t*dp,\t\t/* incore inode pointer */\n\tstruct xfs_buf\t\t*bp)\t\t/* data block's buffer */\n{\n\txfs_dir2_dataptr_t\taddr;\t\t/* addr for leaf lookup */\n\txfs_dir2_data_free_t\t*bf;\t\t/* bestfree table */\n\txfs_dir2_block_tail_t\t*btp=NULL;\t/* block tail */\n\tint\t\t\tcount;\t\t/* count of entries found */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry */\n\tchar\t\t\t*endp;\t\t/* end of useful data */\n\tint\t\t\tfreeseen;\t/* mask of bestfrees seen */\n\txfs_dahash_t\t\thash;\t\t/* hash of current name */\n\tint\t\t\ti;\t\t/* leaf index */\n\tint\t\t\tlastfree;\t/* last entry was unused */\n\txfs_dir2_leaf_entry_t\t*lep=NULL;\t/* block leaf entries */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tchar\t\t\t*p;\t\t/* current data position */\n\tint\t\t\tstale;\t\t/* count of stale leaves */\n\tstruct xfs_name\t\tname;\n\tconst struct xfs_dir_ops *ops;\n\tstruct xfs_da_geometry\t*geo;\n\n\tmp = bp->b_target->bt_mount;\n\tgeo = mp->m_dir_geo;\n\n\t/*\n\t * We can be passed a null dp here from a verifier, so we need to go the\n\t * hard way to get them.\n\t */\n\tops = xfs_dir_get_ops(mp, dp);\n\n\thdr = bp->b_addr;\n\tp = (char *)ops->data_entry_p(hdr);\n\n\tswitch (hdr->magic) {\n\tcase cpu_to_be32(XFS_DIR3_BLOCK_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_BLOCK_MAGIC):\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tlep = xfs_dir2_block_leaf_p(btp);\n\t\tendp = (char *)lep;\n\n\t\t/*\n\t\t * The number of leaf entries is limited by the size of the\n\t\t * block and the amount of space used by the data entries.\n\t\t * We don't know how much space is used by the data entries yet,\n\t\t * so just ensure that the count falls somewhere inside the\n\t\t * block right now.\n\t\t */\n\t\tXFS_WANT_CORRUPTED_RETURN(be32_to_cpu(btp->count) <\n\t\t\t((char *)btp - p) / sizeof(struct xfs_dir2_leaf_entry));\n\t\tbreak;\n\tcase cpu_to_be32(XFS_DIR3_DATA_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_DATA_MAGIC):\n\t\tendp = (char *)hdr + geo->blksize;\n\t\tbreak;\n\tdefault:\n\t\tXFS_ERROR_REPORT(\"Bad Magic\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/*\n\t * Account for zero bestfree entries.\n\t */\n\tbf = ops->data_bestfree_p(hdr);\n\tcount = lastfree = freeseen = 0;\n\tif (!bf[0].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[0].offset);\n\t\tfreeseen |= 1 << 0;\n\t}\n\tif (!bf[1].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[1].offset);\n\t\tfreeseen |= 1 << 1;\n\t}\n\tif (!bf[2].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[2].offset);\n\t\tfreeseen |= 1 << 2;\n\t}\n\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[0].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[1].length));\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[1].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t/*\n\t * Loop over the data/unused entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's unused, look for the space in the bestfree table.\n\t\t * If we find it, account for that, else make sure it\n\t\t * doesn't need to be there.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tXFS_WANT_CORRUPTED_RETURN(lastfree == 0);\n\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tbe16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)) ==\n\t\t\t\t\t       (char *)dup - (char *)hdr);\n\t\t\tdfp = xfs_dir2_data_freefind(hdr, bf, dup);\n\t\t\tif (dfp) {\n\t\t\t\ti = (int)(dfp - bf);\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\t(freeseen & (1 << i)) == 0);\n\t\t\t\tfreeseen |= 1 << i;\n\t\t\t} else {\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe16_to_cpu(dup->length) <=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t\t\t}\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t\tlastfree = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * It's a real entry.  Validate the fields.\n\t\t * If this is a block directory then make sure it's\n\t\t * in the leaf section of the block.\n\t\t * The linear search is crude but this is DEBUG code.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\tXFS_WANT_CORRUPTED_RETURN(dep->namelen != 0);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t!xfs_dir_ino_validate(mp, be64_to_cpu(dep->inumber)));\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\tbe16_to_cpu(*ops->data_entry_tag_p(dep)) ==\n\t\t\t\t\t       (char *)dep - (char *)hdr);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tops->data_get_ftype(dep) < XFS_DIR3_FT_MAX);\n\t\tcount++;\n\t\tlastfree = 0;\n\t\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\t\taddr = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,\n\t\t\t\t\t\t(xfs_dir2_data_aoff_t)\n\t\t\t\t\t\t((char *)dep - (char *)hdr));\n\t\t\tname.name = dep->name;\n\t\t\tname.len = dep->namelen;\n\t\t\thash = mp->m_dirnameops->hashname(&name);\n\t\t\tfor (i = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\t\tif (be32_to_cpu(lep[i].address) == addr &&\n\t\t\t\t    be32_to_cpu(lep[i].hashval) == hash)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i < be32_to_cpu(btp->count));\n\t\t}\n\t\tp += ops->data_entsize(dep->namelen);\n\t}\n\t/*\n\t * Need to have seen all the entries and all the bestfree slots.\n\t */\n\tXFS_WANT_CORRUPTED_RETURN(freeseen == 7);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tfor (i = stale = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\tif (lep[i].address ==\n\t\t\t    cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\t\tstale++;\n\t\t\tif (i > 0)\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe32_to_cpu(lep[i].hashval) >=\n\t\t\t\t\t\tbe32_to_cpu(lep[i - 1].hashval));\n\t\t}\n\t\tXFS_WANT_CORRUPTED_RETURN(count ==\n\t\t\tbe32_to_cpu(btp->count) - be32_to_cpu(btp->stale));\n\t\tXFS_WANT_CORRUPTED_RETURN(stale == be32_to_cpu(btp->stale));\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_log_entry",
          "args": [
            "args",
            "bp",
            "dep"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_log_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "640-656",
          "snippet": "void\nxfs_dir2_data_log_entry(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_entry_t\t*dep)\t\t/* data entry pointer */\n{\n\tstruct xfs_dir2_data_hdr *hdr = bp->b_addr;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\txfs_trans_log_buf(args->trans, bp, (uint)((char *)dep - (char *)hdr),\n\t\t(uint)((char *)(args->dp->d_ops->data_entry_tag_p(dep) + 1) -\n\t\t       (char *)hdr - 1));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dir2_data_log_entry(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_entry_t\t*dep)\t\t/* data entry pointer */\n{\n\tstruct xfs_dir2_data_hdr *hdr = bp->b_addr;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\txfs_trans_log_buf(args->trans, bp, (uint)((char *)dep - (char *)hdr),\n\t\t(uint)((char *)(args->dp->d_ops->data_entry_tag_p(dep) + 1) -\n\t\t       (char *)hdr - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_put_ftype",
          "args": [
            "dep",
            "args->filetype"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "args->inumber"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "be64_to_cpu(dep->inumber) != args->inumber"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dep->inumber"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_dataptr_to_off",
          "args": [
            "args->geo",
            "be32_to_cpu(blp[ent].address)"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_dataptr_to_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "240-244",
          "snippet": "static inline xfs_dir2_data_aoff_t\nxfs_dir2_dataptr_to_off(struct xfs_da_geometry *geo, xfs_dir2_dataptr_t dp)\n{\n\treturn xfs_dir2_byte_to_off(geo, xfs_dir2_dataptr_to_byte(dp));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_data_aoff_t\nxfs_dir2_dataptr_to_off(struct xfs_da_geometry *geo, xfs_dir2_dataptr_t dp)\n{\n\treturn xfs_dir2_byte_to_off(geo, xfs_dir2_dataptr_to_byte(dp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "blp[ent].address"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_leaf_p",
          "args": [
            "btp"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_leaf_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "601-605",
          "snippet": "static inline struct xfs_dir2_leaf_entry *\nxfs_dir2_block_leaf_p(struct xfs_dir2_block_tail *btp)\n{\n\treturn ((struct xfs_dir2_leaf_entry *)btp) - be32_to_cpu(btp->count);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_leaf_entry *\nxfs_dir2_block_leaf_p(struct xfs_dir2_block_tail *btp)\n{\n\treturn ((struct xfs_dir2_leaf_entry *)btp) - be32_to_cpu(btp->count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_tail_p",
          "args": [
            "args->geo",
            "hdr"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_tail_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "305-310",
          "snippet": "static inline struct xfs_dir2_block_tail *\nxfs_dir2_block_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_data_hdr *hdr)\n{\n\treturn ((struct xfs_dir2_block_tail *)\n\t\t((char *)hdr + geo->blksize)) - 1;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_block_tail *\nxfs_dir2_block_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_data_hdr *hdr)\n{\n\treturn ((struct xfs_dir2_block_tail *)\n\t\t((char *)hdr + geo->blksize)) - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_lookup_int",
          "args": [
            "args",
            "&bp",
            "&ent"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_lookup_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
          "lines": "649-748",
          "snippet": "static int\t\t\t\t\t/* error */\nxfs_dir2_block_lookup_int(\n\txfs_da_args_t\t\t*args,\t\t/* dir lookup arguments */\n\tstruct xfs_buf\t\t**bpp,\t\t/* returned block buffer */\n\tint\t\t\t*entno)\t\t/* returned entry number */\n{\n\txfs_dir2_dataptr_t\taddr;\t\t/* data entry address */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* block leaf entries */\n\tstruct xfs_buf\t\t*bp;\t\t/* block buffer */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* block data entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore inode */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_dahash_t\t\thash;\t\t/* found hash value */\n\tint\t\t\thigh;\t\t/* binary search high index */\n\tint\t\t\tlow;\t\t/* binary search low index */\n\tint\t\t\tmid;\t\t/* binary search current idx */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tenum xfs_dacmp\t\tcmp;\t\t/* comparison result */\n\n\tdp = args->dp;\n\ttp = args->trans;\n\tmp = dp->i_mount;\n\n\terror = xfs_dir3_block_read(tp, dp, &bp);\n\tif (error)\n\t\treturn error;\n\n\thdr = bp->b_addr;\n\txfs_dir3_data_check(dp, bp);\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\t/*\n\t * Loop doing a binary search for our hash value.\n\t * Find our entry, ENOENT if it's not there.\n\t */\n\tfor (low = 0, high = be32_to_cpu(btp->count) - 1; ; ) {\n\t\tASSERT(low <= high);\n\t\tmid = (low + high) >> 1;\n\t\tif ((hash = be32_to_cpu(blp[mid].hashval)) == args->hashval)\n\t\t\tbreak;\n\t\tif (hash < args->hashval)\n\t\t\tlow = mid + 1;\n\t\telse\n\t\t\thigh = mid - 1;\n\t\tif (low > high) {\n\t\t\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\t/*\n\t * Back up to the first one with the right hash value.\n\t */\n\twhile (mid > 0 && be32_to_cpu(blp[mid - 1].hashval) == args->hashval) {\n\t\tmid--;\n\t}\n\t/*\n\t * Now loop forward through all the entries with the\n\t * right hash value looking for our name.\n\t */\n\tdo {\n\t\tif ((addr = be32_to_cpu(blp[mid].address)) == XFS_DIR2_NULL_DATAPTR)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Get pointer to the entry from the leaf.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)\n\t\t\t((char *)hdr + xfs_dir2_dataptr_to_off(args->geo, addr));\n\t\t/*\n\t\t * Compare name and if it's an exact match, return the index\n\t\t * and buffer. If it's the first case-insensitive match, store\n\t\t * the index and buffer and continue looking for an exact match.\n\t\t */\n\t\tcmp = mp->m_dirnameops->compname(args, dep->name, dep->namelen);\n\t\tif (cmp != XFS_CMP_DIFFERENT && cmp != args->cmpresult) {\n\t\t\targs->cmpresult = cmp;\n\t\t\t*bpp = bp;\n\t\t\t*entno = mid;\n\t\t\tif (cmp == XFS_CMP_EXACT)\n\t\t\t\treturn 0;\n\t\t}\n\t} while (++mid < be32_to_cpu(btp->count) &&\n\t\t\tbe32_to_cpu(blp[mid].hashval) == hash);\n\n\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\t/*\n\t * Here, we can only be doing a lookup (not a rename or replace).\n\t * If a case-insensitive match was found earlier, return success.\n\t */\n\tif (args->cmpresult == XFS_CMP_CASE)\n\t\treturn 0;\n\t/*\n\t * No match, release the buffer and return ENOENT.\n\t */\n\txfs_trans_brelse(tp, bp);\n\treturn -ENOENT;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);",
            "static int xfs_dir2_block_lookup_int(xfs_da_args_t *args, struct xfs_buf **bpp,\n\t\t\t\t     int *entno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);\nstatic int xfs_dir2_block_lookup_int(xfs_da_args_t *args, struct xfs_buf **bpp,\n\t\t\t\t     int *entno);\n\nstatic int\t\t\t\t\t/* error */\nxfs_dir2_block_lookup_int(\n\txfs_da_args_t\t\t*args,\t\t/* dir lookup arguments */\n\tstruct xfs_buf\t\t**bpp,\t\t/* returned block buffer */\n\tint\t\t\t*entno)\t\t/* returned entry number */\n{\n\txfs_dir2_dataptr_t\taddr;\t\t/* data entry address */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* block leaf entries */\n\tstruct xfs_buf\t\t*bp;\t\t/* block buffer */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* block data entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore inode */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_dahash_t\t\thash;\t\t/* found hash value */\n\tint\t\t\thigh;\t\t/* binary search high index */\n\tint\t\t\tlow;\t\t/* binary search low index */\n\tint\t\t\tmid;\t\t/* binary search current idx */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tenum xfs_dacmp\t\tcmp;\t\t/* comparison result */\n\n\tdp = args->dp;\n\ttp = args->trans;\n\tmp = dp->i_mount;\n\n\terror = xfs_dir3_block_read(tp, dp, &bp);\n\tif (error)\n\t\treturn error;\n\n\thdr = bp->b_addr;\n\txfs_dir3_data_check(dp, bp);\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\t/*\n\t * Loop doing a binary search for our hash value.\n\t * Find our entry, ENOENT if it's not there.\n\t */\n\tfor (low = 0, high = be32_to_cpu(btp->count) - 1; ; ) {\n\t\tASSERT(low <= high);\n\t\tmid = (low + high) >> 1;\n\t\tif ((hash = be32_to_cpu(blp[mid].hashval)) == args->hashval)\n\t\t\tbreak;\n\t\tif (hash < args->hashval)\n\t\t\tlow = mid + 1;\n\t\telse\n\t\t\thigh = mid - 1;\n\t\tif (low > high) {\n\t\t\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\t/*\n\t * Back up to the first one with the right hash value.\n\t */\n\twhile (mid > 0 && be32_to_cpu(blp[mid - 1].hashval) == args->hashval) {\n\t\tmid--;\n\t}\n\t/*\n\t * Now loop forward through all the entries with the\n\t * right hash value looking for our name.\n\t */\n\tdo {\n\t\tif ((addr = be32_to_cpu(blp[mid].address)) == XFS_DIR2_NULL_DATAPTR)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Get pointer to the entry from the leaf.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)\n\t\t\t((char *)hdr + xfs_dir2_dataptr_to_off(args->geo, addr));\n\t\t/*\n\t\t * Compare name and if it's an exact match, return the index\n\t\t * and buffer. If it's the first case-insensitive match, store\n\t\t * the index and buffer and continue looking for an exact match.\n\t\t */\n\t\tcmp = mp->m_dirnameops->compname(args, dep->name, dep->namelen);\n\t\tif (cmp != XFS_CMP_DIFFERENT && cmp != args->cmpresult) {\n\t\t\targs->cmpresult = cmp;\n\t\t\t*bpp = bp;\n\t\t\t*entno = mid;\n\t\t\tif (cmp == XFS_CMP_EXACT)\n\t\t\t\treturn 0;\n\t\t}\n\t} while (++mid < be32_to_cpu(btp->count) &&\n\t\t\tbe32_to_cpu(blp[mid].hashval) == hash);\n\n\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\t/*\n\t * Here, we can only be doing a lookup (not a rename or replace).\n\t * If a case-insensitive match was found earlier, return success.\n\t */\n\tif (args->cmpresult == XFS_CMP_CASE)\n\t\treturn 0;\n\t/*\n\t * No match, release the buffer and return ENOENT.\n\t */\n\txfs_trans_brelse(tp, bp);\n\treturn -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_dir2_block_replace",
          "args": [
            "args"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_block_replace(\n\txfs_da_args_t\t\t*args)\t\t/* directory operation args */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* block leaf entries */\n\tstruct xfs_buf\t\t*bp;\t\t/* block buffer */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* block data entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore inode */\n\tint\t\t\tent;\t\t/* leaf entry index */\n\tint\t\t\terror;\t\t/* error return value */\n\n\ttrace_xfs_dir2_block_replace(args);\n\n\t/*\n\t * Lookup the entry in the directory.  Get buffer and entry index.\n\t * This will always succeed since the caller has already done a lookup.\n\t */\n\tif ((error = xfs_dir2_block_lookup_int(args, &bp, &ent))) {\n\t\treturn error;\n\t}\n\tdp = args->dp;\n\thdr = bp->b_addr;\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\t/*\n\t * Point to the data entry we need to change.\n\t */\n\tdep = (xfs_dir2_data_entry_t *)((char *)hdr +\n\t\t\txfs_dir2_dataptr_to_off(args->geo,\n\t\t\t\t\t\tbe32_to_cpu(blp[ent].address)));\n\tASSERT(be64_to_cpu(dep->inumber) != args->inumber);\n\t/*\n\t * Change the inode number to the new value.\n\t */\n\tdep->inumber = cpu_to_be64(args->inumber);\n\tdp->d_ops->data_put_ftype(dep, args->filetype);\n\txfs_dir2_data_log_entry(args, bp, dep);\n\txfs_dir3_data_check(dp, bp);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_dir2_block_removename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
    "lines": "754-828",
    "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_block_removename(\n\txfs_da_args_t\t\t*args)\t\t/* directory operation args */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* block leaf pointer */\n\tstruct xfs_buf\t\t*bp;\t\t/* block buffer */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* block data entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore inode */\n\tint\t\t\tent;\t\t/* block leaf entry index */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tneedlog;\t/* need to log block header */\n\tint\t\t\tneedscan;\t/* need to fixup bestfree */\n\txfs_dir2_sf_hdr_t\tsfh;\t\t/* shortform header */\n\tint\t\t\tsize;\t\t/* shortform size */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\n\ttrace_xfs_dir2_block_removename(args);\n\n\t/*\n\t * Look up the entry in the block.  Gets the buffer and entry index.\n\t * It will always be there, the vnodeops level does a lookup first.\n\t */\n\tif ((error = xfs_dir2_block_lookup_int(args, &bp, &ent))) {\n\t\treturn error;\n\t}\n\tdp = args->dp;\n\ttp = args->trans;\n\thdr = bp->b_addr;\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\t/*\n\t * Point to the data entry using the leaf entry.\n\t */\n\tdep = (xfs_dir2_data_entry_t *)((char *)hdr +\n\t\t\txfs_dir2_dataptr_to_off(args->geo,\n\t\t\t\t\t\tbe32_to_cpu(blp[ent].address)));\n\t/*\n\t * Mark the data entry's space free.\n\t */\n\tneedlog = needscan = 0;\n\txfs_dir2_data_make_free(args, bp,\n\t\t(xfs_dir2_data_aoff_t)((char *)dep - (char *)hdr),\n\t\tdp->d_ops->data_entsize(dep->namelen), &needlog, &needscan);\n\t/*\n\t * Fix up the block tail.\n\t */\n\tbe32_add_cpu(&btp->stale, 1);\n\txfs_dir2_block_log_tail(tp, bp);\n\t/*\n\t * Remove the leaf entry by marking it stale.\n\t */\n\tblp[ent].address = cpu_to_be32(XFS_DIR2_NULL_DATAPTR);\n\txfs_dir2_block_log_leaf(tp, bp, ent, ent);\n\t/*\n\t * Fix up bestfree, log the header if necessary.\n\t */\n\tif (needscan)\n\t\txfs_dir2_data_freescan(dp, hdr, &needlog);\n\tif (needlog)\n\t\txfs_dir2_data_log_header(args, bp);\n\txfs_dir3_data_check(dp, bp);\n\t/*\n\t * See if the size as a shortform is good enough.\n\t */\n\tsize = xfs_dir2_block_sfsize(dp, hdr, &sfh);\n\tif (size > XFS_IFORK_DSIZE(dp))\n\t\treturn 0;\n\n\t/*\n\t * If it works, do the conversion.\n\t */\n\treturn xfs_dir2_block_to_sf(args, bp, size, &sfh);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_dir2_block_to_sf",
          "args": [
            "args",
            "bp",
            "size",
            "&sfh"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_to_sf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_sf.c",
          "lines": "152-274",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_block_to_sf(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tsize,\t\t/* shortform directory size */\n\txfs_dir2_sf_hdr_t\t*sfhp)\t\t/* shortform directory hdr */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail pointer */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry pointer */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused data pointer */\n\tchar\t\t\t*endptr;\t/* end of data entries */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlogflags;\t/* inode logging flags */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tchar\t\t\t*ptr;\t\t/* current data pointer */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* shortform entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform directory header */\n\txfs_dir2_sf_hdr_t\t*dst;\t\t/* temporary data buffer */\n\n\ttrace_xfs_dir2_block_to_sf(args);\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\n\t/*\n\t * allocate a temporary destination buffer the size of the inode\n\t * to format the data into. Once we have formatted the data, we\n\t * can free the block and copy the formatted data into the inode literal\n\t * area.\n\t */\n\tdst = kmem_alloc(mp->m_sb.sb_inodesize, KM_SLEEP);\n\thdr = bp->b_addr;\n\n\t/*\n\t * Copy the header into the newly allocate local space.\n\t */\n\tsfp = (xfs_dir2_sf_hdr_t *)dst;\n\tmemcpy(sfp, sfhp, xfs_dir2_sf_hdr_size(sfhp->i8count));\n\n\t/*\n\t * Set up to loop over the block's entries.\n\t */\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tptr = (char *)dp->d_ops->data_entry_p(hdr);\n\tendptr = (char *)xfs_dir2_block_leaf_p(btp);\n\tsfep = xfs_dir2_sf_firstentry(sfp);\n\t/*\n\t * Loop over the active and unused entries.\n\t * Stop when we reach the leaf/tail portion of the block.\n\t */\n\twhile (ptr < endptr) {\n\t\t/*\n\t\t * If it's unused, just skip over it.\n\t\t */\n\t\tdup = (xfs_dir2_data_unused_t *)ptr;\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tptr += be16_to_cpu(dup->length);\n\t\t\tcontinue;\n\t\t}\n\t\tdep = (xfs_dir2_data_entry_t *)ptr;\n\t\t/*\n\t\t * Skip .\n\t\t */\n\t\tif (dep->namelen == 1 && dep->name[0] == '.')\n\t\t\tASSERT(be64_to_cpu(dep->inumber) == dp->i_ino);\n\t\t/*\n\t\t * Skip .., but make sure the inode number is right.\n\t\t */\n\t\telse if (dep->namelen == 2 &&\n\t\t\t dep->name[0] == '.' && dep->name[1] == '.')\n\t\t\tASSERT(be64_to_cpu(dep->inumber) ==\n\t\t\t       dp->d_ops->sf_get_parent_ino(sfp));\n\t\t/*\n\t\t * Normal entry, copy it into shortform.\n\t\t */\n\t\telse {\n\t\t\tsfep->namelen = dep->namelen;\n\t\t\txfs_dir2_sf_put_offset(sfep,\n\t\t\t\t(xfs_dir2_data_aoff_t)\n\t\t\t\t((char *)dep - (char *)hdr));\n\t\t\tmemcpy(sfep->name, dep->name, dep->namelen);\n\t\t\tdp->d_ops->sf_put_ino(sfp, sfep,\n\t\t\t\t\t      be64_to_cpu(dep->inumber));\n\t\t\tdp->d_ops->sf_put_ftype(sfep,\n\t\t\t\t\tdp->d_ops->data_get_ftype(dep));\n\n\t\t\tsfep = dp->d_ops->sf_nextentry(sfp, sfep);\n\t\t}\n\t\tptr += dp->d_ops->data_entsize(dep->namelen);\n\t}\n\tASSERT((char *)sfep - (char *)sfp == size);\n\n\t/* now we are done with the block, we can shrink the inode */\n\tlogflags = XFS_ILOG_CORE;\n\terror = xfs_dir2_shrink_inode(args, args->geo->datablk, bp);\n\tif (error) {\n\t\tASSERT(error != -ENOSPC);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The buffer is now unconditionally gone, whether\n\t * xfs_dir2_shrink_inode worked or not.\n\t *\n\t * Convert the inode to local format and copy the data in.\n\t */\n\tdp->i_df.if_flags &= ~XFS_IFEXTENTS;\n\tdp->i_df.if_flags |= XFS_IFINLINE;\n\tdp->i_d.di_format = XFS_DINODE_FMT_LOCAL;\n\tASSERT(dp->i_df.if_bytes == 0);\n\txfs_idata_realloc(dp, size, XFS_DATA_FORK);\n\n\tlogflags |= XFS_ILOG_DDATA;\n\tmemcpy(dp->i_df.if_u1.if_data, dst, size);\n\tdp->i_d.di_size = size;\n\txfs_dir2_sf_check(args);\nout:\n\txfs_trans_log_inode(args->trans, dp, logflags);\n\tkmem_free(dst);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir2_sf_toino4(xfs_da_args_t *args);",
            "static void xfs_dir2_sf_toino8(xfs_da_args_t *args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_sf_toino4(xfs_da_args_t *args);\nstatic void xfs_dir2_sf_toino8(xfs_da_args_t *args);\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_block_to_sf(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tsize,\t\t/* shortform directory size */\n\txfs_dir2_sf_hdr_t\t*sfhp)\t\t/* shortform directory hdr */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail pointer */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry pointer */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused data pointer */\n\tchar\t\t\t*endptr;\t/* end of data entries */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlogflags;\t/* inode logging flags */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tchar\t\t\t*ptr;\t\t/* current data pointer */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* shortform entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform directory header */\n\txfs_dir2_sf_hdr_t\t*dst;\t\t/* temporary data buffer */\n\n\ttrace_xfs_dir2_block_to_sf(args);\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\n\t/*\n\t * allocate a temporary destination buffer the size of the inode\n\t * to format the data into. Once we have formatted the data, we\n\t * can free the block and copy the formatted data into the inode literal\n\t * area.\n\t */\n\tdst = kmem_alloc(mp->m_sb.sb_inodesize, KM_SLEEP);\n\thdr = bp->b_addr;\n\n\t/*\n\t * Copy the header into the newly allocate local space.\n\t */\n\tsfp = (xfs_dir2_sf_hdr_t *)dst;\n\tmemcpy(sfp, sfhp, xfs_dir2_sf_hdr_size(sfhp->i8count));\n\n\t/*\n\t * Set up to loop over the block's entries.\n\t */\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tptr = (char *)dp->d_ops->data_entry_p(hdr);\n\tendptr = (char *)xfs_dir2_block_leaf_p(btp);\n\tsfep = xfs_dir2_sf_firstentry(sfp);\n\t/*\n\t * Loop over the active and unused entries.\n\t * Stop when we reach the leaf/tail portion of the block.\n\t */\n\twhile (ptr < endptr) {\n\t\t/*\n\t\t * If it's unused, just skip over it.\n\t\t */\n\t\tdup = (xfs_dir2_data_unused_t *)ptr;\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tptr += be16_to_cpu(dup->length);\n\t\t\tcontinue;\n\t\t}\n\t\tdep = (xfs_dir2_data_entry_t *)ptr;\n\t\t/*\n\t\t * Skip .\n\t\t */\n\t\tif (dep->namelen == 1 && dep->name[0] == '.')\n\t\t\tASSERT(be64_to_cpu(dep->inumber) == dp->i_ino);\n\t\t/*\n\t\t * Skip .., but make sure the inode number is right.\n\t\t */\n\t\telse if (dep->namelen == 2 &&\n\t\t\t dep->name[0] == '.' && dep->name[1] == '.')\n\t\t\tASSERT(be64_to_cpu(dep->inumber) ==\n\t\t\t       dp->d_ops->sf_get_parent_ino(sfp));\n\t\t/*\n\t\t * Normal entry, copy it into shortform.\n\t\t */\n\t\telse {\n\t\t\tsfep->namelen = dep->namelen;\n\t\t\txfs_dir2_sf_put_offset(sfep,\n\t\t\t\t(xfs_dir2_data_aoff_t)\n\t\t\t\t((char *)dep - (char *)hdr));\n\t\t\tmemcpy(sfep->name, dep->name, dep->namelen);\n\t\t\tdp->d_ops->sf_put_ino(sfp, sfep,\n\t\t\t\t\t      be64_to_cpu(dep->inumber));\n\t\t\tdp->d_ops->sf_put_ftype(sfep,\n\t\t\t\t\tdp->d_ops->data_get_ftype(dep));\n\n\t\t\tsfep = dp->d_ops->sf_nextentry(sfp, sfep);\n\t\t}\n\t\tptr += dp->d_ops->data_entsize(dep->namelen);\n\t}\n\tASSERT((char *)sfep - (char *)sfp == size);\n\n\t/* now we are done with the block, we can shrink the inode */\n\tlogflags = XFS_ILOG_CORE;\n\terror = xfs_dir2_shrink_inode(args, args->geo->datablk, bp);\n\tif (error) {\n\t\tASSERT(error != -ENOSPC);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The buffer is now unconditionally gone, whether\n\t * xfs_dir2_shrink_inode worked or not.\n\t *\n\t * Convert the inode to local format and copy the data in.\n\t */\n\tdp->i_df.if_flags &= ~XFS_IFEXTENTS;\n\tdp->i_df.if_flags |= XFS_IFINLINE;\n\tdp->i_d.di_format = XFS_DINODE_FMT_LOCAL;\n\tASSERT(dp->i_df.if_bytes == 0);\n\txfs_idata_realloc(dp, size, XFS_DATA_FORK);\n\n\tlogflags |= XFS_ILOG_DDATA;\n\tmemcpy(dp->i_df.if_u1.if_data, dst, size);\n\tdp->i_d.di_size = size;\n\txfs_dir2_sf_check(args);\nout:\n\txfs_trans_log_inode(args->trans, dp, logflags);\n\tkmem_free(dst);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_DSIZE",
          "args": [
            "dp"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_sfsize",
          "args": [
            "dp",
            "hdr",
            "&sfh"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_sfsize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_sf.c",
          "lines": "61-146",
          "snippet": "int\t\t\t\t\t\t/* size for sf form */\nxfs_dir2_block_sfsize(\n\txfs_inode_t\t\t*dp,\t\t/* incore inode pointer */\n\txfs_dir2_data_hdr_t\t*hdr,\t\t/* block directory data */\n\txfs_dir2_sf_hdr_t\t*sfhp)\t\t/* output: header for sf form */\n{\n\txfs_dir2_dataptr_t\taddr;\t\t/* data entry address */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* leaf area of the block */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* tail area of the block */\n\tint\t\t\tcount;\t\t/* shortform entry count */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry in the block */\n\tint\t\t\ti;\t\t/* block entry index */\n\tint\t\t\ti8count;\t/* count of big-inode entries */\n\tint\t\t\tisdot;\t\t/* entry is \".\" */\n\tint\t\t\tisdotdot;\t/* entry is \"..\" */\n\txfs_mount_t\t\t*mp;\t\t/* mount structure pointer */\n\tint\t\t\tnamelen;\t/* total name bytes */\n\txfs_ino_t\t\tparent = 0;\t/* parent inode number */\n\tint\t\t\tsize=0;\t\t/* total computed size */\n\tint\t\t\thas_ftype;\n\tstruct xfs_da_geometry\t*geo;\n\n\tmp = dp->i_mount;\n\tgeo = mp->m_dir_geo;\n\n\t/*\n\t * if there is a filetype field, add the extra byte to the namelen\n\t * for each entry that we see.\n\t */\n\thas_ftype = xfs_sb_version_hasftype(&mp->m_sb) ? 1 : 0;\n\n\tcount = i8count = namelen = 0;\n\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\n\t/*\n\t * Iterate over the block's data entries by using the leaf pointers.\n\t */\n\tfor (i = 0; i < be32_to_cpu(btp->count); i++) {\n\t\tif ((addr = be32_to_cpu(blp[i].address)) == XFS_DIR2_NULL_DATAPTR)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Calculate the pointer to the entry at hand.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)((char *)hdr +\n\t\t\t\txfs_dir2_dataptr_to_off(geo, addr));\n\t\t/*\n\t\t * Detect . and .., so we can special-case them.\n\t\t * . is not included in sf directories.\n\t\t * .. is included by just the parent inode number.\n\t\t */\n\t\tisdot = dep->namelen == 1 && dep->name[0] == '.';\n\t\tisdotdot =\n\t\t\tdep->namelen == 2 &&\n\t\t\tdep->name[0] == '.' && dep->name[1] == '.';\n\n\t\tif (!isdot)\n\t\t\ti8count += be64_to_cpu(dep->inumber) > XFS_DIR2_MAX_SHORT_INUM;\n\n\t\t/* take into account the file type field */\n\t\tif (!isdot && !isdotdot) {\n\t\t\tcount++;\n\t\t\tnamelen += dep->namelen + has_ftype;\n\t\t} else if (isdotdot)\n\t\t\tparent = be64_to_cpu(dep->inumber);\n\t\t/*\n\t\t * Calculate the new size, see if we should give up yet.\n\t\t */\n\t\tsize = xfs_dir2_sf_hdr_size(i8count) +\t\t/* header */\n\t\t       count +\t\t\t\t\t/* namelen */\n\t\t       count * (uint)sizeof(xfs_dir2_sf_off_t) + /* offset */\n\t\t       namelen +\t\t\t\t/* name */\n\t\t       (i8count ?\t\t\t\t/* inumber */\n\t\t\t\t(uint)sizeof(xfs_dir2_ino8_t) * count :\n\t\t\t\t(uint)sizeof(xfs_dir2_ino4_t) * count);\n\t\tif (size > XFS_IFORK_DSIZE(dp))\n\t\t\treturn size;\t\t/* size value is a failure */\n\t}\n\t/*\n\t * Create the output header, if it worked.\n\t */\n\tsfhp->count = count;\n\tsfhp->i8count = i8count;\n\tdp->d_ops->sf_put_parent_ino(sfhp, parent);\n\treturn size;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* size for sf form */\nxfs_dir2_block_sfsize(\n\txfs_inode_t\t\t*dp,\t\t/* incore inode pointer */\n\txfs_dir2_data_hdr_t\t*hdr,\t\t/* block directory data */\n\txfs_dir2_sf_hdr_t\t*sfhp)\t\t/* output: header for sf form */\n{\n\txfs_dir2_dataptr_t\taddr;\t\t/* data entry address */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* leaf area of the block */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* tail area of the block */\n\tint\t\t\tcount;\t\t/* shortform entry count */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry in the block */\n\tint\t\t\ti;\t\t/* block entry index */\n\tint\t\t\ti8count;\t/* count of big-inode entries */\n\tint\t\t\tisdot;\t\t/* entry is \".\" */\n\tint\t\t\tisdotdot;\t/* entry is \"..\" */\n\txfs_mount_t\t\t*mp;\t\t/* mount structure pointer */\n\tint\t\t\tnamelen;\t/* total name bytes */\n\txfs_ino_t\t\tparent = 0;\t/* parent inode number */\n\tint\t\t\tsize=0;\t\t/* total computed size */\n\tint\t\t\thas_ftype;\n\tstruct xfs_da_geometry\t*geo;\n\n\tmp = dp->i_mount;\n\tgeo = mp->m_dir_geo;\n\n\t/*\n\t * if there is a filetype field, add the extra byte to the namelen\n\t * for each entry that we see.\n\t */\n\thas_ftype = xfs_sb_version_hasftype(&mp->m_sb) ? 1 : 0;\n\n\tcount = i8count = namelen = 0;\n\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\n\t/*\n\t * Iterate over the block's data entries by using the leaf pointers.\n\t */\n\tfor (i = 0; i < be32_to_cpu(btp->count); i++) {\n\t\tif ((addr = be32_to_cpu(blp[i].address)) == XFS_DIR2_NULL_DATAPTR)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Calculate the pointer to the entry at hand.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)((char *)hdr +\n\t\t\t\txfs_dir2_dataptr_to_off(geo, addr));\n\t\t/*\n\t\t * Detect . and .., so we can special-case them.\n\t\t * . is not included in sf directories.\n\t\t * .. is included by just the parent inode number.\n\t\t */\n\t\tisdot = dep->namelen == 1 && dep->name[0] == '.';\n\t\tisdotdot =\n\t\t\tdep->namelen == 2 &&\n\t\t\tdep->name[0] == '.' && dep->name[1] == '.';\n\n\t\tif (!isdot)\n\t\t\ti8count += be64_to_cpu(dep->inumber) > XFS_DIR2_MAX_SHORT_INUM;\n\n\t\t/* take into account the file type field */\n\t\tif (!isdot && !isdotdot) {\n\t\t\tcount++;\n\t\t\tnamelen += dep->namelen + has_ftype;\n\t\t} else if (isdotdot)\n\t\t\tparent = be64_to_cpu(dep->inumber);\n\t\t/*\n\t\t * Calculate the new size, see if we should give up yet.\n\t\t */\n\t\tsize = xfs_dir2_sf_hdr_size(i8count) +\t\t/* header */\n\t\t       count +\t\t\t\t\t/* namelen */\n\t\t       count * (uint)sizeof(xfs_dir2_sf_off_t) + /* offset */\n\t\t       namelen +\t\t\t\t/* name */\n\t\t       (i8count ?\t\t\t\t/* inumber */\n\t\t\t\t(uint)sizeof(xfs_dir2_ino8_t) * count :\n\t\t\t\t(uint)sizeof(xfs_dir2_ino4_t) * count);\n\t\tif (size > XFS_IFORK_DSIZE(dp))\n\t\t\treturn size;\t\t/* size value is a failure */\n\t}\n\t/*\n\t * Create the output header, if it worked.\n\t */\n\tsfhp->count = count;\n\tsfhp->i8count = i8count;\n\tdp->d_ops->sf_put_parent_ino(sfhp, parent);\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir3_data_check",
          "args": [
            "dp",
            "bp"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "__xfs_dir3_data_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "40-210",
          "snippet": "int\n__xfs_dir3_data_check(\n\tstruct xfs_inode\t*dp,\t\t/* incore inode pointer */\n\tstruct xfs_buf\t\t*bp)\t\t/* data block's buffer */\n{\n\txfs_dir2_dataptr_t\taddr;\t\t/* addr for leaf lookup */\n\txfs_dir2_data_free_t\t*bf;\t\t/* bestfree table */\n\txfs_dir2_block_tail_t\t*btp=NULL;\t/* block tail */\n\tint\t\t\tcount;\t\t/* count of entries found */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry */\n\tchar\t\t\t*endp;\t\t/* end of useful data */\n\tint\t\t\tfreeseen;\t/* mask of bestfrees seen */\n\txfs_dahash_t\t\thash;\t\t/* hash of current name */\n\tint\t\t\ti;\t\t/* leaf index */\n\tint\t\t\tlastfree;\t/* last entry was unused */\n\txfs_dir2_leaf_entry_t\t*lep=NULL;\t/* block leaf entries */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tchar\t\t\t*p;\t\t/* current data position */\n\tint\t\t\tstale;\t\t/* count of stale leaves */\n\tstruct xfs_name\t\tname;\n\tconst struct xfs_dir_ops *ops;\n\tstruct xfs_da_geometry\t*geo;\n\n\tmp = bp->b_target->bt_mount;\n\tgeo = mp->m_dir_geo;\n\n\t/*\n\t * We can be passed a null dp here from a verifier, so we need to go the\n\t * hard way to get them.\n\t */\n\tops = xfs_dir_get_ops(mp, dp);\n\n\thdr = bp->b_addr;\n\tp = (char *)ops->data_entry_p(hdr);\n\n\tswitch (hdr->magic) {\n\tcase cpu_to_be32(XFS_DIR3_BLOCK_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_BLOCK_MAGIC):\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tlep = xfs_dir2_block_leaf_p(btp);\n\t\tendp = (char *)lep;\n\n\t\t/*\n\t\t * The number of leaf entries is limited by the size of the\n\t\t * block and the amount of space used by the data entries.\n\t\t * We don't know how much space is used by the data entries yet,\n\t\t * so just ensure that the count falls somewhere inside the\n\t\t * block right now.\n\t\t */\n\t\tXFS_WANT_CORRUPTED_RETURN(be32_to_cpu(btp->count) <\n\t\t\t((char *)btp - p) / sizeof(struct xfs_dir2_leaf_entry));\n\t\tbreak;\n\tcase cpu_to_be32(XFS_DIR3_DATA_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_DATA_MAGIC):\n\t\tendp = (char *)hdr + geo->blksize;\n\t\tbreak;\n\tdefault:\n\t\tXFS_ERROR_REPORT(\"Bad Magic\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/*\n\t * Account for zero bestfree entries.\n\t */\n\tbf = ops->data_bestfree_p(hdr);\n\tcount = lastfree = freeseen = 0;\n\tif (!bf[0].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[0].offset);\n\t\tfreeseen |= 1 << 0;\n\t}\n\tif (!bf[1].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[1].offset);\n\t\tfreeseen |= 1 << 1;\n\t}\n\tif (!bf[2].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[2].offset);\n\t\tfreeseen |= 1 << 2;\n\t}\n\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[0].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[1].length));\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[1].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t/*\n\t * Loop over the data/unused entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's unused, look for the space in the bestfree table.\n\t\t * If we find it, account for that, else make sure it\n\t\t * doesn't need to be there.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tXFS_WANT_CORRUPTED_RETURN(lastfree == 0);\n\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tbe16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)) ==\n\t\t\t\t\t       (char *)dup - (char *)hdr);\n\t\t\tdfp = xfs_dir2_data_freefind(hdr, bf, dup);\n\t\t\tif (dfp) {\n\t\t\t\ti = (int)(dfp - bf);\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\t(freeseen & (1 << i)) == 0);\n\t\t\t\tfreeseen |= 1 << i;\n\t\t\t} else {\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe16_to_cpu(dup->length) <=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t\t\t}\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t\tlastfree = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * It's a real entry.  Validate the fields.\n\t\t * If this is a block directory then make sure it's\n\t\t * in the leaf section of the block.\n\t\t * The linear search is crude but this is DEBUG code.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\tXFS_WANT_CORRUPTED_RETURN(dep->namelen != 0);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t!xfs_dir_ino_validate(mp, be64_to_cpu(dep->inumber)));\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\tbe16_to_cpu(*ops->data_entry_tag_p(dep)) ==\n\t\t\t\t\t       (char *)dep - (char *)hdr);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tops->data_get_ftype(dep) < XFS_DIR3_FT_MAX);\n\t\tcount++;\n\t\tlastfree = 0;\n\t\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\t\taddr = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,\n\t\t\t\t\t\t(xfs_dir2_data_aoff_t)\n\t\t\t\t\t\t((char *)dep - (char *)hdr));\n\t\t\tname.name = dep->name;\n\t\t\tname.len = dep->namelen;\n\t\t\thash = mp->m_dirnameops->hashname(&name);\n\t\t\tfor (i = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\t\tif (be32_to_cpu(lep[i].address) == addr &&\n\t\t\t\t    be32_to_cpu(lep[i].hashval) == hash)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i < be32_to_cpu(btp->count));\n\t\t}\n\t\tp += ops->data_entsize(dep->namelen);\n\t}\n\t/*\n\t * Need to have seen all the entries and all the bestfree slots.\n\t */\n\tXFS_WANT_CORRUPTED_RETURN(freeseen == 7);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tfor (i = stale = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\tif (lep[i].address ==\n\t\t\t    cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\t\tstale++;\n\t\t\tif (i > 0)\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe32_to_cpu(lep[i].hashval) >=\n\t\t\t\t\t\tbe32_to_cpu(lep[i - 1].hashval));\n\t\t}\n\t\tXFS_WANT_CORRUPTED_RETURN(count ==\n\t\t\tbe32_to_cpu(btp->count) - be32_to_cpu(btp->stale));\n\t\tXFS_WANT_CORRUPTED_RETURN(stale == be32_to_cpu(btp->stale));\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\n__xfs_dir3_data_check(\n\tstruct xfs_inode\t*dp,\t\t/* incore inode pointer */\n\tstruct xfs_buf\t\t*bp)\t\t/* data block's buffer */\n{\n\txfs_dir2_dataptr_t\taddr;\t\t/* addr for leaf lookup */\n\txfs_dir2_data_free_t\t*bf;\t\t/* bestfree table */\n\txfs_dir2_block_tail_t\t*btp=NULL;\t/* block tail */\n\tint\t\t\tcount;\t\t/* count of entries found */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry */\n\tchar\t\t\t*endp;\t\t/* end of useful data */\n\tint\t\t\tfreeseen;\t/* mask of bestfrees seen */\n\txfs_dahash_t\t\thash;\t\t/* hash of current name */\n\tint\t\t\ti;\t\t/* leaf index */\n\tint\t\t\tlastfree;\t/* last entry was unused */\n\txfs_dir2_leaf_entry_t\t*lep=NULL;\t/* block leaf entries */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tchar\t\t\t*p;\t\t/* current data position */\n\tint\t\t\tstale;\t\t/* count of stale leaves */\n\tstruct xfs_name\t\tname;\n\tconst struct xfs_dir_ops *ops;\n\tstruct xfs_da_geometry\t*geo;\n\n\tmp = bp->b_target->bt_mount;\n\tgeo = mp->m_dir_geo;\n\n\t/*\n\t * We can be passed a null dp here from a verifier, so we need to go the\n\t * hard way to get them.\n\t */\n\tops = xfs_dir_get_ops(mp, dp);\n\n\thdr = bp->b_addr;\n\tp = (char *)ops->data_entry_p(hdr);\n\n\tswitch (hdr->magic) {\n\tcase cpu_to_be32(XFS_DIR3_BLOCK_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_BLOCK_MAGIC):\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tlep = xfs_dir2_block_leaf_p(btp);\n\t\tendp = (char *)lep;\n\n\t\t/*\n\t\t * The number of leaf entries is limited by the size of the\n\t\t * block and the amount of space used by the data entries.\n\t\t * We don't know how much space is used by the data entries yet,\n\t\t * so just ensure that the count falls somewhere inside the\n\t\t * block right now.\n\t\t */\n\t\tXFS_WANT_CORRUPTED_RETURN(be32_to_cpu(btp->count) <\n\t\t\t((char *)btp - p) / sizeof(struct xfs_dir2_leaf_entry));\n\t\tbreak;\n\tcase cpu_to_be32(XFS_DIR3_DATA_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_DATA_MAGIC):\n\t\tendp = (char *)hdr + geo->blksize;\n\t\tbreak;\n\tdefault:\n\t\tXFS_ERROR_REPORT(\"Bad Magic\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/*\n\t * Account for zero bestfree entries.\n\t */\n\tbf = ops->data_bestfree_p(hdr);\n\tcount = lastfree = freeseen = 0;\n\tif (!bf[0].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[0].offset);\n\t\tfreeseen |= 1 << 0;\n\t}\n\tif (!bf[1].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[1].offset);\n\t\tfreeseen |= 1 << 1;\n\t}\n\tif (!bf[2].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[2].offset);\n\t\tfreeseen |= 1 << 2;\n\t}\n\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[0].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[1].length));\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[1].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t/*\n\t * Loop over the data/unused entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's unused, look for the space in the bestfree table.\n\t\t * If we find it, account for that, else make sure it\n\t\t * doesn't need to be there.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tXFS_WANT_CORRUPTED_RETURN(lastfree == 0);\n\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tbe16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)) ==\n\t\t\t\t\t       (char *)dup - (char *)hdr);\n\t\t\tdfp = xfs_dir2_data_freefind(hdr, bf, dup);\n\t\t\tif (dfp) {\n\t\t\t\ti = (int)(dfp - bf);\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\t(freeseen & (1 << i)) == 0);\n\t\t\t\tfreeseen |= 1 << i;\n\t\t\t} else {\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe16_to_cpu(dup->length) <=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t\t\t}\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t\tlastfree = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * It's a real entry.  Validate the fields.\n\t\t * If this is a block directory then make sure it's\n\t\t * in the leaf section of the block.\n\t\t * The linear search is crude but this is DEBUG code.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\tXFS_WANT_CORRUPTED_RETURN(dep->namelen != 0);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t!xfs_dir_ino_validate(mp, be64_to_cpu(dep->inumber)));\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\tbe16_to_cpu(*ops->data_entry_tag_p(dep)) ==\n\t\t\t\t\t       (char *)dep - (char *)hdr);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tops->data_get_ftype(dep) < XFS_DIR3_FT_MAX);\n\t\tcount++;\n\t\tlastfree = 0;\n\t\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\t\taddr = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,\n\t\t\t\t\t\t(xfs_dir2_data_aoff_t)\n\t\t\t\t\t\t((char *)dep - (char *)hdr));\n\t\t\tname.name = dep->name;\n\t\t\tname.len = dep->namelen;\n\t\t\thash = mp->m_dirnameops->hashname(&name);\n\t\t\tfor (i = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\t\tif (be32_to_cpu(lep[i].address) == addr &&\n\t\t\t\t    be32_to_cpu(lep[i].hashval) == hash)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i < be32_to_cpu(btp->count));\n\t\t}\n\t\tp += ops->data_entsize(dep->namelen);\n\t}\n\t/*\n\t * Need to have seen all the entries and all the bestfree slots.\n\t */\n\tXFS_WANT_CORRUPTED_RETURN(freeseen == 7);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tfor (i = stale = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\tif (lep[i].address ==\n\t\t\t    cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\t\tstale++;\n\t\t\tif (i > 0)\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe32_to_cpu(lep[i].hashval) >=\n\t\t\t\t\t\tbe32_to_cpu(lep[i - 1].hashval));\n\t\t}\n\t\tXFS_WANT_CORRUPTED_RETURN(count ==\n\t\t\tbe32_to_cpu(btp->count) - be32_to_cpu(btp->stale));\n\t\tXFS_WANT_CORRUPTED_RETURN(stale == be32_to_cpu(btp->stale));\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_log_header",
          "args": [
            "args",
            "bp"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_log_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "661-677",
          "snippet": "void\nxfs_dir2_data_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n#ifdef DEBUG\n\tstruct xfs_dir2_data_hdr *hdr = bp->b_addr;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n#endif\n\n\txfs_trans_log_buf(args->trans, bp, 0,\n\t\t\t  args->dp->d_ops->data_entry_offset - 1);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dir2_data_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n#ifdef DEBUG\n\tstruct xfs_dir2_data_hdr *hdr = bp->b_addr;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n#endif\n\n\txfs_trans_log_buf(args->trans, bp, 0,\n\t\t\t  args->dp->d_ops->data_entry_offset - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_freescan",
          "args": [
            "dp",
            "hdr",
            "&needlog"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_freescan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "500-559",
          "snippet": "void\nxfs_dir2_data_freescan(\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_dir2_data_hdr *hdr,\n\tint\t\t\t*loghead)\n{\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* active data entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused data entry */\n\tstruct xfs_dir2_data_free *bf;\n\tchar\t\t\t*endp;\t\t/* end of block's data */\n\tchar\t\t\t*p;\t\t/* current entry pointer */\n\tstruct xfs_da_geometry\t*geo = dp->i_mount->m_dir_geo;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\t/*\n\t * Start by clearing the table.\n\t */\n\tbf = dp->d_ops->data_bestfree_p(hdr);\n\tmemset(bf, 0, sizeof(*bf) * XFS_DIR2_DATA_FD_COUNT);\n\t*loghead = 1;\n\t/*\n\t * Set up pointers.\n\t */\n\tp = (char *)dp->d_ops->data_entry_p(hdr);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tendp = (char *)xfs_dir2_block_leaf_p(btp);\n\t} else\n\t\tendp = (char *)hdr + geo->blksize;\n\t/*\n\t * Loop over the block's entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's a free entry, insert it.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tASSERT((char *)dup - (char *)hdr ==\n\t\t\t       be16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)));\n\t\t\txfs_dir2_data_freeinsert(hdr, bf, dup, loghead);\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t}\n\t\t/*\n\t\t * For active entries, check their tags and skip them.\n\t\t */\n\t\telse {\n\t\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\t\tASSERT((char *)dep - (char *)hdr ==\n\t\t\t       be16_to_cpu(*dp->d_ops->data_entry_tag_p(dep)));\n\t\t\tp += dp->d_ops->data_entsize(dep->namelen);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dir2_data_freescan(\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_dir2_data_hdr *hdr,\n\tint\t\t\t*loghead)\n{\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* active data entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused data entry */\n\tstruct xfs_dir2_data_free *bf;\n\tchar\t\t\t*endp;\t\t/* end of block's data */\n\tchar\t\t\t*p;\t\t/* current entry pointer */\n\tstruct xfs_da_geometry\t*geo = dp->i_mount->m_dir_geo;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\t/*\n\t * Start by clearing the table.\n\t */\n\tbf = dp->d_ops->data_bestfree_p(hdr);\n\tmemset(bf, 0, sizeof(*bf) * XFS_DIR2_DATA_FD_COUNT);\n\t*loghead = 1;\n\t/*\n\t * Set up pointers.\n\t */\n\tp = (char *)dp->d_ops->data_entry_p(hdr);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tendp = (char *)xfs_dir2_block_leaf_p(btp);\n\t} else\n\t\tendp = (char *)hdr + geo->blksize;\n\t/*\n\t * Loop over the block's entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's a free entry, insert it.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tASSERT((char *)dup - (char *)hdr ==\n\t\t\t       be16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)));\n\t\t\txfs_dir2_data_freeinsert(hdr, bf, dup, loghead);\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t}\n\t\t/*\n\t\t * For active entries, check their tags and skip them.\n\t\t */\n\t\telse {\n\t\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\t\tASSERT((char *)dep - (char *)hdr ==\n\t\t\t       be16_to_cpu(*dp->d_ops->data_entry_tag_p(dep)));\n\t\t\tp += dp->d_ops->data_entsize(dep->namelen);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_log_leaf",
          "args": [
            "tp",
            "bp",
            "ent",
            "ent"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_log_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
          "lines": "567-582",
          "snippet": "static void\nxfs_dir2_block_log_leaf(\n\txfs_trans_t\t\t*tp,\t\t/* transaction structure */\n\tstruct xfs_buf\t\t*bp,\t\t/* block buffer */\n\tint\t\t\tfirst,\t\t/* index of first logged leaf */\n\tint\t\t\tlast)\t\t/* index of last logged leaf */\n{\n\txfs_dir2_data_hdr_t\t*hdr = bp->b_addr;\n\txfs_dir2_leaf_entry_t\t*blp;\n\txfs_dir2_block_tail_t\t*btp;\n\n\tbtp = xfs_dir2_block_tail_p(tp->t_mountp->m_dir_geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\txfs_trans_log_buf(tp, bp, (uint)((char *)&blp[first] - (char *)hdr),\n\t\t(uint)((char *)&blp[last + 1] - (char *)hdr - 1));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir2_block_log_leaf(xfs_trans_t *tp, struct xfs_buf *bp,\n\t\t\t\t    int first, int last);",
            "static void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_block_log_leaf(xfs_trans_t *tp, struct xfs_buf *bp,\n\t\t\t\t    int first, int last);\nstatic void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);\n\nstatic void\nxfs_dir2_block_log_leaf(\n\txfs_trans_t\t\t*tp,\t\t/* transaction structure */\n\tstruct xfs_buf\t\t*bp,\t\t/* block buffer */\n\tint\t\t\tfirst,\t\t/* index of first logged leaf */\n\tint\t\t\tlast)\t\t/* index of last logged leaf */\n{\n\txfs_dir2_data_hdr_t\t*hdr = bp->b_addr;\n\txfs_dir2_leaf_entry_t\t*blp;\n\txfs_dir2_block_tail_t\t*btp;\n\n\tbtp = xfs_dir2_block_tail_p(tp->t_mountp->m_dir_geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\txfs_trans_log_buf(tp, bp, (uint)((char *)&blp[first] - (char *)hdr),\n\t\t(uint)((char *)&blp[last + 1] - (char *)hdr - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_NULL_DATAPTR"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_log_tail",
          "args": [
            "tp",
            "bp"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_log_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
          "lines": "587-598",
          "snippet": "static void\nxfs_dir2_block_log_tail(\n\txfs_trans_t\t\t*tp,\t\t/* transaction structure */\n\tstruct xfs_buf\t\t*bp)\t\t/* block buffer */\n{\n\txfs_dir2_data_hdr_t\t*hdr = bp->b_addr;\n\txfs_dir2_block_tail_t\t*btp;\n\n\tbtp = xfs_dir2_block_tail_p(tp->t_mountp->m_dir_geo, hdr);\n\txfs_trans_log_buf(tp, bp, (uint)((char *)btp - (char *)hdr),\n\t\t(uint)((char *)(btp + 1) - (char *)hdr - 1));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);\n\nstatic void\nxfs_dir2_block_log_tail(\n\txfs_trans_t\t\t*tp,\t\t/* transaction structure */\n\tstruct xfs_buf\t\t*bp)\t\t/* block buffer */\n{\n\txfs_dir2_data_hdr_t\t*hdr = bp->b_addr;\n\txfs_dir2_block_tail_t\t*btp;\n\n\tbtp = xfs_dir2_block_tail_p(tp->t_mountp->m_dir_geo, hdr);\n\txfs_trans_log_buf(tp, bp, (uint)((char *)btp - (char *)hdr),\n\t\t(uint)((char *)(btp + 1) - (char *)hdr - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_add_cpu",
          "args": [
            "&btp->stale",
            "1"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_make_free",
          "args": [
            "args",
            "bp",
            "(xfs_dir2_data_aoff_t)((char *)dep - (char *)hdr)",
            "dp->d_ops->data_entsize(dep->namelen)",
            "&needlog",
            "&needscan"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_make_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "714-894",
          "snippet": "void\nxfs_dir2_data_make_free(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_aoff_t\toffset,\t\t/* starting byte offset */\n\txfs_dir2_data_aoff_t\tlen,\t\t/* length in bytes */\n\tint\t\t\t*needlogp,\t/* out: log header */\n\tint\t\t\t*needscanp)\t/* out: regen bestfree */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block pointer */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree pointer */\n\tchar\t\t\t*endptr;\t/* end of data area */\n\tint\t\t\tneedscan;\t/* need to regen bestfree */\n\txfs_dir2_data_unused_t\t*newdup;\t/* new unused entry */\n\txfs_dir2_data_unused_t\t*postdup;\t/* unused entry after us */\n\txfs_dir2_data_unused_t\t*prevdup;\t/* unused entry before us */\n\tstruct xfs_dir2_data_free *bf;\n\n\thdr = bp->b_addr;\n\n\t/*\n\t * Figure out where the end of the data area is.\n\t */\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC))\n\t\tendptr = (char *)hdr + args->geo->blksize;\n\telse {\n\t\txfs_dir2_block_tail_t\t*btp;\t/* block tail */\n\n\t\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t\t\thdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\t\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\t\tendptr = (char *)xfs_dir2_block_leaf_p(btp);\n\t}\n\t/*\n\t * If this isn't the start of the block, then back up to\n\t * the previous entry and see if it's free.\n\t */\n\tif (offset > args->dp->d_ops->data_entry_offset) {\n\t\t__be16\t\t\t*tagp;\t/* tag just before us */\n\n\t\ttagp = (__be16 *)((char *)hdr + offset) - 1;\n\t\tprevdup = (xfs_dir2_data_unused_t *)((char *)hdr + be16_to_cpu(*tagp));\n\t\tif (be16_to_cpu(prevdup->freetag) != XFS_DIR2_DATA_FREE_TAG)\n\t\t\tprevdup = NULL;\n\t} else\n\t\tprevdup = NULL;\n\t/*\n\t * If this isn't the end of the block, see if the entry after\n\t * us is free.\n\t */\n\tif ((char *)hdr + offset + len < endptr) {\n\t\tpostdup =\n\t\t\t(xfs_dir2_data_unused_t *)((char *)hdr + offset + len);\n\t\tif (be16_to_cpu(postdup->freetag) != XFS_DIR2_DATA_FREE_TAG)\n\t\t\tpostdup = NULL;\n\t} else\n\t\tpostdup = NULL;\n\tASSERT(*needscanp == 0);\n\tneedscan = 0;\n\t/*\n\t * Previous and following entries are both free,\n\t * merge everything into a single free entry.\n\t */\n\tbf = args->dp->d_ops->data_bestfree_p(hdr);\n\tif (prevdup && postdup) {\n\t\txfs_dir2_data_free_t\t*dfp2;\t/* another bestfree pointer */\n\n\t\t/*\n\t\t * See if prevdup and/or postdup are in bestfree table.\n\t\t */\n\t\tdfp = xfs_dir2_data_freefind(hdr, bf, prevdup);\n\t\tdfp2 = xfs_dir2_data_freefind(hdr, bf, postdup);\n\t\t/*\n\t\t * We need a rescan unless there are exactly 2 free entries\n\t\t * namely our two.  Then we know what's happening, otherwise\n\t\t * since the third bestfree is there, there might be more\n\t\t * entries.\n\t\t */\n\t\tneedscan = (bf[2].length != 0);\n\t\t/*\n\t\t * Fix up the new big freespace.\n\t\t */\n\t\tbe16_add_cpu(&prevdup->length, len + be16_to_cpu(postdup->length));\n\t\t*xfs_dir2_data_unused_tag_p(prevdup) =\n\t\t\tcpu_to_be16((char *)prevdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, prevdup);\n\t\tif (!needscan) {\n\t\t\t/*\n\t\t\t * Has to be the case that entries 0 and 1 are\n\t\t\t * dfp and dfp2 (don't know which is which), and\n\t\t\t * entry 2 is empty.\n\t\t\t * Remove entry 1 first then entry 0.\n\t\t\t */\n\t\t\tASSERT(dfp && dfp2);\n\t\t\tif (dfp == &bf[1]) {\n\t\t\t\tdfp = &bf[0];\n\t\t\t\tASSERT(dfp2 == dfp);\n\t\t\t\tdfp2 = &bf[1];\n\t\t\t}\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp2, needlogp);\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\t/*\n\t\t\t * Now insert the new entry.\n\t\t\t */\n\t\t\tdfp = xfs_dir2_data_freeinsert(hdr, bf, prevdup,\n\t\t\t\t\t\t       needlogp);\n\t\t\tASSERT(dfp == &bf[0]);\n\t\t\tASSERT(dfp->length == prevdup->length);\n\t\t\tASSERT(!dfp[1].length);\n\t\t\tASSERT(!dfp[2].length);\n\t\t}\n\t}\n\t/*\n\t * The entry before us is free, merge with it.\n\t */\n\telse if (prevdup) {\n\t\tdfp = xfs_dir2_data_freefind(hdr, bf, prevdup);\n\t\tbe16_add_cpu(&prevdup->length, len);\n\t\t*xfs_dir2_data_unused_tag_p(prevdup) =\n\t\t\tcpu_to_be16((char *)prevdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, prevdup);\n\t\t/*\n\t\t * If the previous entry was in the table, the new entry\n\t\t * is longer, so it will be in the table too.  Remove\n\t\t * the old one and add the new one.\n\t\t */\n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\txfs_dir2_data_freeinsert(hdr, bf, prevdup, needlogp);\n\t\t}\n\t\t/*\n\t\t * Otherwise we need a scan if the new entry is big enough.\n\t\t */\n\t\telse {\n\t\t\tneedscan = be16_to_cpu(prevdup->length) >\n\t\t\t\t   be16_to_cpu(bf[2].length);\n\t\t}\n\t}\n\t/*\n\t * The following entry is free, merge with it.\n\t */\n\telse if (postdup) {\n\t\tdfp = xfs_dir2_data_freefind(hdr, bf, postdup);\n\t\tnewdup = (xfs_dir2_data_unused_t *)((char *)hdr + offset);\n\t\tnewdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup->length = cpu_to_be16(len + be16_to_cpu(postdup->length));\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\t/*\n\t\t * If the following entry was in the table, the new entry\n\t\t * is longer, so it will be in the table too.  Remove\n\t\t * the old one and add the new one.\n\t\t */\n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\txfs_dir2_data_freeinsert(hdr, bf, newdup, needlogp);\n\t\t}\n\t\t/*\n\t\t * Otherwise we need a scan if the new entry is big enough.\n\t\t */\n\t\telse {\n\t\t\tneedscan = be16_to_cpu(newdup->length) >\n\t\t\t\t   be16_to_cpu(bf[2].length);\n\t\t}\n\t}\n\t/*\n\t * Neither neighbor is free.  Make a new entry.\n\t */\n\telse {\n\t\tnewdup = (xfs_dir2_data_unused_t *)((char *)hdr + offset);\n\t\tnewdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup->length = cpu_to_be16(len);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\txfs_dir2_data_freeinsert(hdr, bf, newdup, needlogp);\n\t}\n\t*needscanp = needscan;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dir2_data_make_free(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_aoff_t\toffset,\t\t/* starting byte offset */\n\txfs_dir2_data_aoff_t\tlen,\t\t/* length in bytes */\n\tint\t\t\t*needlogp,\t/* out: log header */\n\tint\t\t\t*needscanp)\t/* out: regen bestfree */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block pointer */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree pointer */\n\tchar\t\t\t*endptr;\t/* end of data area */\n\tint\t\t\tneedscan;\t/* need to regen bestfree */\n\txfs_dir2_data_unused_t\t*newdup;\t/* new unused entry */\n\txfs_dir2_data_unused_t\t*postdup;\t/* unused entry after us */\n\txfs_dir2_data_unused_t\t*prevdup;\t/* unused entry before us */\n\tstruct xfs_dir2_data_free *bf;\n\n\thdr = bp->b_addr;\n\n\t/*\n\t * Figure out where the end of the data area is.\n\t */\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC))\n\t\tendptr = (char *)hdr + args->geo->blksize;\n\telse {\n\t\txfs_dir2_block_tail_t\t*btp;\t/* block tail */\n\n\t\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t\t\thdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\t\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\t\tendptr = (char *)xfs_dir2_block_leaf_p(btp);\n\t}\n\t/*\n\t * If this isn't the start of the block, then back up to\n\t * the previous entry and see if it's free.\n\t */\n\tif (offset > args->dp->d_ops->data_entry_offset) {\n\t\t__be16\t\t\t*tagp;\t/* tag just before us */\n\n\t\ttagp = (__be16 *)((char *)hdr + offset) - 1;\n\t\tprevdup = (xfs_dir2_data_unused_t *)((char *)hdr + be16_to_cpu(*tagp));\n\t\tif (be16_to_cpu(prevdup->freetag) != XFS_DIR2_DATA_FREE_TAG)\n\t\t\tprevdup = NULL;\n\t} else\n\t\tprevdup = NULL;\n\t/*\n\t * If this isn't the end of the block, see if the entry after\n\t * us is free.\n\t */\n\tif ((char *)hdr + offset + len < endptr) {\n\t\tpostdup =\n\t\t\t(xfs_dir2_data_unused_t *)((char *)hdr + offset + len);\n\t\tif (be16_to_cpu(postdup->freetag) != XFS_DIR2_DATA_FREE_TAG)\n\t\t\tpostdup = NULL;\n\t} else\n\t\tpostdup = NULL;\n\tASSERT(*needscanp == 0);\n\tneedscan = 0;\n\t/*\n\t * Previous and following entries are both free,\n\t * merge everything into a single free entry.\n\t */\n\tbf = args->dp->d_ops->data_bestfree_p(hdr);\n\tif (prevdup && postdup) {\n\t\txfs_dir2_data_free_t\t*dfp2;\t/* another bestfree pointer */\n\n\t\t/*\n\t\t * See if prevdup and/or postdup are in bestfree table.\n\t\t */\n\t\tdfp = xfs_dir2_data_freefind(hdr, bf, prevdup);\n\t\tdfp2 = xfs_dir2_data_freefind(hdr, bf, postdup);\n\t\t/*\n\t\t * We need a rescan unless there are exactly 2 free entries\n\t\t * namely our two.  Then we know what's happening, otherwise\n\t\t * since the third bestfree is there, there might be more\n\t\t * entries.\n\t\t */\n\t\tneedscan = (bf[2].length != 0);\n\t\t/*\n\t\t * Fix up the new big freespace.\n\t\t */\n\t\tbe16_add_cpu(&prevdup->length, len + be16_to_cpu(postdup->length));\n\t\t*xfs_dir2_data_unused_tag_p(prevdup) =\n\t\t\tcpu_to_be16((char *)prevdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, prevdup);\n\t\tif (!needscan) {\n\t\t\t/*\n\t\t\t * Has to be the case that entries 0 and 1 are\n\t\t\t * dfp and dfp2 (don't know which is which), and\n\t\t\t * entry 2 is empty.\n\t\t\t * Remove entry 1 first then entry 0.\n\t\t\t */\n\t\t\tASSERT(dfp && dfp2);\n\t\t\tif (dfp == &bf[1]) {\n\t\t\t\tdfp = &bf[0];\n\t\t\t\tASSERT(dfp2 == dfp);\n\t\t\t\tdfp2 = &bf[1];\n\t\t\t}\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp2, needlogp);\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\t/*\n\t\t\t * Now insert the new entry.\n\t\t\t */\n\t\t\tdfp = xfs_dir2_data_freeinsert(hdr, bf, prevdup,\n\t\t\t\t\t\t       needlogp);\n\t\t\tASSERT(dfp == &bf[0]);\n\t\t\tASSERT(dfp->length == prevdup->length);\n\t\t\tASSERT(!dfp[1].length);\n\t\t\tASSERT(!dfp[2].length);\n\t\t}\n\t}\n\t/*\n\t * The entry before us is free, merge with it.\n\t */\n\telse if (prevdup) {\n\t\tdfp = xfs_dir2_data_freefind(hdr, bf, prevdup);\n\t\tbe16_add_cpu(&prevdup->length, len);\n\t\t*xfs_dir2_data_unused_tag_p(prevdup) =\n\t\t\tcpu_to_be16((char *)prevdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, prevdup);\n\t\t/*\n\t\t * If the previous entry was in the table, the new entry\n\t\t * is longer, so it will be in the table too.  Remove\n\t\t * the old one and add the new one.\n\t\t */\n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\txfs_dir2_data_freeinsert(hdr, bf, prevdup, needlogp);\n\t\t}\n\t\t/*\n\t\t * Otherwise we need a scan if the new entry is big enough.\n\t\t */\n\t\telse {\n\t\t\tneedscan = be16_to_cpu(prevdup->length) >\n\t\t\t\t   be16_to_cpu(bf[2].length);\n\t\t}\n\t}\n\t/*\n\t * The following entry is free, merge with it.\n\t */\n\telse if (postdup) {\n\t\tdfp = xfs_dir2_data_freefind(hdr, bf, postdup);\n\t\tnewdup = (xfs_dir2_data_unused_t *)((char *)hdr + offset);\n\t\tnewdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup->length = cpu_to_be16(len + be16_to_cpu(postdup->length));\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\t/*\n\t\t * If the following entry was in the table, the new entry\n\t\t * is longer, so it will be in the table too.  Remove\n\t\t * the old one and add the new one.\n\t\t */\n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\txfs_dir2_data_freeinsert(hdr, bf, newdup, needlogp);\n\t\t}\n\t\t/*\n\t\t * Otherwise we need a scan if the new entry is big enough.\n\t\t */\n\t\telse {\n\t\t\tneedscan = be16_to_cpu(newdup->length) >\n\t\t\t\t   be16_to_cpu(bf[2].length);\n\t\t}\n\t}\n\t/*\n\t * Neither neighbor is free.  Make a new entry.\n\t */\n\telse {\n\t\tnewdup = (xfs_dir2_data_unused_t *)((char *)hdr + offset);\n\t\tnewdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup->length = cpu_to_be16(len);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\txfs_dir2_data_freeinsert(hdr, bf, newdup, needlogp);\n\t}\n\t*needscanp = needscan;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_entsize",
          "args": [
            "dep->namelen"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(char *)dep - (char *)hdr"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_dataptr_to_off",
          "args": [
            "args->geo",
            "be32_to_cpu(blp[ent].address)"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_dataptr_to_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "240-244",
          "snippet": "static inline xfs_dir2_data_aoff_t\nxfs_dir2_dataptr_to_off(struct xfs_da_geometry *geo, xfs_dir2_dataptr_t dp)\n{\n\treturn xfs_dir2_byte_to_off(geo, xfs_dir2_dataptr_to_byte(dp));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_data_aoff_t\nxfs_dir2_dataptr_to_off(struct xfs_da_geometry *geo, xfs_dir2_dataptr_t dp)\n{\n\treturn xfs_dir2_byte_to_off(geo, xfs_dir2_dataptr_to_byte(dp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "blp[ent].address"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_leaf_p",
          "args": [
            "btp"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_leaf_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "601-605",
          "snippet": "static inline struct xfs_dir2_leaf_entry *\nxfs_dir2_block_leaf_p(struct xfs_dir2_block_tail *btp)\n{\n\treturn ((struct xfs_dir2_leaf_entry *)btp) - be32_to_cpu(btp->count);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_leaf_entry *\nxfs_dir2_block_leaf_p(struct xfs_dir2_block_tail *btp)\n{\n\treturn ((struct xfs_dir2_leaf_entry *)btp) - be32_to_cpu(btp->count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_tail_p",
          "args": [
            "args->geo",
            "hdr"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_tail_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "305-310",
          "snippet": "static inline struct xfs_dir2_block_tail *\nxfs_dir2_block_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_data_hdr *hdr)\n{\n\treturn ((struct xfs_dir2_block_tail *)\n\t\t((char *)hdr + geo->blksize)) - 1;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_block_tail *\nxfs_dir2_block_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_data_hdr *hdr)\n{\n\treturn ((struct xfs_dir2_block_tail *)\n\t\t((char *)hdr + geo->blksize)) - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_lookup_int",
          "args": [
            "args",
            "&bp",
            "&ent"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_lookup_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
          "lines": "649-748",
          "snippet": "static int\t\t\t\t\t/* error */\nxfs_dir2_block_lookup_int(\n\txfs_da_args_t\t\t*args,\t\t/* dir lookup arguments */\n\tstruct xfs_buf\t\t**bpp,\t\t/* returned block buffer */\n\tint\t\t\t*entno)\t\t/* returned entry number */\n{\n\txfs_dir2_dataptr_t\taddr;\t\t/* data entry address */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* block leaf entries */\n\tstruct xfs_buf\t\t*bp;\t\t/* block buffer */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* block data entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore inode */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_dahash_t\t\thash;\t\t/* found hash value */\n\tint\t\t\thigh;\t\t/* binary search high index */\n\tint\t\t\tlow;\t\t/* binary search low index */\n\tint\t\t\tmid;\t\t/* binary search current idx */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tenum xfs_dacmp\t\tcmp;\t\t/* comparison result */\n\n\tdp = args->dp;\n\ttp = args->trans;\n\tmp = dp->i_mount;\n\n\terror = xfs_dir3_block_read(tp, dp, &bp);\n\tif (error)\n\t\treturn error;\n\n\thdr = bp->b_addr;\n\txfs_dir3_data_check(dp, bp);\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\t/*\n\t * Loop doing a binary search for our hash value.\n\t * Find our entry, ENOENT if it's not there.\n\t */\n\tfor (low = 0, high = be32_to_cpu(btp->count) - 1; ; ) {\n\t\tASSERT(low <= high);\n\t\tmid = (low + high) >> 1;\n\t\tif ((hash = be32_to_cpu(blp[mid].hashval)) == args->hashval)\n\t\t\tbreak;\n\t\tif (hash < args->hashval)\n\t\t\tlow = mid + 1;\n\t\telse\n\t\t\thigh = mid - 1;\n\t\tif (low > high) {\n\t\t\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\t/*\n\t * Back up to the first one with the right hash value.\n\t */\n\twhile (mid > 0 && be32_to_cpu(blp[mid - 1].hashval) == args->hashval) {\n\t\tmid--;\n\t}\n\t/*\n\t * Now loop forward through all the entries with the\n\t * right hash value looking for our name.\n\t */\n\tdo {\n\t\tif ((addr = be32_to_cpu(blp[mid].address)) == XFS_DIR2_NULL_DATAPTR)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Get pointer to the entry from the leaf.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)\n\t\t\t((char *)hdr + xfs_dir2_dataptr_to_off(args->geo, addr));\n\t\t/*\n\t\t * Compare name and if it's an exact match, return the index\n\t\t * and buffer. If it's the first case-insensitive match, store\n\t\t * the index and buffer and continue looking for an exact match.\n\t\t */\n\t\tcmp = mp->m_dirnameops->compname(args, dep->name, dep->namelen);\n\t\tif (cmp != XFS_CMP_DIFFERENT && cmp != args->cmpresult) {\n\t\t\targs->cmpresult = cmp;\n\t\t\t*bpp = bp;\n\t\t\t*entno = mid;\n\t\t\tif (cmp == XFS_CMP_EXACT)\n\t\t\t\treturn 0;\n\t\t}\n\t} while (++mid < be32_to_cpu(btp->count) &&\n\t\t\tbe32_to_cpu(blp[mid].hashval) == hash);\n\n\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\t/*\n\t * Here, we can only be doing a lookup (not a rename or replace).\n\t * If a case-insensitive match was found earlier, return success.\n\t */\n\tif (args->cmpresult == XFS_CMP_CASE)\n\t\treturn 0;\n\t/*\n\t * No match, release the buffer and return ENOENT.\n\t */\n\txfs_trans_brelse(tp, bp);\n\treturn -ENOENT;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);",
            "static int xfs_dir2_block_lookup_int(xfs_da_args_t *args, struct xfs_buf **bpp,\n\t\t\t\t     int *entno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);\nstatic int xfs_dir2_block_lookup_int(xfs_da_args_t *args, struct xfs_buf **bpp,\n\t\t\t\t     int *entno);\n\nstatic int\t\t\t\t\t/* error */\nxfs_dir2_block_lookup_int(\n\txfs_da_args_t\t\t*args,\t\t/* dir lookup arguments */\n\tstruct xfs_buf\t\t**bpp,\t\t/* returned block buffer */\n\tint\t\t\t*entno)\t\t/* returned entry number */\n{\n\txfs_dir2_dataptr_t\taddr;\t\t/* data entry address */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* block leaf entries */\n\tstruct xfs_buf\t\t*bp;\t\t/* block buffer */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* block data entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore inode */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_dahash_t\t\thash;\t\t/* found hash value */\n\tint\t\t\thigh;\t\t/* binary search high index */\n\tint\t\t\tlow;\t\t/* binary search low index */\n\tint\t\t\tmid;\t\t/* binary search current idx */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tenum xfs_dacmp\t\tcmp;\t\t/* comparison result */\n\n\tdp = args->dp;\n\ttp = args->trans;\n\tmp = dp->i_mount;\n\n\terror = xfs_dir3_block_read(tp, dp, &bp);\n\tif (error)\n\t\treturn error;\n\n\thdr = bp->b_addr;\n\txfs_dir3_data_check(dp, bp);\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\t/*\n\t * Loop doing a binary search for our hash value.\n\t * Find our entry, ENOENT if it's not there.\n\t */\n\tfor (low = 0, high = be32_to_cpu(btp->count) - 1; ; ) {\n\t\tASSERT(low <= high);\n\t\tmid = (low + high) >> 1;\n\t\tif ((hash = be32_to_cpu(blp[mid].hashval)) == args->hashval)\n\t\t\tbreak;\n\t\tif (hash < args->hashval)\n\t\t\tlow = mid + 1;\n\t\telse\n\t\t\thigh = mid - 1;\n\t\tif (low > high) {\n\t\t\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\t/*\n\t * Back up to the first one with the right hash value.\n\t */\n\twhile (mid > 0 && be32_to_cpu(blp[mid - 1].hashval) == args->hashval) {\n\t\tmid--;\n\t}\n\t/*\n\t * Now loop forward through all the entries with the\n\t * right hash value looking for our name.\n\t */\n\tdo {\n\t\tif ((addr = be32_to_cpu(blp[mid].address)) == XFS_DIR2_NULL_DATAPTR)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Get pointer to the entry from the leaf.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)\n\t\t\t((char *)hdr + xfs_dir2_dataptr_to_off(args->geo, addr));\n\t\t/*\n\t\t * Compare name and if it's an exact match, return the index\n\t\t * and buffer. If it's the first case-insensitive match, store\n\t\t * the index and buffer and continue looking for an exact match.\n\t\t */\n\t\tcmp = mp->m_dirnameops->compname(args, dep->name, dep->namelen);\n\t\tif (cmp != XFS_CMP_DIFFERENT && cmp != args->cmpresult) {\n\t\t\targs->cmpresult = cmp;\n\t\t\t*bpp = bp;\n\t\t\t*entno = mid;\n\t\t\tif (cmp == XFS_CMP_EXACT)\n\t\t\t\treturn 0;\n\t\t}\n\t} while (++mid < be32_to_cpu(btp->count) &&\n\t\t\tbe32_to_cpu(blp[mid].hashval) == hash);\n\n\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\t/*\n\t * Here, we can only be doing a lookup (not a rename or replace).\n\t * If a case-insensitive match was found earlier, return success.\n\t */\n\tif (args->cmpresult == XFS_CMP_CASE)\n\t\treturn 0;\n\t/*\n\t * No match, release the buffer and return ENOENT.\n\t */\n\txfs_trans_brelse(tp, bp);\n\treturn -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_dir2_block_removename",
          "args": [
            "args"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_block_removename(\n\txfs_da_args_t\t\t*args)\t\t/* directory operation args */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* block leaf pointer */\n\tstruct xfs_buf\t\t*bp;\t\t/* block buffer */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* block data entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore inode */\n\tint\t\t\tent;\t\t/* block leaf entry index */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tneedlog;\t/* need to log block header */\n\tint\t\t\tneedscan;\t/* need to fixup bestfree */\n\txfs_dir2_sf_hdr_t\tsfh;\t\t/* shortform header */\n\tint\t\t\tsize;\t\t/* shortform size */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\n\ttrace_xfs_dir2_block_removename(args);\n\n\t/*\n\t * Look up the entry in the block.  Gets the buffer and entry index.\n\t * It will always be there, the vnodeops level does a lookup first.\n\t */\n\tif ((error = xfs_dir2_block_lookup_int(args, &bp, &ent))) {\n\t\treturn error;\n\t}\n\tdp = args->dp;\n\ttp = args->trans;\n\thdr = bp->b_addr;\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\t/*\n\t * Point to the data entry using the leaf entry.\n\t */\n\tdep = (xfs_dir2_data_entry_t *)((char *)hdr +\n\t\t\txfs_dir2_dataptr_to_off(args->geo,\n\t\t\t\t\t\tbe32_to_cpu(blp[ent].address)));\n\t/*\n\t * Mark the data entry's space free.\n\t */\n\tneedlog = needscan = 0;\n\txfs_dir2_data_make_free(args, bp,\n\t\t(xfs_dir2_data_aoff_t)((char *)dep - (char *)hdr),\n\t\tdp->d_ops->data_entsize(dep->namelen), &needlog, &needscan);\n\t/*\n\t * Fix up the block tail.\n\t */\n\tbe32_add_cpu(&btp->stale, 1);\n\txfs_dir2_block_log_tail(tp, bp);\n\t/*\n\t * Remove the leaf entry by marking it stale.\n\t */\n\tblp[ent].address = cpu_to_be32(XFS_DIR2_NULL_DATAPTR);\n\txfs_dir2_block_log_leaf(tp, bp, ent, ent);\n\t/*\n\t * Fix up bestfree, log the header if necessary.\n\t */\n\tif (needscan)\n\t\txfs_dir2_data_freescan(dp, hdr, &needlog);\n\tif (needlog)\n\t\txfs_dir2_data_log_header(args, bp);\n\txfs_dir3_data_check(dp, bp);\n\t/*\n\t * See if the size as a shortform is good enough.\n\t */\n\tsize = xfs_dir2_block_sfsize(dp, hdr, &sfh);\n\tif (size > XFS_IFORK_DSIZE(dp))\n\t\treturn 0;\n\n\t/*\n\t * If it works, do the conversion.\n\t */\n\treturn xfs_dir2_block_to_sf(args, bp, size, &sfh);\n}"
  },
  {
    "function_name": "xfs_dir2_block_lookup_int",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
    "lines": "649-748",
    "snippet": "static int\t\t\t\t\t/* error */\nxfs_dir2_block_lookup_int(\n\txfs_da_args_t\t\t*args,\t\t/* dir lookup arguments */\n\tstruct xfs_buf\t\t**bpp,\t\t/* returned block buffer */\n\tint\t\t\t*entno)\t\t/* returned entry number */\n{\n\txfs_dir2_dataptr_t\taddr;\t\t/* data entry address */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* block leaf entries */\n\tstruct xfs_buf\t\t*bp;\t\t/* block buffer */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* block data entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore inode */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_dahash_t\t\thash;\t\t/* found hash value */\n\tint\t\t\thigh;\t\t/* binary search high index */\n\tint\t\t\tlow;\t\t/* binary search low index */\n\tint\t\t\tmid;\t\t/* binary search current idx */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tenum xfs_dacmp\t\tcmp;\t\t/* comparison result */\n\n\tdp = args->dp;\n\ttp = args->trans;\n\tmp = dp->i_mount;\n\n\terror = xfs_dir3_block_read(tp, dp, &bp);\n\tif (error)\n\t\treturn error;\n\n\thdr = bp->b_addr;\n\txfs_dir3_data_check(dp, bp);\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\t/*\n\t * Loop doing a binary search for our hash value.\n\t * Find our entry, ENOENT if it's not there.\n\t */\n\tfor (low = 0, high = be32_to_cpu(btp->count) - 1; ; ) {\n\t\tASSERT(low <= high);\n\t\tmid = (low + high) >> 1;\n\t\tif ((hash = be32_to_cpu(blp[mid].hashval)) == args->hashval)\n\t\t\tbreak;\n\t\tif (hash < args->hashval)\n\t\t\tlow = mid + 1;\n\t\telse\n\t\t\thigh = mid - 1;\n\t\tif (low > high) {\n\t\t\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\t/*\n\t * Back up to the first one with the right hash value.\n\t */\n\twhile (mid > 0 && be32_to_cpu(blp[mid - 1].hashval) == args->hashval) {\n\t\tmid--;\n\t}\n\t/*\n\t * Now loop forward through all the entries with the\n\t * right hash value looking for our name.\n\t */\n\tdo {\n\t\tif ((addr = be32_to_cpu(blp[mid].address)) == XFS_DIR2_NULL_DATAPTR)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Get pointer to the entry from the leaf.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)\n\t\t\t((char *)hdr + xfs_dir2_dataptr_to_off(args->geo, addr));\n\t\t/*\n\t\t * Compare name and if it's an exact match, return the index\n\t\t * and buffer. If it's the first case-insensitive match, store\n\t\t * the index and buffer and continue looking for an exact match.\n\t\t */\n\t\tcmp = mp->m_dirnameops->compname(args, dep->name, dep->namelen);\n\t\tif (cmp != XFS_CMP_DIFFERENT && cmp != args->cmpresult) {\n\t\t\targs->cmpresult = cmp;\n\t\t\t*bpp = bp;\n\t\t\t*entno = mid;\n\t\t\tif (cmp == XFS_CMP_EXACT)\n\t\t\t\treturn 0;\n\t\t}\n\t} while (++mid < be32_to_cpu(btp->count) &&\n\t\t\tbe32_to_cpu(blp[mid].hashval) == hash);\n\n\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\t/*\n\t * Here, we can only be doing a lookup (not a rename or replace).\n\t * If a case-insensitive match was found earlier, return success.\n\t */\n\tif (args->cmpresult == XFS_CMP_CASE)\n\t\treturn 0;\n\t/*\n\t * No match, release the buffer and return ENOENT.\n\t */\n\txfs_trans_brelse(tp, bp);\n\treturn -ENOENT;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);",
      "static int xfs_dir2_block_lookup_int(xfs_da_args_t *args, struct xfs_buf **bpp,\n\t\t\t\t     int *entno);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "tp",
            "bp"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args->op_flags & XFS_DA_OP_OKNOENT"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "blp[mid].hashval"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btp->count"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mp->m_dirnameops->compname",
          "args": [
            "args",
            "dep->name",
            "dep->namelen"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_dataptr_to_off",
          "args": [
            "args->geo",
            "addr"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_dataptr_to_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "240-244",
          "snippet": "static inline xfs_dir2_data_aoff_t\nxfs_dir2_dataptr_to_off(struct xfs_da_geometry *geo, xfs_dir2_dataptr_t dp)\n{\n\treturn xfs_dir2_byte_to_off(geo, xfs_dir2_dataptr_to_byte(dp));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_data_aoff_t\nxfs_dir2_dataptr_to_off(struct xfs_da_geometry *geo, xfs_dir2_dataptr_t dp)\n{\n\treturn xfs_dir2_byte_to_off(geo, xfs_dir2_dataptr_to_byte(dp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "blp[mid].address"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "blp[mid - 1].hashval"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args->op_flags & XFS_DA_OP_OKNOENT"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "blp[mid].hashval"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "low <= high"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btp->count"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_leaf_p",
          "args": [
            "btp"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_leaf_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "601-605",
          "snippet": "static inline struct xfs_dir2_leaf_entry *\nxfs_dir2_block_leaf_p(struct xfs_dir2_block_tail *btp)\n{\n\treturn ((struct xfs_dir2_leaf_entry *)btp) - be32_to_cpu(btp->count);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_leaf_entry *\nxfs_dir2_block_leaf_p(struct xfs_dir2_block_tail *btp)\n{\n\treturn ((struct xfs_dir2_leaf_entry *)btp) - be32_to_cpu(btp->count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_tail_p",
          "args": [
            "args->geo",
            "hdr"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_tail_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "305-310",
          "snippet": "static inline struct xfs_dir2_block_tail *\nxfs_dir2_block_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_data_hdr *hdr)\n{\n\treturn ((struct xfs_dir2_block_tail *)\n\t\t((char *)hdr + geo->blksize)) - 1;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_block_tail *\nxfs_dir2_block_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_data_hdr *hdr)\n{\n\treturn ((struct xfs_dir2_block_tail *)\n\t\t((char *)hdr + geo->blksize)) - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir3_data_check",
          "args": [
            "dp",
            "bp"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "__xfs_dir3_data_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "40-210",
          "snippet": "int\n__xfs_dir3_data_check(\n\tstruct xfs_inode\t*dp,\t\t/* incore inode pointer */\n\tstruct xfs_buf\t\t*bp)\t\t/* data block's buffer */\n{\n\txfs_dir2_dataptr_t\taddr;\t\t/* addr for leaf lookup */\n\txfs_dir2_data_free_t\t*bf;\t\t/* bestfree table */\n\txfs_dir2_block_tail_t\t*btp=NULL;\t/* block tail */\n\tint\t\t\tcount;\t\t/* count of entries found */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry */\n\tchar\t\t\t*endp;\t\t/* end of useful data */\n\tint\t\t\tfreeseen;\t/* mask of bestfrees seen */\n\txfs_dahash_t\t\thash;\t\t/* hash of current name */\n\tint\t\t\ti;\t\t/* leaf index */\n\tint\t\t\tlastfree;\t/* last entry was unused */\n\txfs_dir2_leaf_entry_t\t*lep=NULL;\t/* block leaf entries */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tchar\t\t\t*p;\t\t/* current data position */\n\tint\t\t\tstale;\t\t/* count of stale leaves */\n\tstruct xfs_name\t\tname;\n\tconst struct xfs_dir_ops *ops;\n\tstruct xfs_da_geometry\t*geo;\n\n\tmp = bp->b_target->bt_mount;\n\tgeo = mp->m_dir_geo;\n\n\t/*\n\t * We can be passed a null dp here from a verifier, so we need to go the\n\t * hard way to get them.\n\t */\n\tops = xfs_dir_get_ops(mp, dp);\n\n\thdr = bp->b_addr;\n\tp = (char *)ops->data_entry_p(hdr);\n\n\tswitch (hdr->magic) {\n\tcase cpu_to_be32(XFS_DIR3_BLOCK_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_BLOCK_MAGIC):\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tlep = xfs_dir2_block_leaf_p(btp);\n\t\tendp = (char *)lep;\n\n\t\t/*\n\t\t * The number of leaf entries is limited by the size of the\n\t\t * block and the amount of space used by the data entries.\n\t\t * We don't know how much space is used by the data entries yet,\n\t\t * so just ensure that the count falls somewhere inside the\n\t\t * block right now.\n\t\t */\n\t\tXFS_WANT_CORRUPTED_RETURN(be32_to_cpu(btp->count) <\n\t\t\t((char *)btp - p) / sizeof(struct xfs_dir2_leaf_entry));\n\t\tbreak;\n\tcase cpu_to_be32(XFS_DIR3_DATA_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_DATA_MAGIC):\n\t\tendp = (char *)hdr + geo->blksize;\n\t\tbreak;\n\tdefault:\n\t\tXFS_ERROR_REPORT(\"Bad Magic\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/*\n\t * Account for zero bestfree entries.\n\t */\n\tbf = ops->data_bestfree_p(hdr);\n\tcount = lastfree = freeseen = 0;\n\tif (!bf[0].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[0].offset);\n\t\tfreeseen |= 1 << 0;\n\t}\n\tif (!bf[1].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[1].offset);\n\t\tfreeseen |= 1 << 1;\n\t}\n\tif (!bf[2].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[2].offset);\n\t\tfreeseen |= 1 << 2;\n\t}\n\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[0].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[1].length));\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[1].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t/*\n\t * Loop over the data/unused entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's unused, look for the space in the bestfree table.\n\t\t * If we find it, account for that, else make sure it\n\t\t * doesn't need to be there.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tXFS_WANT_CORRUPTED_RETURN(lastfree == 0);\n\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tbe16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)) ==\n\t\t\t\t\t       (char *)dup - (char *)hdr);\n\t\t\tdfp = xfs_dir2_data_freefind(hdr, bf, dup);\n\t\t\tif (dfp) {\n\t\t\t\ti = (int)(dfp - bf);\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\t(freeseen & (1 << i)) == 0);\n\t\t\t\tfreeseen |= 1 << i;\n\t\t\t} else {\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe16_to_cpu(dup->length) <=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t\t\t}\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t\tlastfree = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * It's a real entry.  Validate the fields.\n\t\t * If this is a block directory then make sure it's\n\t\t * in the leaf section of the block.\n\t\t * The linear search is crude but this is DEBUG code.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\tXFS_WANT_CORRUPTED_RETURN(dep->namelen != 0);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t!xfs_dir_ino_validate(mp, be64_to_cpu(dep->inumber)));\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\tbe16_to_cpu(*ops->data_entry_tag_p(dep)) ==\n\t\t\t\t\t       (char *)dep - (char *)hdr);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tops->data_get_ftype(dep) < XFS_DIR3_FT_MAX);\n\t\tcount++;\n\t\tlastfree = 0;\n\t\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\t\taddr = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,\n\t\t\t\t\t\t(xfs_dir2_data_aoff_t)\n\t\t\t\t\t\t((char *)dep - (char *)hdr));\n\t\t\tname.name = dep->name;\n\t\t\tname.len = dep->namelen;\n\t\t\thash = mp->m_dirnameops->hashname(&name);\n\t\t\tfor (i = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\t\tif (be32_to_cpu(lep[i].address) == addr &&\n\t\t\t\t    be32_to_cpu(lep[i].hashval) == hash)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i < be32_to_cpu(btp->count));\n\t\t}\n\t\tp += ops->data_entsize(dep->namelen);\n\t}\n\t/*\n\t * Need to have seen all the entries and all the bestfree slots.\n\t */\n\tXFS_WANT_CORRUPTED_RETURN(freeseen == 7);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tfor (i = stale = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\tif (lep[i].address ==\n\t\t\t    cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\t\tstale++;\n\t\t\tif (i > 0)\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe32_to_cpu(lep[i].hashval) >=\n\t\t\t\t\t\tbe32_to_cpu(lep[i - 1].hashval));\n\t\t}\n\t\tXFS_WANT_CORRUPTED_RETURN(count ==\n\t\t\tbe32_to_cpu(btp->count) - be32_to_cpu(btp->stale));\n\t\tXFS_WANT_CORRUPTED_RETURN(stale == be32_to_cpu(btp->stale));\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\n__xfs_dir3_data_check(\n\tstruct xfs_inode\t*dp,\t\t/* incore inode pointer */\n\tstruct xfs_buf\t\t*bp)\t\t/* data block's buffer */\n{\n\txfs_dir2_dataptr_t\taddr;\t\t/* addr for leaf lookup */\n\txfs_dir2_data_free_t\t*bf;\t\t/* bestfree table */\n\txfs_dir2_block_tail_t\t*btp=NULL;\t/* block tail */\n\tint\t\t\tcount;\t\t/* count of entries found */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry */\n\tchar\t\t\t*endp;\t\t/* end of useful data */\n\tint\t\t\tfreeseen;\t/* mask of bestfrees seen */\n\txfs_dahash_t\t\thash;\t\t/* hash of current name */\n\tint\t\t\ti;\t\t/* leaf index */\n\tint\t\t\tlastfree;\t/* last entry was unused */\n\txfs_dir2_leaf_entry_t\t*lep=NULL;\t/* block leaf entries */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tchar\t\t\t*p;\t\t/* current data position */\n\tint\t\t\tstale;\t\t/* count of stale leaves */\n\tstruct xfs_name\t\tname;\n\tconst struct xfs_dir_ops *ops;\n\tstruct xfs_da_geometry\t*geo;\n\n\tmp = bp->b_target->bt_mount;\n\tgeo = mp->m_dir_geo;\n\n\t/*\n\t * We can be passed a null dp here from a verifier, so we need to go the\n\t * hard way to get them.\n\t */\n\tops = xfs_dir_get_ops(mp, dp);\n\n\thdr = bp->b_addr;\n\tp = (char *)ops->data_entry_p(hdr);\n\n\tswitch (hdr->magic) {\n\tcase cpu_to_be32(XFS_DIR3_BLOCK_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_BLOCK_MAGIC):\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tlep = xfs_dir2_block_leaf_p(btp);\n\t\tendp = (char *)lep;\n\n\t\t/*\n\t\t * The number of leaf entries is limited by the size of the\n\t\t * block and the amount of space used by the data entries.\n\t\t * We don't know how much space is used by the data entries yet,\n\t\t * so just ensure that the count falls somewhere inside the\n\t\t * block right now.\n\t\t */\n\t\tXFS_WANT_CORRUPTED_RETURN(be32_to_cpu(btp->count) <\n\t\t\t((char *)btp - p) / sizeof(struct xfs_dir2_leaf_entry));\n\t\tbreak;\n\tcase cpu_to_be32(XFS_DIR3_DATA_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_DATA_MAGIC):\n\t\tendp = (char *)hdr + geo->blksize;\n\t\tbreak;\n\tdefault:\n\t\tXFS_ERROR_REPORT(\"Bad Magic\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/*\n\t * Account for zero bestfree entries.\n\t */\n\tbf = ops->data_bestfree_p(hdr);\n\tcount = lastfree = freeseen = 0;\n\tif (!bf[0].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[0].offset);\n\t\tfreeseen |= 1 << 0;\n\t}\n\tif (!bf[1].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[1].offset);\n\t\tfreeseen |= 1 << 1;\n\t}\n\tif (!bf[2].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[2].offset);\n\t\tfreeseen |= 1 << 2;\n\t}\n\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[0].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[1].length));\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[1].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t/*\n\t * Loop over the data/unused entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's unused, look for the space in the bestfree table.\n\t\t * If we find it, account for that, else make sure it\n\t\t * doesn't need to be there.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tXFS_WANT_CORRUPTED_RETURN(lastfree == 0);\n\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tbe16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)) ==\n\t\t\t\t\t       (char *)dup - (char *)hdr);\n\t\t\tdfp = xfs_dir2_data_freefind(hdr, bf, dup);\n\t\t\tif (dfp) {\n\t\t\t\ti = (int)(dfp - bf);\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\t(freeseen & (1 << i)) == 0);\n\t\t\t\tfreeseen |= 1 << i;\n\t\t\t} else {\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe16_to_cpu(dup->length) <=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t\t\t}\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t\tlastfree = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * It's a real entry.  Validate the fields.\n\t\t * If this is a block directory then make sure it's\n\t\t * in the leaf section of the block.\n\t\t * The linear search is crude but this is DEBUG code.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\tXFS_WANT_CORRUPTED_RETURN(dep->namelen != 0);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t!xfs_dir_ino_validate(mp, be64_to_cpu(dep->inumber)));\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\tbe16_to_cpu(*ops->data_entry_tag_p(dep)) ==\n\t\t\t\t\t       (char *)dep - (char *)hdr);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tops->data_get_ftype(dep) < XFS_DIR3_FT_MAX);\n\t\tcount++;\n\t\tlastfree = 0;\n\t\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\t\taddr = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,\n\t\t\t\t\t\t(xfs_dir2_data_aoff_t)\n\t\t\t\t\t\t((char *)dep - (char *)hdr));\n\t\t\tname.name = dep->name;\n\t\t\tname.len = dep->namelen;\n\t\t\thash = mp->m_dirnameops->hashname(&name);\n\t\t\tfor (i = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\t\tif (be32_to_cpu(lep[i].address) == addr &&\n\t\t\t\t    be32_to_cpu(lep[i].hashval) == hash)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i < be32_to_cpu(btp->count));\n\t\t}\n\t\tp += ops->data_entsize(dep->namelen);\n\t}\n\t/*\n\t * Need to have seen all the entries and all the bestfree slots.\n\t */\n\tXFS_WANT_CORRUPTED_RETURN(freeseen == 7);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tfor (i = stale = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\tif (lep[i].address ==\n\t\t\t    cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\t\tstale++;\n\t\t\tif (i > 0)\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe32_to_cpu(lep[i].hashval) >=\n\t\t\t\t\t\tbe32_to_cpu(lep[i - 1].hashval));\n\t\t}\n\t\tXFS_WANT_CORRUPTED_RETURN(count ==\n\t\t\tbe32_to_cpu(btp->count) - be32_to_cpu(btp->stale));\n\t\tXFS_WANT_CORRUPTED_RETURN(stale == be32_to_cpu(btp->stale));\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir3_block_read",
          "args": [
            "tp",
            "dp",
            "&bp"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_block_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
          "lines": "127-141",
          "snippet": "int\nxfs_dir3_block_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, mp->m_dir_geo->datablk, -1, bpp,\n\t\t\t\tXFS_DATA_FORK, &xfs_dir3_block_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_DIR_BLOCK_BUF);\n\treturn err;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_dir3_block_buf_ops = {\n\t.verify_read = xfs_dir3_block_read_verify,\n\t.verify_write = xfs_dir3_block_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_dir3_block_buf_ops = {\n\t.verify_read = xfs_dir3_block_read_verify,\n\t.verify_write = xfs_dir3_block_write_verify,\n};\n\nint\nxfs_dir3_block_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, mp->m_dir_geo->datablk, -1, bpp,\n\t\t\t\tXFS_DATA_FORK, &xfs_dir3_block_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_DIR_BLOCK_BUF);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);\nstatic int xfs_dir2_block_lookup_int(xfs_da_args_t *args, struct xfs_buf **bpp,\n\t\t\t\t     int *entno);\n\nstatic int\t\t\t\t\t/* error */\nxfs_dir2_block_lookup_int(\n\txfs_da_args_t\t\t*args,\t\t/* dir lookup arguments */\n\tstruct xfs_buf\t\t**bpp,\t\t/* returned block buffer */\n\tint\t\t\t*entno)\t\t/* returned entry number */\n{\n\txfs_dir2_dataptr_t\taddr;\t\t/* data entry address */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* block leaf entries */\n\tstruct xfs_buf\t\t*bp;\t\t/* block buffer */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* block data entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore inode */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_dahash_t\t\thash;\t\t/* found hash value */\n\tint\t\t\thigh;\t\t/* binary search high index */\n\tint\t\t\tlow;\t\t/* binary search low index */\n\tint\t\t\tmid;\t\t/* binary search current idx */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tenum xfs_dacmp\t\tcmp;\t\t/* comparison result */\n\n\tdp = args->dp;\n\ttp = args->trans;\n\tmp = dp->i_mount;\n\n\terror = xfs_dir3_block_read(tp, dp, &bp);\n\tif (error)\n\t\treturn error;\n\n\thdr = bp->b_addr;\n\txfs_dir3_data_check(dp, bp);\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\t/*\n\t * Loop doing a binary search for our hash value.\n\t * Find our entry, ENOENT if it's not there.\n\t */\n\tfor (low = 0, high = be32_to_cpu(btp->count) - 1; ; ) {\n\t\tASSERT(low <= high);\n\t\tmid = (low + high) >> 1;\n\t\tif ((hash = be32_to_cpu(blp[mid].hashval)) == args->hashval)\n\t\t\tbreak;\n\t\tif (hash < args->hashval)\n\t\t\tlow = mid + 1;\n\t\telse\n\t\t\thigh = mid - 1;\n\t\tif (low > high) {\n\t\t\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\t/*\n\t * Back up to the first one with the right hash value.\n\t */\n\twhile (mid > 0 && be32_to_cpu(blp[mid - 1].hashval) == args->hashval) {\n\t\tmid--;\n\t}\n\t/*\n\t * Now loop forward through all the entries with the\n\t * right hash value looking for our name.\n\t */\n\tdo {\n\t\tif ((addr = be32_to_cpu(blp[mid].address)) == XFS_DIR2_NULL_DATAPTR)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Get pointer to the entry from the leaf.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)\n\t\t\t((char *)hdr + xfs_dir2_dataptr_to_off(args->geo, addr));\n\t\t/*\n\t\t * Compare name and if it's an exact match, return the index\n\t\t * and buffer. If it's the first case-insensitive match, store\n\t\t * the index and buffer and continue looking for an exact match.\n\t\t */\n\t\tcmp = mp->m_dirnameops->compname(args, dep->name, dep->namelen);\n\t\tif (cmp != XFS_CMP_DIFFERENT && cmp != args->cmpresult) {\n\t\t\targs->cmpresult = cmp;\n\t\t\t*bpp = bp;\n\t\t\t*entno = mid;\n\t\t\tif (cmp == XFS_CMP_EXACT)\n\t\t\t\treturn 0;\n\t\t}\n\t} while (++mid < be32_to_cpu(btp->count) &&\n\t\t\tbe32_to_cpu(blp[mid].hashval) == hash);\n\n\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\t/*\n\t * Here, we can only be doing a lookup (not a rename or replace).\n\t * If a case-insensitive match was found earlier, return success.\n\t */\n\tif (args->cmpresult == XFS_CMP_CASE)\n\t\treturn 0;\n\t/*\n\t * No match, release the buffer and return ENOENT.\n\t */\n\txfs_trans_brelse(tp, bp);\n\treturn -ENOENT;\n}"
  },
  {
    "function_name": "xfs_dir2_block_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
    "lines": "604-644",
    "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_block_lookup(\n\txfs_da_args_t\t\t*args)\t\t/* dir lookup arguments */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* block leaf entries */\n\tstruct xfs_buf\t\t*bp;\t\t/* block buffer */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* block data entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore inode */\n\tint\t\t\tent;\t\t/* entry index */\n\tint\t\t\terror;\t\t/* error return value */\n\n\ttrace_xfs_dir2_block_lookup(args);\n\n\t/*\n\t * Get the buffer, look up the entry.\n\t * If not found (ENOENT) then return, have no buffer.\n\t */\n\tif ((error = xfs_dir2_block_lookup_int(args, &bp, &ent)))\n\t\treturn error;\n\tdp = args->dp;\n\thdr = bp->b_addr;\n\txfs_dir3_data_check(dp, bp);\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\t/*\n\t * Get the offset from the leaf entry, to point to the data.\n\t */\n\tdep = (xfs_dir2_data_entry_t *)((char *)hdr +\n\t\t\txfs_dir2_dataptr_to_off(args->geo,\n\t\t\t\t\t\tbe32_to_cpu(blp[ent].address)));\n\t/*\n\t * Fill in inode number, CI name if appropriate, release the block.\n\t */\n\targs->inumber = be64_to_cpu(dep->inumber);\n\targs->filetype = dp->d_ops->data_get_ftype(dep);\n\terror = xfs_dir_cilookup_result(args, dep->name, dep->namelen);\n\txfs_trans_brelse(args->trans, bp);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "args->trans",
            "bp"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir_cilookup_result",
          "args": [
            "args",
            "dep->name",
            "dep->namelen"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir_cilookup_result",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
          "lines": "327-346",
          "snippet": "int\nxfs_dir_cilookup_result(\n\tstruct xfs_da_args *args,\n\tconst unsigned char *name,\n\tint\t\tlen)\n{\n\tif (args->cmpresult == XFS_CMP_DIFFERENT)\n\t\treturn -ENOENT;\n\tif (args->cmpresult != XFS_CMP_CASE ||\n\t\t\t\t\t!(args->op_flags & XFS_DA_OP_CILOOKUP))\n\t\treturn -EEXIST;\n\n\targs->value = kmem_alloc(len, KM_NOFS | KM_MAYFAIL);\n\tif (!args->value)\n\t\treturn -ENOMEM;\n\n\tmemcpy(args->value, name, len);\n\targs->valuelen = len;\n\treturn -EEXIST;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir_cilookup_result(\n\tstruct xfs_da_args *args,\n\tconst unsigned char *name,\n\tint\t\tlen)\n{\n\tif (args->cmpresult == XFS_CMP_DIFFERENT)\n\t\treturn -ENOENT;\n\tif (args->cmpresult != XFS_CMP_CASE ||\n\t\t\t\t\t!(args->op_flags & XFS_DA_OP_CILOOKUP))\n\t\treturn -EEXIST;\n\n\targs->value = kmem_alloc(len, KM_NOFS | KM_MAYFAIL);\n\tif (!args->value)\n\t\treturn -ENOMEM;\n\n\tmemcpy(args->value, name, len);\n\targs->valuelen = len;\n\treturn -EEXIST;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_get_ftype",
          "args": [
            "dep"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dep->inumber"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_dataptr_to_off",
          "args": [
            "args->geo",
            "be32_to_cpu(blp[ent].address)"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_dataptr_to_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "240-244",
          "snippet": "static inline xfs_dir2_data_aoff_t\nxfs_dir2_dataptr_to_off(struct xfs_da_geometry *geo, xfs_dir2_dataptr_t dp)\n{\n\treturn xfs_dir2_byte_to_off(geo, xfs_dir2_dataptr_to_byte(dp));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_data_aoff_t\nxfs_dir2_dataptr_to_off(struct xfs_da_geometry *geo, xfs_dir2_dataptr_t dp)\n{\n\treturn xfs_dir2_byte_to_off(geo, xfs_dir2_dataptr_to_byte(dp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "blp[ent].address"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_leaf_p",
          "args": [
            "btp"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_leaf_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "601-605",
          "snippet": "static inline struct xfs_dir2_leaf_entry *\nxfs_dir2_block_leaf_p(struct xfs_dir2_block_tail *btp)\n{\n\treturn ((struct xfs_dir2_leaf_entry *)btp) - be32_to_cpu(btp->count);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_leaf_entry *\nxfs_dir2_block_leaf_p(struct xfs_dir2_block_tail *btp)\n{\n\treturn ((struct xfs_dir2_leaf_entry *)btp) - be32_to_cpu(btp->count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_tail_p",
          "args": [
            "args->geo",
            "hdr"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_tail_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "305-310",
          "snippet": "static inline struct xfs_dir2_block_tail *\nxfs_dir2_block_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_data_hdr *hdr)\n{\n\treturn ((struct xfs_dir2_block_tail *)\n\t\t((char *)hdr + geo->blksize)) - 1;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_block_tail *\nxfs_dir2_block_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_data_hdr *hdr)\n{\n\treturn ((struct xfs_dir2_block_tail *)\n\t\t((char *)hdr + geo->blksize)) - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir3_data_check",
          "args": [
            "dp",
            "bp"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "__xfs_dir3_data_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "40-210",
          "snippet": "int\n__xfs_dir3_data_check(\n\tstruct xfs_inode\t*dp,\t\t/* incore inode pointer */\n\tstruct xfs_buf\t\t*bp)\t\t/* data block's buffer */\n{\n\txfs_dir2_dataptr_t\taddr;\t\t/* addr for leaf lookup */\n\txfs_dir2_data_free_t\t*bf;\t\t/* bestfree table */\n\txfs_dir2_block_tail_t\t*btp=NULL;\t/* block tail */\n\tint\t\t\tcount;\t\t/* count of entries found */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry */\n\tchar\t\t\t*endp;\t\t/* end of useful data */\n\tint\t\t\tfreeseen;\t/* mask of bestfrees seen */\n\txfs_dahash_t\t\thash;\t\t/* hash of current name */\n\tint\t\t\ti;\t\t/* leaf index */\n\tint\t\t\tlastfree;\t/* last entry was unused */\n\txfs_dir2_leaf_entry_t\t*lep=NULL;\t/* block leaf entries */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tchar\t\t\t*p;\t\t/* current data position */\n\tint\t\t\tstale;\t\t/* count of stale leaves */\n\tstruct xfs_name\t\tname;\n\tconst struct xfs_dir_ops *ops;\n\tstruct xfs_da_geometry\t*geo;\n\n\tmp = bp->b_target->bt_mount;\n\tgeo = mp->m_dir_geo;\n\n\t/*\n\t * We can be passed a null dp here from a verifier, so we need to go the\n\t * hard way to get them.\n\t */\n\tops = xfs_dir_get_ops(mp, dp);\n\n\thdr = bp->b_addr;\n\tp = (char *)ops->data_entry_p(hdr);\n\n\tswitch (hdr->magic) {\n\tcase cpu_to_be32(XFS_DIR3_BLOCK_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_BLOCK_MAGIC):\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tlep = xfs_dir2_block_leaf_p(btp);\n\t\tendp = (char *)lep;\n\n\t\t/*\n\t\t * The number of leaf entries is limited by the size of the\n\t\t * block and the amount of space used by the data entries.\n\t\t * We don't know how much space is used by the data entries yet,\n\t\t * so just ensure that the count falls somewhere inside the\n\t\t * block right now.\n\t\t */\n\t\tXFS_WANT_CORRUPTED_RETURN(be32_to_cpu(btp->count) <\n\t\t\t((char *)btp - p) / sizeof(struct xfs_dir2_leaf_entry));\n\t\tbreak;\n\tcase cpu_to_be32(XFS_DIR3_DATA_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_DATA_MAGIC):\n\t\tendp = (char *)hdr + geo->blksize;\n\t\tbreak;\n\tdefault:\n\t\tXFS_ERROR_REPORT(\"Bad Magic\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/*\n\t * Account for zero bestfree entries.\n\t */\n\tbf = ops->data_bestfree_p(hdr);\n\tcount = lastfree = freeseen = 0;\n\tif (!bf[0].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[0].offset);\n\t\tfreeseen |= 1 << 0;\n\t}\n\tif (!bf[1].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[1].offset);\n\t\tfreeseen |= 1 << 1;\n\t}\n\tif (!bf[2].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[2].offset);\n\t\tfreeseen |= 1 << 2;\n\t}\n\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[0].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[1].length));\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[1].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t/*\n\t * Loop over the data/unused entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's unused, look for the space in the bestfree table.\n\t\t * If we find it, account for that, else make sure it\n\t\t * doesn't need to be there.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tXFS_WANT_CORRUPTED_RETURN(lastfree == 0);\n\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tbe16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)) ==\n\t\t\t\t\t       (char *)dup - (char *)hdr);\n\t\t\tdfp = xfs_dir2_data_freefind(hdr, bf, dup);\n\t\t\tif (dfp) {\n\t\t\t\ti = (int)(dfp - bf);\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\t(freeseen & (1 << i)) == 0);\n\t\t\t\tfreeseen |= 1 << i;\n\t\t\t} else {\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe16_to_cpu(dup->length) <=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t\t\t}\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t\tlastfree = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * It's a real entry.  Validate the fields.\n\t\t * If this is a block directory then make sure it's\n\t\t * in the leaf section of the block.\n\t\t * The linear search is crude but this is DEBUG code.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\tXFS_WANT_CORRUPTED_RETURN(dep->namelen != 0);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t!xfs_dir_ino_validate(mp, be64_to_cpu(dep->inumber)));\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\tbe16_to_cpu(*ops->data_entry_tag_p(dep)) ==\n\t\t\t\t\t       (char *)dep - (char *)hdr);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tops->data_get_ftype(dep) < XFS_DIR3_FT_MAX);\n\t\tcount++;\n\t\tlastfree = 0;\n\t\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\t\taddr = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,\n\t\t\t\t\t\t(xfs_dir2_data_aoff_t)\n\t\t\t\t\t\t((char *)dep - (char *)hdr));\n\t\t\tname.name = dep->name;\n\t\t\tname.len = dep->namelen;\n\t\t\thash = mp->m_dirnameops->hashname(&name);\n\t\t\tfor (i = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\t\tif (be32_to_cpu(lep[i].address) == addr &&\n\t\t\t\t    be32_to_cpu(lep[i].hashval) == hash)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i < be32_to_cpu(btp->count));\n\t\t}\n\t\tp += ops->data_entsize(dep->namelen);\n\t}\n\t/*\n\t * Need to have seen all the entries and all the bestfree slots.\n\t */\n\tXFS_WANT_CORRUPTED_RETURN(freeseen == 7);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tfor (i = stale = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\tif (lep[i].address ==\n\t\t\t    cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\t\tstale++;\n\t\t\tif (i > 0)\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe32_to_cpu(lep[i].hashval) >=\n\t\t\t\t\t\tbe32_to_cpu(lep[i - 1].hashval));\n\t\t}\n\t\tXFS_WANT_CORRUPTED_RETURN(count ==\n\t\t\tbe32_to_cpu(btp->count) - be32_to_cpu(btp->stale));\n\t\tXFS_WANT_CORRUPTED_RETURN(stale == be32_to_cpu(btp->stale));\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\n__xfs_dir3_data_check(\n\tstruct xfs_inode\t*dp,\t\t/* incore inode pointer */\n\tstruct xfs_buf\t\t*bp)\t\t/* data block's buffer */\n{\n\txfs_dir2_dataptr_t\taddr;\t\t/* addr for leaf lookup */\n\txfs_dir2_data_free_t\t*bf;\t\t/* bestfree table */\n\txfs_dir2_block_tail_t\t*btp=NULL;\t/* block tail */\n\tint\t\t\tcount;\t\t/* count of entries found */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry */\n\tchar\t\t\t*endp;\t\t/* end of useful data */\n\tint\t\t\tfreeseen;\t/* mask of bestfrees seen */\n\txfs_dahash_t\t\thash;\t\t/* hash of current name */\n\tint\t\t\ti;\t\t/* leaf index */\n\tint\t\t\tlastfree;\t/* last entry was unused */\n\txfs_dir2_leaf_entry_t\t*lep=NULL;\t/* block leaf entries */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tchar\t\t\t*p;\t\t/* current data position */\n\tint\t\t\tstale;\t\t/* count of stale leaves */\n\tstruct xfs_name\t\tname;\n\tconst struct xfs_dir_ops *ops;\n\tstruct xfs_da_geometry\t*geo;\n\n\tmp = bp->b_target->bt_mount;\n\tgeo = mp->m_dir_geo;\n\n\t/*\n\t * We can be passed a null dp here from a verifier, so we need to go the\n\t * hard way to get them.\n\t */\n\tops = xfs_dir_get_ops(mp, dp);\n\n\thdr = bp->b_addr;\n\tp = (char *)ops->data_entry_p(hdr);\n\n\tswitch (hdr->magic) {\n\tcase cpu_to_be32(XFS_DIR3_BLOCK_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_BLOCK_MAGIC):\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tlep = xfs_dir2_block_leaf_p(btp);\n\t\tendp = (char *)lep;\n\n\t\t/*\n\t\t * The number of leaf entries is limited by the size of the\n\t\t * block and the amount of space used by the data entries.\n\t\t * We don't know how much space is used by the data entries yet,\n\t\t * so just ensure that the count falls somewhere inside the\n\t\t * block right now.\n\t\t */\n\t\tXFS_WANT_CORRUPTED_RETURN(be32_to_cpu(btp->count) <\n\t\t\t((char *)btp - p) / sizeof(struct xfs_dir2_leaf_entry));\n\t\tbreak;\n\tcase cpu_to_be32(XFS_DIR3_DATA_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_DATA_MAGIC):\n\t\tendp = (char *)hdr + geo->blksize;\n\t\tbreak;\n\tdefault:\n\t\tXFS_ERROR_REPORT(\"Bad Magic\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/*\n\t * Account for zero bestfree entries.\n\t */\n\tbf = ops->data_bestfree_p(hdr);\n\tcount = lastfree = freeseen = 0;\n\tif (!bf[0].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[0].offset);\n\t\tfreeseen |= 1 << 0;\n\t}\n\tif (!bf[1].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[1].offset);\n\t\tfreeseen |= 1 << 1;\n\t}\n\tif (!bf[2].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[2].offset);\n\t\tfreeseen |= 1 << 2;\n\t}\n\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[0].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[1].length));\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[1].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t/*\n\t * Loop over the data/unused entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's unused, look for the space in the bestfree table.\n\t\t * If we find it, account for that, else make sure it\n\t\t * doesn't need to be there.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tXFS_WANT_CORRUPTED_RETURN(lastfree == 0);\n\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tbe16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)) ==\n\t\t\t\t\t       (char *)dup - (char *)hdr);\n\t\t\tdfp = xfs_dir2_data_freefind(hdr, bf, dup);\n\t\t\tif (dfp) {\n\t\t\t\ti = (int)(dfp - bf);\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\t(freeseen & (1 << i)) == 0);\n\t\t\t\tfreeseen |= 1 << i;\n\t\t\t} else {\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe16_to_cpu(dup->length) <=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t\t\t}\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t\tlastfree = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * It's a real entry.  Validate the fields.\n\t\t * If this is a block directory then make sure it's\n\t\t * in the leaf section of the block.\n\t\t * The linear search is crude but this is DEBUG code.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\tXFS_WANT_CORRUPTED_RETURN(dep->namelen != 0);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t!xfs_dir_ino_validate(mp, be64_to_cpu(dep->inumber)));\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\tbe16_to_cpu(*ops->data_entry_tag_p(dep)) ==\n\t\t\t\t\t       (char *)dep - (char *)hdr);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tops->data_get_ftype(dep) < XFS_DIR3_FT_MAX);\n\t\tcount++;\n\t\tlastfree = 0;\n\t\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\t\taddr = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,\n\t\t\t\t\t\t(xfs_dir2_data_aoff_t)\n\t\t\t\t\t\t((char *)dep - (char *)hdr));\n\t\t\tname.name = dep->name;\n\t\t\tname.len = dep->namelen;\n\t\t\thash = mp->m_dirnameops->hashname(&name);\n\t\t\tfor (i = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\t\tif (be32_to_cpu(lep[i].address) == addr &&\n\t\t\t\t    be32_to_cpu(lep[i].hashval) == hash)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i < be32_to_cpu(btp->count));\n\t\t}\n\t\tp += ops->data_entsize(dep->namelen);\n\t}\n\t/*\n\t * Need to have seen all the entries and all the bestfree slots.\n\t */\n\tXFS_WANT_CORRUPTED_RETURN(freeseen == 7);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tfor (i = stale = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\tif (lep[i].address ==\n\t\t\t    cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\t\tstale++;\n\t\t\tif (i > 0)\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe32_to_cpu(lep[i].hashval) >=\n\t\t\t\t\t\tbe32_to_cpu(lep[i - 1].hashval));\n\t\t}\n\t\tXFS_WANT_CORRUPTED_RETURN(count ==\n\t\t\tbe32_to_cpu(btp->count) - be32_to_cpu(btp->stale));\n\t\tXFS_WANT_CORRUPTED_RETURN(stale == be32_to_cpu(btp->stale));\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_lookup_int",
          "args": [
            "args",
            "&bp",
            "&ent"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_lookup_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
          "lines": "649-748",
          "snippet": "static int\t\t\t\t\t/* error */\nxfs_dir2_block_lookup_int(\n\txfs_da_args_t\t\t*args,\t\t/* dir lookup arguments */\n\tstruct xfs_buf\t\t**bpp,\t\t/* returned block buffer */\n\tint\t\t\t*entno)\t\t/* returned entry number */\n{\n\txfs_dir2_dataptr_t\taddr;\t\t/* data entry address */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* block leaf entries */\n\tstruct xfs_buf\t\t*bp;\t\t/* block buffer */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* block data entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore inode */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_dahash_t\t\thash;\t\t/* found hash value */\n\tint\t\t\thigh;\t\t/* binary search high index */\n\tint\t\t\tlow;\t\t/* binary search low index */\n\tint\t\t\tmid;\t\t/* binary search current idx */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tenum xfs_dacmp\t\tcmp;\t\t/* comparison result */\n\n\tdp = args->dp;\n\ttp = args->trans;\n\tmp = dp->i_mount;\n\n\terror = xfs_dir3_block_read(tp, dp, &bp);\n\tif (error)\n\t\treturn error;\n\n\thdr = bp->b_addr;\n\txfs_dir3_data_check(dp, bp);\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\t/*\n\t * Loop doing a binary search for our hash value.\n\t * Find our entry, ENOENT if it's not there.\n\t */\n\tfor (low = 0, high = be32_to_cpu(btp->count) - 1; ; ) {\n\t\tASSERT(low <= high);\n\t\tmid = (low + high) >> 1;\n\t\tif ((hash = be32_to_cpu(blp[mid].hashval)) == args->hashval)\n\t\t\tbreak;\n\t\tif (hash < args->hashval)\n\t\t\tlow = mid + 1;\n\t\telse\n\t\t\thigh = mid - 1;\n\t\tif (low > high) {\n\t\t\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\t/*\n\t * Back up to the first one with the right hash value.\n\t */\n\twhile (mid > 0 && be32_to_cpu(blp[mid - 1].hashval) == args->hashval) {\n\t\tmid--;\n\t}\n\t/*\n\t * Now loop forward through all the entries with the\n\t * right hash value looking for our name.\n\t */\n\tdo {\n\t\tif ((addr = be32_to_cpu(blp[mid].address)) == XFS_DIR2_NULL_DATAPTR)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Get pointer to the entry from the leaf.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)\n\t\t\t((char *)hdr + xfs_dir2_dataptr_to_off(args->geo, addr));\n\t\t/*\n\t\t * Compare name and if it's an exact match, return the index\n\t\t * and buffer. If it's the first case-insensitive match, store\n\t\t * the index and buffer and continue looking for an exact match.\n\t\t */\n\t\tcmp = mp->m_dirnameops->compname(args, dep->name, dep->namelen);\n\t\tif (cmp != XFS_CMP_DIFFERENT && cmp != args->cmpresult) {\n\t\t\targs->cmpresult = cmp;\n\t\t\t*bpp = bp;\n\t\t\t*entno = mid;\n\t\t\tif (cmp == XFS_CMP_EXACT)\n\t\t\t\treturn 0;\n\t\t}\n\t} while (++mid < be32_to_cpu(btp->count) &&\n\t\t\tbe32_to_cpu(blp[mid].hashval) == hash);\n\n\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\t/*\n\t * Here, we can only be doing a lookup (not a rename or replace).\n\t * If a case-insensitive match was found earlier, return success.\n\t */\n\tif (args->cmpresult == XFS_CMP_CASE)\n\t\treturn 0;\n\t/*\n\t * No match, release the buffer and return ENOENT.\n\t */\n\txfs_trans_brelse(tp, bp);\n\treturn -ENOENT;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);",
            "static int xfs_dir2_block_lookup_int(xfs_da_args_t *args, struct xfs_buf **bpp,\n\t\t\t\t     int *entno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);\nstatic int xfs_dir2_block_lookup_int(xfs_da_args_t *args, struct xfs_buf **bpp,\n\t\t\t\t     int *entno);\n\nstatic int\t\t\t\t\t/* error */\nxfs_dir2_block_lookup_int(\n\txfs_da_args_t\t\t*args,\t\t/* dir lookup arguments */\n\tstruct xfs_buf\t\t**bpp,\t\t/* returned block buffer */\n\tint\t\t\t*entno)\t\t/* returned entry number */\n{\n\txfs_dir2_dataptr_t\taddr;\t\t/* data entry address */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* block leaf entries */\n\tstruct xfs_buf\t\t*bp;\t\t/* block buffer */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* block data entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore inode */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_dahash_t\t\thash;\t\t/* found hash value */\n\tint\t\t\thigh;\t\t/* binary search high index */\n\tint\t\t\tlow;\t\t/* binary search low index */\n\tint\t\t\tmid;\t\t/* binary search current idx */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tenum xfs_dacmp\t\tcmp;\t\t/* comparison result */\n\n\tdp = args->dp;\n\ttp = args->trans;\n\tmp = dp->i_mount;\n\n\terror = xfs_dir3_block_read(tp, dp, &bp);\n\tif (error)\n\t\treturn error;\n\n\thdr = bp->b_addr;\n\txfs_dir3_data_check(dp, bp);\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\t/*\n\t * Loop doing a binary search for our hash value.\n\t * Find our entry, ENOENT if it's not there.\n\t */\n\tfor (low = 0, high = be32_to_cpu(btp->count) - 1; ; ) {\n\t\tASSERT(low <= high);\n\t\tmid = (low + high) >> 1;\n\t\tif ((hash = be32_to_cpu(blp[mid].hashval)) == args->hashval)\n\t\t\tbreak;\n\t\tif (hash < args->hashval)\n\t\t\tlow = mid + 1;\n\t\telse\n\t\t\thigh = mid - 1;\n\t\tif (low > high) {\n\t\t\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\t/*\n\t * Back up to the first one with the right hash value.\n\t */\n\twhile (mid > 0 && be32_to_cpu(blp[mid - 1].hashval) == args->hashval) {\n\t\tmid--;\n\t}\n\t/*\n\t * Now loop forward through all the entries with the\n\t * right hash value looking for our name.\n\t */\n\tdo {\n\t\tif ((addr = be32_to_cpu(blp[mid].address)) == XFS_DIR2_NULL_DATAPTR)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Get pointer to the entry from the leaf.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)\n\t\t\t((char *)hdr + xfs_dir2_dataptr_to_off(args->geo, addr));\n\t\t/*\n\t\t * Compare name and if it's an exact match, return the index\n\t\t * and buffer. If it's the first case-insensitive match, store\n\t\t * the index and buffer and continue looking for an exact match.\n\t\t */\n\t\tcmp = mp->m_dirnameops->compname(args, dep->name, dep->namelen);\n\t\tif (cmp != XFS_CMP_DIFFERENT && cmp != args->cmpresult) {\n\t\t\targs->cmpresult = cmp;\n\t\t\t*bpp = bp;\n\t\t\t*entno = mid;\n\t\t\tif (cmp == XFS_CMP_EXACT)\n\t\t\t\treturn 0;\n\t\t}\n\t} while (++mid < be32_to_cpu(btp->count) &&\n\t\t\tbe32_to_cpu(blp[mid].hashval) == hash);\n\n\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\t/*\n\t * Here, we can only be doing a lookup (not a rename or replace).\n\t * If a case-insensitive match was found earlier, return success.\n\t */\n\tif (args->cmpresult == XFS_CMP_CASE)\n\t\treturn 0;\n\t/*\n\t * No match, release the buffer and return ENOENT.\n\t */\n\txfs_trans_brelse(tp, bp);\n\treturn -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_dir2_block_lookup",
          "args": [
            "args"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_block_lookup(\n\txfs_da_args_t\t\t*args)\t\t/* dir lookup arguments */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* block leaf entries */\n\tstruct xfs_buf\t\t*bp;\t\t/* block buffer */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* block data entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore inode */\n\tint\t\t\tent;\t\t/* entry index */\n\tint\t\t\terror;\t\t/* error return value */\n\n\ttrace_xfs_dir2_block_lookup(args);\n\n\t/*\n\t * Get the buffer, look up the entry.\n\t * If not found (ENOENT) then return, have no buffer.\n\t */\n\tif ((error = xfs_dir2_block_lookup_int(args, &bp, &ent)))\n\t\treturn error;\n\tdp = args->dp;\n\thdr = bp->b_addr;\n\txfs_dir3_data_check(dp, bp);\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\t/*\n\t * Get the offset from the leaf entry, to point to the data.\n\t */\n\tdep = (xfs_dir2_data_entry_t *)((char *)hdr +\n\t\t\txfs_dir2_dataptr_to_off(args->geo,\n\t\t\t\t\t\tbe32_to_cpu(blp[ent].address)));\n\t/*\n\t * Fill in inode number, CI name if appropriate, release the block.\n\t */\n\targs->inumber = be64_to_cpu(dep->inumber);\n\targs->filetype = dp->d_ops->data_get_ftype(dep);\n\terror = xfs_dir_cilookup_result(args, dep->name, dep->namelen);\n\txfs_trans_brelse(args->trans, bp);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_dir2_block_log_tail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
    "lines": "587-598",
    "snippet": "static void\nxfs_dir2_block_log_tail(\n\txfs_trans_t\t\t*tp,\t\t/* transaction structure */\n\tstruct xfs_buf\t\t*bp)\t\t/* block buffer */\n{\n\txfs_dir2_data_hdr_t\t*hdr = bp->b_addr;\n\txfs_dir2_block_tail_t\t*btp;\n\n\tbtp = xfs_dir2_block_tail_p(tp->t_mountp->m_dir_geo, hdr);\n\txfs_trans_log_buf(tp, bp, (uint)((char *)btp - (char *)hdr),\n\t\t(uint)((char *)(btp + 1) - (char *)hdr - 1));\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "tp",
            "bp",
            "(uint)((char *)btp - (char *)hdr)",
            "(uint)((char *)(btp + 1) - (char *)hdr - 1)"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "497-552",
          "snippet": "void\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(char *)(btp + 1) - (char *)hdr - 1"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(char *)btp - (char *)hdr"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_tail_p",
          "args": [
            "tp->t_mountp->m_dir_geo",
            "hdr"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_tail_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "305-310",
          "snippet": "static inline struct xfs_dir2_block_tail *\nxfs_dir2_block_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_data_hdr *hdr)\n{\n\treturn ((struct xfs_dir2_block_tail *)\n\t\t((char *)hdr + geo->blksize)) - 1;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_block_tail *\nxfs_dir2_block_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_data_hdr *hdr)\n{\n\treturn ((struct xfs_dir2_block_tail *)\n\t\t((char *)hdr + geo->blksize)) - 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);\n\nstatic void\nxfs_dir2_block_log_tail(\n\txfs_trans_t\t\t*tp,\t\t/* transaction structure */\n\tstruct xfs_buf\t\t*bp)\t\t/* block buffer */\n{\n\txfs_dir2_data_hdr_t\t*hdr = bp->b_addr;\n\txfs_dir2_block_tail_t\t*btp;\n\n\tbtp = xfs_dir2_block_tail_p(tp->t_mountp->m_dir_geo, hdr);\n\txfs_trans_log_buf(tp, bp, (uint)((char *)btp - (char *)hdr),\n\t\t(uint)((char *)(btp + 1) - (char *)hdr - 1));\n}"
  },
  {
    "function_name": "xfs_dir2_block_log_leaf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
    "lines": "567-582",
    "snippet": "static void\nxfs_dir2_block_log_leaf(\n\txfs_trans_t\t\t*tp,\t\t/* transaction structure */\n\tstruct xfs_buf\t\t*bp,\t\t/* block buffer */\n\tint\t\t\tfirst,\t\t/* index of first logged leaf */\n\tint\t\t\tlast)\t\t/* index of last logged leaf */\n{\n\txfs_dir2_data_hdr_t\t*hdr = bp->b_addr;\n\txfs_dir2_leaf_entry_t\t*blp;\n\txfs_dir2_block_tail_t\t*btp;\n\n\tbtp = xfs_dir2_block_tail_p(tp->t_mountp->m_dir_geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\txfs_trans_log_buf(tp, bp, (uint)((char *)&blp[first] - (char *)hdr),\n\t\t(uint)((char *)&blp[last + 1] - (char *)hdr - 1));\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xfs_dir2_block_log_leaf(xfs_trans_t *tp, struct xfs_buf *bp,\n\t\t\t\t    int first, int last);",
      "static void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "tp",
            "bp",
            "(uint)((char *)&blp[first] - (char *)hdr)",
            "(uint)((char *)&blp[last + 1] - (char *)hdr - 1)"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "497-552",
          "snippet": "void\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(char *)&blp[last + 1] - (char *)hdr - 1"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(char *)&blp[first] - (char *)hdr"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_leaf_p",
          "args": [
            "btp"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_leaf_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "601-605",
          "snippet": "static inline struct xfs_dir2_leaf_entry *\nxfs_dir2_block_leaf_p(struct xfs_dir2_block_tail *btp)\n{\n\treturn ((struct xfs_dir2_leaf_entry *)btp) - be32_to_cpu(btp->count);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_leaf_entry *\nxfs_dir2_block_leaf_p(struct xfs_dir2_block_tail *btp)\n{\n\treturn ((struct xfs_dir2_leaf_entry *)btp) - be32_to_cpu(btp->count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_tail_p",
          "args": [
            "tp->t_mountp->m_dir_geo",
            "hdr"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_tail_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "305-310",
          "snippet": "static inline struct xfs_dir2_block_tail *\nxfs_dir2_block_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_data_hdr *hdr)\n{\n\treturn ((struct xfs_dir2_block_tail *)\n\t\t((char *)hdr + geo->blksize)) - 1;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_block_tail *\nxfs_dir2_block_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_data_hdr *hdr)\n{\n\treturn ((struct xfs_dir2_block_tail *)\n\t\t((char *)hdr + geo->blksize)) - 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_block_log_leaf(xfs_trans_t *tp, struct xfs_buf *bp,\n\t\t\t\t    int first, int last);\nstatic void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);\n\nstatic void\nxfs_dir2_block_log_leaf(\n\txfs_trans_t\t\t*tp,\t\t/* transaction structure */\n\tstruct xfs_buf\t\t*bp,\t\t/* block buffer */\n\tint\t\t\tfirst,\t\t/* index of first logged leaf */\n\tint\t\t\tlast)\t\t/* index of last logged leaf */\n{\n\txfs_dir2_data_hdr_t\t*hdr = bp->b_addr;\n\txfs_dir2_leaf_entry_t\t*blp;\n\txfs_dir2_block_tail_t\t*btp;\n\n\tbtp = xfs_dir2_block_tail_p(tp->t_mountp->m_dir_geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\txfs_trans_log_buf(tp, bp, (uint)((char *)&blp[first] - (char *)hdr),\n\t\t(uint)((char *)&blp[last + 1] - (char *)hdr - 1));\n}"
  },
  {
    "function_name": "xfs_dir2_block_addname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
    "lines": "330-562",
    "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_block_addname(\n\txfs_da_args_t\t\t*args)\t\t/* directory op arguments */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* block leaf entries */\n\tstruct xfs_buf\t\t*bp;\t\t/* buffer for block */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\tint\t\t\tcompact;\t/* need to compact leaf ents */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* block data entry */\n\txfs_inode_t\t\t*dp;\t\t/* directory inode */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* block unused entry */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_dir2_data_unused_t\t*enddup=NULL;\t/* unused at end of data */\n\txfs_dahash_t\t\thash;\t\t/* hash value of found entry */\n\tint\t\t\thigh;\t\t/* high index for binary srch */\n\tint\t\t\thighstale;\t/* high stale index */\n\tint\t\t\tlfloghigh=0;\t/* last final leaf to log */\n\tint\t\t\tlfloglow=0;\t/* first final leaf to log */\n\tint\t\t\tlen;\t\t/* length of the new entry */\n\tint\t\t\tlow;\t\t/* low index for binary srch */\n\tint\t\t\tlowstale;\t/* low stale index */\n\tint\t\t\tmid=0;\t\t/* midpoint for binary srch */\n\tint\t\t\tneedlog;\t/* need to log header */\n\tint\t\t\tneedscan;\t/* need to rescan freespace */\n\t__be16\t\t\t*tagp;\t\t/* pointer to tag value */\n\txfs_trans_t\t\t*tp;\t\t/* transaction structure */\n\n\ttrace_xfs_dir2_block_addname(args);\n\n\tdp = args->dp;\n\ttp = args->trans;\n\n\t/* Read the (one and only) directory block into bp. */\n\terror = xfs_dir3_block_read(tp, dp, &bp);\n\tif (error)\n\t\treturn error;\n\n\tlen = dp->d_ops->data_entsize(args->namelen);\n\n\t/*\n\t * Set up pointers to parts of the block.\n\t */\n\thdr = bp->b_addr;\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\n\t/*\n\t * Find out if we can reuse stale entries or whether we need extra\n\t * space for entry and new leaf.\n\t */\n\txfs_dir2_block_need_space(dp, hdr, btp, blp, &tagp, &dup,\n\t\t\t\t  &enddup, &compact, len);\n\n\t/*\n\t * Done everything we need for a space check now.\n\t */\n\tif (args->op_flags & XFS_DA_OP_JUSTCHECK) {\n\t\txfs_trans_brelse(tp, bp);\n\t\tif (!dup)\n\t\t\treturn -ENOSPC;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If we don't have space for the new entry & leaf ...\n\t */\n\tif (!dup) {\n\t\t/* Don't have a space reservation: return no-space.  */\n\t\tif (args->total == 0)\n\t\t\treturn -ENOSPC;\n\t\t/*\n\t\t * Convert to the next larger format.\n\t\t * Then add the new entry in that format.\n\t\t */\n\t\terror = xfs_dir2_block_to_leaf(args, bp);\n\t\tif (error)\n\t\t\treturn error;\n\t\treturn xfs_dir2_leaf_addname(args);\n\t}\n\n\tneedlog = needscan = 0;\n\n\t/*\n\t * If need to compact the leaf entries, do it now.\n\t */\n\tif (compact) {\n\t\txfs_dir2_block_compact(args, bp, hdr, btp, blp, &needlog,\n\t\t\t\t      &lfloghigh, &lfloglow);\n\t\t/* recalculate blp post-compaction */\n\t\tblp = xfs_dir2_block_leaf_p(btp);\n\t} else if (btp->stale) {\n\t\t/*\n\t\t * Set leaf logging boundaries to impossible state.\n\t\t * For the no-stale case they're set explicitly.\n\t\t */\n\t\tlfloglow = be32_to_cpu(btp->count);\n\t\tlfloghigh = -1;\n\t}\n\n\t/*\n\t * Find the slot that's first lower than our hash value, -1 if none.\n\t */\n\tfor (low = 0, high = be32_to_cpu(btp->count) - 1; low <= high; ) {\n\t\tmid = (low + high) >> 1;\n\t\tif ((hash = be32_to_cpu(blp[mid].hashval)) == args->hashval)\n\t\t\tbreak;\n\t\tif (hash < args->hashval)\n\t\t\tlow = mid + 1;\n\t\telse\n\t\t\thigh = mid - 1;\n\t}\n\twhile (mid >= 0 && be32_to_cpu(blp[mid].hashval) >= args->hashval) {\n\t\tmid--;\n\t}\n\t/*\n\t * No stale entries, will use enddup space to hold new leaf.\n\t */\n\tif (!btp->stale) {\n\t\t/*\n\t\t * Mark the space needed for the new leaf entry, now in use.\n\t\t */\n\t\txfs_dir2_data_use_free(args, bp, enddup,\n\t\t\t(xfs_dir2_data_aoff_t)\n\t\t\t((char *)enddup - (char *)hdr + be16_to_cpu(enddup->length) -\n\t\t\t sizeof(*blp)),\n\t\t\t(xfs_dir2_data_aoff_t)sizeof(*blp),\n\t\t\t&needlog, &needscan);\n\t\t/*\n\t\t * Update the tail (entry count).\n\t\t */\n\t\tbe32_add_cpu(&btp->count, 1);\n\t\t/*\n\t\t * If we now need to rebuild the bestfree map, do so.\n\t\t * This needs to happen before the next call to use_free.\n\t\t */\n\t\tif (needscan) {\n\t\t\txfs_dir2_data_freescan(dp, hdr, &needlog);\n\t\t\tneedscan = 0;\n\t\t}\n\t\t/*\n\t\t * Adjust pointer to the first leaf entry, we're about to move\n\t\t * the table up one to open up space for the new leaf entry.\n\t\t * Then adjust our index to match.\n\t\t */\n\t\tblp--;\n\t\tmid++;\n\t\tif (mid)\n\t\t\tmemmove(blp, &blp[1], mid * sizeof(*blp));\n\t\tlfloglow = 0;\n\t\tlfloghigh = mid;\n\t}\n\t/*\n\t * Use a stale leaf for our new entry.\n\t */\n\telse {\n\t\tfor (lowstale = mid;\n\t\t     lowstale >= 0 &&\n\t\t\tblp[lowstale].address !=\n\t\t\tcpu_to_be32(XFS_DIR2_NULL_DATAPTR);\n\t\t     lowstale--)\n\t\t\tcontinue;\n\t\tfor (highstale = mid + 1;\n\t\t     highstale < be32_to_cpu(btp->count) &&\n\t\t\tblp[highstale].address !=\n\t\t\tcpu_to_be32(XFS_DIR2_NULL_DATAPTR) &&\n\t\t\t(lowstale < 0 || mid - lowstale > highstale - mid);\n\t\t     highstale++)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Move entries toward the low-numbered stale entry.\n\t\t */\n\t\tif (lowstale >= 0 &&\n\t\t    (highstale == be32_to_cpu(btp->count) ||\n\t\t     mid - lowstale <= highstale - mid)) {\n\t\t\tif (mid - lowstale)\n\t\t\t\tmemmove(&blp[lowstale], &blp[lowstale + 1],\n\t\t\t\t\t(mid - lowstale) * sizeof(*blp));\n\t\t\tlfloglow = MIN(lowstale, lfloglow);\n\t\t\tlfloghigh = MAX(mid, lfloghigh);\n\t\t}\n\t\t/*\n\t\t * Move entries toward the high-numbered stale entry.\n\t\t */\n\t\telse {\n\t\t\tASSERT(highstale < be32_to_cpu(btp->count));\n\t\t\tmid++;\n\t\t\tif (highstale - mid)\n\t\t\t\tmemmove(&blp[mid + 1], &blp[mid],\n\t\t\t\t\t(highstale - mid) * sizeof(*blp));\n\t\t\tlfloglow = MIN(mid, lfloglow);\n\t\t\tlfloghigh = MAX(highstale, lfloghigh);\n\t\t}\n\t\tbe32_add_cpu(&btp->stale, -1);\n\t}\n\t/*\n\t * Point to the new data entry.\n\t */\n\tdep = (xfs_dir2_data_entry_t *)dup;\n\t/*\n\t * Fill in the leaf entry.\n\t */\n\tblp[mid].hashval = cpu_to_be32(args->hashval);\n\tblp[mid].address = cpu_to_be32(xfs_dir2_byte_to_dataptr(\n\t\t\t\t(char *)dep - (char *)hdr));\n\txfs_dir2_block_log_leaf(tp, bp, lfloglow, lfloghigh);\n\t/*\n\t * Mark space for the data entry used.\n\t */\n\txfs_dir2_data_use_free(args, bp, dup,\n\t\t(xfs_dir2_data_aoff_t)((char *)dup - (char *)hdr),\n\t\t(xfs_dir2_data_aoff_t)len, &needlog, &needscan);\n\t/*\n\t * Create the new data entry.\n\t */\n\tdep->inumber = cpu_to_be64(args->inumber);\n\tdep->namelen = args->namelen;\n\tmemcpy(dep->name, args->name, args->namelen);\n\tdp->d_ops->data_put_ftype(dep, args->filetype);\n\ttagp = dp->d_ops->data_entry_tag_p(dep);\n\t*tagp = cpu_to_be16((char *)dep - (char *)hdr);\n\t/*\n\t * Clean up the bestfree array and log the header, tail, and entry.\n\t */\n\tif (needscan)\n\t\txfs_dir2_data_freescan(dp, hdr, &needlog);\n\tif (needlog)\n\t\txfs_dir2_data_log_header(args, bp);\n\txfs_dir2_block_log_tail(tp, bp);\n\txfs_dir2_data_log_entry(args, bp, dep);\n\txfs_dir3_data_check(dp, bp);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xfs_dir2_block_log_leaf(xfs_trans_t *tp, struct xfs_buf *bp,\n\t\t\t\t    int first, int last);",
      "static void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_dir3_data_check",
          "args": [
            "dp",
            "bp"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "__xfs_dir3_data_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "40-210",
          "snippet": "int\n__xfs_dir3_data_check(\n\tstruct xfs_inode\t*dp,\t\t/* incore inode pointer */\n\tstruct xfs_buf\t\t*bp)\t\t/* data block's buffer */\n{\n\txfs_dir2_dataptr_t\taddr;\t\t/* addr for leaf lookup */\n\txfs_dir2_data_free_t\t*bf;\t\t/* bestfree table */\n\txfs_dir2_block_tail_t\t*btp=NULL;\t/* block tail */\n\tint\t\t\tcount;\t\t/* count of entries found */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry */\n\tchar\t\t\t*endp;\t\t/* end of useful data */\n\tint\t\t\tfreeseen;\t/* mask of bestfrees seen */\n\txfs_dahash_t\t\thash;\t\t/* hash of current name */\n\tint\t\t\ti;\t\t/* leaf index */\n\tint\t\t\tlastfree;\t/* last entry was unused */\n\txfs_dir2_leaf_entry_t\t*lep=NULL;\t/* block leaf entries */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tchar\t\t\t*p;\t\t/* current data position */\n\tint\t\t\tstale;\t\t/* count of stale leaves */\n\tstruct xfs_name\t\tname;\n\tconst struct xfs_dir_ops *ops;\n\tstruct xfs_da_geometry\t*geo;\n\n\tmp = bp->b_target->bt_mount;\n\tgeo = mp->m_dir_geo;\n\n\t/*\n\t * We can be passed a null dp here from a verifier, so we need to go the\n\t * hard way to get them.\n\t */\n\tops = xfs_dir_get_ops(mp, dp);\n\n\thdr = bp->b_addr;\n\tp = (char *)ops->data_entry_p(hdr);\n\n\tswitch (hdr->magic) {\n\tcase cpu_to_be32(XFS_DIR3_BLOCK_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_BLOCK_MAGIC):\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tlep = xfs_dir2_block_leaf_p(btp);\n\t\tendp = (char *)lep;\n\n\t\t/*\n\t\t * The number of leaf entries is limited by the size of the\n\t\t * block and the amount of space used by the data entries.\n\t\t * We don't know how much space is used by the data entries yet,\n\t\t * so just ensure that the count falls somewhere inside the\n\t\t * block right now.\n\t\t */\n\t\tXFS_WANT_CORRUPTED_RETURN(be32_to_cpu(btp->count) <\n\t\t\t((char *)btp - p) / sizeof(struct xfs_dir2_leaf_entry));\n\t\tbreak;\n\tcase cpu_to_be32(XFS_DIR3_DATA_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_DATA_MAGIC):\n\t\tendp = (char *)hdr + geo->blksize;\n\t\tbreak;\n\tdefault:\n\t\tXFS_ERROR_REPORT(\"Bad Magic\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/*\n\t * Account for zero bestfree entries.\n\t */\n\tbf = ops->data_bestfree_p(hdr);\n\tcount = lastfree = freeseen = 0;\n\tif (!bf[0].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[0].offset);\n\t\tfreeseen |= 1 << 0;\n\t}\n\tif (!bf[1].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[1].offset);\n\t\tfreeseen |= 1 << 1;\n\t}\n\tif (!bf[2].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[2].offset);\n\t\tfreeseen |= 1 << 2;\n\t}\n\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[0].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[1].length));\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[1].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t/*\n\t * Loop over the data/unused entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's unused, look for the space in the bestfree table.\n\t\t * If we find it, account for that, else make sure it\n\t\t * doesn't need to be there.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tXFS_WANT_CORRUPTED_RETURN(lastfree == 0);\n\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tbe16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)) ==\n\t\t\t\t\t       (char *)dup - (char *)hdr);\n\t\t\tdfp = xfs_dir2_data_freefind(hdr, bf, dup);\n\t\t\tif (dfp) {\n\t\t\t\ti = (int)(dfp - bf);\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\t(freeseen & (1 << i)) == 0);\n\t\t\t\tfreeseen |= 1 << i;\n\t\t\t} else {\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe16_to_cpu(dup->length) <=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t\t\t}\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t\tlastfree = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * It's a real entry.  Validate the fields.\n\t\t * If this is a block directory then make sure it's\n\t\t * in the leaf section of the block.\n\t\t * The linear search is crude but this is DEBUG code.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\tXFS_WANT_CORRUPTED_RETURN(dep->namelen != 0);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t!xfs_dir_ino_validate(mp, be64_to_cpu(dep->inumber)));\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\tbe16_to_cpu(*ops->data_entry_tag_p(dep)) ==\n\t\t\t\t\t       (char *)dep - (char *)hdr);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tops->data_get_ftype(dep) < XFS_DIR3_FT_MAX);\n\t\tcount++;\n\t\tlastfree = 0;\n\t\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\t\taddr = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,\n\t\t\t\t\t\t(xfs_dir2_data_aoff_t)\n\t\t\t\t\t\t((char *)dep - (char *)hdr));\n\t\t\tname.name = dep->name;\n\t\t\tname.len = dep->namelen;\n\t\t\thash = mp->m_dirnameops->hashname(&name);\n\t\t\tfor (i = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\t\tif (be32_to_cpu(lep[i].address) == addr &&\n\t\t\t\t    be32_to_cpu(lep[i].hashval) == hash)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i < be32_to_cpu(btp->count));\n\t\t}\n\t\tp += ops->data_entsize(dep->namelen);\n\t}\n\t/*\n\t * Need to have seen all the entries and all the bestfree slots.\n\t */\n\tXFS_WANT_CORRUPTED_RETURN(freeseen == 7);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tfor (i = stale = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\tif (lep[i].address ==\n\t\t\t    cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\t\tstale++;\n\t\t\tif (i > 0)\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe32_to_cpu(lep[i].hashval) >=\n\t\t\t\t\t\tbe32_to_cpu(lep[i - 1].hashval));\n\t\t}\n\t\tXFS_WANT_CORRUPTED_RETURN(count ==\n\t\t\tbe32_to_cpu(btp->count) - be32_to_cpu(btp->stale));\n\t\tXFS_WANT_CORRUPTED_RETURN(stale == be32_to_cpu(btp->stale));\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\n__xfs_dir3_data_check(\n\tstruct xfs_inode\t*dp,\t\t/* incore inode pointer */\n\tstruct xfs_buf\t\t*bp)\t\t/* data block's buffer */\n{\n\txfs_dir2_dataptr_t\taddr;\t\t/* addr for leaf lookup */\n\txfs_dir2_data_free_t\t*bf;\t\t/* bestfree table */\n\txfs_dir2_block_tail_t\t*btp=NULL;\t/* block tail */\n\tint\t\t\tcount;\t\t/* count of entries found */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry */\n\tchar\t\t\t*endp;\t\t/* end of useful data */\n\tint\t\t\tfreeseen;\t/* mask of bestfrees seen */\n\txfs_dahash_t\t\thash;\t\t/* hash of current name */\n\tint\t\t\ti;\t\t/* leaf index */\n\tint\t\t\tlastfree;\t/* last entry was unused */\n\txfs_dir2_leaf_entry_t\t*lep=NULL;\t/* block leaf entries */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tchar\t\t\t*p;\t\t/* current data position */\n\tint\t\t\tstale;\t\t/* count of stale leaves */\n\tstruct xfs_name\t\tname;\n\tconst struct xfs_dir_ops *ops;\n\tstruct xfs_da_geometry\t*geo;\n\n\tmp = bp->b_target->bt_mount;\n\tgeo = mp->m_dir_geo;\n\n\t/*\n\t * We can be passed a null dp here from a verifier, so we need to go the\n\t * hard way to get them.\n\t */\n\tops = xfs_dir_get_ops(mp, dp);\n\n\thdr = bp->b_addr;\n\tp = (char *)ops->data_entry_p(hdr);\n\n\tswitch (hdr->magic) {\n\tcase cpu_to_be32(XFS_DIR3_BLOCK_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_BLOCK_MAGIC):\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tlep = xfs_dir2_block_leaf_p(btp);\n\t\tendp = (char *)lep;\n\n\t\t/*\n\t\t * The number of leaf entries is limited by the size of the\n\t\t * block and the amount of space used by the data entries.\n\t\t * We don't know how much space is used by the data entries yet,\n\t\t * so just ensure that the count falls somewhere inside the\n\t\t * block right now.\n\t\t */\n\t\tXFS_WANT_CORRUPTED_RETURN(be32_to_cpu(btp->count) <\n\t\t\t((char *)btp - p) / sizeof(struct xfs_dir2_leaf_entry));\n\t\tbreak;\n\tcase cpu_to_be32(XFS_DIR3_DATA_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_DATA_MAGIC):\n\t\tendp = (char *)hdr + geo->blksize;\n\t\tbreak;\n\tdefault:\n\t\tXFS_ERROR_REPORT(\"Bad Magic\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/*\n\t * Account for zero bestfree entries.\n\t */\n\tbf = ops->data_bestfree_p(hdr);\n\tcount = lastfree = freeseen = 0;\n\tif (!bf[0].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[0].offset);\n\t\tfreeseen |= 1 << 0;\n\t}\n\tif (!bf[1].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[1].offset);\n\t\tfreeseen |= 1 << 1;\n\t}\n\tif (!bf[2].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[2].offset);\n\t\tfreeseen |= 1 << 2;\n\t}\n\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[0].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[1].length));\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[1].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t/*\n\t * Loop over the data/unused entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's unused, look for the space in the bestfree table.\n\t\t * If we find it, account for that, else make sure it\n\t\t * doesn't need to be there.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tXFS_WANT_CORRUPTED_RETURN(lastfree == 0);\n\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tbe16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)) ==\n\t\t\t\t\t       (char *)dup - (char *)hdr);\n\t\t\tdfp = xfs_dir2_data_freefind(hdr, bf, dup);\n\t\t\tif (dfp) {\n\t\t\t\ti = (int)(dfp - bf);\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\t(freeseen & (1 << i)) == 0);\n\t\t\t\tfreeseen |= 1 << i;\n\t\t\t} else {\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe16_to_cpu(dup->length) <=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t\t\t}\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t\tlastfree = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * It's a real entry.  Validate the fields.\n\t\t * If this is a block directory then make sure it's\n\t\t * in the leaf section of the block.\n\t\t * The linear search is crude but this is DEBUG code.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\tXFS_WANT_CORRUPTED_RETURN(dep->namelen != 0);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t!xfs_dir_ino_validate(mp, be64_to_cpu(dep->inumber)));\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\tbe16_to_cpu(*ops->data_entry_tag_p(dep)) ==\n\t\t\t\t\t       (char *)dep - (char *)hdr);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tops->data_get_ftype(dep) < XFS_DIR3_FT_MAX);\n\t\tcount++;\n\t\tlastfree = 0;\n\t\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\t\taddr = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,\n\t\t\t\t\t\t(xfs_dir2_data_aoff_t)\n\t\t\t\t\t\t((char *)dep - (char *)hdr));\n\t\t\tname.name = dep->name;\n\t\t\tname.len = dep->namelen;\n\t\t\thash = mp->m_dirnameops->hashname(&name);\n\t\t\tfor (i = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\t\tif (be32_to_cpu(lep[i].address) == addr &&\n\t\t\t\t    be32_to_cpu(lep[i].hashval) == hash)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i < be32_to_cpu(btp->count));\n\t\t}\n\t\tp += ops->data_entsize(dep->namelen);\n\t}\n\t/*\n\t * Need to have seen all the entries and all the bestfree slots.\n\t */\n\tXFS_WANT_CORRUPTED_RETURN(freeseen == 7);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tfor (i = stale = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\tif (lep[i].address ==\n\t\t\t    cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\t\tstale++;\n\t\t\tif (i > 0)\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe32_to_cpu(lep[i].hashval) >=\n\t\t\t\t\t\tbe32_to_cpu(lep[i - 1].hashval));\n\t\t}\n\t\tXFS_WANT_CORRUPTED_RETURN(count ==\n\t\t\tbe32_to_cpu(btp->count) - be32_to_cpu(btp->stale));\n\t\tXFS_WANT_CORRUPTED_RETURN(stale == be32_to_cpu(btp->stale));\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_log_entry",
          "args": [
            "args",
            "bp",
            "dep"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_log_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "640-656",
          "snippet": "void\nxfs_dir2_data_log_entry(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_entry_t\t*dep)\t\t/* data entry pointer */\n{\n\tstruct xfs_dir2_data_hdr *hdr = bp->b_addr;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\txfs_trans_log_buf(args->trans, bp, (uint)((char *)dep - (char *)hdr),\n\t\t(uint)((char *)(args->dp->d_ops->data_entry_tag_p(dep) + 1) -\n\t\t       (char *)hdr - 1));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dir2_data_log_entry(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_entry_t\t*dep)\t\t/* data entry pointer */\n{\n\tstruct xfs_dir2_data_hdr *hdr = bp->b_addr;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\txfs_trans_log_buf(args->trans, bp, (uint)((char *)dep - (char *)hdr),\n\t\t(uint)((char *)(args->dp->d_ops->data_entry_tag_p(dep) + 1) -\n\t\t       (char *)hdr - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_log_tail",
          "args": [
            "tp",
            "bp"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_log_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
          "lines": "587-598",
          "snippet": "static void\nxfs_dir2_block_log_tail(\n\txfs_trans_t\t\t*tp,\t\t/* transaction structure */\n\tstruct xfs_buf\t\t*bp)\t\t/* block buffer */\n{\n\txfs_dir2_data_hdr_t\t*hdr = bp->b_addr;\n\txfs_dir2_block_tail_t\t*btp;\n\n\tbtp = xfs_dir2_block_tail_p(tp->t_mountp->m_dir_geo, hdr);\n\txfs_trans_log_buf(tp, bp, (uint)((char *)btp - (char *)hdr),\n\t\t(uint)((char *)(btp + 1) - (char *)hdr - 1));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);\n\nstatic void\nxfs_dir2_block_log_tail(\n\txfs_trans_t\t\t*tp,\t\t/* transaction structure */\n\tstruct xfs_buf\t\t*bp)\t\t/* block buffer */\n{\n\txfs_dir2_data_hdr_t\t*hdr = bp->b_addr;\n\txfs_dir2_block_tail_t\t*btp;\n\n\tbtp = xfs_dir2_block_tail_p(tp->t_mountp->m_dir_geo, hdr);\n\txfs_trans_log_buf(tp, bp, (uint)((char *)btp - (char *)hdr),\n\t\t(uint)((char *)(btp + 1) - (char *)hdr - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_log_header",
          "args": [
            "args",
            "bp"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_log_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "661-677",
          "snippet": "void\nxfs_dir2_data_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n#ifdef DEBUG\n\tstruct xfs_dir2_data_hdr *hdr = bp->b_addr;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n#endif\n\n\txfs_trans_log_buf(args->trans, bp, 0,\n\t\t\t  args->dp->d_ops->data_entry_offset - 1);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dir2_data_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n#ifdef DEBUG\n\tstruct xfs_dir2_data_hdr *hdr = bp->b_addr;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n#endif\n\n\txfs_trans_log_buf(args->trans, bp, 0,\n\t\t\t  args->dp->d_ops->data_entry_offset - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_freescan",
          "args": [
            "dp",
            "hdr",
            "&needlog"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_freescan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "500-559",
          "snippet": "void\nxfs_dir2_data_freescan(\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_dir2_data_hdr *hdr,\n\tint\t\t\t*loghead)\n{\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* active data entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused data entry */\n\tstruct xfs_dir2_data_free *bf;\n\tchar\t\t\t*endp;\t\t/* end of block's data */\n\tchar\t\t\t*p;\t\t/* current entry pointer */\n\tstruct xfs_da_geometry\t*geo = dp->i_mount->m_dir_geo;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\t/*\n\t * Start by clearing the table.\n\t */\n\tbf = dp->d_ops->data_bestfree_p(hdr);\n\tmemset(bf, 0, sizeof(*bf) * XFS_DIR2_DATA_FD_COUNT);\n\t*loghead = 1;\n\t/*\n\t * Set up pointers.\n\t */\n\tp = (char *)dp->d_ops->data_entry_p(hdr);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tendp = (char *)xfs_dir2_block_leaf_p(btp);\n\t} else\n\t\tendp = (char *)hdr + geo->blksize;\n\t/*\n\t * Loop over the block's entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's a free entry, insert it.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tASSERT((char *)dup - (char *)hdr ==\n\t\t\t       be16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)));\n\t\t\txfs_dir2_data_freeinsert(hdr, bf, dup, loghead);\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t}\n\t\t/*\n\t\t * For active entries, check their tags and skip them.\n\t\t */\n\t\telse {\n\t\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\t\tASSERT((char *)dep - (char *)hdr ==\n\t\t\t       be16_to_cpu(*dp->d_ops->data_entry_tag_p(dep)));\n\t\t\tp += dp->d_ops->data_entsize(dep->namelen);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dir2_data_freescan(\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_dir2_data_hdr *hdr,\n\tint\t\t\t*loghead)\n{\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* active data entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused data entry */\n\tstruct xfs_dir2_data_free *bf;\n\tchar\t\t\t*endp;\t\t/* end of block's data */\n\tchar\t\t\t*p;\t\t/* current entry pointer */\n\tstruct xfs_da_geometry\t*geo = dp->i_mount->m_dir_geo;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\t/*\n\t * Start by clearing the table.\n\t */\n\tbf = dp->d_ops->data_bestfree_p(hdr);\n\tmemset(bf, 0, sizeof(*bf) * XFS_DIR2_DATA_FD_COUNT);\n\t*loghead = 1;\n\t/*\n\t * Set up pointers.\n\t */\n\tp = (char *)dp->d_ops->data_entry_p(hdr);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tendp = (char *)xfs_dir2_block_leaf_p(btp);\n\t} else\n\t\tendp = (char *)hdr + geo->blksize;\n\t/*\n\t * Loop over the block's entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's a free entry, insert it.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tASSERT((char *)dup - (char *)hdr ==\n\t\t\t       be16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)));\n\t\t\txfs_dir2_data_freeinsert(hdr, bf, dup, loghead);\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t}\n\t\t/*\n\t\t * For active entries, check their tags and skip them.\n\t\t */\n\t\telse {\n\t\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\t\tASSERT((char *)dep - (char *)hdr ==\n\t\t\t       be16_to_cpu(*dp->d_ops->data_entry_tag_p(dep)));\n\t\t\tp += dp->d_ops->data_entsize(dep->namelen);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "(char *)dep - (char *)hdr"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_entry_tag_p",
          "args": [
            "dep"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_put_ftype",
          "args": [
            "dep",
            "args->filetype"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dep->name",
            "args->name",
            "args->namelen"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "args->inumber"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_use_free",
          "args": [
            "args",
            "bp",
            "dup",
            "(xfs_dir2_data_aoff_t)((char *)dup - (char *)hdr)",
            "(xfs_dir2_data_aoff_t)len",
            "&needlog",
            "&needscan"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_use_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "899-1048",
          "snippet": "void\nxfs_dir2_data_use_free(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_unused_t\t*dup,\t\t/* unused entry */\n\txfs_dir2_data_aoff_t\toffset,\t\t/* starting offset to use */\n\txfs_dir2_data_aoff_t\tlen,\t\t/* length to use */\n\tint\t\t\t*needlogp,\t/* out: need to log header */\n\tint\t\t\t*needscanp)\t/* out: need regen bestfree */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree pointer */\n\tint\t\t\tmatchback;\t/* matches end of freespace */\n\tint\t\t\tmatchfront;\t/* matches start of freespace */\n\tint\t\t\tneedscan;\t/* need to regen bestfree */\n\txfs_dir2_data_unused_t\t*newdup;\t/* new unused entry */\n\txfs_dir2_data_unused_t\t*newdup2;\t/* another new unused entry */\n\tint\t\t\toldlen;\t\t/* old unused entry's length */\n\tstruct xfs_dir2_data_free *bf;\n\n\thdr = bp->b_addr;\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\tASSERT(be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG);\n\tASSERT(offset >= (char *)dup - (char *)hdr);\n\tASSERT(offset + len <= (char *)dup + be16_to_cpu(dup->length) - (char *)hdr);\n\tASSERT((char *)dup - (char *)hdr == be16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)));\n\t/*\n\t * Look up the entry in the bestfree table.\n\t */\n\toldlen = be16_to_cpu(dup->length);\n\tbf = args->dp->d_ops->data_bestfree_p(hdr);\n\tdfp = xfs_dir2_data_freefind(hdr, bf, dup);\n\tASSERT(dfp || oldlen <= be16_to_cpu(bf[2].length));\n\t/*\n\t * Check for alignment with front and back of the entry.\n\t */\n\tmatchfront = (char *)dup - (char *)hdr == offset;\n\tmatchback = (char *)dup + oldlen - (char *)hdr == offset + len;\n\tASSERT(*needscanp == 0);\n\tneedscan = 0;\n\t/*\n\t * If we matched it exactly we just need to get rid of it from\n\t * the bestfree table.\n\t */\n\tif (matchfront && matchback) {\n\t\tif (dfp) {\n\t\t\tneedscan = (bf[2].offset != 0);\n\t\t\tif (!needscan)\n\t\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp,\n\t\t\t\t\t\t\t needlogp);\n\t\t}\n\t}\n\t/*\n\t * We match the first part of the entry.\n\t * Make a new entry with the remaining freespace.\n\t */\n\telse if (matchfront) {\n\t\tnewdup = (xfs_dir2_data_unused_t *)((char *)hdr + offset + len);\n\t\tnewdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup->length = cpu_to_be16(oldlen - len);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\t/*\n\t\t * If it was in the table, remove it and add the new one.\n\t\t */\n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\tdfp = xfs_dir2_data_freeinsert(hdr, bf, newdup,\n\t\t\t\t\t\t       needlogp);\n\t\t\tASSERT(dfp != NULL);\n\t\t\tASSERT(dfp->length == newdup->length);\n\t\t\tASSERT(be16_to_cpu(dfp->offset) == (char *)newdup - (char *)hdr);\n\t\t\t/*\n\t\t\t * If we got inserted at the last slot,\n\t\t\t * that means we don't know if there was a better\n\t\t\t * choice for the last slot, or not.  Rescan.\n\t\t\t */\n\t\t\tneedscan = dfp == &bf[2];\n\t\t}\n\t}\n\t/*\n\t * We match the last part of the entry.\n\t * Trim the allocated space off the tail of the entry.\n\t */\n\telse if (matchback) {\n\t\tnewdup = dup;\n\t\tnewdup->length = cpu_to_be16(((char *)hdr + offset) - (char *)newdup);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\t/*\n\t\t * If it was in the table, remove it and add the new one.\n\t\t */\n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\tdfp = xfs_dir2_data_freeinsert(hdr, bf, newdup,\n\t\t\t\t\t\t       needlogp);\n\t\t\tASSERT(dfp != NULL);\n\t\t\tASSERT(dfp->length == newdup->length);\n\t\t\tASSERT(be16_to_cpu(dfp->offset) == (char *)newdup - (char *)hdr);\n\t\t\t/*\n\t\t\t * If we got inserted at the last slot,\n\t\t\t * that means we don't know if there was a better\n\t\t\t * choice for the last slot, or not.  Rescan.\n\t\t\t */\n\t\t\tneedscan = dfp == &bf[2];\n\t\t}\n\t}\n\t/*\n\t * Poking out the middle of an entry.\n\t * Make two new entries.\n\t */\n\telse {\n\t\tnewdup = dup;\n\t\tnewdup->length = cpu_to_be16(((char *)hdr + offset) - (char *)newdup);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\tnewdup2 = (xfs_dir2_data_unused_t *)((char *)hdr + offset + len);\n\t\tnewdup2->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup2->length = cpu_to_be16(oldlen - len - be16_to_cpu(newdup->length));\n\t\t*xfs_dir2_data_unused_tag_p(newdup2) =\n\t\t\tcpu_to_be16((char *)newdup2 - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup2);\n\t\t/*\n\t\t * If the old entry was in the table, we need to scan\n\t\t * if the 3rd entry was valid, since these entries\n\t\t * are smaller than the old one.\n\t\t * If we don't need to scan that means there were 1 or 2\n\t\t * entries in the table, and removing the old and adding\n\t\t * the 2 new will work.\n\t\t */\n\t\tif (dfp) {\n\t\t\tneedscan = (bf[2].length != 0);\n\t\t\tif (!needscan) {\n\t\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp,\n\t\t\t\t\t\t\t needlogp);\n\t\t\t\txfs_dir2_data_freeinsert(hdr, bf, newdup,\n\t\t\t\t\t\t\t needlogp);\n\t\t\t\txfs_dir2_data_freeinsert(hdr, bf, newdup2,\n\t\t\t\t\t\t\t needlogp);\n\t\t\t}\n\t\t}\n\t}\n\t*needscanp = needscan;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dir2_data_use_free(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_unused_t\t*dup,\t\t/* unused entry */\n\txfs_dir2_data_aoff_t\toffset,\t\t/* starting offset to use */\n\txfs_dir2_data_aoff_t\tlen,\t\t/* length to use */\n\tint\t\t\t*needlogp,\t/* out: need to log header */\n\tint\t\t\t*needscanp)\t/* out: need regen bestfree */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree pointer */\n\tint\t\t\tmatchback;\t/* matches end of freespace */\n\tint\t\t\tmatchfront;\t/* matches start of freespace */\n\tint\t\t\tneedscan;\t/* need to regen bestfree */\n\txfs_dir2_data_unused_t\t*newdup;\t/* new unused entry */\n\txfs_dir2_data_unused_t\t*newdup2;\t/* another new unused entry */\n\tint\t\t\toldlen;\t\t/* old unused entry's length */\n\tstruct xfs_dir2_data_free *bf;\n\n\thdr = bp->b_addr;\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\tASSERT(be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG);\n\tASSERT(offset >= (char *)dup - (char *)hdr);\n\tASSERT(offset + len <= (char *)dup + be16_to_cpu(dup->length) - (char *)hdr);\n\tASSERT((char *)dup - (char *)hdr == be16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)));\n\t/*\n\t * Look up the entry in the bestfree table.\n\t */\n\toldlen = be16_to_cpu(dup->length);\n\tbf = args->dp->d_ops->data_bestfree_p(hdr);\n\tdfp = xfs_dir2_data_freefind(hdr, bf, dup);\n\tASSERT(dfp || oldlen <= be16_to_cpu(bf[2].length));\n\t/*\n\t * Check for alignment with front and back of the entry.\n\t */\n\tmatchfront = (char *)dup - (char *)hdr == offset;\n\tmatchback = (char *)dup + oldlen - (char *)hdr == offset + len;\n\tASSERT(*needscanp == 0);\n\tneedscan = 0;\n\t/*\n\t * If we matched it exactly we just need to get rid of it from\n\t * the bestfree table.\n\t */\n\tif (matchfront && matchback) {\n\t\tif (dfp) {\n\t\t\tneedscan = (bf[2].offset != 0);\n\t\t\tif (!needscan)\n\t\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp,\n\t\t\t\t\t\t\t needlogp);\n\t\t}\n\t}\n\t/*\n\t * We match the first part of the entry.\n\t * Make a new entry with the remaining freespace.\n\t */\n\telse if (matchfront) {\n\t\tnewdup = (xfs_dir2_data_unused_t *)((char *)hdr + offset + len);\n\t\tnewdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup->length = cpu_to_be16(oldlen - len);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\t/*\n\t\t * If it was in the table, remove it and add the new one.\n\t\t */\n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\tdfp = xfs_dir2_data_freeinsert(hdr, bf, newdup,\n\t\t\t\t\t\t       needlogp);\n\t\t\tASSERT(dfp != NULL);\n\t\t\tASSERT(dfp->length == newdup->length);\n\t\t\tASSERT(be16_to_cpu(dfp->offset) == (char *)newdup - (char *)hdr);\n\t\t\t/*\n\t\t\t * If we got inserted at the last slot,\n\t\t\t * that means we don't know if there was a better\n\t\t\t * choice for the last slot, or not.  Rescan.\n\t\t\t */\n\t\t\tneedscan = dfp == &bf[2];\n\t\t}\n\t}\n\t/*\n\t * We match the last part of the entry.\n\t * Trim the allocated space off the tail of the entry.\n\t */\n\telse if (matchback) {\n\t\tnewdup = dup;\n\t\tnewdup->length = cpu_to_be16(((char *)hdr + offset) - (char *)newdup);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\t/*\n\t\t * If it was in the table, remove it and add the new one.\n\t\t */\n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\tdfp = xfs_dir2_data_freeinsert(hdr, bf, newdup,\n\t\t\t\t\t\t       needlogp);\n\t\t\tASSERT(dfp != NULL);\n\t\t\tASSERT(dfp->length == newdup->length);\n\t\t\tASSERT(be16_to_cpu(dfp->offset) == (char *)newdup - (char *)hdr);\n\t\t\t/*\n\t\t\t * If we got inserted at the last slot,\n\t\t\t * that means we don't know if there was a better\n\t\t\t * choice for the last slot, or not.  Rescan.\n\t\t\t */\n\t\t\tneedscan = dfp == &bf[2];\n\t\t}\n\t}\n\t/*\n\t * Poking out the middle of an entry.\n\t * Make two new entries.\n\t */\n\telse {\n\t\tnewdup = dup;\n\t\tnewdup->length = cpu_to_be16(((char *)hdr + offset) - (char *)newdup);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\tnewdup2 = (xfs_dir2_data_unused_t *)((char *)hdr + offset + len);\n\t\tnewdup2->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup2->length = cpu_to_be16(oldlen - len - be16_to_cpu(newdup->length));\n\t\t*xfs_dir2_data_unused_tag_p(newdup2) =\n\t\t\tcpu_to_be16((char *)newdup2 - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup2);\n\t\t/*\n\t\t * If the old entry was in the table, we need to scan\n\t\t * if the 3rd entry was valid, since these entries\n\t\t * are smaller than the old one.\n\t\t * If we don't need to scan that means there were 1 or 2\n\t\t * entries in the table, and removing the old and adding\n\t\t * the 2 new will work.\n\t\t */\n\t\tif (dfp) {\n\t\t\tneedscan = (bf[2].length != 0);\n\t\t\tif (!needscan) {\n\t\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp,\n\t\t\t\t\t\t\t needlogp);\n\t\t\t\txfs_dir2_data_freeinsert(hdr, bf, newdup,\n\t\t\t\t\t\t\t needlogp);\n\t\t\t\txfs_dir2_data_freeinsert(hdr, bf, newdup2,\n\t\t\t\t\t\t\t needlogp);\n\t\t\t}\n\t\t}\n\t}\n\t*needscanp = needscan;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(char *)dup - (char *)hdr"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_log_leaf",
          "args": [
            "tp",
            "bp",
            "lfloglow",
            "lfloghigh"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_log_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
          "lines": "567-582",
          "snippet": "static void\nxfs_dir2_block_log_leaf(\n\txfs_trans_t\t\t*tp,\t\t/* transaction structure */\n\tstruct xfs_buf\t\t*bp,\t\t/* block buffer */\n\tint\t\t\tfirst,\t\t/* index of first logged leaf */\n\tint\t\t\tlast)\t\t/* index of last logged leaf */\n{\n\txfs_dir2_data_hdr_t\t*hdr = bp->b_addr;\n\txfs_dir2_leaf_entry_t\t*blp;\n\txfs_dir2_block_tail_t\t*btp;\n\n\tbtp = xfs_dir2_block_tail_p(tp->t_mountp->m_dir_geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\txfs_trans_log_buf(tp, bp, (uint)((char *)&blp[first] - (char *)hdr),\n\t\t(uint)((char *)&blp[last + 1] - (char *)hdr - 1));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir2_block_log_leaf(xfs_trans_t *tp, struct xfs_buf *bp,\n\t\t\t\t    int first, int last);",
            "static void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_block_log_leaf(xfs_trans_t *tp, struct xfs_buf *bp,\n\t\t\t\t    int first, int last);\nstatic void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);\n\nstatic void\nxfs_dir2_block_log_leaf(\n\txfs_trans_t\t\t*tp,\t\t/* transaction structure */\n\tstruct xfs_buf\t\t*bp,\t\t/* block buffer */\n\tint\t\t\tfirst,\t\t/* index of first logged leaf */\n\tint\t\t\tlast)\t\t/* index of last logged leaf */\n{\n\txfs_dir2_data_hdr_t\t*hdr = bp->b_addr;\n\txfs_dir2_leaf_entry_t\t*blp;\n\txfs_dir2_block_tail_t\t*btp;\n\n\tbtp = xfs_dir2_block_tail_p(tp->t_mountp->m_dir_geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\txfs_trans_log_buf(tp, bp, (uint)((char *)&blp[first] - (char *)hdr),\n\t\t(uint)((char *)&blp[last + 1] - (char *)hdr - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "xfs_dir2_byte_to_dataptr(\n\t\t\t\t(char *)dep - (char *)hdr)"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_byte_to_dataptr",
          "args": [
            "(char *)dep - (char *)hdr"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_byte_to_dataptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "204-208",
          "snippet": "static inline xfs_dir2_dataptr_t\nxfs_dir2_byte_to_dataptr(xfs_dir2_off_t by)\n{\n\treturn (xfs_dir2_dataptr_t)(by >> XFS_DIR2_DATA_ALIGN_LOG);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_dataptr_t\nxfs_dir2_byte_to_dataptr(xfs_dir2_off_t by)\n{\n\treturn (xfs_dir2_dataptr_t)(by >> XFS_DIR2_DATA_ALIGN_LOG);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "args->hashval"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_add_cpu",
          "args": [
            "&btp->stale",
            "-1"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX",
          "args": [
            "highstale",
            "lfloghigh"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIN",
          "args": [
            "mid",
            "lfloglow"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&blp[mid + 1]",
            "&blp[mid]",
            "(highstale - mid) * sizeof(*blp)"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "highstale < be32_to_cpu(btp->count)"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btp->count"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX",
          "args": [
            "mid",
            "lfloghigh"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIN",
          "args": [
            "lowstale",
            "lfloglow"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&blp[lowstale]",
            "&blp[lowstale + 1]",
            "(mid - lowstale) * sizeof(*blp)"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btp->count"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_NULL_DATAPTR"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btp->count"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_NULL_DATAPTR"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "blp",
            "&blp[1]",
            "mid * sizeof(*blp)"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_add_cpu",
          "args": [
            "&btp->count",
            "1"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(char *)enddup - (char *)hdr + be16_to_cpu(enddup->length) -\n\t\t\t sizeof(*blp)"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "enddup->length"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "blp[mid].hashval"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "blp[mid].hashval"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btp->count"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btp->count"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_leaf_p",
          "args": [
            "btp"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_leaf_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "601-605",
          "snippet": "static inline struct xfs_dir2_leaf_entry *\nxfs_dir2_block_leaf_p(struct xfs_dir2_block_tail *btp)\n{\n\treturn ((struct xfs_dir2_leaf_entry *)btp) - be32_to_cpu(btp->count);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_leaf_entry *\nxfs_dir2_block_leaf_p(struct xfs_dir2_block_tail *btp)\n{\n\treturn ((struct xfs_dir2_leaf_entry *)btp) - be32_to_cpu(btp->count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_compact",
          "args": [
            "args",
            "bp",
            "hdr",
            "btp",
            "blp",
            "&needlog",
            "&lfloghigh",
            "&lfloglow"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_compact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
          "lines": "279-325",
          "snippet": "static void\nxfs_dir2_block_compact(\n\tstruct xfs_da_args\t\t*args,\n\tstruct xfs_buf\t\t\t*bp,\n\tstruct xfs_dir2_data_hdr\t*hdr,\n\tstruct xfs_dir2_block_tail\t*btp,\n\tstruct xfs_dir2_leaf_entry\t*blp,\n\tint\t\t\t\t*needlog,\n\tint\t\t\t\t*lfloghigh,\n\tint\t\t\t\t*lfloglow)\n{\n\tint\t\t\tfromidx;\t/* source leaf index */\n\tint\t\t\ttoidx;\t\t/* target leaf index */\n\tint\t\t\tneedscan = 0;\n\tint\t\t\thighstale;\t/* high stale index */\n\n\tfromidx = toidx = be32_to_cpu(btp->count) - 1;\n\thighstale = *lfloghigh = -1;\n\tfor (; fromidx >= 0; fromidx--) {\n\t\tif (blp[fromidx].address == cpu_to_be32(XFS_DIR2_NULL_DATAPTR)) {\n\t\t\tif (highstale == -1)\n\t\t\t\thighstale = toidx;\n\t\t\telse {\n\t\t\t\tif (*lfloghigh == -1)\n\t\t\t\t\t*lfloghigh = toidx;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (fromidx < toidx)\n\t\t\tblp[toidx] = blp[fromidx];\n\t\ttoidx--;\n\t}\n\t*lfloglow = toidx + 1 - (be32_to_cpu(btp->stale) - 1);\n\t*lfloghigh -= be32_to_cpu(btp->stale) - 1;\n\tbe32_add_cpu(&btp->count, -(be32_to_cpu(btp->stale) - 1));\n\txfs_dir2_data_make_free(args, bp,\n\t\t(xfs_dir2_data_aoff_t)((char *)blp - (char *)hdr),\n\t\t(xfs_dir2_data_aoff_t)((be32_to_cpu(btp->stale) - 1) * sizeof(*blp)),\n\t\tneedlog, &needscan);\n\tbtp->stale = cpu_to_be32(1);\n\t/*\n\t * If we now need to rebuild the bestfree map, do so.\n\t * This needs to happen before the next call to use_free.\n\t */\n\tif (needscan)\n\t\txfs_dir2_data_freescan(args->dp, hdr, needlog);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);\n\nstatic void\nxfs_dir2_block_compact(\n\tstruct xfs_da_args\t\t*args,\n\tstruct xfs_buf\t\t\t*bp,\n\tstruct xfs_dir2_data_hdr\t*hdr,\n\tstruct xfs_dir2_block_tail\t*btp,\n\tstruct xfs_dir2_leaf_entry\t*blp,\n\tint\t\t\t\t*needlog,\n\tint\t\t\t\t*lfloghigh,\n\tint\t\t\t\t*lfloglow)\n{\n\tint\t\t\tfromidx;\t/* source leaf index */\n\tint\t\t\ttoidx;\t\t/* target leaf index */\n\tint\t\t\tneedscan = 0;\n\tint\t\t\thighstale;\t/* high stale index */\n\n\tfromidx = toidx = be32_to_cpu(btp->count) - 1;\n\thighstale = *lfloghigh = -1;\n\tfor (; fromidx >= 0; fromidx--) {\n\t\tif (blp[fromidx].address == cpu_to_be32(XFS_DIR2_NULL_DATAPTR)) {\n\t\t\tif (highstale == -1)\n\t\t\t\thighstale = toidx;\n\t\t\telse {\n\t\t\t\tif (*lfloghigh == -1)\n\t\t\t\t\t*lfloghigh = toidx;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (fromidx < toidx)\n\t\t\tblp[toidx] = blp[fromidx];\n\t\ttoidx--;\n\t}\n\t*lfloglow = toidx + 1 - (be32_to_cpu(btp->stale) - 1);\n\t*lfloghigh -= be32_to_cpu(btp->stale) - 1;\n\tbe32_add_cpu(&btp->count, -(be32_to_cpu(btp->stale) - 1));\n\txfs_dir2_data_make_free(args, bp,\n\t\t(xfs_dir2_data_aoff_t)((char *)blp - (char *)hdr),\n\t\t(xfs_dir2_data_aoff_t)((be32_to_cpu(btp->stale) - 1) * sizeof(*blp)),\n\t\tneedlog, &needscan);\n\tbtp->stale = cpu_to_be32(1);\n\t/*\n\t * If we now need to rebuild the bestfree map, do so.\n\t * This needs to happen before the next call to use_free.\n\t */\n\tif (needscan)\n\t\txfs_dir2_data_freescan(args->dp, hdr, needlog);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leaf_addname",
          "args": [
            "args"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leaf_addname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "601-901",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_leaf_addname(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\t__be16\t\t\t*bestsp;\t/* freespace table in leaf */\n\tint\t\t\tcompact;\t/* need to compact leaves */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\tstruct xfs_buf\t\t*dbp;\t\t/* data block buffer */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data block entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* data unused entry */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tgrown;\t\t/* allocated new data block */\n\tint\t\t\thighstale;\t/* index of next stale leaf */\n\tint\t\t\ti;\t\t/* temporary, index */\n\tint\t\t\tindex;\t\t/* leaf table position */\n\tstruct xfs_buf\t\t*lbp;\t\t/* leaf's buffer */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\tint\t\t\tlength;\t\t/* length of new entry */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry table pointer */\n\tint\t\t\tlfloglow;\t/* low leaf logging index */\n\tint\t\t\tlfloghigh;\t/* high leaf logging index */\n\tint\t\t\tlowstale;\t/* index of prev stale leaf */\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf tail pointer */\n\tint\t\t\tneedbytes;\t/* leaf block bytes needed */\n\tint\t\t\tneedlog;\t/* need to log data header */\n\tint\t\t\tneedscan;\t/* need to rescan data free */\n\t__be16\t\t\t*tagp;\t\t/* end of data entry */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\txfs_dir2_db_t\t\tuse_block;\t/* data block number */\n\tstruct xfs_dir2_data_free *bf;\t\t/* bestfree table */\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\ttrace_xfs_dir2_leaf_addname(args);\n\n\tdp = args->dp;\n\ttp = args->trans;\n\n\terror = xfs_dir3_leaf_read(tp, dp, args->geo->leafblk, -1, &lbp);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Look up the entry by hash value and name.\n\t * We know it's not there, our caller has already done a lookup.\n\t * So the index is of the entry to insert in front of.\n\t * But if there are dup hash values the index is of the first of those.\n\t */\n\tindex = xfs_dir2_leaf_search_hash(args, lbp);\n\tleaf = lbp->b_addr;\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\tbestsp = xfs_dir2_leaf_bests_p(ltp);\n\tlength = dp->d_ops->data_entsize(args->namelen);\n\n\t/*\n\t * See if there are any entries with the same hash value\n\t * and space in their block for the new entry.\n\t * This is good because it puts multiple same-hash value entries\n\t * in a data block, improving the lookup of those entries.\n\t */\n\tfor (use_block = -1, lep = &ents[index];\n\t     index < leafhdr.count && be32_to_cpu(lep->hashval) == args->hashval;\n\t     index++, lep++) {\n\t\tif (be32_to_cpu(lep->address) == XFS_DIR2_NULL_DATAPTR)\n\t\t\tcontinue;\n\t\ti = xfs_dir2_dataptr_to_db(args->geo, be32_to_cpu(lep->address));\n\t\tASSERT(i < be32_to_cpu(ltp->bestcount));\n\t\tASSERT(bestsp[i] != cpu_to_be16(NULLDATAOFF));\n\t\tif (be16_to_cpu(bestsp[i]) >= length) {\n\t\t\tuse_block = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * Didn't find a block yet, linear search all the data blocks.\n\t */\n\tif (use_block == -1) {\n\t\tfor (i = 0; i < be32_to_cpu(ltp->bestcount); i++) {\n\t\t\t/*\n\t\t\t * Remember a block we see that's missing.\n\t\t\t */\n\t\t\tif (bestsp[i] == cpu_to_be16(NULLDATAOFF) &&\n\t\t\t    use_block == -1)\n\t\t\t\tuse_block = i;\n\t\t\telse if (be16_to_cpu(bestsp[i]) >= length) {\n\t\t\t\tuse_block = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * How many bytes do we need in the leaf block?\n\t */\n\tneedbytes = 0;\n\tif (!leafhdr.stale)\n\t\tneedbytes += sizeof(xfs_dir2_leaf_entry_t);\n\tif (use_block == -1)\n\t\tneedbytes += sizeof(xfs_dir2_data_off_t);\n\n\t/*\n\t * Now kill use_block if it refers to a missing block, so we\n\t * can use it as an indication of allocation needed.\n\t */\n\tif (use_block != -1 && bestsp[use_block] == cpu_to_be16(NULLDATAOFF))\n\t\tuse_block = -1;\n\t/*\n\t * If we don't have enough free bytes but we can make enough\n\t * by compacting out stale entries, we'll do that.\n\t */\n\tif ((char *)bestsp - (char *)&ents[leafhdr.count] < needbytes &&\n\t    leafhdr.stale > 1)\n\t\tcompact = 1;\n\n\t/*\n\t * Otherwise if we don't have enough free bytes we need to\n\t * convert to node form.\n\t */\n\telse if ((char *)bestsp - (char *)&ents[leafhdr.count] < needbytes) {\n\t\t/*\n\t\t * Just checking or no space reservation, give up.\n\t\t */\n\t\tif ((args->op_flags & XFS_DA_OP_JUSTCHECK) ||\n\t\t\t\t\t\t\targs->total == 0) {\n\t\t\txfs_trans_brelse(tp, lbp);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\t/*\n\t\t * Convert to node form.\n\t\t */\n\t\terror = xfs_dir2_leaf_to_node(args, lbp);\n\t\tif (error)\n\t\t\treturn error;\n\t\t/*\n\t\t * Then add the new entry.\n\t\t */\n\t\treturn xfs_dir2_node_addname(args);\n\t}\n\t/*\n\t * Otherwise it will fit without compaction.\n\t */\n\telse\n\t\tcompact = 0;\n\t/*\n\t * If just checking, then it will fit unless we needed to allocate\n\t * a new data block.\n\t */\n\tif (args->op_flags & XFS_DA_OP_JUSTCHECK) {\n\t\txfs_trans_brelse(tp, lbp);\n\t\treturn use_block == -1 ? -ENOSPC : 0;\n\t}\n\t/*\n\t * If no allocations are allowed, return now before we've\n\t * changed anything.\n\t */\n\tif (args->total == 0 && use_block == -1) {\n\t\txfs_trans_brelse(tp, lbp);\n\t\treturn -ENOSPC;\n\t}\n\t/*\n\t * Need to compact the leaf entries, removing stale ones.\n\t * Leave one stale entry behind - the one closest to our\n\t * insertion index - and we'll shift that one to our insertion\n\t * point later.\n\t */\n\tif (compact) {\n\t\txfs_dir3_leaf_compact_x1(&leafhdr, ents, &index, &lowstale,\n\t\t\t&highstale, &lfloglow, &lfloghigh);\n\t}\n\t/*\n\t * There are stale entries, so we'll need log-low and log-high\n\t * impossibly bad values later.\n\t */\n\telse if (leafhdr.stale) {\n\t\tlfloglow = leafhdr.count;\n\t\tlfloghigh = -1;\n\t}\n\t/*\n\t * If there was no data block space found, we need to allocate\n\t * a new one.\n\t */\n\tif (use_block == -1) {\n\t\t/*\n\t\t * Add the new data block.\n\t\t */\n\t\tif ((error = xfs_dir2_grow_inode(args, XFS_DIR2_DATA_SPACE,\n\t\t\t\t&use_block))) {\n\t\t\txfs_trans_brelse(tp, lbp);\n\t\t\treturn error;\n\t\t}\n\t\t/*\n\t\t * Initialize the block.\n\t\t */\n\t\tif ((error = xfs_dir3_data_init(args, use_block, &dbp))) {\n\t\t\txfs_trans_brelse(tp, lbp);\n\t\t\treturn error;\n\t\t}\n\t\t/*\n\t\t * If we're adding a new data block on the end we need to\n\t\t * extend the bests table.  Copy it up one entry.\n\t\t */\n\t\tif (use_block >= be32_to_cpu(ltp->bestcount)) {\n\t\t\tbestsp--;\n\t\t\tmemmove(&bestsp[0], &bestsp[1],\n\t\t\t\tbe32_to_cpu(ltp->bestcount) * sizeof(bestsp[0]));\n\t\t\tbe32_add_cpu(&ltp->bestcount, 1);\n\t\t\txfs_dir3_leaf_log_tail(args, lbp);\n\t\t\txfs_dir3_leaf_log_bests(args, lbp, 0,\n\t\t\t\t\t\tbe32_to_cpu(ltp->bestcount) - 1);\n\t\t}\n\t\t/*\n\t\t * If we're filling in a previously empty block just log it.\n\t\t */\n\t\telse\n\t\t\txfs_dir3_leaf_log_bests(args, lbp, use_block, use_block);\n\t\thdr = dbp->b_addr;\n\t\tbf = dp->d_ops->data_bestfree_p(hdr);\n\t\tbestsp[use_block] = bf[0].length;\n\t\tgrown = 1;\n\t} else {\n\t\t/*\n\t\t * Already had space in some data block.\n\t\t * Just read that one in.\n\t\t */\n\t\terror = xfs_dir3_data_read(tp, dp,\n\t\t\t\t   xfs_dir2_db_to_da(args->geo, use_block),\n\t\t\t\t   -1, &dbp);\n\t\tif (error) {\n\t\t\txfs_trans_brelse(tp, lbp);\n\t\t\treturn error;\n\t\t}\n\t\thdr = dbp->b_addr;\n\t\tbf = dp->d_ops->data_bestfree_p(hdr);\n\t\tgrown = 0;\n\t}\n\t/*\n\t * Point to the biggest freespace in our data block.\n\t */\n\tdup = (xfs_dir2_data_unused_t *)\n\t      ((char *)hdr + be16_to_cpu(bf[0].offset));\n\tASSERT(be16_to_cpu(dup->length) >= length);\n\tneedscan = needlog = 0;\n\t/*\n\t * Mark the initial part of our freespace in use for the new entry.\n\t */\n\txfs_dir2_data_use_free(args, dbp, dup,\n\t\t(xfs_dir2_data_aoff_t)((char *)dup - (char *)hdr), length,\n\t\t&needlog, &needscan);\n\t/*\n\t * Initialize our new entry (at last).\n\t */\n\tdep = (xfs_dir2_data_entry_t *)dup;\n\tdep->inumber = cpu_to_be64(args->inumber);\n\tdep->namelen = args->namelen;\n\tmemcpy(dep->name, args->name, dep->namelen);\n\tdp->d_ops->data_put_ftype(dep, args->filetype);\n\ttagp = dp->d_ops->data_entry_tag_p(dep);\n\t*tagp = cpu_to_be16((char *)dep - (char *)hdr);\n\t/*\n\t * Need to scan fix up the bestfree table.\n\t */\n\tif (needscan)\n\t\txfs_dir2_data_freescan(dp, hdr, &needlog);\n\t/*\n\t * Need to log the data block's header.\n\t */\n\tif (needlog)\n\t\txfs_dir2_data_log_header(args, dbp);\n\txfs_dir2_data_log_entry(args, dbp, dep);\n\t/*\n\t * If the bests table needs to be changed, do it.\n\t * Log the change unless we've already done that.\n\t */\n\tif (be16_to_cpu(bestsp[use_block]) != be16_to_cpu(bf[0].length)) {\n\t\tbestsp[use_block] = bf[0].length;\n\t\tif (!grown)\n\t\t\txfs_dir3_leaf_log_bests(args, lbp, use_block, use_block);\n\t}\n\n\tlep = xfs_dir3_leaf_find_entry(&leafhdr, ents, index, compact, lowstale,\n\t\t\t\t       highstale, &lfloglow, &lfloghigh);\n\n\t/*\n\t * Fill in the new leaf entry.\n\t */\n\tlep->hashval = cpu_to_be32(args->hashval);\n\tlep->address = cpu_to_be32(\n\t\t\t\txfs_dir2_db_off_to_dataptr(args->geo, use_block,\n\t\t\t\tbe16_to_cpu(*tagp)));\n\t/*\n\t * Log the leaf fields and give up the buffers.\n\t */\n\tdp->d_ops->leaf_hdr_to_disk(leaf, &leafhdr);\n\txfs_dir3_leaf_log_header(args, lbp);\n\txfs_dir3_leaf_log_ents(args, lbp, lfloglow, lfloghigh);\n\txfs_dir3_leaf_check(dp, lbp);\n\txfs_dir3_data_check(dp, dbp);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_leaf_addname(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\t__be16\t\t\t*bestsp;\t/* freespace table in leaf */\n\tint\t\t\tcompact;\t/* need to compact leaves */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\tstruct xfs_buf\t\t*dbp;\t\t/* data block buffer */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data block entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* data unused entry */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tgrown;\t\t/* allocated new data block */\n\tint\t\t\thighstale;\t/* index of next stale leaf */\n\tint\t\t\ti;\t\t/* temporary, index */\n\tint\t\t\tindex;\t\t/* leaf table position */\n\tstruct xfs_buf\t\t*lbp;\t\t/* leaf's buffer */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\tint\t\t\tlength;\t\t/* length of new entry */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry table pointer */\n\tint\t\t\tlfloglow;\t/* low leaf logging index */\n\tint\t\t\tlfloghigh;\t/* high leaf logging index */\n\tint\t\t\tlowstale;\t/* index of prev stale leaf */\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf tail pointer */\n\tint\t\t\tneedbytes;\t/* leaf block bytes needed */\n\tint\t\t\tneedlog;\t/* need to log data header */\n\tint\t\t\tneedscan;\t/* need to rescan data free */\n\t__be16\t\t\t*tagp;\t\t/* end of data entry */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\txfs_dir2_db_t\t\tuse_block;\t/* data block number */\n\tstruct xfs_dir2_data_free *bf;\t\t/* bestfree table */\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\ttrace_xfs_dir2_leaf_addname(args);\n\n\tdp = args->dp;\n\ttp = args->trans;\n\n\terror = xfs_dir3_leaf_read(tp, dp, args->geo->leafblk, -1, &lbp);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Look up the entry by hash value and name.\n\t * We know it's not there, our caller has already done a lookup.\n\t * So the index is of the entry to insert in front of.\n\t * But if there are dup hash values the index is of the first of those.\n\t */\n\tindex = xfs_dir2_leaf_search_hash(args, lbp);\n\tleaf = lbp->b_addr;\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\tbestsp = xfs_dir2_leaf_bests_p(ltp);\n\tlength = dp->d_ops->data_entsize(args->namelen);\n\n\t/*\n\t * See if there are any entries with the same hash value\n\t * and space in their block for the new entry.\n\t * This is good because it puts multiple same-hash value entries\n\t * in a data block, improving the lookup of those entries.\n\t */\n\tfor (use_block = -1, lep = &ents[index];\n\t     index < leafhdr.count && be32_to_cpu(lep->hashval) == args->hashval;\n\t     index++, lep++) {\n\t\tif (be32_to_cpu(lep->address) == XFS_DIR2_NULL_DATAPTR)\n\t\t\tcontinue;\n\t\ti = xfs_dir2_dataptr_to_db(args->geo, be32_to_cpu(lep->address));\n\t\tASSERT(i < be32_to_cpu(ltp->bestcount));\n\t\tASSERT(bestsp[i] != cpu_to_be16(NULLDATAOFF));\n\t\tif (be16_to_cpu(bestsp[i]) >= length) {\n\t\t\tuse_block = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * Didn't find a block yet, linear search all the data blocks.\n\t */\n\tif (use_block == -1) {\n\t\tfor (i = 0; i < be32_to_cpu(ltp->bestcount); i++) {\n\t\t\t/*\n\t\t\t * Remember a block we see that's missing.\n\t\t\t */\n\t\t\tif (bestsp[i] == cpu_to_be16(NULLDATAOFF) &&\n\t\t\t    use_block == -1)\n\t\t\t\tuse_block = i;\n\t\t\telse if (be16_to_cpu(bestsp[i]) >= length) {\n\t\t\t\tuse_block = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * How many bytes do we need in the leaf block?\n\t */\n\tneedbytes = 0;\n\tif (!leafhdr.stale)\n\t\tneedbytes += sizeof(xfs_dir2_leaf_entry_t);\n\tif (use_block == -1)\n\t\tneedbytes += sizeof(xfs_dir2_data_off_t);\n\n\t/*\n\t * Now kill use_block if it refers to a missing block, so we\n\t * can use it as an indication of allocation needed.\n\t */\n\tif (use_block != -1 && bestsp[use_block] == cpu_to_be16(NULLDATAOFF))\n\t\tuse_block = -1;\n\t/*\n\t * If we don't have enough free bytes but we can make enough\n\t * by compacting out stale entries, we'll do that.\n\t */\n\tif ((char *)bestsp - (char *)&ents[leafhdr.count] < needbytes &&\n\t    leafhdr.stale > 1)\n\t\tcompact = 1;\n\n\t/*\n\t * Otherwise if we don't have enough free bytes we need to\n\t * convert to node form.\n\t */\n\telse if ((char *)bestsp - (char *)&ents[leafhdr.count] < needbytes) {\n\t\t/*\n\t\t * Just checking or no space reservation, give up.\n\t\t */\n\t\tif ((args->op_flags & XFS_DA_OP_JUSTCHECK) ||\n\t\t\t\t\t\t\targs->total == 0) {\n\t\t\txfs_trans_brelse(tp, lbp);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\t/*\n\t\t * Convert to node form.\n\t\t */\n\t\terror = xfs_dir2_leaf_to_node(args, lbp);\n\t\tif (error)\n\t\t\treturn error;\n\t\t/*\n\t\t * Then add the new entry.\n\t\t */\n\t\treturn xfs_dir2_node_addname(args);\n\t}\n\t/*\n\t * Otherwise it will fit without compaction.\n\t */\n\telse\n\t\tcompact = 0;\n\t/*\n\t * If just checking, then it will fit unless we needed to allocate\n\t * a new data block.\n\t */\n\tif (args->op_flags & XFS_DA_OP_JUSTCHECK) {\n\t\txfs_trans_brelse(tp, lbp);\n\t\treturn use_block == -1 ? -ENOSPC : 0;\n\t}\n\t/*\n\t * If no allocations are allowed, return now before we've\n\t * changed anything.\n\t */\n\tif (args->total == 0 && use_block == -1) {\n\t\txfs_trans_brelse(tp, lbp);\n\t\treturn -ENOSPC;\n\t}\n\t/*\n\t * Need to compact the leaf entries, removing stale ones.\n\t * Leave one stale entry behind - the one closest to our\n\t * insertion index - and we'll shift that one to our insertion\n\t * point later.\n\t */\n\tif (compact) {\n\t\txfs_dir3_leaf_compact_x1(&leafhdr, ents, &index, &lowstale,\n\t\t\t&highstale, &lfloglow, &lfloghigh);\n\t}\n\t/*\n\t * There are stale entries, so we'll need log-low and log-high\n\t * impossibly bad values later.\n\t */\n\telse if (leafhdr.stale) {\n\t\tlfloglow = leafhdr.count;\n\t\tlfloghigh = -1;\n\t}\n\t/*\n\t * If there was no data block space found, we need to allocate\n\t * a new one.\n\t */\n\tif (use_block == -1) {\n\t\t/*\n\t\t * Add the new data block.\n\t\t */\n\t\tif ((error = xfs_dir2_grow_inode(args, XFS_DIR2_DATA_SPACE,\n\t\t\t\t&use_block))) {\n\t\t\txfs_trans_brelse(tp, lbp);\n\t\t\treturn error;\n\t\t}\n\t\t/*\n\t\t * Initialize the block.\n\t\t */\n\t\tif ((error = xfs_dir3_data_init(args, use_block, &dbp))) {\n\t\t\txfs_trans_brelse(tp, lbp);\n\t\t\treturn error;\n\t\t}\n\t\t/*\n\t\t * If we're adding a new data block on the end we need to\n\t\t * extend the bests table.  Copy it up one entry.\n\t\t */\n\t\tif (use_block >= be32_to_cpu(ltp->bestcount)) {\n\t\t\tbestsp--;\n\t\t\tmemmove(&bestsp[0], &bestsp[1],\n\t\t\t\tbe32_to_cpu(ltp->bestcount) * sizeof(bestsp[0]));\n\t\t\tbe32_add_cpu(&ltp->bestcount, 1);\n\t\t\txfs_dir3_leaf_log_tail(args, lbp);\n\t\t\txfs_dir3_leaf_log_bests(args, lbp, 0,\n\t\t\t\t\t\tbe32_to_cpu(ltp->bestcount) - 1);\n\t\t}\n\t\t/*\n\t\t * If we're filling in a previously empty block just log it.\n\t\t */\n\t\telse\n\t\t\txfs_dir3_leaf_log_bests(args, lbp, use_block, use_block);\n\t\thdr = dbp->b_addr;\n\t\tbf = dp->d_ops->data_bestfree_p(hdr);\n\t\tbestsp[use_block] = bf[0].length;\n\t\tgrown = 1;\n\t} else {\n\t\t/*\n\t\t * Already had space in some data block.\n\t\t * Just read that one in.\n\t\t */\n\t\terror = xfs_dir3_data_read(tp, dp,\n\t\t\t\t   xfs_dir2_db_to_da(args->geo, use_block),\n\t\t\t\t   -1, &dbp);\n\t\tif (error) {\n\t\t\txfs_trans_brelse(tp, lbp);\n\t\t\treturn error;\n\t\t}\n\t\thdr = dbp->b_addr;\n\t\tbf = dp->d_ops->data_bestfree_p(hdr);\n\t\tgrown = 0;\n\t}\n\t/*\n\t * Point to the biggest freespace in our data block.\n\t */\n\tdup = (xfs_dir2_data_unused_t *)\n\t      ((char *)hdr + be16_to_cpu(bf[0].offset));\n\tASSERT(be16_to_cpu(dup->length) >= length);\n\tneedscan = needlog = 0;\n\t/*\n\t * Mark the initial part of our freespace in use for the new entry.\n\t */\n\txfs_dir2_data_use_free(args, dbp, dup,\n\t\t(xfs_dir2_data_aoff_t)((char *)dup - (char *)hdr), length,\n\t\t&needlog, &needscan);\n\t/*\n\t * Initialize our new entry (at last).\n\t */\n\tdep = (xfs_dir2_data_entry_t *)dup;\n\tdep->inumber = cpu_to_be64(args->inumber);\n\tdep->namelen = args->namelen;\n\tmemcpy(dep->name, args->name, dep->namelen);\n\tdp->d_ops->data_put_ftype(dep, args->filetype);\n\ttagp = dp->d_ops->data_entry_tag_p(dep);\n\t*tagp = cpu_to_be16((char *)dep - (char *)hdr);\n\t/*\n\t * Need to scan fix up the bestfree table.\n\t */\n\tif (needscan)\n\t\txfs_dir2_data_freescan(dp, hdr, &needlog);\n\t/*\n\t * Need to log the data block's header.\n\t */\n\tif (needlog)\n\t\txfs_dir2_data_log_header(args, dbp);\n\txfs_dir2_data_log_entry(args, dbp, dep);\n\t/*\n\t * If the bests table needs to be changed, do it.\n\t * Log the change unless we've already done that.\n\t */\n\tif (be16_to_cpu(bestsp[use_block]) != be16_to_cpu(bf[0].length)) {\n\t\tbestsp[use_block] = bf[0].length;\n\t\tif (!grown)\n\t\t\txfs_dir3_leaf_log_bests(args, lbp, use_block, use_block);\n\t}\n\n\tlep = xfs_dir3_leaf_find_entry(&leafhdr, ents, index, compact, lowstale,\n\t\t\t\t       highstale, &lfloglow, &lfloghigh);\n\n\t/*\n\t * Fill in the new leaf entry.\n\t */\n\tlep->hashval = cpu_to_be32(args->hashval);\n\tlep->address = cpu_to_be32(\n\t\t\t\txfs_dir2_db_off_to_dataptr(args->geo, use_block,\n\t\t\t\tbe16_to_cpu(*tagp)));\n\t/*\n\t * Log the leaf fields and give up the buffers.\n\t */\n\tdp->d_ops->leaf_hdr_to_disk(leaf, &leafhdr);\n\txfs_dir3_leaf_log_header(args, lbp);\n\txfs_dir3_leaf_log_ents(args, lbp, lfloglow, lfloghigh);\n\txfs_dir3_leaf_check(dp, lbp);\n\txfs_dir3_data_check(dp, dbp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_to_leaf",
          "args": [
            "args",
            "bp"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_to_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "369-475",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_block_to_leaf(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tstruct xfs_buf\t\t*dbp)\t\t/* input block's buffer */\n{\n\t__be16\t\t\t*bestsp;\t/* leaf's bestsp entries */\n\txfs_dablk_t\t\tblkno;\t\t/* leaf block's bno */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* block's leaf entries */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block's tail */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return code */\n\tstruct xfs_buf\t\t*lbp;\t\t/* leaf block's buffer */\n\txfs_dir2_db_t\t\tldb;\t\t/* leaf block's bno */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf's tail */\n\tint\t\t\tneedlog;\t/* need to log block header */\n\tint\t\t\tneedscan;\t/* need to rescan bestfree */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tstruct xfs_dir2_data_free *bf;\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\ttrace_xfs_dir2_block_to_leaf(args);\n\n\tdp = args->dp;\n\ttp = args->trans;\n\t/*\n\t * Add the leaf block to the inode.\n\t * This interface will only put blocks in the leaf/node range.\n\t * Since that's empty now, we'll get the root (block 0 in range).\n\t */\n\tif ((error = xfs_da_grow_inode(args, &blkno))) {\n\t\treturn error;\n\t}\n\tldb = xfs_dir2_da_to_db(args->geo, blkno);\n\tASSERT(ldb == xfs_dir2_byte_to_db(args->geo, XFS_DIR2_LEAF_OFFSET));\n\t/*\n\t * Initialize the leaf block, get a buffer for it.\n\t */\n\terror = xfs_dir3_leaf_get_buf(args, ldb, &lbp, XFS_DIR2_LEAF1_MAGIC);\n\tif (error)\n\t\treturn error;\n\n\tleaf = lbp->b_addr;\n\thdr = dbp->b_addr;\n\txfs_dir3_data_check(dp, dbp);\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\tbf = dp->d_ops->data_bestfree_p(hdr);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\n\t/*\n\t * Set the counts in the leaf header.\n\t */\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\tleafhdr.count = be32_to_cpu(btp->count);\n\tleafhdr.stale = be32_to_cpu(btp->stale);\n\tdp->d_ops->leaf_hdr_to_disk(leaf, &leafhdr);\n\txfs_dir3_leaf_log_header(args, lbp);\n\n\t/*\n\t * Could compact these but I think we always do the conversion\n\t * after squeezing out stale entries.\n\t */\n\tmemcpy(ents, blp, be32_to_cpu(btp->count) * sizeof(xfs_dir2_leaf_entry_t));\n\txfs_dir3_leaf_log_ents(args, lbp, 0, leafhdr.count - 1);\n\tneedscan = 0;\n\tneedlog = 1;\n\t/*\n\t * Make the space formerly occupied by the leaf entries and block\n\t * tail be free.\n\t */\n\txfs_dir2_data_make_free(args, dbp,\n\t\t(xfs_dir2_data_aoff_t)((char *)blp - (char *)hdr),\n\t\t(xfs_dir2_data_aoff_t)((char *)hdr + args->geo->blksize -\n\t\t\t\t       (char *)blp),\n\t\t&needlog, &needscan);\n\t/*\n\t * Fix up the block header, make it a data block.\n\t */\n\tdbp->b_ops = &xfs_dir3_data_buf_ops;\n\txfs_trans_buf_set_type(tp, dbp, XFS_BLFT_DIR_DATA_BUF);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC))\n\t\thdr->magic = cpu_to_be32(XFS_DIR2_DATA_MAGIC);\n\telse\n\t\thdr->magic = cpu_to_be32(XFS_DIR3_DATA_MAGIC);\n\n\tif (needscan)\n\t\txfs_dir2_data_freescan(dp, hdr, &needlog);\n\t/*\n\t * Set up leaf tail and bests table.\n\t */\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\tltp->bestcount = cpu_to_be32(1);\n\tbestsp = xfs_dir2_leaf_bests_p(ltp);\n\tbestsp[0] =  bf[0].length;\n\t/*\n\t * Log the data header and leaf bests table.\n\t */\n\tif (needlog)\n\t\txfs_dir2_data_log_header(args, dbp);\n\txfs_dir3_leaf_check(dp, lbp);\n\txfs_dir3_data_check(dp, dbp);\n\txfs_dir3_leaf_log_bests(args, lbp, 0, 0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_block_to_leaf(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tstruct xfs_buf\t\t*dbp)\t\t/* input block's buffer */\n{\n\t__be16\t\t\t*bestsp;\t/* leaf's bestsp entries */\n\txfs_dablk_t\t\tblkno;\t\t/* leaf block's bno */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* block's leaf entries */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block's tail */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return code */\n\tstruct xfs_buf\t\t*lbp;\t\t/* leaf block's buffer */\n\txfs_dir2_db_t\t\tldb;\t\t/* leaf block's bno */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf's tail */\n\tint\t\t\tneedlog;\t/* need to log block header */\n\tint\t\t\tneedscan;\t/* need to rescan bestfree */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tstruct xfs_dir2_data_free *bf;\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\ttrace_xfs_dir2_block_to_leaf(args);\n\n\tdp = args->dp;\n\ttp = args->trans;\n\t/*\n\t * Add the leaf block to the inode.\n\t * This interface will only put blocks in the leaf/node range.\n\t * Since that's empty now, we'll get the root (block 0 in range).\n\t */\n\tif ((error = xfs_da_grow_inode(args, &blkno))) {\n\t\treturn error;\n\t}\n\tldb = xfs_dir2_da_to_db(args->geo, blkno);\n\tASSERT(ldb == xfs_dir2_byte_to_db(args->geo, XFS_DIR2_LEAF_OFFSET));\n\t/*\n\t * Initialize the leaf block, get a buffer for it.\n\t */\n\terror = xfs_dir3_leaf_get_buf(args, ldb, &lbp, XFS_DIR2_LEAF1_MAGIC);\n\tif (error)\n\t\treturn error;\n\n\tleaf = lbp->b_addr;\n\thdr = dbp->b_addr;\n\txfs_dir3_data_check(dp, dbp);\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\tbf = dp->d_ops->data_bestfree_p(hdr);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\n\t/*\n\t * Set the counts in the leaf header.\n\t */\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\tleafhdr.count = be32_to_cpu(btp->count);\n\tleafhdr.stale = be32_to_cpu(btp->stale);\n\tdp->d_ops->leaf_hdr_to_disk(leaf, &leafhdr);\n\txfs_dir3_leaf_log_header(args, lbp);\n\n\t/*\n\t * Could compact these but I think we always do the conversion\n\t * after squeezing out stale entries.\n\t */\n\tmemcpy(ents, blp, be32_to_cpu(btp->count) * sizeof(xfs_dir2_leaf_entry_t));\n\txfs_dir3_leaf_log_ents(args, lbp, 0, leafhdr.count - 1);\n\tneedscan = 0;\n\tneedlog = 1;\n\t/*\n\t * Make the space formerly occupied by the leaf entries and block\n\t * tail be free.\n\t */\n\txfs_dir2_data_make_free(args, dbp,\n\t\t(xfs_dir2_data_aoff_t)((char *)blp - (char *)hdr),\n\t\t(xfs_dir2_data_aoff_t)((char *)hdr + args->geo->blksize -\n\t\t\t\t       (char *)blp),\n\t\t&needlog, &needscan);\n\t/*\n\t * Fix up the block header, make it a data block.\n\t */\n\tdbp->b_ops = &xfs_dir3_data_buf_ops;\n\txfs_trans_buf_set_type(tp, dbp, XFS_BLFT_DIR_DATA_BUF);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC))\n\t\thdr->magic = cpu_to_be32(XFS_DIR2_DATA_MAGIC);\n\telse\n\t\thdr->magic = cpu_to_be32(XFS_DIR3_DATA_MAGIC);\n\n\tif (needscan)\n\t\txfs_dir2_data_freescan(dp, hdr, &needlog);\n\t/*\n\t * Set up leaf tail and bests table.\n\t */\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\tltp->bestcount = cpu_to_be32(1);\n\tbestsp = xfs_dir2_leaf_bests_p(ltp);\n\tbestsp[0] =  bf[0].length;\n\t/*\n\t * Log the data header and leaf bests table.\n\t */\n\tif (needlog)\n\t\txfs_dir2_data_log_header(args, dbp);\n\txfs_dir3_leaf_check(dp, lbp);\n\txfs_dir3_data_check(dp, dbp);\n\txfs_dir3_leaf_log_bests(args, lbp, 0, 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "tp",
            "bp"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_need_space",
          "args": [
            "dp",
            "hdr",
            "btp",
            "blp",
            "&tagp",
            "&dup",
            "&enddup",
            "&compact",
            "len"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_need_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
          "lines": "167-272",
          "snippet": "static void\nxfs_dir2_block_need_space(\n\tstruct xfs_inode\t\t*dp,\n\tstruct xfs_dir2_data_hdr\t*hdr,\n\tstruct xfs_dir2_block_tail\t*btp,\n\tstruct xfs_dir2_leaf_entry\t*blp,\n\t__be16\t\t\t\t**tagpp,\n\tstruct xfs_dir2_data_unused\t**dupp,\n\tstruct xfs_dir2_data_unused\t**enddupp,\n\tint\t\t\t\t*compact,\n\tint\t\t\t\tlen)\n{\n\tstruct xfs_dir2_data_free\t*bf;\n\t__be16\t\t\t\t*tagp = NULL;\n\tstruct xfs_dir2_data_unused\t*dup = NULL;\n\tstruct xfs_dir2_data_unused\t*enddup = NULL;\n\n\t*compact = 0;\n\tbf = dp->d_ops->data_bestfree_p(hdr);\n\n\t/*\n\t * If there are stale entries we'll use one for the leaf.\n\t */\n\tif (btp->stale) {\n\t\tif (be16_to_cpu(bf[0].length) >= len) {\n\t\t\t/*\n\t\t\t * The biggest entry enough to avoid compaction.\n\t\t\t */\n\t\t\tdup = (xfs_dir2_data_unused_t *)\n\t\t\t      ((char *)hdr + be16_to_cpu(bf[0].offset));\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Will need to compact to make this work.\n\t\t * Tag just before the first leaf entry.\n\t\t */\n\t\t*compact = 1;\n\t\ttagp = (__be16 *)blp - 1;\n\n\t\t/* Data object just before the first leaf entry.  */\n\t\tdup = (xfs_dir2_data_unused_t *)((char *)hdr + be16_to_cpu(*tagp));\n\n\t\t/*\n\t\t * If it's not free then the data will go where the\n\t\t * leaf data starts now, if it works at all.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tif (be16_to_cpu(dup->length) + (be32_to_cpu(btp->stale) - 1) *\n\t\t\t    (uint)sizeof(*blp) < len)\n\t\t\t\tdup = NULL;\n\t\t} else if ((be32_to_cpu(btp->stale) - 1) * (uint)sizeof(*blp) < len)\n\t\t\tdup = NULL;\n\t\telse\n\t\t\tdup = (xfs_dir2_data_unused_t *)blp;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * no stale entries, so just use free space.\n\t * Tag just before the first leaf entry.\n\t */\n\ttagp = (__be16 *)blp - 1;\n\n\t/* Data object just before the first leaf entry.  */\n\tenddup = (xfs_dir2_data_unused_t *)((char *)hdr + be16_to_cpu(*tagp));\n\n\t/*\n\t * If it's not free then can't do this add without cleaning up:\n\t * the space before the first leaf entry needs to be free so it\n\t * can be expanded to hold the pointer to the new entry.\n\t */\n\tif (be16_to_cpu(enddup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t/*\n\t\t * Check out the biggest freespace and see if it's the same one.\n\t\t */\n\t\tdup = (xfs_dir2_data_unused_t *)\n\t\t      ((char *)hdr + be16_to_cpu(bf[0].offset));\n\t\tif (dup != enddup) {\n\t\t\t/*\n\t\t\t * Not the same free entry, just check its length.\n\t\t\t */\n\t\t\tif (be16_to_cpu(dup->length) < len)\n\t\t\t\tdup = NULL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * It is the biggest freespace, can it hold the leaf too?\n\t\t */\n\t\tif (be16_to_cpu(dup->length) < len + (uint)sizeof(*blp)) {\n\t\t\t/*\n\t\t\t * Yes, use the second-largest entry instead if it works.\n\t\t\t */\n\t\t\tif (be16_to_cpu(bf[1].length) >= len)\n\t\t\t\tdup = (xfs_dir2_data_unused_t *)\n\t\t\t\t      ((char *)hdr + be16_to_cpu(bf[1].offset));\n\t\t\telse\n\t\t\t\tdup = NULL;\n\t\t}\n\t}\nout:\n\t*tagpp = tagp;\n\t*dupp = dup;\n\t*enddupp = enddup;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_dir2_block_need_space(\n\tstruct xfs_inode\t\t*dp,\n\tstruct xfs_dir2_data_hdr\t*hdr,\n\tstruct xfs_dir2_block_tail\t*btp,\n\tstruct xfs_dir2_leaf_entry\t*blp,\n\t__be16\t\t\t\t**tagpp,\n\tstruct xfs_dir2_data_unused\t**dupp,\n\tstruct xfs_dir2_data_unused\t**enddupp,\n\tint\t\t\t\t*compact,\n\tint\t\t\t\tlen)\n{\n\tstruct xfs_dir2_data_free\t*bf;\n\t__be16\t\t\t\t*tagp = NULL;\n\tstruct xfs_dir2_data_unused\t*dup = NULL;\n\tstruct xfs_dir2_data_unused\t*enddup = NULL;\n\n\t*compact = 0;\n\tbf = dp->d_ops->data_bestfree_p(hdr);\n\n\t/*\n\t * If there are stale entries we'll use one for the leaf.\n\t */\n\tif (btp->stale) {\n\t\tif (be16_to_cpu(bf[0].length) >= len) {\n\t\t\t/*\n\t\t\t * The biggest entry enough to avoid compaction.\n\t\t\t */\n\t\t\tdup = (xfs_dir2_data_unused_t *)\n\t\t\t      ((char *)hdr + be16_to_cpu(bf[0].offset));\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Will need to compact to make this work.\n\t\t * Tag just before the first leaf entry.\n\t\t */\n\t\t*compact = 1;\n\t\ttagp = (__be16 *)blp - 1;\n\n\t\t/* Data object just before the first leaf entry.  */\n\t\tdup = (xfs_dir2_data_unused_t *)((char *)hdr + be16_to_cpu(*tagp));\n\n\t\t/*\n\t\t * If it's not free then the data will go where the\n\t\t * leaf data starts now, if it works at all.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tif (be16_to_cpu(dup->length) + (be32_to_cpu(btp->stale) - 1) *\n\t\t\t    (uint)sizeof(*blp) < len)\n\t\t\t\tdup = NULL;\n\t\t} else if ((be32_to_cpu(btp->stale) - 1) * (uint)sizeof(*blp) < len)\n\t\t\tdup = NULL;\n\t\telse\n\t\t\tdup = (xfs_dir2_data_unused_t *)blp;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * no stale entries, so just use free space.\n\t * Tag just before the first leaf entry.\n\t */\n\ttagp = (__be16 *)blp - 1;\n\n\t/* Data object just before the first leaf entry.  */\n\tenddup = (xfs_dir2_data_unused_t *)((char *)hdr + be16_to_cpu(*tagp));\n\n\t/*\n\t * If it's not free then can't do this add without cleaning up:\n\t * the space before the first leaf entry needs to be free so it\n\t * can be expanded to hold the pointer to the new entry.\n\t */\n\tif (be16_to_cpu(enddup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t/*\n\t\t * Check out the biggest freespace and see if it's the same one.\n\t\t */\n\t\tdup = (xfs_dir2_data_unused_t *)\n\t\t      ((char *)hdr + be16_to_cpu(bf[0].offset));\n\t\tif (dup != enddup) {\n\t\t\t/*\n\t\t\t * Not the same free entry, just check its length.\n\t\t\t */\n\t\t\tif (be16_to_cpu(dup->length) < len)\n\t\t\t\tdup = NULL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * It is the biggest freespace, can it hold the leaf too?\n\t\t */\n\t\tif (be16_to_cpu(dup->length) < len + (uint)sizeof(*blp)) {\n\t\t\t/*\n\t\t\t * Yes, use the second-largest entry instead if it works.\n\t\t\t */\n\t\t\tif (be16_to_cpu(bf[1].length) >= len)\n\t\t\t\tdup = (xfs_dir2_data_unused_t *)\n\t\t\t\t      ((char *)hdr + be16_to_cpu(bf[1].offset));\n\t\t\telse\n\t\t\t\tdup = NULL;\n\t\t}\n\t}\nout:\n\t*tagpp = tagp;\n\t*dupp = dup;\n\t*enddupp = enddup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_tail_p",
          "args": [
            "args->geo",
            "hdr"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_tail_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "305-310",
          "snippet": "static inline struct xfs_dir2_block_tail *\nxfs_dir2_block_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_data_hdr *hdr)\n{\n\treturn ((struct xfs_dir2_block_tail *)\n\t\t((char *)hdr + geo->blksize)) - 1;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_block_tail *\nxfs_dir2_block_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_data_hdr *hdr)\n{\n\treturn ((struct xfs_dir2_block_tail *)\n\t\t((char *)hdr + geo->blksize)) - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_entsize",
          "args": [
            "args->namelen"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_block_read",
          "args": [
            "tp",
            "dp",
            "&bp"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_block_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
          "lines": "127-141",
          "snippet": "int\nxfs_dir3_block_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, mp->m_dir_geo->datablk, -1, bpp,\n\t\t\t\tXFS_DATA_FORK, &xfs_dir3_block_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_DIR_BLOCK_BUF);\n\treturn err;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_dir3_block_buf_ops = {\n\t.verify_read = xfs_dir3_block_read_verify,\n\t.verify_write = xfs_dir3_block_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_dir3_block_buf_ops = {\n\t.verify_read = xfs_dir3_block_read_verify,\n\t.verify_write = xfs_dir3_block_write_verify,\n};\n\nint\nxfs_dir3_block_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, mp->m_dir_geo->datablk, -1, bpp,\n\t\t\t\tXFS_DATA_FORK, &xfs_dir3_block_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_DIR_BLOCK_BUF);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_dir2_block_addname",
          "args": [
            "args"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_block_log_leaf(xfs_trans_t *tp, struct xfs_buf *bp,\n\t\t\t\t    int first, int last);\nstatic void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_block_addname(\n\txfs_da_args_t\t\t*args)\t\t/* directory op arguments */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* block leaf entries */\n\tstruct xfs_buf\t\t*bp;\t\t/* buffer for block */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\tint\t\t\tcompact;\t/* need to compact leaf ents */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* block data entry */\n\txfs_inode_t\t\t*dp;\t\t/* directory inode */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* block unused entry */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_dir2_data_unused_t\t*enddup=NULL;\t/* unused at end of data */\n\txfs_dahash_t\t\thash;\t\t/* hash value of found entry */\n\tint\t\t\thigh;\t\t/* high index for binary srch */\n\tint\t\t\thighstale;\t/* high stale index */\n\tint\t\t\tlfloghigh=0;\t/* last final leaf to log */\n\tint\t\t\tlfloglow=0;\t/* first final leaf to log */\n\tint\t\t\tlen;\t\t/* length of the new entry */\n\tint\t\t\tlow;\t\t/* low index for binary srch */\n\tint\t\t\tlowstale;\t/* low stale index */\n\tint\t\t\tmid=0;\t\t/* midpoint for binary srch */\n\tint\t\t\tneedlog;\t/* need to log header */\n\tint\t\t\tneedscan;\t/* need to rescan freespace */\n\t__be16\t\t\t*tagp;\t\t/* pointer to tag value */\n\txfs_trans_t\t\t*tp;\t\t/* transaction structure */\n\n\ttrace_xfs_dir2_block_addname(args);\n\n\tdp = args->dp;\n\ttp = args->trans;\n\n\t/* Read the (one and only) directory block into bp. */\n\terror = xfs_dir3_block_read(tp, dp, &bp);\n\tif (error)\n\t\treturn error;\n\n\tlen = dp->d_ops->data_entsize(args->namelen);\n\n\t/*\n\t * Set up pointers to parts of the block.\n\t */\n\thdr = bp->b_addr;\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tblp = xfs_dir2_block_leaf_p(btp);\n\n\t/*\n\t * Find out if we can reuse stale entries or whether we need extra\n\t * space for entry and new leaf.\n\t */\n\txfs_dir2_block_need_space(dp, hdr, btp, blp, &tagp, &dup,\n\t\t\t\t  &enddup, &compact, len);\n\n\t/*\n\t * Done everything we need for a space check now.\n\t */\n\tif (args->op_flags & XFS_DA_OP_JUSTCHECK) {\n\t\txfs_trans_brelse(tp, bp);\n\t\tif (!dup)\n\t\t\treturn -ENOSPC;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If we don't have space for the new entry & leaf ...\n\t */\n\tif (!dup) {\n\t\t/* Don't have a space reservation: return no-space.  */\n\t\tif (args->total == 0)\n\t\t\treturn -ENOSPC;\n\t\t/*\n\t\t * Convert to the next larger format.\n\t\t * Then add the new entry in that format.\n\t\t */\n\t\terror = xfs_dir2_block_to_leaf(args, bp);\n\t\tif (error)\n\t\t\treturn error;\n\t\treturn xfs_dir2_leaf_addname(args);\n\t}\n\n\tneedlog = needscan = 0;\n\n\t/*\n\t * If need to compact the leaf entries, do it now.\n\t */\n\tif (compact) {\n\t\txfs_dir2_block_compact(args, bp, hdr, btp, blp, &needlog,\n\t\t\t\t      &lfloghigh, &lfloglow);\n\t\t/* recalculate blp post-compaction */\n\t\tblp = xfs_dir2_block_leaf_p(btp);\n\t} else if (btp->stale) {\n\t\t/*\n\t\t * Set leaf logging boundaries to impossible state.\n\t\t * For the no-stale case they're set explicitly.\n\t\t */\n\t\tlfloglow = be32_to_cpu(btp->count);\n\t\tlfloghigh = -1;\n\t}\n\n\t/*\n\t * Find the slot that's first lower than our hash value, -1 if none.\n\t */\n\tfor (low = 0, high = be32_to_cpu(btp->count) - 1; low <= high; ) {\n\t\tmid = (low + high) >> 1;\n\t\tif ((hash = be32_to_cpu(blp[mid].hashval)) == args->hashval)\n\t\t\tbreak;\n\t\tif (hash < args->hashval)\n\t\t\tlow = mid + 1;\n\t\telse\n\t\t\thigh = mid - 1;\n\t}\n\twhile (mid >= 0 && be32_to_cpu(blp[mid].hashval) >= args->hashval) {\n\t\tmid--;\n\t}\n\t/*\n\t * No stale entries, will use enddup space to hold new leaf.\n\t */\n\tif (!btp->stale) {\n\t\t/*\n\t\t * Mark the space needed for the new leaf entry, now in use.\n\t\t */\n\t\txfs_dir2_data_use_free(args, bp, enddup,\n\t\t\t(xfs_dir2_data_aoff_t)\n\t\t\t((char *)enddup - (char *)hdr + be16_to_cpu(enddup->length) -\n\t\t\t sizeof(*blp)),\n\t\t\t(xfs_dir2_data_aoff_t)sizeof(*blp),\n\t\t\t&needlog, &needscan);\n\t\t/*\n\t\t * Update the tail (entry count).\n\t\t */\n\t\tbe32_add_cpu(&btp->count, 1);\n\t\t/*\n\t\t * If we now need to rebuild the bestfree map, do so.\n\t\t * This needs to happen before the next call to use_free.\n\t\t */\n\t\tif (needscan) {\n\t\t\txfs_dir2_data_freescan(dp, hdr, &needlog);\n\t\t\tneedscan = 0;\n\t\t}\n\t\t/*\n\t\t * Adjust pointer to the first leaf entry, we're about to move\n\t\t * the table up one to open up space for the new leaf entry.\n\t\t * Then adjust our index to match.\n\t\t */\n\t\tblp--;\n\t\tmid++;\n\t\tif (mid)\n\t\t\tmemmove(blp, &blp[1], mid * sizeof(*blp));\n\t\tlfloglow = 0;\n\t\tlfloghigh = mid;\n\t}\n\t/*\n\t * Use a stale leaf for our new entry.\n\t */\n\telse {\n\t\tfor (lowstale = mid;\n\t\t     lowstale >= 0 &&\n\t\t\tblp[lowstale].address !=\n\t\t\tcpu_to_be32(XFS_DIR2_NULL_DATAPTR);\n\t\t     lowstale--)\n\t\t\tcontinue;\n\t\tfor (highstale = mid + 1;\n\t\t     highstale < be32_to_cpu(btp->count) &&\n\t\t\tblp[highstale].address !=\n\t\t\tcpu_to_be32(XFS_DIR2_NULL_DATAPTR) &&\n\t\t\t(lowstale < 0 || mid - lowstale > highstale - mid);\n\t\t     highstale++)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Move entries toward the low-numbered stale entry.\n\t\t */\n\t\tif (lowstale >= 0 &&\n\t\t    (highstale == be32_to_cpu(btp->count) ||\n\t\t     mid - lowstale <= highstale - mid)) {\n\t\t\tif (mid - lowstale)\n\t\t\t\tmemmove(&blp[lowstale], &blp[lowstale + 1],\n\t\t\t\t\t(mid - lowstale) * sizeof(*blp));\n\t\t\tlfloglow = MIN(lowstale, lfloglow);\n\t\t\tlfloghigh = MAX(mid, lfloghigh);\n\t\t}\n\t\t/*\n\t\t * Move entries toward the high-numbered stale entry.\n\t\t */\n\t\telse {\n\t\t\tASSERT(highstale < be32_to_cpu(btp->count));\n\t\t\tmid++;\n\t\t\tif (highstale - mid)\n\t\t\t\tmemmove(&blp[mid + 1], &blp[mid],\n\t\t\t\t\t(highstale - mid) * sizeof(*blp));\n\t\t\tlfloglow = MIN(mid, lfloglow);\n\t\t\tlfloghigh = MAX(highstale, lfloghigh);\n\t\t}\n\t\tbe32_add_cpu(&btp->stale, -1);\n\t}\n\t/*\n\t * Point to the new data entry.\n\t */\n\tdep = (xfs_dir2_data_entry_t *)dup;\n\t/*\n\t * Fill in the leaf entry.\n\t */\n\tblp[mid].hashval = cpu_to_be32(args->hashval);\n\tblp[mid].address = cpu_to_be32(xfs_dir2_byte_to_dataptr(\n\t\t\t\t(char *)dep - (char *)hdr));\n\txfs_dir2_block_log_leaf(tp, bp, lfloglow, lfloghigh);\n\t/*\n\t * Mark space for the data entry used.\n\t */\n\txfs_dir2_data_use_free(args, bp, dup,\n\t\t(xfs_dir2_data_aoff_t)((char *)dup - (char *)hdr),\n\t\t(xfs_dir2_data_aoff_t)len, &needlog, &needscan);\n\t/*\n\t * Create the new data entry.\n\t */\n\tdep->inumber = cpu_to_be64(args->inumber);\n\tdep->namelen = args->namelen;\n\tmemcpy(dep->name, args->name, args->namelen);\n\tdp->d_ops->data_put_ftype(dep, args->filetype);\n\ttagp = dp->d_ops->data_entry_tag_p(dep);\n\t*tagp = cpu_to_be16((char *)dep - (char *)hdr);\n\t/*\n\t * Clean up the bestfree array and log the header, tail, and entry.\n\t */\n\tif (needscan)\n\t\txfs_dir2_data_freescan(dp, hdr, &needlog);\n\tif (needlog)\n\t\txfs_dir2_data_log_header(args, bp);\n\txfs_dir2_block_log_tail(tp, bp);\n\txfs_dir2_data_log_entry(args, bp, dep);\n\txfs_dir3_data_check(dp, bp);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_dir2_block_compact",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
    "lines": "279-325",
    "snippet": "static void\nxfs_dir2_block_compact(\n\tstruct xfs_da_args\t\t*args,\n\tstruct xfs_buf\t\t\t*bp,\n\tstruct xfs_dir2_data_hdr\t*hdr,\n\tstruct xfs_dir2_block_tail\t*btp,\n\tstruct xfs_dir2_leaf_entry\t*blp,\n\tint\t\t\t\t*needlog,\n\tint\t\t\t\t*lfloghigh,\n\tint\t\t\t\t*lfloglow)\n{\n\tint\t\t\tfromidx;\t/* source leaf index */\n\tint\t\t\ttoidx;\t\t/* target leaf index */\n\tint\t\t\tneedscan = 0;\n\tint\t\t\thighstale;\t/* high stale index */\n\n\tfromidx = toidx = be32_to_cpu(btp->count) - 1;\n\thighstale = *lfloghigh = -1;\n\tfor (; fromidx >= 0; fromidx--) {\n\t\tif (blp[fromidx].address == cpu_to_be32(XFS_DIR2_NULL_DATAPTR)) {\n\t\t\tif (highstale == -1)\n\t\t\t\thighstale = toidx;\n\t\t\telse {\n\t\t\t\tif (*lfloghigh == -1)\n\t\t\t\t\t*lfloghigh = toidx;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (fromidx < toidx)\n\t\t\tblp[toidx] = blp[fromidx];\n\t\ttoidx--;\n\t}\n\t*lfloglow = toidx + 1 - (be32_to_cpu(btp->stale) - 1);\n\t*lfloghigh -= be32_to_cpu(btp->stale) - 1;\n\tbe32_add_cpu(&btp->count, -(be32_to_cpu(btp->stale) - 1));\n\txfs_dir2_data_make_free(args, bp,\n\t\t(xfs_dir2_data_aoff_t)((char *)blp - (char *)hdr),\n\t\t(xfs_dir2_data_aoff_t)((be32_to_cpu(btp->stale) - 1) * sizeof(*blp)),\n\t\tneedlog, &needscan);\n\tbtp->stale = cpu_to_be32(1);\n\t/*\n\t * If we now need to rebuild the bestfree map, do so.\n\t * This needs to happen before the next call to use_free.\n\t */\n\tif (needscan)\n\t\txfs_dir2_data_freescan(args->dp, hdr, needlog);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_dir2_data_freescan",
          "args": [
            "args->dp",
            "hdr",
            "needlog"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_freescan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "500-559",
          "snippet": "void\nxfs_dir2_data_freescan(\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_dir2_data_hdr *hdr,\n\tint\t\t\t*loghead)\n{\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* active data entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused data entry */\n\tstruct xfs_dir2_data_free *bf;\n\tchar\t\t\t*endp;\t\t/* end of block's data */\n\tchar\t\t\t*p;\t\t/* current entry pointer */\n\tstruct xfs_da_geometry\t*geo = dp->i_mount->m_dir_geo;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\t/*\n\t * Start by clearing the table.\n\t */\n\tbf = dp->d_ops->data_bestfree_p(hdr);\n\tmemset(bf, 0, sizeof(*bf) * XFS_DIR2_DATA_FD_COUNT);\n\t*loghead = 1;\n\t/*\n\t * Set up pointers.\n\t */\n\tp = (char *)dp->d_ops->data_entry_p(hdr);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tendp = (char *)xfs_dir2_block_leaf_p(btp);\n\t} else\n\t\tendp = (char *)hdr + geo->blksize;\n\t/*\n\t * Loop over the block's entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's a free entry, insert it.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tASSERT((char *)dup - (char *)hdr ==\n\t\t\t       be16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)));\n\t\t\txfs_dir2_data_freeinsert(hdr, bf, dup, loghead);\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t}\n\t\t/*\n\t\t * For active entries, check their tags and skip them.\n\t\t */\n\t\telse {\n\t\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\t\tASSERT((char *)dep - (char *)hdr ==\n\t\t\t       be16_to_cpu(*dp->d_ops->data_entry_tag_p(dep)));\n\t\t\tp += dp->d_ops->data_entsize(dep->namelen);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dir2_data_freescan(\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_dir2_data_hdr *hdr,\n\tint\t\t\t*loghead)\n{\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* active data entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused data entry */\n\tstruct xfs_dir2_data_free *bf;\n\tchar\t\t\t*endp;\t\t/* end of block's data */\n\tchar\t\t\t*p;\t\t/* current entry pointer */\n\tstruct xfs_da_geometry\t*geo = dp->i_mount->m_dir_geo;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\t/*\n\t * Start by clearing the table.\n\t */\n\tbf = dp->d_ops->data_bestfree_p(hdr);\n\tmemset(bf, 0, sizeof(*bf) * XFS_DIR2_DATA_FD_COUNT);\n\t*loghead = 1;\n\t/*\n\t * Set up pointers.\n\t */\n\tp = (char *)dp->d_ops->data_entry_p(hdr);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tendp = (char *)xfs_dir2_block_leaf_p(btp);\n\t} else\n\t\tendp = (char *)hdr + geo->blksize;\n\t/*\n\t * Loop over the block's entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's a free entry, insert it.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tASSERT((char *)dup - (char *)hdr ==\n\t\t\t       be16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)));\n\t\t\txfs_dir2_data_freeinsert(hdr, bf, dup, loghead);\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t}\n\t\t/*\n\t\t * For active entries, check their tags and skip them.\n\t\t */\n\t\telse {\n\t\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\t\tASSERT((char *)dep - (char *)hdr ==\n\t\t\t       be16_to_cpu(*dp->d_ops->data_entry_tag_p(dep)));\n\t\t\tp += dp->d_ops->data_entsize(dep->namelen);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "1"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_make_free",
          "args": [
            "args",
            "bp",
            "(xfs_dir2_data_aoff_t)((char *)blp - (char *)hdr)",
            "(xfs_dir2_data_aoff_t)((be32_to_cpu(btp->stale) - 1) * sizeof(*blp))",
            "needlog",
            "&needscan"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_make_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "714-894",
          "snippet": "void\nxfs_dir2_data_make_free(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_aoff_t\toffset,\t\t/* starting byte offset */\n\txfs_dir2_data_aoff_t\tlen,\t\t/* length in bytes */\n\tint\t\t\t*needlogp,\t/* out: log header */\n\tint\t\t\t*needscanp)\t/* out: regen bestfree */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block pointer */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree pointer */\n\tchar\t\t\t*endptr;\t/* end of data area */\n\tint\t\t\tneedscan;\t/* need to regen bestfree */\n\txfs_dir2_data_unused_t\t*newdup;\t/* new unused entry */\n\txfs_dir2_data_unused_t\t*postdup;\t/* unused entry after us */\n\txfs_dir2_data_unused_t\t*prevdup;\t/* unused entry before us */\n\tstruct xfs_dir2_data_free *bf;\n\n\thdr = bp->b_addr;\n\n\t/*\n\t * Figure out where the end of the data area is.\n\t */\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC))\n\t\tendptr = (char *)hdr + args->geo->blksize;\n\telse {\n\t\txfs_dir2_block_tail_t\t*btp;\t/* block tail */\n\n\t\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t\t\thdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\t\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\t\tendptr = (char *)xfs_dir2_block_leaf_p(btp);\n\t}\n\t/*\n\t * If this isn't the start of the block, then back up to\n\t * the previous entry and see if it's free.\n\t */\n\tif (offset > args->dp->d_ops->data_entry_offset) {\n\t\t__be16\t\t\t*tagp;\t/* tag just before us */\n\n\t\ttagp = (__be16 *)((char *)hdr + offset) - 1;\n\t\tprevdup = (xfs_dir2_data_unused_t *)((char *)hdr + be16_to_cpu(*tagp));\n\t\tif (be16_to_cpu(prevdup->freetag) != XFS_DIR2_DATA_FREE_TAG)\n\t\t\tprevdup = NULL;\n\t} else\n\t\tprevdup = NULL;\n\t/*\n\t * If this isn't the end of the block, see if the entry after\n\t * us is free.\n\t */\n\tif ((char *)hdr + offset + len < endptr) {\n\t\tpostdup =\n\t\t\t(xfs_dir2_data_unused_t *)((char *)hdr + offset + len);\n\t\tif (be16_to_cpu(postdup->freetag) != XFS_DIR2_DATA_FREE_TAG)\n\t\t\tpostdup = NULL;\n\t} else\n\t\tpostdup = NULL;\n\tASSERT(*needscanp == 0);\n\tneedscan = 0;\n\t/*\n\t * Previous and following entries are both free,\n\t * merge everything into a single free entry.\n\t */\n\tbf = args->dp->d_ops->data_bestfree_p(hdr);\n\tif (prevdup && postdup) {\n\t\txfs_dir2_data_free_t\t*dfp2;\t/* another bestfree pointer */\n\n\t\t/*\n\t\t * See if prevdup and/or postdup are in bestfree table.\n\t\t */\n\t\tdfp = xfs_dir2_data_freefind(hdr, bf, prevdup);\n\t\tdfp2 = xfs_dir2_data_freefind(hdr, bf, postdup);\n\t\t/*\n\t\t * We need a rescan unless there are exactly 2 free entries\n\t\t * namely our two.  Then we know what's happening, otherwise\n\t\t * since the third bestfree is there, there might be more\n\t\t * entries.\n\t\t */\n\t\tneedscan = (bf[2].length != 0);\n\t\t/*\n\t\t * Fix up the new big freespace.\n\t\t */\n\t\tbe16_add_cpu(&prevdup->length, len + be16_to_cpu(postdup->length));\n\t\t*xfs_dir2_data_unused_tag_p(prevdup) =\n\t\t\tcpu_to_be16((char *)prevdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, prevdup);\n\t\tif (!needscan) {\n\t\t\t/*\n\t\t\t * Has to be the case that entries 0 and 1 are\n\t\t\t * dfp and dfp2 (don't know which is which), and\n\t\t\t * entry 2 is empty.\n\t\t\t * Remove entry 1 first then entry 0.\n\t\t\t */\n\t\t\tASSERT(dfp && dfp2);\n\t\t\tif (dfp == &bf[1]) {\n\t\t\t\tdfp = &bf[0];\n\t\t\t\tASSERT(dfp2 == dfp);\n\t\t\t\tdfp2 = &bf[1];\n\t\t\t}\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp2, needlogp);\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\t/*\n\t\t\t * Now insert the new entry.\n\t\t\t */\n\t\t\tdfp = xfs_dir2_data_freeinsert(hdr, bf, prevdup,\n\t\t\t\t\t\t       needlogp);\n\t\t\tASSERT(dfp == &bf[0]);\n\t\t\tASSERT(dfp->length == prevdup->length);\n\t\t\tASSERT(!dfp[1].length);\n\t\t\tASSERT(!dfp[2].length);\n\t\t}\n\t}\n\t/*\n\t * The entry before us is free, merge with it.\n\t */\n\telse if (prevdup) {\n\t\tdfp = xfs_dir2_data_freefind(hdr, bf, prevdup);\n\t\tbe16_add_cpu(&prevdup->length, len);\n\t\t*xfs_dir2_data_unused_tag_p(prevdup) =\n\t\t\tcpu_to_be16((char *)prevdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, prevdup);\n\t\t/*\n\t\t * If the previous entry was in the table, the new entry\n\t\t * is longer, so it will be in the table too.  Remove\n\t\t * the old one and add the new one.\n\t\t */\n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\txfs_dir2_data_freeinsert(hdr, bf, prevdup, needlogp);\n\t\t}\n\t\t/*\n\t\t * Otherwise we need a scan if the new entry is big enough.\n\t\t */\n\t\telse {\n\t\t\tneedscan = be16_to_cpu(prevdup->length) >\n\t\t\t\t   be16_to_cpu(bf[2].length);\n\t\t}\n\t}\n\t/*\n\t * The following entry is free, merge with it.\n\t */\n\telse if (postdup) {\n\t\tdfp = xfs_dir2_data_freefind(hdr, bf, postdup);\n\t\tnewdup = (xfs_dir2_data_unused_t *)((char *)hdr + offset);\n\t\tnewdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup->length = cpu_to_be16(len + be16_to_cpu(postdup->length));\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\t/*\n\t\t * If the following entry was in the table, the new entry\n\t\t * is longer, so it will be in the table too.  Remove\n\t\t * the old one and add the new one.\n\t\t */\n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\txfs_dir2_data_freeinsert(hdr, bf, newdup, needlogp);\n\t\t}\n\t\t/*\n\t\t * Otherwise we need a scan if the new entry is big enough.\n\t\t */\n\t\telse {\n\t\t\tneedscan = be16_to_cpu(newdup->length) >\n\t\t\t\t   be16_to_cpu(bf[2].length);\n\t\t}\n\t}\n\t/*\n\t * Neither neighbor is free.  Make a new entry.\n\t */\n\telse {\n\t\tnewdup = (xfs_dir2_data_unused_t *)((char *)hdr + offset);\n\t\tnewdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup->length = cpu_to_be16(len);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\txfs_dir2_data_freeinsert(hdr, bf, newdup, needlogp);\n\t}\n\t*needscanp = needscan;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dir2_data_make_free(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_aoff_t\toffset,\t\t/* starting byte offset */\n\txfs_dir2_data_aoff_t\tlen,\t\t/* length in bytes */\n\tint\t\t\t*needlogp,\t/* out: log header */\n\tint\t\t\t*needscanp)\t/* out: regen bestfree */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block pointer */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree pointer */\n\tchar\t\t\t*endptr;\t/* end of data area */\n\tint\t\t\tneedscan;\t/* need to regen bestfree */\n\txfs_dir2_data_unused_t\t*newdup;\t/* new unused entry */\n\txfs_dir2_data_unused_t\t*postdup;\t/* unused entry after us */\n\txfs_dir2_data_unused_t\t*prevdup;\t/* unused entry before us */\n\tstruct xfs_dir2_data_free *bf;\n\n\thdr = bp->b_addr;\n\n\t/*\n\t * Figure out where the end of the data area is.\n\t */\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC))\n\t\tendptr = (char *)hdr + args->geo->blksize;\n\telse {\n\t\txfs_dir2_block_tail_t\t*btp;\t/* block tail */\n\n\t\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t\t\thdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\t\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\t\tendptr = (char *)xfs_dir2_block_leaf_p(btp);\n\t}\n\t/*\n\t * If this isn't the start of the block, then back up to\n\t * the previous entry and see if it's free.\n\t */\n\tif (offset > args->dp->d_ops->data_entry_offset) {\n\t\t__be16\t\t\t*tagp;\t/* tag just before us */\n\n\t\ttagp = (__be16 *)((char *)hdr + offset) - 1;\n\t\tprevdup = (xfs_dir2_data_unused_t *)((char *)hdr + be16_to_cpu(*tagp));\n\t\tif (be16_to_cpu(prevdup->freetag) != XFS_DIR2_DATA_FREE_TAG)\n\t\t\tprevdup = NULL;\n\t} else\n\t\tprevdup = NULL;\n\t/*\n\t * If this isn't the end of the block, see if the entry after\n\t * us is free.\n\t */\n\tif ((char *)hdr + offset + len < endptr) {\n\t\tpostdup =\n\t\t\t(xfs_dir2_data_unused_t *)((char *)hdr + offset + len);\n\t\tif (be16_to_cpu(postdup->freetag) != XFS_DIR2_DATA_FREE_TAG)\n\t\t\tpostdup = NULL;\n\t} else\n\t\tpostdup = NULL;\n\tASSERT(*needscanp == 0);\n\tneedscan = 0;\n\t/*\n\t * Previous and following entries are both free,\n\t * merge everything into a single free entry.\n\t */\n\tbf = args->dp->d_ops->data_bestfree_p(hdr);\n\tif (prevdup && postdup) {\n\t\txfs_dir2_data_free_t\t*dfp2;\t/* another bestfree pointer */\n\n\t\t/*\n\t\t * See if prevdup and/or postdup are in bestfree table.\n\t\t */\n\t\tdfp = xfs_dir2_data_freefind(hdr, bf, prevdup);\n\t\tdfp2 = xfs_dir2_data_freefind(hdr, bf, postdup);\n\t\t/*\n\t\t * We need a rescan unless there are exactly 2 free entries\n\t\t * namely our two.  Then we know what's happening, otherwise\n\t\t * since the third bestfree is there, there might be more\n\t\t * entries.\n\t\t */\n\t\tneedscan = (bf[2].length != 0);\n\t\t/*\n\t\t * Fix up the new big freespace.\n\t\t */\n\t\tbe16_add_cpu(&prevdup->length, len + be16_to_cpu(postdup->length));\n\t\t*xfs_dir2_data_unused_tag_p(prevdup) =\n\t\t\tcpu_to_be16((char *)prevdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, prevdup);\n\t\tif (!needscan) {\n\t\t\t/*\n\t\t\t * Has to be the case that entries 0 and 1 are\n\t\t\t * dfp and dfp2 (don't know which is which), and\n\t\t\t * entry 2 is empty.\n\t\t\t * Remove entry 1 first then entry 0.\n\t\t\t */\n\t\t\tASSERT(dfp && dfp2);\n\t\t\tif (dfp == &bf[1]) {\n\t\t\t\tdfp = &bf[0];\n\t\t\t\tASSERT(dfp2 == dfp);\n\t\t\t\tdfp2 = &bf[1];\n\t\t\t}\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp2, needlogp);\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\t/*\n\t\t\t * Now insert the new entry.\n\t\t\t */\n\t\t\tdfp = xfs_dir2_data_freeinsert(hdr, bf, prevdup,\n\t\t\t\t\t\t       needlogp);\n\t\t\tASSERT(dfp == &bf[0]);\n\t\t\tASSERT(dfp->length == prevdup->length);\n\t\t\tASSERT(!dfp[1].length);\n\t\t\tASSERT(!dfp[2].length);\n\t\t}\n\t}\n\t/*\n\t * The entry before us is free, merge with it.\n\t */\n\telse if (prevdup) {\n\t\tdfp = xfs_dir2_data_freefind(hdr, bf, prevdup);\n\t\tbe16_add_cpu(&prevdup->length, len);\n\t\t*xfs_dir2_data_unused_tag_p(prevdup) =\n\t\t\tcpu_to_be16((char *)prevdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, prevdup);\n\t\t/*\n\t\t * If the previous entry was in the table, the new entry\n\t\t * is longer, so it will be in the table too.  Remove\n\t\t * the old one and add the new one.\n\t\t */\n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\txfs_dir2_data_freeinsert(hdr, bf, prevdup, needlogp);\n\t\t}\n\t\t/*\n\t\t * Otherwise we need a scan if the new entry is big enough.\n\t\t */\n\t\telse {\n\t\t\tneedscan = be16_to_cpu(prevdup->length) >\n\t\t\t\t   be16_to_cpu(bf[2].length);\n\t\t}\n\t}\n\t/*\n\t * The following entry is free, merge with it.\n\t */\n\telse if (postdup) {\n\t\tdfp = xfs_dir2_data_freefind(hdr, bf, postdup);\n\t\tnewdup = (xfs_dir2_data_unused_t *)((char *)hdr + offset);\n\t\tnewdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup->length = cpu_to_be16(len + be16_to_cpu(postdup->length));\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\t/*\n\t\t * If the following entry was in the table, the new entry\n\t\t * is longer, so it will be in the table too.  Remove\n\t\t * the old one and add the new one.\n\t\t */\n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\txfs_dir2_data_freeinsert(hdr, bf, newdup, needlogp);\n\t\t}\n\t\t/*\n\t\t * Otherwise we need a scan if the new entry is big enough.\n\t\t */\n\t\telse {\n\t\t\tneedscan = be16_to_cpu(newdup->length) >\n\t\t\t\t   be16_to_cpu(bf[2].length);\n\t\t}\n\t}\n\t/*\n\t * Neither neighbor is free.  Make a new entry.\n\t */\n\telse {\n\t\tnewdup = (xfs_dir2_data_unused_t *)((char *)hdr + offset);\n\t\tnewdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup->length = cpu_to_be16(len);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\txfs_dir2_data_freeinsert(hdr, bf, newdup, needlogp);\n\t}\n\t*needscanp = needscan;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(be32_to_cpu(btp->stale) - 1) * sizeof(*blp)"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btp->stale"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(char *)blp - (char *)hdr"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_add_cpu",
          "args": [
            "&btp->count",
            "-(be32_to_cpu(btp->stale) - 1)"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btp->stale"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btp->stale"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btp->stale"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_NULL_DATAPTR"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btp->count"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);\n\nstatic void\nxfs_dir2_block_compact(\n\tstruct xfs_da_args\t\t*args,\n\tstruct xfs_buf\t\t\t*bp,\n\tstruct xfs_dir2_data_hdr\t*hdr,\n\tstruct xfs_dir2_block_tail\t*btp,\n\tstruct xfs_dir2_leaf_entry\t*blp,\n\tint\t\t\t\t*needlog,\n\tint\t\t\t\t*lfloghigh,\n\tint\t\t\t\t*lfloglow)\n{\n\tint\t\t\tfromidx;\t/* source leaf index */\n\tint\t\t\ttoidx;\t\t/* target leaf index */\n\tint\t\t\tneedscan = 0;\n\tint\t\t\thighstale;\t/* high stale index */\n\n\tfromidx = toidx = be32_to_cpu(btp->count) - 1;\n\thighstale = *lfloghigh = -1;\n\tfor (; fromidx >= 0; fromidx--) {\n\t\tif (blp[fromidx].address == cpu_to_be32(XFS_DIR2_NULL_DATAPTR)) {\n\t\t\tif (highstale == -1)\n\t\t\t\thighstale = toidx;\n\t\t\telse {\n\t\t\t\tif (*lfloghigh == -1)\n\t\t\t\t\t*lfloghigh = toidx;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (fromidx < toidx)\n\t\t\tblp[toidx] = blp[fromidx];\n\t\ttoidx--;\n\t}\n\t*lfloglow = toidx + 1 - (be32_to_cpu(btp->stale) - 1);\n\t*lfloghigh -= be32_to_cpu(btp->stale) - 1;\n\tbe32_add_cpu(&btp->count, -(be32_to_cpu(btp->stale) - 1));\n\txfs_dir2_data_make_free(args, bp,\n\t\t(xfs_dir2_data_aoff_t)((char *)blp - (char *)hdr),\n\t\t(xfs_dir2_data_aoff_t)((be32_to_cpu(btp->stale) - 1) * sizeof(*blp)),\n\t\tneedlog, &needscan);\n\tbtp->stale = cpu_to_be32(1);\n\t/*\n\t * If we now need to rebuild the bestfree map, do so.\n\t * This needs to happen before the next call to use_free.\n\t */\n\tif (needscan)\n\t\txfs_dir2_data_freescan(args->dp, hdr, needlog);\n}"
  },
  {
    "function_name": "xfs_dir2_block_need_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
    "lines": "167-272",
    "snippet": "static void\nxfs_dir2_block_need_space(\n\tstruct xfs_inode\t\t*dp,\n\tstruct xfs_dir2_data_hdr\t*hdr,\n\tstruct xfs_dir2_block_tail\t*btp,\n\tstruct xfs_dir2_leaf_entry\t*blp,\n\t__be16\t\t\t\t**tagpp,\n\tstruct xfs_dir2_data_unused\t**dupp,\n\tstruct xfs_dir2_data_unused\t**enddupp,\n\tint\t\t\t\t*compact,\n\tint\t\t\t\tlen)\n{\n\tstruct xfs_dir2_data_free\t*bf;\n\t__be16\t\t\t\t*tagp = NULL;\n\tstruct xfs_dir2_data_unused\t*dup = NULL;\n\tstruct xfs_dir2_data_unused\t*enddup = NULL;\n\n\t*compact = 0;\n\tbf = dp->d_ops->data_bestfree_p(hdr);\n\n\t/*\n\t * If there are stale entries we'll use one for the leaf.\n\t */\n\tif (btp->stale) {\n\t\tif (be16_to_cpu(bf[0].length) >= len) {\n\t\t\t/*\n\t\t\t * The biggest entry enough to avoid compaction.\n\t\t\t */\n\t\t\tdup = (xfs_dir2_data_unused_t *)\n\t\t\t      ((char *)hdr + be16_to_cpu(bf[0].offset));\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Will need to compact to make this work.\n\t\t * Tag just before the first leaf entry.\n\t\t */\n\t\t*compact = 1;\n\t\ttagp = (__be16 *)blp - 1;\n\n\t\t/* Data object just before the first leaf entry.  */\n\t\tdup = (xfs_dir2_data_unused_t *)((char *)hdr + be16_to_cpu(*tagp));\n\n\t\t/*\n\t\t * If it's not free then the data will go where the\n\t\t * leaf data starts now, if it works at all.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tif (be16_to_cpu(dup->length) + (be32_to_cpu(btp->stale) - 1) *\n\t\t\t    (uint)sizeof(*blp) < len)\n\t\t\t\tdup = NULL;\n\t\t} else if ((be32_to_cpu(btp->stale) - 1) * (uint)sizeof(*blp) < len)\n\t\t\tdup = NULL;\n\t\telse\n\t\t\tdup = (xfs_dir2_data_unused_t *)blp;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * no stale entries, so just use free space.\n\t * Tag just before the first leaf entry.\n\t */\n\ttagp = (__be16 *)blp - 1;\n\n\t/* Data object just before the first leaf entry.  */\n\tenddup = (xfs_dir2_data_unused_t *)((char *)hdr + be16_to_cpu(*tagp));\n\n\t/*\n\t * If it's not free then can't do this add without cleaning up:\n\t * the space before the first leaf entry needs to be free so it\n\t * can be expanded to hold the pointer to the new entry.\n\t */\n\tif (be16_to_cpu(enddup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t/*\n\t\t * Check out the biggest freespace and see if it's the same one.\n\t\t */\n\t\tdup = (xfs_dir2_data_unused_t *)\n\t\t      ((char *)hdr + be16_to_cpu(bf[0].offset));\n\t\tif (dup != enddup) {\n\t\t\t/*\n\t\t\t * Not the same free entry, just check its length.\n\t\t\t */\n\t\t\tif (be16_to_cpu(dup->length) < len)\n\t\t\t\tdup = NULL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * It is the biggest freespace, can it hold the leaf too?\n\t\t */\n\t\tif (be16_to_cpu(dup->length) < len + (uint)sizeof(*blp)) {\n\t\t\t/*\n\t\t\t * Yes, use the second-largest entry instead if it works.\n\t\t\t */\n\t\t\tif (be16_to_cpu(bf[1].length) >= len)\n\t\t\t\tdup = (xfs_dir2_data_unused_t *)\n\t\t\t\t      ((char *)hdr + be16_to_cpu(bf[1].offset));\n\t\t\telse\n\t\t\t\tdup = NULL;\n\t\t}\n\t}\nout:\n\t*tagpp = tagp;\n\t*dupp = dup;\n\t*enddupp = enddup;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "bf[1].offset"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "bf[1].length"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dup->length"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dup->length"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "bf[0].offset"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "enddup->freetag"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "*tagp"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btp->stale"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "btp->stale"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dup->length"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dup->freetag"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "*tagp"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "bf[0].offset"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "bf[0].length"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_bestfree_p",
          "args": [
            "hdr"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_dir2_block_need_space(\n\tstruct xfs_inode\t\t*dp,\n\tstruct xfs_dir2_data_hdr\t*hdr,\n\tstruct xfs_dir2_block_tail\t*btp,\n\tstruct xfs_dir2_leaf_entry\t*blp,\n\t__be16\t\t\t\t**tagpp,\n\tstruct xfs_dir2_data_unused\t**dupp,\n\tstruct xfs_dir2_data_unused\t**enddupp,\n\tint\t\t\t\t*compact,\n\tint\t\t\t\tlen)\n{\n\tstruct xfs_dir2_data_free\t*bf;\n\t__be16\t\t\t\t*tagp = NULL;\n\tstruct xfs_dir2_data_unused\t*dup = NULL;\n\tstruct xfs_dir2_data_unused\t*enddup = NULL;\n\n\t*compact = 0;\n\tbf = dp->d_ops->data_bestfree_p(hdr);\n\n\t/*\n\t * If there are stale entries we'll use one for the leaf.\n\t */\n\tif (btp->stale) {\n\t\tif (be16_to_cpu(bf[0].length) >= len) {\n\t\t\t/*\n\t\t\t * The biggest entry enough to avoid compaction.\n\t\t\t */\n\t\t\tdup = (xfs_dir2_data_unused_t *)\n\t\t\t      ((char *)hdr + be16_to_cpu(bf[0].offset));\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Will need to compact to make this work.\n\t\t * Tag just before the first leaf entry.\n\t\t */\n\t\t*compact = 1;\n\t\ttagp = (__be16 *)blp - 1;\n\n\t\t/* Data object just before the first leaf entry.  */\n\t\tdup = (xfs_dir2_data_unused_t *)((char *)hdr + be16_to_cpu(*tagp));\n\n\t\t/*\n\t\t * If it's not free then the data will go where the\n\t\t * leaf data starts now, if it works at all.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tif (be16_to_cpu(dup->length) + (be32_to_cpu(btp->stale) - 1) *\n\t\t\t    (uint)sizeof(*blp) < len)\n\t\t\t\tdup = NULL;\n\t\t} else if ((be32_to_cpu(btp->stale) - 1) * (uint)sizeof(*blp) < len)\n\t\t\tdup = NULL;\n\t\telse\n\t\t\tdup = (xfs_dir2_data_unused_t *)blp;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * no stale entries, so just use free space.\n\t * Tag just before the first leaf entry.\n\t */\n\ttagp = (__be16 *)blp - 1;\n\n\t/* Data object just before the first leaf entry.  */\n\tenddup = (xfs_dir2_data_unused_t *)((char *)hdr + be16_to_cpu(*tagp));\n\n\t/*\n\t * If it's not free then can't do this add without cleaning up:\n\t * the space before the first leaf entry needs to be free so it\n\t * can be expanded to hold the pointer to the new entry.\n\t */\n\tif (be16_to_cpu(enddup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t/*\n\t\t * Check out the biggest freespace and see if it's the same one.\n\t\t */\n\t\tdup = (xfs_dir2_data_unused_t *)\n\t\t      ((char *)hdr + be16_to_cpu(bf[0].offset));\n\t\tif (dup != enddup) {\n\t\t\t/*\n\t\t\t * Not the same free entry, just check its length.\n\t\t\t */\n\t\t\tif (be16_to_cpu(dup->length) < len)\n\t\t\t\tdup = NULL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * It is the biggest freespace, can it hold the leaf too?\n\t\t */\n\t\tif (be16_to_cpu(dup->length) < len + (uint)sizeof(*blp)) {\n\t\t\t/*\n\t\t\t * Yes, use the second-largest entry instead if it works.\n\t\t\t */\n\t\t\tif (be16_to_cpu(bf[1].length) >= len)\n\t\t\t\tdup = (xfs_dir2_data_unused_t *)\n\t\t\t\t      ((char *)hdr + be16_to_cpu(bf[1].offset));\n\t\t\telse\n\t\t\t\tdup = NULL;\n\t\t}\n\t}\nout:\n\t*tagpp = tagp;\n\t*dupp = dup;\n\t*enddupp = enddup;\n}"
  },
  {
    "function_name": "xfs_dir3_block_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
    "lines": "143-165",
    "snippet": "static void\nxfs_dir3_block_init(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_inode\t*dp)\n{\n\tstruct xfs_dir3_blk_hdr *hdr3 = bp->b_addr;\n\n\tbp->b_ops = &xfs_dir3_block_buf_ops;\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DIR_BLOCK_BUF);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tmemset(hdr3, 0, sizeof(*hdr3));\n\t\thdr3->magic = cpu_to_be32(XFS_DIR3_BLOCK_MAGIC);\n\t\thdr3->blkno = cpu_to_be64(bp->b_bn);\n\t\thdr3->owner = cpu_to_be64(dp->i_ino);\n\t\tuuid_copy(&hdr3->uuid, &mp->m_sb.sb_uuid);\n\t\treturn;\n\n\t}\n\thdr3->magic = cpu_to_be32(XFS_DIR2_BLOCK_MAGIC);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);",
      "const struct xfs_buf_ops xfs_dir3_block_buf_ops = {\n\t.verify_read = xfs_dir3_block_read_verify,\n\t.verify_write = xfs_dir3_block_write_verify,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_BLOCK_MAGIC"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uuid_copy",
          "args": [
            "&hdr3->uuid",
            "&mp->m_sb.sb_uuid"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.h",
          "lines": "29-33",
          "snippet": "static inline void\nuuid_copy(uuid_t *dst, uuid_t *src)\n{\n\tmemcpy(dst, src, sizeof(uuid_t));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nuuid_copy(uuid_t *dst, uuid_t *src)\n{\n\tmemcpy(dst, src, sizeof(uuid_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "dp->i_ino"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "bp->b_bn"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR3_BLOCK_MAGIC"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "hdr3",
            "0",
            "sizeof(*hdr3)"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_buf_set_type",
          "args": [
            "tp",
            "bp",
            "XFS_BLFT_DIR_BLOCK_BUF"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_buf_set_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "730-746",
          "snippet": "void\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);\nconst struct xfs_buf_ops xfs_dir3_block_buf_ops = {\n\t.verify_read = xfs_dir3_block_read_verify,\n\t.verify_write = xfs_dir3_block_write_verify,\n};\n\nstatic void\nxfs_dir3_block_init(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_inode\t*dp)\n{\n\tstruct xfs_dir3_blk_hdr *hdr3 = bp->b_addr;\n\n\tbp->b_ops = &xfs_dir3_block_buf_ops;\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DIR_BLOCK_BUF);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tmemset(hdr3, 0, sizeof(*hdr3));\n\t\thdr3->magic = cpu_to_be32(XFS_DIR3_BLOCK_MAGIC);\n\t\thdr3->blkno = cpu_to_be64(bp->b_bn);\n\t\thdr3->owner = cpu_to_be64(dp->i_ino);\n\t\tuuid_copy(&hdr3->uuid, &mp->m_sb.sb_uuid);\n\t\treturn;\n\n\t}\n\thdr3->magic = cpu_to_be32(XFS_DIR2_BLOCK_MAGIC);\n}"
  },
  {
    "function_name": "xfs_dir3_block_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
    "lines": "127-141",
    "snippet": "int\nxfs_dir3_block_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, mp->m_dir_geo->datablk, -1, bpp,\n\t\t\t\tXFS_DATA_FORK, &xfs_dir3_block_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_DIR_BLOCK_BUF);\n\treturn err;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "const struct xfs_buf_ops xfs_dir3_block_buf_ops = {\n\t.verify_read = xfs_dir3_block_read_verify,\n\t.verify_write = xfs_dir3_block_write_verify,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_buf_set_type",
          "args": [
            "tp",
            "*bpp",
            "XFS_BLFT_DIR_BLOCK_BUF"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_buf_set_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "730-746",
          "snippet": "void\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da_read_buf",
          "args": [
            "tp",
            "dp",
            "mp->m_dir_geo->datablk",
            "-1",
            "bpp",
            "XFS_DATA_FORK",
            "&xfs_dir3_block_buf_ops"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_read_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "2577-2621",
          "snippet": "int\nxfs_da_read_buf(\n\tstruct xfs_trans\t*trans,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhichfork,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_buf_map\tmap;\n\tstruct xfs_buf_map\t*mapp;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\n\t*bpp = NULL;\n\tmapp = &map;\n\tnmap = 1;\n\terror = xfs_dabuf_map(dp, bno, mappedbno, whichfork,\n\t\t\t\t&mapp, &nmap);\n\tif (error) {\n\t\t/* mapping a hole is not an error, but we don't continue */\n\t\tif (error == -1)\n\t\t\terror = 0;\n\t\tgoto out_free;\n\t}\n\n\terror = xfs_trans_read_buf_map(dp->i_mount, trans,\n\t\t\t\t\tdp->i_mount->m_ddev_targp,\n\t\t\t\t\tmapp, nmap, 0, &bp, ops);\n\tif (error)\n\t\tgoto out_free;\n\n\tif (whichfork == XFS_ATTR_FORK)\n\t\txfs_buf_set_ref(bp, XFS_ATTR_BTREE_REF);\n\telse\n\t\txfs_buf_set_ref(bp, XFS_DIR_BTREE_REF);\n\t*bpp = bp;\nout_free:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_da_read_buf(\n\tstruct xfs_trans\t*trans,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhichfork,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_buf_map\tmap;\n\tstruct xfs_buf_map\t*mapp;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\n\t*bpp = NULL;\n\tmapp = &map;\n\tnmap = 1;\n\terror = xfs_dabuf_map(dp, bno, mappedbno, whichfork,\n\t\t\t\t&mapp, &nmap);\n\tif (error) {\n\t\t/* mapping a hole is not an error, but we don't continue */\n\t\tif (error == -1)\n\t\t\terror = 0;\n\t\tgoto out_free;\n\t}\n\n\terror = xfs_trans_read_buf_map(dp->i_mount, trans,\n\t\t\t\t\tdp->i_mount->m_ddev_targp,\n\t\t\t\t\tmapp, nmap, 0, &bp, ops);\n\tif (error)\n\t\tgoto out_free;\n\n\tif (whichfork == XFS_ATTR_FORK)\n\t\txfs_buf_set_ref(bp, XFS_ATTR_BTREE_REF);\n\telse\n\t\txfs_buf_set_ref(bp, XFS_DIR_BTREE_REF);\n\t*bpp = bp;\nout_free:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_dir3_block_buf_ops = {\n\t.verify_read = xfs_dir3_block_read_verify,\n\t.verify_write = xfs_dir3_block_write_verify,\n};\n\nint\nxfs_dir3_block_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, mp->m_dir_geo->datablk, -1, bpp,\n\t\t\t\tXFS_DATA_FORK, &xfs_dir3_block_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_DIR_BLOCK_BUF);\n\treturn err;\n}"
  },
  {
    "function_name": "xfs_dir3_block_write_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
    "lines": "99-120",
    "snippet": "static void\nxfs_dir3_block_write_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\tstruct xfs_dir3_blk_hdr\t*hdr3 = bp->b_addr;\n\n\tif (!xfs_dir3_block_verify(bp)) {\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\t\txfs_verifier_error(bp);\n\t\treturn;\n\t}\n\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn;\n\n\tif (bip)\n\t\thdr3->lsn = cpu_to_be64(bip->bli_item.li_lsn);\n\n\txfs_buf_update_cksum(bp, XFS_DIR3_DATA_CRC_OFF);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_update_cksum",
          "args": [
            "bp",
            "XFS_DIR3_DATA_CRC_OFF"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_update_cksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "374-379",
          "snippet": "static inline void\nxfs_buf_update_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\txfs_update_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t cksum_offset);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void\nxfs_buf_update_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\txfs_update_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t cksum_offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "bip->bli_item.li_lsn"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_verifier_error",
          "args": [
            "bp"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_verifier_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_error.c",
          "lines": "161-180",
          "snippet": "void\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioerror",
          "args": [
            "bp",
            "-EFSCORRUPTED"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir3_block_verify",
          "args": [
            "bp"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_block_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
          "lines": "60-81",
          "snippet": "static bool\nxfs_dir3_block_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_dir3_blk_hdr\t*hdr3 = bp->b_addr;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tif (hdr3->magic != cpu_to_be32(XFS_DIR3_BLOCK_MAGIC))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&hdr3->uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (be64_to_cpu(hdr3->blkno) != bp->b_bn)\n\t\t\treturn false;\n\t} else {\n\t\tif (hdr3->magic != cpu_to_be32(XFS_DIR2_BLOCK_MAGIC))\n\t\t\treturn false;\n\t}\n\tif (__xfs_dir3_data_check(NULL, bp))\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);\n\nstatic bool\nxfs_dir3_block_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_dir3_blk_hdr\t*hdr3 = bp->b_addr;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tif (hdr3->magic != cpu_to_be32(XFS_DIR3_BLOCK_MAGIC))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&hdr3->uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (be64_to_cpu(hdr3->blkno) != bp->b_bn)\n\t\t\treturn false;\n\t} else {\n\t\tif (hdr3->magic != cpu_to_be32(XFS_DIR2_BLOCK_MAGIC))\n\t\t\treturn false;\n\t}\n\tif (__xfs_dir3_data_check(NULL, bp))\n\t\treturn false;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);\n\nstatic void\nxfs_dir3_block_write_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\tstruct xfs_dir3_blk_hdr\t*hdr3 = bp->b_addr;\n\n\tif (!xfs_dir3_block_verify(bp)) {\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\t\txfs_verifier_error(bp);\n\t\treturn;\n\t}\n\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn;\n\n\tif (bip)\n\t\thdr3->lsn = cpu_to_be64(bip->bli_item.li_lsn);\n\n\txfs_buf_update_cksum(bp, XFS_DIR3_DATA_CRC_OFF);\n}"
  },
  {
    "function_name": "xfs_dir3_block_read_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
    "lines": "83-97",
    "snippet": "static void\nxfs_dir3_block_read_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb) &&\n\t     !xfs_buf_verify_cksum(bp, XFS_DIR3_DATA_CRC_OFF))\n\t\txfs_buf_ioerror(bp, -EFSBADCRC);\n\telse if (!xfs_dir3_block_verify(bp))\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\n\tif (bp->b_error)\n\t\txfs_verifier_error(bp);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_verifier_error",
          "args": [
            "bp"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_verifier_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_error.c",
          "lines": "161-180",
          "snippet": "void\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioerror",
          "args": [
            "bp",
            "-EFSCORRUPTED"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir3_block_verify",
          "args": [
            "bp"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_block_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
          "lines": "60-81",
          "snippet": "static bool\nxfs_dir3_block_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_dir3_blk_hdr\t*hdr3 = bp->b_addr;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tif (hdr3->magic != cpu_to_be32(XFS_DIR3_BLOCK_MAGIC))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&hdr3->uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (be64_to_cpu(hdr3->blkno) != bp->b_bn)\n\t\t\treturn false;\n\t} else {\n\t\tif (hdr3->magic != cpu_to_be32(XFS_DIR2_BLOCK_MAGIC))\n\t\t\treturn false;\n\t}\n\tif (__xfs_dir3_data_check(NULL, bp))\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);\n\nstatic bool\nxfs_dir3_block_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_dir3_blk_hdr\t*hdr3 = bp->b_addr;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tif (hdr3->magic != cpu_to_be32(XFS_DIR3_BLOCK_MAGIC))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&hdr3->uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (be64_to_cpu(hdr3->blkno) != bp->b_bn)\n\t\t\treturn false;\n\t} else {\n\t\tif (hdr3->magic != cpu_to_be32(XFS_DIR2_BLOCK_MAGIC))\n\t\t\treturn false;\n\t}\n\tif (__xfs_dir3_data_check(NULL, bp))\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_verify_cksum",
          "args": [
            "bp",
            "XFS_DIR3_DATA_CRC_OFF"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_verify_cksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "367-372",
          "snippet": "static inline int\nxfs_buf_verify_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\treturn xfs_verify_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t\tcksum_offset);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline int\nxfs_buf_verify_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\treturn xfs_verify_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t\tcksum_offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);\n\nstatic void\nxfs_dir3_block_read_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb) &&\n\t     !xfs_buf_verify_cksum(bp, XFS_DIR3_DATA_CRC_OFF))\n\t\txfs_buf_ioerror(bp, -EFSBADCRC);\n\telse if (!xfs_dir3_block_verify(bp))\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\n\tif (bp->b_error)\n\t\txfs_verifier_error(bp);\n}"
  },
  {
    "function_name": "xfs_dir3_block_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
    "lines": "60-81",
    "snippet": "static bool\nxfs_dir3_block_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_dir3_blk_hdr\t*hdr3 = bp->b_addr;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tif (hdr3->magic != cpu_to_be32(XFS_DIR3_BLOCK_MAGIC))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&hdr3->uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (be64_to_cpu(hdr3->blkno) != bp->b_bn)\n\t\t\treturn false;\n\t} else {\n\t\tif (hdr3->magic != cpu_to_be32(XFS_DIR2_BLOCK_MAGIC))\n\t\t\treturn false;\n\t}\n\tif (__xfs_dir3_data_check(NULL, bp))\n\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__xfs_dir3_data_check",
          "args": [
            "NULL",
            "bp"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "__xfs_dir3_data_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "40-210",
          "snippet": "int\n__xfs_dir3_data_check(\n\tstruct xfs_inode\t*dp,\t\t/* incore inode pointer */\n\tstruct xfs_buf\t\t*bp)\t\t/* data block's buffer */\n{\n\txfs_dir2_dataptr_t\taddr;\t\t/* addr for leaf lookup */\n\txfs_dir2_data_free_t\t*bf;\t\t/* bestfree table */\n\txfs_dir2_block_tail_t\t*btp=NULL;\t/* block tail */\n\tint\t\t\tcount;\t\t/* count of entries found */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry */\n\tchar\t\t\t*endp;\t\t/* end of useful data */\n\tint\t\t\tfreeseen;\t/* mask of bestfrees seen */\n\txfs_dahash_t\t\thash;\t\t/* hash of current name */\n\tint\t\t\ti;\t\t/* leaf index */\n\tint\t\t\tlastfree;\t/* last entry was unused */\n\txfs_dir2_leaf_entry_t\t*lep=NULL;\t/* block leaf entries */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tchar\t\t\t*p;\t\t/* current data position */\n\tint\t\t\tstale;\t\t/* count of stale leaves */\n\tstruct xfs_name\t\tname;\n\tconst struct xfs_dir_ops *ops;\n\tstruct xfs_da_geometry\t*geo;\n\n\tmp = bp->b_target->bt_mount;\n\tgeo = mp->m_dir_geo;\n\n\t/*\n\t * We can be passed a null dp here from a verifier, so we need to go the\n\t * hard way to get them.\n\t */\n\tops = xfs_dir_get_ops(mp, dp);\n\n\thdr = bp->b_addr;\n\tp = (char *)ops->data_entry_p(hdr);\n\n\tswitch (hdr->magic) {\n\tcase cpu_to_be32(XFS_DIR3_BLOCK_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_BLOCK_MAGIC):\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tlep = xfs_dir2_block_leaf_p(btp);\n\t\tendp = (char *)lep;\n\n\t\t/*\n\t\t * The number of leaf entries is limited by the size of the\n\t\t * block and the amount of space used by the data entries.\n\t\t * We don't know how much space is used by the data entries yet,\n\t\t * so just ensure that the count falls somewhere inside the\n\t\t * block right now.\n\t\t */\n\t\tXFS_WANT_CORRUPTED_RETURN(be32_to_cpu(btp->count) <\n\t\t\t((char *)btp - p) / sizeof(struct xfs_dir2_leaf_entry));\n\t\tbreak;\n\tcase cpu_to_be32(XFS_DIR3_DATA_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_DATA_MAGIC):\n\t\tendp = (char *)hdr + geo->blksize;\n\t\tbreak;\n\tdefault:\n\t\tXFS_ERROR_REPORT(\"Bad Magic\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/*\n\t * Account for zero bestfree entries.\n\t */\n\tbf = ops->data_bestfree_p(hdr);\n\tcount = lastfree = freeseen = 0;\n\tif (!bf[0].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[0].offset);\n\t\tfreeseen |= 1 << 0;\n\t}\n\tif (!bf[1].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[1].offset);\n\t\tfreeseen |= 1 << 1;\n\t}\n\tif (!bf[2].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[2].offset);\n\t\tfreeseen |= 1 << 2;\n\t}\n\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[0].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[1].length));\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[1].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t/*\n\t * Loop over the data/unused entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's unused, look for the space in the bestfree table.\n\t\t * If we find it, account for that, else make sure it\n\t\t * doesn't need to be there.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tXFS_WANT_CORRUPTED_RETURN(lastfree == 0);\n\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tbe16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)) ==\n\t\t\t\t\t       (char *)dup - (char *)hdr);\n\t\t\tdfp = xfs_dir2_data_freefind(hdr, bf, dup);\n\t\t\tif (dfp) {\n\t\t\t\ti = (int)(dfp - bf);\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\t(freeseen & (1 << i)) == 0);\n\t\t\t\tfreeseen |= 1 << i;\n\t\t\t} else {\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe16_to_cpu(dup->length) <=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t\t\t}\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t\tlastfree = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * It's a real entry.  Validate the fields.\n\t\t * If this is a block directory then make sure it's\n\t\t * in the leaf section of the block.\n\t\t * The linear search is crude but this is DEBUG code.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\tXFS_WANT_CORRUPTED_RETURN(dep->namelen != 0);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t!xfs_dir_ino_validate(mp, be64_to_cpu(dep->inumber)));\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\tbe16_to_cpu(*ops->data_entry_tag_p(dep)) ==\n\t\t\t\t\t       (char *)dep - (char *)hdr);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tops->data_get_ftype(dep) < XFS_DIR3_FT_MAX);\n\t\tcount++;\n\t\tlastfree = 0;\n\t\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\t\taddr = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,\n\t\t\t\t\t\t(xfs_dir2_data_aoff_t)\n\t\t\t\t\t\t((char *)dep - (char *)hdr));\n\t\t\tname.name = dep->name;\n\t\t\tname.len = dep->namelen;\n\t\t\thash = mp->m_dirnameops->hashname(&name);\n\t\t\tfor (i = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\t\tif (be32_to_cpu(lep[i].address) == addr &&\n\t\t\t\t    be32_to_cpu(lep[i].hashval) == hash)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i < be32_to_cpu(btp->count));\n\t\t}\n\t\tp += ops->data_entsize(dep->namelen);\n\t}\n\t/*\n\t * Need to have seen all the entries and all the bestfree slots.\n\t */\n\tXFS_WANT_CORRUPTED_RETURN(freeseen == 7);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tfor (i = stale = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\tif (lep[i].address ==\n\t\t\t    cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\t\tstale++;\n\t\t\tif (i > 0)\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe32_to_cpu(lep[i].hashval) >=\n\t\t\t\t\t\tbe32_to_cpu(lep[i - 1].hashval));\n\t\t}\n\t\tXFS_WANT_CORRUPTED_RETURN(count ==\n\t\t\tbe32_to_cpu(btp->count) - be32_to_cpu(btp->stale));\n\t\tXFS_WANT_CORRUPTED_RETURN(stale == be32_to_cpu(btp->stale));\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\n__xfs_dir3_data_check(\n\tstruct xfs_inode\t*dp,\t\t/* incore inode pointer */\n\tstruct xfs_buf\t\t*bp)\t\t/* data block's buffer */\n{\n\txfs_dir2_dataptr_t\taddr;\t\t/* addr for leaf lookup */\n\txfs_dir2_data_free_t\t*bf;\t\t/* bestfree table */\n\txfs_dir2_block_tail_t\t*btp=NULL;\t/* block tail */\n\tint\t\t\tcount;\t\t/* count of entries found */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry */\n\tchar\t\t\t*endp;\t\t/* end of useful data */\n\tint\t\t\tfreeseen;\t/* mask of bestfrees seen */\n\txfs_dahash_t\t\thash;\t\t/* hash of current name */\n\tint\t\t\ti;\t\t/* leaf index */\n\tint\t\t\tlastfree;\t/* last entry was unused */\n\txfs_dir2_leaf_entry_t\t*lep=NULL;\t/* block leaf entries */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tchar\t\t\t*p;\t\t/* current data position */\n\tint\t\t\tstale;\t\t/* count of stale leaves */\n\tstruct xfs_name\t\tname;\n\tconst struct xfs_dir_ops *ops;\n\tstruct xfs_da_geometry\t*geo;\n\n\tmp = bp->b_target->bt_mount;\n\tgeo = mp->m_dir_geo;\n\n\t/*\n\t * We can be passed a null dp here from a verifier, so we need to go the\n\t * hard way to get them.\n\t */\n\tops = xfs_dir_get_ops(mp, dp);\n\n\thdr = bp->b_addr;\n\tp = (char *)ops->data_entry_p(hdr);\n\n\tswitch (hdr->magic) {\n\tcase cpu_to_be32(XFS_DIR3_BLOCK_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_BLOCK_MAGIC):\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tlep = xfs_dir2_block_leaf_p(btp);\n\t\tendp = (char *)lep;\n\n\t\t/*\n\t\t * The number of leaf entries is limited by the size of the\n\t\t * block and the amount of space used by the data entries.\n\t\t * We don't know how much space is used by the data entries yet,\n\t\t * so just ensure that the count falls somewhere inside the\n\t\t * block right now.\n\t\t */\n\t\tXFS_WANT_CORRUPTED_RETURN(be32_to_cpu(btp->count) <\n\t\t\t((char *)btp - p) / sizeof(struct xfs_dir2_leaf_entry));\n\t\tbreak;\n\tcase cpu_to_be32(XFS_DIR3_DATA_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_DATA_MAGIC):\n\t\tendp = (char *)hdr + geo->blksize;\n\t\tbreak;\n\tdefault:\n\t\tXFS_ERROR_REPORT(\"Bad Magic\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/*\n\t * Account for zero bestfree entries.\n\t */\n\tbf = ops->data_bestfree_p(hdr);\n\tcount = lastfree = freeseen = 0;\n\tif (!bf[0].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[0].offset);\n\t\tfreeseen |= 1 << 0;\n\t}\n\tif (!bf[1].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[1].offset);\n\t\tfreeseen |= 1 << 1;\n\t}\n\tif (!bf[2].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[2].offset);\n\t\tfreeseen |= 1 << 2;\n\t}\n\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[0].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[1].length));\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[1].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t/*\n\t * Loop over the data/unused entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's unused, look for the space in the bestfree table.\n\t\t * If we find it, account for that, else make sure it\n\t\t * doesn't need to be there.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tXFS_WANT_CORRUPTED_RETURN(lastfree == 0);\n\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tbe16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)) ==\n\t\t\t\t\t       (char *)dup - (char *)hdr);\n\t\t\tdfp = xfs_dir2_data_freefind(hdr, bf, dup);\n\t\t\tif (dfp) {\n\t\t\t\ti = (int)(dfp - bf);\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\t(freeseen & (1 << i)) == 0);\n\t\t\t\tfreeseen |= 1 << i;\n\t\t\t} else {\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe16_to_cpu(dup->length) <=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t\t\t}\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t\tlastfree = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * It's a real entry.  Validate the fields.\n\t\t * If this is a block directory then make sure it's\n\t\t * in the leaf section of the block.\n\t\t * The linear search is crude but this is DEBUG code.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\tXFS_WANT_CORRUPTED_RETURN(dep->namelen != 0);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t!xfs_dir_ino_validate(mp, be64_to_cpu(dep->inumber)));\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\tbe16_to_cpu(*ops->data_entry_tag_p(dep)) ==\n\t\t\t\t\t       (char *)dep - (char *)hdr);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tops->data_get_ftype(dep) < XFS_DIR3_FT_MAX);\n\t\tcount++;\n\t\tlastfree = 0;\n\t\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\t\taddr = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,\n\t\t\t\t\t\t(xfs_dir2_data_aoff_t)\n\t\t\t\t\t\t((char *)dep - (char *)hdr));\n\t\t\tname.name = dep->name;\n\t\t\tname.len = dep->namelen;\n\t\t\thash = mp->m_dirnameops->hashname(&name);\n\t\t\tfor (i = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\t\tif (be32_to_cpu(lep[i].address) == addr &&\n\t\t\t\t    be32_to_cpu(lep[i].hashval) == hash)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i < be32_to_cpu(btp->count));\n\t\t}\n\t\tp += ops->data_entsize(dep->namelen);\n\t}\n\t/*\n\t * Need to have seen all the entries and all the bestfree slots.\n\t */\n\tXFS_WANT_CORRUPTED_RETURN(freeseen == 7);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tfor (i = stale = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\tif (lep[i].address ==\n\t\t\t    cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\t\tstale++;\n\t\t\tif (i > 0)\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe32_to_cpu(lep[i].hashval) >=\n\t\t\t\t\t\tbe32_to_cpu(lep[i - 1].hashval));\n\t\t}\n\t\tXFS_WANT_CORRUPTED_RETURN(count ==\n\t\t\tbe32_to_cpu(btp->count) - be32_to_cpu(btp->stale));\n\t\tXFS_WANT_CORRUPTED_RETURN(stale == be32_to_cpu(btp->stale));\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_BLOCK_MAGIC"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "hdr3->blkno"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uuid_equal",
          "args": [
            "&hdr3->uuid",
            "&mp->m_sb.sb_uuid"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR3_BLOCK_MAGIC"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);\n\nstatic bool\nxfs_dir3_block_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_dir3_blk_hdr\t*hdr3 = bp->b_addr;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tif (hdr3->magic != cpu_to_be32(XFS_DIR3_BLOCK_MAGIC))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&hdr3->uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (be64_to_cpu(hdr3->blkno) != bp->b_bn)\n\t\t\treturn false;\n\t} else {\n\t\tif (hdr3->magic != cpu_to_be32(XFS_DIR2_BLOCK_MAGIC))\n\t\t\treturn false;\n\t}\n\tif (__xfs_dir3_data_check(NULL, bp))\n\t\treturn false;\n\treturn true;\n}"
  },
  {
    "function_name": "xfs_dir_startup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
    "lines": "53-58",
    "snippet": "void\nxfs_dir_startup(void)\n{\n\txfs_dir_hash_dot = xfs_da_hashname((unsigned char *)\".\", 1);\n\txfs_dir_hash_dotdot = xfs_da_hashname((unsigned char *)\"..\", 2);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static xfs_dahash_t xfs_dir_hash_dot, xfs_dir_hash_dotdot;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_da_hashname",
          "args": [
            "(unsigned char *)\"..\"",
            "2"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_hashname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "1944-1970",
          "snippet": "xfs_dahash_t\nxfs_da_hashname(const __uint8_t *name, int namelen)\n{\n\txfs_dahash_t hash;\n\n\t/*\n\t * Do four characters at a time as long as we can.\n\t */\n\tfor (hash = 0; namelen >= 4; namelen -= 4, name += 4)\n\t\thash = (name[0] << 21) ^ (name[1] << 14) ^ (name[2] << 7) ^\n\t\t       (name[3] << 0) ^ rol32(hash, 7 * 4);\n\n\t/*\n\t * Now do the rest of the characters.\n\t */\n\tswitch (namelen) {\n\tcase 3:\n\t\treturn (name[0] << 14) ^ (name[1] << 7) ^ (name[2] << 0) ^\n\t\t       rol32(hash, 7 * 3);\n\tcase 2:\n\t\treturn (name[0] << 7) ^ (name[1] << 0) ^ rol32(hash, 7 * 2);\n\tcase 1:\n\t\treturn (name[0] << 0) ^ rol32(hash, 7 * 1);\n\tdefault: /* case 0: */\n\t\treturn hash;\n\t}\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_dahash_t\nxfs_da_hashname(const __uint8_t *name, int namelen)\n{\n\txfs_dahash_t hash;\n\n\t/*\n\t * Do four characters at a time as long as we can.\n\t */\n\tfor (hash = 0; namelen >= 4; namelen -= 4, name += 4)\n\t\thash = (name[0] << 21) ^ (name[1] << 14) ^ (name[2] << 7) ^\n\t\t       (name[3] << 0) ^ rol32(hash, 7 * 4);\n\n\t/*\n\t * Now do the rest of the characters.\n\t */\n\tswitch (namelen) {\n\tcase 3:\n\t\treturn (name[0] << 14) ^ (name[1] << 7) ^ (name[2] << 0) ^\n\t\t       rol32(hash, 7 * 3);\n\tcase 2:\n\t\treturn (name[0] << 7) ^ (name[1] << 0) ^ rol32(hash, 7 * 2);\n\tcase 1:\n\t\treturn (name[0] << 0) ^ rol32(hash, 7 * 1);\n\tdefault: /* case 0: */\n\t\treturn hash;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic xfs_dahash_t xfs_dir_hash_dot, xfs_dir_hash_dotdot;\n\nvoid\nxfs_dir_startup(void)\n{\n\txfs_dir_hash_dot = xfs_da_hashname((unsigned char *)\".\", 1);\n\txfs_dir_hash_dotdot = xfs_da_hashname((unsigned char *)\"..\", 2);\n}"
  }
]