[
  {
    "function_name": "ntfs_cluster_free_from_rl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/lcnalloc.h",
    "lines": "132-141",
    "snippet": "static inline int ntfs_cluster_free_from_rl(ntfs_volume *vol,\n\t\tconst runlist_element *rl)\n{\n\tint ret;\n\n\tdown_write(&vol->lcnbmp_lock);\n\tret = ntfs_cluster_free_from_rl_nolock(vol, rl);\n\tup_write(&vol->lcnbmp_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"volume.h\"",
      "#include \"runlist.h\"",
      "#include \"inode.h\"",
      "#include \"types.h\"",
      "#include \"attrib.h\"",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&vol->lcnbmp_lock"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_cluster_free_from_rl_nolock",
          "args": [
            "vol",
            "rl"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_cluster_free_from_rl_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/lcnalloc.c",
          "lines": "50-70",
          "snippet": "int ntfs_cluster_free_from_rl_nolock(ntfs_volume *vol,\n\t\tconst runlist_element *rl)\n{\n\tstruct inode *lcnbmp_vi = vol->lcnbmp_ino;\n\tint ret = 0;\n\n\tntfs_debug(\"Entering.\");\n\tif (!rl)\n\t\treturn 0;\n\tfor (; rl->length; rl++) {\n\t\tint err;\n\n\t\tif (rl->lcn < 0)\n\t\t\tcontinue;\n\t\terr = ntfs_bitmap_clear_run(lcnbmp_vi, rl->lcn, rl->length);\n\t\tif (unlikely(err && (!ret || ret == -ENOMEM) && ret != err))\n\t\t\tret = err;\n\t}\n\tntfs_debug(\"Done.\");\n\treturn ret;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"aops.h\"",
            "#include \"malloc.h\"",
            "#include \"attrib.h\"",
            "#include \"volume.h\"",
            "#include \"inode.h\"",
            "#include \"bitmap.h\"",
            "#include \"debug.h\"",
            "#include \"lcnalloc.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"aops.h\"\n#include \"malloc.h\"\n#include \"attrib.h\"\n#include \"volume.h\"\n#include \"inode.h\"\n#include \"bitmap.h\"\n#include \"debug.h\"\n#include \"lcnalloc.h\"\n#include <linux/pagemap.h>\n\nint ntfs_cluster_free_from_rl_nolock(ntfs_volume *vol,\n\t\tconst runlist_element *rl)\n{\n\tstruct inode *lcnbmp_vi = vol->lcnbmp_ino;\n\tint ret = 0;\n\n\tntfs_debug(\"Entering.\");\n\tif (!rl)\n\t\treturn 0;\n\tfor (; rl->length; rl++) {\n\t\tint err;\n\n\t\tif (rl->lcn < 0)\n\t\t\tcontinue;\n\t\terr = ntfs_bitmap_clear_run(lcnbmp_vi, rl->lcn, rl->length);\n\t\tif (unlikely(err && (!ret || ret == -ENOMEM) && ret != err))\n\t\t\tret = err;\n\t}\n\tntfs_debug(\"Done.\");\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&vol->lcnbmp_lock"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"volume.h\"\n#include \"runlist.h\"\n#include \"inode.h\"\n#include \"types.h\"\n#include \"attrib.h\"\n#include <linux/fs.h>\n\nstatic inline int ntfs_cluster_free_from_rl(ntfs_volume *vol,\n\t\tconst runlist_element *rl)\n{\n\tint ret;\n\n\tdown_write(&vol->lcnbmp_lock);\n\tret = ntfs_cluster_free_from_rl_nolock(vol, rl);\n\tup_write(&vol->lcnbmp_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "ntfs_cluster_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/lcnalloc.h",
    "lines": "107-111",
    "snippet": "static inline s64 ntfs_cluster_free(ntfs_inode *ni, const VCN start_vcn,\n\t\ts64 count, ntfs_attr_search_ctx *ctx)\n{\n\treturn __ntfs_cluster_free(ni, start_vcn, count, ctx, false);\n}",
    "includes": [
      "#include \"volume.h\"",
      "#include \"runlist.h\"",
      "#include \"inode.h\"",
      "#include \"types.h\"",
      "#include \"attrib.h\"",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ntfs_cluster_free",
          "args": [
            "ni",
            "start_vcn",
            "count",
            "ctx",
            "false"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_cluster_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/lcnalloc.c",
          "lines": "849-1012",
          "snippet": "s64 __ntfs_cluster_free(ntfs_inode *ni, const VCN start_vcn, s64 count,\n\t\tntfs_attr_search_ctx *ctx, const bool is_rollback)\n{\n\ts64 delta, to_free, total_freed, real_freed;\n\tntfs_volume *vol;\n\tstruct inode *lcnbmp_vi;\n\trunlist_element *rl;\n\tint err;\n\n\tBUG_ON(!ni);\n\tntfs_debug(\"Entering for i_ino 0x%lx, start_vcn 0x%llx, count \"\n\t\t\t\"0x%llx.%s\", ni->mft_no, (unsigned long long)start_vcn,\n\t\t\t(unsigned long long)count,\n\t\t\tis_rollback ? \" (rollback)\" : \"\");\n\tvol = ni->vol;\n\tlcnbmp_vi = vol->lcnbmp_ino;\n\tBUG_ON(!lcnbmp_vi);\n\tBUG_ON(start_vcn < 0);\n\tBUG_ON(count < -1);\n\t/*\n\t * Lock the lcn bitmap for writing but only if not rolling back.  We\n\t * must hold the lock all the way including through rollback otherwise\n\t * rollback is not possible because once we have cleared a bit and\n\t * dropped the lock, anyone could have set the bit again, thus\n\t * allocating the cluster for another use.\n\t */\n\tif (likely(!is_rollback))\n\t\tdown_write(&vol->lcnbmp_lock);\n\n\ttotal_freed = real_freed = 0;\n\n\trl = ntfs_attr_find_vcn_nolock(ni, start_vcn, ctx);\n\tif (IS_ERR(rl)) {\n\t\tif (!is_rollback)\n\t\t\tntfs_error(vol->sb, \"Failed to find first runlist \"\n\t\t\t\t\t\"element (error %li), aborting.\",\n\t\t\t\t\tPTR_ERR(rl));\n\t\terr = PTR_ERR(rl);\n\t\tgoto err_out;\n\t}\n\tif (unlikely(rl->lcn < LCN_HOLE)) {\n\t\tif (!is_rollback)\n\t\t\tntfs_error(vol->sb, \"First runlist element has \"\n\t\t\t\t\t\"invalid lcn, aborting.\");\n\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\t/* Find the starting cluster inside the run that needs freeing. */\n\tdelta = start_vcn - rl->vcn;\n\n\t/* The number of clusters in this run that need freeing. */\n\tto_free = rl->length - delta;\n\tif (count >= 0 && to_free > count)\n\t\tto_free = count;\n\n\tif (likely(rl->lcn >= 0)) {\n\t\t/* Do the actual freeing of the clusters in this run. */\n\t\terr = ntfs_bitmap_set_bits_in_run(lcnbmp_vi, rl->lcn + delta,\n\t\t\t\tto_free, likely(!is_rollback) ? 0 : 1);\n\t\tif (unlikely(err)) {\n\t\t\tif (!is_rollback)\n\t\t\t\tntfs_error(vol->sb, \"Failed to clear first run \"\n\t\t\t\t\t\t\"(error %i), aborting.\", err);\n\t\t\tgoto err_out;\n\t\t}\n\t\t/* We have freed @to_free real clusters. */\n\t\treal_freed = to_free;\n\t};\n\t/* Go to the next run and adjust the number of clusters left to free. */\n\t++rl;\n\tif (count >= 0)\n\t\tcount -= to_free;\n\n\t/* Keep track of the total \"freed\" clusters, including sparse ones. */\n\ttotal_freed = to_free;\n\t/*\n\t * Loop over the remaining runs, using @count as a capping value, and\n\t * free them.\n\t */\n\tfor (; rl->length && count != 0; ++rl) {\n\t\tif (unlikely(rl->lcn < LCN_HOLE)) {\n\t\t\tVCN vcn;\n\n\t\t\t/* Attempt to map runlist. */\n\t\t\tvcn = rl->vcn;\n\t\t\trl = ntfs_attr_find_vcn_nolock(ni, vcn, ctx);\n\t\t\tif (IS_ERR(rl)) {\n\t\t\t\terr = PTR_ERR(rl);\n\t\t\t\tif (!is_rollback)\n\t\t\t\t\tntfs_error(vol->sb, \"Failed to map \"\n\t\t\t\t\t\t\t\"runlist fragment or \"\n\t\t\t\t\t\t\t\"failed to find \"\n\t\t\t\t\t\t\t\"subsequent runlist \"\n\t\t\t\t\t\t\t\"element.\");\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\tif (unlikely(rl->lcn < LCN_HOLE)) {\n\t\t\t\tif (!is_rollback)\n\t\t\t\t\tntfs_error(vol->sb, \"Runlist element \"\n\t\t\t\t\t\t\t\"has invalid lcn \"\n\t\t\t\t\t\t\t\"(0x%llx).\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\trl->lcn);\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t}\n\t\t/* The number of clusters in this run that need freeing. */\n\t\tto_free = rl->length;\n\t\tif (count >= 0 && to_free > count)\n\t\t\tto_free = count;\n\n\t\tif (likely(rl->lcn >= 0)) {\n\t\t\t/* Do the actual freeing of the clusters in the run. */\n\t\t\terr = ntfs_bitmap_set_bits_in_run(lcnbmp_vi, rl->lcn,\n\t\t\t\t\tto_free, likely(!is_rollback) ? 0 : 1);\n\t\t\tif (unlikely(err)) {\n\t\t\t\tif (!is_rollback)\n\t\t\t\t\tntfs_error(vol->sb, \"Failed to clear \"\n\t\t\t\t\t\t\t\"subsequent run.\");\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\t/* We have freed @to_free real clusters. */\n\t\t\treal_freed += to_free;\n\t\t}\n\t\t/* Adjust the number of clusters left to free. */\n\t\tif (count >= 0)\n\t\t\tcount -= to_free;\n\t\n\t\t/* Update the total done clusters. */\n\t\ttotal_freed += to_free;\n\t}\n\tif (likely(!is_rollback))\n\t\tup_write(&vol->lcnbmp_lock);\n\n\tBUG_ON(count > 0);\n\n\t/* We are done.  Return the number of actually freed clusters. */\n\tntfs_debug(\"Done.\");\n\treturn real_freed;\nerr_out:\n\tif (is_rollback)\n\t\treturn err;\n\t/* If no real clusters were freed, no need to rollback. */\n\tif (!real_freed) {\n\t\tup_write(&vol->lcnbmp_lock);\n\t\treturn err;\n\t}\n\t/*\n\t * Attempt to rollback and if that succeeds just return the error code.\n\t * If rollback fails, set the volume errors flag, emit an error\n\t * message, and return the error code.\n\t */\n\tdelta = __ntfs_cluster_free(ni, start_vcn, total_freed, ctx, true);\n\tif (delta < 0) {\n\t\tntfs_error(vol->sb, \"Failed to rollback (error %i).  Leaving \"\n\t\t\t\t\"inconsistent metadata!  Unmount and run \"\n\t\t\t\t\"chkdsk.\", (int)delta);\n\t\tNVolSetErrors(vol);\n\t}\n\tup_write(&vol->lcnbmp_lock);\n\tntfs_error(vol->sb, \"Aborting (error %i).\", err);\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"aops.h\"",
            "#include \"malloc.h\"",
            "#include \"attrib.h\"",
            "#include \"volume.h\"",
            "#include \"inode.h\"",
            "#include \"bitmap.h\"",
            "#include \"debug.h\"",
            "#include \"lcnalloc.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"aops.h\"\n#include \"malloc.h\"\n#include \"attrib.h\"\n#include \"volume.h\"\n#include \"inode.h\"\n#include \"bitmap.h\"\n#include \"debug.h\"\n#include \"lcnalloc.h\"\n#include <linux/pagemap.h>\n\ns64 __ntfs_cluster_free(ntfs_inode *ni, const VCN start_vcn, s64 count,\n\t\tntfs_attr_search_ctx *ctx, const bool is_rollback)\n{\n\ts64 delta, to_free, total_freed, real_freed;\n\tntfs_volume *vol;\n\tstruct inode *lcnbmp_vi;\n\trunlist_element *rl;\n\tint err;\n\n\tBUG_ON(!ni);\n\tntfs_debug(\"Entering for i_ino 0x%lx, start_vcn 0x%llx, count \"\n\t\t\t\"0x%llx.%s\", ni->mft_no, (unsigned long long)start_vcn,\n\t\t\t(unsigned long long)count,\n\t\t\tis_rollback ? \" (rollback)\" : \"\");\n\tvol = ni->vol;\n\tlcnbmp_vi = vol->lcnbmp_ino;\n\tBUG_ON(!lcnbmp_vi);\n\tBUG_ON(start_vcn < 0);\n\tBUG_ON(count < -1);\n\t/*\n\t * Lock the lcn bitmap for writing but only if not rolling back.  We\n\t * must hold the lock all the way including through rollback otherwise\n\t * rollback is not possible because once we have cleared a bit and\n\t * dropped the lock, anyone could have set the bit again, thus\n\t * allocating the cluster for another use.\n\t */\n\tif (likely(!is_rollback))\n\t\tdown_write(&vol->lcnbmp_lock);\n\n\ttotal_freed = real_freed = 0;\n\n\trl = ntfs_attr_find_vcn_nolock(ni, start_vcn, ctx);\n\tif (IS_ERR(rl)) {\n\t\tif (!is_rollback)\n\t\t\tntfs_error(vol->sb, \"Failed to find first runlist \"\n\t\t\t\t\t\"element (error %li), aborting.\",\n\t\t\t\t\tPTR_ERR(rl));\n\t\terr = PTR_ERR(rl);\n\t\tgoto err_out;\n\t}\n\tif (unlikely(rl->lcn < LCN_HOLE)) {\n\t\tif (!is_rollback)\n\t\t\tntfs_error(vol->sb, \"First runlist element has \"\n\t\t\t\t\t\"invalid lcn, aborting.\");\n\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\t/* Find the starting cluster inside the run that needs freeing. */\n\tdelta = start_vcn - rl->vcn;\n\n\t/* The number of clusters in this run that need freeing. */\n\tto_free = rl->length - delta;\n\tif (count >= 0 && to_free > count)\n\t\tto_free = count;\n\n\tif (likely(rl->lcn >= 0)) {\n\t\t/* Do the actual freeing of the clusters in this run. */\n\t\terr = ntfs_bitmap_set_bits_in_run(lcnbmp_vi, rl->lcn + delta,\n\t\t\t\tto_free, likely(!is_rollback) ? 0 : 1);\n\t\tif (unlikely(err)) {\n\t\t\tif (!is_rollback)\n\t\t\t\tntfs_error(vol->sb, \"Failed to clear first run \"\n\t\t\t\t\t\t\"(error %i), aborting.\", err);\n\t\t\tgoto err_out;\n\t\t}\n\t\t/* We have freed @to_free real clusters. */\n\t\treal_freed = to_free;\n\t};\n\t/* Go to the next run and adjust the number of clusters left to free. */\n\t++rl;\n\tif (count >= 0)\n\t\tcount -= to_free;\n\n\t/* Keep track of the total \"freed\" clusters, including sparse ones. */\n\ttotal_freed = to_free;\n\t/*\n\t * Loop over the remaining runs, using @count as a capping value, and\n\t * free them.\n\t */\n\tfor (; rl->length && count != 0; ++rl) {\n\t\tif (unlikely(rl->lcn < LCN_HOLE)) {\n\t\t\tVCN vcn;\n\n\t\t\t/* Attempt to map runlist. */\n\t\t\tvcn = rl->vcn;\n\t\t\trl = ntfs_attr_find_vcn_nolock(ni, vcn, ctx);\n\t\t\tif (IS_ERR(rl)) {\n\t\t\t\terr = PTR_ERR(rl);\n\t\t\t\tif (!is_rollback)\n\t\t\t\t\tntfs_error(vol->sb, \"Failed to map \"\n\t\t\t\t\t\t\t\"runlist fragment or \"\n\t\t\t\t\t\t\t\"failed to find \"\n\t\t\t\t\t\t\t\"subsequent runlist \"\n\t\t\t\t\t\t\t\"element.\");\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\tif (unlikely(rl->lcn < LCN_HOLE)) {\n\t\t\t\tif (!is_rollback)\n\t\t\t\t\tntfs_error(vol->sb, \"Runlist element \"\n\t\t\t\t\t\t\t\"has invalid lcn \"\n\t\t\t\t\t\t\t\"(0x%llx).\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\trl->lcn);\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t}\n\t\t/* The number of clusters in this run that need freeing. */\n\t\tto_free = rl->length;\n\t\tif (count >= 0 && to_free > count)\n\t\t\tto_free = count;\n\n\t\tif (likely(rl->lcn >= 0)) {\n\t\t\t/* Do the actual freeing of the clusters in the run. */\n\t\t\terr = ntfs_bitmap_set_bits_in_run(lcnbmp_vi, rl->lcn,\n\t\t\t\t\tto_free, likely(!is_rollback) ? 0 : 1);\n\t\t\tif (unlikely(err)) {\n\t\t\t\tif (!is_rollback)\n\t\t\t\t\tntfs_error(vol->sb, \"Failed to clear \"\n\t\t\t\t\t\t\t\"subsequent run.\");\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\t/* We have freed @to_free real clusters. */\n\t\t\treal_freed += to_free;\n\t\t}\n\t\t/* Adjust the number of clusters left to free. */\n\t\tif (count >= 0)\n\t\t\tcount -= to_free;\n\t\n\t\t/* Update the total done clusters. */\n\t\ttotal_freed += to_free;\n\t}\n\tif (likely(!is_rollback))\n\t\tup_write(&vol->lcnbmp_lock);\n\n\tBUG_ON(count > 0);\n\n\t/* We are done.  Return the number of actually freed clusters. */\n\tntfs_debug(\"Done.\");\n\treturn real_freed;\nerr_out:\n\tif (is_rollback)\n\t\treturn err;\n\t/* If no real clusters were freed, no need to rollback. */\n\tif (!real_freed) {\n\t\tup_write(&vol->lcnbmp_lock);\n\t\treturn err;\n\t}\n\t/*\n\t * Attempt to rollback and if that succeeds just return the error code.\n\t * If rollback fails, set the volume errors flag, emit an error\n\t * message, and return the error code.\n\t */\n\tdelta = __ntfs_cluster_free(ni, start_vcn, total_freed, ctx, true);\n\tif (delta < 0) {\n\t\tntfs_error(vol->sb, \"Failed to rollback (error %i).  Leaving \"\n\t\t\t\t\"inconsistent metadata!  Unmount and run \"\n\t\t\t\t\"chkdsk.\", (int)delta);\n\t\tNVolSetErrors(vol);\n\t}\n\tup_write(&vol->lcnbmp_lock);\n\tntfs_error(vol->sb, \"Aborting (error %i).\", err);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"volume.h\"\n#include \"runlist.h\"\n#include \"inode.h\"\n#include \"types.h\"\n#include \"attrib.h\"\n#include <linux/fs.h>\n\nstatic inline s64 ntfs_cluster_free(ntfs_inode *ni, const VCN start_vcn,\n\t\ts64 count, ntfs_attr_search_ctx *ctx)\n{\n\treturn __ntfs_cluster_free(ni, start_vcn, count, ctx, false);\n}"
  }
]