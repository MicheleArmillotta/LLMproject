[
  {
    "function_name": "udf_tag_checksum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
    "lines": "290-299",
    "snippet": "u8 udf_tag_checksum(const struct tag *t)\n{\n\tu8 *data = (u8 *)t;\n\tu8 checksum = 0;\n\tint i;\n\tfor (i = 0; i < sizeof(struct tag); ++i)\n\t\tif (i != 4) /* position of checksum */\n\t\t\tchecksum += data[i];\n\treturn checksum;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nu8 udf_tag_checksum(const struct tag *t)\n{\n\tu8 *data = (u8 *)t;\n\tu8 checksum = 0;\n\tint i;\n\tfor (i = 0; i < sizeof(struct tag); ++i)\n\t\tif (i != 4) /* position of checksum */\n\t\t\tchecksum += data[i];\n\treturn checksum;\n}"
  },
  {
    "function_name": "udf_new_tag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
    "lines": "279-288",
    "snippet": "void udf_new_tag(char *data, uint16_t ident, uint16_t version, uint16_t snum,\n\t\t uint32_t loc, int length)\n{\n\tstruct tag *tptr = (struct tag *)data;\n\ttptr->tagIdent = cpu_to_le16(ident);\n\ttptr->descVersion = cpu_to_le16(version);\n\ttptr->tagSerialNum = cpu_to_le16(snum);\n\ttptr->tagLocation = cpu_to_le32(loc);\n\tudf_update_tag(data, length);\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "udf_update_tag",
          "args": [
            "data",
            "length"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "udf_update_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "269-277",
          "snippet": "void udf_update_tag(char *data, int length)\n{\n\tstruct tag *tptr = (struct tag *)data;\n\tlength -= sizeof(struct tag);\n\n\ttptr->descCRCLength = cpu_to_le16(length);\n\ttptr->descCRC = cpu_to_le16(crc_itu_t(0, data + sizeof(struct tag), length));\n\ttptr->tagChecksum = udf_tag_checksum(tptr);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nvoid udf_update_tag(char *data, int length)\n{\n\tstruct tag *tptr = (struct tag *)data;\n\tlength -= sizeof(struct tag);\n\n\ttptr->descCRCLength = cpu_to_le16(length);\n\ttptr->descCRC = cpu_to_le16(crc_itu_t(0, data + sizeof(struct tag), length));\n\ttptr->tagChecksum = udf_tag_checksum(tptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "loc"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "snum"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "version"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "ident"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nvoid udf_new_tag(char *data, uint16_t ident, uint16_t version, uint16_t snum,\n\t\t uint32_t loc, int length)\n{\n\tstruct tag *tptr = (struct tag *)data;\n\ttptr->tagIdent = cpu_to_le16(ident);\n\ttptr->descVersion = cpu_to_le16(version);\n\ttptr->tagSerialNum = cpu_to_le16(snum);\n\ttptr->tagLocation = cpu_to_le32(loc);\n\tudf_update_tag(data, length);\n}"
  },
  {
    "function_name": "udf_update_tag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
    "lines": "269-277",
    "snippet": "void udf_update_tag(char *data, int length)\n{\n\tstruct tag *tptr = (struct tag *)data;\n\tlength -= sizeof(struct tag);\n\n\ttptr->descCRCLength = cpu_to_le16(length);\n\ttptr->descCRC = cpu_to_le16(crc_itu_t(0, data + sizeof(struct tag), length));\n\ttptr->tagChecksum = udf_tag_checksum(tptr);\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "udf_tag_checksum",
          "args": [
            "tptr"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "udf_tag_checksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "290-299",
          "snippet": "u8 udf_tag_checksum(const struct tag *t)\n{\n\tu8 *data = (u8 *)t;\n\tu8 checksum = 0;\n\tint i;\n\tfor (i = 0; i < sizeof(struct tag); ++i)\n\t\tif (i != 4) /* position of checksum */\n\t\t\tchecksum += data[i];\n\treturn checksum;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nu8 udf_tag_checksum(const struct tag *t)\n{\n\tu8 *data = (u8 *)t;\n\tu8 checksum = 0;\n\tint i;\n\tfor (i = 0; i < sizeof(struct tag); ++i)\n\t\tif (i != 4) /* position of checksum */\n\t\t\tchecksum += data[i];\n\treturn checksum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "crc_itu_t(0, data + sizeof(struct tag), length)"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crc_itu_t",
          "args": [
            "0",
            "data + sizeof(struct tag)",
            "length"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "length"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nvoid udf_update_tag(char *data, int length)\n{\n\tstruct tag *tptr = (struct tag *)data;\n\tlength -= sizeof(struct tag);\n\n\ttptr->descCRCLength = cpu_to_le16(length);\n\ttptr->descCRC = cpu_to_le16(crc_itu_t(0, data + sizeof(struct tag), length));\n\ttptr->tagChecksum = udf_tag_checksum(tptr);\n}"
  },
  {
    "function_name": "udf_read_ptagged",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
    "lines": "261-267",
    "snippet": "struct buffer_head *udf_read_ptagged(struct super_block *sb,\n\t\t\t\t     struct kernel_lb_addr *loc,\n\t\t\t\t     uint32_t offset, uint16_t *ident)\n{\n\treturn udf_read_tagged(sb, udf_get_lb_pblock(sb, loc, offset),\n\t\t\t       loc->logicalBlockNum + offset, ident);\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "udf_read_tagged",
          "args": [
            "sb",
            "udf_get_lb_pblock(sb, loc, offset)",
            "loc->logicalBlockNum + offset",
            "ident"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "udf_read_tagged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "202-259",
          "snippet": "struct buffer_head *udf_read_tagged(struct super_block *sb, uint32_t block,\n\t\t\t\t    uint32_t location, uint16_t *ident)\n{\n\tstruct tag *tag_p;\n\tstruct buffer_head *bh = NULL;\n\tu8 checksum;\n\n\t/* Read the block */\n\tif (block == 0xFFFFFFFF)\n\t\treturn NULL;\n\n\tbh = udf_tread(sb, block);\n\tif (!bh) {\n\t\tudf_err(sb, \"read failed, block=%u, location=%d\\n\",\n\t\t\tblock, location);\n\t\treturn NULL;\n\t}\n\n\ttag_p = (struct tag *)(bh->b_data);\n\n\t*ident = le16_to_cpu(tag_p->tagIdent);\n\n\tif (location != le32_to_cpu(tag_p->tagLocation)) {\n\t\tudf_debug(\"location mismatch block %u, tag %u != %u\\n\",\n\t\t\t  block, le32_to_cpu(tag_p->tagLocation), location);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the tag checksum */\n\tchecksum = udf_tag_checksum(tag_p);\n\tif (checksum != tag_p->tagChecksum) {\n\t\tudf_err(sb, \"tag checksum failed, block %u: 0x%02x != 0x%02x\\n\",\n\t\t\tblock, checksum, tag_p->tagChecksum);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the tag version */\n\tif (tag_p->descVersion != cpu_to_le16(0x0002U) &&\n\t    tag_p->descVersion != cpu_to_le16(0x0003U)) {\n\t\tudf_err(sb, \"tag version 0x%04x != 0x0002 || 0x0003, block %u\\n\",\n\t\t\tle16_to_cpu(tag_p->descVersion), block);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the descriptor CRC */\n\tif (le16_to_cpu(tag_p->descCRCLength) + sizeof(struct tag) > sb->s_blocksize ||\n\t    le16_to_cpu(tag_p->descCRC) == crc_itu_t(0,\n\t\t\t\t\tbh->b_data + sizeof(struct tag),\n\t\t\t\t\tle16_to_cpu(tag_p->descCRCLength)))\n\t\treturn bh;\n\n\tudf_debug(\"Crc failure block %d: crc = %d, crclen = %d\\n\", block,\n\t\t  le16_to_cpu(tag_p->descCRC),\n\t\t  le16_to_cpu(tag_p->descCRCLength));\nerror_out:\n\tbrelse(bh);\n\treturn NULL;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstruct buffer_head *udf_read_tagged(struct super_block *sb, uint32_t block,\n\t\t\t\t    uint32_t location, uint16_t *ident)\n{\n\tstruct tag *tag_p;\n\tstruct buffer_head *bh = NULL;\n\tu8 checksum;\n\n\t/* Read the block */\n\tif (block == 0xFFFFFFFF)\n\t\treturn NULL;\n\n\tbh = udf_tread(sb, block);\n\tif (!bh) {\n\t\tudf_err(sb, \"read failed, block=%u, location=%d\\n\",\n\t\t\tblock, location);\n\t\treturn NULL;\n\t}\n\n\ttag_p = (struct tag *)(bh->b_data);\n\n\t*ident = le16_to_cpu(tag_p->tagIdent);\n\n\tif (location != le32_to_cpu(tag_p->tagLocation)) {\n\t\tudf_debug(\"location mismatch block %u, tag %u != %u\\n\",\n\t\t\t  block, le32_to_cpu(tag_p->tagLocation), location);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the tag checksum */\n\tchecksum = udf_tag_checksum(tag_p);\n\tif (checksum != tag_p->tagChecksum) {\n\t\tudf_err(sb, \"tag checksum failed, block %u: 0x%02x != 0x%02x\\n\",\n\t\t\tblock, checksum, tag_p->tagChecksum);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the tag version */\n\tif (tag_p->descVersion != cpu_to_le16(0x0002U) &&\n\t    tag_p->descVersion != cpu_to_le16(0x0003U)) {\n\t\tudf_err(sb, \"tag version 0x%04x != 0x0002 || 0x0003, block %u\\n\",\n\t\t\tle16_to_cpu(tag_p->descVersion), block);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the descriptor CRC */\n\tif (le16_to_cpu(tag_p->descCRCLength) + sizeof(struct tag) > sb->s_blocksize ||\n\t    le16_to_cpu(tag_p->descCRC) == crc_itu_t(0,\n\t\t\t\t\tbh->b_data + sizeof(struct tag),\n\t\t\t\t\tle16_to_cpu(tag_p->descCRCLength)))\n\t\treturn bh;\n\n\tudf_debug(\"Crc failure block %d: crc = %d, crclen = %d\\n\", block,\n\t\t  le16_to_cpu(tag_p->descCRC),\n\t\t  le16_to_cpu(tag_p->descCRCLength));\nerror_out:\n\tbrelse(bh);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_get_lb_pblock",
          "args": [
            "sb",
            "loc",
            "offset"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "udf_get_lb_pblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "205-211",
          "snippet": "static inline uint32_t\nudf_get_lb_pblock(struct super_block *sb, struct kernel_lb_addr *loc,\n\t\t  uint32_t offset)\n{\n\treturn udf_get_pblock(sb, loc->logicalBlockNum,\n\t\t\tloc->partitionReferenceNum, offset);\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline uint32_t\nudf_get_lb_pblock(struct super_block *sb, struct kernel_lb_addr *loc,\n\t\t  uint32_t offset)\n{\n\treturn udf_get_pblock(sb, loc->logicalBlockNum,\n\t\t\tloc->partitionReferenceNum, offset);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstruct buffer_head *udf_read_ptagged(struct super_block *sb,\n\t\t\t\t     struct kernel_lb_addr *loc,\n\t\t\t\t     uint32_t offset, uint16_t *ident)\n{\n\treturn udf_read_tagged(sb, udf_get_lb_pblock(sb, loc, offset),\n\t\t\t       loc->logicalBlockNum + offset, ident);\n}"
  },
  {
    "function_name": "udf_read_tagged",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
    "lines": "202-259",
    "snippet": "struct buffer_head *udf_read_tagged(struct super_block *sb, uint32_t block,\n\t\t\t\t    uint32_t location, uint16_t *ident)\n{\n\tstruct tag *tag_p;\n\tstruct buffer_head *bh = NULL;\n\tu8 checksum;\n\n\t/* Read the block */\n\tif (block == 0xFFFFFFFF)\n\t\treturn NULL;\n\n\tbh = udf_tread(sb, block);\n\tif (!bh) {\n\t\tudf_err(sb, \"read failed, block=%u, location=%d\\n\",\n\t\t\tblock, location);\n\t\treturn NULL;\n\t}\n\n\ttag_p = (struct tag *)(bh->b_data);\n\n\t*ident = le16_to_cpu(tag_p->tagIdent);\n\n\tif (location != le32_to_cpu(tag_p->tagLocation)) {\n\t\tudf_debug(\"location mismatch block %u, tag %u != %u\\n\",\n\t\t\t  block, le32_to_cpu(tag_p->tagLocation), location);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the tag checksum */\n\tchecksum = udf_tag_checksum(tag_p);\n\tif (checksum != tag_p->tagChecksum) {\n\t\tudf_err(sb, \"tag checksum failed, block %u: 0x%02x != 0x%02x\\n\",\n\t\t\tblock, checksum, tag_p->tagChecksum);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the tag version */\n\tif (tag_p->descVersion != cpu_to_le16(0x0002U) &&\n\t    tag_p->descVersion != cpu_to_le16(0x0003U)) {\n\t\tudf_err(sb, \"tag version 0x%04x != 0x0002 || 0x0003, block %u\\n\",\n\t\t\tle16_to_cpu(tag_p->descVersion), block);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the descriptor CRC */\n\tif (le16_to_cpu(tag_p->descCRCLength) + sizeof(struct tag) > sb->s_blocksize ||\n\t    le16_to_cpu(tag_p->descCRC) == crc_itu_t(0,\n\t\t\t\t\tbh->b_data + sizeof(struct tag),\n\t\t\t\t\tle16_to_cpu(tag_p->descCRCLength)))\n\t\treturn bh;\n\n\tudf_debug(\"Crc failure block %d: crc = %d, crclen = %d\\n\", block,\n\t\t  le16_to_cpu(tag_p->descCRC),\n\t\t  le16_to_cpu(tag_p->descCRCLength));\nerror_out:\n\tbrelse(bh);\n\treturn NULL;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"Crc failure block %d: crc = %d, crclen = %d\\n\"",
            "block",
            "le16_to_cpu(tag_p->descCRC)",
            "le16_to_cpu(tag_p->descCRCLength)"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "tag_p->descCRCLength"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "crc_itu_t",
          "args": [
            "0",
            "bh->b_data + sizeof(struct tag)",
            "le16_to_cpu(tag_p->descCRCLength)"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_err",
          "args": [
            "sb",
            "\"tag version 0x%04x != 0x0002 || 0x0003, block %u\\n\"",
            "le16_to_cpu(tag_p->descVersion)",
            "block"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "_udf_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "2256-2270",
          "snippet": "void _udf_err(struct super_block *sb, const char *function,\n\t      const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"error (device %s): %s: %pV\", sb->s_id, function, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nvoid _udf_err(struct super_block *sb, const char *function,\n\t      const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"error (device %s): %s: %pV\", sb->s_id, function, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "0x0003U"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "0x0002U"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_tag_checksum",
          "args": [
            "tag_p"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "udf_tag_checksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "290-299",
          "snippet": "u8 udf_tag_checksum(const struct tag *t)\n{\n\tu8 *data = (u8 *)t;\n\tu8 checksum = 0;\n\tint i;\n\tfor (i = 0; i < sizeof(struct tag); ++i)\n\t\tif (i != 4) /* position of checksum */\n\t\t\tchecksum += data[i];\n\treturn checksum;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nu8 udf_tag_checksum(const struct tag *t)\n{\n\tu8 *data = (u8 *)t;\n\tu8 checksum = 0;\n\tint i;\n\tfor (i = 0; i < sizeof(struct tag); ++i)\n\t\tif (i != 4) /* position of checksum */\n\t\t\tchecksum += data[i];\n\treturn checksum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"location mismatch block %u, tag %u != %u\\n\"",
            "block",
            "le32_to_cpu(tag_p->tagLocation)",
            "location"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "tag_p->tagLocation"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_tread",
          "args": [
            "sb",
            "block"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "udf_tread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "40-46",
          "snippet": "struct buffer_head *udf_tread(struct super_block *sb, int block)\n{\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_VARCONV))\n\t\treturn sb_bread(sb, udf_fixed_to_variable(block));\n\telse\n\t\treturn sb_bread(sb, block);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstruct buffer_head *udf_tread(struct super_block *sb, int block)\n{\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_VARCONV))\n\t\treturn sb_bread(sb, udf_fixed_to_variable(block));\n\telse\n\t\treturn sb_bread(sb, block);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstruct buffer_head *udf_read_tagged(struct super_block *sb, uint32_t block,\n\t\t\t\t    uint32_t location, uint16_t *ident)\n{\n\tstruct tag *tag_p;\n\tstruct buffer_head *bh = NULL;\n\tu8 checksum;\n\n\t/* Read the block */\n\tif (block == 0xFFFFFFFF)\n\t\treturn NULL;\n\n\tbh = udf_tread(sb, block);\n\tif (!bh) {\n\t\tudf_err(sb, \"read failed, block=%u, location=%d\\n\",\n\t\t\tblock, location);\n\t\treturn NULL;\n\t}\n\n\ttag_p = (struct tag *)(bh->b_data);\n\n\t*ident = le16_to_cpu(tag_p->tagIdent);\n\n\tif (location != le32_to_cpu(tag_p->tagLocation)) {\n\t\tudf_debug(\"location mismatch block %u, tag %u != %u\\n\",\n\t\t\t  block, le32_to_cpu(tag_p->tagLocation), location);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the tag checksum */\n\tchecksum = udf_tag_checksum(tag_p);\n\tif (checksum != tag_p->tagChecksum) {\n\t\tudf_err(sb, \"tag checksum failed, block %u: 0x%02x != 0x%02x\\n\",\n\t\t\tblock, checksum, tag_p->tagChecksum);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the tag version */\n\tif (tag_p->descVersion != cpu_to_le16(0x0002U) &&\n\t    tag_p->descVersion != cpu_to_le16(0x0003U)) {\n\t\tudf_err(sb, \"tag version 0x%04x != 0x0002 || 0x0003, block %u\\n\",\n\t\t\tle16_to_cpu(tag_p->descVersion), block);\n\t\tgoto error_out;\n\t}\n\n\t/* Verify the descriptor CRC */\n\tif (le16_to_cpu(tag_p->descCRCLength) + sizeof(struct tag) > sb->s_blocksize ||\n\t    le16_to_cpu(tag_p->descCRC) == crc_itu_t(0,\n\t\t\t\t\tbh->b_data + sizeof(struct tag),\n\t\t\t\t\tle16_to_cpu(tag_p->descCRCLength)))\n\t\treturn bh;\n\n\tudf_debug(\"Crc failure block %d: crc = %d, crclen = %d\\n\", block,\n\t\t  le16_to_cpu(tag_p->descCRC),\n\t\t  le16_to_cpu(tag_p->descCRCLength));\nerror_out:\n\tbrelse(bh);\n\treturn NULL;\n}"
  },
  {
    "function_name": "udf_get_extendedattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
    "lines": "151-190",
    "snippet": "struct genericFormat *udf_get_extendedattr(struct inode *inode, uint32_t type,\n\t\t\t\t\t   uint8_t subtype)\n{\n\tstruct genericFormat *gaf;\n\tuint8_t *ea = NULL;\n\tuint32_t offset;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tea = iinfo->i_ext.i_data;\n\n\tif (iinfo->i_lenEAttr) {\n\t\tstruct extendedAttrHeaderDesc *eahd;\n\t\teahd = (struct extendedAttrHeaderDesc *)ea;\n\n\t\t/* check checksum/crc */\n\t\tif (eahd->descTag.tagIdent !=\n\t\t\t\tcpu_to_le16(TAG_IDENT_EAHD) ||\n\t\t    le32_to_cpu(eahd->descTag.tagLocation) !=\n\t\t\t\tiinfo->i_location.logicalBlockNum)\n\t\t\treturn NULL;\n\n\t\tif (type < 2048)\n\t\t\toffset = sizeof(struct extendedAttrHeaderDesc);\n\t\telse if (type < 65536)\n\t\t\toffset = le32_to_cpu(eahd->impAttrLocation);\n\t\telse\n\t\t\toffset = le32_to_cpu(eahd->appAttrLocation);\n\n\t\twhile (offset < iinfo->i_lenEAttr) {\n\t\t\tgaf = (struct genericFormat *)&ea[offset];\n\t\t\tif (le32_to_cpu(gaf->attrType) == type &&\n\t\t\t\t\tgaf->attrSubtype == subtype)\n\t\t\t\treturn gaf;\n\t\t\telse\n\t\t\t\toffset += le32_to_cpu(gaf->attrLength);\n\t\t}\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "gaf->attrLength"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "TAG_IDENT_EAHD"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "inode"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstruct genericFormat *udf_get_extendedattr(struct inode *inode, uint32_t type,\n\t\t\t\t\t   uint8_t subtype)\n{\n\tstruct genericFormat *gaf;\n\tuint8_t *ea = NULL;\n\tuint32_t offset;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tea = iinfo->i_ext.i_data;\n\n\tif (iinfo->i_lenEAttr) {\n\t\tstruct extendedAttrHeaderDesc *eahd;\n\t\teahd = (struct extendedAttrHeaderDesc *)ea;\n\n\t\t/* check checksum/crc */\n\t\tif (eahd->descTag.tagIdent !=\n\t\t\t\tcpu_to_le16(TAG_IDENT_EAHD) ||\n\t\t    le32_to_cpu(eahd->descTag.tagLocation) !=\n\t\t\t\tiinfo->i_location.logicalBlockNum)\n\t\t\treturn NULL;\n\n\t\tif (type < 2048)\n\t\t\toffset = sizeof(struct extendedAttrHeaderDesc);\n\t\telse if (type < 65536)\n\t\t\toffset = le32_to_cpu(eahd->impAttrLocation);\n\t\telse\n\t\t\toffset = le32_to_cpu(eahd->appAttrLocation);\n\n\t\twhile (offset < iinfo->i_lenEAttr) {\n\t\t\tgaf = (struct genericFormat *)&ea[offset];\n\t\t\tif (le32_to_cpu(gaf->attrType) == type &&\n\t\t\t\t\tgaf->attrSubtype == subtype)\n\t\t\t\treturn gaf;\n\t\t\telse\n\t\t\t\toffset += le32_to_cpu(gaf->attrLength);\n\t\t}\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "udf_add_extendedattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
    "lines": "48-149",
    "snippet": "struct genericFormat *udf_add_extendedattr(struct inode *inode, uint32_t size,\n\t\t\t\t\t   uint32_t type, uint8_t loc)\n{\n\tuint8_t *ea = NULL, *ad = NULL;\n\tint offset;\n\tuint16_t crclen;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tea = iinfo->i_ext.i_data;\n\tif (iinfo->i_lenEAttr) {\n\t\tad = iinfo->i_ext.i_data + iinfo->i_lenEAttr;\n\t} else {\n\t\tad = ea;\n\t\tsize += sizeof(struct extendedAttrHeaderDesc);\n\t}\n\n\toffset = inode->i_sb->s_blocksize - udf_file_entry_alloc_offset(inode) -\n\t\tiinfo->i_lenAlloc;\n\n\t/* TODO - Check for FreeEASpace */\n\n\tif (loc & 0x01 && offset >= size) {\n\t\tstruct extendedAttrHeaderDesc *eahd;\n\t\teahd = (struct extendedAttrHeaderDesc *)ea;\n\n\t\tif (iinfo->i_lenAlloc)\n\t\t\tmemmove(&ad[size], ad, iinfo->i_lenAlloc);\n\n\t\tif (iinfo->i_lenEAttr) {\n\t\t\t/* check checksum/crc */\n\t\t\tif (eahd->descTag.tagIdent !=\n\t\t\t\t\tcpu_to_le16(TAG_IDENT_EAHD) ||\n\t\t\t    le32_to_cpu(eahd->descTag.tagLocation) !=\n\t\t\t\t\tiinfo->i_location.logicalBlockNum)\n\t\t\t\treturn NULL;\n\t\t} else {\n\t\t\tstruct udf_sb_info *sbi = UDF_SB(inode->i_sb);\n\n\t\t\tsize -= sizeof(struct extendedAttrHeaderDesc);\n\t\t\tiinfo->i_lenEAttr +=\n\t\t\t\tsizeof(struct extendedAttrHeaderDesc);\n\t\t\teahd->descTag.tagIdent = cpu_to_le16(TAG_IDENT_EAHD);\n\t\t\tif (sbi->s_udfrev >= 0x0200)\n\t\t\t\teahd->descTag.descVersion = cpu_to_le16(3);\n\t\t\telse\n\t\t\t\teahd->descTag.descVersion = cpu_to_le16(2);\n\t\t\teahd->descTag.tagSerialNum =\n\t\t\t\t\tcpu_to_le16(sbi->s_serial_number);\n\t\t\teahd->descTag.tagLocation = cpu_to_le32(\n\t\t\t\t\tiinfo->i_location.logicalBlockNum);\n\t\t\teahd->impAttrLocation = cpu_to_le32(0xFFFFFFFF);\n\t\t\teahd->appAttrLocation = cpu_to_le32(0xFFFFFFFF);\n\t\t}\n\n\t\toffset = iinfo->i_lenEAttr;\n\t\tif (type < 2048) {\n\t\t\tif (le32_to_cpu(eahd->appAttrLocation) <\n\t\t\t\t\tiinfo->i_lenEAttr) {\n\t\t\t\tuint32_t aal =\n\t\t\t\t\tle32_to_cpu(eahd->appAttrLocation);\n\t\t\t\tmemmove(&ea[offset - aal + size],\n\t\t\t\t\t&ea[aal], offset - aal);\n\t\t\t\toffset -= aal;\n\t\t\t\teahd->appAttrLocation =\n\t\t\t\t\t\tcpu_to_le32(aal + size);\n\t\t\t}\n\t\t\tif (le32_to_cpu(eahd->impAttrLocation) <\n\t\t\t\t\tiinfo->i_lenEAttr) {\n\t\t\t\tuint32_t ial =\n\t\t\t\t\tle32_to_cpu(eahd->impAttrLocation);\n\t\t\t\tmemmove(&ea[offset - ial + size],\n\t\t\t\t\t&ea[ial], offset - ial);\n\t\t\t\toffset -= ial;\n\t\t\t\teahd->impAttrLocation =\n\t\t\t\t\t\tcpu_to_le32(ial + size);\n\t\t\t}\n\t\t} else if (type < 65536) {\n\t\t\tif (le32_to_cpu(eahd->appAttrLocation) <\n\t\t\t\t\tiinfo->i_lenEAttr) {\n\t\t\t\tuint32_t aal =\n\t\t\t\t\tle32_to_cpu(eahd->appAttrLocation);\n\t\t\t\tmemmove(&ea[offset - aal + size],\n\t\t\t\t\t&ea[aal], offset - aal);\n\t\t\t\toffset -= aal;\n\t\t\t\teahd->appAttrLocation =\n\t\t\t\t\t\tcpu_to_le32(aal + size);\n\t\t\t}\n\t\t}\n\t\t/* rewrite CRC + checksum of eahd */\n\t\tcrclen = sizeof(struct extendedAttrHeaderDesc) - sizeof(struct tag);\n\t\teahd->descTag.descCRCLength = cpu_to_le16(crclen);\n\t\teahd->descTag.descCRC = cpu_to_le16(crc_itu_t(0, (char *)eahd +\n\t\t\t\t\t\tsizeof(struct tag), crclen));\n\t\teahd->descTag.tagChecksum = udf_tag_checksum(&eahd->descTag);\n\t\tiinfo->i_lenEAttr += size;\n\t\treturn (struct genericFormat *)&ea[offset];\n\t}\n\tif (loc & 0x02)\n\t\t;\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "udf_tag_checksum",
          "args": [
            "&eahd->descTag"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "udf_tag_checksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "290-299",
          "snippet": "u8 udf_tag_checksum(const struct tag *t)\n{\n\tu8 *data = (u8 *)t;\n\tu8 checksum = 0;\n\tint i;\n\tfor (i = 0; i < sizeof(struct tag); ++i)\n\t\tif (i != 4) /* position of checksum */\n\t\t\tchecksum += data[i];\n\treturn checksum;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nu8 udf_tag_checksum(const struct tag *t)\n{\n\tu8 *data = (u8 *)t;\n\tu8 checksum = 0;\n\tint i;\n\tfor (i = 0; i < sizeof(struct tag); ++i)\n\t\tif (i != 4) /* position of checksum */\n\t\t\tchecksum += data[i];\n\treturn checksum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "crc_itu_t(0, (char *)eahd +\n\t\t\t\t\t\tsizeof(struct tag), crclen)"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crc_itu_t",
          "args": [
            "0",
            "(char *)eahd +\n\t\t\t\t\t\tsizeof(struct tag)",
            "crclen"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "crclen"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "aal + size"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&ea[offset - aal + size]",
            "&ea[aal]",
            "offset - aal"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "eahd->appAttrLocation"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ial + size"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&ea[offset - ial + size]",
            "&ea[ial]",
            "offset - ial"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "aal + size"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&ea[offset - aal + size]",
            "&ea[aal]",
            "offset - aal"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "0xFFFFFFFF"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "0xFFFFFFFF"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "iinfo->i_location.logicalBlockNum"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "sbi->s_serial_number"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "2"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "3"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "TAG_IDENT_EAHD"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "TAG_IDENT_EAHD"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&ad[size]",
            "ad",
            "iinfo->i_lenAlloc"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_file_entry_alloc_offset",
          "args": [
            "inode"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "udf_file_entry_alloc_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udfdecl.h",
          "lines": "55-64",
          "snippet": "static inline size_t udf_file_entry_alloc_offset(struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tif (iinfo->i_use)\n\t\treturn sizeof(struct unallocSpaceEntry);\n\telse if (iinfo->i_efe)\n\t\treturn sizeof(struct extendedFileEntry) + iinfo->i_lenEAttr;\n\telse\n\t\treturn sizeof(struct fileEntry) + iinfo->i_lenEAttr;\n}",
          "includes": [
            "#include \"udf_i.h\"",
            "#include \"udfend.h\"",
            "#include \"udf_sb.h\"",
            "#include <linux/udf_fs_i.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include \"osta_udf.h\"",
            "#include \"ecma_167.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_i.h\"\n#include \"udfend.h\"\n#include \"udf_sb.h\"\n#include <linux/udf_fs_i.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include \"osta_udf.h\"\n#include \"ecma_167.h\"\n\nstatic inline size_t udf_file_entry_alloc_offset(struct inode *inode)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tif (iinfo->i_use)\n\t\treturn sizeof(struct unallocSpaceEntry);\n\telse if (iinfo->i_efe)\n\t\treturn sizeof(struct extendedFileEntry) + iinfo->i_lenEAttr;\n\telse\n\t\treturn sizeof(struct fileEntry) + iinfo->i_lenEAttr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "inode"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstruct genericFormat *udf_add_extendedattr(struct inode *inode, uint32_t size,\n\t\t\t\t\t   uint32_t type, uint8_t loc)\n{\n\tuint8_t *ea = NULL, *ad = NULL;\n\tint offset;\n\tuint16_t crclen;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tea = iinfo->i_ext.i_data;\n\tif (iinfo->i_lenEAttr) {\n\t\tad = iinfo->i_ext.i_data + iinfo->i_lenEAttr;\n\t} else {\n\t\tad = ea;\n\t\tsize += sizeof(struct extendedAttrHeaderDesc);\n\t}\n\n\toffset = inode->i_sb->s_blocksize - udf_file_entry_alloc_offset(inode) -\n\t\tiinfo->i_lenAlloc;\n\n\t/* TODO - Check for FreeEASpace */\n\n\tif (loc & 0x01 && offset >= size) {\n\t\tstruct extendedAttrHeaderDesc *eahd;\n\t\teahd = (struct extendedAttrHeaderDesc *)ea;\n\n\t\tif (iinfo->i_lenAlloc)\n\t\t\tmemmove(&ad[size], ad, iinfo->i_lenAlloc);\n\n\t\tif (iinfo->i_lenEAttr) {\n\t\t\t/* check checksum/crc */\n\t\t\tif (eahd->descTag.tagIdent !=\n\t\t\t\t\tcpu_to_le16(TAG_IDENT_EAHD) ||\n\t\t\t    le32_to_cpu(eahd->descTag.tagLocation) !=\n\t\t\t\t\tiinfo->i_location.logicalBlockNum)\n\t\t\t\treturn NULL;\n\t\t} else {\n\t\t\tstruct udf_sb_info *sbi = UDF_SB(inode->i_sb);\n\n\t\t\tsize -= sizeof(struct extendedAttrHeaderDesc);\n\t\t\tiinfo->i_lenEAttr +=\n\t\t\t\tsizeof(struct extendedAttrHeaderDesc);\n\t\t\teahd->descTag.tagIdent = cpu_to_le16(TAG_IDENT_EAHD);\n\t\t\tif (sbi->s_udfrev >= 0x0200)\n\t\t\t\teahd->descTag.descVersion = cpu_to_le16(3);\n\t\t\telse\n\t\t\t\teahd->descTag.descVersion = cpu_to_le16(2);\n\t\t\teahd->descTag.tagSerialNum =\n\t\t\t\t\tcpu_to_le16(sbi->s_serial_number);\n\t\t\teahd->descTag.tagLocation = cpu_to_le32(\n\t\t\t\t\tiinfo->i_location.logicalBlockNum);\n\t\t\teahd->impAttrLocation = cpu_to_le32(0xFFFFFFFF);\n\t\t\teahd->appAttrLocation = cpu_to_le32(0xFFFFFFFF);\n\t\t}\n\n\t\toffset = iinfo->i_lenEAttr;\n\t\tif (type < 2048) {\n\t\t\tif (le32_to_cpu(eahd->appAttrLocation) <\n\t\t\t\t\tiinfo->i_lenEAttr) {\n\t\t\t\tuint32_t aal =\n\t\t\t\t\tle32_to_cpu(eahd->appAttrLocation);\n\t\t\t\tmemmove(&ea[offset - aal + size],\n\t\t\t\t\t&ea[aal], offset - aal);\n\t\t\t\toffset -= aal;\n\t\t\t\teahd->appAttrLocation =\n\t\t\t\t\t\tcpu_to_le32(aal + size);\n\t\t\t}\n\t\t\tif (le32_to_cpu(eahd->impAttrLocation) <\n\t\t\t\t\tiinfo->i_lenEAttr) {\n\t\t\t\tuint32_t ial =\n\t\t\t\t\tle32_to_cpu(eahd->impAttrLocation);\n\t\t\t\tmemmove(&ea[offset - ial + size],\n\t\t\t\t\t&ea[ial], offset - ial);\n\t\t\t\toffset -= ial;\n\t\t\t\teahd->impAttrLocation =\n\t\t\t\t\t\tcpu_to_le32(ial + size);\n\t\t\t}\n\t\t} else if (type < 65536) {\n\t\t\tif (le32_to_cpu(eahd->appAttrLocation) <\n\t\t\t\t\tiinfo->i_lenEAttr) {\n\t\t\t\tuint32_t aal =\n\t\t\t\t\tle32_to_cpu(eahd->appAttrLocation);\n\t\t\t\tmemmove(&ea[offset - aal + size],\n\t\t\t\t\t&ea[aal], offset - aal);\n\t\t\t\toffset -= aal;\n\t\t\t\teahd->appAttrLocation =\n\t\t\t\t\t\tcpu_to_le32(aal + size);\n\t\t\t}\n\t\t}\n\t\t/* rewrite CRC + checksum of eahd */\n\t\tcrclen = sizeof(struct extendedAttrHeaderDesc) - sizeof(struct tag);\n\t\teahd->descTag.descCRCLength = cpu_to_le16(crclen);\n\t\teahd->descTag.descCRC = cpu_to_le16(crc_itu_t(0, (char *)eahd +\n\t\t\t\t\t\tsizeof(struct tag), crclen));\n\t\teahd->descTag.tagChecksum = udf_tag_checksum(&eahd->descTag);\n\t\tiinfo->i_lenEAttr += size;\n\t\treturn (struct genericFormat *)&ea[offset];\n\t}\n\tif (loc & 0x02)\n\t\t;\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "udf_tread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
    "lines": "40-46",
    "snippet": "struct buffer_head *udf_tread(struct super_block *sb, int block)\n{\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_VARCONV))\n\t\treturn sb_bread(sb, udf_fixed_to_variable(block));\n\telse\n\t\treturn sb_bread(sb, block);\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "block"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "udf_fixed_to_variable(block)"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_fixed_to_variable",
          "args": [
            "block"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_QUERY_FLAG",
          "args": [
            "sb",
            "UDF_FLAG_VARCONV"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_QUERY_FLAG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "169-172",
          "snippet": "static inline int UDF_QUERY_FLAG(struct super_block *sb, int flag)\n{\n\treturn test_bit(flag, &UDF_SB(sb)->s_flags);\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline int UDF_QUERY_FLAG(struct super_block *sb, int flag)\n{\n\treturn test_bit(flag, &UDF_SB(sb)->s_flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstruct buffer_head *udf_tread(struct super_block *sb, int block)\n{\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_VARCONV))\n\t\treturn sb_bread(sb, udf_fixed_to_variable(block));\n\telse\n\t\treturn sb_bread(sb, block);\n}"
  },
  {
    "function_name": "udf_tgetblk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
    "lines": "32-38",
    "snippet": "struct buffer_head *udf_tgetblk(struct super_block *sb, int block)\n{\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_VARCONV))\n\t\treturn sb_getblk(sb, udf_fixed_to_variable(block));\n\telse\n\t\treturn sb_getblk(sb, block);\n}",
    "includes": [
      "#include \"udf_sb.h\"",
      "#include \"udf_i.h\"",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "block"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "udf_fixed_to_variable(block)"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_fixed_to_variable",
          "args": [
            "block"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_QUERY_FLAG",
          "args": [
            "sb",
            "UDF_FLAG_VARCONV"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_QUERY_FLAG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "169-172",
          "snippet": "static inline int UDF_QUERY_FLAG(struct super_block *sb, int flag)\n{\n\treturn test_bit(flag, &UDF_SB(sb)->s_flags);\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline int UDF_QUERY_FLAG(struct super_block *sb, int flag)\n{\n\treturn test_bit(flag, &UDF_SB(sb)->s_flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nstruct buffer_head *udf_tgetblk(struct super_block *sb, int block)\n{\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_VARCONV))\n\t\treturn sb_getblk(sb, udf_fixed_to_variable(block));\n\telse\n\t\treturn sb_getblk(sb, block);\n}"
  }
]