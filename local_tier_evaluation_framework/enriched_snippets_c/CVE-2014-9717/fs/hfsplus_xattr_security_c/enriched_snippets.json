[
  {
    "function_name": "hfsplus_init_inode_security",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr_security.c",
    "lines": "107-117",
    "snippet": "int hfsplus_init_inode_security(struct inode *inode,\n\t\t\t\t\t\tstruct inode *dir,\n\t\t\t\t\t\tconst struct qstr *qstr)\n{\n\tint err;\n\n\terr = hfsplus_init_posix_acl(inode, dir);\n\tif (!err)\n\t\terr = hfsplus_init_security(inode, dir, qstr);\n\treturn err;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/nls.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfsplus_init_security",
          "args": [
            "inode",
            "dir",
            "qstr"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_init_security",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr_security.c",
          "lines": "100-105",
          "snippet": "int hfsplus_init_security(struct inode *inode, struct inode *dir,\n\t\t\t\tconst struct qstr *qstr)\n{\n\treturn security_inode_init_security(inode, dir, qstr,\n\t\t\t\t\t&hfsplus_initxattrs, NULL);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/nls.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/security.h>\n\nint hfsplus_init_security(struct inode *inode, struct inode *dir,\n\t\t\t\tconst struct qstr *qstr)\n{\n\treturn security_inode_init_security(inode, dir, qstr,\n\t\t\t\t\t&hfsplus_initxattrs, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_init_posix_acl",
          "args": [
            "inode",
            "dir"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_init_posix_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/posix_acl.c",
          "lines": "111-140",
          "snippet": "int hfsplus_init_posix_acl(struct inode *inode, struct inode *dir)\n{\n\tint err = 0;\n\tstruct posix_acl *default_acl, *acl;\n\n\thfs_dbg(ACL_MOD,\n\t\t\"[%s]: ino %lu, dir->ino %lu\\n\",\n\t\t__func__, inode->i_ino, dir->i_ino);\n\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn 0;\n\n\terr = posix_acl_create(dir, &inode->i_mode, &default_acl, &acl);\n\tif (err)\n\t\treturn err;\n\n\tif (default_acl) {\n\t\terr = hfsplus_set_posix_acl(inode, default_acl,\n\t\t\t\t\t    ACL_TYPE_DEFAULT);\n\t\tposix_acl_release(default_acl);\n\t}\n\n\tif (acl) {\n\t\tif (!err)\n\t\t\terr = hfsplus_set_posix_acl(inode, acl,\n\t\t\t\t\t\t    ACL_TYPE_ACCESS);\n\t\tposix_acl_release(acl);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_init_posix_acl(struct inode *inode, struct inode *dir)\n{\n\tint err = 0;\n\tstruct posix_acl *default_acl, *acl;\n\n\thfs_dbg(ACL_MOD,\n\t\t\"[%s]: ino %lu, dir->ino %lu\\n\",\n\t\t__func__, inode->i_ino, dir->i_ino);\n\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn 0;\n\n\terr = posix_acl_create(dir, &inode->i_mode, &default_acl, &acl);\n\tif (err)\n\t\treturn err;\n\n\tif (default_acl) {\n\t\terr = hfsplus_set_posix_acl(inode, default_acl,\n\t\t\t\t\t    ACL_TYPE_DEFAULT);\n\t\tposix_acl_release(default_acl);\n\t}\n\n\tif (acl) {\n\t\tif (!err)\n\t\t\terr = hfsplus_set_posix_acl(inode, acl,\n\t\t\t\t\t\t    ACL_TYPE_ACCESS);\n\t\tposix_acl_release(acl);\n\t}\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/security.h>\n\nint hfsplus_init_inode_security(struct inode *inode,\n\t\t\t\t\t\tstruct inode *dir,\n\t\t\t\t\t\tconst struct qstr *qstr)\n{\n\tint err;\n\n\terr = hfsplus_init_posix_acl(inode, dir);\n\tif (!err)\n\t\terr = hfsplus_init_security(inode, dir, qstr);\n\treturn err;\n}"
  },
  {
    "function_name": "hfsplus_init_security",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr_security.c",
    "lines": "100-105",
    "snippet": "int hfsplus_init_security(struct inode *inode, struct inode *dir,\n\t\t\t\tconst struct qstr *qstr)\n{\n\treturn security_inode_init_security(inode, dir, qstr,\n\t\t\t\t\t&hfsplus_initxattrs, NULL);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/nls.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_inode_init_security",
          "args": [
            "inode",
            "dir",
            "qstr",
            "&hfsplus_initxattrs",
            "NULL"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/security.h>\n\nint hfsplus_init_security(struct inode *inode, struct inode *dir,\n\t\t\t\tconst struct qstr *qstr)\n{\n\treturn security_inode_init_security(inode, dir, qstr,\n\t\t\t\t\t&hfsplus_initxattrs, NULL);\n}"
  },
  {
    "function_name": "hfsplus_initxattrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr_security.c",
    "lines": "68-98",
    "snippet": "static int hfsplus_initxattrs(struct inode *inode,\n\t\t\t\tconst struct xattr *xattr_array,\n\t\t\t\tvoid *fs_info)\n{\n\tconst struct xattr *xattr;\n\tchar *xattr_name;\n\tint err = 0;\n\n\txattr_name = kmalloc(NLS_MAX_CHARSET_SIZE * HFSPLUS_ATTR_MAX_STRLEN + 1,\n\t\tGFP_KERNEL);\n\tif (!xattr_name)\n\t\treturn -ENOMEM;\n\tfor (xattr = xattr_array; xattr->name != NULL; xattr++) {\n\n\t\tif (!strcmp(xattr->name, \"\"))\n\t\t\tcontinue;\n\n\t\tstrcpy(xattr_name, XATTR_SECURITY_PREFIX);\n\t\tstrcpy(xattr_name +\n\t\t\tXATTR_SECURITY_PREFIX_LEN, xattr->name);\n\t\tmemset(xattr_name +\n\t\t\tXATTR_SECURITY_PREFIX_LEN + strlen(xattr->name), 0, 1);\n\n\t\terr = __hfsplus_setxattr(inode, xattr_name,\n\t\t\t\t\txattr->value, xattr->value_len, 0);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tkfree(xattr_name);\n\treturn err;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/nls.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "xattr_name"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__hfsplus_setxattr",
          "args": [
            "inode",
            "xattr_name",
            "xattr->value",
            "xattr->value_len",
            "0"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "__hfsplus_setxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.c",
          "lines": "263-397",
          "snippet": "int __hfsplus_setxattr(struct inode *inode, const char *name,\n\t\t\tconst void *value, size_t size, int flags)\n{\n\tint err = 0;\n\tstruct hfs_find_data cat_fd;\n\thfsplus_cat_entry entry;\n\tu16 cat_entry_flags, cat_entry_type;\n\tu16 folder_finderinfo_len = sizeof(struct DInfo) +\n\t\t\t\t\tsizeof(struct DXInfo);\n\tu16 file_finderinfo_len = sizeof(struct FInfo) +\n\t\t\t\t\tsizeof(struct FXInfo);\n\n\tif ((!S_ISREG(inode->i_mode) &&\n\t\t\t!S_ISDIR(inode->i_mode)) ||\n\t\t\t\tHFSPLUS_IS_RSRC(inode))\n\t\treturn -EOPNOTSUPP;\n\n\tif (value == NULL)\n\t\treturn hfsplus_removexattr(inode, name);\n\n\terr = hfs_find_init(HFSPLUS_SB(inode->i_sb)->cat_tree, &cat_fd);\n\tif (err) {\n\t\tpr_err(\"can't init xattr find struct\\n\");\n\t\treturn err;\n\t}\n\n\terr = hfsplus_find_cat(inode->i_sb, inode->i_ino, &cat_fd);\n\tif (err) {\n\t\tpr_err(\"catalog searching failed\\n\");\n\t\tgoto end_setxattr;\n\t}\n\n\tif (!strcmp_xattr_finder_info(name)) {\n\t\tif (flags & XATTR_CREATE) {\n\t\t\tpr_err(\"xattr exists yet\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto end_setxattr;\n\t\t}\n\t\thfs_bnode_read(cat_fd.bnode, &entry, cat_fd.entryoffset,\n\t\t\t\t\tsizeof(hfsplus_cat_entry));\n\t\tif (be16_to_cpu(entry.type) == HFSPLUS_FOLDER) {\n\t\t\tif (size == folder_finderinfo_len) {\n\t\t\t\tmemcpy(&entry.folder.user_info, value,\n\t\t\t\t\t\tfolder_finderinfo_len);\n\t\t\t\thfs_bnode_write(cat_fd.bnode, &entry,\n\t\t\t\t\tcat_fd.entryoffset,\n\t\t\t\t\tsizeof(struct hfsplus_cat_folder));\n\t\t\t\thfsplus_mark_inode_dirty(inode,\n\t\t\t\t\t\tHFSPLUS_I_CAT_DIRTY);\n\t\t\t} else {\n\t\t\t\terr = -ERANGE;\n\t\t\t\tgoto end_setxattr;\n\t\t\t}\n\t\t} else if (be16_to_cpu(entry.type) == HFSPLUS_FILE) {\n\t\t\tif (size == file_finderinfo_len) {\n\t\t\t\tmemcpy(&entry.file.user_info, value,\n\t\t\t\t\t\tfile_finderinfo_len);\n\t\t\t\thfs_bnode_write(cat_fd.bnode, &entry,\n\t\t\t\t\tcat_fd.entryoffset,\n\t\t\t\t\tsizeof(struct hfsplus_cat_file));\n\t\t\t\thfsplus_mark_inode_dirty(inode,\n\t\t\t\t\t\tHFSPLUS_I_CAT_DIRTY);\n\t\t\t} else {\n\t\t\t\terr = -ERANGE;\n\t\t\t\tgoto end_setxattr;\n\t\t\t}\n\t\t} else {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto end_setxattr;\n\t\t}\n\t\tgoto end_setxattr;\n\t}\n\n\tif (!HFSPLUS_SB(inode->i_sb)->attr_tree) {\n\t\terr = hfsplus_create_attributes_file(inode->i_sb);\n\t\tif (unlikely(err))\n\t\t\tgoto end_setxattr;\n\t}\n\n\tif (hfsplus_attr_exists(inode, name)) {\n\t\tif (flags & XATTR_CREATE) {\n\t\t\tpr_err(\"xattr exists yet\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto end_setxattr;\n\t\t}\n\t\terr = hfsplus_delete_attr(inode, name);\n\t\tif (err)\n\t\t\tgoto end_setxattr;\n\t\terr = hfsplus_create_attr(inode, name, value, size);\n\t\tif (err)\n\t\t\tgoto end_setxattr;\n\t} else {\n\t\tif (flags & XATTR_REPLACE) {\n\t\t\tpr_err(\"cannot replace xattr\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto end_setxattr;\n\t\t}\n\t\terr = hfsplus_create_attr(inode, name, value, size);\n\t\tif (err)\n\t\t\tgoto end_setxattr;\n\t}\n\n\tcat_entry_type = hfs_bnode_read_u16(cat_fd.bnode, cat_fd.entryoffset);\n\tif (cat_entry_type == HFSPLUS_FOLDER) {\n\t\tcat_entry_flags = hfs_bnode_read_u16(cat_fd.bnode,\n\t\t\t\t    cat_fd.entryoffset +\n\t\t\t\t    offsetof(struct hfsplus_cat_folder, flags));\n\t\tcat_entry_flags |= HFSPLUS_XATTR_EXISTS;\n\t\tif (!strcmp_xattr_acl(name))\n\t\t\tcat_entry_flags |= HFSPLUS_ACL_EXISTS;\n\t\thfs_bnode_write_u16(cat_fd.bnode, cat_fd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_folder, flags),\n\t\t\t\tcat_entry_flags);\n\t\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_CAT_DIRTY);\n\t} else if (cat_entry_type == HFSPLUS_FILE) {\n\t\tcat_entry_flags = hfs_bnode_read_u16(cat_fd.bnode,\n\t\t\t\t    cat_fd.entryoffset +\n\t\t\t\t    offsetof(struct hfsplus_cat_file, flags));\n\t\tcat_entry_flags |= HFSPLUS_XATTR_EXISTS;\n\t\tif (!strcmp_xattr_acl(name))\n\t\t\tcat_entry_flags |= HFSPLUS_ACL_EXISTS;\n\t\thfs_bnode_write_u16(cat_fd.bnode, cat_fd.entryoffset +\n\t\t\t\t    offsetof(struct hfsplus_cat_file, flags),\n\t\t\t\t    cat_entry_flags);\n\t\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_CAT_DIRTY);\n\t} else {\n\t\tpr_err(\"invalid catalog entry type\\n\");\n\t\terr = -EIO;\n\t\tgoto end_setxattr;\n\t}\n\nend_setxattr:\n\thfs_find_exit(&cat_fd);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/nls.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int hfsplus_removexattr(struct inode *inode, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/nls.h>\n#include <linux/posix_acl_xattr.h>\n#include \"hfsplus_fs.h\"\n\nstatic int hfsplus_removexattr(struct inode *inode, const char *name);\n\nint __hfsplus_setxattr(struct inode *inode, const char *name,\n\t\t\tconst void *value, size_t size, int flags)\n{\n\tint err = 0;\n\tstruct hfs_find_data cat_fd;\n\thfsplus_cat_entry entry;\n\tu16 cat_entry_flags, cat_entry_type;\n\tu16 folder_finderinfo_len = sizeof(struct DInfo) +\n\t\t\t\t\tsizeof(struct DXInfo);\n\tu16 file_finderinfo_len = sizeof(struct FInfo) +\n\t\t\t\t\tsizeof(struct FXInfo);\n\n\tif ((!S_ISREG(inode->i_mode) &&\n\t\t\t!S_ISDIR(inode->i_mode)) ||\n\t\t\t\tHFSPLUS_IS_RSRC(inode))\n\t\treturn -EOPNOTSUPP;\n\n\tif (value == NULL)\n\t\treturn hfsplus_removexattr(inode, name);\n\n\terr = hfs_find_init(HFSPLUS_SB(inode->i_sb)->cat_tree, &cat_fd);\n\tif (err) {\n\t\tpr_err(\"can't init xattr find struct\\n\");\n\t\treturn err;\n\t}\n\n\terr = hfsplus_find_cat(inode->i_sb, inode->i_ino, &cat_fd);\n\tif (err) {\n\t\tpr_err(\"catalog searching failed\\n\");\n\t\tgoto end_setxattr;\n\t}\n\n\tif (!strcmp_xattr_finder_info(name)) {\n\t\tif (flags & XATTR_CREATE) {\n\t\t\tpr_err(\"xattr exists yet\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto end_setxattr;\n\t\t}\n\t\thfs_bnode_read(cat_fd.bnode, &entry, cat_fd.entryoffset,\n\t\t\t\t\tsizeof(hfsplus_cat_entry));\n\t\tif (be16_to_cpu(entry.type) == HFSPLUS_FOLDER) {\n\t\t\tif (size == folder_finderinfo_len) {\n\t\t\t\tmemcpy(&entry.folder.user_info, value,\n\t\t\t\t\t\tfolder_finderinfo_len);\n\t\t\t\thfs_bnode_write(cat_fd.bnode, &entry,\n\t\t\t\t\tcat_fd.entryoffset,\n\t\t\t\t\tsizeof(struct hfsplus_cat_folder));\n\t\t\t\thfsplus_mark_inode_dirty(inode,\n\t\t\t\t\t\tHFSPLUS_I_CAT_DIRTY);\n\t\t\t} else {\n\t\t\t\terr = -ERANGE;\n\t\t\t\tgoto end_setxattr;\n\t\t\t}\n\t\t} else if (be16_to_cpu(entry.type) == HFSPLUS_FILE) {\n\t\t\tif (size == file_finderinfo_len) {\n\t\t\t\tmemcpy(&entry.file.user_info, value,\n\t\t\t\t\t\tfile_finderinfo_len);\n\t\t\t\thfs_bnode_write(cat_fd.bnode, &entry,\n\t\t\t\t\tcat_fd.entryoffset,\n\t\t\t\t\tsizeof(struct hfsplus_cat_file));\n\t\t\t\thfsplus_mark_inode_dirty(inode,\n\t\t\t\t\t\tHFSPLUS_I_CAT_DIRTY);\n\t\t\t} else {\n\t\t\t\terr = -ERANGE;\n\t\t\t\tgoto end_setxattr;\n\t\t\t}\n\t\t} else {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto end_setxattr;\n\t\t}\n\t\tgoto end_setxattr;\n\t}\n\n\tif (!HFSPLUS_SB(inode->i_sb)->attr_tree) {\n\t\terr = hfsplus_create_attributes_file(inode->i_sb);\n\t\tif (unlikely(err))\n\t\t\tgoto end_setxattr;\n\t}\n\n\tif (hfsplus_attr_exists(inode, name)) {\n\t\tif (flags & XATTR_CREATE) {\n\t\t\tpr_err(\"xattr exists yet\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto end_setxattr;\n\t\t}\n\t\terr = hfsplus_delete_attr(inode, name);\n\t\tif (err)\n\t\t\tgoto end_setxattr;\n\t\terr = hfsplus_create_attr(inode, name, value, size);\n\t\tif (err)\n\t\t\tgoto end_setxattr;\n\t} else {\n\t\tif (flags & XATTR_REPLACE) {\n\t\t\tpr_err(\"cannot replace xattr\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto end_setxattr;\n\t\t}\n\t\terr = hfsplus_create_attr(inode, name, value, size);\n\t\tif (err)\n\t\t\tgoto end_setxattr;\n\t}\n\n\tcat_entry_type = hfs_bnode_read_u16(cat_fd.bnode, cat_fd.entryoffset);\n\tif (cat_entry_type == HFSPLUS_FOLDER) {\n\t\tcat_entry_flags = hfs_bnode_read_u16(cat_fd.bnode,\n\t\t\t\t    cat_fd.entryoffset +\n\t\t\t\t    offsetof(struct hfsplus_cat_folder, flags));\n\t\tcat_entry_flags |= HFSPLUS_XATTR_EXISTS;\n\t\tif (!strcmp_xattr_acl(name))\n\t\t\tcat_entry_flags |= HFSPLUS_ACL_EXISTS;\n\t\thfs_bnode_write_u16(cat_fd.bnode, cat_fd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_folder, flags),\n\t\t\t\tcat_entry_flags);\n\t\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_CAT_DIRTY);\n\t} else if (cat_entry_type == HFSPLUS_FILE) {\n\t\tcat_entry_flags = hfs_bnode_read_u16(cat_fd.bnode,\n\t\t\t\t    cat_fd.entryoffset +\n\t\t\t\t    offsetof(struct hfsplus_cat_file, flags));\n\t\tcat_entry_flags |= HFSPLUS_XATTR_EXISTS;\n\t\tif (!strcmp_xattr_acl(name))\n\t\t\tcat_entry_flags |= HFSPLUS_ACL_EXISTS;\n\t\thfs_bnode_write_u16(cat_fd.bnode, cat_fd.entryoffset +\n\t\t\t\t    offsetof(struct hfsplus_cat_file, flags),\n\t\t\t\t    cat_entry_flags);\n\t\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_CAT_DIRTY);\n\t} else {\n\t\tpr_err(\"invalid catalog entry type\\n\");\n\t\terr = -EIO;\n\t\tgoto end_setxattr;\n\t}\n\nend_setxattr:\n\thfs_find_exit(&cat_fd);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "xattr_name +\n\t\t\tXATTR_SECURITY_PREFIX_LEN + strlen(xattr->name)",
            "0",
            "1"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "xattr->name"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "xattr_name +\n\t\t\tXATTR_SECURITY_PREFIX_LEN",
            "xattr->name"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "xattr_name",
            "XATTR_SECURITY_PREFIX"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "xattr->name",
            "\"\""
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_strcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/unicode.c",
          "lines": "64-87",
          "snippet": "int hfsplus_strcmp(const struct hfsplus_unistr *s1,\n\t\t   const struct hfsplus_unistr *s2)\n{\n\tu16 len1, len2, c1, c2;\n\tconst hfsplus_unichr *p1, *p2;\n\tint len;\n\n\tlen1 = be16_to_cpu(s1->length);\n\tlen2 = be16_to_cpu(s2->length);\n\tp1 = s1->unicode;\n\tp2 = s2->unicode;\n\n\tfor (len = min(len1, len2); len > 0; len--) {\n\t\tc1 = be16_to_cpu(*p1);\n\t\tc2 = be16_to_cpu(*p2);\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tp1++;\n\t\tp2++;\n\t}\n\n\treturn len1 < len2 ? -1 :\n\t       len1 > len2 ? 1 : 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/types.h>\n\nint hfsplus_strcmp(const struct hfsplus_unistr *s1,\n\t\t   const struct hfsplus_unistr *s2)\n{\n\tu16 len1, len2, c1, c2;\n\tconst hfsplus_unichr *p1, *p2;\n\tint len;\n\n\tlen1 = be16_to_cpu(s1->length);\n\tlen2 = be16_to_cpu(s2->length);\n\tp1 = s1->unicode;\n\tp2 = s2->unicode;\n\n\tfor (len = min(len1, len2); len > 0; len--) {\n\t\tc1 = be16_to_cpu(*p1);\n\t\tc2 = be16_to_cpu(*p2);\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tp1++;\n\t\tp2++;\n\t}\n\n\treturn len1 < len2 ? -1 :\n\t       len1 > len2 ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "NLS_MAX_CHARSET_SIZE * HFSPLUS_ATTR_MAX_STRLEN + 1",
            "GFP_KERNEL"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/security.h>\n\nstatic int hfsplus_initxattrs(struct inode *inode,\n\t\t\t\tconst struct xattr *xattr_array,\n\t\t\t\tvoid *fs_info)\n{\n\tconst struct xattr *xattr;\n\tchar *xattr_name;\n\tint err = 0;\n\n\txattr_name = kmalloc(NLS_MAX_CHARSET_SIZE * HFSPLUS_ATTR_MAX_STRLEN + 1,\n\t\tGFP_KERNEL);\n\tif (!xattr_name)\n\t\treturn -ENOMEM;\n\tfor (xattr = xattr_array; xattr->name != NULL; xattr++) {\n\n\t\tif (!strcmp(xattr->name, \"\"))\n\t\t\tcontinue;\n\n\t\tstrcpy(xattr_name, XATTR_SECURITY_PREFIX);\n\t\tstrcpy(xattr_name +\n\t\t\tXATTR_SECURITY_PREFIX_LEN, xattr->name);\n\t\tmemset(xattr_name +\n\t\t\tXATTR_SECURITY_PREFIX_LEN + strlen(xattr->name), 0, 1);\n\n\t\terr = __hfsplus_setxattr(inode, xattr_name,\n\t\t\t\t\txattr->value, xattr->value_len, 0);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tkfree(xattr_name);\n\treturn err;\n}"
  },
  {
    "function_name": "hfsplus_security_listxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr_security.c",
    "lines": "58-66",
    "snippet": "static size_t hfsplus_security_listxattr(struct dentry *dentry, char *list,\n\t\tsize_t list_size, const char *name, size_t name_len, int type)\n{\n\t/*\n\t * This method is not used.\n\t * It is used hfsplus_listxattr() instead of generic_listxattr().\n\t */\n\treturn -EOPNOTSUPP;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/nls.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/security.h>\n\nstatic size_t hfsplus_security_listxattr(struct dentry *dentry, char *list,\n\t\tsize_t list_size, const char *name, size_t name_len, int type)\n{\n\t/*\n\t * This method is not used.\n\t * It is used hfsplus_listxattr() instead of generic_listxattr().\n\t */\n\treturn -EOPNOTSUPP;\n}"
  },
  {
    "function_name": "hfsplus_security_setxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr_security.c",
    "lines": "37-56",
    "snippet": "static int hfsplus_security_setxattr(struct dentry *dentry, const char *name,\n\t\tconst void *buffer, size_t size, int flags, int type)\n{\n\tchar *xattr_name;\n\tint res;\n\n\tif (!strcmp(name, \"\"))\n\t\treturn -EINVAL;\n\n\txattr_name = kmalloc(NLS_MAX_CHARSET_SIZE * HFSPLUS_ATTR_MAX_STRLEN + 1,\n\t\tGFP_KERNEL);\n\tif (!xattr_name)\n\t\treturn -ENOMEM;\n\tstrcpy(xattr_name, XATTR_SECURITY_PREFIX);\n\tstrcpy(xattr_name + XATTR_SECURITY_PREFIX_LEN, name);\n\n\tres = hfsplus_setxattr(dentry, xattr_name, buffer, size, flags);\n\tkfree(xattr_name);\n\treturn res;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/nls.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "xattr_name"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_setxattr",
          "args": [
            "dentry",
            "xattr_name",
            "buffer",
            "size",
            "flags"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_setxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.h",
          "lines": "24-28",
          "snippet": "static inline int hfsplus_setxattr(struct dentry *dentry, const char *name,\n\t\t\tconst void *value, size_t size, int flags)\n{\n\treturn __hfsplus_setxattr(dentry->d_inode, name, value, size, flags);\n}",
          "includes": [
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/xattr.h>\n\nstatic inline int hfsplus_setxattr(struct dentry *dentry, const char *name,\n\t\t\tconst void *value, size_t size, int flags)\n{\n\treturn __hfsplus_setxattr(dentry->d_inode, name, value, size, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "xattr_name + XATTR_SECURITY_PREFIX_LEN",
            "name"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "xattr_name",
            "XATTR_SECURITY_PREFIX"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "NLS_MAX_CHARSET_SIZE * HFSPLUS_ATTR_MAX_STRLEN + 1",
            "GFP_KERNEL"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"\""
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_strcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/unicode.c",
          "lines": "64-87",
          "snippet": "int hfsplus_strcmp(const struct hfsplus_unistr *s1,\n\t\t   const struct hfsplus_unistr *s2)\n{\n\tu16 len1, len2, c1, c2;\n\tconst hfsplus_unichr *p1, *p2;\n\tint len;\n\n\tlen1 = be16_to_cpu(s1->length);\n\tlen2 = be16_to_cpu(s2->length);\n\tp1 = s1->unicode;\n\tp2 = s2->unicode;\n\n\tfor (len = min(len1, len2); len > 0; len--) {\n\t\tc1 = be16_to_cpu(*p1);\n\t\tc2 = be16_to_cpu(*p2);\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tp1++;\n\t\tp2++;\n\t}\n\n\treturn len1 < len2 ? -1 :\n\t       len1 > len2 ? 1 : 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/types.h>\n\nint hfsplus_strcmp(const struct hfsplus_unistr *s1,\n\t\t   const struct hfsplus_unistr *s2)\n{\n\tu16 len1, len2, c1, c2;\n\tconst hfsplus_unichr *p1, *p2;\n\tint len;\n\n\tlen1 = be16_to_cpu(s1->length);\n\tlen2 = be16_to_cpu(s2->length);\n\tp1 = s1->unicode;\n\tp2 = s2->unicode;\n\n\tfor (len = min(len1, len2); len > 0; len--) {\n\t\tc1 = be16_to_cpu(*p1);\n\t\tc2 = be16_to_cpu(*p2);\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tp1++;\n\t\tp2++;\n\t}\n\n\treturn len1 < len2 ? -1 :\n\t       len1 > len2 ? 1 : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/security.h>\n\nstatic int hfsplus_security_setxattr(struct dentry *dentry, const char *name,\n\t\tconst void *buffer, size_t size, int flags, int type)\n{\n\tchar *xattr_name;\n\tint res;\n\n\tif (!strcmp(name, \"\"))\n\t\treturn -EINVAL;\n\n\txattr_name = kmalloc(NLS_MAX_CHARSET_SIZE * HFSPLUS_ATTR_MAX_STRLEN + 1,\n\t\tGFP_KERNEL);\n\tif (!xattr_name)\n\t\treturn -ENOMEM;\n\tstrcpy(xattr_name, XATTR_SECURITY_PREFIX);\n\tstrcpy(xattr_name + XATTR_SECURITY_PREFIX_LEN, name);\n\n\tres = hfsplus_setxattr(dentry, xattr_name, buffer, size, flags);\n\tkfree(xattr_name);\n\treturn res;\n}"
  },
  {
    "function_name": "hfsplus_security_getxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr_security.c",
    "lines": "16-35",
    "snippet": "static int hfsplus_security_getxattr(struct dentry *dentry, const char *name,\n\t\t\t\t\tvoid *buffer, size_t size, int type)\n{\n\tchar *xattr_name;\n\tint res;\n\n\tif (!strcmp(name, \"\"))\n\t\treturn -EINVAL;\n\n\txattr_name = kmalloc(NLS_MAX_CHARSET_SIZE * HFSPLUS_ATTR_MAX_STRLEN + 1,\n\t\tGFP_KERNEL);\n\tif (!xattr_name)\n\t\treturn -ENOMEM;\n\tstrcpy(xattr_name, XATTR_SECURITY_PREFIX);\n\tstrcpy(xattr_name + XATTR_SECURITY_PREFIX_LEN, name);\n\n\tres = hfsplus_getxattr(dentry, xattr_name, buffer, size);\n\tkfree(xattr_name);\n\treturn res;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/nls.h>",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "xattr_name"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_getxattr",
          "args": [
            "dentry",
            "xattr_name",
            "buffer",
            "size"
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_getxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.h",
          "lines": "33-39",
          "snippet": "static inline ssize_t hfsplus_getxattr(struct dentry *dentry,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tvoid *value,\n\t\t\t\t\tsize_t size)\n{\n\treturn __hfsplus_getxattr(dentry->d_inode, name, value, size);\n}",
          "includes": [
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/xattr.h>\n\nstatic inline ssize_t hfsplus_getxattr(struct dentry *dentry,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tvoid *value,\n\t\t\t\t\tsize_t size)\n{\n\treturn __hfsplus_getxattr(dentry->d_inode, name, value, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "xattr_name + XATTR_SECURITY_PREFIX_LEN",
            "name"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "xattr_name",
            "XATTR_SECURITY_PREFIX"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "NLS_MAX_CHARSET_SIZE * HFSPLUS_ATTR_MAX_STRLEN + 1",
            "GFP_KERNEL"
          ],
          "line": 25
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"\""
          ],
          "line": 22
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_strcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/unicode.c",
          "lines": "64-87",
          "snippet": "int hfsplus_strcmp(const struct hfsplus_unistr *s1,\n\t\t   const struct hfsplus_unistr *s2)\n{\n\tu16 len1, len2, c1, c2;\n\tconst hfsplus_unichr *p1, *p2;\n\tint len;\n\n\tlen1 = be16_to_cpu(s1->length);\n\tlen2 = be16_to_cpu(s2->length);\n\tp1 = s1->unicode;\n\tp2 = s2->unicode;\n\n\tfor (len = min(len1, len2); len > 0; len--) {\n\t\tc1 = be16_to_cpu(*p1);\n\t\tc2 = be16_to_cpu(*p2);\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tp1++;\n\t\tp2++;\n\t}\n\n\treturn len1 < len2 ? -1 :\n\t       len1 > len2 ? 1 : 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/types.h>\n\nint hfsplus_strcmp(const struct hfsplus_unistr *s1,\n\t\t   const struct hfsplus_unistr *s2)\n{\n\tu16 len1, len2, c1, c2;\n\tconst hfsplus_unichr *p1, *p2;\n\tint len;\n\n\tlen1 = be16_to_cpu(s1->length);\n\tlen2 = be16_to_cpu(s2->length);\n\tp1 = s1->unicode;\n\tp2 = s2->unicode;\n\n\tfor (len = min(len1, len2); len > 0; len--) {\n\t\tc1 = be16_to_cpu(*p1);\n\t\tc2 = be16_to_cpu(*p2);\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tp1++;\n\t\tp2++;\n\t}\n\n\treturn len1 < len2 ? -1 :\n\t       len1 > len2 ? 1 : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/security.h>\n\nstatic int hfsplus_security_getxattr(struct dentry *dentry, const char *name,\n\t\t\t\t\tvoid *buffer, size_t size, int type)\n{\n\tchar *xattr_name;\n\tint res;\n\n\tif (!strcmp(name, \"\"))\n\t\treturn -EINVAL;\n\n\txattr_name = kmalloc(NLS_MAX_CHARSET_SIZE * HFSPLUS_ATTR_MAX_STRLEN + 1,\n\t\tGFP_KERNEL);\n\tif (!xattr_name)\n\t\treturn -ENOMEM;\n\tstrcpy(xattr_name, XATTR_SECURITY_PREFIX);\n\tstrcpy(xattr_name + XATTR_SECURITY_PREFIX_LEN, name);\n\n\tres = hfsplus_getxattr(dentry, xattr_name, buffer, size);\n\tkfree(xattr_name);\n\treturn res;\n}"
  }
]