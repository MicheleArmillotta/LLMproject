[
  {
    "function_name": "btrfs_uuid_tree_iterate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/uuid-tree.c",
    "lines": "258-354",
    "snippet": "int btrfs_uuid_tree_iterate(struct btrfs_fs_info *fs_info,\n\t\t\t    int (*check_func)(struct btrfs_fs_info *, u8 *, u8,\n\t\t\t\t\t      u64))\n{\n\tstruct btrfs_root *root = fs_info->uuid_root;\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\tint ret = 0;\n\tstruct extent_buffer *leaf;\n\tint slot;\n\tu32 item_size;\n\tunsigned long offset;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tkey.objectid = 0;\n\tkey.type = 0;\n\tkey.offset = 0;\n\nagain_search_slot:\n\tret = btrfs_search_forward(root, &key, path, 0);\n\tif (ret) {\n\t\tif (ret > 0)\n\t\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\twhile (1) {\n\t\tcond_resched();\n\t\tleaf = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\n\t\tif (key.type != BTRFS_UUID_KEY_SUBVOL &&\n\t\t    key.type != BTRFS_UUID_KEY_RECEIVED_SUBVOL)\n\t\t\tgoto skip;\n\n\t\toffset = btrfs_item_ptr_offset(leaf, slot);\n\t\titem_size = btrfs_item_size_nr(leaf, slot);\n\t\tif (!IS_ALIGNED(item_size, sizeof(u64))) {\n\t\t\tbtrfs_warn(fs_info, \"uuid item with illegal size %lu!\",\n\t\t\t\t(unsigned long)item_size);\n\t\t\tgoto skip;\n\t\t}\n\t\twhile (item_size) {\n\t\t\tu8 uuid[BTRFS_UUID_SIZE];\n\t\t\t__le64 subid_le;\n\t\t\tu64 subid_cpu;\n\n\t\t\tput_unaligned_le64(key.objectid, uuid);\n\t\t\tput_unaligned_le64(key.offset, uuid + sizeof(u64));\n\t\t\tread_extent_buffer(leaf, &subid_le, offset,\n\t\t\t\t\t   sizeof(subid_le));\n\t\t\tsubid_cpu = le64_to_cpu(subid_le);\n\t\t\tret = check_func(fs_info, uuid, key.type, subid_cpu);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret > 0) {\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tret = btrfs_uuid_iter_rem(root, uuid, key.type,\n\t\t\t\t\t\t\t  subid_cpu);\n\t\t\t\tif (ret == 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * this might look inefficient, but the\n\t\t\t\t\t * justification is that it is an\n\t\t\t\t\t * exception that check_func returns 1,\n\t\t\t\t\t * and that in the regular case only one\n\t\t\t\t\t * entry per UUID exists.\n\t\t\t\t\t */\n\t\t\t\t\tgoto again_search_slot;\n\t\t\t\t}\n\t\t\t\tif (ret < 0 && ret != -ENOENT)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\titem_size -= sizeof(subid_le);\n\t\t\toffset += sizeof(subid_le);\n\t\t}\n\nskip:\n\t\tret = btrfs_next_item(root, path);\n\t\tif (ret == 0)\n\t\t\tcontinue;\n\t\telse if (ret > 0)\n\t\t\tret = 0;\n\t\tbreak;\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\tif (ret)\n\t\tbtrfs_warn(fs_info, \"btrfs_uuid_tree_iterate failed %d\", ret);\n\treturn 0;\n}",
    "includes": [
      "#include \"print-tree.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/uuid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_warn",
          "args": [
            "fs_info",
            "\"btrfs_uuid_tree_iterate failed %d\"",
            "ret"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_next_item",
          "args": [
            "root",
            "path"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_next_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3600-3603",
          "snippet": "static inline int btrfs_next_item(struct btrfs_root *root, struct btrfs_path *p)\n{\n\treturn btrfs_next_old_item(root, p, 0);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_next_item(struct btrfs_root *root, struct btrfs_path *p)\n{\n\treturn btrfs_next_old_item(root, p, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_uuid_iter_rem",
          "args": [
            "root",
            "uuid",
            "key.type",
            "subid_cpu"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_uuid_iter_rem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/uuid-tree.c",
          "lines": "238-256",
          "snippet": "static int btrfs_uuid_iter_rem(struct btrfs_root *uuid_root, u8 *uuid, u8 type,\n\t\t\t       u64 subid)\n{\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\n\t/* 1 - for the uuid item */\n\ttrans = btrfs_start_transaction(uuid_root, 1);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out;\n\t}\n\n\tret = btrfs_uuid_tree_rem(trans, uuid_root, uuid, type, subid);\n\tbtrfs_end_transaction(trans, uuid_root);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/uuid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/uuid.h>\n\nstatic int btrfs_uuid_iter_rem(struct btrfs_root *uuid_root, u8 *uuid, u8 type,\n\t\t\t       u64 subid)\n{\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\n\t/* 1 - for the uuid item */\n\ttrans = btrfs_start_transaction(uuid_root, 1);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out;\n\t}\n\n\tret = btrfs_uuid_tree_rem(trans, uuid_root, uuid, type, subid);\n\tbtrfs_end_transaction(trans, uuid_root);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_func",
          "args": [
            "fs_info",
            "uuid",
            "key.type",
            "subid_cpu"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "subid_le"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_extent_buffer",
          "args": [
            "leaf",
            "&subid_le",
            "offset",
            "sizeof(subid_le)"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "btree_read_extent_buffer_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "442-497",
          "snippet": "static int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_unaligned_le64",
          "args": [
            "key.offset",
            "uuid + sizeof(u64)"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_unaligned_le64",
          "args": [
            "key.objectid",
            "uuid"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_warn",
          "args": [
            "fs_info",
            "\"uuid item with illegal size %lu!\"",
            "(unsigned long)item_size"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "item_size",
            "sizeof(u64)"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_size_nr",
          "args": [
            "leaf",
            "slot"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr_offset",
          "args": [
            "leaf",
            "slot"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "leaf",
            "&key",
            "slot"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_forward",
          "args": [
            "root",
            "&key",
            "path",
            "0"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_forward",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5113-5211",
          "snippet": "int btrfs_search_forward(struct btrfs_root *root, struct btrfs_key *min_key,\n\t\t\t struct btrfs_path *path,\n\t\t\t u64 min_trans)\n{\n\tstruct extent_buffer *cur;\n\tstruct btrfs_key found_key;\n\tint slot;\n\tint sret;\n\tu32 nritems;\n\tint level;\n\tint ret = 1;\n\tint keep_locks = path->keep_locks;\n\n\tpath->keep_locks = 1;\nagain:\n\tcur = btrfs_read_lock_root_node(root);\n\tlevel = btrfs_header_level(cur);\n\tWARN_ON(path->nodes[level]);\n\tpath->nodes[level] = cur;\n\tpath->locks[level] = BTRFS_READ_LOCK;\n\n\tif (btrfs_header_generation(cur) < min_trans) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\twhile (1) {\n\t\tnritems = btrfs_header_nritems(cur);\n\t\tlevel = btrfs_header_level(cur);\n\t\tsret = bin_search(cur, min_key, level, &slot);\n\n\t\t/* at the lowest level, we're done, setup the path and exit */\n\t\tif (level == path->lowest_level) {\n\t\t\tif (slot >= nritems)\n\t\t\t\tgoto find_next_key;\n\t\t\tret = 0;\n\t\t\tpath->slots[level] = slot;\n\t\t\tbtrfs_item_key_to_cpu(cur, &found_key, slot);\n\t\t\tgoto out;\n\t\t}\n\t\tif (sret && slot > 0)\n\t\t\tslot--;\n\t\t/*\n\t\t * check this node pointer against the min_trans parameters.\n\t\t * If it is too old, old, skip to the next one.\n\t\t */\n\t\twhile (slot < nritems) {\n\t\t\tu64 gen;\n\n\t\t\tgen = btrfs_node_ptr_generation(cur, slot);\n\t\t\tif (gen < min_trans) {\n\t\t\t\tslot++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\nfind_next_key:\n\t\t/*\n\t\t * we didn't find a candidate key in this node, walk forward\n\t\t * and find another one\n\t\t */\n\t\tif (slot >= nritems) {\n\t\t\tpath->slots[level] = slot;\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tsret = btrfs_find_next_key(root, path, min_key, level,\n\t\t\t\t\t\t  min_trans);\n\t\t\tif (sret == 0) {\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tgoto again;\n\t\t\t} else {\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\t/* save our key for returning back */\n\t\tbtrfs_node_key_to_cpu(cur, &found_key, slot);\n\t\tpath->slots[level] = slot;\n\t\tif (level == path->lowest_level) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tbtrfs_set_path_blocking(path);\n\t\tcur = read_node_slot(root, cur, slot);\n\t\tBUG_ON(!cur); /* -ENOMEM */\n\n\t\tbtrfs_tree_read_lock(cur);\n\n\t\tpath->locks[level - 1] = BTRFS_READ_LOCK;\n\t\tpath->nodes[level - 1] = cur;\n\t\tunlock_up(path, level, 1, 0, NULL);\n\t\tbtrfs_clear_path_blocking(path, NULL, 0);\n\t}\nout:\n\tpath->keep_locks = keep_locks;\n\tif (ret == 0) {\n\t\tbtrfs_unlock_up_safe(path, path->lowest_level + 1);\n\t\tbtrfs_set_path_blocking(path);\n\t\tmemcpy(min_key, &found_key, sizeof(found_key));\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_forward(struct btrfs_root *root, struct btrfs_key *min_key,\n\t\t\t struct btrfs_path *path,\n\t\t\t u64 min_trans)\n{\n\tstruct extent_buffer *cur;\n\tstruct btrfs_key found_key;\n\tint slot;\n\tint sret;\n\tu32 nritems;\n\tint level;\n\tint ret = 1;\n\tint keep_locks = path->keep_locks;\n\n\tpath->keep_locks = 1;\nagain:\n\tcur = btrfs_read_lock_root_node(root);\n\tlevel = btrfs_header_level(cur);\n\tWARN_ON(path->nodes[level]);\n\tpath->nodes[level] = cur;\n\tpath->locks[level] = BTRFS_READ_LOCK;\n\n\tif (btrfs_header_generation(cur) < min_trans) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\twhile (1) {\n\t\tnritems = btrfs_header_nritems(cur);\n\t\tlevel = btrfs_header_level(cur);\n\t\tsret = bin_search(cur, min_key, level, &slot);\n\n\t\t/* at the lowest level, we're done, setup the path and exit */\n\t\tif (level == path->lowest_level) {\n\t\t\tif (slot >= nritems)\n\t\t\t\tgoto find_next_key;\n\t\t\tret = 0;\n\t\t\tpath->slots[level] = slot;\n\t\t\tbtrfs_item_key_to_cpu(cur, &found_key, slot);\n\t\t\tgoto out;\n\t\t}\n\t\tif (sret && slot > 0)\n\t\t\tslot--;\n\t\t/*\n\t\t * check this node pointer against the min_trans parameters.\n\t\t * If it is too old, old, skip to the next one.\n\t\t */\n\t\twhile (slot < nritems) {\n\t\t\tu64 gen;\n\n\t\t\tgen = btrfs_node_ptr_generation(cur, slot);\n\t\t\tif (gen < min_trans) {\n\t\t\t\tslot++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\nfind_next_key:\n\t\t/*\n\t\t * we didn't find a candidate key in this node, walk forward\n\t\t * and find another one\n\t\t */\n\t\tif (slot >= nritems) {\n\t\t\tpath->slots[level] = slot;\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tsret = btrfs_find_next_key(root, path, min_key, level,\n\t\t\t\t\t\t  min_trans);\n\t\t\tif (sret == 0) {\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tgoto again;\n\t\t\t} else {\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\t/* save our key for returning back */\n\t\tbtrfs_node_key_to_cpu(cur, &found_key, slot);\n\t\tpath->slots[level] = slot;\n\t\tif (level == path->lowest_level) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tbtrfs_set_path_blocking(path);\n\t\tcur = read_node_slot(root, cur, slot);\n\t\tBUG_ON(!cur); /* -ENOMEM */\n\n\t\tbtrfs_tree_read_lock(cur);\n\n\t\tpath->locks[level - 1] = BTRFS_READ_LOCK;\n\t\tpath->nodes[level - 1] = cur;\n\t\tunlock_up(path, level, 1, 0, NULL);\n\t\tbtrfs_clear_path_blocking(path, NULL, 0);\n\t}\nout:\n\tpath->keep_locks = keep_locks;\n\tif (ret == 0) {\n\t\tbtrfs_unlock_up_safe(path, path->lowest_level + 1);\n\t\tbtrfs_set_path_blocking(path);\n\t\tmemcpy(min_key, &found_key, sizeof(found_key));\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/uuid.h>\n\nint btrfs_uuid_tree_iterate(struct btrfs_fs_info *fs_info,\n\t\t\t    int (*check_func)(struct btrfs_fs_info *, u8 *, u8,\n\t\t\t\t\t      u64))\n{\n\tstruct btrfs_root *root = fs_info->uuid_root;\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\tint ret = 0;\n\tstruct extent_buffer *leaf;\n\tint slot;\n\tu32 item_size;\n\tunsigned long offset;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tkey.objectid = 0;\n\tkey.type = 0;\n\tkey.offset = 0;\n\nagain_search_slot:\n\tret = btrfs_search_forward(root, &key, path, 0);\n\tif (ret) {\n\t\tif (ret > 0)\n\t\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\twhile (1) {\n\t\tcond_resched();\n\t\tleaf = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\n\t\tif (key.type != BTRFS_UUID_KEY_SUBVOL &&\n\t\t    key.type != BTRFS_UUID_KEY_RECEIVED_SUBVOL)\n\t\t\tgoto skip;\n\n\t\toffset = btrfs_item_ptr_offset(leaf, slot);\n\t\titem_size = btrfs_item_size_nr(leaf, slot);\n\t\tif (!IS_ALIGNED(item_size, sizeof(u64))) {\n\t\t\tbtrfs_warn(fs_info, \"uuid item with illegal size %lu!\",\n\t\t\t\t(unsigned long)item_size);\n\t\t\tgoto skip;\n\t\t}\n\t\twhile (item_size) {\n\t\t\tu8 uuid[BTRFS_UUID_SIZE];\n\t\t\t__le64 subid_le;\n\t\t\tu64 subid_cpu;\n\n\t\t\tput_unaligned_le64(key.objectid, uuid);\n\t\t\tput_unaligned_le64(key.offset, uuid + sizeof(u64));\n\t\t\tread_extent_buffer(leaf, &subid_le, offset,\n\t\t\t\t\t   sizeof(subid_le));\n\t\t\tsubid_cpu = le64_to_cpu(subid_le);\n\t\t\tret = check_func(fs_info, uuid, key.type, subid_cpu);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret > 0) {\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tret = btrfs_uuid_iter_rem(root, uuid, key.type,\n\t\t\t\t\t\t\t  subid_cpu);\n\t\t\t\tif (ret == 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * this might look inefficient, but the\n\t\t\t\t\t * justification is that it is an\n\t\t\t\t\t * exception that check_func returns 1,\n\t\t\t\t\t * and that in the regular case only one\n\t\t\t\t\t * entry per UUID exists.\n\t\t\t\t\t */\n\t\t\t\t\tgoto again_search_slot;\n\t\t\t\t}\n\t\t\t\tif (ret < 0 && ret != -ENOENT)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\titem_size -= sizeof(subid_le);\n\t\t\toffset += sizeof(subid_le);\n\t\t}\n\nskip:\n\t\tret = btrfs_next_item(root, path);\n\t\tif (ret == 0)\n\t\t\tcontinue;\n\t\telse if (ret > 0)\n\t\t\tret = 0;\n\t\tbreak;\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\tif (ret)\n\t\tbtrfs_warn(fs_info, \"btrfs_uuid_tree_iterate failed %d\", ret);\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_uuid_iter_rem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/uuid-tree.c",
    "lines": "238-256",
    "snippet": "static int btrfs_uuid_iter_rem(struct btrfs_root *uuid_root, u8 *uuid, u8 type,\n\t\t\t       u64 subid)\n{\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\n\t/* 1 - for the uuid item */\n\ttrans = btrfs_start_transaction(uuid_root, 1);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out;\n\t}\n\n\tret = btrfs_uuid_tree_rem(trans, uuid_root, uuid, type, subid);\n\tbtrfs_end_transaction(trans, uuid_root);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"print-tree.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/uuid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_end_transaction",
          "args": [
            "trans",
            "uuid_root"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_end_transaction_throttle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "846-850",
          "snippet": "int btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_uuid_tree_rem",
          "args": [
            "trans",
            "uuid_root",
            "uuid",
            "type",
            "subid"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_uuid_tree_rem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/uuid-tree.c",
          "lines": "157-236",
          "snippet": "int btrfs_uuid_tree_rem(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_root *uuid_root, u8 *uuid, u8 type,\n\t\t\tu64 subid)\n{\n\tint ret;\n\tstruct btrfs_path *path = NULL;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tunsigned long offset;\n\tu32 item_size;\n\tunsigned long move_dst;\n\tunsigned long move_src;\n\tunsigned long move_len;\n\n\tif (WARN_ON_ONCE(!uuid_root)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tbtrfs_uuid_to_key(uuid, type, &key);\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_search_slot(trans, uuid_root, &key, path, -1, 1);\n\tif (ret < 0) {\n\t\tbtrfs_warn(uuid_root->fs_info, \"error %d while searching for uuid item!\",\n\t\t\tret);\n\t\tgoto out;\n\t}\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\toffset = btrfs_item_ptr_offset(eb, slot);\n\titem_size = btrfs_item_size_nr(eb, slot);\n\tif (!IS_ALIGNED(item_size, sizeof(u64))) {\n\t\tbtrfs_warn(uuid_root->fs_info, \"uuid item with illegal size %lu!\",\n\t\t\t(unsigned long)item_size);\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\twhile (item_size) {\n\t\t__le64 read_subid;\n\n\t\tread_extent_buffer(eb, &read_subid, offset, sizeof(read_subid));\n\t\tif (le64_to_cpu(read_subid) == subid)\n\t\t\tbreak;\n\t\toffset += sizeof(read_subid);\n\t\titem_size -= sizeof(read_subid);\n\t}\n\n\tif (!item_size) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\titem_size = btrfs_item_size_nr(eb, slot);\n\tif (item_size == sizeof(subid)) {\n\t\tret = btrfs_del_item(trans, uuid_root, path);\n\t\tgoto out;\n\t}\n\n\tmove_dst = offset;\n\tmove_src = offset + sizeof(subid);\n\tmove_len = item_size - (move_src - btrfs_item_ptr_offset(eb, slot));\n\tmemmove_extent_buffer(eb, move_dst, move_src, move_len);\n\tbtrfs_truncate_item(uuid_root, path, item_size - sizeof(subid), 1);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/uuid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/uuid.h>\n\nint btrfs_uuid_tree_rem(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_root *uuid_root, u8 *uuid, u8 type,\n\t\t\tu64 subid)\n{\n\tint ret;\n\tstruct btrfs_path *path = NULL;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tunsigned long offset;\n\tu32 item_size;\n\tunsigned long move_dst;\n\tunsigned long move_src;\n\tunsigned long move_len;\n\n\tif (WARN_ON_ONCE(!uuid_root)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tbtrfs_uuid_to_key(uuid, type, &key);\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_search_slot(trans, uuid_root, &key, path, -1, 1);\n\tif (ret < 0) {\n\t\tbtrfs_warn(uuid_root->fs_info, \"error %d while searching for uuid item!\",\n\t\t\tret);\n\t\tgoto out;\n\t}\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\toffset = btrfs_item_ptr_offset(eb, slot);\n\titem_size = btrfs_item_size_nr(eb, slot);\n\tif (!IS_ALIGNED(item_size, sizeof(u64))) {\n\t\tbtrfs_warn(uuid_root->fs_info, \"uuid item with illegal size %lu!\",\n\t\t\t(unsigned long)item_size);\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\twhile (item_size) {\n\t\t__le64 read_subid;\n\n\t\tread_extent_buffer(eb, &read_subid, offset, sizeof(read_subid));\n\t\tif (le64_to_cpu(read_subid) == subid)\n\t\t\tbreak;\n\t\toffset += sizeof(read_subid);\n\t\titem_size -= sizeof(read_subid);\n\t}\n\n\tif (!item_size) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\titem_size = btrfs_item_size_nr(eb, slot);\n\tif (item_size == sizeof(subid)) {\n\t\tret = btrfs_del_item(trans, uuid_root, path);\n\t\tgoto out;\n\t}\n\n\tmove_dst = offset;\n\tmove_src = offset + sizeof(subid);\n\tmove_len = item_size - (move_src - btrfs_item_ptr_offset(eb, slot));\n\tmemmove_extent_buffer(eb, move_dst, move_src, move_len);\n\tbtrfs_truncate_item(uuid_root, path, item_size - sizeof(subid), 1);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_start_transaction",
          "args": [
            "uuid_root",
            "1"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_transaction_lflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "569-574",
          "snippet": "struct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/uuid.h>\n\nstatic int btrfs_uuid_iter_rem(struct btrfs_root *uuid_root, u8 *uuid, u8 type,\n\t\t\t       u64 subid)\n{\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\n\t/* 1 - for the uuid item */\n\ttrans = btrfs_start_transaction(uuid_root, 1);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out;\n\t}\n\n\tret = btrfs_uuid_tree_rem(trans, uuid_root, uuid, type, subid);\n\tbtrfs_end_transaction(trans, uuid_root);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_uuid_tree_rem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/uuid-tree.c",
    "lines": "157-236",
    "snippet": "int btrfs_uuid_tree_rem(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_root *uuid_root, u8 *uuid, u8 type,\n\t\t\tu64 subid)\n{\n\tint ret;\n\tstruct btrfs_path *path = NULL;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tunsigned long offset;\n\tu32 item_size;\n\tunsigned long move_dst;\n\tunsigned long move_src;\n\tunsigned long move_len;\n\n\tif (WARN_ON_ONCE(!uuid_root)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tbtrfs_uuid_to_key(uuid, type, &key);\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_search_slot(trans, uuid_root, &key, path, -1, 1);\n\tif (ret < 0) {\n\t\tbtrfs_warn(uuid_root->fs_info, \"error %d while searching for uuid item!\",\n\t\t\tret);\n\t\tgoto out;\n\t}\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\toffset = btrfs_item_ptr_offset(eb, slot);\n\titem_size = btrfs_item_size_nr(eb, slot);\n\tif (!IS_ALIGNED(item_size, sizeof(u64))) {\n\t\tbtrfs_warn(uuid_root->fs_info, \"uuid item with illegal size %lu!\",\n\t\t\t(unsigned long)item_size);\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\twhile (item_size) {\n\t\t__le64 read_subid;\n\n\t\tread_extent_buffer(eb, &read_subid, offset, sizeof(read_subid));\n\t\tif (le64_to_cpu(read_subid) == subid)\n\t\t\tbreak;\n\t\toffset += sizeof(read_subid);\n\t\titem_size -= sizeof(read_subid);\n\t}\n\n\tif (!item_size) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\titem_size = btrfs_item_size_nr(eb, slot);\n\tif (item_size == sizeof(subid)) {\n\t\tret = btrfs_del_item(trans, uuid_root, path);\n\t\tgoto out;\n\t}\n\n\tmove_dst = offset;\n\tmove_src = offset + sizeof(subid);\n\tmove_len = item_size - (move_src - btrfs_item_ptr_offset(eb, slot));\n\tmemmove_extent_buffer(eb, move_dst, move_src, move_len);\n\tbtrfs_truncate_item(uuid_root, path, item_size - sizeof(subid), 1);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"print-tree.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/uuid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_truncate_item",
          "args": [
            "uuid_root",
            "path",
            "item_size - sizeof(subid)",
            "1"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_truncate_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "4535-4629",
          "snippet": "void btrfs_truncate_item(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t u32 new_size, int from_end)\n{\n\tint slot;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_item *item;\n\tu32 nritems;\n\tunsigned int data_end;\n\tunsigned int old_data_start;\n\tunsigned int old_size;\n\tunsigned int size_diff;\n\tint i;\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\n\told_size = btrfs_item_size_nr(leaf, slot);\n\tif (old_size == new_size)\n\t\treturn;\n\n\tnritems = btrfs_header_nritems(leaf);\n\tdata_end = leaf_data_end(root, leaf);\n\n\told_data_start = btrfs_item_offset_nr(leaf, slot);\n\n\tsize_diff = old_size - new_size;\n\n\tBUG_ON(slot < 0);\n\tBUG_ON(slot >= nritems);\n\n\t/*\n\t * item0..itemN ... dataN.offset..dataN.size .. data0.size\n\t */\n\t/* first correct the data pointers */\n\tfor (i = slot; i < nritems; i++) {\n\t\tu32 ioff;\n\t\titem = btrfs_item_nr(i);\n\n\t\tioff = btrfs_token_item_offset(leaf, item, &token);\n\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t    ioff + size_diff, &token);\n\t}\n\n\t/* shift the data */\n\tif (from_end) {\n\t\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t\t      data_end + size_diff, btrfs_leaf_data(leaf) +\n\t\t\t      data_end, old_data_start + new_size - data_end);\n\t} else {\n\t\tstruct btrfs_disk_key disk_key;\n\t\tu64 offset;\n\n\t\tbtrfs_item_key(leaf, &disk_key, slot);\n\n\t\tif (btrfs_disk_key_type(&disk_key) == BTRFS_EXTENT_DATA_KEY) {\n\t\t\tunsigned long ptr;\n\t\t\tstruct btrfs_file_extent_item *fi;\n\n\t\t\tfi = btrfs_item_ptr(leaf, slot,\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\t\t\tfi = (struct btrfs_file_extent_item *)(\n\t\t\t     (unsigned long)fi - size_diff);\n\n\t\t\tif (btrfs_file_extent_type(leaf, fi) ==\n\t\t\t    BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tptr = btrfs_item_ptr_offset(leaf, slot);\n\t\t\t\tmemmove_extent_buffer(leaf, ptr,\n\t\t\t\t      (unsigned long)fi,\n\t\t\t\t      BTRFS_FILE_EXTENT_INLINE_DATA_START);\n\t\t\t}\n\t\t}\n\n\t\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t\t      data_end + size_diff, btrfs_leaf_data(leaf) +\n\t\t\t      data_end, old_data_start - data_end);\n\n\t\toffset = btrfs_disk_key_offset(&disk_key);\n\t\tbtrfs_set_disk_key_offset(&disk_key, offset + size_diff);\n\t\tbtrfs_set_item_key(leaf, &disk_key, slot);\n\t\tif (slot == 0)\n\t\t\tfixup_low_keys(root, path, &disk_key, 1);\n\t}\n\n\titem = btrfs_item_nr(slot);\n\tbtrfs_set_item_size(leaf, item, new_size);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < 0) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nvoid btrfs_truncate_item(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t u32 new_size, int from_end)\n{\n\tint slot;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_item *item;\n\tu32 nritems;\n\tunsigned int data_end;\n\tunsigned int old_data_start;\n\tunsigned int old_size;\n\tunsigned int size_diff;\n\tint i;\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\n\told_size = btrfs_item_size_nr(leaf, slot);\n\tif (old_size == new_size)\n\t\treturn;\n\n\tnritems = btrfs_header_nritems(leaf);\n\tdata_end = leaf_data_end(root, leaf);\n\n\told_data_start = btrfs_item_offset_nr(leaf, slot);\n\n\tsize_diff = old_size - new_size;\n\n\tBUG_ON(slot < 0);\n\tBUG_ON(slot >= nritems);\n\n\t/*\n\t * item0..itemN ... dataN.offset..dataN.size .. data0.size\n\t */\n\t/* first correct the data pointers */\n\tfor (i = slot; i < nritems; i++) {\n\t\tu32 ioff;\n\t\titem = btrfs_item_nr(i);\n\n\t\tioff = btrfs_token_item_offset(leaf, item, &token);\n\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t    ioff + size_diff, &token);\n\t}\n\n\t/* shift the data */\n\tif (from_end) {\n\t\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t\t      data_end + size_diff, btrfs_leaf_data(leaf) +\n\t\t\t      data_end, old_data_start + new_size - data_end);\n\t} else {\n\t\tstruct btrfs_disk_key disk_key;\n\t\tu64 offset;\n\n\t\tbtrfs_item_key(leaf, &disk_key, slot);\n\n\t\tif (btrfs_disk_key_type(&disk_key) == BTRFS_EXTENT_DATA_KEY) {\n\t\t\tunsigned long ptr;\n\t\t\tstruct btrfs_file_extent_item *fi;\n\n\t\t\tfi = btrfs_item_ptr(leaf, slot,\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\t\t\tfi = (struct btrfs_file_extent_item *)(\n\t\t\t     (unsigned long)fi - size_diff);\n\n\t\t\tif (btrfs_file_extent_type(leaf, fi) ==\n\t\t\t    BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tptr = btrfs_item_ptr_offset(leaf, slot);\n\t\t\t\tmemmove_extent_buffer(leaf, ptr,\n\t\t\t\t      (unsigned long)fi,\n\t\t\t\t      BTRFS_FILE_EXTENT_INLINE_DATA_START);\n\t\t\t}\n\t\t}\n\n\t\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t\t      data_end + size_diff, btrfs_leaf_data(leaf) +\n\t\t\t      data_end, old_data_start - data_end);\n\n\t\toffset = btrfs_disk_key_offset(&disk_key);\n\t\tbtrfs_set_disk_key_offset(&disk_key, offset + size_diff);\n\t\tbtrfs_set_item_key(leaf, &disk_key, slot);\n\t\tif (slot == 0)\n\t\t\tfixup_low_keys(root, path, &disk_key, 1);\n\t}\n\n\titem = btrfs_item_nr(slot);\n\tbtrfs_set_item_size(leaf, item, new_size);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < 0) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove_extent_buffer",
          "args": [
            "eb",
            "move_dst",
            "move_src",
            "move_len"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "memmove_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5521-5566",
          "snippet": "void memmove_extent_buffer(struct extent_buffer *dst, unsigned long dst_offset,\n\t\t\t   unsigned long src_offset, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t dst_off_in_page;\n\tsize_t src_off_in_page;\n\tunsigned long dst_end = dst_offset + len - 1;\n\tunsigned long src_end = src_offset + len - 1;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long dst_i;\n\tunsigned long src_i;\n\n\tif (src_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus src_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", src_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus dst_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", dst_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset < src_offset) {\n\t\tmemcpy_extent_buffer(dst, dst_offset, src_offset, len);\n\t\treturn;\n\t}\n\twhile (len > 0) {\n\t\tdst_i = (start_offset + dst_end) >> PAGE_CACHE_SHIFT;\n\t\tsrc_i = (start_offset + src_end) >> PAGE_CACHE_SHIFT;\n\n\t\tdst_off_in_page = (start_offset + dst_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\t\tsrc_off_in_page = (start_offset + src_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\n\t\tcur = min_t(unsigned long, len, src_off_in_page + 1);\n\t\tcur = min(cur, dst_off_in_page + 1);\n\t\tcopy_pages(dst->pages[dst_i], dst->pages[src_i],\n\t\t\t   dst_off_in_page - cur + 1,\n\t\t\t   src_off_in_page - cur + 1, cur);\n\n\t\tdst_end -= cur;\n\t\tsrc_end -= cur;\n\t\tlen -= cur;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid memmove_extent_buffer(struct extent_buffer *dst, unsigned long dst_offset,\n\t\t\t   unsigned long src_offset, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t dst_off_in_page;\n\tsize_t src_off_in_page;\n\tunsigned long dst_end = dst_offset + len - 1;\n\tunsigned long src_end = src_offset + len - 1;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long dst_i;\n\tunsigned long src_i;\n\n\tif (src_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus src_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", src_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus dst_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", dst_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset < src_offset) {\n\t\tmemcpy_extent_buffer(dst, dst_offset, src_offset, len);\n\t\treturn;\n\t}\n\twhile (len > 0) {\n\t\tdst_i = (start_offset + dst_end) >> PAGE_CACHE_SHIFT;\n\t\tsrc_i = (start_offset + src_end) >> PAGE_CACHE_SHIFT;\n\n\t\tdst_off_in_page = (start_offset + dst_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\t\tsrc_off_in_page = (start_offset + src_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\n\t\tcur = min_t(unsigned long, len, src_off_in_page + 1);\n\t\tcur = min(cur, dst_off_in_page + 1);\n\t\tcopy_pages(dst->pages[dst_i], dst->pages[src_i],\n\t\t\t   dst_off_in_page - cur + 1,\n\t\t\t   src_off_in_page - cur + 1, cur);\n\n\t\tdst_end -= cur;\n\t\tsrc_end -= cur;\n\t\tlen -= cur;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr_offset",
          "args": [
            "eb",
            "slot"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_del_item",
          "args": [
            "trans",
            "uuid_root",
            "path"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_del_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3562-3567",
          "snippet": "static inline int btrfs_del_item(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root,\n\t\t\t\t struct btrfs_path *path)\n{\n\treturn btrfs_del_items(trans, root, path, path->slots[0], 1);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_del_item(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root,\n\t\t\t\t struct btrfs_path *path)\n{\n\treturn btrfs_del_items(trans, root, path, path->slots[0], 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_size_nr",
          "args": [
            "eb",
            "slot"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "read_subid"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_extent_buffer",
          "args": [
            "eb",
            "&read_subid",
            "offset",
            "sizeof(read_subid)"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "btree_read_extent_buffer_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "442-497",
          "snippet": "static int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_warn",
          "args": [
            "uuid_root->fs_info",
            "\"uuid item with illegal size %lu!\"",
            "(unsigned long)item_size"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "item_size",
            "sizeof(u64)"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr_offset",
          "args": [
            "eb",
            "slot"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_warn",
          "args": [
            "uuid_root->fs_info",
            "\"error %d while searching for uuid item!\"",
            "ret"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "trans",
            "uuid_root",
            "&key",
            "path",
            "-1",
            "1"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_uuid_to_key",
          "args": [
            "uuid",
            "type",
            "&key"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_uuid_to_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/uuid-tree.c",
          "lines": "26-31",
          "snippet": "static void btrfs_uuid_to_key(u8 *uuid, u8 type, struct btrfs_key *key)\n{\n\tkey->type = type;\n\tkey->objectid = get_unaligned_le64(uuid);\n\tkey->offset = get_unaligned_le64(uuid + sizeof(u64));\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/uuid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/uuid.h>\n\nstatic void btrfs_uuid_to_key(u8 *uuid, u8 type, struct btrfs_key *key)\n{\n\tkey->type = type;\n\tkey->objectid = get_unaligned_le64(uuid);\n\tkey->offset = get_unaligned_le64(uuid + sizeof(u64));\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!uuid_root"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/uuid.h>\n\nint btrfs_uuid_tree_rem(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_root *uuid_root, u8 *uuid, u8 type,\n\t\t\tu64 subid)\n{\n\tint ret;\n\tstruct btrfs_path *path = NULL;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tunsigned long offset;\n\tu32 item_size;\n\tunsigned long move_dst;\n\tunsigned long move_src;\n\tunsigned long move_len;\n\n\tif (WARN_ON_ONCE(!uuid_root)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tbtrfs_uuid_to_key(uuid, type, &key);\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_search_slot(trans, uuid_root, &key, path, -1, 1);\n\tif (ret < 0) {\n\t\tbtrfs_warn(uuid_root->fs_info, \"error %d while searching for uuid item!\",\n\t\t\tret);\n\t\tgoto out;\n\t}\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\toffset = btrfs_item_ptr_offset(eb, slot);\n\titem_size = btrfs_item_size_nr(eb, slot);\n\tif (!IS_ALIGNED(item_size, sizeof(u64))) {\n\t\tbtrfs_warn(uuid_root->fs_info, \"uuid item with illegal size %lu!\",\n\t\t\t(unsigned long)item_size);\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\twhile (item_size) {\n\t\t__le64 read_subid;\n\n\t\tread_extent_buffer(eb, &read_subid, offset, sizeof(read_subid));\n\t\tif (le64_to_cpu(read_subid) == subid)\n\t\t\tbreak;\n\t\toffset += sizeof(read_subid);\n\t\titem_size -= sizeof(read_subid);\n\t}\n\n\tif (!item_size) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\titem_size = btrfs_item_size_nr(eb, slot);\n\tif (item_size == sizeof(subid)) {\n\t\tret = btrfs_del_item(trans, uuid_root, path);\n\t\tgoto out;\n\t}\n\n\tmove_dst = offset;\n\tmove_src = offset + sizeof(subid);\n\tmove_len = item_size - (move_src - btrfs_item_ptr_offset(eb, slot));\n\tmemmove_extent_buffer(eb, move_dst, move_src, move_len);\n\tbtrfs_truncate_item(uuid_root, path, item_size - sizeof(subid), 1);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_uuid_tree_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/uuid-tree.c",
    "lines": "93-155",
    "snippet": "int btrfs_uuid_tree_add(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_root *uuid_root, u8 *uuid, u8 type,\n\t\t\tu64 subid_cpu)\n{\n\tint ret;\n\tstruct btrfs_path *path = NULL;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tunsigned long offset;\n\t__le64 subid_le;\n\n\tret = btrfs_uuid_tree_lookup(uuid_root, uuid, type, subid_cpu);\n\tif (ret != -ENOENT)\n\t\treturn ret;\n\n\tif (WARN_ON_ONCE(!uuid_root)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tbtrfs_uuid_to_key(uuid, type, &key);\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_insert_empty_item(trans, uuid_root, path, &key,\n\t\t\t\t      sizeof(subid_le));\n\tif (ret >= 0) {\n\t\t/* Add an item for the type for the first time */\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\toffset = btrfs_item_ptr_offset(eb, slot);\n\t} else if (ret == -EEXIST) {\n\t\t/*\n\t\t * An item with that type already exists.\n\t\t * Extend the item and store the new subid at the end.\n\t\t */\n\t\tbtrfs_extend_item(uuid_root, path, sizeof(subid_le));\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\toffset = btrfs_item_ptr_offset(eb, slot);\n\t\toffset += btrfs_item_size_nr(eb, slot) - sizeof(subid_le);\n\t} else if (ret < 0) {\n\t\tbtrfs_warn(uuid_root->fs_info, \"insert uuid item failed %d \"\n\t\t\t\"(0x%016llx, 0x%016llx) type %u!\",\n\t\t\tret, (unsigned long long)key.objectid,\n\t\t\t(unsigned long long)key.offset, type);\n\t\tgoto out;\n\t}\n\n\tret = 0;\n\tsubid_le = cpu_to_le64(subid_cpu);\n\twrite_extent_buffer(eb, &subid_le, offset, sizeof(subid_le));\n\tbtrfs_mark_buffer_dirty(eb);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"print-tree.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/uuid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "eb"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_extent_buffer",
          "args": [
            "eb",
            "&subid_le",
            "offset",
            "sizeof(subid_le)"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "write_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5356-5385",
          "snippet": "void write_extent_buffer(struct extent_buffer *eb, const void *srcv,\n\t\t\t unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *src = (char *)srcv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemcpy(kaddr + offset, src, cur);\n\n\t\tsrc += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid write_extent_buffer(struct extent_buffer *eb, const void *srcv,\n\t\t\t unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *src = (char *)srcv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemcpy(kaddr + offset, src, cur);\n\n\t\tsrc += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "subid_cpu"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_warn",
          "args": [
            "uuid_root->fs_info",
            "\"insert uuid item failed %d \"\n\t\t\t\"(0x%016llx, 0x%016llx) type %u!\"",
            "ret",
            "(unsigned long long)key.objectid",
            "(unsigned long long)key.offset",
            "type"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_size_nr",
          "args": [
            "eb",
            "slot"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr_offset",
          "args": [
            "eb",
            "slot"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_extend_item",
          "args": [
            "uuid_root",
            "path",
            "sizeof(subid_le)"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_extend_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "4634-4697",
          "snippet": "void btrfs_extend_item(struct btrfs_root *root, struct btrfs_path *path,\n\t\t       u32 data_size)\n{\n\tint slot;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_item *item;\n\tu32 nritems;\n\tunsigned int data_end;\n\tunsigned int old_data;\n\tunsigned int old_size;\n\tint i;\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\n\tleaf = path->nodes[0];\n\n\tnritems = btrfs_header_nritems(leaf);\n\tdata_end = leaf_data_end(root, leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < data_size) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tBUG();\n\t}\n\tslot = path->slots[0];\n\told_data = btrfs_item_end_nr(leaf, slot);\n\n\tBUG_ON(slot < 0);\n\tif (slot >= nritems) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tbtrfs_crit(root->fs_info, \"slot %d too large, nritems %d\",\n\t\t       slot, nritems);\n\t\tBUG_ON(1);\n\t}\n\n\t/*\n\t * item0..itemN ... dataN.offset..dataN.size .. data0.size\n\t */\n\t/* first correct the data pointers */\n\tfor (i = slot; i < nritems; i++) {\n\t\tu32 ioff;\n\t\titem = btrfs_item_nr(i);\n\n\t\tioff = btrfs_token_item_offset(leaf, item, &token);\n\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t    ioff - data_size, &token);\n\t}\n\n\t/* shift the data */\n\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t      data_end - data_size, btrfs_leaf_data(leaf) +\n\t\t      data_end, old_data - data_end);\n\n\tdata_end = old_data;\n\told_size = btrfs_item_size_nr(leaf, slot);\n\titem = btrfs_item_nr(slot);\n\tbtrfs_set_item_size(leaf, item, old_size + data_size);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < 0) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nvoid btrfs_extend_item(struct btrfs_root *root, struct btrfs_path *path,\n\t\t       u32 data_size)\n{\n\tint slot;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_item *item;\n\tu32 nritems;\n\tunsigned int data_end;\n\tunsigned int old_data;\n\tunsigned int old_size;\n\tint i;\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\n\tleaf = path->nodes[0];\n\n\tnritems = btrfs_header_nritems(leaf);\n\tdata_end = leaf_data_end(root, leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < data_size) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tBUG();\n\t}\n\tslot = path->slots[0];\n\told_data = btrfs_item_end_nr(leaf, slot);\n\n\tBUG_ON(slot < 0);\n\tif (slot >= nritems) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tbtrfs_crit(root->fs_info, \"slot %d too large, nritems %d\",\n\t\t       slot, nritems);\n\t\tBUG_ON(1);\n\t}\n\n\t/*\n\t * item0..itemN ... dataN.offset..dataN.size .. data0.size\n\t */\n\t/* first correct the data pointers */\n\tfor (i = slot; i < nritems; i++) {\n\t\tu32 ioff;\n\t\titem = btrfs_item_nr(i);\n\n\t\tioff = btrfs_token_item_offset(leaf, item, &token);\n\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t    ioff - data_size, &token);\n\t}\n\n\t/* shift the data */\n\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t      data_end - data_size, btrfs_leaf_data(leaf) +\n\t\t      data_end, old_data - data_end);\n\n\tdata_end = old_data;\n\told_size = btrfs_item_size_nr(leaf, slot);\n\titem = btrfs_item_nr(slot);\n\tbtrfs_set_item_size(leaf, item, old_size + data_size);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < 0) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr_offset",
          "args": [
            "eb",
            "slot"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_insert_empty_item",
          "args": [
            "trans",
            "uuid_root",
            "path",
            "&key",
            "sizeof(subid_le)"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_empty_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3579-3586",
          "snippet": "static inline int btrfs_insert_empty_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  struct btrfs_key *key,\n\t\t\t\t\t  u32 data_size)\n{\n\treturn btrfs_insert_empty_items(trans, root, path, key, &data_size, 1);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_insert_empty_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  struct btrfs_key *key,\n\t\t\t\t\t  u32 data_size)\n{\n\treturn btrfs_insert_empty_items(trans, root, path, key, &data_size, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_uuid_to_key",
          "args": [
            "uuid",
            "type",
            "&key"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_uuid_to_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/uuid-tree.c",
          "lines": "26-31",
          "snippet": "static void btrfs_uuid_to_key(u8 *uuid, u8 type, struct btrfs_key *key)\n{\n\tkey->type = type;\n\tkey->objectid = get_unaligned_le64(uuid);\n\tkey->offset = get_unaligned_le64(uuid + sizeof(u64));\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/uuid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/uuid.h>\n\nstatic void btrfs_uuid_to_key(u8 *uuid, u8 type, struct btrfs_key *key)\n{\n\tkey->type = type;\n\tkey->objectid = get_unaligned_le64(uuid);\n\tkey->offset = get_unaligned_le64(uuid + sizeof(u64));\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!uuid_root"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_uuid_tree_lookup",
          "args": [
            "uuid_root",
            "uuid",
            "type",
            "subid_cpu"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_uuid_tree_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/uuid-tree.c",
          "lines": "34-91",
          "snippet": "static int btrfs_uuid_tree_lookup(struct btrfs_root *uuid_root, u8 *uuid,\n\t\t\t\t  u8 type, u64 subid)\n{\n\tint ret;\n\tstruct btrfs_path *path = NULL;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tu32 item_size;\n\tunsigned long offset;\n\tstruct btrfs_key key;\n\n\tif (WARN_ON_ONCE(!uuid_root)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tbtrfs_uuid_to_key(uuid, type, &key);\n\tret = btrfs_search_slot(NULL, uuid_root, &key, path, 0, 0);\n\tif (ret < 0) {\n\t\tgoto out;\n\t} else if (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\titem_size = btrfs_item_size_nr(eb, slot);\n\toffset = btrfs_item_ptr_offset(eb, slot);\n\tret = -ENOENT;\n\n\tif (!IS_ALIGNED(item_size, sizeof(u64))) {\n\t\tbtrfs_warn(uuid_root->fs_info, \"uuid item with illegal size %lu!\",\n\t\t\t(unsigned long)item_size);\n\t\tgoto out;\n\t}\n\twhile (item_size) {\n\t\t__le64 data;\n\n\t\tread_extent_buffer(eb, &data, offset, sizeof(data));\n\t\tif (le64_to_cpu(data) == subid) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\toffset += sizeof(data);\n\t\titem_size -= sizeof(data);\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/uuid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/uuid.h>\n\nstatic int btrfs_uuid_tree_lookup(struct btrfs_root *uuid_root, u8 *uuid,\n\t\t\t\t  u8 type, u64 subid)\n{\n\tint ret;\n\tstruct btrfs_path *path = NULL;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tu32 item_size;\n\tunsigned long offset;\n\tstruct btrfs_key key;\n\n\tif (WARN_ON_ONCE(!uuid_root)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tbtrfs_uuid_to_key(uuid, type, &key);\n\tret = btrfs_search_slot(NULL, uuid_root, &key, path, 0, 0);\n\tif (ret < 0) {\n\t\tgoto out;\n\t} else if (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\titem_size = btrfs_item_size_nr(eb, slot);\n\toffset = btrfs_item_ptr_offset(eb, slot);\n\tret = -ENOENT;\n\n\tif (!IS_ALIGNED(item_size, sizeof(u64))) {\n\t\tbtrfs_warn(uuid_root->fs_info, \"uuid item with illegal size %lu!\",\n\t\t\t(unsigned long)item_size);\n\t\tgoto out;\n\t}\n\twhile (item_size) {\n\t\t__le64 data;\n\n\t\tread_extent_buffer(eb, &data, offset, sizeof(data));\n\t\tif (le64_to_cpu(data) == subid) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\toffset += sizeof(data);\n\t\titem_size -= sizeof(data);\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/uuid.h>\n\nint btrfs_uuid_tree_add(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_root *uuid_root, u8 *uuid, u8 type,\n\t\t\tu64 subid_cpu)\n{\n\tint ret;\n\tstruct btrfs_path *path = NULL;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tunsigned long offset;\n\t__le64 subid_le;\n\n\tret = btrfs_uuid_tree_lookup(uuid_root, uuid, type, subid_cpu);\n\tif (ret != -ENOENT)\n\t\treturn ret;\n\n\tif (WARN_ON_ONCE(!uuid_root)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tbtrfs_uuid_to_key(uuid, type, &key);\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_insert_empty_item(trans, uuid_root, path, &key,\n\t\t\t\t      sizeof(subid_le));\n\tif (ret >= 0) {\n\t\t/* Add an item for the type for the first time */\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\toffset = btrfs_item_ptr_offset(eb, slot);\n\t} else if (ret == -EEXIST) {\n\t\t/*\n\t\t * An item with that type already exists.\n\t\t * Extend the item and store the new subid at the end.\n\t\t */\n\t\tbtrfs_extend_item(uuid_root, path, sizeof(subid_le));\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\toffset = btrfs_item_ptr_offset(eb, slot);\n\t\toffset += btrfs_item_size_nr(eb, slot) - sizeof(subid_le);\n\t} else if (ret < 0) {\n\t\tbtrfs_warn(uuid_root->fs_info, \"insert uuid item failed %d \"\n\t\t\t\"(0x%016llx, 0x%016llx) type %u!\",\n\t\t\tret, (unsigned long long)key.objectid,\n\t\t\t(unsigned long long)key.offset, type);\n\t\tgoto out;\n\t}\n\n\tret = 0;\n\tsubid_le = cpu_to_le64(subid_cpu);\n\twrite_extent_buffer(eb, &subid_le, offset, sizeof(subid_le));\n\tbtrfs_mark_buffer_dirty(eb);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_uuid_tree_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/uuid-tree.c",
    "lines": "34-91",
    "snippet": "static int btrfs_uuid_tree_lookup(struct btrfs_root *uuid_root, u8 *uuid,\n\t\t\t\t  u8 type, u64 subid)\n{\n\tint ret;\n\tstruct btrfs_path *path = NULL;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tu32 item_size;\n\tunsigned long offset;\n\tstruct btrfs_key key;\n\n\tif (WARN_ON_ONCE(!uuid_root)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tbtrfs_uuid_to_key(uuid, type, &key);\n\tret = btrfs_search_slot(NULL, uuid_root, &key, path, 0, 0);\n\tif (ret < 0) {\n\t\tgoto out;\n\t} else if (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\titem_size = btrfs_item_size_nr(eb, slot);\n\toffset = btrfs_item_ptr_offset(eb, slot);\n\tret = -ENOENT;\n\n\tif (!IS_ALIGNED(item_size, sizeof(u64))) {\n\t\tbtrfs_warn(uuid_root->fs_info, \"uuid item with illegal size %lu!\",\n\t\t\t(unsigned long)item_size);\n\t\tgoto out;\n\t}\n\twhile (item_size) {\n\t\t__le64 data;\n\n\t\tread_extent_buffer(eb, &data, offset, sizeof(data));\n\t\tif (le64_to_cpu(data) == subid) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\toffset += sizeof(data);\n\t\titem_size -= sizeof(data);\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"print-tree.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/uuid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "data"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_extent_buffer",
          "args": [
            "eb",
            "&data",
            "offset",
            "sizeof(data)"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "btree_read_extent_buffer_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "442-497",
          "snippet": "static int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_warn",
          "args": [
            "uuid_root->fs_info",
            "\"uuid item with illegal size %lu!\"",
            "(unsigned long)item_size"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "item_size",
            "sizeof(u64)"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr_offset",
          "args": [
            "eb",
            "slot"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_size_nr",
          "args": [
            "eb",
            "slot"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "uuid_root",
            "&key",
            "path",
            "0",
            "0"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_uuid_to_key",
          "args": [
            "uuid",
            "type",
            "&key"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_uuid_to_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/uuid-tree.c",
          "lines": "26-31",
          "snippet": "static void btrfs_uuid_to_key(u8 *uuid, u8 type, struct btrfs_key *key)\n{\n\tkey->type = type;\n\tkey->objectid = get_unaligned_le64(uuid);\n\tkey->offset = get_unaligned_le64(uuid + sizeof(u64));\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/uuid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/uuid.h>\n\nstatic void btrfs_uuid_to_key(u8 *uuid, u8 type, struct btrfs_key *key)\n{\n\tkey->type = type;\n\tkey->objectid = get_unaligned_le64(uuid);\n\tkey->offset = get_unaligned_le64(uuid + sizeof(u64));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!uuid_root"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/uuid.h>\n\nstatic int btrfs_uuid_tree_lookup(struct btrfs_root *uuid_root, u8 *uuid,\n\t\t\t\t  u8 type, u64 subid)\n{\n\tint ret;\n\tstruct btrfs_path *path = NULL;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tu32 item_size;\n\tunsigned long offset;\n\tstruct btrfs_key key;\n\n\tif (WARN_ON_ONCE(!uuid_root)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tbtrfs_uuid_to_key(uuid, type, &key);\n\tret = btrfs_search_slot(NULL, uuid_root, &key, path, 0, 0);\n\tif (ret < 0) {\n\t\tgoto out;\n\t} else if (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\titem_size = btrfs_item_size_nr(eb, slot);\n\toffset = btrfs_item_ptr_offset(eb, slot);\n\tret = -ENOENT;\n\n\tif (!IS_ALIGNED(item_size, sizeof(u64))) {\n\t\tbtrfs_warn(uuid_root->fs_info, \"uuid item with illegal size %lu!\",\n\t\t\t(unsigned long)item_size);\n\t\tgoto out;\n\t}\n\twhile (item_size) {\n\t\t__le64 data;\n\n\t\tread_extent_buffer(eb, &data, offset, sizeof(data));\n\t\tif (le64_to_cpu(data) == subid) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\toffset += sizeof(data);\n\t\titem_size -= sizeof(data);\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_uuid_to_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/uuid-tree.c",
    "lines": "26-31",
    "snippet": "static void btrfs_uuid_to_key(u8 *uuid, u8 type, struct btrfs_key *key)\n{\n\tkey->type = type;\n\tkey->objectid = get_unaligned_le64(uuid);\n\tkey->offset = get_unaligned_le64(uuid + sizeof(u64));\n}",
    "includes": [
      "#include \"print-tree.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <asm/unaligned.h>",
      "#include <linux/uuid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_unaligned_le64",
          "args": [
            "uuid + sizeof(u64)"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_unaligned_le64",
          "args": [
            "uuid"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/uuid.h>\n\nstatic void btrfs_uuid_to_key(u8 *uuid, u8 type, struct btrfs_key *key)\n{\n\tkey->type = type;\n\tkey->objectid = get_unaligned_le64(uuid);\n\tkey->offset = get_unaligned_le64(uuid + sizeof(u64));\n}"
  }
]