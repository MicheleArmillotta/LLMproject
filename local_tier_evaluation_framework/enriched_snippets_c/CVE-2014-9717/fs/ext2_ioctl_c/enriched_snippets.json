[
  {
    "function_name": "ext2_compat_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ioctl.c",
    "lines": "167-187",
    "snippet": "long ext2_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\t/* These are just misnamed, they actually get/put from/to user an int */\n\tswitch (cmd) {\n\tcase EXT2_IOC32_GETFLAGS:\n\t\tcmd = EXT2_IOC_GETFLAGS;\n\t\tbreak;\n\tcase EXT2_IOC32_SETFLAGS:\n\t\tcmd = EXT2_IOC_SETFLAGS;\n\t\tbreak;\n\tcase EXT2_IOC32_GETVERSION:\n\t\tcmd = EXT2_IOC_GETVERSION;\n\t\tbreak;\n\tcase EXT2_IOC32_SETVERSION:\n\t\tcmd = EXT2_IOC_SETVERSION;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\treturn ext2_ioctl(file, cmd, (unsigned long) compat_ptr(arg));\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <asm/current.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/capability.h>",
      "#include \"ext2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext2_ioctl",
          "args": [
            "file",
            "cmd",
            "(unsigned long) compat_ptr(arg)"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ioctl.c",
          "lines": "20-164",
          "snippet": "long ext2_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct ext2_inode_info *ei = EXT2_I(inode);\n\tunsigned int flags;\n\tunsigned short rsv_window_size;\n\tint ret;\n\n\text2_debug (\"cmd = %u, arg = %lu\\n\", cmd, arg);\n\n\tswitch (cmd) {\n\tcase EXT2_IOC_GETFLAGS:\n\t\text2_get_inode_flags(ei);\n\t\tflags = ei->i_flags & EXT2_FL_USER_VISIBLE;\n\t\treturn put_user(flags, (int __user *) arg);\n\tcase EXT2_IOC_SETFLAGS: {\n\t\tunsigned int oldflags;\n\n\t\tret = mnt_want_write_file(filp);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (!inode_owner_or_capable(inode)) {\n\t\t\tret = -EACCES;\n\t\t\tgoto setflags_out;\n\t\t}\n\n\t\tif (get_user(flags, (int __user *) arg)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto setflags_out;\n\t\t}\n\n\t\tflags = ext2_mask_flags(inode->i_mode, flags);\n\n\t\tmutex_lock(&inode->i_mutex);\n\t\t/* Is it quota file? Do not allow user to mess with it */\n\t\tif (IS_NOQUOTA(inode)) {\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\tret = -EPERM;\n\t\t\tgoto setflags_out;\n\t\t}\n\t\toldflags = ei->i_flags;\n\n\t\t/*\n\t\t * The IMMUTABLE and APPEND_ONLY flags can only be changed by\n\t\t * the relevant capability.\n\t\t *\n\t\t * This test looks nicer. Thanks to Pauline Middelink\n\t\t */\n\t\tif ((flags ^ oldflags) & (EXT2_APPEND_FL | EXT2_IMMUTABLE_FL)) {\n\t\t\tif (!capable(CAP_LINUX_IMMUTABLE)) {\n\t\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\t\tret = -EPERM;\n\t\t\t\tgoto setflags_out;\n\t\t\t}\n\t\t}\n\n\t\tflags = flags & EXT2_FL_USER_MODIFIABLE;\n\t\tflags |= oldflags & ~EXT2_FL_USER_MODIFIABLE;\n\t\tei->i_flags = flags;\n\n\t\text2_set_inode_flags(inode);\n\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\tmutex_unlock(&inode->i_mutex);\n\n\t\tmark_inode_dirty(inode);\nsetflags_out:\n\t\tmnt_drop_write_file(filp);\n\t\treturn ret;\n\t}\n\tcase EXT2_IOC_GETVERSION:\n\t\treturn put_user(inode->i_generation, (int __user *) arg);\n\tcase EXT2_IOC_SETVERSION: {\n\t\t__u32 generation;\n\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\tret = mnt_want_write_file(filp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (get_user(generation, (int __user *) arg)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto setversion_out;\n\t\t}\n\n\t\tmutex_lock(&inode->i_mutex);\n\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\tinode->i_generation = generation;\n\t\tmutex_unlock(&inode->i_mutex);\n\n\t\tmark_inode_dirty(inode);\nsetversion_out:\n\t\tmnt_drop_write_file(filp);\n\t\treturn ret;\n\t}\n\tcase EXT2_IOC_GETRSVSZ:\n\t\tif (test_opt(inode->i_sb, RESERVATION)\n\t\t\t&& S_ISREG(inode->i_mode)\n\t\t\t&& ei->i_block_alloc_info) {\n\t\t\trsv_window_size = ei->i_block_alloc_info->rsv_window_node.rsv_goal_size;\n\t\t\treturn put_user(rsv_window_size, (int __user *)arg);\n\t\t}\n\t\treturn -ENOTTY;\n\tcase EXT2_IOC_SETRSVSZ: {\n\n\t\tif (!test_opt(inode->i_sb, RESERVATION) ||!S_ISREG(inode->i_mode))\n\t\t\treturn -ENOTTY;\n\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EACCES;\n\n\t\tif (get_user(rsv_window_size, (int __user *)arg))\n\t\t\treturn -EFAULT;\n\n\t\tret = mnt_want_write_file(filp);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (rsv_window_size > EXT2_MAX_RESERVE_BLOCKS)\n\t\t\trsv_window_size = EXT2_MAX_RESERVE_BLOCKS;\n\n\t\t/*\n\t\t * need to allocate reservation structure for this inode\n\t\t * before set the window size\n\t\t */\n\t\t/*\n\t\t * XXX What lock should protect the rsv_goal_size?\n\t\t * Accessed in ext2_get_block only.  ext3 uses i_truncate.\n\t\t */\n\t\tmutex_lock(&ei->truncate_mutex);\n\t\tif (!ei->i_block_alloc_info)\n\t\t\text2_init_block_alloc_info(inode);\n\n\t\tif (ei->i_block_alloc_info){\n\t\t\tstruct ext2_reserve_window_node *rsv = &ei->i_block_alloc_info->rsv_window_node;\n\t\t\trsv->rsv_goal_size = rsv_window_size;\n\t\t}\n\t\tmutex_unlock(&ei->truncate_mutex);\n\t\tmnt_drop_write_file(filp);\n\t\treturn 0;\n\t}\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/capability.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/capability.h>\n#include \"ext2.h\"\n\nlong ext2_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct ext2_inode_info *ei = EXT2_I(inode);\n\tunsigned int flags;\n\tunsigned short rsv_window_size;\n\tint ret;\n\n\text2_debug (\"cmd = %u, arg = %lu\\n\", cmd, arg);\n\n\tswitch (cmd) {\n\tcase EXT2_IOC_GETFLAGS:\n\t\text2_get_inode_flags(ei);\n\t\tflags = ei->i_flags & EXT2_FL_USER_VISIBLE;\n\t\treturn put_user(flags, (int __user *) arg);\n\tcase EXT2_IOC_SETFLAGS: {\n\t\tunsigned int oldflags;\n\n\t\tret = mnt_want_write_file(filp);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (!inode_owner_or_capable(inode)) {\n\t\t\tret = -EACCES;\n\t\t\tgoto setflags_out;\n\t\t}\n\n\t\tif (get_user(flags, (int __user *) arg)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto setflags_out;\n\t\t}\n\n\t\tflags = ext2_mask_flags(inode->i_mode, flags);\n\n\t\tmutex_lock(&inode->i_mutex);\n\t\t/* Is it quota file? Do not allow user to mess with it */\n\t\tif (IS_NOQUOTA(inode)) {\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\tret = -EPERM;\n\t\t\tgoto setflags_out;\n\t\t}\n\t\toldflags = ei->i_flags;\n\n\t\t/*\n\t\t * The IMMUTABLE and APPEND_ONLY flags can only be changed by\n\t\t * the relevant capability.\n\t\t *\n\t\t * This test looks nicer. Thanks to Pauline Middelink\n\t\t */\n\t\tif ((flags ^ oldflags) & (EXT2_APPEND_FL | EXT2_IMMUTABLE_FL)) {\n\t\t\tif (!capable(CAP_LINUX_IMMUTABLE)) {\n\t\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\t\tret = -EPERM;\n\t\t\t\tgoto setflags_out;\n\t\t\t}\n\t\t}\n\n\t\tflags = flags & EXT2_FL_USER_MODIFIABLE;\n\t\tflags |= oldflags & ~EXT2_FL_USER_MODIFIABLE;\n\t\tei->i_flags = flags;\n\n\t\text2_set_inode_flags(inode);\n\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\tmutex_unlock(&inode->i_mutex);\n\n\t\tmark_inode_dirty(inode);\nsetflags_out:\n\t\tmnt_drop_write_file(filp);\n\t\treturn ret;\n\t}\n\tcase EXT2_IOC_GETVERSION:\n\t\treturn put_user(inode->i_generation, (int __user *) arg);\n\tcase EXT2_IOC_SETVERSION: {\n\t\t__u32 generation;\n\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\tret = mnt_want_write_file(filp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (get_user(generation, (int __user *) arg)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto setversion_out;\n\t\t}\n\n\t\tmutex_lock(&inode->i_mutex);\n\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\tinode->i_generation = generation;\n\t\tmutex_unlock(&inode->i_mutex);\n\n\t\tmark_inode_dirty(inode);\nsetversion_out:\n\t\tmnt_drop_write_file(filp);\n\t\treturn ret;\n\t}\n\tcase EXT2_IOC_GETRSVSZ:\n\t\tif (test_opt(inode->i_sb, RESERVATION)\n\t\t\t&& S_ISREG(inode->i_mode)\n\t\t\t&& ei->i_block_alloc_info) {\n\t\t\trsv_window_size = ei->i_block_alloc_info->rsv_window_node.rsv_goal_size;\n\t\t\treturn put_user(rsv_window_size, (int __user *)arg);\n\t\t}\n\t\treturn -ENOTTY;\n\tcase EXT2_IOC_SETRSVSZ: {\n\n\t\tif (!test_opt(inode->i_sb, RESERVATION) ||!S_ISREG(inode->i_mode))\n\t\t\treturn -ENOTTY;\n\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EACCES;\n\n\t\tif (get_user(rsv_window_size, (int __user *)arg))\n\t\t\treturn -EFAULT;\n\n\t\tret = mnt_want_write_file(filp);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (rsv_window_size > EXT2_MAX_RESERVE_BLOCKS)\n\t\t\trsv_window_size = EXT2_MAX_RESERVE_BLOCKS;\n\n\t\t/*\n\t\t * need to allocate reservation structure for this inode\n\t\t * before set the window size\n\t\t */\n\t\t/*\n\t\t * XXX What lock should protect the rsv_goal_size?\n\t\t * Accessed in ext2_get_block only.  ext3 uses i_truncate.\n\t\t */\n\t\tmutex_lock(&ei->truncate_mutex);\n\t\tif (!ei->i_block_alloc_info)\n\t\t\text2_init_block_alloc_info(inode);\n\n\t\tif (ei->i_block_alloc_info){\n\t\t\tstruct ext2_reserve_window_node *rsv = &ei->i_block_alloc_info->rsv_window_node;\n\t\t\trsv->rsv_goal_size = rsv_window_size;\n\t\t}\n\t\tmutex_unlock(&ei->truncate_mutex);\n\t\tmnt_drop_write_file(filp);\n\t\treturn 0;\n\t}\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "arg"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/capability.h>\n#include \"ext2.h\"\n\nlong ext2_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\t/* These are just misnamed, they actually get/put from/to user an int */\n\tswitch (cmd) {\n\tcase EXT2_IOC32_GETFLAGS:\n\t\tcmd = EXT2_IOC_GETFLAGS;\n\t\tbreak;\n\tcase EXT2_IOC32_SETFLAGS:\n\t\tcmd = EXT2_IOC_SETFLAGS;\n\t\tbreak;\n\tcase EXT2_IOC32_GETVERSION:\n\t\tcmd = EXT2_IOC_GETVERSION;\n\t\tbreak;\n\tcase EXT2_IOC32_SETVERSION:\n\t\tcmd = EXT2_IOC_SETVERSION;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\treturn ext2_ioctl(file, cmd, (unsigned long) compat_ptr(arg));\n}"
  },
  {
    "function_name": "ext2_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ioctl.c",
    "lines": "20-164",
    "snippet": "long ext2_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct ext2_inode_info *ei = EXT2_I(inode);\n\tunsigned int flags;\n\tunsigned short rsv_window_size;\n\tint ret;\n\n\text2_debug (\"cmd = %u, arg = %lu\\n\", cmd, arg);\n\n\tswitch (cmd) {\n\tcase EXT2_IOC_GETFLAGS:\n\t\text2_get_inode_flags(ei);\n\t\tflags = ei->i_flags & EXT2_FL_USER_VISIBLE;\n\t\treturn put_user(flags, (int __user *) arg);\n\tcase EXT2_IOC_SETFLAGS: {\n\t\tunsigned int oldflags;\n\n\t\tret = mnt_want_write_file(filp);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (!inode_owner_or_capable(inode)) {\n\t\t\tret = -EACCES;\n\t\t\tgoto setflags_out;\n\t\t}\n\n\t\tif (get_user(flags, (int __user *) arg)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto setflags_out;\n\t\t}\n\n\t\tflags = ext2_mask_flags(inode->i_mode, flags);\n\n\t\tmutex_lock(&inode->i_mutex);\n\t\t/* Is it quota file? Do not allow user to mess with it */\n\t\tif (IS_NOQUOTA(inode)) {\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\tret = -EPERM;\n\t\t\tgoto setflags_out;\n\t\t}\n\t\toldflags = ei->i_flags;\n\n\t\t/*\n\t\t * The IMMUTABLE and APPEND_ONLY flags can only be changed by\n\t\t * the relevant capability.\n\t\t *\n\t\t * This test looks nicer. Thanks to Pauline Middelink\n\t\t */\n\t\tif ((flags ^ oldflags) & (EXT2_APPEND_FL | EXT2_IMMUTABLE_FL)) {\n\t\t\tif (!capable(CAP_LINUX_IMMUTABLE)) {\n\t\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\t\tret = -EPERM;\n\t\t\t\tgoto setflags_out;\n\t\t\t}\n\t\t}\n\n\t\tflags = flags & EXT2_FL_USER_MODIFIABLE;\n\t\tflags |= oldflags & ~EXT2_FL_USER_MODIFIABLE;\n\t\tei->i_flags = flags;\n\n\t\text2_set_inode_flags(inode);\n\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\tmutex_unlock(&inode->i_mutex);\n\n\t\tmark_inode_dirty(inode);\nsetflags_out:\n\t\tmnt_drop_write_file(filp);\n\t\treturn ret;\n\t}\n\tcase EXT2_IOC_GETVERSION:\n\t\treturn put_user(inode->i_generation, (int __user *) arg);\n\tcase EXT2_IOC_SETVERSION: {\n\t\t__u32 generation;\n\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\tret = mnt_want_write_file(filp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (get_user(generation, (int __user *) arg)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto setversion_out;\n\t\t}\n\n\t\tmutex_lock(&inode->i_mutex);\n\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\tinode->i_generation = generation;\n\t\tmutex_unlock(&inode->i_mutex);\n\n\t\tmark_inode_dirty(inode);\nsetversion_out:\n\t\tmnt_drop_write_file(filp);\n\t\treturn ret;\n\t}\n\tcase EXT2_IOC_GETRSVSZ:\n\t\tif (test_opt(inode->i_sb, RESERVATION)\n\t\t\t&& S_ISREG(inode->i_mode)\n\t\t\t&& ei->i_block_alloc_info) {\n\t\t\trsv_window_size = ei->i_block_alloc_info->rsv_window_node.rsv_goal_size;\n\t\t\treturn put_user(rsv_window_size, (int __user *)arg);\n\t\t}\n\t\treturn -ENOTTY;\n\tcase EXT2_IOC_SETRSVSZ: {\n\n\t\tif (!test_opt(inode->i_sb, RESERVATION) ||!S_ISREG(inode->i_mode))\n\t\t\treturn -ENOTTY;\n\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EACCES;\n\n\t\tif (get_user(rsv_window_size, (int __user *)arg))\n\t\t\treturn -EFAULT;\n\n\t\tret = mnt_want_write_file(filp);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (rsv_window_size > EXT2_MAX_RESERVE_BLOCKS)\n\t\t\trsv_window_size = EXT2_MAX_RESERVE_BLOCKS;\n\n\t\t/*\n\t\t * need to allocate reservation structure for this inode\n\t\t * before set the window size\n\t\t */\n\t\t/*\n\t\t * XXX What lock should protect the rsv_goal_size?\n\t\t * Accessed in ext2_get_block only.  ext3 uses i_truncate.\n\t\t */\n\t\tmutex_lock(&ei->truncate_mutex);\n\t\tif (!ei->i_block_alloc_info)\n\t\t\text2_init_block_alloc_info(inode);\n\n\t\tif (ei->i_block_alloc_info){\n\t\t\tstruct ext2_reserve_window_node *rsv = &ei->i_block_alloc_info->rsv_window_node;\n\t\t\trsv->rsv_goal_size = rsv_window_size;\n\t\t}\n\t\tmutex_unlock(&ei->truncate_mutex);\n\t\tmnt_drop_write_file(filp);\n\t\treturn 0;\n\t}\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <asm/current.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/capability.h>",
      "#include \"ext2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "filp"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ei->truncate_mutex"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_init_block_alloc_info",
          "args": [
            "inode"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_init_block_alloc_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "410-437",
          "snippet": "void ext2_init_block_alloc_info(struct inode *inode)\n{\n\tstruct ext2_inode_info *ei = EXT2_I(inode);\n\tstruct ext2_block_alloc_info *block_i;\n\tstruct super_block *sb = inode->i_sb;\n\n\tblock_i = kmalloc(sizeof(*block_i), GFP_NOFS);\n\tif (block_i) {\n\t\tstruct ext2_reserve_window_node *rsv = &block_i->rsv_window_node;\n\n\t\trsv->rsv_start = EXT2_RESERVE_WINDOW_NOT_ALLOCATED;\n\t\trsv->rsv_end = EXT2_RESERVE_WINDOW_NOT_ALLOCATED;\n\n\t \t/*\n\t\t * if filesystem is mounted with NORESERVATION, the goal\n\t\t * reservation window size is set to zero to indicate\n\t\t * block reservation is off\n\t\t */\n\t\tif (!test_opt(sb, RESERVATION))\n\t\t\trsv->rsv_goal_size = 0;\n\t\telse\n\t\t\trsv->rsv_goal_size = EXT2_DEFAULT_RESERVE_BLOCKS;\n\t\trsv->rsv_alloc_hit = 0;\n\t\tblock_i->last_alloc_logical_block = 0;\n\t\tblock_i->last_alloc_physical_block = 0;\n\t}\n\tei->i_block_alloc_info = block_i;\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nvoid ext2_init_block_alloc_info(struct inode *inode)\n{\n\tstruct ext2_inode_info *ei = EXT2_I(inode);\n\tstruct ext2_block_alloc_info *block_i;\n\tstruct super_block *sb = inode->i_sb;\n\n\tblock_i = kmalloc(sizeof(*block_i), GFP_NOFS);\n\tif (block_i) {\n\t\tstruct ext2_reserve_window_node *rsv = &block_i->rsv_window_node;\n\n\t\trsv->rsv_start = EXT2_RESERVE_WINDOW_NOT_ALLOCATED;\n\t\trsv->rsv_end = EXT2_RESERVE_WINDOW_NOT_ALLOCATED;\n\n\t \t/*\n\t\t * if filesystem is mounted with NORESERVATION, the goal\n\t\t * reservation window size is set to zero to indicate\n\t\t * block reservation is off\n\t\t */\n\t\tif (!test_opt(sb, RESERVATION))\n\t\t\trsv->rsv_goal_size = 0;\n\t\telse\n\t\t\trsv->rsv_goal_size = EXT2_DEFAULT_RESERVE_BLOCKS;\n\t\trsv->rsv_alloc_hit = 0;\n\t\tblock_i->last_alloc_logical_block = 0;\n\t\tblock_i->last_alloc_physical_block = 0;\n\t}\n\tei->i_block_alloc_info = block_i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ei->truncate_mutex"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "filp"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "rsv_window_size",
            "(int __user *)arg"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_arg_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "399-418",
          "snippet": "static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_owner_or_capable",
          "args": [
            "inode"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "inode->i_sb",
            "RESERVATION"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "rsv_window_size",
            "(int __user *)arg"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "inode->i_sb",
            "RESERVATION"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "inode->i_generation",
            "(int __user *) arg"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_set_inode_flags",
          "args": [
            "inode"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_set_inode_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
          "lines": "1273-1291",
          "snippet": "void ext2_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = EXT2_I(inode)->i_flags;\n\n\tinode->i_flags &= ~(S_SYNC | S_APPEND | S_IMMUTABLE | S_NOATIME |\n\t\t\t\tS_DIRSYNC | S_DAX);\n\tif (flags & EXT2_SYNC_FL)\n\t\tinode->i_flags |= S_SYNC;\n\tif (flags & EXT2_APPEND_FL)\n\t\tinode->i_flags |= S_APPEND;\n\tif (flags & EXT2_IMMUTABLE_FL)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\tif (flags & EXT2_NOATIME_FL)\n\t\tinode->i_flags |= S_NOATIME;\n\tif (flags & EXT2_DIRSYNC_FL)\n\t\tinode->i_flags |= S_DIRSYNC;\n\tif (test_opt(inode->i_sb, DAX))\n\t\tinode->i_flags |= S_DAX;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"ext2.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nvoid ext2_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = EXT2_I(inode)->i_flags;\n\n\tinode->i_flags &= ~(S_SYNC | S_APPEND | S_IMMUTABLE | S_NOATIME |\n\t\t\t\tS_DIRSYNC | S_DAX);\n\tif (flags & EXT2_SYNC_FL)\n\t\tinode->i_flags |= S_SYNC;\n\tif (flags & EXT2_APPEND_FL)\n\t\tinode->i_flags |= S_APPEND;\n\tif (flags & EXT2_IMMUTABLE_FL)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\tif (flags & EXT2_NOATIME_FL)\n\t\tinode->i_flags |= S_NOATIME;\n\tif (flags & EXT2_DIRSYNC_FL)\n\t\tinode->i_flags |= S_DIRSYNC;\n\tif (test_opt(inode->i_sb, DAX))\n\t\tinode->i_flags |= S_DAX;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_NOQUOTA",
          "args": [
            "inode"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_mask_flags",
          "args": [
            "inode->i_mode",
            "flags"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_mask_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "266-274",
          "snippet": "static inline __u32 ext2_mask_flags(umode_t mode, __u32 flags)\n{\n\tif (S_ISDIR(mode))\n\t\treturn flags;\n\telse if (S_ISREG(mode))\n\t\treturn flags & EXT2_REG_FLMASK;\n\telse\n\t\treturn flags & EXT2_OTHER_FLMASK;\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT2_OTHER_FLMASK (EXT2_NODUMP_FL | EXT2_NOATIME_FL)",
            "#define EXT2_REG_FLMASK (~(EXT2_DIRSYNC_FL | EXT2_TOPDIR_FL))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\n#define EXT2_OTHER_FLMASK (EXT2_NODUMP_FL | EXT2_NOATIME_FL)\n#define EXT2_REG_FLMASK (~(EXT2_DIRSYNC_FL | EXT2_TOPDIR_FL))\n\nstatic inline __u32 ext2_mask_flags(umode_t mode, __u32 flags)\n{\n\tif (S_ISDIR(mode))\n\t\treturn flags;\n\telse if (S_ISREG(mode))\n\t\treturn flags & EXT2_REG_FLMASK;\n\telse\n\t\treturn flags & EXT2_OTHER_FLMASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "flags",
            "(int __user *) arg"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_get_inode_flags",
          "args": [
            "ei"
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_get_inode_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
          "lines": "1294-1310",
          "snippet": "void ext2_get_inode_flags(struct ext2_inode_info *ei)\n{\n\tunsigned int flags = ei->vfs_inode.i_flags;\n\n\tei->i_flags &= ~(EXT2_SYNC_FL|EXT2_APPEND_FL|\n\t\t\tEXT2_IMMUTABLE_FL|EXT2_NOATIME_FL|EXT2_DIRSYNC_FL);\n\tif (flags & S_SYNC)\n\t\tei->i_flags |= EXT2_SYNC_FL;\n\tif (flags & S_APPEND)\n\t\tei->i_flags |= EXT2_APPEND_FL;\n\tif (flags & S_IMMUTABLE)\n\t\tei->i_flags |= EXT2_IMMUTABLE_FL;\n\tif (flags & S_NOATIME)\n\t\tei->i_flags |= EXT2_NOATIME_FL;\n\tif (flags & S_DIRSYNC)\n\t\tei->i_flags |= EXT2_DIRSYNC_FL;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"ext2.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nvoid ext2_get_inode_flags(struct ext2_inode_info *ei)\n{\n\tunsigned int flags = ei->vfs_inode.i_flags;\n\n\tei->i_flags &= ~(EXT2_SYNC_FL|EXT2_APPEND_FL|\n\t\t\tEXT2_IMMUTABLE_FL|EXT2_NOATIME_FL|EXT2_DIRSYNC_FL);\n\tif (flags & S_SYNC)\n\t\tei->i_flags |= EXT2_SYNC_FL;\n\tif (flags & S_APPEND)\n\t\tei->i_flags |= EXT2_APPEND_FL;\n\tif (flags & S_IMMUTABLE)\n\t\tei->i_flags |= EXT2_IMMUTABLE_FL;\n\tif (flags & S_NOATIME)\n\t\tei->i_flags |= EXT2_NOATIME_FL;\n\tif (flags & S_DIRSYNC)\n\t\tei->i_flags |= EXT2_DIRSYNC_FL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_debug",
          "args": [
            "\"cmd = %u, arg = %lu\\n\"",
            "cmd",
            "arg"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_I",
          "args": [
            "inode"
          ],
          "line": 23
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "717-720",
          "snippet": "static inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);",
            "extern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);",
            "extern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);",
            "extern void ext2_discard_reservation (struct inode *);",
            "extern void ext2_init_block_alloc_info(struct inode *);",
            "extern int ext2_add_link (struct dentry *, struct inode *);",
            "extern int ext2_make_empty(struct inode *, struct inode *);",
            "extern int ext2_empty_dir (struct inode *);",
            "extern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);",
            "extern void ext2_free_inode (struct inode *);",
            "extern void ext2_evict_inode(struct inode *);",
            "extern void ext2_set_inode_flags(struct inode *inode);",
            "extern void ext2_get_inode_flags(struct ext2_inode_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);\nextern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);\nextern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);\nextern void ext2_discard_reservation (struct inode *);\nextern void ext2_init_block_alloc_info(struct inode *);\nextern int ext2_add_link (struct dentry *, struct inode *);\nextern int ext2_make_empty(struct inode *, struct inode *);\nextern int ext2_empty_dir (struct inode *);\nextern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);\nextern void ext2_free_inode (struct inode *);\nextern void ext2_evict_inode(struct inode *);\nextern void ext2_set_inode_flags(struct inode *inode);\nextern void ext2_get_inode_flags(struct ext2_inode_info *);\n\nstatic inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 22
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/capability.h>\n#include \"ext2.h\"\n\nlong ext2_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct ext2_inode_info *ei = EXT2_I(inode);\n\tunsigned int flags;\n\tunsigned short rsv_window_size;\n\tint ret;\n\n\text2_debug (\"cmd = %u, arg = %lu\\n\", cmd, arg);\n\n\tswitch (cmd) {\n\tcase EXT2_IOC_GETFLAGS:\n\t\text2_get_inode_flags(ei);\n\t\tflags = ei->i_flags & EXT2_FL_USER_VISIBLE;\n\t\treturn put_user(flags, (int __user *) arg);\n\tcase EXT2_IOC_SETFLAGS: {\n\t\tunsigned int oldflags;\n\n\t\tret = mnt_want_write_file(filp);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (!inode_owner_or_capable(inode)) {\n\t\t\tret = -EACCES;\n\t\t\tgoto setflags_out;\n\t\t}\n\n\t\tif (get_user(flags, (int __user *) arg)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto setflags_out;\n\t\t}\n\n\t\tflags = ext2_mask_flags(inode->i_mode, flags);\n\n\t\tmutex_lock(&inode->i_mutex);\n\t\t/* Is it quota file? Do not allow user to mess with it */\n\t\tif (IS_NOQUOTA(inode)) {\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\tret = -EPERM;\n\t\t\tgoto setflags_out;\n\t\t}\n\t\toldflags = ei->i_flags;\n\n\t\t/*\n\t\t * The IMMUTABLE and APPEND_ONLY flags can only be changed by\n\t\t * the relevant capability.\n\t\t *\n\t\t * This test looks nicer. Thanks to Pauline Middelink\n\t\t */\n\t\tif ((flags ^ oldflags) & (EXT2_APPEND_FL | EXT2_IMMUTABLE_FL)) {\n\t\t\tif (!capable(CAP_LINUX_IMMUTABLE)) {\n\t\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\t\tret = -EPERM;\n\t\t\t\tgoto setflags_out;\n\t\t\t}\n\t\t}\n\n\t\tflags = flags & EXT2_FL_USER_MODIFIABLE;\n\t\tflags |= oldflags & ~EXT2_FL_USER_MODIFIABLE;\n\t\tei->i_flags = flags;\n\n\t\text2_set_inode_flags(inode);\n\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\tmutex_unlock(&inode->i_mutex);\n\n\t\tmark_inode_dirty(inode);\nsetflags_out:\n\t\tmnt_drop_write_file(filp);\n\t\treturn ret;\n\t}\n\tcase EXT2_IOC_GETVERSION:\n\t\treturn put_user(inode->i_generation, (int __user *) arg);\n\tcase EXT2_IOC_SETVERSION: {\n\t\t__u32 generation;\n\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\tret = mnt_want_write_file(filp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (get_user(generation, (int __user *) arg)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto setversion_out;\n\t\t}\n\n\t\tmutex_lock(&inode->i_mutex);\n\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\tinode->i_generation = generation;\n\t\tmutex_unlock(&inode->i_mutex);\n\n\t\tmark_inode_dirty(inode);\nsetversion_out:\n\t\tmnt_drop_write_file(filp);\n\t\treturn ret;\n\t}\n\tcase EXT2_IOC_GETRSVSZ:\n\t\tif (test_opt(inode->i_sb, RESERVATION)\n\t\t\t&& S_ISREG(inode->i_mode)\n\t\t\t&& ei->i_block_alloc_info) {\n\t\t\trsv_window_size = ei->i_block_alloc_info->rsv_window_node.rsv_goal_size;\n\t\t\treturn put_user(rsv_window_size, (int __user *)arg);\n\t\t}\n\t\treturn -ENOTTY;\n\tcase EXT2_IOC_SETRSVSZ: {\n\n\t\tif (!test_opt(inode->i_sb, RESERVATION) ||!S_ISREG(inode->i_mode))\n\t\t\treturn -ENOTTY;\n\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EACCES;\n\n\t\tif (get_user(rsv_window_size, (int __user *)arg))\n\t\t\treturn -EFAULT;\n\n\t\tret = mnt_want_write_file(filp);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (rsv_window_size > EXT2_MAX_RESERVE_BLOCKS)\n\t\t\trsv_window_size = EXT2_MAX_RESERVE_BLOCKS;\n\n\t\t/*\n\t\t * need to allocate reservation structure for this inode\n\t\t * before set the window size\n\t\t */\n\t\t/*\n\t\t * XXX What lock should protect the rsv_goal_size?\n\t\t * Accessed in ext2_get_block only.  ext3 uses i_truncate.\n\t\t */\n\t\tmutex_lock(&ei->truncate_mutex);\n\t\tif (!ei->i_block_alloc_info)\n\t\t\text2_init_block_alloc_info(inode);\n\n\t\tif (ei->i_block_alloc_info){\n\t\t\tstruct ext2_reserve_window_node *rsv = &ei->i_block_alloc_info->rsv_window_node;\n\t\t\trsv->rsv_goal_size = rsv_window_size;\n\t\t}\n\t\tmutex_unlock(&ei->truncate_mutex);\n\t\tmnt_drop_write_file(filp);\n\t\treturn 0;\n\t}\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}"
  }
]